 [LINE] @Override [LINE] @Override [EOL] public T get() throws ConcurrentException { [EOL]     T result = object; [EOL]     if (result == null) { [EOL]         synchronized (this) { [EOL]             result = object; [EOL]             if (result == null) { [EOL]                 object = result = initialize(); [EOL]             } [EOL]         } [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] T result = object; [LINE] @Override [EOL] public T get() throws ConcurrentException { [EOL]     T result = object; [EOL]     if (result == null) { [EOL]         synchronized (this) { [EOL]             result = object; [EOL]             if (result == null) { [EOL]                 object = result = initialize(); [EOL]             } [EOL]         } [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] if (result == null) { [LINE] @Override [EOL] public T get() throws ConcurrentException { [EOL]     T result = object; [EOL]     if (result == null) { [EOL]         synchronized (this) { [EOL]             result = object; [EOL]             if (result == null) { [EOL]                 object = result = initialize(); [EOL]             } [EOL]         } [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] synchronized (this) { [LINE] @Override [EOL] public T get() throws ConcurrentException { [EOL]     T result = object; [EOL]     if (result == null) { [EOL]         synchronized (this) { [EOL]             result = object; [EOL]             if (result == null) { [EOL]                 object = result = initialize(); [EOL]             } [EOL]         } [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] result = object; [LINE] @Override [EOL] public T get() throws ConcurrentException { [EOL]     T result = object; [EOL]     if (result == null) { [EOL]         synchronized (this) { [EOL]             result = object; [EOL]             if (result == null) { [EOL]                 object = result = initialize(); [EOL]             } [EOL]         } [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] if (result == null) { [LINE] @Override [EOL] public T get() throws ConcurrentException { [EOL]     T result = object; [EOL]     if (result == null) { [EOL]         synchronized (this) { [EOL]             result = object; [EOL]             if (result == null) { [EOL]                 object = result = initialize(); [EOL]             } [EOL]         } [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] object = result = initialize(); [LINE] @Override [EOL] public T get() throws ConcurrentException { [EOL]     T result = object; [EOL]     if (result == null) { [EOL]         synchronized (this) { [EOL]             result = object; [EOL]             if (result == null) { [EOL]                 object = result = initialize(); [EOL]             } [EOL]         } [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] return result; [LINE] @Override [EOL] public T get() throws ConcurrentException { [EOL]     T result = object; [EOL]     if (result == null) { [EOL]         synchronized (this) { [EOL]             result = object; [EOL]             if (result == null) { [EOL]                 object = result = initialize(); [EOL]             } [EOL]         } [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] throw new IllegalArgumentException(String.format(message, values)); [LINE] public static <T> void inclusiveBetween(final T start, final T end, final Comparable<T> value, final String message, final Object... values) { [EOL]     if (value.compareTo(start) < 0 || value.compareTo(end) > 0) { [EOL]         throw new IllegalArgumentException(String.format(message, values)); [EOL]     } [EOL] } 
 [LINE] throw new IllegalArgumentException(String.format(DEFAULT_EXCLUSIVE_BETWEEN_EX_MESSAGE, value, start, end)); [LINE] public static <T> void exclusiveBetween(final T start, final T end, final Comparable<T> value) { [EOL]     if (value.compareTo(start) <= 0 || value.compareTo(end) >= 0) { [EOL]         throw new IllegalArgumentException(String.format(DEFAULT_EXCLUSIVE_BETWEEN_EX_MESSAGE, value, start, end)); [EOL]     } [EOL] } 
 [LINE] REGISTRY.remove(); [LINE] static void unregister(final Object lhs, final Object rhs) { [EOL]     Set<Pair<IDKey, IDKey>> registry = getRegistry(); [EOL]     if (registry != null) { [EOL]         final Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs); [EOL]         registry.remove(pair); [EOL]         synchronized (EqualsBuilder.class) { [EOL]             registry = getRegistry(); [EOL]             if (registry != null && registry.isEmpty()) { [EOL]                 REGISTRY.remove(); [EOL]             } [EOL]         } [EOL]     } [EOL] } 
 [LINE] } else if (lhs.getClass() != rhs.getClass()) { [LINE] public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] this.setEquals(false); [LINE] public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] else if (lhs instanceof long[]) { [LINE] public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] append((long[]) lhs, (long[]) rhs); [LINE] public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] } else if (lhs instanceof int[]) { [LINE] public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] append((int[]) lhs, (int[]) rhs); [LINE] public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] } else if (lhs instanceof short[]) { [LINE] public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] append((short[]) lhs, (short[]) rhs); [LINE] public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] } else if (lhs instanceof char[]) { [LINE] public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] append((char[]) lhs, (char[]) rhs); [LINE] public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] } else if (lhs instanceof byte[]) { [LINE] public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] append((byte[]) lhs, (byte[]) rhs); [LINE] public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] } else if (lhs instanceof double[]) { [LINE] public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] append((double[]) lhs, (double[]) rhs); [LINE] public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] } else if (lhs instanceof float[]) { [LINE] public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] append((float[]) lhs, (float[]) rhs); [LINE] public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] } else if (lhs instanceof boolean[]) { [LINE] public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] append((boolean[]) lhs, (boolean[]) rhs); [LINE] public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] append((Object[]) lhs, (Object[]) rhs); [LINE] public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] for (int i = 0; i < lhs.length && isEquals; ++i) { [LINE] public EqualsBuilder append(final short[] lhs, final short[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] append(lhs[i], rhs[i]); [LINE] public EqualsBuilder append(final short[] lhs, final short[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] return this; [LINE] public EqualsBuilder append(final short[] lhs, final short[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] for (int i = 0; i < lhs.length && isEquals; ++i) { [LINE] public EqualsBuilder append(final byte[] lhs, final byte[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] append(lhs[i], rhs[i]); [LINE] public EqualsBuilder append(final byte[] lhs, final byte[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] return this; [LINE] public EqualsBuilder append(final byte[] lhs, final byte[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] for (int i = 0; i < lhs.length && isEquals; ++i) { [LINE] public EqualsBuilder append(final double[] lhs, final double[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] append(lhs[i], rhs[i]); [LINE] public EqualsBuilder append(final double[] lhs, final double[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] return this; [LINE] public EqualsBuilder append(final double[] lhs, final double[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] for (int i = 0; i < lhs.length && isEquals; ++i) { [LINE] public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] append(lhs[i], rhs[i]); [LINE] public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] return this; [LINE] public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] end = chars.length; [LINE] public static String random(int count, int start, int end, final boolean letters, final boolean numbers, final char[] chars, final Random random) { [EOL]     if (count == 0) { [EOL]         return ""; [EOL]     } else if (count < 0) { [EOL]         throw new IllegalArgumentException("Requested random string length " + count + " is less than 0."); [EOL]     } [EOL]     if (chars != null && chars.length == 0) { [EOL]         throw new IllegalArgumentException("The chars array must not be empty"); [EOL]     } [EOL]     if (start == 0 && end == 0) { [EOL]         if (chars != null) { [EOL]             end = chars.length; [EOL]         } else { [EOL]             if (!letters && !numbers) { [EOL]                 end = Integer.MAX_VALUE; [EOL]             } else { [EOL]                 end = 'z' + 1; [EOL]                 start = ' '; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (end <= start) { [EOL]             throw new IllegalArgumentException("Parameter end (" + end + ") must be greater than start (" + start + ")"); [EOL]         } [EOL]     } [EOL]     final char[] buffer = new char[count]; [EOL]     final int gap = end - start; [EOL]     while (count-- != 0) { [EOL]         char ch; [EOL]         if (chars == null) { [EOL]             ch = (char) (random.nextInt(gap) + start); [EOL]         } else { [EOL]             ch = chars[random.nextInt(gap) + start]; [EOL]         } [EOL]         if (letters && Character.isLetter(ch) || numbers && Character.isDigit(ch) || !letters && !numbers) { [EOL]             if (ch >= 56320 && ch <= 57343) { [EOL]                 if (count == 0) { [EOL]                     count++; [EOL]                 } else { [EOL]                     buffer[count] = ch; [EOL]                     count--; [EOL]                     buffer[count] = (char) (55296 + random.nextInt(128)); [EOL]                 } [EOL]             } else if (ch >= 55296 && ch <= 56191) { [EOL]                 if (count == 0) { [EOL]                     count++; [EOL]                 } else { [EOL]                     buffer[count] = (char) (56320 + random.nextInt(128)); [EOL]                     count--; [EOL]                     buffer[count] = ch; [EOL]                 } [EOL]             } else if (ch >= 56192 && ch <= 56319) { [EOL]                 count++; [EOL]             } else { [EOL]                 buffer[count] = ch; [EOL]             } [EOL]         } else { [EOL]             count++; [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] } 
 [LINE] if(count == 0) { [LINE] public static String random(int count, int start, int end, final boolean letters, final boolean numbers, final char[] chars, final Random random) { [EOL]     if (count == 0) { [EOL]         return ""; [EOL]     } else if (count < 0) { [EOL]         throw new IllegalArgumentException("Requested random string length " + count + " is less than 0."); [EOL]     } [EOL]     if (chars != null && chars.length == 0) { [EOL]         throw new IllegalArgumentException("The chars array must not be empty"); [EOL]     } [EOL]     if (start == 0 && end == 0) { [EOL]         if (chars != null) { [EOL]             end = chars.length; [EOL]         } else { [EOL]             if (!letters && !numbers) { [EOL]                 end = Integer.MAX_VALUE; [EOL]             } else { [EOL]                 end = 'z' + 1; [EOL]                 start = ' '; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (end <= start) { [EOL]             throw new IllegalArgumentException("Parameter end (" + end + ") must be greater than start (" + start + ")"); [EOL]         } [EOL]     } [EOL]     final char[] buffer = new char[count]; [EOL]     final int gap = end - start; [EOL]     while (count-- != 0) { [EOL]         char ch; [EOL]         if (chars == null) { [EOL]             ch = (char) (random.nextInt(gap) + start); [EOL]         } else { [EOL]             ch = chars[random.nextInt(gap) + start]; [EOL]         } [EOL]         if (letters && Character.isLetter(ch) || numbers && Character.isDigit(ch) || !letters && !numbers) { [EOL]             if (ch >= 56320 && ch <= 57343) { [EOL]                 if (count == 0) { [EOL]                     count++; [EOL]                 } else { [EOL]                     buffer[count] = ch; [EOL]                     count--; [EOL]                     buffer[count] = (char) (55296 + random.nextInt(128)); [EOL]                 } [EOL]             } else if (ch >= 55296 && ch <= 56191) { [EOL]                 if (count == 0) { [EOL]                     count++; [EOL]                 } else { [EOL]                     buffer[count] = (char) (56320 + random.nextInt(128)); [EOL]                     count--; [EOL]                     buffer[count] = ch; [EOL]                 } [EOL]             } else if (ch >= 56192 && ch <= 56319) { [EOL]                 count++; [EOL]             } else { [EOL]                 buffer[count] = ch; [EOL]             } [EOL]         } else { [EOL]             count++; [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] } 
 [LINE] buffer[count] = ch; [LINE] public static String random(int count, int start, int end, final boolean letters, final boolean numbers, final char[] chars, final Random random) { [EOL]     if (count == 0) { [EOL]         return ""; [EOL]     } else if (count < 0) { [EOL]         throw new IllegalArgumentException("Requested random string length " + count + " is less than 0."); [EOL]     } [EOL]     if (chars != null && chars.length == 0) { [EOL]         throw new IllegalArgumentException("The chars array must not be empty"); [EOL]     } [EOL]     if (start == 0 && end == 0) { [EOL]         if (chars != null) { [EOL]             end = chars.length; [EOL]         } else { [EOL]             if (!letters && !numbers) { [EOL]                 end = Integer.MAX_VALUE; [EOL]             } else { [EOL]                 end = 'z' + 1; [EOL]                 start = ' '; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (end <= start) { [EOL]             throw new IllegalArgumentException("Parameter end (" + end + ") must be greater than start (" + start + ")"); [EOL]         } [EOL]     } [EOL]     final char[] buffer = new char[count]; [EOL]     final int gap = end - start; [EOL]     while (count-- != 0) { [EOL]         char ch; [EOL]         if (chars == null) { [EOL]             ch = (char) (random.nextInt(gap) + start); [EOL]         } else { [EOL]             ch = chars[random.nextInt(gap) + start]; [EOL]         } [EOL]         if (letters && Character.isLetter(ch) || numbers && Character.isDigit(ch) || !letters && !numbers) { [EOL]             if (ch >= 56320 && ch <= 57343) { [EOL]                 if (count == 0) { [EOL]                     count++; [EOL]                 } else { [EOL]                     buffer[count] = ch; [EOL]                     count--; [EOL]                     buffer[count] = (char) (55296 + random.nextInt(128)); [EOL]                 } [EOL]             } else if (ch >= 55296 && ch <= 56191) { [EOL]                 if (count == 0) { [EOL]                     count++; [EOL]                 } else { [EOL]                     buffer[count] = (char) (56320 + random.nextInt(128)); [EOL]                     count--; [EOL]                     buffer[count] = ch; [EOL]                 } [EOL]             } else if (ch >= 56192 && ch <= 56319) { [EOL]                 count++; [EOL]             } else { [EOL]                 buffer[count] = ch; [EOL]             } [EOL]         } else { [EOL]             count++; [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] } 
 [LINE] count--; [LINE] public static String random(int count, int start, int end, final boolean letters, final boolean numbers, final char[] chars, final Random random) { [EOL]     if (count == 0) { [EOL]         return ""; [EOL]     } else if (count < 0) { [EOL]         throw new IllegalArgumentException("Requested random string length " + count + " is less than 0."); [EOL]     } [EOL]     if (chars != null && chars.length == 0) { [EOL]         throw new IllegalArgumentException("The chars array must not be empty"); [EOL]     } [EOL]     if (start == 0 && end == 0) { [EOL]         if (chars != null) { [EOL]             end = chars.length; [EOL]         } else { [EOL]             if (!letters && !numbers) { [EOL]                 end = Integer.MAX_VALUE; [EOL]             } else { [EOL]                 end = 'z' + 1; [EOL]                 start = ' '; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (end <= start) { [EOL]             throw new IllegalArgumentException("Parameter end (" + end + ") must be greater than start (" + start + ")"); [EOL]         } [EOL]     } [EOL]     final char[] buffer = new char[count]; [EOL]     final int gap = end - start; [EOL]     while (count-- != 0) { [EOL]         char ch; [EOL]         if (chars == null) { [EOL]             ch = (char) (random.nextInt(gap) + start); [EOL]         } else { [EOL]             ch = chars[random.nextInt(gap) + start]; [EOL]         } [EOL]         if (letters && Character.isLetter(ch) || numbers && Character.isDigit(ch) || !letters && !numbers) { [EOL]             if (ch >= 56320 && ch <= 57343) { [EOL]                 if (count == 0) { [EOL]                     count++; [EOL]                 } else { [EOL]                     buffer[count] = ch; [EOL]                     count--; [EOL]                     buffer[count] = (char) (55296 + random.nextInt(128)); [EOL]                 } [EOL]             } else if (ch >= 55296 && ch <= 56191) { [EOL]                 if (count == 0) { [EOL]                     count++; [EOL]                 } else { [EOL]                     buffer[count] = (char) (56320 + random.nextInt(128)); [EOL]                     count--; [EOL]                     buffer[count] = ch; [EOL]                 } [EOL]             } else if (ch >= 56192 && ch <= 56319) { [EOL]                 count++; [EOL]             } else { [EOL]                 buffer[count] = ch; [EOL]             } [EOL]         } else { [EOL]             count++; [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] } 
 [LINE] buffer[count] = (char) (55296 + random.nextInt(128)); [LINE] public static String random(int count, int start, int end, final boolean letters, final boolean numbers, final char[] chars, final Random random) { [EOL]     if (count == 0) { [EOL]         return ""; [EOL]     } else if (count < 0) { [EOL]         throw new IllegalArgumentException("Requested random string length " + count + " is less than 0."); [EOL]     } [EOL]     if (chars != null && chars.length == 0) { [EOL]         throw new IllegalArgumentException("The chars array must not be empty"); [EOL]     } [EOL]     if (start == 0 && end == 0) { [EOL]         if (chars != null) { [EOL]             end = chars.length; [EOL]         } else { [EOL]             if (!letters && !numbers) { [EOL]                 end = Integer.MAX_VALUE; [EOL]             } else { [EOL]                 end = 'z' + 1; [EOL]                 start = ' '; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (end <= start) { [EOL]             throw new IllegalArgumentException("Parameter end (" + end + ") must be greater than start (" + start + ")"); [EOL]         } [EOL]     } [EOL]     final char[] buffer = new char[count]; [EOL]     final int gap = end - start; [EOL]     while (count-- != 0) { [EOL]         char ch; [EOL]         if (chars == null) { [EOL]             ch = (char) (random.nextInt(gap) + start); [EOL]         } else { [EOL]             ch = chars[random.nextInt(gap) + start]; [EOL]         } [EOL]         if (letters && Character.isLetter(ch) || numbers && Character.isDigit(ch) || !letters && !numbers) { [EOL]             if (ch >= 56320 && ch <= 57343) { [EOL]                 if (count == 0) { [EOL]                     count++; [EOL]                 } else { [EOL]                     buffer[count] = ch; [EOL]                     count--; [EOL]                     buffer[count] = (char) (55296 + random.nextInt(128)); [EOL]                 } [EOL]             } else if (ch >= 55296 && ch <= 56191) { [EOL]                 if (count == 0) { [EOL]                     count++; [EOL]                 } else { [EOL]                     buffer[count] = (char) (56320 + random.nextInt(128)); [EOL]                     count--; [EOL]                     buffer[count] = ch; [EOL]                 } [EOL]             } else if (ch >= 56192 && ch <= 56319) { [EOL]                 count++; [EOL]             } else { [EOL]                 buffer[count] = ch; [EOL]             } [EOL]         } else { [EOL]             count++; [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] } 
 [LINE] if(count == 0) { [LINE] public static String random(int count, int start, int end, final boolean letters, final boolean numbers, final char[] chars, final Random random) { [EOL]     if (count == 0) { [EOL]         return ""; [EOL]     } else if (count < 0) { [EOL]         throw new IllegalArgumentException("Requested random string length " + count + " is less than 0."); [EOL]     } [EOL]     if (chars != null && chars.length == 0) { [EOL]         throw new IllegalArgumentException("The chars array must not be empty"); [EOL]     } [EOL]     if (start == 0 && end == 0) { [EOL]         if (chars != null) { [EOL]             end = chars.length; [EOL]         } else { [EOL]             if (!letters && !numbers) { [EOL]                 end = Integer.MAX_VALUE; [EOL]             } else { [EOL]                 end = 'z' + 1; [EOL]                 start = ' '; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (end <= start) { [EOL]             throw new IllegalArgumentException("Parameter end (" + end + ") must be greater than start (" + start + ")"); [EOL]         } [EOL]     } [EOL]     final char[] buffer = new char[count]; [EOL]     final int gap = end - start; [EOL]     while (count-- != 0) { [EOL]         char ch; [EOL]         if (chars == null) { [EOL]             ch = (char) (random.nextInt(gap) + start); [EOL]         } else { [EOL]             ch = chars[random.nextInt(gap) + start]; [EOL]         } [EOL]         if (letters && Character.isLetter(ch) || numbers && Character.isDigit(ch) || !letters && !numbers) { [EOL]             if (ch >= 56320 && ch <= 57343) { [EOL]                 if (count == 0) { [EOL]                     count++; [EOL]                 } else { [EOL]                     buffer[count] = ch; [EOL]                     count--; [EOL]                     buffer[count] = (char) (55296 + random.nextInt(128)); [EOL]                 } [EOL]             } else if (ch >= 55296 && ch <= 56191) { [EOL]                 if (count == 0) { [EOL]                     count++; [EOL]                 } else { [EOL]                     buffer[count] = (char) (56320 + random.nextInt(128)); [EOL]                     count--; [EOL]                     buffer[count] = ch; [EOL]                 } [EOL]             } else if (ch >= 56192 && ch <= 56319) { [EOL]                 count++; [EOL]             } else { [EOL]                 buffer[count] = ch; [EOL]             } [EOL]         } else { [EOL]             count++; [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] } 
 [LINE] buffer[count] = (char) (56320 + random.nextInt(128)); [LINE] public static String random(int count, int start, int end, final boolean letters, final boolean numbers, final char[] chars, final Random random) { [EOL]     if (count == 0) { [EOL]         return ""; [EOL]     } else if (count < 0) { [EOL]         throw new IllegalArgumentException("Requested random string length " + count + " is less than 0."); [EOL]     } [EOL]     if (chars != null && chars.length == 0) { [EOL]         throw new IllegalArgumentException("The chars array must not be empty"); [EOL]     } [EOL]     if (start == 0 && end == 0) { [EOL]         if (chars != null) { [EOL]             end = chars.length; [EOL]         } else { [EOL]             if (!letters && !numbers) { [EOL]                 end = Integer.MAX_VALUE; [EOL]             } else { [EOL]                 end = 'z' + 1; [EOL]                 start = ' '; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (end <= start) { [EOL]             throw new IllegalArgumentException("Parameter end (" + end + ") must be greater than start (" + start + ")"); [EOL]         } [EOL]     } [EOL]     final char[] buffer = new char[count]; [EOL]     final int gap = end - start; [EOL]     while (count-- != 0) { [EOL]         char ch; [EOL]         if (chars == null) { [EOL]             ch = (char) (random.nextInt(gap) + start); [EOL]         } else { [EOL]             ch = chars[random.nextInt(gap) + start]; [EOL]         } [EOL]         if (letters && Character.isLetter(ch) || numbers && Character.isDigit(ch) || !letters && !numbers) { [EOL]             if (ch >= 56320 && ch <= 57343) { [EOL]                 if (count == 0) { [EOL]                     count++; [EOL]                 } else { [EOL]                     buffer[count] = ch; [EOL]                     count--; [EOL]                     buffer[count] = (char) (55296 + random.nextInt(128)); [EOL]                 } [EOL]             } else if (ch >= 55296 && ch <= 56191) { [EOL]                 if (count == 0) { [EOL]                     count++; [EOL]                 } else { [EOL]                     buffer[count] = (char) (56320 + random.nextInt(128)); [EOL]                     count--; [EOL]                     buffer[count] = ch; [EOL]                 } [EOL]             } else if (ch >= 56192 && ch <= 56319) { [EOL]                 count++; [EOL]             } else { [EOL]                 buffer[count] = ch; [EOL]             } [EOL]         } else { [EOL]             count++; [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] } 
 [LINE] count--; [LINE] public static String random(int count, int start, int end, final boolean letters, final boolean numbers, final char[] chars, final Random random) { [EOL]     if (count == 0) { [EOL]         return ""; [EOL]     } else if (count < 0) { [EOL]         throw new IllegalArgumentException("Requested random string length " + count + " is less than 0."); [EOL]     } [EOL]     if (chars != null && chars.length == 0) { [EOL]         throw new IllegalArgumentException("The chars array must not be empty"); [EOL]     } [EOL]     if (start == 0 && end == 0) { [EOL]         if (chars != null) { [EOL]             end = chars.length; [EOL]         } else { [EOL]             if (!letters && !numbers) { [EOL]                 end = Integer.MAX_VALUE; [EOL]             } else { [EOL]                 end = 'z' + 1; [EOL]                 start = ' '; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (end <= start) { [EOL]             throw new IllegalArgumentException("Parameter end (" + end + ") must be greater than start (" + start + ")"); [EOL]         } [EOL]     } [EOL]     final char[] buffer = new char[count]; [EOL]     final int gap = end - start; [EOL]     while (count-- != 0) { [EOL]         char ch; [EOL]         if (chars == null) { [EOL]             ch = (char) (random.nextInt(gap) + start); [EOL]         } else { [EOL]             ch = chars[random.nextInt(gap) + start]; [EOL]         } [EOL]         if (letters && Character.isLetter(ch) || numbers && Character.isDigit(ch) || !letters && !numbers) { [EOL]             if (ch >= 56320 && ch <= 57343) { [EOL]                 if (count == 0) { [EOL]                     count++; [EOL]                 } else { [EOL]                     buffer[count] = ch; [EOL]                     count--; [EOL]                     buffer[count] = (char) (55296 + random.nextInt(128)); [EOL]                 } [EOL]             } else if (ch >= 55296 && ch <= 56191) { [EOL]                 if (count == 0) { [EOL]                     count++; [EOL]                 } else { [EOL]                     buffer[count] = (char) (56320 + random.nextInt(128)); [EOL]                     count--; [EOL]                     buffer[count] = ch; [EOL]                 } [EOL]             } else if (ch >= 56192 && ch <= 56319) { [EOL]                 count++; [EOL]             } else { [EOL]                 buffer[count] = ch; [EOL]             } [EOL]         } else { [EOL]             count++; [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] } 
 [LINE] buffer[count] = ch; [LINE] public static String random(int count, int start, int end, final boolean letters, final boolean numbers, final char[] chars, final Random random) { [EOL]     if (count == 0) { [EOL]         return ""; [EOL]     } else if (count < 0) { [EOL]         throw new IllegalArgumentException("Requested random string length " + count + " is less than 0."); [EOL]     } [EOL]     if (chars != null && chars.length == 0) { [EOL]         throw new IllegalArgumentException("The chars array must not be empty"); [EOL]     } [EOL]     if (start == 0 && end == 0) { [EOL]         if (chars != null) { [EOL]             end = chars.length; [EOL]         } else { [EOL]             if (!letters && !numbers) { [EOL]                 end = Integer.MAX_VALUE; [EOL]             } else { [EOL]                 end = 'z' + 1; [EOL]                 start = ' '; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (end <= start) { [EOL]             throw new IllegalArgumentException("Parameter end (" + end + ") must be greater than start (" + start + ")"); [EOL]         } [EOL]     } [EOL]     final char[] buffer = new char[count]; [EOL]     final int gap = end - start; [EOL]     while (count-- != 0) { [EOL]         char ch; [EOL]         if (chars == null) { [EOL]             ch = (char) (random.nextInt(gap) + start); [EOL]         } else { [EOL]             ch = chars[random.nextInt(gap) + start]; [EOL]         } [EOL]         if (letters && Character.isLetter(ch) || numbers && Character.isDigit(ch) || !letters && !numbers) { [EOL]             if (ch >= 56320 && ch <= 57343) { [EOL]                 if (count == 0) { [EOL]                     count++; [EOL]                 } else { [EOL]                     buffer[count] = ch; [EOL]                     count--; [EOL]                     buffer[count] = (char) (55296 + random.nextInt(128)); [EOL]                 } [EOL]             } else if (ch >= 55296 && ch <= 56191) { [EOL]                 if (count == 0) { [EOL]                     count++; [EOL]                 } else { [EOL]                     buffer[count] = (char) (56320 + random.nextInt(128)); [EOL]                     count--; [EOL]                     buffer[count] = ch; [EOL]                 } [EOL]             } else if (ch >= 56192 && ch <= 56319) { [EOL]                 count++; [EOL]             } else { [EOL]                 buffer[count] = ch; [EOL]             } [EOL]         } else { [EOL]             count++; [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] } 
 [LINE] count++; [LINE] public static String random(int count, int start, int end, final boolean letters, final boolean numbers, final char[] chars, final Random random) { [EOL]     if (count == 0) { [EOL]         return ""; [EOL]     } else if (count < 0) { [EOL]         throw new IllegalArgumentException("Requested random string length " + count + " is less than 0."); [EOL]     } [EOL]     if (chars != null && chars.length == 0) { [EOL]         throw new IllegalArgumentException("The chars array must not be empty"); [EOL]     } [EOL]     if (start == 0 && end == 0) { [EOL]         if (chars != null) { [EOL]             end = chars.length; [EOL]         } else { [EOL]             if (!letters && !numbers) { [EOL]                 end = Integer.MAX_VALUE; [EOL]             } else { [EOL]                 end = 'z' + 1; [EOL]                 start = ' '; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (end <= start) { [EOL]             throw new IllegalArgumentException("Parameter end (" + end + ") must be greater than start (" + start + ")"); [EOL]         } [EOL]     } [EOL]     final char[] buffer = new char[count]; [EOL]     final int gap = end - start; [EOL]     while (count-- != 0) { [EOL]         char ch; [EOL]         if (chars == null) { [EOL]             ch = (char) (random.nextInt(gap) + start); [EOL]         } else { [EOL]             ch = chars[random.nextInt(gap) + start]; [EOL]         } [EOL]         if (letters && Character.isLetter(ch) || numbers && Character.isDigit(ch) || !letters && !numbers) { [EOL]             if (ch >= 56320 && ch <= 57343) { [EOL]                 if (count == 0) { [EOL]                     count++; [EOL]                 } else { [EOL]                     buffer[count] = ch; [EOL]                     count--; [EOL]                     buffer[count] = (char) (55296 + random.nextInt(128)); [EOL]                 } [EOL]             } else if (ch >= 55296 && ch <= 56191) { [EOL]                 if (count == 0) { [EOL]                     count++; [EOL]                 } else { [EOL]                     buffer[count] = (char) (56320 + random.nextInt(128)); [EOL]                     count--; [EOL]                     buffer[count] = ch; [EOL]                 } [EOL]             } else if (ch >= 56192 && ch <= 56319) { [EOL]                 count++; [EOL]             } else { [EOL]                 buffer[count] = ch; [EOL]             } [EOL]         } else { [EOL]             count++; [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] } 
 [LINE] return random(count, 0, 0, false, false, null, RANDOM); [LINE] public static String random(final int count, final String chars) { [EOL]     if (chars == null) { [EOL]         return random(count, 0, 0, false, false, null, RANDOM); [EOL]     } [EOL]     return random(count, chars.toCharArray()); [EOL] } 
 [LINE] removeLastFieldSeparator(buffer); [LINE] public void appendToString(final StringBuffer buffer, final String toString) { [EOL]     if (toString != null) { [EOL]         final int pos1 = toString.indexOf(contentStart) + contentStart.length(); [EOL]         final int pos2 = toString.lastIndexOf(contentEnd); [EOL]         if (pos1 != pos2 && pos1 >= 0 && pos2 >= 0) { [EOL]             final String data = toString.substring(pos1, pos2); [EOL]             if (fieldSeparatorAtStart) { [EOL]                 removeLastFieldSeparator(buffer); [EOL]             } [EOL]             buffer.append(data); [EOL]             appendFieldSeparator(buffer); [EOL]         } [EOL]     } [EOL] } 
 [LINE] if (detail) { [LINE] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail) { [EOL]     if (isRegistered(value) && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) { [EOL]         appendCyclicObject(buffer, fieldName, value); [EOL]         return; [EOL]     } [EOL]     register(value); [EOL]     try { [EOL]         if (value instanceof Collection<?>) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Collection<?>) value); [EOL]             } else { [EOL]                 appendSummarySize(buffer, fieldName, ((Collection<?>) value).size()); [EOL]             } [EOL]         } else if (value instanceof Map<?, ?>) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Map<?, ?>) value); [EOL]             } else { [EOL]                 appendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size()); [EOL]             } [EOL]         } else if (value instanceof long[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (long[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (long[]) value); [EOL]             } [EOL]         } else if (value instanceof int[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (int[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (int[]) value); [EOL]             } [EOL]         } else if (value instanceof short[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (short[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (short[]) value); [EOL]             } [EOL]         } else if (value instanceof byte[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (byte[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (byte[]) value); [EOL]             } [EOL]         } else if (value instanceof char[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (char[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (char[]) value); [EOL]             } [EOL]         } else if (value instanceof double[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (double[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (double[]) value); [EOL]             } [EOL]         } else if (value instanceof float[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (float[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (float[]) value); [EOL]             } [EOL]         } else if (value instanceof boolean[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (boolean[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (boolean[]) value); [EOL]             } [EOL]         } else if (value.getClass().isArray()) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Object[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (Object[]) value); [EOL]             } [EOL]         } else { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, value); [EOL]             } [EOL]         } [EOL]     } finally { [EOL]         unregister(value); [EOL]     } [EOL] } 
 [LINE] appendDetail(buffer, fieldName, (Map<?, ?>) value); [LINE] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail) { [EOL]     if (isRegistered(value) && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) { [EOL]         appendCyclicObject(buffer, fieldName, value); [EOL]         return; [EOL]     } [EOL]     register(value); [EOL]     try { [EOL]         if (value instanceof Collection<?>) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Collection<?>) value); [EOL]             } else { [EOL]                 appendSummarySize(buffer, fieldName, ((Collection<?>) value).size()); [EOL]             } [EOL]         } else if (value instanceof Map<?, ?>) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Map<?, ?>) value); [EOL]             } else { [EOL]                 appendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size()); [EOL]             } [EOL]         } else if (value instanceof long[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (long[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (long[]) value); [EOL]             } [EOL]         } else if (value instanceof int[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (int[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (int[]) value); [EOL]             } [EOL]         } else if (value instanceof short[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (short[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (short[]) value); [EOL]             } [EOL]         } else if (value instanceof byte[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (byte[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (byte[]) value); [EOL]             } [EOL]         } else if (value instanceof char[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (char[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (char[]) value); [EOL]             } [EOL]         } else if (value instanceof double[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (double[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (double[]) value); [EOL]             } [EOL]         } else if (value instanceof float[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (float[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (float[]) value); [EOL]             } [EOL]         } else if (value instanceof boolean[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (boolean[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (boolean[]) value); [EOL]             } [EOL]         } else if (value.getClass().isArray()) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Object[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (Object[]) value); [EOL]             } [EOL]         } else { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, value); [EOL]             } [EOL]         } [EOL]     } finally { [EOL]         unregister(value); [EOL]     } [EOL] } 
 [LINE] appendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size()); [LINE] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail) { [EOL]     if (isRegistered(value) && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) { [EOL]         appendCyclicObject(buffer, fieldName, value); [EOL]         return; [EOL]     } [EOL]     register(value); [EOL]     try { [EOL]         if (value instanceof Collection<?>) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Collection<?>) value); [EOL]             } else { [EOL]                 appendSummarySize(buffer, fieldName, ((Collection<?>) value).size()); [EOL]             } [EOL]         } else if (value instanceof Map<?, ?>) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Map<?, ?>) value); [EOL]             } else { [EOL]                 appendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size()); [EOL]             } [EOL]         } else if (value instanceof long[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (long[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (long[]) value); [EOL]             } [EOL]         } else if (value instanceof int[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (int[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (int[]) value); [EOL]             } [EOL]         } else if (value instanceof short[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (short[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (short[]) value); [EOL]             } [EOL]         } else if (value instanceof byte[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (byte[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (byte[]) value); [EOL]             } [EOL]         } else if (value instanceof char[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (char[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (char[]) value); [EOL]             } [EOL]         } else if (value instanceof double[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (double[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (double[]) value); [EOL]             } [EOL]         } else if (value instanceof float[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (float[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (float[]) value); [EOL]             } [EOL]         } else if (value instanceof boolean[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (boolean[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (boolean[]) value); [EOL]             } [EOL]         } else if (value.getClass().isArray()) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Object[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (Object[]) value); [EOL]             } [EOL]         } else { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, value); [EOL]             } [EOL]         } [EOL]     } finally { [EOL]         unregister(value); [EOL]     } [EOL] } 
 [LINE] if (detail) { [LINE] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail) { [EOL]     if (isRegistered(value) && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) { [EOL]         appendCyclicObject(buffer, fieldName, value); [EOL]         return; [EOL]     } [EOL]     register(value); [EOL]     try { [EOL]         if (value instanceof Collection<?>) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Collection<?>) value); [EOL]             } else { [EOL]                 appendSummarySize(buffer, fieldName, ((Collection<?>) value).size()); [EOL]             } [EOL]         } else if (value instanceof Map<?, ?>) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Map<?, ?>) value); [EOL]             } else { [EOL]                 appendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size()); [EOL]             } [EOL]         } else if (value instanceof long[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (long[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (long[]) value); [EOL]             } [EOL]         } else if (value instanceof int[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (int[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (int[]) value); [EOL]             } [EOL]         } else if (value instanceof short[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (short[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (short[]) value); [EOL]             } [EOL]         } else if (value instanceof byte[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (byte[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (byte[]) value); [EOL]             } [EOL]         } else if (value instanceof char[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (char[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (char[]) value); [EOL]             } [EOL]         } else if (value instanceof double[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (double[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (double[]) value); [EOL]             } [EOL]         } else if (value instanceof float[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (float[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (float[]) value); [EOL]             } [EOL]         } else if (value instanceof boolean[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (boolean[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (boolean[]) value); [EOL]             } [EOL]         } else if (value.getClass().isArray()) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Object[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (Object[]) value); [EOL]             } [EOL]         } else { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, value); [EOL]             } [EOL]         } [EOL]     } finally { [EOL]         unregister(value); [EOL]     } [EOL] } 
 [LINE] appendDetail(buffer, fieldName, (long[]) value); [LINE] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail) { [EOL]     if (isRegistered(value) && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) { [EOL]         appendCyclicObject(buffer, fieldName, value); [EOL]         return; [EOL]     } [EOL]     register(value); [EOL]     try { [EOL]         if (value instanceof Collection<?>) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Collection<?>) value); [EOL]             } else { [EOL]                 appendSummarySize(buffer, fieldName, ((Collection<?>) value).size()); [EOL]             } [EOL]         } else if (value instanceof Map<?, ?>) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Map<?, ?>) value); [EOL]             } else { [EOL]                 appendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size()); [EOL]             } [EOL]         } else if (value instanceof long[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (long[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (long[]) value); [EOL]             } [EOL]         } else if (value instanceof int[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (int[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (int[]) value); [EOL]             } [EOL]         } else if (value instanceof short[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (short[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (short[]) value); [EOL]             } [EOL]         } else if (value instanceof byte[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (byte[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (byte[]) value); [EOL]             } [EOL]         } else if (value instanceof char[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (char[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (char[]) value); [EOL]             } [EOL]         } else if (value instanceof double[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (double[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (double[]) value); [EOL]             } [EOL]         } else if (value instanceof float[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (float[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (float[]) value); [EOL]             } [EOL]         } else if (value instanceof boolean[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (boolean[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (boolean[]) value); [EOL]             } [EOL]         } else if (value.getClass().isArray()) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Object[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (Object[]) value); [EOL]             } [EOL]         } else { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, value); [EOL]             } [EOL]         } [EOL]     } finally { [EOL]         unregister(value); [EOL]     } [EOL] } 
 [LINE] if (detail) { [LINE] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail) { [EOL]     if (isRegistered(value) && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) { [EOL]         appendCyclicObject(buffer, fieldName, value); [EOL]         return; [EOL]     } [EOL]     register(value); [EOL]     try { [EOL]         if (value instanceof Collection<?>) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Collection<?>) value); [EOL]             } else { [EOL]                 appendSummarySize(buffer, fieldName, ((Collection<?>) value).size()); [EOL]             } [EOL]         } else if (value instanceof Map<?, ?>) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Map<?, ?>) value); [EOL]             } else { [EOL]                 appendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size()); [EOL]             } [EOL]         } else if (value instanceof long[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (long[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (long[]) value); [EOL]             } [EOL]         } else if (value instanceof int[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (int[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (int[]) value); [EOL]             } [EOL]         } else if (value instanceof short[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (short[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (short[]) value); [EOL]             } [EOL]         } else if (value instanceof byte[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (byte[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (byte[]) value); [EOL]             } [EOL]         } else if (value instanceof char[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (char[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (char[]) value); [EOL]             } [EOL]         } else if (value instanceof double[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (double[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (double[]) value); [EOL]             } [EOL]         } else if (value instanceof float[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (float[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (float[]) value); [EOL]             } [EOL]         } else if (value instanceof boolean[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (boolean[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (boolean[]) value); [EOL]             } [EOL]         } else if (value.getClass().isArray()) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Object[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (Object[]) value); [EOL]             } [EOL]         } else { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, value); [EOL]             } [EOL]         } [EOL]     } finally { [EOL]         unregister(value); [EOL]     } [EOL] } 
 [LINE] appendDetail(buffer, fieldName, (int[]) value); [LINE] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail) { [EOL]     if (isRegistered(value) && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) { [EOL]         appendCyclicObject(buffer, fieldName, value); [EOL]         return; [EOL]     } [EOL]     register(value); [EOL]     try { [EOL]         if (value instanceof Collection<?>) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Collection<?>) value); [EOL]             } else { [EOL]                 appendSummarySize(buffer, fieldName, ((Collection<?>) value).size()); [EOL]             } [EOL]         } else if (value instanceof Map<?, ?>) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Map<?, ?>) value); [EOL]             } else { [EOL]                 appendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size()); [EOL]             } [EOL]         } else if (value instanceof long[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (long[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (long[]) value); [EOL]             } [EOL]         } else if (value instanceof int[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (int[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (int[]) value); [EOL]             } [EOL]         } else if (value instanceof short[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (short[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (short[]) value); [EOL]             } [EOL]         } else if (value instanceof byte[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (byte[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (byte[]) value); [EOL]             } [EOL]         } else if (value instanceof char[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (char[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (char[]) value); [EOL]             } [EOL]         } else if (value instanceof double[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (double[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (double[]) value); [EOL]             } [EOL]         } else if (value instanceof float[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (float[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (float[]) value); [EOL]             } [EOL]         } else if (value instanceof boolean[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (boolean[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (boolean[]) value); [EOL]             } [EOL]         } else if (value.getClass().isArray()) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Object[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (Object[]) value); [EOL]             } [EOL]         } else { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, value); [EOL]             } [EOL]         } [EOL]     } finally { [EOL]         unregister(value); [EOL]     } [EOL] } 
 [LINE] if (detail) { [LINE] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail) { [EOL]     if (isRegistered(value) && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) { [EOL]         appendCyclicObject(buffer, fieldName, value); [EOL]         return; [EOL]     } [EOL]     register(value); [EOL]     try { [EOL]         if (value instanceof Collection<?>) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Collection<?>) value); [EOL]             } else { [EOL]                 appendSummarySize(buffer, fieldName, ((Collection<?>) value).size()); [EOL]             } [EOL]         } else if (value instanceof Map<?, ?>) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Map<?, ?>) value); [EOL]             } else { [EOL]                 appendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size()); [EOL]             } [EOL]         } else if (value instanceof long[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (long[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (long[]) value); [EOL]             } [EOL]         } else if (value instanceof int[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (int[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (int[]) value); [EOL]             } [EOL]         } else if (value instanceof short[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (short[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (short[]) value); [EOL]             } [EOL]         } else if (value instanceof byte[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (byte[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (byte[]) value); [EOL]             } [EOL]         } else if (value instanceof char[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (char[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (char[]) value); [EOL]             } [EOL]         } else if (value instanceof double[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (double[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (double[]) value); [EOL]             } [EOL]         } else if (value instanceof float[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (float[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (float[]) value); [EOL]             } [EOL]         } else if (value instanceof boolean[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (boolean[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (boolean[]) value); [EOL]             } [EOL]         } else if (value.getClass().isArray()) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Object[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (Object[]) value); [EOL]             } [EOL]         } else { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, value); [EOL]             } [EOL]         } [EOL]     } finally { [EOL]         unregister(value); [EOL]     } [EOL] } 
 [LINE] appendDetail(buffer, fieldName, (short[]) value); [LINE] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail) { [EOL]     if (isRegistered(value) && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) { [EOL]         appendCyclicObject(buffer, fieldName, value); [EOL]         return; [EOL]     } [EOL]     register(value); [EOL]     try { [EOL]         if (value instanceof Collection<?>) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Collection<?>) value); [EOL]             } else { [EOL]                 appendSummarySize(buffer, fieldName, ((Collection<?>) value).size()); [EOL]             } [EOL]         } else if (value instanceof Map<?, ?>) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Map<?, ?>) value); [EOL]             } else { [EOL]                 appendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size()); [EOL]             } [EOL]         } else if (value instanceof long[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (long[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (long[]) value); [EOL]             } [EOL]         } else if (value instanceof int[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (int[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (int[]) value); [EOL]             } [EOL]         } else if (value instanceof short[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (short[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (short[]) value); [EOL]             } [EOL]         } else if (value instanceof byte[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (byte[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (byte[]) value); [EOL]             } [EOL]         } else if (value instanceof char[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (char[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (char[]) value); [EOL]             } [EOL]         } else if (value instanceof double[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (double[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (double[]) value); [EOL]             } [EOL]         } else if (value instanceof float[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (float[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (float[]) value); [EOL]             } [EOL]         } else if (value instanceof boolean[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (boolean[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (boolean[]) value); [EOL]             } [EOL]         } else if (value.getClass().isArray()) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Object[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (Object[]) value); [EOL]             } [EOL]         } else { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, value); [EOL]             } [EOL]         } [EOL]     } finally { [EOL]         unregister(value); [EOL]     } [EOL] } 
 [LINE] if (detail) { [LINE] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail) { [EOL]     if (isRegistered(value) && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) { [EOL]         appendCyclicObject(buffer, fieldName, value); [EOL]         return; [EOL]     } [EOL]     register(value); [EOL]     try { [EOL]         if (value instanceof Collection<?>) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Collection<?>) value); [EOL]             } else { [EOL]                 appendSummarySize(buffer, fieldName, ((Collection<?>) value).size()); [EOL]             } [EOL]         } else if (value instanceof Map<?, ?>) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Map<?, ?>) value); [EOL]             } else { [EOL]                 appendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size()); [EOL]             } [EOL]         } else if (value instanceof long[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (long[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (long[]) value); [EOL]             } [EOL]         } else if (value instanceof int[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (int[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (int[]) value); [EOL]             } [EOL]         } else if (value instanceof short[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (short[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (short[]) value); [EOL]             } [EOL]         } else if (value instanceof byte[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (byte[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (byte[]) value); [EOL]             } [EOL]         } else if (value instanceof char[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (char[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (char[]) value); [EOL]             } [EOL]         } else if (value instanceof double[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (double[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (double[]) value); [EOL]             } [EOL]         } else if (value instanceof float[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (float[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (float[]) value); [EOL]             } [EOL]         } else if (value instanceof boolean[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (boolean[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (boolean[]) value); [EOL]             } [EOL]         } else if (value.getClass().isArray()) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Object[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (Object[]) value); [EOL]             } [EOL]         } else { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, value); [EOL]             } [EOL]         } [EOL]     } finally { [EOL]         unregister(value); [EOL]     } [EOL] } 
 [LINE] appendDetail(buffer, fieldName, (byte[]) value); [LINE] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail) { [EOL]     if (isRegistered(value) && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) { [EOL]         appendCyclicObject(buffer, fieldName, value); [EOL]         return; [EOL]     } [EOL]     register(value); [EOL]     try { [EOL]         if (value instanceof Collection<?>) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Collection<?>) value); [EOL]             } else { [EOL]                 appendSummarySize(buffer, fieldName, ((Collection<?>) value).size()); [EOL]             } [EOL]         } else if (value instanceof Map<?, ?>) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Map<?, ?>) value); [EOL]             } else { [EOL]                 appendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size()); [EOL]             } [EOL]         } else if (value instanceof long[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (long[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (long[]) value); [EOL]             } [EOL]         } else if (value instanceof int[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (int[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (int[]) value); [EOL]             } [EOL]         } else if (value instanceof short[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (short[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (short[]) value); [EOL]             } [EOL]         } else if (value instanceof byte[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (byte[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (byte[]) value); [EOL]             } [EOL]         } else if (value instanceof char[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (char[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (char[]) value); [EOL]             } [EOL]         } else if (value instanceof double[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (double[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (double[]) value); [EOL]             } [EOL]         } else if (value instanceof float[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (float[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (float[]) value); [EOL]             } [EOL]         } else if (value instanceof boolean[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (boolean[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (boolean[]) value); [EOL]             } [EOL]         } else if (value.getClass().isArray()) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Object[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (Object[]) value); [EOL]             } [EOL]         } else { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, value); [EOL]             } [EOL]         } [EOL]     } finally { [EOL]         unregister(value); [EOL]     } [EOL] } 
 [LINE] if (detail) { [LINE] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail) { [EOL]     if (isRegistered(value) && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) { [EOL]         appendCyclicObject(buffer, fieldName, value); [EOL]         return; [EOL]     } [EOL]     register(value); [EOL]     try { [EOL]         if (value instanceof Collection<?>) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Collection<?>) value); [EOL]             } else { [EOL]                 appendSummarySize(buffer, fieldName, ((Collection<?>) value).size()); [EOL]             } [EOL]         } else if (value instanceof Map<?, ?>) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Map<?, ?>) value); [EOL]             } else { [EOL]                 appendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size()); [EOL]             } [EOL]         } else if (value instanceof long[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (long[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (long[]) value); [EOL]             } [EOL]         } else if (value instanceof int[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (int[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (int[]) value); [EOL]             } [EOL]         } else if (value instanceof short[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (short[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (short[]) value); [EOL]             } [EOL]         } else if (value instanceof byte[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (byte[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (byte[]) value); [EOL]             } [EOL]         } else if (value instanceof char[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (char[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (char[]) value); [EOL]             } [EOL]         } else if (value instanceof double[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (double[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (double[]) value); [EOL]             } [EOL]         } else if (value instanceof float[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (float[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (float[]) value); [EOL]             } [EOL]         } else if (value instanceof boolean[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (boolean[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (boolean[]) value); [EOL]             } [EOL]         } else if (value.getClass().isArray()) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Object[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (Object[]) value); [EOL]             } [EOL]         } else { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, value); [EOL]             } [EOL]         } [EOL]     } finally { [EOL]         unregister(value); [EOL]     } [EOL] } 
 [LINE] appendDetail(buffer, fieldName, (double[]) value); [LINE] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail) { [EOL]     if (isRegistered(value) && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) { [EOL]         appendCyclicObject(buffer, fieldName, value); [EOL]         return; [EOL]     } [EOL]     register(value); [EOL]     try { [EOL]         if (value instanceof Collection<?>) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Collection<?>) value); [EOL]             } else { [EOL]                 appendSummarySize(buffer, fieldName, ((Collection<?>) value).size()); [EOL]             } [EOL]         } else if (value instanceof Map<?, ?>) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Map<?, ?>) value); [EOL]             } else { [EOL]                 appendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size()); [EOL]             } [EOL]         } else if (value instanceof long[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (long[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (long[]) value); [EOL]             } [EOL]         } else if (value instanceof int[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (int[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (int[]) value); [EOL]             } [EOL]         } else if (value instanceof short[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (short[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (short[]) value); [EOL]             } [EOL]         } else if (value instanceof byte[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (byte[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (byte[]) value); [EOL]             } [EOL]         } else if (value instanceof char[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (char[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (char[]) value); [EOL]             } [EOL]         } else if (value instanceof double[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (double[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (double[]) value); [EOL]             } [EOL]         } else if (value instanceof float[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (float[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (float[]) value); [EOL]             } [EOL]         } else if (value instanceof boolean[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (boolean[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (boolean[]) value); [EOL]             } [EOL]         } else if (value.getClass().isArray()) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Object[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (Object[]) value); [EOL]             } [EOL]         } else { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, value); [EOL]             } [EOL]         } [EOL]     } finally { [EOL]         unregister(value); [EOL]     } [EOL] } 
 [LINE] if (detail) { [LINE] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail) { [EOL]     if (isRegistered(value) && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) { [EOL]         appendCyclicObject(buffer, fieldName, value); [EOL]         return; [EOL]     } [EOL]     register(value); [EOL]     try { [EOL]         if (value instanceof Collection<?>) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Collection<?>) value); [EOL]             } else { [EOL]                 appendSummarySize(buffer, fieldName, ((Collection<?>) value).size()); [EOL]             } [EOL]         } else if (value instanceof Map<?, ?>) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Map<?, ?>) value); [EOL]             } else { [EOL]                 appendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size()); [EOL]             } [EOL]         } else if (value instanceof long[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (long[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (long[]) value); [EOL]             } [EOL]         } else if (value instanceof int[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (int[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (int[]) value); [EOL]             } [EOL]         } else if (value instanceof short[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (short[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (short[]) value); [EOL]             } [EOL]         } else if (value instanceof byte[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (byte[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (byte[]) value); [EOL]             } [EOL]         } else if (value instanceof char[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (char[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (char[]) value); [EOL]             } [EOL]         } else if (value instanceof double[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (double[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (double[]) value); [EOL]             } [EOL]         } else if (value instanceof float[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (float[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (float[]) value); [EOL]             } [EOL]         } else if (value instanceof boolean[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (boolean[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (boolean[]) value); [EOL]             } [EOL]         } else if (value.getClass().isArray()) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Object[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (Object[]) value); [EOL]             } [EOL]         } else { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, value); [EOL]             } [EOL]         } [EOL]     } finally { [EOL]         unregister(value); [EOL]     } [EOL] } 
 [LINE] appendDetail(buffer, fieldName, (float[]) value); [LINE] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail) { [EOL]     if (isRegistered(value) && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) { [EOL]         appendCyclicObject(buffer, fieldName, value); [EOL]         return; [EOL]     } [EOL]     register(value); [EOL]     try { [EOL]         if (value instanceof Collection<?>) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Collection<?>) value); [EOL]             } else { [EOL]                 appendSummarySize(buffer, fieldName, ((Collection<?>) value).size()); [EOL]             } [EOL]         } else if (value instanceof Map<?, ?>) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Map<?, ?>) value); [EOL]             } else { [EOL]                 appendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size()); [EOL]             } [EOL]         } else if (value instanceof long[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (long[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (long[]) value); [EOL]             } [EOL]         } else if (value instanceof int[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (int[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (int[]) value); [EOL]             } [EOL]         } else if (value instanceof short[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (short[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (short[]) value); [EOL]             } [EOL]         } else if (value instanceof byte[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (byte[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (byte[]) value); [EOL]             } [EOL]         } else if (value instanceof char[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (char[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (char[]) value); [EOL]             } [EOL]         } else if (value instanceof double[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (double[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (double[]) value); [EOL]             } [EOL]         } else if (value instanceof float[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (float[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (float[]) value); [EOL]             } [EOL]         } else if (value instanceof boolean[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (boolean[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (boolean[]) value); [EOL]             } [EOL]         } else if (value.getClass().isArray()) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Object[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (Object[]) value); [EOL]             } [EOL]         } else { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, value); [EOL]             } [EOL]         } [EOL]     } finally { [EOL]         unregister(value); [EOL]     } [EOL] } 
 [LINE] if (detail) { [LINE] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail) { [EOL]     if (isRegistered(value) && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) { [EOL]         appendCyclicObject(buffer, fieldName, value); [EOL]         return; [EOL]     } [EOL]     register(value); [EOL]     try { [EOL]         if (value instanceof Collection<?>) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Collection<?>) value); [EOL]             } else { [EOL]                 appendSummarySize(buffer, fieldName, ((Collection<?>) value).size()); [EOL]             } [EOL]         } else if (value instanceof Map<?, ?>) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Map<?, ?>) value); [EOL]             } else { [EOL]                 appendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size()); [EOL]             } [EOL]         } else if (value instanceof long[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (long[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (long[]) value); [EOL]             } [EOL]         } else if (value instanceof int[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (int[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (int[]) value); [EOL]             } [EOL]         } else if (value instanceof short[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (short[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (short[]) value); [EOL]             } [EOL]         } else if (value instanceof byte[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (byte[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (byte[]) value); [EOL]             } [EOL]         } else if (value instanceof char[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (char[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (char[]) value); [EOL]             } [EOL]         } else if (value instanceof double[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (double[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (double[]) value); [EOL]             } [EOL]         } else if (value instanceof float[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (float[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (float[]) value); [EOL]             } [EOL]         } else if (value instanceof boolean[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (boolean[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (boolean[]) value); [EOL]             } [EOL]         } else if (value.getClass().isArray()) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Object[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (Object[]) value); [EOL]             } [EOL]         } else { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, value); [EOL]             } [EOL]         } [EOL]     } finally { [EOL]         unregister(value); [EOL]     } [EOL] } 
 [LINE] appendDetail(buffer, fieldName, (boolean[]) value); [LINE] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail) { [EOL]     if (isRegistered(value) && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) { [EOL]         appendCyclicObject(buffer, fieldName, value); [EOL]         return; [EOL]     } [EOL]     register(value); [EOL]     try { [EOL]         if (value instanceof Collection<?>) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Collection<?>) value); [EOL]             } else { [EOL]                 appendSummarySize(buffer, fieldName, ((Collection<?>) value).size()); [EOL]             } [EOL]         } else if (value instanceof Map<?, ?>) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Map<?, ?>) value); [EOL]             } else { [EOL]                 appendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size()); [EOL]             } [EOL]         } else if (value instanceof long[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (long[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (long[]) value); [EOL]             } [EOL]         } else if (value instanceof int[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (int[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (int[]) value); [EOL]             } [EOL]         } else if (value instanceof short[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (short[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (short[]) value); [EOL]             } [EOL]         } else if (value instanceof byte[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (byte[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (byte[]) value); [EOL]             } [EOL]         } else if (value instanceof char[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (char[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (char[]) value); [EOL]             } [EOL]         } else if (value instanceof double[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (double[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (double[]) value); [EOL]             } [EOL]         } else if (value instanceof float[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (float[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (float[]) value); [EOL]             } [EOL]         } else if (value instanceof boolean[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (boolean[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (boolean[]) value); [EOL]             } [EOL]         } else if (value.getClass().isArray()) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Object[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (Object[]) value); [EOL]             } [EOL]         } else { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, value); [EOL]             } [EOL]         } [EOL]     } finally { [EOL]         unregister(value); [EOL]     } [EOL] } 
 [LINE] appendSummary(buffer, fieldName, (Object[]) value); [LINE] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail) { [EOL]     if (isRegistered(value) && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) { [EOL]         appendCyclicObject(buffer, fieldName, value); [EOL]         return; [EOL]     } [EOL]     register(value); [EOL]     try { [EOL]         if (value instanceof Collection<?>) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Collection<?>) value); [EOL]             } else { [EOL]                 appendSummarySize(buffer, fieldName, ((Collection<?>) value).size()); [EOL]             } [EOL]         } else if (value instanceof Map<?, ?>) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Map<?, ?>) value); [EOL]             } else { [EOL]                 appendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size()); [EOL]             } [EOL]         } else if (value instanceof long[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (long[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (long[]) value); [EOL]             } [EOL]         } else if (value instanceof int[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (int[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (int[]) value); [EOL]             } [EOL]         } else if (value instanceof short[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (short[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (short[]) value); [EOL]             } [EOL]         } else if (value instanceof byte[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (byte[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (byte[]) value); [EOL]             } [EOL]         } else if (value instanceof char[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (char[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (char[]) value); [EOL]             } [EOL]         } else if (value instanceof double[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (double[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (double[]) value); [EOL]             } [EOL]         } else if (value instanceof float[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (float[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (float[]) value); [EOL]             } [EOL]         } else if (value instanceof boolean[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (boolean[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (boolean[]) value); [EOL]             } [EOL]         } else if (value.getClass().isArray()) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Object[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (Object[]) value); [EOL]             } [EOL]         } else { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, value); [EOL]             } [EOL]         } [EOL]     } finally { [EOL]         unregister(value); [EOL]     } [EOL] } 
 [LINE] for (int i = 0; i < length; i++) { [LINE] protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array) { [EOL]     buffer.append(arrayStart); [EOL]     final int length = Array.getLength(array); [EOL]     for (int i = 0; i < length; i++) { [EOL]         final Object item = Array.get(array, i); [EOL]         if (i > 0) { [EOL]             buffer.append(arraySeparator); [EOL]         } [EOL]         if (item == null) { [EOL]             appendNullText(buffer, fieldName); [EOL]         } else { [EOL]             appendInternal(buffer, fieldName, item, arrayContentDetail); [EOL]         } [EOL]     } [EOL]     buffer.append(arrayEnd); [EOL] } 
 [LINE] final Object item = Array.get(array, i); [LINE] protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array) { [EOL]     buffer.append(arrayStart); [EOL]     final int length = Array.getLength(array); [EOL]     for (int i = 0; i < length; i++) { [EOL]         final Object item = Array.get(array, i); [EOL]         if (i > 0) { [EOL]             buffer.append(arraySeparator); [EOL]         } [EOL]         if (item == null) { [EOL]             appendNullText(buffer, fieldName); [EOL]         } else { [EOL]             appendInternal(buffer, fieldName, item, arrayContentDetail); [EOL]         } [EOL]     } [EOL]     buffer.append(arrayEnd); [EOL] } 
 [LINE] if (i > 0) { [LINE] protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array) { [EOL]     buffer.append(arrayStart); [EOL]     final int length = Array.getLength(array); [EOL]     for (int i = 0; i < length; i++) { [EOL]         final Object item = Array.get(array, i); [EOL]         if (i > 0) { [EOL]             buffer.append(arraySeparator); [EOL]         } [EOL]         if (item == null) { [EOL]             appendNullText(buffer, fieldName); [EOL]         } else { [EOL]             appendInternal(buffer, fieldName, item, arrayContentDetail); [EOL]         } [EOL]     } [EOL]     buffer.append(arrayEnd); [EOL] } 
 [LINE] buffer.append(arraySeparator); [LINE] protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array) { [EOL]     buffer.append(arrayStart); [EOL]     final int length = Array.getLength(array); [EOL]     for (int i = 0; i < length; i++) { [EOL]         final Object item = Array.get(array, i); [EOL]         if (i > 0) { [EOL]             buffer.append(arraySeparator); [EOL]         } [EOL]         if (item == null) { [EOL]             appendNullText(buffer, fieldName); [EOL]         } else { [EOL]             appendInternal(buffer, fieldName, item, arrayContentDetail); [EOL]         } [EOL]     } [EOL]     buffer.append(arrayEnd); [EOL] } 
 [LINE] if (item == null) { [LINE] protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array) { [EOL]     buffer.append(arrayStart); [EOL]     final int length = Array.getLength(array); [EOL]     for (int i = 0; i < length; i++) { [EOL]         final Object item = Array.get(array, i); [EOL]         if (i > 0) { [EOL]             buffer.append(arraySeparator); [EOL]         } [EOL]         if (item == null) { [EOL]             appendNullText(buffer, fieldName); [EOL]         } else { [EOL]             appendInternal(buffer, fieldName, item, arrayContentDetail); [EOL]         } [EOL]     } [EOL]     buffer.append(arrayEnd); [EOL] } 
 [LINE] appendNullText(buffer, fieldName); [LINE] protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array) { [EOL]     buffer.append(arrayStart); [EOL]     final int length = Array.getLength(array); [EOL]     for (int i = 0; i < length; i++) { [EOL]         final Object item = Array.get(array, i); [EOL]         if (i > 0) { [EOL]             buffer.append(arraySeparator); [EOL]         } [EOL]         if (item == null) { [EOL]             appendNullText(buffer, fieldName); [EOL]         } else { [EOL]             appendInternal(buffer, fieldName, item, arrayContentDetail); [EOL]         } [EOL]     } [EOL]     buffer.append(arrayEnd); [EOL] } 
 [LINE] appendInternal(buffer, fieldName, item, arrayContentDetail); [LINE] protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array) { [EOL]     buffer.append(arrayStart); [EOL]     final int length = Array.getLength(array); [EOL]     for (int i = 0; i < length; i++) { [EOL]         final Object item = Array.get(array, i); [EOL]         if (i > 0) { [EOL]             buffer.append(arraySeparator); [EOL]         } [EOL]         if (item == null) { [EOL]             appendNullText(buffer, fieldName); [EOL]         } else { [EOL]             appendInternal(buffer, fieldName, item, arrayContentDetail); [EOL]         } [EOL]     } [EOL]     buffer.append(arrayEnd); [EOL] } 
 [LINE] buffer.append(arrayEnd); [LINE] protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array) { [EOL]     buffer.append(arrayStart); [EOL]     final int length = Array.getLength(array); [EOL]     for (int i = 0; i < length; i++) { [EOL]         final Object item = Array.get(array, i); [EOL]         if (i > 0) { [EOL]             buffer.append(arraySeparator); [EOL]         } [EOL]         if (item == null) { [EOL]             appendNullText(buffer, fieldName); [EOL]         } else { [EOL]             appendInternal(buffer, fieldName, item, arrayContentDetail); [EOL]         } [EOL]     } [EOL]     buffer.append(arrayEnd); [EOL] } 
 [LINE] appendNullText(buffer, fieldName); [LINE] public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail) { [EOL]     appendFieldStart(buffer, fieldName); [EOL]     if (array == null) { [EOL]         appendNullText(buffer, fieldName); [EOL]     } else if (isFullDetail(fullDetail)) { [EOL]         appendDetail(buffer, fieldName, array); [EOL]     } else { [EOL]         appendSummary(buffer, fieldName, array); [EOL]     } [EOL]     appendFieldEnd(buffer, fieldName); [EOL] } 
 [LINE] sizeStartText = ""; [LINE] protected void setSizeStartText(String sizeStartText) { [EOL]     if (sizeStartText == null) { [EOL]         sizeStartText = ""; [EOL]     } [EOL]     this.sizeStartText = sizeStartText; [EOL] } 
 [LINE] return isAssignable(type, (GenericArrayType) toType, typeVarAssigns); [LINE] private static boolean isAssignable(final Type type, final Type toType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (toType == null || toType instanceof Class<?>) { [EOL]         return isAssignable(type, (Class<?>) toType); [EOL]     } [EOL]     if (toType instanceof ParameterizedType) { [EOL]         return isAssignable(type, (ParameterizedType) toType, typeVarAssigns); [EOL]     } [EOL]     if (toType instanceof GenericArrayType) { [EOL]         return isAssignable(type, (GenericArrayType) toType, typeVarAssigns); [EOL]     } [EOL]     if (toType instanceof WildcardType) { [EOL]         return isAssignable(type, (WildcardType) toType, typeVarAssigns); [EOL]     } [EOL]     if (toType instanceof TypeVariable<?>) { [EOL]         return isAssignable(type, (TypeVariable<?>) toType, typeVarAssigns); [EOL]     } [EOL]     throw new IllegalStateException("found an unhandled type: " + toType); [EOL] } 
 [LINE] return isAssignable(type, (WildcardType) toType, typeVarAssigns); [LINE] private static boolean isAssignable(final Type type, final Type toType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (toType == null || toType instanceof Class<?>) { [EOL]         return isAssignable(type, (Class<?>) toType); [EOL]     } [EOL]     if (toType instanceof ParameterizedType) { [EOL]         return isAssignable(type, (ParameterizedType) toType, typeVarAssigns); [EOL]     } [EOL]     if (toType instanceof GenericArrayType) { [EOL]         return isAssignable(type, (GenericArrayType) toType, typeVarAssigns); [EOL]     } [EOL]     if (toType instanceof WildcardType) { [EOL]         return isAssignable(type, (WildcardType) toType, typeVarAssigns); [EOL]     } [EOL]     if (toType instanceof TypeVariable<?>) { [EOL]         return isAssignable(type, (TypeVariable<?>) toType, typeVarAssigns); [EOL]     } [EOL]     throw new IllegalStateException("found an unhandled type: " + toType); [EOL] } 
 [LINE] if (type instanceof TypeVariable<?>) { [LINE] private static boolean isAssignable(final Type type, final Class<?> toClass) { [EOL]     if (type == null) { [EOL]         return toClass == null || !toClass.isPrimitive(); [EOL]     } [EOL]     if (toClass == null) { [EOL]         return false; [EOL]     } [EOL]     if (toClass.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     if (type instanceof Class<?>) { [EOL]         return ClassUtils.isAssignable((Class<?>) type, toClass); [EOL]     } [EOL]     if (type instanceof ParameterizedType) { [EOL]         return isAssignable(getRawType((ParameterizedType) type), toClass); [EOL]     } [EOL]     if (type instanceof TypeVariable<?>) { [EOL]         for (final Type bound : ((TypeVariable<?>) type).getBounds()) { [EOL]             if (isAssignable(bound, toClass)) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (type instanceof GenericArrayType) { [EOL]         return toClass.equals(Object.class) || toClass.isArray() && isAssignable(((GenericArrayType) type).getGenericComponentType(), toClass.getComponentType()); [EOL]     } [EOL]     if (type instanceof WildcardType) { [EOL]         return false; [EOL]     } [EOL]     throw new IllegalStateException("found an unhandled type: " + type); [EOL] } 
 [LINE] if (type instanceof GenericArrayType) { [LINE] private static boolean isAssignable(final Type type, final Class<?> toClass) { [EOL]     if (type == null) { [EOL]         return toClass == null || !toClass.isPrimitive(); [EOL]     } [EOL]     if (toClass == null) { [EOL]         return false; [EOL]     } [EOL]     if (toClass.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     if (type instanceof Class<?>) { [EOL]         return ClassUtils.isAssignable((Class<?>) type, toClass); [EOL]     } [EOL]     if (type instanceof ParameterizedType) { [EOL]         return isAssignable(getRawType((ParameterizedType) type), toClass); [EOL]     } [EOL]     if (type instanceof TypeVariable<?>) { [EOL]         for (final Type bound : ((TypeVariable<?>) type).getBounds()) { [EOL]             if (isAssignable(bound, toClass)) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (type instanceof GenericArrayType) { [EOL]         return toClass.equals(Object.class) || toClass.isArray() && isAssignable(((GenericArrayType) type).getGenericComponentType(), toClass.getComponentType()); [EOL]     } [EOL]     if (type instanceof WildcardType) { [EOL]         return false; [EOL]     } [EOL]     throw new IllegalStateException("found an unhandled type: " + type); [EOL] } 
 [LINE] return toClass.equals(Object.class) [LINE] private static boolean isAssignable(final Type type, final Class<?> toClass) { [EOL]     if (type == null) { [EOL]         return toClass == null || !toClass.isPrimitive(); [EOL]     } [EOL]     if (toClass == null) { [EOL]         return false; [EOL]     } [EOL]     if (toClass.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     if (type instanceof Class<?>) { [EOL]         return ClassUtils.isAssignable((Class<?>) type, toClass); [EOL]     } [EOL]     if (type instanceof ParameterizedType) { [EOL]         return isAssignable(getRawType((ParameterizedType) type), toClass); [EOL]     } [EOL]     if (type instanceof TypeVariable<?>) { [EOL]         for (final Type bound : ((TypeVariable<?>) type).getBounds()) { [EOL]             if (isAssignable(bound, toClass)) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (type instanceof GenericArrayType) { [EOL]         return toClass.equals(Object.class) || toClass.isArray() && isAssignable(((GenericArrayType) type).getGenericComponentType(), toClass.getComponentType()); [EOL]     } [EOL]     if (type instanceof WildcardType) { [EOL]         return false; [EOL]     } [EOL]     throw new IllegalStateException("found an unhandled type: " + type); [EOL] } 
 [LINE] return true; [LINE] private static boolean isAssignable(final Type type, final ParameterizedType toParameterizedType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toParameterizedType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toParameterizedType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Class<?> toClass = getRawType(toParameterizedType); [EOL]     final Map<TypeVariable<?>, Type> fromTypeVarAssigns = getTypeArguments(type, toClass, null); [EOL]     if (fromTypeVarAssigns == null) { [EOL]         return false; [EOL]     } [EOL]     if (fromTypeVarAssigns.isEmpty()) { [EOL]         return true; [EOL]     } [EOL]     final Map<TypeVariable<?>, Type> toTypeVarAssigns = getTypeArguments(toParameterizedType, toClass, typeVarAssigns); [EOL]     for (final TypeVariable<?> var : toTypeVarAssigns.keySet()) { [EOL]         final Type toTypeArg = unrollVariableAssignments(var, toTypeVarAssigns); [EOL]         final Type fromTypeArg = unrollVariableAssignments(var, fromTypeVarAssigns); [EOL]         if (fromTypeArg != null && !toTypeArg.equals(fromTypeArg) && !(toTypeArg instanceof WildcardType && isAssignable(fromTypeArg, toTypeArg, typeVarAssigns))) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] final Map<TypeVariable<?>, Type> toTypeVarAssigns = getTypeArguments(toParameterizedType, [LINE] private static boolean isAssignable(final Type type, final ParameterizedType toParameterizedType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toParameterizedType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toParameterizedType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Class<?> toClass = getRawType(toParameterizedType); [EOL]     final Map<TypeVariable<?>, Type> fromTypeVarAssigns = getTypeArguments(type, toClass, null); [EOL]     if (fromTypeVarAssigns == null) { [EOL]         return false; [EOL]     } [EOL]     if (fromTypeVarAssigns.isEmpty()) { [EOL]         return true; [EOL]     } [EOL]     final Map<TypeVariable<?>, Type> toTypeVarAssigns = getTypeArguments(toParameterizedType, toClass, typeVarAssigns); [EOL]     for (final TypeVariable<?> var : toTypeVarAssigns.keySet()) { [EOL]         final Type toTypeArg = unrollVariableAssignments(var, toTypeVarAssigns); [EOL]         final Type fromTypeArg = unrollVariableAssignments(var, fromTypeVarAssigns); [EOL]         if (fromTypeArg != null && !toTypeArg.equals(fromTypeArg) && !(toTypeArg instanceof WildcardType && isAssignable(fromTypeArg, toTypeArg, typeVarAssigns))) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] for (final TypeVariable<?> var : toTypeVarAssigns.keySet()) { [LINE] private static boolean isAssignable(final Type type, final ParameterizedType toParameterizedType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toParameterizedType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toParameterizedType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Class<?> toClass = getRawType(toParameterizedType); [EOL]     final Map<TypeVariable<?>, Type> fromTypeVarAssigns = getTypeArguments(type, toClass, null); [EOL]     if (fromTypeVarAssigns == null) { [EOL]         return false; [EOL]     } [EOL]     if (fromTypeVarAssigns.isEmpty()) { [EOL]         return true; [EOL]     } [EOL]     final Map<TypeVariable<?>, Type> toTypeVarAssigns = getTypeArguments(toParameterizedType, toClass, typeVarAssigns); [EOL]     for (final TypeVariable<?> var : toTypeVarAssigns.keySet()) { [EOL]         final Type toTypeArg = unrollVariableAssignments(var, toTypeVarAssigns); [EOL]         final Type fromTypeArg = unrollVariableAssignments(var, fromTypeVarAssigns); [EOL]         if (fromTypeArg != null && !toTypeArg.equals(fromTypeArg) && !(toTypeArg instanceof WildcardType && isAssignable(fromTypeArg, toTypeArg, typeVarAssigns))) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] final Type toTypeArg = unrollVariableAssignments(var, toTypeVarAssigns); [LINE] private static boolean isAssignable(final Type type, final ParameterizedType toParameterizedType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toParameterizedType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toParameterizedType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Class<?> toClass = getRawType(toParameterizedType); [EOL]     final Map<TypeVariable<?>, Type> fromTypeVarAssigns = getTypeArguments(type, toClass, null); [EOL]     if (fromTypeVarAssigns == null) { [EOL]         return false; [EOL]     } [EOL]     if (fromTypeVarAssigns.isEmpty()) { [EOL]         return true; [EOL]     } [EOL]     final Map<TypeVariable<?>, Type> toTypeVarAssigns = getTypeArguments(toParameterizedType, toClass, typeVarAssigns); [EOL]     for (final TypeVariable<?> var : toTypeVarAssigns.keySet()) { [EOL]         final Type toTypeArg = unrollVariableAssignments(var, toTypeVarAssigns); [EOL]         final Type fromTypeArg = unrollVariableAssignments(var, fromTypeVarAssigns); [EOL]         if (fromTypeArg != null && !toTypeArg.equals(fromTypeArg) && !(toTypeArg instanceof WildcardType && isAssignable(fromTypeArg, toTypeArg, typeVarAssigns))) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] final Type fromTypeArg = unrollVariableAssignments(var, fromTypeVarAssigns); [LINE] private static boolean isAssignable(final Type type, final ParameterizedType toParameterizedType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toParameterizedType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toParameterizedType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Class<?> toClass = getRawType(toParameterizedType); [EOL]     final Map<TypeVariable<?>, Type> fromTypeVarAssigns = getTypeArguments(type, toClass, null); [EOL]     if (fromTypeVarAssigns == null) { [EOL]         return false; [EOL]     } [EOL]     if (fromTypeVarAssigns.isEmpty()) { [EOL]         return true; [EOL]     } [EOL]     final Map<TypeVariable<?>, Type> toTypeVarAssigns = getTypeArguments(toParameterizedType, toClass, typeVarAssigns); [EOL]     for (final TypeVariable<?> var : toTypeVarAssigns.keySet()) { [EOL]         final Type toTypeArg = unrollVariableAssignments(var, toTypeVarAssigns); [EOL]         final Type fromTypeArg = unrollVariableAssignments(var, fromTypeVarAssigns); [EOL]         if (fromTypeArg != null && !toTypeArg.equals(fromTypeArg) && !(toTypeArg instanceof WildcardType && isAssignable(fromTypeArg, toTypeArg, typeVarAssigns))) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] if (fromTypeArg != null [LINE] private static boolean isAssignable(final Type type, final ParameterizedType toParameterizedType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toParameterizedType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toParameterizedType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Class<?> toClass = getRawType(toParameterizedType); [EOL]     final Map<TypeVariable<?>, Type> fromTypeVarAssigns = getTypeArguments(type, toClass, null); [EOL]     if (fromTypeVarAssigns == null) { [EOL]         return false; [EOL]     } [EOL]     if (fromTypeVarAssigns.isEmpty()) { [EOL]         return true; [EOL]     } [EOL]     final Map<TypeVariable<?>, Type> toTypeVarAssigns = getTypeArguments(toParameterizedType, toClass, typeVarAssigns); [EOL]     for (final TypeVariable<?> var : toTypeVarAssigns.keySet()) { [EOL]         final Type toTypeArg = unrollVariableAssignments(var, toTypeVarAssigns); [EOL]         final Type fromTypeArg = unrollVariableAssignments(var, fromTypeVarAssigns); [EOL]         if (fromTypeArg != null && !toTypeArg.equals(fromTypeArg) && !(toTypeArg instanceof WildcardType && isAssignable(fromTypeArg, toTypeArg, typeVarAssigns))) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] return false; [LINE] private static boolean isAssignable(final Type type, final ParameterizedType toParameterizedType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toParameterizedType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toParameterizedType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Class<?> toClass = getRawType(toParameterizedType); [EOL]     final Map<TypeVariable<?>, Type> fromTypeVarAssigns = getTypeArguments(type, toClass, null); [EOL]     if (fromTypeVarAssigns == null) { [EOL]         return false; [EOL]     } [EOL]     if (fromTypeVarAssigns.isEmpty()) { [EOL]         return true; [EOL]     } [EOL]     final Map<TypeVariable<?>, Type> toTypeVarAssigns = getTypeArguments(toParameterizedType, toClass, typeVarAssigns); [EOL]     for (final TypeVariable<?> var : toTypeVarAssigns.keySet()) { [EOL]         final Type toTypeArg = unrollVariableAssignments(var, toTypeVarAssigns); [EOL]         final Type fromTypeArg = unrollVariableAssignments(var, fromTypeVarAssigns); [EOL]         if (fromTypeArg != null && !toTypeArg.equals(fromTypeArg) && !(toTypeArg instanceof WildcardType && isAssignable(fromTypeArg, toTypeArg, typeVarAssigns))) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] return true; [LINE] private static boolean isAssignable(final Type type, final ParameterizedType toParameterizedType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toParameterizedType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toParameterizedType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Class<?> toClass = getRawType(toParameterizedType); [EOL]     final Map<TypeVariable<?>, Type> fromTypeVarAssigns = getTypeArguments(type, toClass, null); [EOL]     if (fromTypeVarAssigns == null) { [EOL]         return false; [EOL]     } [EOL]     if (fromTypeVarAssigns.isEmpty()) { [EOL]         return true; [EOL]     } [EOL]     final Map<TypeVariable<?>, Type> toTypeVarAssigns = getTypeArguments(toParameterizedType, toClass, typeVarAssigns); [EOL]     for (final TypeVariable<?> var : toTypeVarAssigns.keySet()) { [EOL]         final Type toTypeArg = unrollVariableAssignments(var, toTypeVarAssigns); [EOL]         final Type fromTypeArg = unrollVariableAssignments(var, fromTypeVarAssigns); [EOL]         if (fromTypeArg != null && !toTypeArg.equals(fromTypeArg) && !(toTypeArg instanceof WildcardType && isAssignable(fromTypeArg, toTypeArg, typeVarAssigns))) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] private static Type unrollVariableAssignments(TypeVariable<?> var, final Map<TypeVariable<?>, Type> typeVarAssigns) { [LINE] private static Type unrollVariableAssignments(TypeVariable<?> var, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     Type result; [EOL]     do { [EOL]         result = typeVarAssigns.get(var); [EOL]         if (result instanceof TypeVariable<?> && !result.equals(var)) { [EOL]             var = (TypeVariable<?>) result; [EOL]             continue; [EOL]         } [EOL]         break; [EOL]     } while (true); [EOL]     return result; [EOL] } 
 [LINE] Type result; [LINE] private static Type unrollVariableAssignments(TypeVariable<?> var, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     Type result; [EOL]     do { [EOL]         result = typeVarAssigns.get(var); [EOL]         if (result instanceof TypeVariable<?> && !result.equals(var)) { [EOL]             var = (TypeVariable<?>) result; [EOL]             continue; [EOL]         } [EOL]         break; [EOL]     } while (true); [EOL]     return result; [EOL] } 
 [LINE] do { [LINE] private static Type unrollVariableAssignments(TypeVariable<?> var, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     Type result; [EOL]     do { [EOL]         result = typeVarAssigns.get(var); [EOL]         if (result instanceof TypeVariable<?> && !result.equals(var)) { [EOL]             var = (TypeVariable<?>) result; [EOL]             continue; [EOL]         } [EOL]         break; [EOL]     } while (true); [EOL]     return result; [EOL] } 
 [LINE] result = typeVarAssigns.get(var); [LINE] private static Type unrollVariableAssignments(TypeVariable<?> var, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     Type result; [EOL]     do { [EOL]         result = typeVarAssigns.get(var); [EOL]         if (result instanceof TypeVariable<?> && !result.equals(var)) { [EOL]             var = (TypeVariable<?>) result; [EOL]             continue; [EOL]         } [EOL]         break; [EOL]     } while (true); [EOL]     return result; [EOL] } 
 [LINE] if (result instanceof TypeVariable<?> && !result.equals(var)) { [LINE] private static Type unrollVariableAssignments(TypeVariable<?> var, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     Type result; [EOL]     do { [EOL]         result = typeVarAssigns.get(var); [EOL]         if (result instanceof TypeVariable<?> && !result.equals(var)) { [EOL]             var = (TypeVariable<?>) result; [EOL]             continue; [EOL]         } [EOL]         break; [EOL]     } while (true); [EOL]     return result; [EOL] } 
 [LINE] var = (TypeVariable<?>) result; [LINE] private static Type unrollVariableAssignments(TypeVariable<?> var, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     Type result; [EOL]     do { [EOL]         result = typeVarAssigns.get(var); [EOL]         if (result instanceof TypeVariable<?> && !result.equals(var)) { [EOL]             var = (TypeVariable<?>) result; [EOL]             continue; [EOL]         } [EOL]         break; [EOL]     } while (true); [EOL]     return result; [EOL] } 
 [LINE] continue; [LINE] private static Type unrollVariableAssignments(TypeVariable<?> var, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     Type result; [EOL]     do { [EOL]         result = typeVarAssigns.get(var); [EOL]         if (result instanceof TypeVariable<?> && !result.equals(var)) { [EOL]             var = (TypeVariable<?>) result; [EOL]             continue; [EOL]         } [EOL]         break; [EOL]     } while (true); [EOL]     return result; [EOL] } 
 [LINE] break; [LINE] private static Type unrollVariableAssignments(TypeVariable<?> var, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     Type result; [EOL]     do { [EOL]         result = typeVarAssigns.get(var); [EOL]         if (result instanceof TypeVariable<?> && !result.equals(var)) { [EOL]             var = (TypeVariable<?>) result; [EOL]             continue; [EOL]         } [EOL]         break; [EOL]     } while (true); [EOL]     return result; [EOL] } 
 [LINE] return result; [LINE] private static Type unrollVariableAssignments(TypeVariable<?> var, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     Type result; [EOL]     do { [EOL]         result = typeVarAssigns.get(var); [EOL]         if (result instanceof TypeVariable<?> && !result.equals(var)) { [EOL]             var = (TypeVariable<?>) result; [EOL]             continue; [EOL]         } [EOL]         break; [EOL]     } while (true); [EOL]     return result; [EOL] } 
 [LINE] private static boolean isAssignable(final Type type, final GenericArrayType toGenericArrayType, [LINE] private static boolean isAssignable(final Type type, final GenericArrayType toGenericArrayType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toGenericArrayType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toGenericArrayType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Type toComponentType = toGenericArrayType.getGenericComponentType(); [EOL]     if (type instanceof Class<?>) { [EOL]         final Class<?> cls = (Class<?>) type; [EOL]         return cls.isArray() && isAssignable(cls.getComponentType(), toComponentType, typeVarAssigns); [EOL]     } [EOL]     if (type instanceof GenericArrayType) { [EOL]         return isAssignable(((GenericArrayType) type).getGenericComponentType(), toComponentType, typeVarAssigns); [EOL]     } [EOL]     if (type instanceof WildcardType) { [EOL]         for (final Type bound : getImplicitUpperBounds((WildcardType) type)) { [EOL]             if (isAssignable(bound, toGenericArrayType)) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (type instanceof TypeVariable<?>) { [EOL]         for (final Type bound : getImplicitBounds((TypeVariable<?>) type)) { [EOL]             if (isAssignable(bound, toGenericArrayType)) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (type instanceof ParameterizedType) { [EOL]         return false; [EOL]     } [EOL]     throw new IllegalStateException("found an unhandled type: " + type); [EOL] } 
 [LINE] if (type == null) { [LINE] private static boolean isAssignable(final Type type, final GenericArrayType toGenericArrayType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toGenericArrayType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toGenericArrayType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Type toComponentType = toGenericArrayType.getGenericComponentType(); [EOL]     if (type instanceof Class<?>) { [EOL]         final Class<?> cls = (Class<?>) type; [EOL]         return cls.isArray() && isAssignable(cls.getComponentType(), toComponentType, typeVarAssigns); [EOL]     } [EOL]     if (type instanceof GenericArrayType) { [EOL]         return isAssignable(((GenericArrayType) type).getGenericComponentType(), toComponentType, typeVarAssigns); [EOL]     } [EOL]     if (type instanceof WildcardType) { [EOL]         for (final Type bound : getImplicitUpperBounds((WildcardType) type)) { [EOL]             if (isAssignable(bound, toGenericArrayType)) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (type instanceof TypeVariable<?>) { [EOL]         for (final Type bound : getImplicitBounds((TypeVariable<?>) type)) { [EOL]             if (isAssignable(bound, toGenericArrayType)) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (type instanceof ParameterizedType) { [EOL]         return false; [EOL]     } [EOL]     throw new IllegalStateException("found an unhandled type: " + type); [EOL] } 
 [LINE] if (toGenericArrayType == null) { [LINE] private static boolean isAssignable(final Type type, final GenericArrayType toGenericArrayType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toGenericArrayType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toGenericArrayType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Type toComponentType = toGenericArrayType.getGenericComponentType(); [EOL]     if (type instanceof Class<?>) { [EOL]         final Class<?> cls = (Class<?>) type; [EOL]         return cls.isArray() && isAssignable(cls.getComponentType(), toComponentType, typeVarAssigns); [EOL]     } [EOL]     if (type instanceof GenericArrayType) { [EOL]         return isAssignable(((GenericArrayType) type).getGenericComponentType(), toComponentType, typeVarAssigns); [EOL]     } [EOL]     if (type instanceof WildcardType) { [EOL]         for (final Type bound : getImplicitUpperBounds((WildcardType) type)) { [EOL]             if (isAssignable(bound, toGenericArrayType)) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (type instanceof TypeVariable<?>) { [EOL]         for (final Type bound : getImplicitBounds((TypeVariable<?>) type)) { [EOL]             if (isAssignable(bound, toGenericArrayType)) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (type instanceof ParameterizedType) { [EOL]         return false; [EOL]     } [EOL]     throw new IllegalStateException("found an unhandled type: " + type); [EOL] } 
 [LINE] if (toGenericArrayType.equals(type)) { [LINE] private static boolean isAssignable(final Type type, final GenericArrayType toGenericArrayType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toGenericArrayType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toGenericArrayType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Type toComponentType = toGenericArrayType.getGenericComponentType(); [EOL]     if (type instanceof Class<?>) { [EOL]         final Class<?> cls = (Class<?>) type; [EOL]         return cls.isArray() && isAssignable(cls.getComponentType(), toComponentType, typeVarAssigns); [EOL]     } [EOL]     if (type instanceof GenericArrayType) { [EOL]         return isAssignable(((GenericArrayType) type).getGenericComponentType(), toComponentType, typeVarAssigns); [EOL]     } [EOL]     if (type instanceof WildcardType) { [EOL]         for (final Type bound : getImplicitUpperBounds((WildcardType) type)) { [EOL]             if (isAssignable(bound, toGenericArrayType)) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (type instanceof TypeVariable<?>) { [EOL]         for (final Type bound : getImplicitBounds((TypeVariable<?>) type)) { [EOL]             if (isAssignable(bound, toGenericArrayType)) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (type instanceof ParameterizedType) { [EOL]         return false; [EOL]     } [EOL]     throw new IllegalStateException("found an unhandled type: " + type); [EOL] } 
 [LINE] return true; [LINE] private static boolean isAssignable(final Type type, final GenericArrayType toGenericArrayType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toGenericArrayType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toGenericArrayType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Type toComponentType = toGenericArrayType.getGenericComponentType(); [EOL]     if (type instanceof Class<?>) { [EOL]         final Class<?> cls = (Class<?>) type; [EOL]         return cls.isArray() && isAssignable(cls.getComponentType(), toComponentType, typeVarAssigns); [EOL]     } [EOL]     if (type instanceof GenericArrayType) { [EOL]         return isAssignable(((GenericArrayType) type).getGenericComponentType(), toComponentType, typeVarAssigns); [EOL]     } [EOL]     if (type instanceof WildcardType) { [EOL]         for (final Type bound : getImplicitUpperBounds((WildcardType) type)) { [EOL]             if (isAssignable(bound, toGenericArrayType)) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (type instanceof TypeVariable<?>) { [EOL]         for (final Type bound : getImplicitBounds((TypeVariable<?>) type)) { [EOL]             if (isAssignable(bound, toGenericArrayType)) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (type instanceof ParameterizedType) { [EOL]         return false; [EOL]     } [EOL]     throw new IllegalStateException("found an unhandled type: " + type); [EOL] } 
 [LINE] final Type toComponentType = toGenericArrayType.getGenericComponentType(); [LINE] private static boolean isAssignable(final Type type, final GenericArrayType toGenericArrayType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toGenericArrayType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toGenericArrayType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Type toComponentType = toGenericArrayType.getGenericComponentType(); [EOL]     if (type instanceof Class<?>) { [EOL]         final Class<?> cls = (Class<?>) type; [EOL]         return cls.isArray() && isAssignable(cls.getComponentType(), toComponentType, typeVarAssigns); [EOL]     } [EOL]     if (type instanceof GenericArrayType) { [EOL]         return isAssignable(((GenericArrayType) type).getGenericComponentType(), toComponentType, typeVarAssigns); [EOL]     } [EOL]     if (type instanceof WildcardType) { [EOL]         for (final Type bound : getImplicitUpperBounds((WildcardType) type)) { [EOL]             if (isAssignable(bound, toGenericArrayType)) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (type instanceof TypeVariable<?>) { [EOL]         for (final Type bound : getImplicitBounds((TypeVariable<?>) type)) { [EOL]             if (isAssignable(bound, toGenericArrayType)) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (type instanceof ParameterizedType) { [EOL]         return false; [EOL]     } [EOL]     throw new IllegalStateException("found an unhandled type: " + type); [EOL] } 
 [LINE] if (type instanceof Class<?>) { [LINE] private static boolean isAssignable(final Type type, final GenericArrayType toGenericArrayType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toGenericArrayType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toGenericArrayType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Type toComponentType = toGenericArrayType.getGenericComponentType(); [EOL]     if (type instanceof Class<?>) { [EOL]         final Class<?> cls = (Class<?>) type; [EOL]         return cls.isArray() && isAssignable(cls.getComponentType(), toComponentType, typeVarAssigns); [EOL]     } [EOL]     if (type instanceof GenericArrayType) { [EOL]         return isAssignable(((GenericArrayType) type).getGenericComponentType(), toComponentType, typeVarAssigns); [EOL]     } [EOL]     if (type instanceof WildcardType) { [EOL]         for (final Type bound : getImplicitUpperBounds((WildcardType) type)) { [EOL]             if (isAssignable(bound, toGenericArrayType)) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (type instanceof TypeVariable<?>) { [EOL]         for (final Type bound : getImplicitBounds((TypeVariable<?>) type)) { [EOL]             if (isAssignable(bound, toGenericArrayType)) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (type instanceof ParameterizedType) { [EOL]         return false; [EOL]     } [EOL]     throw new IllegalStateException("found an unhandled type: " + type); [EOL] } 
 [LINE] final Class<?> cls = (Class<?>) type; [LINE] private static boolean isAssignable(final Type type, final GenericArrayType toGenericArrayType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toGenericArrayType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toGenericArrayType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Type toComponentType = toGenericArrayType.getGenericComponentType(); [EOL]     if (type instanceof Class<?>) { [EOL]         final Class<?> cls = (Class<?>) type; [EOL]         return cls.isArray() && isAssignable(cls.getComponentType(), toComponentType, typeVarAssigns); [EOL]     } [EOL]     if (type instanceof GenericArrayType) { [EOL]         return isAssignable(((GenericArrayType) type).getGenericComponentType(), toComponentType, typeVarAssigns); [EOL]     } [EOL]     if (type instanceof WildcardType) { [EOL]         for (final Type bound : getImplicitUpperBounds((WildcardType) type)) { [EOL]             if (isAssignable(bound, toGenericArrayType)) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (type instanceof TypeVariable<?>) { [EOL]         for (final Type bound : getImplicitBounds((TypeVariable<?>) type)) { [EOL]             if (isAssignable(bound, toGenericArrayType)) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (type instanceof ParameterizedType) { [EOL]         return false; [EOL]     } [EOL]     throw new IllegalStateException("found an unhandled type: " + type); [EOL] } 
 [LINE] return cls.isArray() [LINE] private static boolean isAssignable(final Type type, final GenericArrayType toGenericArrayType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toGenericArrayType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toGenericArrayType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Type toComponentType = toGenericArrayType.getGenericComponentType(); [EOL]     if (type instanceof Class<?>) { [EOL]         final Class<?> cls = (Class<?>) type; [EOL]         return cls.isArray() && isAssignable(cls.getComponentType(), toComponentType, typeVarAssigns); [EOL]     } [EOL]     if (type instanceof GenericArrayType) { [EOL]         return isAssignable(((GenericArrayType) type).getGenericComponentType(), toComponentType, typeVarAssigns); [EOL]     } [EOL]     if (type instanceof WildcardType) { [EOL]         for (final Type bound : getImplicitUpperBounds((WildcardType) type)) { [EOL]             if (isAssignable(bound, toGenericArrayType)) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (type instanceof TypeVariable<?>) { [EOL]         for (final Type bound : getImplicitBounds((TypeVariable<?>) type)) { [EOL]             if (isAssignable(bound, toGenericArrayType)) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (type instanceof ParameterizedType) { [EOL]         return false; [EOL]     } [EOL]     throw new IllegalStateException("found an unhandled type: " + type); [EOL] } 
 [LINE] if (type instanceof GenericArrayType) { [LINE] private static boolean isAssignable(final Type type, final GenericArrayType toGenericArrayType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toGenericArrayType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toGenericArrayType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Type toComponentType = toGenericArrayType.getGenericComponentType(); [EOL]     if (type instanceof Class<?>) { [EOL]         final Class<?> cls = (Class<?>) type; [EOL]         return cls.isArray() && isAssignable(cls.getComponentType(), toComponentType, typeVarAssigns); [EOL]     } [EOL]     if (type instanceof GenericArrayType) { [EOL]         return isAssignable(((GenericArrayType) type).getGenericComponentType(), toComponentType, typeVarAssigns); [EOL]     } [EOL]     if (type instanceof WildcardType) { [EOL]         for (final Type bound : getImplicitUpperBounds((WildcardType) type)) { [EOL]             if (isAssignable(bound, toGenericArrayType)) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (type instanceof TypeVariable<?>) { [EOL]         for (final Type bound : getImplicitBounds((TypeVariable<?>) type)) { [EOL]             if (isAssignable(bound, toGenericArrayType)) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (type instanceof ParameterizedType) { [EOL]         return false; [EOL]     } [EOL]     throw new IllegalStateException("found an unhandled type: " + type); [EOL] } 
 [LINE] return isAssignable(((GenericArrayType) type).getGenericComponentType(), [LINE] private static boolean isAssignable(final Type type, final GenericArrayType toGenericArrayType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toGenericArrayType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toGenericArrayType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Type toComponentType = toGenericArrayType.getGenericComponentType(); [EOL]     if (type instanceof Class<?>) { [EOL]         final Class<?> cls = (Class<?>) type; [EOL]         return cls.isArray() && isAssignable(cls.getComponentType(), toComponentType, typeVarAssigns); [EOL]     } [EOL]     if (type instanceof GenericArrayType) { [EOL]         return isAssignable(((GenericArrayType) type).getGenericComponentType(), toComponentType, typeVarAssigns); [EOL]     } [EOL]     if (type instanceof WildcardType) { [EOL]         for (final Type bound : getImplicitUpperBounds((WildcardType) type)) { [EOL]             if (isAssignable(bound, toGenericArrayType)) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (type instanceof TypeVariable<?>) { [EOL]         for (final Type bound : getImplicitBounds((TypeVariable<?>) type)) { [EOL]             if (isAssignable(bound, toGenericArrayType)) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (type instanceof ParameterizedType) { [EOL]         return false; [EOL]     } [EOL]     throw new IllegalStateException("found an unhandled type: " + type); [EOL] } 
 [LINE] private static boolean isAssignable(final Type type, final WildcardType toWildcardType, [LINE] private static boolean isAssignable(final Type type, final WildcardType toWildcardType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toWildcardType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toWildcardType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Type[] toUpperBounds = getImplicitUpperBounds(toWildcardType); [EOL]     final Type[] toLowerBounds = getImplicitLowerBounds(toWildcardType); [EOL]     if (type instanceof WildcardType) { [EOL]         final WildcardType wildcardType = (WildcardType) type; [EOL]         final Type[] upperBounds = getImplicitUpperBounds(wildcardType); [EOL]         final Type[] lowerBounds = getImplicitLowerBounds(wildcardType); [EOL]         for (Type toBound : toUpperBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : upperBounds) { [EOL]                 if (!isAssignable(bound, toBound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         for (Type toBound : toLowerBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : lowerBounds) { [EOL]                 if (!isAssignable(toBound, bound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     for (final Type toBound : toUpperBounds) { [EOL]         if (!isAssignable(type, substituteTypeVariables(toBound, typeVarAssigns), typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     for (final Type toBound : toLowerBounds) { [EOL]         if (!isAssignable(substituteTypeVariables(toBound, typeVarAssigns), type, typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] if (type == null) { [LINE] private static boolean isAssignable(final Type type, final WildcardType toWildcardType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toWildcardType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toWildcardType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Type[] toUpperBounds = getImplicitUpperBounds(toWildcardType); [EOL]     final Type[] toLowerBounds = getImplicitLowerBounds(toWildcardType); [EOL]     if (type instanceof WildcardType) { [EOL]         final WildcardType wildcardType = (WildcardType) type; [EOL]         final Type[] upperBounds = getImplicitUpperBounds(wildcardType); [EOL]         final Type[] lowerBounds = getImplicitLowerBounds(wildcardType); [EOL]         for (Type toBound : toUpperBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : upperBounds) { [EOL]                 if (!isAssignable(bound, toBound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         for (Type toBound : toLowerBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : lowerBounds) { [EOL]                 if (!isAssignable(toBound, bound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     for (final Type toBound : toUpperBounds) { [EOL]         if (!isAssignable(type, substituteTypeVariables(toBound, typeVarAssigns), typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     for (final Type toBound : toLowerBounds) { [EOL]         if (!isAssignable(substituteTypeVariables(toBound, typeVarAssigns), type, typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] if (toWildcardType == null) { [LINE] private static boolean isAssignable(final Type type, final WildcardType toWildcardType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toWildcardType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toWildcardType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Type[] toUpperBounds = getImplicitUpperBounds(toWildcardType); [EOL]     final Type[] toLowerBounds = getImplicitLowerBounds(toWildcardType); [EOL]     if (type instanceof WildcardType) { [EOL]         final WildcardType wildcardType = (WildcardType) type; [EOL]         final Type[] upperBounds = getImplicitUpperBounds(wildcardType); [EOL]         final Type[] lowerBounds = getImplicitLowerBounds(wildcardType); [EOL]         for (Type toBound : toUpperBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : upperBounds) { [EOL]                 if (!isAssignable(bound, toBound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         for (Type toBound : toLowerBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : lowerBounds) { [EOL]                 if (!isAssignable(toBound, bound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     for (final Type toBound : toUpperBounds) { [EOL]         if (!isAssignable(type, substituteTypeVariables(toBound, typeVarAssigns), typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     for (final Type toBound : toLowerBounds) { [EOL]         if (!isAssignable(substituteTypeVariables(toBound, typeVarAssigns), type, typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] if (toWildcardType.equals(type)) { [LINE] private static boolean isAssignable(final Type type, final WildcardType toWildcardType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toWildcardType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toWildcardType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Type[] toUpperBounds = getImplicitUpperBounds(toWildcardType); [EOL]     final Type[] toLowerBounds = getImplicitLowerBounds(toWildcardType); [EOL]     if (type instanceof WildcardType) { [EOL]         final WildcardType wildcardType = (WildcardType) type; [EOL]         final Type[] upperBounds = getImplicitUpperBounds(wildcardType); [EOL]         final Type[] lowerBounds = getImplicitLowerBounds(wildcardType); [EOL]         for (Type toBound : toUpperBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : upperBounds) { [EOL]                 if (!isAssignable(bound, toBound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         for (Type toBound : toLowerBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : lowerBounds) { [EOL]                 if (!isAssignable(toBound, bound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     for (final Type toBound : toUpperBounds) { [EOL]         if (!isAssignable(type, substituteTypeVariables(toBound, typeVarAssigns), typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     for (final Type toBound : toLowerBounds) { [EOL]         if (!isAssignable(substituteTypeVariables(toBound, typeVarAssigns), type, typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] final Type[] toUpperBounds = getImplicitUpperBounds(toWildcardType); [LINE] private static boolean isAssignable(final Type type, final WildcardType toWildcardType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toWildcardType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toWildcardType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Type[] toUpperBounds = getImplicitUpperBounds(toWildcardType); [EOL]     final Type[] toLowerBounds = getImplicitLowerBounds(toWildcardType); [EOL]     if (type instanceof WildcardType) { [EOL]         final WildcardType wildcardType = (WildcardType) type; [EOL]         final Type[] upperBounds = getImplicitUpperBounds(wildcardType); [EOL]         final Type[] lowerBounds = getImplicitLowerBounds(wildcardType); [EOL]         for (Type toBound : toUpperBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : upperBounds) { [EOL]                 if (!isAssignable(bound, toBound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         for (Type toBound : toLowerBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : lowerBounds) { [EOL]                 if (!isAssignable(toBound, bound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     for (final Type toBound : toUpperBounds) { [EOL]         if (!isAssignable(type, substituteTypeVariables(toBound, typeVarAssigns), typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     for (final Type toBound : toLowerBounds) { [EOL]         if (!isAssignable(substituteTypeVariables(toBound, typeVarAssigns), type, typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] final Type[] toLowerBounds = getImplicitLowerBounds(toWildcardType); [LINE] private static boolean isAssignable(final Type type, final WildcardType toWildcardType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toWildcardType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toWildcardType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Type[] toUpperBounds = getImplicitUpperBounds(toWildcardType); [EOL]     final Type[] toLowerBounds = getImplicitLowerBounds(toWildcardType); [EOL]     if (type instanceof WildcardType) { [EOL]         final WildcardType wildcardType = (WildcardType) type; [EOL]         final Type[] upperBounds = getImplicitUpperBounds(wildcardType); [EOL]         final Type[] lowerBounds = getImplicitLowerBounds(wildcardType); [EOL]         for (Type toBound : toUpperBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : upperBounds) { [EOL]                 if (!isAssignable(bound, toBound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         for (Type toBound : toLowerBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : lowerBounds) { [EOL]                 if (!isAssignable(toBound, bound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     for (final Type toBound : toUpperBounds) { [EOL]         if (!isAssignable(type, substituteTypeVariables(toBound, typeVarAssigns), typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     for (final Type toBound : toLowerBounds) { [EOL]         if (!isAssignable(substituteTypeVariables(toBound, typeVarAssigns), type, typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] if (type instanceof WildcardType) { [LINE] private static boolean isAssignable(final Type type, final WildcardType toWildcardType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toWildcardType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toWildcardType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Type[] toUpperBounds = getImplicitUpperBounds(toWildcardType); [EOL]     final Type[] toLowerBounds = getImplicitLowerBounds(toWildcardType); [EOL]     if (type instanceof WildcardType) { [EOL]         final WildcardType wildcardType = (WildcardType) type; [EOL]         final Type[] upperBounds = getImplicitUpperBounds(wildcardType); [EOL]         final Type[] lowerBounds = getImplicitLowerBounds(wildcardType); [EOL]         for (Type toBound : toUpperBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : upperBounds) { [EOL]                 if (!isAssignable(bound, toBound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         for (Type toBound : toLowerBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : lowerBounds) { [EOL]                 if (!isAssignable(toBound, bound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     for (final Type toBound : toUpperBounds) { [EOL]         if (!isAssignable(type, substituteTypeVariables(toBound, typeVarAssigns), typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     for (final Type toBound : toLowerBounds) { [EOL]         if (!isAssignable(substituteTypeVariables(toBound, typeVarAssigns), type, typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] final WildcardType wildcardType = (WildcardType) type; [LINE] private static boolean isAssignable(final Type type, final WildcardType toWildcardType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toWildcardType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toWildcardType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Type[] toUpperBounds = getImplicitUpperBounds(toWildcardType); [EOL]     final Type[] toLowerBounds = getImplicitLowerBounds(toWildcardType); [EOL]     if (type instanceof WildcardType) { [EOL]         final WildcardType wildcardType = (WildcardType) type; [EOL]         final Type[] upperBounds = getImplicitUpperBounds(wildcardType); [EOL]         final Type[] lowerBounds = getImplicitLowerBounds(wildcardType); [EOL]         for (Type toBound : toUpperBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : upperBounds) { [EOL]                 if (!isAssignable(bound, toBound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         for (Type toBound : toLowerBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : lowerBounds) { [EOL]                 if (!isAssignable(toBound, bound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     for (final Type toBound : toUpperBounds) { [EOL]         if (!isAssignable(type, substituteTypeVariables(toBound, typeVarAssigns), typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     for (final Type toBound : toLowerBounds) { [EOL]         if (!isAssignable(substituteTypeVariables(toBound, typeVarAssigns), type, typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] final Type[] upperBounds = getImplicitUpperBounds(wildcardType); [LINE] private static boolean isAssignable(final Type type, final WildcardType toWildcardType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toWildcardType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toWildcardType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Type[] toUpperBounds = getImplicitUpperBounds(toWildcardType); [EOL]     final Type[] toLowerBounds = getImplicitLowerBounds(toWildcardType); [EOL]     if (type instanceof WildcardType) { [EOL]         final WildcardType wildcardType = (WildcardType) type; [EOL]         final Type[] upperBounds = getImplicitUpperBounds(wildcardType); [EOL]         final Type[] lowerBounds = getImplicitLowerBounds(wildcardType); [EOL]         for (Type toBound : toUpperBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : upperBounds) { [EOL]                 if (!isAssignable(bound, toBound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         for (Type toBound : toLowerBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : lowerBounds) { [EOL]                 if (!isAssignable(toBound, bound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     for (final Type toBound : toUpperBounds) { [EOL]         if (!isAssignable(type, substituteTypeVariables(toBound, typeVarAssigns), typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     for (final Type toBound : toLowerBounds) { [EOL]         if (!isAssignable(substituteTypeVariables(toBound, typeVarAssigns), type, typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] final Type[] lowerBounds = getImplicitLowerBounds(wildcardType); [LINE] private static boolean isAssignable(final Type type, final WildcardType toWildcardType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toWildcardType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toWildcardType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Type[] toUpperBounds = getImplicitUpperBounds(toWildcardType); [EOL]     final Type[] toLowerBounds = getImplicitLowerBounds(toWildcardType); [EOL]     if (type instanceof WildcardType) { [EOL]         final WildcardType wildcardType = (WildcardType) type; [EOL]         final Type[] upperBounds = getImplicitUpperBounds(wildcardType); [EOL]         final Type[] lowerBounds = getImplicitLowerBounds(wildcardType); [EOL]         for (Type toBound : toUpperBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : upperBounds) { [EOL]                 if (!isAssignable(bound, toBound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         for (Type toBound : toLowerBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : lowerBounds) { [EOL]                 if (!isAssignable(toBound, bound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     for (final Type toBound : toUpperBounds) { [EOL]         if (!isAssignable(type, substituteTypeVariables(toBound, typeVarAssigns), typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     for (final Type toBound : toLowerBounds) { [EOL]         if (!isAssignable(substituteTypeVariables(toBound, typeVarAssigns), type, typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] for (Type toBound : toUpperBounds) { [LINE] private static boolean isAssignable(final Type type, final WildcardType toWildcardType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toWildcardType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toWildcardType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Type[] toUpperBounds = getImplicitUpperBounds(toWildcardType); [EOL]     final Type[] toLowerBounds = getImplicitLowerBounds(toWildcardType); [EOL]     if (type instanceof WildcardType) { [EOL]         final WildcardType wildcardType = (WildcardType) type; [EOL]         final Type[] upperBounds = getImplicitUpperBounds(wildcardType); [EOL]         final Type[] lowerBounds = getImplicitLowerBounds(wildcardType); [EOL]         for (Type toBound : toUpperBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : upperBounds) { [EOL]                 if (!isAssignable(bound, toBound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         for (Type toBound : toLowerBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : lowerBounds) { [EOL]                 if (!isAssignable(toBound, bound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     for (final Type toBound : toUpperBounds) { [EOL]         if (!isAssignable(type, substituteTypeVariables(toBound, typeVarAssigns), typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     for (final Type toBound : toLowerBounds) { [EOL]         if (!isAssignable(substituteTypeVariables(toBound, typeVarAssigns), type, typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] toBound = substituteTypeVariables(toBound, typeVarAssigns); [LINE] private static boolean isAssignable(final Type type, final WildcardType toWildcardType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toWildcardType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toWildcardType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Type[] toUpperBounds = getImplicitUpperBounds(toWildcardType); [EOL]     final Type[] toLowerBounds = getImplicitLowerBounds(toWildcardType); [EOL]     if (type instanceof WildcardType) { [EOL]         final WildcardType wildcardType = (WildcardType) type; [EOL]         final Type[] upperBounds = getImplicitUpperBounds(wildcardType); [EOL]         final Type[] lowerBounds = getImplicitLowerBounds(wildcardType); [EOL]         for (Type toBound : toUpperBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : upperBounds) { [EOL]                 if (!isAssignable(bound, toBound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         for (Type toBound : toLowerBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : lowerBounds) { [EOL]                 if (!isAssignable(toBound, bound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     for (final Type toBound : toUpperBounds) { [EOL]         if (!isAssignable(type, substituteTypeVariables(toBound, typeVarAssigns), typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     for (final Type toBound : toLowerBounds) { [EOL]         if (!isAssignable(substituteTypeVariables(toBound, typeVarAssigns), type, typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] for (final Type bound : upperBounds) { [LINE] private static boolean isAssignable(final Type type, final WildcardType toWildcardType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toWildcardType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toWildcardType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Type[] toUpperBounds = getImplicitUpperBounds(toWildcardType); [EOL]     final Type[] toLowerBounds = getImplicitLowerBounds(toWildcardType); [EOL]     if (type instanceof WildcardType) { [EOL]         final WildcardType wildcardType = (WildcardType) type; [EOL]         final Type[] upperBounds = getImplicitUpperBounds(wildcardType); [EOL]         final Type[] lowerBounds = getImplicitLowerBounds(wildcardType); [EOL]         for (Type toBound : toUpperBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : upperBounds) { [EOL]                 if (!isAssignable(bound, toBound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         for (Type toBound : toLowerBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : lowerBounds) { [EOL]                 if (!isAssignable(toBound, bound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     for (final Type toBound : toUpperBounds) { [EOL]         if (!isAssignable(type, substituteTypeVariables(toBound, typeVarAssigns), typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     for (final Type toBound : toLowerBounds) { [EOL]         if (!isAssignable(substituteTypeVariables(toBound, typeVarAssigns), type, typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] if (!isAssignable(bound, toBound, typeVarAssigns)) { [LINE] private static boolean isAssignable(final Type type, final WildcardType toWildcardType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toWildcardType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toWildcardType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Type[] toUpperBounds = getImplicitUpperBounds(toWildcardType); [EOL]     final Type[] toLowerBounds = getImplicitLowerBounds(toWildcardType); [EOL]     if (type instanceof WildcardType) { [EOL]         final WildcardType wildcardType = (WildcardType) type; [EOL]         final Type[] upperBounds = getImplicitUpperBounds(wildcardType); [EOL]         final Type[] lowerBounds = getImplicitLowerBounds(wildcardType); [EOL]         for (Type toBound : toUpperBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : upperBounds) { [EOL]                 if (!isAssignable(bound, toBound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         for (Type toBound : toLowerBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : lowerBounds) { [EOL]                 if (!isAssignable(toBound, bound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     for (final Type toBound : toUpperBounds) { [EOL]         if (!isAssignable(type, substituteTypeVariables(toBound, typeVarAssigns), typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     for (final Type toBound : toLowerBounds) { [EOL]         if (!isAssignable(substituteTypeVariables(toBound, typeVarAssigns), type, typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] return false; [LINE] private static boolean isAssignable(final Type type, final WildcardType toWildcardType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toWildcardType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toWildcardType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Type[] toUpperBounds = getImplicitUpperBounds(toWildcardType); [EOL]     final Type[] toLowerBounds = getImplicitLowerBounds(toWildcardType); [EOL]     if (type instanceof WildcardType) { [EOL]         final WildcardType wildcardType = (WildcardType) type; [EOL]         final Type[] upperBounds = getImplicitUpperBounds(wildcardType); [EOL]         final Type[] lowerBounds = getImplicitLowerBounds(wildcardType); [EOL]         for (Type toBound : toUpperBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : upperBounds) { [EOL]                 if (!isAssignable(bound, toBound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         for (Type toBound : toLowerBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : lowerBounds) { [EOL]                 if (!isAssignable(toBound, bound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     for (final Type toBound : toUpperBounds) { [EOL]         if (!isAssignable(type, substituteTypeVariables(toBound, typeVarAssigns), typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     for (final Type toBound : toLowerBounds) { [EOL]         if (!isAssignable(substituteTypeVariables(toBound, typeVarAssigns), type, typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] for (Type toBound : toLowerBounds) { [LINE] private static boolean isAssignable(final Type type, final WildcardType toWildcardType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toWildcardType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toWildcardType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Type[] toUpperBounds = getImplicitUpperBounds(toWildcardType); [EOL]     final Type[] toLowerBounds = getImplicitLowerBounds(toWildcardType); [EOL]     if (type instanceof WildcardType) { [EOL]         final WildcardType wildcardType = (WildcardType) type; [EOL]         final Type[] upperBounds = getImplicitUpperBounds(wildcardType); [EOL]         final Type[] lowerBounds = getImplicitLowerBounds(wildcardType); [EOL]         for (Type toBound : toUpperBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : upperBounds) { [EOL]                 if (!isAssignable(bound, toBound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         for (Type toBound : toLowerBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : lowerBounds) { [EOL]                 if (!isAssignable(toBound, bound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     for (final Type toBound : toUpperBounds) { [EOL]         if (!isAssignable(type, substituteTypeVariables(toBound, typeVarAssigns), typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     for (final Type toBound : toLowerBounds) { [EOL]         if (!isAssignable(substituteTypeVariables(toBound, typeVarAssigns), type, typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] toBound = substituteTypeVariables(toBound, typeVarAssigns); [LINE] private static boolean isAssignable(final Type type, final WildcardType toWildcardType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toWildcardType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toWildcardType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Type[] toUpperBounds = getImplicitUpperBounds(toWildcardType); [EOL]     final Type[] toLowerBounds = getImplicitLowerBounds(toWildcardType); [EOL]     if (type instanceof WildcardType) { [EOL]         final WildcardType wildcardType = (WildcardType) type; [EOL]         final Type[] upperBounds = getImplicitUpperBounds(wildcardType); [EOL]         final Type[] lowerBounds = getImplicitLowerBounds(wildcardType); [EOL]         for (Type toBound : toUpperBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : upperBounds) { [EOL]                 if (!isAssignable(bound, toBound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         for (Type toBound : toLowerBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : lowerBounds) { [EOL]                 if (!isAssignable(toBound, bound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     for (final Type toBound : toUpperBounds) { [EOL]         if (!isAssignable(type, substituteTypeVariables(toBound, typeVarAssigns), typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     for (final Type toBound : toLowerBounds) { [EOL]         if (!isAssignable(substituteTypeVariables(toBound, typeVarAssigns), type, typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] for (final Type bound : lowerBounds) { [LINE] private static boolean isAssignable(final Type type, final WildcardType toWildcardType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toWildcardType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toWildcardType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Type[] toUpperBounds = getImplicitUpperBounds(toWildcardType); [EOL]     final Type[] toLowerBounds = getImplicitLowerBounds(toWildcardType); [EOL]     if (type instanceof WildcardType) { [EOL]         final WildcardType wildcardType = (WildcardType) type; [EOL]         final Type[] upperBounds = getImplicitUpperBounds(wildcardType); [EOL]         final Type[] lowerBounds = getImplicitLowerBounds(wildcardType); [EOL]         for (Type toBound : toUpperBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : upperBounds) { [EOL]                 if (!isAssignable(bound, toBound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         for (Type toBound : toLowerBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : lowerBounds) { [EOL]                 if (!isAssignable(toBound, bound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     for (final Type toBound : toUpperBounds) { [EOL]         if (!isAssignable(type, substituteTypeVariables(toBound, typeVarAssigns), typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     for (final Type toBound : toLowerBounds) { [EOL]         if (!isAssignable(substituteTypeVariables(toBound, typeVarAssigns), type, typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] if (!isAssignable(toBound, bound, typeVarAssigns)) { [LINE] private static boolean isAssignable(final Type type, final WildcardType toWildcardType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toWildcardType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toWildcardType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Type[] toUpperBounds = getImplicitUpperBounds(toWildcardType); [EOL]     final Type[] toLowerBounds = getImplicitLowerBounds(toWildcardType); [EOL]     if (type instanceof WildcardType) { [EOL]         final WildcardType wildcardType = (WildcardType) type; [EOL]         final Type[] upperBounds = getImplicitUpperBounds(wildcardType); [EOL]         final Type[] lowerBounds = getImplicitLowerBounds(wildcardType); [EOL]         for (Type toBound : toUpperBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : upperBounds) { [EOL]                 if (!isAssignable(bound, toBound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         for (Type toBound : toLowerBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : lowerBounds) { [EOL]                 if (!isAssignable(toBound, bound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     for (final Type toBound : toUpperBounds) { [EOL]         if (!isAssignable(type, substituteTypeVariables(toBound, typeVarAssigns), typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     for (final Type toBound : toLowerBounds) { [EOL]         if (!isAssignable(substituteTypeVariables(toBound, typeVarAssigns), type, typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] return false; [LINE] private static boolean isAssignable(final Type type, final WildcardType toWildcardType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toWildcardType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toWildcardType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Type[] toUpperBounds = getImplicitUpperBounds(toWildcardType); [EOL]     final Type[] toLowerBounds = getImplicitLowerBounds(toWildcardType); [EOL]     if (type instanceof WildcardType) { [EOL]         final WildcardType wildcardType = (WildcardType) type; [EOL]         final Type[] upperBounds = getImplicitUpperBounds(wildcardType); [EOL]         final Type[] lowerBounds = getImplicitLowerBounds(wildcardType); [EOL]         for (Type toBound : toUpperBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : upperBounds) { [EOL]                 if (!isAssignable(bound, toBound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         for (Type toBound : toLowerBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : lowerBounds) { [EOL]                 if (!isAssignable(toBound, bound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     for (final Type toBound : toUpperBounds) { [EOL]         if (!isAssignable(type, substituteTypeVariables(toBound, typeVarAssigns), typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     for (final Type toBound : toLowerBounds) { [EOL]         if (!isAssignable(substituteTypeVariables(toBound, typeVarAssigns), type, typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] return true; [LINE] private static boolean isAssignable(final Type type, final WildcardType toWildcardType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toWildcardType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toWildcardType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Type[] toUpperBounds = getImplicitUpperBounds(toWildcardType); [EOL]     final Type[] toLowerBounds = getImplicitLowerBounds(toWildcardType); [EOL]     if (type instanceof WildcardType) { [EOL]         final WildcardType wildcardType = (WildcardType) type; [EOL]         final Type[] upperBounds = getImplicitUpperBounds(wildcardType); [EOL]         final Type[] lowerBounds = getImplicitLowerBounds(wildcardType); [EOL]         for (Type toBound : toUpperBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : upperBounds) { [EOL]                 if (!isAssignable(bound, toBound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         for (Type toBound : toLowerBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : lowerBounds) { [EOL]                 if (!isAssignable(toBound, bound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     for (final Type toBound : toUpperBounds) { [EOL]         if (!isAssignable(type, substituteTypeVariables(toBound, typeVarAssigns), typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     for (final Type toBound : toLowerBounds) { [EOL]         if (!isAssignable(substituteTypeVariables(toBound, typeVarAssigns), type, typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] for (final Type toBound : toUpperBounds) { [LINE] private static boolean isAssignable(final Type type, final WildcardType toWildcardType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toWildcardType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toWildcardType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Type[] toUpperBounds = getImplicitUpperBounds(toWildcardType); [EOL]     final Type[] toLowerBounds = getImplicitLowerBounds(toWildcardType); [EOL]     if (type instanceof WildcardType) { [EOL]         final WildcardType wildcardType = (WildcardType) type; [EOL]         final Type[] upperBounds = getImplicitUpperBounds(wildcardType); [EOL]         final Type[] lowerBounds = getImplicitLowerBounds(wildcardType); [EOL]         for (Type toBound : toUpperBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : upperBounds) { [EOL]                 if (!isAssignable(bound, toBound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         for (Type toBound : toLowerBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : lowerBounds) { [EOL]                 if (!isAssignable(toBound, bound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     for (final Type toBound : toUpperBounds) { [EOL]         if (!isAssignable(type, substituteTypeVariables(toBound, typeVarAssigns), typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     for (final Type toBound : toLowerBounds) { [EOL]         if (!isAssignable(substituteTypeVariables(toBound, typeVarAssigns), type, typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] if (!isAssignable(type, substituteTypeVariables(toBound, typeVarAssigns), [LINE] private static boolean isAssignable(final Type type, final WildcardType toWildcardType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toWildcardType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toWildcardType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Type[] toUpperBounds = getImplicitUpperBounds(toWildcardType); [EOL]     final Type[] toLowerBounds = getImplicitLowerBounds(toWildcardType); [EOL]     if (type instanceof WildcardType) { [EOL]         final WildcardType wildcardType = (WildcardType) type; [EOL]         final Type[] upperBounds = getImplicitUpperBounds(wildcardType); [EOL]         final Type[] lowerBounds = getImplicitLowerBounds(wildcardType); [EOL]         for (Type toBound : toUpperBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : upperBounds) { [EOL]                 if (!isAssignable(bound, toBound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         for (Type toBound : toLowerBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : lowerBounds) { [EOL]                 if (!isAssignable(toBound, bound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     for (final Type toBound : toUpperBounds) { [EOL]         if (!isAssignable(type, substituteTypeVariables(toBound, typeVarAssigns), typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     for (final Type toBound : toLowerBounds) { [EOL]         if (!isAssignable(substituteTypeVariables(toBound, typeVarAssigns), type, typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] return false; [LINE] private static boolean isAssignable(final Type type, final WildcardType toWildcardType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toWildcardType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toWildcardType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Type[] toUpperBounds = getImplicitUpperBounds(toWildcardType); [EOL]     final Type[] toLowerBounds = getImplicitLowerBounds(toWildcardType); [EOL]     if (type instanceof WildcardType) { [EOL]         final WildcardType wildcardType = (WildcardType) type; [EOL]         final Type[] upperBounds = getImplicitUpperBounds(wildcardType); [EOL]         final Type[] lowerBounds = getImplicitLowerBounds(wildcardType); [EOL]         for (Type toBound : toUpperBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : upperBounds) { [EOL]                 if (!isAssignable(bound, toBound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         for (Type toBound : toLowerBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : lowerBounds) { [EOL]                 if (!isAssignable(toBound, bound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     for (final Type toBound : toUpperBounds) { [EOL]         if (!isAssignable(type, substituteTypeVariables(toBound, typeVarAssigns), typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     for (final Type toBound : toLowerBounds) { [EOL]         if (!isAssignable(substituteTypeVariables(toBound, typeVarAssigns), type, typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] for (final Type toBound : toLowerBounds) { [LINE] private static boolean isAssignable(final Type type, final WildcardType toWildcardType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toWildcardType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toWildcardType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Type[] toUpperBounds = getImplicitUpperBounds(toWildcardType); [EOL]     final Type[] toLowerBounds = getImplicitLowerBounds(toWildcardType); [EOL]     if (type instanceof WildcardType) { [EOL]         final WildcardType wildcardType = (WildcardType) type; [EOL]         final Type[] upperBounds = getImplicitUpperBounds(wildcardType); [EOL]         final Type[] lowerBounds = getImplicitLowerBounds(wildcardType); [EOL]         for (Type toBound : toUpperBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : upperBounds) { [EOL]                 if (!isAssignable(bound, toBound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         for (Type toBound : toLowerBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : lowerBounds) { [EOL]                 if (!isAssignable(toBound, bound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     for (final Type toBound : toUpperBounds) { [EOL]         if (!isAssignable(type, substituteTypeVariables(toBound, typeVarAssigns), typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     for (final Type toBound : toLowerBounds) { [EOL]         if (!isAssignable(substituteTypeVariables(toBound, typeVarAssigns), type, typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] if (!isAssignable(substituteTypeVariables(toBound, typeVarAssigns), type, [LINE] private static boolean isAssignable(final Type type, final WildcardType toWildcardType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toWildcardType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toWildcardType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Type[] toUpperBounds = getImplicitUpperBounds(toWildcardType); [EOL]     final Type[] toLowerBounds = getImplicitLowerBounds(toWildcardType); [EOL]     if (type instanceof WildcardType) { [EOL]         final WildcardType wildcardType = (WildcardType) type; [EOL]         final Type[] upperBounds = getImplicitUpperBounds(wildcardType); [EOL]         final Type[] lowerBounds = getImplicitLowerBounds(wildcardType); [EOL]         for (Type toBound : toUpperBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : upperBounds) { [EOL]                 if (!isAssignable(bound, toBound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         for (Type toBound : toLowerBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : lowerBounds) { [EOL]                 if (!isAssignable(toBound, bound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     for (final Type toBound : toUpperBounds) { [EOL]         if (!isAssignable(type, substituteTypeVariables(toBound, typeVarAssigns), typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     for (final Type toBound : toLowerBounds) { [EOL]         if (!isAssignable(substituteTypeVariables(toBound, typeVarAssigns), type, typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] return false; [LINE] private static boolean isAssignable(final Type type, final WildcardType toWildcardType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toWildcardType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toWildcardType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Type[] toUpperBounds = getImplicitUpperBounds(toWildcardType); [EOL]     final Type[] toLowerBounds = getImplicitLowerBounds(toWildcardType); [EOL]     if (type instanceof WildcardType) { [EOL]         final WildcardType wildcardType = (WildcardType) type; [EOL]         final Type[] upperBounds = getImplicitUpperBounds(wildcardType); [EOL]         final Type[] lowerBounds = getImplicitLowerBounds(wildcardType); [EOL]         for (Type toBound : toUpperBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : upperBounds) { [EOL]                 if (!isAssignable(bound, toBound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         for (Type toBound : toLowerBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : lowerBounds) { [EOL]                 if (!isAssignable(toBound, bound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     for (final Type toBound : toUpperBounds) { [EOL]         if (!isAssignable(type, substituteTypeVariables(toBound, typeVarAssigns), typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     for (final Type toBound : toLowerBounds) { [EOL]         if (!isAssignable(substituteTypeVariables(toBound, typeVarAssigns), type, typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] return true; [LINE] private static boolean isAssignable(final Type type, final WildcardType toWildcardType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toWildcardType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toWildcardType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Type[] toUpperBounds = getImplicitUpperBounds(toWildcardType); [EOL]     final Type[] toLowerBounds = getImplicitLowerBounds(toWildcardType); [EOL]     if (type instanceof WildcardType) { [EOL]         final WildcardType wildcardType = (WildcardType) type; [EOL]         final Type[] upperBounds = getImplicitUpperBounds(wildcardType); [EOL]         final Type[] lowerBounds = getImplicitLowerBounds(wildcardType); [EOL]         for (Type toBound : toUpperBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : upperBounds) { [EOL]                 if (!isAssignable(bound, toBound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         for (Type toBound : toLowerBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : lowerBounds) { [EOL]                 if (!isAssignable(toBound, bound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     for (final Type toBound : toUpperBounds) { [EOL]         if (!isAssignable(type, substituteTypeVariables(toBound, typeVarAssigns), typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     for (final Type toBound : toLowerBounds) { [EOL]         if (!isAssignable(substituteTypeVariables(toBound, typeVarAssigns), type, typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] private static Type substituteTypeVariables(final Type type, final Map<TypeVariable<?>, Type> typeVarAssigns) { [LINE] private static Type substituteTypeVariables(final Type type, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type instanceof TypeVariable<?> && typeVarAssigns != null) { [EOL]         final Type replacementType = typeVarAssigns.get(type); [EOL]         if (replacementType == null) { [EOL]             throw new IllegalArgumentException("missing assignment type for type variable " + type); [EOL]         } [EOL]         return replacementType; [EOL]     } [EOL]     return type; [EOL] } 
 [LINE] if (type instanceof TypeVariable<?> && typeVarAssigns != null) { [LINE] private static Type substituteTypeVariables(final Type type, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type instanceof TypeVariable<?> && typeVarAssigns != null) { [EOL]         final Type replacementType = typeVarAssigns.get(type); [EOL]         if (replacementType == null) { [EOL]             throw new IllegalArgumentException("missing assignment type for type variable " + type); [EOL]         } [EOL]         return replacementType; [EOL]     } [EOL]     return type; [EOL] } 
 [LINE] return type; [LINE] private static Type substituteTypeVariables(final Type type, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type instanceof TypeVariable<?> && typeVarAssigns != null) { [EOL]         final Type replacementType = typeVarAssigns.get(type); [EOL]         if (replacementType == null) { [EOL]             throw new IllegalArgumentException("missing assignment type for type variable " + type); [EOL]         } [EOL]         return replacementType; [EOL]     } [EOL]     return type; [EOL] } 
 [LINE] return getTypeArguments((ParameterizedType) type, toClass, subtypeVarAssigns); [LINE] private static Map<TypeVariable<?>, Type> getTypeArguments(final Type type, final Class<?> toClass, final Map<TypeVariable<?>, Type> subtypeVarAssigns) { [EOL]     if (type instanceof Class<?>) { [EOL]         return getTypeArguments((Class<?>) type, toClass, subtypeVarAssigns); [EOL]     } [EOL]     if (type instanceof ParameterizedType) { [EOL]         return getTypeArguments((ParameterizedType) type, toClass, subtypeVarAssigns); [EOL]     } [EOL]     if (type instanceof GenericArrayType) { [EOL]         return getTypeArguments(((GenericArrayType) type).getGenericComponentType(), toClass.isArray() ? toClass.getComponentType() : toClass, subtypeVarAssigns); [EOL]     } [EOL]     if (type instanceof WildcardType) { [EOL]         for (final Type bound : getImplicitUpperBounds((WildcardType) type)) { [EOL]             if (isAssignable(bound, toClass)) { [EOL]                 return getTypeArguments(bound, toClass, subtypeVarAssigns); [EOL]             } [EOL]         } [EOL]         return null; [EOL]     } [EOL]     if (type instanceof TypeVariable<?>) { [EOL]         for (final Type bound : getImplicitBounds((TypeVariable<?>) type)) { [EOL]             if (isAssignable(bound, toClass)) { [EOL]                 return getTypeArguments(bound, toClass, subtypeVarAssigns); [EOL]             } [EOL]         } [EOL]         return null; [EOL]     } [EOL]     throw new IllegalStateException("found an unhandled type: " + type); [EOL] } 
 [LINE] final Type typeArg = typeArgs[i]; [LINE] private static Map<TypeVariable<?>, Type> getTypeArguments(final ParameterizedType parameterizedType, final Class<?> toClass, final Map<TypeVariable<?>, Type> subtypeVarAssigns) { [EOL]     final Class<?> cls = getRawType(parameterizedType); [EOL]     if (!isAssignable(cls, toClass)) { [EOL]         return null; [EOL]     } [EOL]     final Type ownerType = parameterizedType.getOwnerType(); [EOL]     Map<TypeVariable<?>, Type> typeVarAssigns; [EOL]     if (ownerType instanceof ParameterizedType) { [EOL]         final ParameterizedType parameterizedOwnerType = (ParameterizedType) ownerType; [EOL]         typeVarAssigns = getTypeArguments(parameterizedOwnerType, getRawType(parameterizedOwnerType), subtypeVarAssigns); [EOL]     } else { [EOL]         typeVarAssigns = subtypeVarAssigns == null ? new HashMap<TypeVariable<?>, Type>() : new HashMap<TypeVariable<?>, Type>(subtypeVarAssigns); [EOL]     } [EOL]     final Type[] typeArgs = parameterizedType.getActualTypeArguments(); [EOL]     final TypeVariable<?>[] typeParams = cls.getTypeParameters(); [EOL]     for (int i = 0; i < typeParams.length; i++) { [EOL]         final Type typeArg = typeArgs[i]; [EOL]         typeVarAssigns.put(typeParams[i], typeVarAssigns.containsKey(typeArg) ? typeVarAssigns.get(typeArg) : typeArg); [EOL]     } [EOL]     if (toClass.equals(cls)) { [EOL]         return typeVarAssigns; [EOL]     } [EOL]     return getTypeArguments(getClosestParentType(cls, toClass), toClass, typeVarAssigns); [EOL] } 
 [LINE] typeVarAssigns.put(typeParams[i], typeVarAssigns.containsKey(typeArg) ? typeVarAssigns [LINE] private static Map<TypeVariable<?>, Type> getTypeArguments(final ParameterizedType parameterizedType, final Class<?> toClass, final Map<TypeVariable<?>, Type> subtypeVarAssigns) { [EOL]     final Class<?> cls = getRawType(parameterizedType); [EOL]     if (!isAssignable(cls, toClass)) { [EOL]         return null; [EOL]     } [EOL]     final Type ownerType = parameterizedType.getOwnerType(); [EOL]     Map<TypeVariable<?>, Type> typeVarAssigns; [EOL]     if (ownerType instanceof ParameterizedType) { [EOL]         final ParameterizedType parameterizedOwnerType = (ParameterizedType) ownerType; [EOL]         typeVarAssigns = getTypeArguments(parameterizedOwnerType, getRawType(parameterizedOwnerType), subtypeVarAssigns); [EOL]     } else { [EOL]         typeVarAssigns = subtypeVarAssigns == null ? new HashMap<TypeVariable<?>, Type>() : new HashMap<TypeVariable<?>, Type>(subtypeVarAssigns); [EOL]     } [EOL]     final Type[] typeArgs = parameterizedType.getActualTypeArguments(); [EOL]     final TypeVariable<?>[] typeParams = cls.getTypeParameters(); [EOL]     for (int i = 0; i < typeParams.length; i++) { [EOL]         final Type typeArg = typeArgs[i]; [EOL]         typeVarAssigns.put(typeParams[i], typeVarAssigns.containsKey(typeArg) ? typeVarAssigns.get(typeArg) : typeArg); [EOL]     } [EOL]     if (toClass.equals(cls)) { [EOL]         return typeVarAssigns; [EOL]     } [EOL]     return getTypeArguments(getClosestParentType(cls, toClass), toClass, typeVarAssigns); [EOL] } 
 [LINE] return getTypeArguments(getClosestParentType(cls, toClass), toClass, typeVarAssigns); [LINE] private static Map<TypeVariable<?>, Type> getTypeArguments(final ParameterizedType parameterizedType, final Class<?> toClass, final Map<TypeVariable<?>, Type> subtypeVarAssigns) { [EOL]     final Class<?> cls = getRawType(parameterizedType); [EOL]     if (!isAssignable(cls, toClass)) { [EOL]         return null; [EOL]     } [EOL]     final Type ownerType = parameterizedType.getOwnerType(); [EOL]     Map<TypeVariable<?>, Type> typeVarAssigns; [EOL]     if (ownerType instanceof ParameterizedType) { [EOL]         final ParameterizedType parameterizedOwnerType = (ParameterizedType) ownerType; [EOL]         typeVarAssigns = getTypeArguments(parameterizedOwnerType, getRawType(parameterizedOwnerType), subtypeVarAssigns); [EOL]     } else { [EOL]         typeVarAssigns = subtypeVarAssigns == null ? new HashMap<TypeVariable<?>, Type>() : new HashMap<TypeVariable<?>, Type>(subtypeVarAssigns); [EOL]     } [EOL]     final Type[] typeArgs = parameterizedType.getActualTypeArguments(); [EOL]     final TypeVariable<?>[] typeParams = cls.getTypeParameters(); [EOL]     for (int i = 0; i < typeParams.length; i++) { [EOL]         final Type typeArg = typeArgs[i]; [EOL]         typeVarAssigns.put(typeParams[i], typeVarAssigns.containsKey(typeArg) ? typeVarAssigns.get(typeArg) : typeArg); [EOL]     } [EOL]     if (toClass.equals(cls)) { [EOL]         return typeVarAssigns; [EOL]     } [EOL]     return getTypeArguments(getClosestParentType(cls, toClass), toClass, typeVarAssigns); [EOL] } 
 [LINE] if (toClass.isPrimitive()) { [LINE] private static Map<TypeVariable<?>, Type> getTypeArguments(Class<?> cls, final Class<?> toClass, final Map<TypeVariable<?>, Type> subtypeVarAssigns) { [EOL]     if (!isAssignable(cls, toClass)) { [EOL]         return null; [EOL]     } [EOL]     if (cls.isPrimitive()) { [EOL]         if (toClass.isPrimitive()) { [EOL]             return new HashMap<TypeVariable<?>, Type>(); [EOL]         } [EOL]         cls = ClassUtils.primitiveToWrapper(cls); [EOL]     } [EOL]     final HashMap<TypeVariable<?>, Type> typeVarAssigns = subtypeVarAssigns == null ? new HashMap<TypeVariable<?>, Type>() : new HashMap<TypeVariable<?>, Type>(subtypeVarAssigns); [EOL]     if (toClass.equals(cls)) { [EOL]         return typeVarAssigns; [EOL]     } [EOL]     return getTypeArguments(getClosestParentType(cls, toClass), toClass, typeVarAssigns); [EOL] } 
 [LINE] cls = ClassUtils.primitiveToWrapper(cls); [LINE] private static Map<TypeVariable<?>, Type> getTypeArguments(Class<?> cls, final Class<?> toClass, final Map<TypeVariable<?>, Type> subtypeVarAssigns) { [EOL]     if (!isAssignable(cls, toClass)) { [EOL]         return null; [EOL]     } [EOL]     if (cls.isPrimitive()) { [EOL]         if (toClass.isPrimitive()) { [EOL]             return new HashMap<TypeVariable<?>, Type>(); [EOL]         } [EOL]         cls = ClassUtils.primitiveToWrapper(cls); [EOL]     } [EOL]     final HashMap<TypeVariable<?>, Type> typeVarAssigns = subtypeVarAssigns == null ? new HashMap<TypeVariable<?>, Type>() : new HashMap<TypeVariable<?>, Type>(subtypeVarAssigns); [EOL]     if (toClass.equals(cls)) { [EOL]         return typeVarAssigns; [EOL]     } [EOL]     return getTypeArguments(getClosestParentType(cls, toClass), toClass, typeVarAssigns); [EOL] } 
 [LINE] final Type midType = getClosestParentType(cls, superClass); [LINE] public static Map<TypeVariable<?>, Type> determineTypeArguments(final Class<?> cls, final ParameterizedType superType) { [EOL]     final Class<?> superClass = getRawType(superType); [EOL]     if (!isAssignable(cls, superClass)) { [EOL]         return null; [EOL]     } [EOL]     if (cls.equals(superClass)) { [EOL]         return getTypeArguments(superType, superClass, null); [EOL]     } [EOL]     final Type midType = getClosestParentType(cls, superClass); [EOL]     if (midType instanceof Class<?>) { [EOL]         return determineTypeArguments((Class<?>) midType, superType); [EOL]     } [EOL]     final ParameterizedType midParameterizedType = (ParameterizedType) midType; [EOL]     final Class<?> midClass = getRawType(midParameterizedType); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = determineTypeArguments(midClass, superType); [EOL]     mapTypeVariablesToArguments(cls, midParameterizedType, typeVarAssigns); [EOL]     return typeVarAssigns; [EOL] } 
 [LINE] if (midType instanceof Class<?>) { [LINE] public static Map<TypeVariable<?>, Type> determineTypeArguments(final Class<?> cls, final ParameterizedType superType) { [EOL]     final Class<?> superClass = getRawType(superType); [EOL]     if (!isAssignable(cls, superClass)) { [EOL]         return null; [EOL]     } [EOL]     if (cls.equals(superClass)) { [EOL]         return getTypeArguments(superType, superClass, null); [EOL]     } [EOL]     final Type midType = getClosestParentType(cls, superClass); [EOL]     if (midType instanceof Class<?>) { [EOL]         return determineTypeArguments((Class<?>) midType, superType); [EOL]     } [EOL]     final ParameterizedType midParameterizedType = (ParameterizedType) midType; [EOL]     final Class<?> midClass = getRawType(midParameterizedType); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = determineTypeArguments(midClass, superType); [EOL]     mapTypeVariablesToArguments(cls, midParameterizedType, typeVarAssigns); [EOL]     return typeVarAssigns; [EOL] } 
 [LINE] final ParameterizedType midParameterizedType = (ParameterizedType) midType; [LINE] public static Map<TypeVariable<?>, Type> determineTypeArguments(final Class<?> cls, final ParameterizedType superType) { [EOL]     final Class<?> superClass = getRawType(superType); [EOL]     if (!isAssignable(cls, superClass)) { [EOL]         return null; [EOL]     } [EOL]     if (cls.equals(superClass)) { [EOL]         return getTypeArguments(superType, superClass, null); [EOL]     } [EOL]     final Type midType = getClosestParentType(cls, superClass); [EOL]     if (midType instanceof Class<?>) { [EOL]         return determineTypeArguments((Class<?>) midType, superType); [EOL]     } [EOL]     final ParameterizedType midParameterizedType = (ParameterizedType) midType; [EOL]     final Class<?> midClass = getRawType(midParameterizedType); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = determineTypeArguments(midClass, superType); [EOL]     mapTypeVariablesToArguments(cls, midParameterizedType, typeVarAssigns); [EOL]     return typeVarAssigns; [EOL] } 
 [LINE] final Class<?> midClass = getRawType(midParameterizedType); [LINE] public static Map<TypeVariable<?>, Type> determineTypeArguments(final Class<?> cls, final ParameterizedType superType) { [EOL]     final Class<?> superClass = getRawType(superType); [EOL]     if (!isAssignable(cls, superClass)) { [EOL]         return null; [EOL]     } [EOL]     if (cls.equals(superClass)) { [EOL]         return getTypeArguments(superType, superClass, null); [EOL]     } [EOL]     final Type midType = getClosestParentType(cls, superClass); [EOL]     if (midType instanceof Class<?>) { [EOL]         return determineTypeArguments((Class<?>) midType, superType); [EOL]     } [EOL]     final ParameterizedType midParameterizedType = (ParameterizedType) midType; [EOL]     final Class<?> midClass = getRawType(midParameterizedType); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = determineTypeArguments(midClass, superType); [EOL]     mapTypeVariablesToArguments(cls, midParameterizedType, typeVarAssigns); [EOL]     return typeVarAssigns; [EOL] } 
 [LINE] final Map<TypeVariable<?>, Type> typeVarAssigns = determineTypeArguments(midClass, superType); [LINE] public static Map<TypeVariable<?>, Type> determineTypeArguments(final Class<?> cls, final ParameterizedType superType) { [EOL]     final Class<?> superClass = getRawType(superType); [EOL]     if (!isAssignable(cls, superClass)) { [EOL]         return null; [EOL]     } [EOL]     if (cls.equals(superClass)) { [EOL]         return getTypeArguments(superType, superClass, null); [EOL]     } [EOL]     final Type midType = getClosestParentType(cls, superClass); [EOL]     if (midType instanceof Class<?>) { [EOL]         return determineTypeArguments((Class<?>) midType, superType); [EOL]     } [EOL]     final ParameterizedType midParameterizedType = (ParameterizedType) midType; [EOL]     final Class<?> midClass = getRawType(midParameterizedType); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = determineTypeArguments(midClass, superType); [EOL]     mapTypeVariablesToArguments(cls, midParameterizedType, typeVarAssigns); [EOL]     return typeVarAssigns; [EOL] } 
 [LINE] mapTypeVariablesToArguments(cls, midParameterizedType, typeVarAssigns); [LINE] public static Map<TypeVariable<?>, Type> determineTypeArguments(final Class<?> cls, final ParameterizedType superType) { [EOL]     final Class<?> superClass = getRawType(superType); [EOL]     if (!isAssignable(cls, superClass)) { [EOL]         return null; [EOL]     } [EOL]     if (cls.equals(superClass)) { [EOL]         return getTypeArguments(superType, superClass, null); [EOL]     } [EOL]     final Type midType = getClosestParentType(cls, superClass); [EOL]     if (midType instanceof Class<?>) { [EOL]         return determineTypeArguments((Class<?>) midType, superType); [EOL]     } [EOL]     final ParameterizedType midParameterizedType = (ParameterizedType) midType; [EOL]     final Class<?> midClass = getRawType(midParameterizedType); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = determineTypeArguments(midClass, superType); [EOL]     mapTypeVariablesToArguments(cls, midParameterizedType, typeVarAssigns); [EOL]     return typeVarAssigns; [EOL] } 
 [LINE] return typeVarAssigns; [LINE] public static Map<TypeVariable<?>, Type> determineTypeArguments(final Class<?> cls, final ParameterizedType superType) { [EOL]     final Class<?> superClass = getRawType(superType); [EOL]     if (!isAssignable(cls, superClass)) { [EOL]         return null; [EOL]     } [EOL]     if (cls.equals(superClass)) { [EOL]         return getTypeArguments(superType, superClass, null); [EOL]     } [EOL]     final Type midType = getClosestParentType(cls, superClass); [EOL]     if (midType instanceof Class<?>) { [EOL]         return determineTypeArguments((Class<?>) midType, superType); [EOL]     } [EOL]     final ParameterizedType midParameterizedType = (ParameterizedType) midType; [EOL]     final Class<?> midClass = getRawType(midParameterizedType); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = determineTypeArguments(midClass, superType); [EOL]     mapTypeVariablesToArguments(cls, midParameterizedType, typeVarAssigns); [EOL]     return typeVarAssigns; [EOL] } 
 [LINE] private static <T> void mapTypeVariablesToArguments(final Class<T> cls, [LINE] private static <T> void mapTypeVariablesToArguments(final Class<T> cls, final ParameterizedType parameterizedType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     final Type ownerType = parameterizedType.getOwnerType(); [EOL]     if (ownerType instanceof ParameterizedType) { [EOL]         mapTypeVariablesToArguments(cls, (ParameterizedType) ownerType, typeVarAssigns); [EOL]     } [EOL]     final Type[] typeArgs = parameterizedType.getActualTypeArguments(); [EOL]     final TypeVariable<?>[] typeVars = getRawType(parameterizedType).getTypeParameters(); [EOL]     final List<TypeVariable<Class<T>>> typeVarList = Arrays.asList(cls.getTypeParameters()); [EOL]     for (int i = 0; i < typeArgs.length; i++) { [EOL]         final TypeVariable<?> typeVar = typeVars[i]; [EOL]         final Type typeArg = typeArgs[i]; [EOL]         if (typeVarList.contains(typeArg) && typeVarAssigns.containsKey(typeVar)) { [EOL]             typeVarAssigns.put((TypeVariable<?>) typeArg, typeVarAssigns.get(typeVar)); [EOL]         } [EOL]     } [EOL] } 
 [LINE] final Type ownerType = parameterizedType.getOwnerType(); [LINE] private static <T> void mapTypeVariablesToArguments(final Class<T> cls, final ParameterizedType parameterizedType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     final Type ownerType = parameterizedType.getOwnerType(); [EOL]     if (ownerType instanceof ParameterizedType) { [EOL]         mapTypeVariablesToArguments(cls, (ParameterizedType) ownerType, typeVarAssigns); [EOL]     } [EOL]     final Type[] typeArgs = parameterizedType.getActualTypeArguments(); [EOL]     final TypeVariable<?>[] typeVars = getRawType(parameterizedType).getTypeParameters(); [EOL]     final List<TypeVariable<Class<T>>> typeVarList = Arrays.asList(cls.getTypeParameters()); [EOL]     for (int i = 0; i < typeArgs.length; i++) { [EOL]         final TypeVariable<?> typeVar = typeVars[i]; [EOL]         final Type typeArg = typeArgs[i]; [EOL]         if (typeVarList.contains(typeArg) && typeVarAssigns.containsKey(typeVar)) { [EOL]             typeVarAssigns.put((TypeVariable<?>) typeArg, typeVarAssigns.get(typeVar)); [EOL]         } [EOL]     } [EOL] } 
 [LINE] if (ownerType instanceof ParameterizedType) { [LINE] private static <T> void mapTypeVariablesToArguments(final Class<T> cls, final ParameterizedType parameterizedType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     final Type ownerType = parameterizedType.getOwnerType(); [EOL]     if (ownerType instanceof ParameterizedType) { [EOL]         mapTypeVariablesToArguments(cls, (ParameterizedType) ownerType, typeVarAssigns); [EOL]     } [EOL]     final Type[] typeArgs = parameterizedType.getActualTypeArguments(); [EOL]     final TypeVariable<?>[] typeVars = getRawType(parameterizedType).getTypeParameters(); [EOL]     final List<TypeVariable<Class<T>>> typeVarList = Arrays.asList(cls.getTypeParameters()); [EOL]     for (int i = 0; i < typeArgs.length; i++) { [EOL]         final TypeVariable<?> typeVar = typeVars[i]; [EOL]         final Type typeArg = typeArgs[i]; [EOL]         if (typeVarList.contains(typeArg) && typeVarAssigns.containsKey(typeVar)) { [EOL]             typeVarAssigns.put((TypeVariable<?>) typeArg, typeVarAssigns.get(typeVar)); [EOL]         } [EOL]     } [EOL] } 
 [LINE] final Type[] typeArgs = parameterizedType.getActualTypeArguments(); [LINE] private static <T> void mapTypeVariablesToArguments(final Class<T> cls, final ParameterizedType parameterizedType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     final Type ownerType = parameterizedType.getOwnerType(); [EOL]     if (ownerType instanceof ParameterizedType) { [EOL]         mapTypeVariablesToArguments(cls, (ParameterizedType) ownerType, typeVarAssigns); [EOL]     } [EOL]     final Type[] typeArgs = parameterizedType.getActualTypeArguments(); [EOL]     final TypeVariable<?>[] typeVars = getRawType(parameterizedType).getTypeParameters(); [EOL]     final List<TypeVariable<Class<T>>> typeVarList = Arrays.asList(cls.getTypeParameters()); [EOL]     for (int i = 0; i < typeArgs.length; i++) { [EOL]         final TypeVariable<?> typeVar = typeVars[i]; [EOL]         final Type typeArg = typeArgs[i]; [EOL]         if (typeVarList.contains(typeArg) && typeVarAssigns.containsKey(typeVar)) { [EOL]             typeVarAssigns.put((TypeVariable<?>) typeArg, typeVarAssigns.get(typeVar)); [EOL]         } [EOL]     } [EOL] } 
 [LINE] final TypeVariable<?>[] typeVars = getRawType(parameterizedType).getTypeParameters(); [LINE] private static <T> void mapTypeVariablesToArguments(final Class<T> cls, final ParameterizedType parameterizedType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     final Type ownerType = parameterizedType.getOwnerType(); [EOL]     if (ownerType instanceof ParameterizedType) { [EOL]         mapTypeVariablesToArguments(cls, (ParameterizedType) ownerType, typeVarAssigns); [EOL]     } [EOL]     final Type[] typeArgs = parameterizedType.getActualTypeArguments(); [EOL]     final TypeVariable<?>[] typeVars = getRawType(parameterizedType).getTypeParameters(); [EOL]     final List<TypeVariable<Class<T>>> typeVarList = Arrays.asList(cls.getTypeParameters()); [EOL]     for (int i = 0; i < typeArgs.length; i++) { [EOL]         final TypeVariable<?> typeVar = typeVars[i]; [EOL]         final Type typeArg = typeArgs[i]; [EOL]         if (typeVarList.contains(typeArg) && typeVarAssigns.containsKey(typeVar)) { [EOL]             typeVarAssigns.put((TypeVariable<?>) typeArg, typeVarAssigns.get(typeVar)); [EOL]         } [EOL]     } [EOL] } 
 [LINE] final List<TypeVariable<Class<T>>> typeVarList = Arrays.asList(cls [LINE] private static <T> void mapTypeVariablesToArguments(final Class<T> cls, final ParameterizedType parameterizedType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     final Type ownerType = parameterizedType.getOwnerType(); [EOL]     if (ownerType instanceof ParameterizedType) { [EOL]         mapTypeVariablesToArguments(cls, (ParameterizedType) ownerType, typeVarAssigns); [EOL]     } [EOL]     final Type[] typeArgs = parameterizedType.getActualTypeArguments(); [EOL]     final TypeVariable<?>[] typeVars = getRawType(parameterizedType).getTypeParameters(); [EOL]     final List<TypeVariable<Class<T>>> typeVarList = Arrays.asList(cls.getTypeParameters()); [EOL]     for (int i = 0; i < typeArgs.length; i++) { [EOL]         final TypeVariable<?> typeVar = typeVars[i]; [EOL]         final Type typeArg = typeArgs[i]; [EOL]         if (typeVarList.contains(typeArg) && typeVarAssigns.containsKey(typeVar)) { [EOL]             typeVarAssigns.put((TypeVariable<?>) typeArg, typeVarAssigns.get(typeVar)); [EOL]         } [EOL]     } [EOL] } 
 [LINE] for (int i = 0; i < typeArgs.length; i++) { [LINE] private static <T> void mapTypeVariablesToArguments(final Class<T> cls, final ParameterizedType parameterizedType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     final Type ownerType = parameterizedType.getOwnerType(); [EOL]     if (ownerType instanceof ParameterizedType) { [EOL]         mapTypeVariablesToArguments(cls, (ParameterizedType) ownerType, typeVarAssigns); [EOL]     } [EOL]     final Type[] typeArgs = parameterizedType.getActualTypeArguments(); [EOL]     final TypeVariable<?>[] typeVars = getRawType(parameterizedType).getTypeParameters(); [EOL]     final List<TypeVariable<Class<T>>> typeVarList = Arrays.asList(cls.getTypeParameters()); [EOL]     for (int i = 0; i < typeArgs.length; i++) { [EOL]         final TypeVariable<?> typeVar = typeVars[i]; [EOL]         final Type typeArg = typeArgs[i]; [EOL]         if (typeVarList.contains(typeArg) && typeVarAssigns.containsKey(typeVar)) { [EOL]             typeVarAssigns.put((TypeVariable<?>) typeArg, typeVarAssigns.get(typeVar)); [EOL]         } [EOL]     } [EOL] } 
 [LINE] final TypeVariable<?> typeVar = typeVars[i]; [LINE] private static <T> void mapTypeVariablesToArguments(final Class<T> cls, final ParameterizedType parameterizedType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     final Type ownerType = parameterizedType.getOwnerType(); [EOL]     if (ownerType instanceof ParameterizedType) { [EOL]         mapTypeVariablesToArguments(cls, (ParameterizedType) ownerType, typeVarAssigns); [EOL]     } [EOL]     final Type[] typeArgs = parameterizedType.getActualTypeArguments(); [EOL]     final TypeVariable<?>[] typeVars = getRawType(parameterizedType).getTypeParameters(); [EOL]     final List<TypeVariable<Class<T>>> typeVarList = Arrays.asList(cls.getTypeParameters()); [EOL]     for (int i = 0; i < typeArgs.length; i++) { [EOL]         final TypeVariable<?> typeVar = typeVars[i]; [EOL]         final Type typeArg = typeArgs[i]; [EOL]         if (typeVarList.contains(typeArg) && typeVarAssigns.containsKey(typeVar)) { [EOL]             typeVarAssigns.put((TypeVariable<?>) typeArg, typeVarAssigns.get(typeVar)); [EOL]         } [EOL]     } [EOL] } 
 [LINE] final Type typeArg = typeArgs[i]; [LINE] private static <T> void mapTypeVariablesToArguments(final Class<T> cls, final ParameterizedType parameterizedType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     final Type ownerType = parameterizedType.getOwnerType(); [EOL]     if (ownerType instanceof ParameterizedType) { [EOL]         mapTypeVariablesToArguments(cls, (ParameterizedType) ownerType, typeVarAssigns); [EOL]     } [EOL]     final Type[] typeArgs = parameterizedType.getActualTypeArguments(); [EOL]     final TypeVariable<?>[] typeVars = getRawType(parameterizedType).getTypeParameters(); [EOL]     final List<TypeVariable<Class<T>>> typeVarList = Arrays.asList(cls.getTypeParameters()); [EOL]     for (int i = 0; i < typeArgs.length; i++) { [EOL]         final TypeVariable<?> typeVar = typeVars[i]; [EOL]         final Type typeArg = typeArgs[i]; [EOL]         if (typeVarList.contains(typeArg) && typeVarAssigns.containsKey(typeVar)) { [EOL]             typeVarAssigns.put((TypeVariable<?>) typeArg, typeVarAssigns.get(typeVar)); [EOL]         } [EOL]     } [EOL] } 
 [LINE] if (typeVarList.contains(typeArg) [LINE] private static <T> void mapTypeVariablesToArguments(final Class<T> cls, final ParameterizedType parameterizedType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     final Type ownerType = parameterizedType.getOwnerType(); [EOL]     if (ownerType instanceof ParameterizedType) { [EOL]         mapTypeVariablesToArguments(cls, (ParameterizedType) ownerType, typeVarAssigns); [EOL]     } [EOL]     final Type[] typeArgs = parameterizedType.getActualTypeArguments(); [EOL]     final TypeVariable<?>[] typeVars = getRawType(parameterizedType).getTypeParameters(); [EOL]     final List<TypeVariable<Class<T>>> typeVarList = Arrays.asList(cls.getTypeParameters()); [EOL]     for (int i = 0; i < typeArgs.length; i++) { [EOL]         final TypeVariable<?> typeVar = typeVars[i]; [EOL]         final Type typeArg = typeArgs[i]; [EOL]         if (typeVarList.contains(typeArg) && typeVarAssigns.containsKey(typeVar)) { [EOL]             typeVarAssigns.put((TypeVariable<?>) typeArg, typeVarAssigns.get(typeVar)); [EOL]         } [EOL]     } [EOL] } 
 [LINE] typeVarAssigns.put((TypeVariable<?>) typeArg, typeVarAssigns.get(typeVar)); [LINE] private static <T> void mapTypeVariablesToArguments(final Class<T> cls, final ParameterizedType parameterizedType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     final Type ownerType = parameterizedType.getOwnerType(); [EOL]     if (ownerType instanceof ParameterizedType) { [EOL]         mapTypeVariablesToArguments(cls, (ParameterizedType) ownerType, typeVarAssigns); [EOL]     } [EOL]     final Type[] typeArgs = parameterizedType.getActualTypeArguments(); [EOL]     final TypeVariable<?>[] typeVars = getRawType(parameterizedType).getTypeParameters(); [EOL]     final List<TypeVariable<Class<T>>> typeVarList = Arrays.asList(cls.getTypeParameters()); [EOL]     for (int i = 0; i < typeArgs.length; i++) { [EOL]         final TypeVariable<?> typeVar = typeVars[i]; [EOL]         final Type typeArg = typeArgs[i]; [EOL]         if (typeVarList.contains(typeArg) && typeVarAssigns.containsKey(typeVar)) { [EOL]             typeVarAssigns.put((TypeVariable<?>) typeArg, typeVarAssigns.get(typeVar)); [EOL]         } [EOL]     } [EOL] } 
 [LINE] final Type[] interfaceTypes = cls.getGenericInterfaces(); [LINE] private static Type getClosestParentType(final Class<?> cls, final Class<?> superClass) { [EOL]     if (superClass.isInterface()) { [EOL]         final Type[] interfaceTypes = cls.getGenericInterfaces(); [EOL]         Type genericInterface = null; [EOL]         for (final Type midType : interfaceTypes) { [EOL]             Class<?> midClass = null; [EOL]             if (midType instanceof ParameterizedType) { [EOL]                 midClass = getRawType((ParameterizedType) midType); [EOL]             } else if (midType instanceof Class<?>) { [EOL]                 midClass = (Class<?>) midType; [EOL]             } else { [EOL]                 throw new IllegalStateException("Unexpected generic" + " interface type found: " + midType); [EOL]             } [EOL]             if (isAssignable(midClass, superClass) && isAssignable(genericInterface, (Type) midClass)) { [EOL]                 genericInterface = midType; [EOL]             } [EOL]         } [EOL]         if (genericInterface != null) { [EOL]             return genericInterface; [EOL]         } [EOL]     } [EOL]     return cls.getGenericSuperclass(); [EOL] } 
 [LINE] Type genericInterface = null; [LINE] private static Type getClosestParentType(final Class<?> cls, final Class<?> superClass) { [EOL]     if (superClass.isInterface()) { [EOL]         final Type[] interfaceTypes = cls.getGenericInterfaces(); [EOL]         Type genericInterface = null; [EOL]         for (final Type midType : interfaceTypes) { [EOL]             Class<?> midClass = null; [EOL]             if (midType instanceof ParameterizedType) { [EOL]                 midClass = getRawType((ParameterizedType) midType); [EOL]             } else if (midType instanceof Class<?>) { [EOL]                 midClass = (Class<?>) midType; [EOL]             } else { [EOL]                 throw new IllegalStateException("Unexpected generic" + " interface type found: " + midType); [EOL]             } [EOL]             if (isAssignable(midClass, superClass) && isAssignable(genericInterface, (Type) midClass)) { [EOL]                 genericInterface = midType; [EOL]             } [EOL]         } [EOL]         if (genericInterface != null) { [EOL]             return genericInterface; [EOL]         } [EOL]     } [EOL]     return cls.getGenericSuperclass(); [EOL] } 
 [LINE] for (final Type midType : interfaceTypes) { [LINE] private static Type getClosestParentType(final Class<?> cls, final Class<?> superClass) { [EOL]     if (superClass.isInterface()) { [EOL]         final Type[] interfaceTypes = cls.getGenericInterfaces(); [EOL]         Type genericInterface = null; [EOL]         for (final Type midType : interfaceTypes) { [EOL]             Class<?> midClass = null; [EOL]             if (midType instanceof ParameterizedType) { [EOL]                 midClass = getRawType((ParameterizedType) midType); [EOL]             } else if (midType instanceof Class<?>) { [EOL]                 midClass = (Class<?>) midType; [EOL]             } else { [EOL]                 throw new IllegalStateException("Unexpected generic" + " interface type found: " + midType); [EOL]             } [EOL]             if (isAssignable(midClass, superClass) && isAssignable(genericInterface, (Type) midClass)) { [EOL]                 genericInterface = midType; [EOL]             } [EOL]         } [EOL]         if (genericInterface != null) { [EOL]             return genericInterface; [EOL]         } [EOL]     } [EOL]     return cls.getGenericSuperclass(); [EOL] } 
 [LINE] Class<?> midClass = null; [LINE] private static Type getClosestParentType(final Class<?> cls, final Class<?> superClass) { [EOL]     if (superClass.isInterface()) { [EOL]         final Type[] interfaceTypes = cls.getGenericInterfaces(); [EOL]         Type genericInterface = null; [EOL]         for (final Type midType : interfaceTypes) { [EOL]             Class<?> midClass = null; [EOL]             if (midType instanceof ParameterizedType) { [EOL]                 midClass = getRawType((ParameterizedType) midType); [EOL]             } else if (midType instanceof Class<?>) { [EOL]                 midClass = (Class<?>) midType; [EOL]             } else { [EOL]                 throw new IllegalStateException("Unexpected generic" + " interface type found: " + midType); [EOL]             } [EOL]             if (isAssignable(midClass, superClass) && isAssignable(genericInterface, (Type) midClass)) { [EOL]                 genericInterface = midType; [EOL]             } [EOL]         } [EOL]         if (genericInterface != null) { [EOL]             return genericInterface; [EOL]         } [EOL]     } [EOL]     return cls.getGenericSuperclass(); [EOL] } 
 [LINE] if (midType instanceof ParameterizedType) { [LINE] private static Type getClosestParentType(final Class<?> cls, final Class<?> superClass) { [EOL]     if (superClass.isInterface()) { [EOL]         final Type[] interfaceTypes = cls.getGenericInterfaces(); [EOL]         Type genericInterface = null; [EOL]         for (final Type midType : interfaceTypes) { [EOL]             Class<?> midClass = null; [EOL]             if (midType instanceof ParameterizedType) { [EOL]                 midClass = getRawType((ParameterizedType) midType); [EOL]             } else if (midType instanceof Class<?>) { [EOL]                 midClass = (Class<?>) midType; [EOL]             } else { [EOL]                 throw new IllegalStateException("Unexpected generic" + " interface type found: " + midType); [EOL]             } [EOL]             if (isAssignable(midClass, superClass) && isAssignable(genericInterface, (Type) midClass)) { [EOL]                 genericInterface = midType; [EOL]             } [EOL]         } [EOL]         if (genericInterface != null) { [EOL]             return genericInterface; [EOL]         } [EOL]     } [EOL]     return cls.getGenericSuperclass(); [EOL] } 
 [LINE] midClass = getRawType((ParameterizedType) midType); [LINE] private static Type getClosestParentType(final Class<?> cls, final Class<?> superClass) { [EOL]     if (superClass.isInterface()) { [EOL]         final Type[] interfaceTypes = cls.getGenericInterfaces(); [EOL]         Type genericInterface = null; [EOL]         for (final Type midType : interfaceTypes) { [EOL]             Class<?> midClass = null; [EOL]             if (midType instanceof ParameterizedType) { [EOL]                 midClass = getRawType((ParameterizedType) midType); [EOL]             } else if (midType instanceof Class<?>) { [EOL]                 midClass = (Class<?>) midType; [EOL]             } else { [EOL]                 throw new IllegalStateException("Unexpected generic" + " interface type found: " + midType); [EOL]             } [EOL]             if (isAssignable(midClass, superClass) && isAssignable(genericInterface, (Type) midClass)) { [EOL]                 genericInterface = midType; [EOL]             } [EOL]         } [EOL]         if (genericInterface != null) { [EOL]             return genericInterface; [EOL]         } [EOL]     } [EOL]     return cls.getGenericSuperclass(); [EOL] } 
 [LINE] } else if (midType instanceof Class<?>) { [LINE] private static Type getClosestParentType(final Class<?> cls, final Class<?> superClass) { [EOL]     if (superClass.isInterface()) { [EOL]         final Type[] interfaceTypes = cls.getGenericInterfaces(); [EOL]         Type genericInterface = null; [EOL]         for (final Type midType : interfaceTypes) { [EOL]             Class<?> midClass = null; [EOL]             if (midType instanceof ParameterizedType) { [EOL]                 midClass = getRawType((ParameterizedType) midType); [EOL]             } else if (midType instanceof Class<?>) { [EOL]                 midClass = (Class<?>) midType; [EOL]             } else { [EOL]                 throw new IllegalStateException("Unexpected generic" + " interface type found: " + midType); [EOL]             } [EOL]             if (isAssignable(midClass, superClass) && isAssignable(genericInterface, (Type) midClass)) { [EOL]                 genericInterface = midType; [EOL]             } [EOL]         } [EOL]         if (genericInterface != null) { [EOL]             return genericInterface; [EOL]         } [EOL]     } [EOL]     return cls.getGenericSuperclass(); [EOL] } 
 [LINE] midClass = (Class<?>) midType; [LINE] private static Type getClosestParentType(final Class<?> cls, final Class<?> superClass) { [EOL]     if (superClass.isInterface()) { [EOL]         final Type[] interfaceTypes = cls.getGenericInterfaces(); [EOL]         Type genericInterface = null; [EOL]         for (final Type midType : interfaceTypes) { [EOL]             Class<?> midClass = null; [EOL]             if (midType instanceof ParameterizedType) { [EOL]                 midClass = getRawType((ParameterizedType) midType); [EOL]             } else if (midType instanceof Class<?>) { [EOL]                 midClass = (Class<?>) midType; [EOL]             } else { [EOL]                 throw new IllegalStateException("Unexpected generic" + " interface type found: " + midType); [EOL]             } [EOL]             if (isAssignable(midClass, superClass) && isAssignable(genericInterface, (Type) midClass)) { [EOL]                 genericInterface = midType; [EOL]             } [EOL]         } [EOL]         if (genericInterface != null) { [EOL]             return genericInterface; [EOL]         } [EOL]     } [EOL]     return cls.getGenericSuperclass(); [EOL] } 
 [LINE] if (isAssignable(midClass, superClass) [LINE] private static Type getClosestParentType(final Class<?> cls, final Class<?> superClass) { [EOL]     if (superClass.isInterface()) { [EOL]         final Type[] interfaceTypes = cls.getGenericInterfaces(); [EOL]         Type genericInterface = null; [EOL]         for (final Type midType : interfaceTypes) { [EOL]             Class<?> midClass = null; [EOL]             if (midType instanceof ParameterizedType) { [EOL]                 midClass = getRawType((ParameterizedType) midType); [EOL]             } else if (midType instanceof Class<?>) { [EOL]                 midClass = (Class<?>) midType; [EOL]             } else { [EOL]                 throw new IllegalStateException("Unexpected generic" + " interface type found: " + midType); [EOL]             } [EOL]             if (isAssignable(midClass, superClass) && isAssignable(genericInterface, (Type) midClass)) { [EOL]                 genericInterface = midType; [EOL]             } [EOL]         } [EOL]         if (genericInterface != null) { [EOL]             return genericInterface; [EOL]         } [EOL]     } [EOL]     return cls.getGenericSuperclass(); [EOL] } 
 [LINE] genericInterface = midType; [LINE] private static Type getClosestParentType(final Class<?> cls, final Class<?> superClass) { [EOL]     if (superClass.isInterface()) { [EOL]         final Type[] interfaceTypes = cls.getGenericInterfaces(); [EOL]         Type genericInterface = null; [EOL]         for (final Type midType : interfaceTypes) { [EOL]             Class<?> midClass = null; [EOL]             if (midType instanceof ParameterizedType) { [EOL]                 midClass = getRawType((ParameterizedType) midType); [EOL]             } else if (midType instanceof Class<?>) { [EOL]                 midClass = (Class<?>) midType; [EOL]             } else { [EOL]                 throw new IllegalStateException("Unexpected generic" + " interface type found: " + midType); [EOL]             } [EOL]             if (isAssignable(midClass, superClass) && isAssignable(genericInterface, (Type) midClass)) { [EOL]                 genericInterface = midType; [EOL]             } [EOL]         } [EOL]         if (genericInterface != null) { [EOL]             return genericInterface; [EOL]         } [EOL]     } [EOL]     return cls.getGenericSuperclass(); [EOL] } 
 [LINE] if (genericInterface != null) { [LINE] private static Type getClosestParentType(final Class<?> cls, final Class<?> superClass) { [EOL]     if (superClass.isInterface()) { [EOL]         final Type[] interfaceTypes = cls.getGenericInterfaces(); [EOL]         Type genericInterface = null; [EOL]         for (final Type midType : interfaceTypes) { [EOL]             Class<?> midClass = null; [EOL]             if (midType instanceof ParameterizedType) { [EOL]                 midClass = getRawType((ParameterizedType) midType); [EOL]             } else if (midType instanceof Class<?>) { [EOL]                 midClass = (Class<?>) midType; [EOL]             } else { [EOL]                 throw new IllegalStateException("Unexpected generic" + " interface type found: " + midType); [EOL]             } [EOL]             if (isAssignable(midClass, superClass) && isAssignable(genericInterface, (Type) midClass)) { [EOL]                 genericInterface = midType; [EOL]             } [EOL]         } [EOL]         if (genericInterface != null) { [EOL]             return genericInterface; [EOL]         } [EOL]     } [EOL]     return cls.getGenericSuperclass(); [EOL] } 
 [LINE] return genericInterface; [LINE] private static Type getClosestParentType(final Class<?> cls, final Class<?> superClass) { [EOL]     if (superClass.isInterface()) { [EOL]         final Type[] interfaceTypes = cls.getGenericInterfaces(); [EOL]         Type genericInterface = null; [EOL]         for (final Type midType : interfaceTypes) { [EOL]             Class<?> midClass = null; [EOL]             if (midType instanceof ParameterizedType) { [EOL]                 midClass = getRawType((ParameterizedType) midType); [EOL]             } else if (midType instanceof Class<?>) { [EOL]                 midClass = (Class<?>) midType; [EOL]             } else { [EOL]                 throw new IllegalStateException("Unexpected generic" + " interface type found: " + midType); [EOL]             } [EOL]             if (isAssignable(midClass, superClass) && isAssignable(genericInterface, (Type) midClass)) { [EOL]                 genericInterface = midType; [EOL]             } [EOL]         } [EOL]         if (genericInterface != null) { [EOL]             return genericInterface; [EOL]         } [EOL]     } [EOL]     return cls.getGenericSuperclass(); [EOL] } 
 [LINE] if (assigningType == null) { [LINE] public static Class<?> getRawType(final Type type, final Type assigningType) { [EOL]     if (type instanceof Class<?>) { [EOL]         return (Class<?>) type; [EOL]     } [EOL]     if (type instanceof ParameterizedType) { [EOL]         return getRawType((ParameterizedType) type); [EOL]     } [EOL]     if (type instanceof TypeVariable<?>) { [EOL]         if (assigningType == null) { [EOL]             return null; [EOL]         } [EOL]         final Object genericDeclaration = ((TypeVariable<?>) type).getGenericDeclaration(); [EOL]         if (!(genericDeclaration instanceof Class<?>)) { [EOL]             return null; [EOL]         } [EOL]         final Map<TypeVariable<?>, Type> typeVarAssigns = getTypeArguments(assigningType, (Class<?>) genericDeclaration); [EOL]         if (typeVarAssigns == null) { [EOL]             return null; [EOL]         } [EOL]         final Type typeArgument = typeVarAssigns.get(type); [EOL]         if (typeArgument == null) { [EOL]             return null; [EOL]         } [EOL]         return getRawType(typeArgument, assigningType); [EOL]     } [EOL]     if (type instanceof GenericArrayType) { [EOL]         final Class<?> rawComponentType = getRawType(((GenericArrayType) type).getGenericComponentType(), assigningType); [EOL]         return Array.newInstance(rawComponentType, 0).getClass(); [EOL]     } [EOL]     if (type instanceof WildcardType) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("unknown type: " + type); [EOL] } 
 [LINE] final Object genericDeclaration = ((TypeVariable<?>) type).getGenericDeclaration(); [LINE] public static Class<?> getRawType(final Type type, final Type assigningType) { [EOL]     if (type instanceof Class<?>) { [EOL]         return (Class<?>) type; [EOL]     } [EOL]     if (type instanceof ParameterizedType) { [EOL]         return getRawType((ParameterizedType) type); [EOL]     } [EOL]     if (type instanceof TypeVariable<?>) { [EOL]         if (assigningType == null) { [EOL]             return null; [EOL]         } [EOL]         final Object genericDeclaration = ((TypeVariable<?>) type).getGenericDeclaration(); [EOL]         if (!(genericDeclaration instanceof Class<?>)) { [EOL]             return null; [EOL]         } [EOL]         final Map<TypeVariable<?>, Type> typeVarAssigns = getTypeArguments(assigningType, (Class<?>) genericDeclaration); [EOL]         if (typeVarAssigns == null) { [EOL]             return null; [EOL]         } [EOL]         final Type typeArgument = typeVarAssigns.get(type); [EOL]         if (typeArgument == null) { [EOL]             return null; [EOL]         } [EOL]         return getRawType(typeArgument, assigningType); [EOL]     } [EOL]     if (type instanceof GenericArrayType) { [EOL]         final Class<?> rawComponentType = getRawType(((GenericArrayType) type).getGenericComponentType(), assigningType); [EOL]         return Array.newInstance(rawComponentType, 0).getClass(); [EOL]     } [EOL]     if (type instanceof WildcardType) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("unknown type: " + type); [EOL] } 
 [LINE] if (!(genericDeclaration instanceof Class<?>)) { [LINE] public static Class<?> getRawType(final Type type, final Type assigningType) { [EOL]     if (type instanceof Class<?>) { [EOL]         return (Class<?>) type; [EOL]     } [EOL]     if (type instanceof ParameterizedType) { [EOL]         return getRawType((ParameterizedType) type); [EOL]     } [EOL]     if (type instanceof TypeVariable<?>) { [EOL]         if (assigningType == null) { [EOL]             return null; [EOL]         } [EOL]         final Object genericDeclaration = ((TypeVariable<?>) type).getGenericDeclaration(); [EOL]         if (!(genericDeclaration instanceof Class<?>)) { [EOL]             return null; [EOL]         } [EOL]         final Map<TypeVariable<?>, Type> typeVarAssigns = getTypeArguments(assigningType, (Class<?>) genericDeclaration); [EOL]         if (typeVarAssigns == null) { [EOL]             return null; [EOL]         } [EOL]         final Type typeArgument = typeVarAssigns.get(type); [EOL]         if (typeArgument == null) { [EOL]             return null; [EOL]         } [EOL]         return getRawType(typeArgument, assigningType); [EOL]     } [EOL]     if (type instanceof GenericArrayType) { [EOL]         final Class<?> rawComponentType = getRawType(((GenericArrayType) type).getGenericComponentType(), assigningType); [EOL]         return Array.newInstance(rawComponentType, 0).getClass(); [EOL]     } [EOL]     if (type instanceof WildcardType) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("unknown type: " + type); [EOL] } 
 [LINE] final Map<TypeVariable<?>, Type> typeVarAssigns = getTypeArguments(assigningType, [LINE] public static Class<?> getRawType(final Type type, final Type assigningType) { [EOL]     if (type instanceof Class<?>) { [EOL]         return (Class<?>) type; [EOL]     } [EOL]     if (type instanceof ParameterizedType) { [EOL]         return getRawType((ParameterizedType) type); [EOL]     } [EOL]     if (type instanceof TypeVariable<?>) { [EOL]         if (assigningType == null) { [EOL]             return null; [EOL]         } [EOL]         final Object genericDeclaration = ((TypeVariable<?>) type).getGenericDeclaration(); [EOL]         if (!(genericDeclaration instanceof Class<?>)) { [EOL]             return null; [EOL]         } [EOL]         final Map<TypeVariable<?>, Type> typeVarAssigns = getTypeArguments(assigningType, (Class<?>) genericDeclaration); [EOL]         if (typeVarAssigns == null) { [EOL]             return null; [EOL]         } [EOL]         final Type typeArgument = typeVarAssigns.get(type); [EOL]         if (typeArgument == null) { [EOL]             return null; [EOL]         } [EOL]         return getRawType(typeArgument, assigningType); [EOL]     } [EOL]     if (type instanceof GenericArrayType) { [EOL]         final Class<?> rawComponentType = getRawType(((GenericArrayType) type).getGenericComponentType(), assigningType); [EOL]         return Array.newInstance(rawComponentType, 0).getClass(); [EOL]     } [EOL]     if (type instanceof WildcardType) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("unknown type: " + type); [EOL] } 
 [LINE] if (typeVarAssigns == null) { [LINE] public static Class<?> getRawType(final Type type, final Type assigningType) { [EOL]     if (type instanceof Class<?>) { [EOL]         return (Class<?>) type; [EOL]     } [EOL]     if (type instanceof ParameterizedType) { [EOL]         return getRawType((ParameterizedType) type); [EOL]     } [EOL]     if (type instanceof TypeVariable<?>) { [EOL]         if (assigningType == null) { [EOL]             return null; [EOL]         } [EOL]         final Object genericDeclaration = ((TypeVariable<?>) type).getGenericDeclaration(); [EOL]         if (!(genericDeclaration instanceof Class<?>)) { [EOL]             return null; [EOL]         } [EOL]         final Map<TypeVariable<?>, Type> typeVarAssigns = getTypeArguments(assigningType, (Class<?>) genericDeclaration); [EOL]         if (typeVarAssigns == null) { [EOL]             return null; [EOL]         } [EOL]         final Type typeArgument = typeVarAssigns.get(type); [EOL]         if (typeArgument == null) { [EOL]             return null; [EOL]         } [EOL]         return getRawType(typeArgument, assigningType); [EOL]     } [EOL]     if (type instanceof GenericArrayType) { [EOL]         final Class<?> rawComponentType = getRawType(((GenericArrayType) type).getGenericComponentType(), assigningType); [EOL]         return Array.newInstance(rawComponentType, 0).getClass(); [EOL]     } [EOL]     if (type instanceof WildcardType) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("unknown type: " + type); [EOL] } 
 [LINE] final Type typeArgument = typeVarAssigns.get(type); [LINE] public static Class<?> getRawType(final Type type, final Type assigningType) { [EOL]     if (type instanceof Class<?>) { [EOL]         return (Class<?>) type; [EOL]     } [EOL]     if (type instanceof ParameterizedType) { [EOL]         return getRawType((ParameterizedType) type); [EOL]     } [EOL]     if (type instanceof TypeVariable<?>) { [EOL]         if (assigningType == null) { [EOL]             return null; [EOL]         } [EOL]         final Object genericDeclaration = ((TypeVariable<?>) type).getGenericDeclaration(); [EOL]         if (!(genericDeclaration instanceof Class<?>)) { [EOL]             return null; [EOL]         } [EOL]         final Map<TypeVariable<?>, Type> typeVarAssigns = getTypeArguments(assigningType, (Class<?>) genericDeclaration); [EOL]         if (typeVarAssigns == null) { [EOL]             return null; [EOL]         } [EOL]         final Type typeArgument = typeVarAssigns.get(type); [EOL]         if (typeArgument == null) { [EOL]             return null; [EOL]         } [EOL]         return getRawType(typeArgument, assigningType); [EOL]     } [EOL]     if (type instanceof GenericArrayType) { [EOL]         final Class<?> rawComponentType = getRawType(((GenericArrayType) type).getGenericComponentType(), assigningType); [EOL]         return Array.newInstance(rawComponentType, 0).getClass(); [EOL]     } [EOL]     if (type instanceof WildcardType) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("unknown type: " + type); [EOL] } 
 [LINE] if (typeArgument == null) { [LINE] public static Class<?> getRawType(final Type type, final Type assigningType) { [EOL]     if (type instanceof Class<?>) { [EOL]         return (Class<?>) type; [EOL]     } [EOL]     if (type instanceof ParameterizedType) { [EOL]         return getRawType((ParameterizedType) type); [EOL]     } [EOL]     if (type instanceof TypeVariable<?>) { [EOL]         if (assigningType == null) { [EOL]             return null; [EOL]         } [EOL]         final Object genericDeclaration = ((TypeVariable<?>) type).getGenericDeclaration(); [EOL]         if (!(genericDeclaration instanceof Class<?>)) { [EOL]             return null; [EOL]         } [EOL]         final Map<TypeVariable<?>, Type> typeVarAssigns = getTypeArguments(assigningType, (Class<?>) genericDeclaration); [EOL]         if (typeVarAssigns == null) { [EOL]             return null; [EOL]         } [EOL]         final Type typeArgument = typeVarAssigns.get(type); [EOL]         if (typeArgument == null) { [EOL]             return null; [EOL]         } [EOL]         return getRawType(typeArgument, assigningType); [EOL]     } [EOL]     if (type instanceof GenericArrayType) { [EOL]         final Class<?> rawComponentType = getRawType(((GenericArrayType) type).getGenericComponentType(), assigningType); [EOL]         return Array.newInstance(rawComponentType, 0).getClass(); [EOL]     } [EOL]     if (type instanceof WildcardType) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("unknown type: " + type); [EOL] } 
 [LINE] return null; [LINE] public static Class<?> getRawType(final Type type, final Type assigningType) { [EOL]     if (type instanceof Class<?>) { [EOL]         return (Class<?>) type; [EOL]     } [EOL]     if (type instanceof ParameterizedType) { [EOL]         return getRawType((ParameterizedType) type); [EOL]     } [EOL]     if (type instanceof TypeVariable<?>) { [EOL]         if (assigningType == null) { [EOL]             return null; [EOL]         } [EOL]         final Object genericDeclaration = ((TypeVariable<?>) type).getGenericDeclaration(); [EOL]         if (!(genericDeclaration instanceof Class<?>)) { [EOL]             return null; [EOL]         } [EOL]         final Map<TypeVariable<?>, Type> typeVarAssigns = getTypeArguments(assigningType, (Class<?>) genericDeclaration); [EOL]         if (typeVarAssigns == null) { [EOL]             return null; [EOL]         } [EOL]         final Type typeArgument = typeVarAssigns.get(type); [EOL]         if (typeArgument == null) { [EOL]             return null; [EOL]         } [EOL]         return getRawType(typeArgument, assigningType); [EOL]     } [EOL]     if (type instanceof GenericArrayType) { [EOL]         final Class<?> rawComponentType = getRawType(((GenericArrayType) type).getGenericComponentType(), assigningType); [EOL]         return Array.newInstance(rawComponentType, 0).getClass(); [EOL]     } [EOL]     if (type instanceof WildcardType) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("unknown type: " + type); [EOL] } 
 [LINE] return getRawType(typeArgument, assigningType); [LINE] public static Class<?> getRawType(final Type type, final Type assigningType) { [EOL]     if (type instanceof Class<?>) { [EOL]         return (Class<?>) type; [EOL]     } [EOL]     if (type instanceof ParameterizedType) { [EOL]         return getRawType((ParameterizedType) type); [EOL]     } [EOL]     if (type instanceof TypeVariable<?>) { [EOL]         if (assigningType == null) { [EOL]             return null; [EOL]         } [EOL]         final Object genericDeclaration = ((TypeVariable<?>) type).getGenericDeclaration(); [EOL]         if (!(genericDeclaration instanceof Class<?>)) { [EOL]             return null; [EOL]         } [EOL]         final Map<TypeVariable<?>, Type> typeVarAssigns = getTypeArguments(assigningType, (Class<?>) genericDeclaration); [EOL]         if (typeVarAssigns == null) { [EOL]             return null; [EOL]         } [EOL]         final Type typeArgument = typeVarAssigns.get(type); [EOL]         if (typeArgument == null) { [EOL]             return null; [EOL]         } [EOL]         return getRawType(typeArgument, assigningType); [EOL]     } [EOL]     if (type instanceof GenericArrayType) { [EOL]         final Class<?> rawComponentType = getRawType(((GenericArrayType) type).getGenericComponentType(), assigningType); [EOL]         return Array.newInstance(rawComponentType, 0).getClass(); [EOL]     } [EOL]     if (type instanceof WildcardType) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("unknown type: " + type); [EOL] } 
 [LINE] final Class<?> rawComponentType = getRawType(((GenericArrayType) type) [LINE] public static Class<?> getRawType(final Type type, final Type assigningType) { [EOL]     if (type instanceof Class<?>) { [EOL]         return (Class<?>) type; [EOL]     } [EOL]     if (type instanceof ParameterizedType) { [EOL]         return getRawType((ParameterizedType) type); [EOL]     } [EOL]     if (type instanceof TypeVariable<?>) { [EOL]         if (assigningType == null) { [EOL]             return null; [EOL]         } [EOL]         final Object genericDeclaration = ((TypeVariable<?>) type).getGenericDeclaration(); [EOL]         if (!(genericDeclaration instanceof Class<?>)) { [EOL]             return null; [EOL]         } [EOL]         final Map<TypeVariable<?>, Type> typeVarAssigns = getTypeArguments(assigningType, (Class<?>) genericDeclaration); [EOL]         if (typeVarAssigns == null) { [EOL]             return null; [EOL]         } [EOL]         final Type typeArgument = typeVarAssigns.get(type); [EOL]         if (typeArgument == null) { [EOL]             return null; [EOL]         } [EOL]         return getRawType(typeArgument, assigningType); [EOL]     } [EOL]     if (type instanceof GenericArrayType) { [EOL]         final Class<?> rawComponentType = getRawType(((GenericArrayType) type).getGenericComponentType(), assigningType); [EOL]         return Array.newInstance(rawComponentType, 0).getClass(); [EOL]     } [EOL]     if (type instanceof WildcardType) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("unknown type: " + type); [EOL] } 
 [LINE] return Array.newInstance(rawComponentType, 0).getClass(); [LINE] public static Class<?> getRawType(final Type type, final Type assigningType) { [EOL]     if (type instanceof Class<?>) { [EOL]         return (Class<?>) type; [EOL]     } [EOL]     if (type instanceof ParameterizedType) { [EOL]         return getRawType((ParameterizedType) type); [EOL]     } [EOL]     if (type instanceof TypeVariable<?>) { [EOL]         if (assigningType == null) { [EOL]             return null; [EOL]         } [EOL]         final Object genericDeclaration = ((TypeVariable<?>) type).getGenericDeclaration(); [EOL]         if (!(genericDeclaration instanceof Class<?>)) { [EOL]             return null; [EOL]         } [EOL]         final Map<TypeVariable<?>, Type> typeVarAssigns = getTypeArguments(assigningType, (Class<?>) genericDeclaration); [EOL]         if (typeVarAssigns == null) { [EOL]             return null; [EOL]         } [EOL]         final Type typeArgument = typeVarAssigns.get(type); [EOL]         if (typeArgument == null) { [EOL]             return null; [EOL]         } [EOL]         return getRawType(typeArgument, assigningType); [EOL]     } [EOL]     if (type instanceof GenericArrayType) { [EOL]         final Class<?> rawComponentType = getRawType(((GenericArrayType) type).getGenericComponentType(), assigningType); [EOL]         return Array.newInstance(rawComponentType, 0).getClass(); [EOL]     } [EOL]     if (type instanceof WildcardType) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("unknown type: " + type); [EOL] } 
 [LINE] return ((GenericArrayType) type).getGenericComponentType(); [LINE] public static Type getArrayComponentType(final Type type) { [EOL]     if (type instanceof Class<?>) { [EOL]         final Class<?> clazz = (Class<?>) type; [EOL]         return clazz.isArray() ? clazz.getComponentType() : null; [EOL]     } [EOL]     if (type instanceof GenericArrayType) { [EOL]         return ((GenericArrayType) type).getGenericComponentType(); [EOL]     } [EOL]     return null; [EOL] } 
 [LINE] this.options = EnumSet.copyOf(Arrays.asList(options)); [LINE] public NumericEntityUnescaper(final OPTION... options) { [EOL]     if (options.length > 0) { [EOL]         this.options = EnumSet.copyOf(Arrays.asList(options)); [EOL]     } else { [EOL]         this.options = EnumSet.copyOf(Arrays.asList(new OPTION[] { OPTION.semiColonRequired })); [EOL]     } [EOL] } 
 [LINE] public boolean isSet(final OPTION option) { [LINE] public boolean isSet(final OPTION option) { [EOL]     return options == null ? false : options.contains(option); [EOL] } 
 [LINE] return options == null ? false : options.contains(option); [LINE] public boolean isSet(final OPTION option) { [EOL]     return options == null ? false : options.contains(option); [EOL] } 
 [LINE] int start = index + 2; [LINE] @Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     final int seqEnd = input.length(); [EOL]     if (input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') { [EOL]         int start = index + 2; [EOL]         boolean isHex = false; [EOL]         final char firstChar = input.charAt(start); [EOL]         if (firstChar == 'x' || firstChar == 'X') { [EOL]             start++; [EOL]             isHex = true; [EOL]             if (start == seqEnd) { [EOL]                 return 0; [EOL]             } [EOL]         } [EOL]         int end = start; [EOL]         while (end < seqEnd && (input.charAt(end) >= '0' && input.charAt(end) <= '9' || input.charAt(end) >= 'a' && input.charAt(end) <= 'f' || input.charAt(end) >= 'A' && input.charAt(end) <= 'F')) { [EOL]             end++; [EOL]         } [EOL]         final boolean semiNext = end != seqEnd && input.charAt(end) == ';'; [EOL]         if (!semiNext) { [EOL]             if (isSet(OPTION.semiColonRequired)) { [EOL]                 return 0; [EOL]             } else if (isSet(OPTION.errorIfNoSemiColon)) { [EOL]                 throw new IllegalArgumentException("Semi-colon required at end of numeric entity"); [EOL]             } [EOL]         } [EOL]         int entityValue; [EOL]         try { [EOL]             if (isHex) { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16); [EOL]             } else { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10); [EOL]             } [EOL]         } catch (final NumberFormatException nfe) { [EOL]             return 0; [EOL]         } [EOL]         if (entityValue > 0xFFFF) { [EOL]             final char[] chrs = Character.toChars(entityValue); [EOL]             out.write(chrs[0]); [EOL]             out.write(chrs[1]); [EOL]         } else { [EOL]             out.write(entityValue); [EOL]         } [EOL]         return 2 + end - start + (isHex ? 1 : 0) + (semiNext ? 1 : 0); [EOL]     } [EOL]     return 0; [EOL] } 
 [LINE] boolean isHex = false; [LINE] @Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     final int seqEnd = input.length(); [EOL]     if (input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') { [EOL]         int start = index + 2; [EOL]         boolean isHex = false; [EOL]         final char firstChar = input.charAt(start); [EOL]         if (firstChar == 'x' || firstChar == 'X') { [EOL]             start++; [EOL]             isHex = true; [EOL]             if (start == seqEnd) { [EOL]                 return 0; [EOL]             } [EOL]         } [EOL]         int end = start; [EOL]         while (end < seqEnd && (input.charAt(end) >= '0' && input.charAt(end) <= '9' || input.charAt(end) >= 'a' && input.charAt(end) <= 'f' || input.charAt(end) >= 'A' && input.charAt(end) <= 'F')) { [EOL]             end++; [EOL]         } [EOL]         final boolean semiNext = end != seqEnd && input.charAt(end) == ';'; [EOL]         if (!semiNext) { [EOL]             if (isSet(OPTION.semiColonRequired)) { [EOL]                 return 0; [EOL]             } else if (isSet(OPTION.errorIfNoSemiColon)) { [EOL]                 throw new IllegalArgumentException("Semi-colon required at end of numeric entity"); [EOL]             } [EOL]         } [EOL]         int entityValue; [EOL]         try { [EOL]             if (isHex) { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16); [EOL]             } else { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10); [EOL]             } [EOL]         } catch (final NumberFormatException nfe) { [EOL]             return 0; [EOL]         } [EOL]         if (entityValue > 0xFFFF) { [EOL]             final char[] chrs = Character.toChars(entityValue); [EOL]             out.write(chrs[0]); [EOL]             out.write(chrs[1]); [EOL]         } else { [EOL]             out.write(entityValue); [EOL]         } [EOL]         return 2 + end - start + (isHex ? 1 : 0) + (semiNext ? 1 : 0); [EOL]     } [EOL]     return 0; [EOL] } 
 [LINE] final char firstChar = input.charAt(start); [LINE] @Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     final int seqEnd = input.length(); [EOL]     if (input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') { [EOL]         int start = index + 2; [EOL]         boolean isHex = false; [EOL]         final char firstChar = input.charAt(start); [EOL]         if (firstChar == 'x' || firstChar == 'X') { [EOL]             start++; [EOL]             isHex = true; [EOL]             if (start == seqEnd) { [EOL]                 return 0; [EOL]             } [EOL]         } [EOL]         int end = start; [EOL]         while (end < seqEnd && (input.charAt(end) >= '0' && input.charAt(end) <= '9' || input.charAt(end) >= 'a' && input.charAt(end) <= 'f' || input.charAt(end) >= 'A' && input.charAt(end) <= 'F')) { [EOL]             end++; [EOL]         } [EOL]         final boolean semiNext = end != seqEnd && input.charAt(end) == ';'; [EOL]         if (!semiNext) { [EOL]             if (isSet(OPTION.semiColonRequired)) { [EOL]                 return 0; [EOL]             } else if (isSet(OPTION.errorIfNoSemiColon)) { [EOL]                 throw new IllegalArgumentException("Semi-colon required at end of numeric entity"); [EOL]             } [EOL]         } [EOL]         int entityValue; [EOL]         try { [EOL]             if (isHex) { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16); [EOL]             } else { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10); [EOL]             } [EOL]         } catch (final NumberFormatException nfe) { [EOL]             return 0; [EOL]         } [EOL]         if (entityValue > 0xFFFF) { [EOL]             final char[] chrs = Character.toChars(entityValue); [EOL]             out.write(chrs[0]); [EOL]             out.write(chrs[1]); [EOL]         } else { [EOL]             out.write(entityValue); [EOL]         } [EOL]         return 2 + end - start + (isHex ? 1 : 0) + (semiNext ? 1 : 0); [EOL]     } [EOL]     return 0; [EOL] } 
 [LINE] if(firstChar == 'x' || firstChar == 'X') { [LINE] @Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     final int seqEnd = input.length(); [EOL]     if (input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') { [EOL]         int start = index + 2; [EOL]         boolean isHex = false; [EOL]         final char firstChar = input.charAt(start); [EOL]         if (firstChar == 'x' || firstChar == 'X') { [EOL]             start++; [EOL]             isHex = true; [EOL]             if (start == seqEnd) { [EOL]                 return 0; [EOL]             } [EOL]         } [EOL]         int end = start; [EOL]         while (end < seqEnd && (input.charAt(end) >= '0' && input.charAt(end) <= '9' || input.charAt(end) >= 'a' && input.charAt(end) <= 'f' || input.charAt(end) >= 'A' && input.charAt(end) <= 'F')) { [EOL]             end++; [EOL]         } [EOL]         final boolean semiNext = end != seqEnd && input.charAt(end) == ';'; [EOL]         if (!semiNext) { [EOL]             if (isSet(OPTION.semiColonRequired)) { [EOL]                 return 0; [EOL]             } else if (isSet(OPTION.errorIfNoSemiColon)) { [EOL]                 throw new IllegalArgumentException("Semi-colon required at end of numeric entity"); [EOL]             } [EOL]         } [EOL]         int entityValue; [EOL]         try { [EOL]             if (isHex) { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16); [EOL]             } else { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10); [EOL]             } [EOL]         } catch (final NumberFormatException nfe) { [EOL]             return 0; [EOL]         } [EOL]         if (entityValue > 0xFFFF) { [EOL]             final char[] chrs = Character.toChars(entityValue); [EOL]             out.write(chrs[0]); [EOL]             out.write(chrs[1]); [EOL]         } else { [EOL]             out.write(entityValue); [EOL]         } [EOL]         return 2 + end - start + (isHex ? 1 : 0) + (semiNext ? 1 : 0); [EOL]     } [EOL]     return 0; [EOL] } 
 [LINE] start++; [LINE] @Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     final int seqEnd = input.length(); [EOL]     if (input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') { [EOL]         int start = index + 2; [EOL]         boolean isHex = false; [EOL]         final char firstChar = input.charAt(start); [EOL]         if (firstChar == 'x' || firstChar == 'X') { [EOL]             start++; [EOL]             isHex = true; [EOL]             if (start == seqEnd) { [EOL]                 return 0; [EOL]             } [EOL]         } [EOL]         int end = start; [EOL]         while (end < seqEnd && (input.charAt(end) >= '0' && input.charAt(end) <= '9' || input.charAt(end) >= 'a' && input.charAt(end) <= 'f' || input.charAt(end) >= 'A' && input.charAt(end) <= 'F')) { [EOL]             end++; [EOL]         } [EOL]         final boolean semiNext = end != seqEnd && input.charAt(end) == ';'; [EOL]         if (!semiNext) { [EOL]             if (isSet(OPTION.semiColonRequired)) { [EOL]                 return 0; [EOL]             } else if (isSet(OPTION.errorIfNoSemiColon)) { [EOL]                 throw new IllegalArgumentException("Semi-colon required at end of numeric entity"); [EOL]             } [EOL]         } [EOL]         int entityValue; [EOL]         try { [EOL]             if (isHex) { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16); [EOL]             } else { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10); [EOL]             } [EOL]         } catch (final NumberFormatException nfe) { [EOL]             return 0; [EOL]         } [EOL]         if (entityValue > 0xFFFF) { [EOL]             final char[] chrs = Character.toChars(entityValue); [EOL]             out.write(chrs[0]); [EOL]             out.write(chrs[1]); [EOL]         } else { [EOL]             out.write(entityValue); [EOL]         } [EOL]         return 2 + end - start + (isHex ? 1 : 0) + (semiNext ? 1 : 0); [EOL]     } [EOL]     return 0; [EOL] } 
 [LINE] isHex = true; [LINE] @Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     final int seqEnd = input.length(); [EOL]     if (input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') { [EOL]         int start = index + 2; [EOL]         boolean isHex = false; [EOL]         final char firstChar = input.charAt(start); [EOL]         if (firstChar == 'x' || firstChar == 'X') { [EOL]             start++; [EOL]             isHex = true; [EOL]             if (start == seqEnd) { [EOL]                 return 0; [EOL]             } [EOL]         } [EOL]         int end = start; [EOL]         while (end < seqEnd && (input.charAt(end) >= '0' && input.charAt(end) <= '9' || input.charAt(end) >= 'a' && input.charAt(end) <= 'f' || input.charAt(end) >= 'A' && input.charAt(end) <= 'F')) { [EOL]             end++; [EOL]         } [EOL]         final boolean semiNext = end != seqEnd && input.charAt(end) == ';'; [EOL]         if (!semiNext) { [EOL]             if (isSet(OPTION.semiColonRequired)) { [EOL]                 return 0; [EOL]             } else if (isSet(OPTION.errorIfNoSemiColon)) { [EOL]                 throw new IllegalArgumentException("Semi-colon required at end of numeric entity"); [EOL]             } [EOL]         } [EOL]         int entityValue; [EOL]         try { [EOL]             if (isHex) { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16); [EOL]             } else { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10); [EOL]             } [EOL]         } catch (final NumberFormatException nfe) { [EOL]             return 0; [EOL]         } [EOL]         if (entityValue > 0xFFFF) { [EOL]             final char[] chrs = Character.toChars(entityValue); [EOL]             out.write(chrs[0]); [EOL]             out.write(chrs[1]); [EOL]         } else { [EOL]             out.write(entityValue); [EOL]         } [EOL]         return 2 + end - start + (isHex ? 1 : 0) + (semiNext ? 1 : 0); [EOL]     } [EOL]     return 0; [EOL] } 
 [LINE] if(start == seqEnd) { [LINE] @Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     final int seqEnd = input.length(); [EOL]     if (input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') { [EOL]         int start = index + 2; [EOL]         boolean isHex = false; [EOL]         final char firstChar = input.charAt(start); [EOL]         if (firstChar == 'x' || firstChar == 'X') { [EOL]             start++; [EOL]             isHex = true; [EOL]             if (start == seqEnd) { [EOL]                 return 0; [EOL]             } [EOL]         } [EOL]         int end = start; [EOL]         while (end < seqEnd && (input.charAt(end) >= '0' && input.charAt(end) <= '9' || input.charAt(end) >= 'a' && input.charAt(end) <= 'f' || input.charAt(end) >= 'A' && input.charAt(end) <= 'F')) { [EOL]             end++; [EOL]         } [EOL]         final boolean semiNext = end != seqEnd && input.charAt(end) == ';'; [EOL]         if (!semiNext) { [EOL]             if (isSet(OPTION.semiColonRequired)) { [EOL]                 return 0; [EOL]             } else if (isSet(OPTION.errorIfNoSemiColon)) { [EOL]                 throw new IllegalArgumentException("Semi-colon required at end of numeric entity"); [EOL]             } [EOL]         } [EOL]         int entityValue; [EOL]         try { [EOL]             if (isHex) { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16); [EOL]             } else { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10); [EOL]             } [EOL]         } catch (final NumberFormatException nfe) { [EOL]             return 0; [EOL]         } [EOL]         if (entityValue > 0xFFFF) { [EOL]             final char[] chrs = Character.toChars(entityValue); [EOL]             out.write(chrs[0]); [EOL]             out.write(chrs[1]); [EOL]         } else { [EOL]             out.write(entityValue); [EOL]         } [EOL]         return 2 + end - start + (isHex ? 1 : 0) + (semiNext ? 1 : 0); [EOL]     } [EOL]     return 0; [EOL] } 
 [LINE] return 0; [LINE] @Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     final int seqEnd = input.length(); [EOL]     if (input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') { [EOL]         int start = index + 2; [EOL]         boolean isHex = false; [EOL]         final char firstChar = input.charAt(start); [EOL]         if (firstChar == 'x' || firstChar == 'X') { [EOL]             start++; [EOL]             isHex = true; [EOL]             if (start == seqEnd) { [EOL]                 return 0; [EOL]             } [EOL]         } [EOL]         int end = start; [EOL]         while (end < seqEnd && (input.charAt(end) >= '0' && input.charAt(end) <= '9' || input.charAt(end) >= 'a' && input.charAt(end) <= 'f' || input.charAt(end) >= 'A' && input.charAt(end) <= 'F')) { [EOL]             end++; [EOL]         } [EOL]         final boolean semiNext = end != seqEnd && input.charAt(end) == ';'; [EOL]         if (!semiNext) { [EOL]             if (isSet(OPTION.semiColonRequired)) { [EOL]                 return 0; [EOL]             } else if (isSet(OPTION.errorIfNoSemiColon)) { [EOL]                 throw new IllegalArgumentException("Semi-colon required at end of numeric entity"); [EOL]             } [EOL]         } [EOL]         int entityValue; [EOL]         try { [EOL]             if (isHex) { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16); [EOL]             } else { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10); [EOL]             } [EOL]         } catch (final NumberFormatException nfe) { [EOL]             return 0; [EOL]         } [EOL]         if (entityValue > 0xFFFF) { [EOL]             final char[] chrs = Character.toChars(entityValue); [EOL]             out.write(chrs[0]); [EOL]             out.write(chrs[1]); [EOL]         } else { [EOL]             out.write(entityValue); [EOL]         } [EOL]         return 2 + end - start + (isHex ? 1 : 0) + (semiNext ? 1 : 0); [EOL]     } [EOL]     return 0; [EOL] } 
 [LINE] int end = start; [LINE] @Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     final int seqEnd = input.length(); [EOL]     if (input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') { [EOL]         int start = index + 2; [EOL]         boolean isHex = false; [EOL]         final char firstChar = input.charAt(start); [EOL]         if (firstChar == 'x' || firstChar == 'X') { [EOL]             start++; [EOL]             isHex = true; [EOL]             if (start == seqEnd) { [EOL]                 return 0; [EOL]             } [EOL]         } [EOL]         int end = start; [EOL]         while (end < seqEnd && (input.charAt(end) >= '0' && input.charAt(end) <= '9' || input.charAt(end) >= 'a' && input.charAt(end) <= 'f' || input.charAt(end) >= 'A' && input.charAt(end) <= 'F')) { [EOL]             end++; [EOL]         } [EOL]         final boolean semiNext = end != seqEnd && input.charAt(end) == ';'; [EOL]         if (!semiNext) { [EOL]             if (isSet(OPTION.semiColonRequired)) { [EOL]                 return 0; [EOL]             } else if (isSet(OPTION.errorIfNoSemiColon)) { [EOL]                 throw new IllegalArgumentException("Semi-colon required at end of numeric entity"); [EOL]             } [EOL]         } [EOL]         int entityValue; [EOL]         try { [EOL]             if (isHex) { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16); [EOL]             } else { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10); [EOL]             } [EOL]         } catch (final NumberFormatException nfe) { [EOL]             return 0; [EOL]         } [EOL]         if (entityValue > 0xFFFF) { [EOL]             final char[] chrs = Character.toChars(entityValue); [EOL]             out.write(chrs[0]); [EOL]             out.write(chrs[1]); [EOL]         } else { [EOL]             out.write(entityValue); [EOL]         } [EOL]         return 2 + end - start + (isHex ? 1 : 0) + (semiNext ? 1 : 0); [EOL]     } [EOL]     return 0; [EOL] } 
 [LINE] while(end < seqEnd && ( input.charAt(end) >= '0' && input.charAt(end) <= '9' || [LINE] @Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     final int seqEnd = input.length(); [EOL]     if (input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') { [EOL]         int start = index + 2; [EOL]         boolean isHex = false; [EOL]         final char firstChar = input.charAt(start); [EOL]         if (firstChar == 'x' || firstChar == 'X') { [EOL]             start++; [EOL]             isHex = true; [EOL]             if (start == seqEnd) { [EOL]                 return 0; [EOL]             } [EOL]         } [EOL]         int end = start; [EOL]         while (end < seqEnd && (input.charAt(end) >= '0' && input.charAt(end) <= '9' || input.charAt(end) >= 'a' && input.charAt(end) <= 'f' || input.charAt(end) >= 'A' && input.charAt(end) <= 'F')) { [EOL]             end++; [EOL]         } [EOL]         final boolean semiNext = end != seqEnd && input.charAt(end) == ';'; [EOL]         if (!semiNext) { [EOL]             if (isSet(OPTION.semiColonRequired)) { [EOL]                 return 0; [EOL]             } else if (isSet(OPTION.errorIfNoSemiColon)) { [EOL]                 throw new IllegalArgumentException("Semi-colon required at end of numeric entity"); [EOL]             } [EOL]         } [EOL]         int entityValue; [EOL]         try { [EOL]             if (isHex) { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16); [EOL]             } else { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10); [EOL]             } [EOL]         } catch (final NumberFormatException nfe) { [EOL]             return 0; [EOL]         } [EOL]         if (entityValue > 0xFFFF) { [EOL]             final char[] chrs = Character.toChars(entityValue); [EOL]             out.write(chrs[0]); [EOL]             out.write(chrs[1]); [EOL]         } else { [EOL]             out.write(entityValue); [EOL]         } [EOL]         return 2 + end - start + (isHex ? 1 : 0) + (semiNext ? 1 : 0); [EOL]     } [EOL]     return 0; [EOL] } 
 [LINE] end++; [LINE] @Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     final int seqEnd = input.length(); [EOL]     if (input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') { [EOL]         int start = index + 2; [EOL]         boolean isHex = false; [EOL]         final char firstChar = input.charAt(start); [EOL]         if (firstChar == 'x' || firstChar == 'X') { [EOL]             start++; [EOL]             isHex = true; [EOL]             if (start == seqEnd) { [EOL]                 return 0; [EOL]             } [EOL]         } [EOL]         int end = start; [EOL]         while (end < seqEnd && (input.charAt(end) >= '0' && input.charAt(end) <= '9' || input.charAt(end) >= 'a' && input.charAt(end) <= 'f' || input.charAt(end) >= 'A' && input.charAt(end) <= 'F')) { [EOL]             end++; [EOL]         } [EOL]         final boolean semiNext = end != seqEnd && input.charAt(end) == ';'; [EOL]         if (!semiNext) { [EOL]             if (isSet(OPTION.semiColonRequired)) { [EOL]                 return 0; [EOL]             } else if (isSet(OPTION.errorIfNoSemiColon)) { [EOL]                 throw new IllegalArgumentException("Semi-colon required at end of numeric entity"); [EOL]             } [EOL]         } [EOL]         int entityValue; [EOL]         try { [EOL]             if (isHex) { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16); [EOL]             } else { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10); [EOL]             } [EOL]         } catch (final NumberFormatException nfe) { [EOL]             return 0; [EOL]         } [EOL]         if (entityValue > 0xFFFF) { [EOL]             final char[] chrs = Character.toChars(entityValue); [EOL]             out.write(chrs[0]); [EOL]             out.write(chrs[1]); [EOL]         } else { [EOL]             out.write(entityValue); [EOL]         } [EOL]         return 2 + end - start + (isHex ? 1 : 0) + (semiNext ? 1 : 0); [EOL]     } [EOL]     return 0; [EOL] } 
 [LINE] final boolean semiNext = end != seqEnd && input.charAt(end) == ';'; [LINE] @Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     final int seqEnd = input.length(); [EOL]     if (input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') { [EOL]         int start = index + 2; [EOL]         boolean isHex = false; [EOL]         final char firstChar = input.charAt(start); [EOL]         if (firstChar == 'x' || firstChar == 'X') { [EOL]             start++; [EOL]             isHex = true; [EOL]             if (start == seqEnd) { [EOL]                 return 0; [EOL]             } [EOL]         } [EOL]         int end = start; [EOL]         while (end < seqEnd && (input.charAt(end) >= '0' && input.charAt(end) <= '9' || input.charAt(end) >= 'a' && input.charAt(end) <= 'f' || input.charAt(end) >= 'A' && input.charAt(end) <= 'F')) { [EOL]             end++; [EOL]         } [EOL]         final boolean semiNext = end != seqEnd && input.charAt(end) == ';'; [EOL]         if (!semiNext) { [EOL]             if (isSet(OPTION.semiColonRequired)) { [EOL]                 return 0; [EOL]             } else if (isSet(OPTION.errorIfNoSemiColon)) { [EOL]                 throw new IllegalArgumentException("Semi-colon required at end of numeric entity"); [EOL]             } [EOL]         } [EOL]         int entityValue; [EOL]         try { [EOL]             if (isHex) { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16); [EOL]             } else { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10); [EOL]             } [EOL]         } catch (final NumberFormatException nfe) { [EOL]             return 0; [EOL]         } [EOL]         if (entityValue > 0xFFFF) { [EOL]             final char[] chrs = Character.toChars(entityValue); [EOL]             out.write(chrs[0]); [EOL]             out.write(chrs[1]); [EOL]         } else { [EOL]             out.write(entityValue); [EOL]         } [EOL]         return 2 + end - start + (isHex ? 1 : 0) + (semiNext ? 1 : 0); [EOL]     } [EOL]     return 0; [EOL] } 
 [LINE] if(!semiNext) { [LINE] @Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     final int seqEnd = input.length(); [EOL]     if (input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') { [EOL]         int start = index + 2; [EOL]         boolean isHex = false; [EOL]         final char firstChar = input.charAt(start); [EOL]         if (firstChar == 'x' || firstChar == 'X') { [EOL]             start++; [EOL]             isHex = true; [EOL]             if (start == seqEnd) { [EOL]                 return 0; [EOL]             } [EOL]         } [EOL]         int end = start; [EOL]         while (end < seqEnd && (input.charAt(end) >= '0' && input.charAt(end) <= '9' || input.charAt(end) >= 'a' && input.charAt(end) <= 'f' || input.charAt(end) >= 'A' && input.charAt(end) <= 'F')) { [EOL]             end++; [EOL]         } [EOL]         final boolean semiNext = end != seqEnd && input.charAt(end) == ';'; [EOL]         if (!semiNext) { [EOL]             if (isSet(OPTION.semiColonRequired)) { [EOL]                 return 0; [EOL]             } else if (isSet(OPTION.errorIfNoSemiColon)) { [EOL]                 throw new IllegalArgumentException("Semi-colon required at end of numeric entity"); [EOL]             } [EOL]         } [EOL]         int entityValue; [EOL]         try { [EOL]             if (isHex) { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16); [EOL]             } else { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10); [EOL]             } [EOL]         } catch (final NumberFormatException nfe) { [EOL]             return 0; [EOL]         } [EOL]         if (entityValue > 0xFFFF) { [EOL]             final char[] chrs = Character.toChars(entityValue); [EOL]             out.write(chrs[0]); [EOL]             out.write(chrs[1]); [EOL]         } else { [EOL]             out.write(entityValue); [EOL]         } [EOL]         return 2 + end - start + (isHex ? 1 : 0) + (semiNext ? 1 : 0); [EOL]     } [EOL]     return 0; [EOL] } 
 [LINE] if(isSet(OPTION.semiColonRequired)) { [LINE] @Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     final int seqEnd = input.length(); [EOL]     if (input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') { [EOL]         int start = index + 2; [EOL]         boolean isHex = false; [EOL]         final char firstChar = input.charAt(start); [EOL]         if (firstChar == 'x' || firstChar == 'X') { [EOL]             start++; [EOL]             isHex = true; [EOL]             if (start == seqEnd) { [EOL]                 return 0; [EOL]             } [EOL]         } [EOL]         int end = start; [EOL]         while (end < seqEnd && (input.charAt(end) >= '0' && input.charAt(end) <= '9' || input.charAt(end) >= 'a' && input.charAt(end) <= 'f' || input.charAt(end) >= 'A' && input.charAt(end) <= 'F')) { [EOL]             end++; [EOL]         } [EOL]         final boolean semiNext = end != seqEnd && input.charAt(end) == ';'; [EOL]         if (!semiNext) { [EOL]             if (isSet(OPTION.semiColonRequired)) { [EOL]                 return 0; [EOL]             } else if (isSet(OPTION.errorIfNoSemiColon)) { [EOL]                 throw new IllegalArgumentException("Semi-colon required at end of numeric entity"); [EOL]             } [EOL]         } [EOL]         int entityValue; [EOL]         try { [EOL]             if (isHex) { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16); [EOL]             } else { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10); [EOL]             } [EOL]         } catch (final NumberFormatException nfe) { [EOL]             return 0; [EOL]         } [EOL]         if (entityValue > 0xFFFF) { [EOL]             final char[] chrs = Character.toChars(entityValue); [EOL]             out.write(chrs[0]); [EOL]             out.write(chrs[1]); [EOL]         } else { [EOL]             out.write(entityValue); [EOL]         } [EOL]         return 2 + end - start + (isHex ? 1 : 0) + (semiNext ? 1 : 0); [EOL]     } [EOL]     return 0; [EOL] } 
 [LINE] return 0; [LINE] @Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     final int seqEnd = input.length(); [EOL]     if (input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') { [EOL]         int start = index + 2; [EOL]         boolean isHex = false; [EOL]         final char firstChar = input.charAt(start); [EOL]         if (firstChar == 'x' || firstChar == 'X') { [EOL]             start++; [EOL]             isHex = true; [EOL]             if (start == seqEnd) { [EOL]                 return 0; [EOL]             } [EOL]         } [EOL]         int end = start; [EOL]         while (end < seqEnd && (input.charAt(end) >= '0' && input.charAt(end) <= '9' || input.charAt(end) >= 'a' && input.charAt(end) <= 'f' || input.charAt(end) >= 'A' && input.charAt(end) <= 'F')) { [EOL]             end++; [EOL]         } [EOL]         final boolean semiNext = end != seqEnd && input.charAt(end) == ';'; [EOL]         if (!semiNext) { [EOL]             if (isSet(OPTION.semiColonRequired)) { [EOL]                 return 0; [EOL]             } else if (isSet(OPTION.errorIfNoSemiColon)) { [EOL]                 throw new IllegalArgumentException("Semi-colon required at end of numeric entity"); [EOL]             } [EOL]         } [EOL]         int entityValue; [EOL]         try { [EOL]             if (isHex) { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16); [EOL]             } else { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10); [EOL]             } [EOL]         } catch (final NumberFormatException nfe) { [EOL]             return 0; [EOL]         } [EOL]         if (entityValue > 0xFFFF) { [EOL]             final char[] chrs = Character.toChars(entityValue); [EOL]             out.write(chrs[0]); [EOL]             out.write(chrs[1]); [EOL]         } else { [EOL]             out.write(entityValue); [EOL]         } [EOL]         return 2 + end - start + (isHex ? 1 : 0) + (semiNext ? 1 : 0); [EOL]     } [EOL]     return 0; [EOL] } 
 [LINE] if(isSet(OPTION.errorIfNoSemiColon)) { [LINE] @Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     final int seqEnd = input.length(); [EOL]     if (input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') { [EOL]         int start = index + 2; [EOL]         boolean isHex = false; [EOL]         final char firstChar = input.charAt(start); [EOL]         if (firstChar == 'x' || firstChar == 'X') { [EOL]             start++; [EOL]             isHex = true; [EOL]             if (start == seqEnd) { [EOL]                 return 0; [EOL]             } [EOL]         } [EOL]         int end = start; [EOL]         while (end < seqEnd && (input.charAt(end) >= '0' && input.charAt(end) <= '9' || input.charAt(end) >= 'a' && input.charAt(end) <= 'f' || input.charAt(end) >= 'A' && input.charAt(end) <= 'F')) { [EOL]             end++; [EOL]         } [EOL]         final boolean semiNext = end != seqEnd && input.charAt(end) == ';'; [EOL]         if (!semiNext) { [EOL]             if (isSet(OPTION.semiColonRequired)) { [EOL]                 return 0; [EOL]             } else if (isSet(OPTION.errorIfNoSemiColon)) { [EOL]                 throw new IllegalArgumentException("Semi-colon required at end of numeric entity"); [EOL]             } [EOL]         } [EOL]         int entityValue; [EOL]         try { [EOL]             if (isHex) { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16); [EOL]             } else { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10); [EOL]             } [EOL]         } catch (final NumberFormatException nfe) { [EOL]             return 0; [EOL]         } [EOL]         if (entityValue > 0xFFFF) { [EOL]             final char[] chrs = Character.toChars(entityValue); [EOL]             out.write(chrs[0]); [EOL]             out.write(chrs[1]); [EOL]         } else { [EOL]             out.write(entityValue); [EOL]         } [EOL]         return 2 + end - start + (isHex ? 1 : 0) + (semiNext ? 1 : 0); [EOL]     } [EOL]     return 0; [EOL] } 
 [LINE] throw new IllegalArgumentException("Semi-colon required at end of numeric entity"); [LINE] @Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     final int seqEnd = input.length(); [EOL]     if (input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') { [EOL]         int start = index + 2; [EOL]         boolean isHex = false; [EOL]         final char firstChar = input.charAt(start); [EOL]         if (firstChar == 'x' || firstChar == 'X') { [EOL]             start++; [EOL]             isHex = true; [EOL]             if (start == seqEnd) { [EOL]                 return 0; [EOL]             } [EOL]         } [EOL]         int end = start; [EOL]         while (end < seqEnd && (input.charAt(end) >= '0' && input.charAt(end) <= '9' || input.charAt(end) >= 'a' && input.charAt(end) <= 'f' || input.charAt(end) >= 'A' && input.charAt(end) <= 'F')) { [EOL]             end++; [EOL]         } [EOL]         final boolean semiNext = end != seqEnd && input.charAt(end) == ';'; [EOL]         if (!semiNext) { [EOL]             if (isSet(OPTION.semiColonRequired)) { [EOL]                 return 0; [EOL]             } else if (isSet(OPTION.errorIfNoSemiColon)) { [EOL]                 throw new IllegalArgumentException("Semi-colon required at end of numeric entity"); [EOL]             } [EOL]         } [EOL]         int entityValue; [EOL]         try { [EOL]             if (isHex) { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16); [EOL]             } else { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10); [EOL]             } [EOL]         } catch (final NumberFormatException nfe) { [EOL]             return 0; [EOL]         } [EOL]         if (entityValue > 0xFFFF) { [EOL]             final char[] chrs = Character.toChars(entityValue); [EOL]             out.write(chrs[0]); [EOL]             out.write(chrs[1]); [EOL]         } else { [EOL]             out.write(entityValue); [EOL]         } [EOL]         return 2 + end - start + (isHex ? 1 : 0) + (semiNext ? 1 : 0); [EOL]     } [EOL]     return 0; [EOL] } 
 [LINE] int entityValue; [LINE] @Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     final int seqEnd = input.length(); [EOL]     if (input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') { [EOL]         int start = index + 2; [EOL]         boolean isHex = false; [EOL]         final char firstChar = input.charAt(start); [EOL]         if (firstChar == 'x' || firstChar == 'X') { [EOL]             start++; [EOL]             isHex = true; [EOL]             if (start == seqEnd) { [EOL]                 return 0; [EOL]             } [EOL]         } [EOL]         int end = start; [EOL]         while (end < seqEnd && (input.charAt(end) >= '0' && input.charAt(end) <= '9' || input.charAt(end) >= 'a' && input.charAt(end) <= 'f' || input.charAt(end) >= 'A' && input.charAt(end) <= 'F')) { [EOL]             end++; [EOL]         } [EOL]         final boolean semiNext = end != seqEnd && input.charAt(end) == ';'; [EOL]         if (!semiNext) { [EOL]             if (isSet(OPTION.semiColonRequired)) { [EOL]                 return 0; [EOL]             } else if (isSet(OPTION.errorIfNoSemiColon)) { [EOL]                 throw new IllegalArgumentException("Semi-colon required at end of numeric entity"); [EOL]             } [EOL]         } [EOL]         int entityValue; [EOL]         try { [EOL]             if (isHex) { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16); [EOL]             } else { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10); [EOL]             } [EOL]         } catch (final NumberFormatException nfe) { [EOL]             return 0; [EOL]         } [EOL]         if (entityValue > 0xFFFF) { [EOL]             final char[] chrs = Character.toChars(entityValue); [EOL]             out.write(chrs[0]); [EOL]             out.write(chrs[1]); [EOL]         } else { [EOL]             out.write(entityValue); [EOL]         } [EOL]         return 2 + end - start + (isHex ? 1 : 0) + (semiNext ? 1 : 0); [EOL]     } [EOL]     return 0; [EOL] } 
 [LINE] try { [LINE] @Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     final int seqEnd = input.length(); [EOL]     if (input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') { [EOL]         int start = index + 2; [EOL]         boolean isHex = false; [EOL]         final char firstChar = input.charAt(start); [EOL]         if (firstChar == 'x' || firstChar == 'X') { [EOL]             start++; [EOL]             isHex = true; [EOL]             if (start == seqEnd) { [EOL]                 return 0; [EOL]             } [EOL]         } [EOL]         int end = start; [EOL]         while (end < seqEnd && (input.charAt(end) >= '0' && input.charAt(end) <= '9' || input.charAt(end) >= 'a' && input.charAt(end) <= 'f' || input.charAt(end) >= 'A' && input.charAt(end) <= 'F')) { [EOL]             end++; [EOL]         } [EOL]         final boolean semiNext = end != seqEnd && input.charAt(end) == ';'; [EOL]         if (!semiNext) { [EOL]             if (isSet(OPTION.semiColonRequired)) { [EOL]                 return 0; [EOL]             } else if (isSet(OPTION.errorIfNoSemiColon)) { [EOL]                 throw new IllegalArgumentException("Semi-colon required at end of numeric entity"); [EOL]             } [EOL]         } [EOL]         int entityValue; [EOL]         try { [EOL]             if (isHex) { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16); [EOL]             } else { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10); [EOL]             } [EOL]         } catch (final NumberFormatException nfe) { [EOL]             return 0; [EOL]         } [EOL]         if (entityValue > 0xFFFF) { [EOL]             final char[] chrs = Character.toChars(entityValue); [EOL]             out.write(chrs[0]); [EOL]             out.write(chrs[1]); [EOL]         } else { [EOL]             out.write(entityValue); [EOL]         } [EOL]         return 2 + end - start + (isHex ? 1 : 0) + (semiNext ? 1 : 0); [EOL]     } [EOL]     return 0; [EOL] } 
 [LINE] if(isHex) { [LINE] @Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     final int seqEnd = input.length(); [EOL]     if (input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') { [EOL]         int start = index + 2; [EOL]         boolean isHex = false; [EOL]         final char firstChar = input.charAt(start); [EOL]         if (firstChar == 'x' || firstChar == 'X') { [EOL]             start++; [EOL]             isHex = true; [EOL]             if (start == seqEnd) { [EOL]                 return 0; [EOL]             } [EOL]         } [EOL]         int end = start; [EOL]         while (end < seqEnd && (input.charAt(end) >= '0' && input.charAt(end) <= '9' || input.charAt(end) >= 'a' && input.charAt(end) <= 'f' || input.charAt(end) >= 'A' && input.charAt(end) <= 'F')) { [EOL]             end++; [EOL]         } [EOL]         final boolean semiNext = end != seqEnd && input.charAt(end) == ';'; [EOL]         if (!semiNext) { [EOL]             if (isSet(OPTION.semiColonRequired)) { [EOL]                 return 0; [EOL]             } else if (isSet(OPTION.errorIfNoSemiColon)) { [EOL]                 throw new IllegalArgumentException("Semi-colon required at end of numeric entity"); [EOL]             } [EOL]         } [EOL]         int entityValue; [EOL]         try { [EOL]             if (isHex) { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16); [EOL]             } else { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10); [EOL]             } [EOL]         } catch (final NumberFormatException nfe) { [EOL]             return 0; [EOL]         } [EOL]         if (entityValue > 0xFFFF) { [EOL]             final char[] chrs = Character.toChars(entityValue); [EOL]             out.write(chrs[0]); [EOL]             out.write(chrs[1]); [EOL]         } else { [EOL]             out.write(entityValue); [EOL]         } [EOL]         return 2 + end - start + (isHex ? 1 : 0) + (semiNext ? 1 : 0); [EOL]     } [EOL]     return 0; [EOL] } 
 [LINE] entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16); [LINE] @Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     final int seqEnd = input.length(); [EOL]     if (input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') { [EOL]         int start = index + 2; [EOL]         boolean isHex = false; [EOL]         final char firstChar = input.charAt(start); [EOL]         if (firstChar == 'x' || firstChar == 'X') { [EOL]             start++; [EOL]             isHex = true; [EOL]             if (start == seqEnd) { [EOL]                 return 0; [EOL]             } [EOL]         } [EOL]         int end = start; [EOL]         while (end < seqEnd && (input.charAt(end) >= '0' && input.charAt(end) <= '9' || input.charAt(end) >= 'a' && input.charAt(end) <= 'f' || input.charAt(end) >= 'A' && input.charAt(end) <= 'F')) { [EOL]             end++; [EOL]         } [EOL]         final boolean semiNext = end != seqEnd && input.charAt(end) == ';'; [EOL]         if (!semiNext) { [EOL]             if (isSet(OPTION.semiColonRequired)) { [EOL]                 return 0; [EOL]             } else if (isSet(OPTION.errorIfNoSemiColon)) { [EOL]                 throw new IllegalArgumentException("Semi-colon required at end of numeric entity"); [EOL]             } [EOL]         } [EOL]         int entityValue; [EOL]         try { [EOL]             if (isHex) { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16); [EOL]             } else { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10); [EOL]             } [EOL]         } catch (final NumberFormatException nfe) { [EOL]             return 0; [EOL]         } [EOL]         if (entityValue > 0xFFFF) { [EOL]             final char[] chrs = Character.toChars(entityValue); [EOL]             out.write(chrs[0]); [EOL]             out.write(chrs[1]); [EOL]         } else { [EOL]             out.write(entityValue); [EOL]         } [EOL]         return 2 + end - start + (isHex ? 1 : 0) + (semiNext ? 1 : 0); [EOL]     } [EOL]     return 0; [EOL] } 
 [LINE] entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10); [LINE] @Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     final int seqEnd = input.length(); [EOL]     if (input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') { [EOL]         int start = index + 2; [EOL]         boolean isHex = false; [EOL]         final char firstChar = input.charAt(start); [EOL]         if (firstChar == 'x' || firstChar == 'X') { [EOL]             start++; [EOL]             isHex = true; [EOL]             if (start == seqEnd) { [EOL]                 return 0; [EOL]             } [EOL]         } [EOL]         int end = start; [EOL]         while (end < seqEnd && (input.charAt(end) >= '0' && input.charAt(end) <= '9' || input.charAt(end) >= 'a' && input.charAt(end) <= 'f' || input.charAt(end) >= 'A' && input.charAt(end) <= 'F')) { [EOL]             end++; [EOL]         } [EOL]         final boolean semiNext = end != seqEnd && input.charAt(end) == ';'; [EOL]         if (!semiNext) { [EOL]             if (isSet(OPTION.semiColonRequired)) { [EOL]                 return 0; [EOL]             } else if (isSet(OPTION.errorIfNoSemiColon)) { [EOL]                 throw new IllegalArgumentException("Semi-colon required at end of numeric entity"); [EOL]             } [EOL]         } [EOL]         int entityValue; [EOL]         try { [EOL]             if (isHex) { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16); [EOL]             } else { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10); [EOL]             } [EOL]         } catch (final NumberFormatException nfe) { [EOL]             return 0; [EOL]         } [EOL]         if (entityValue > 0xFFFF) { [EOL]             final char[] chrs = Character.toChars(entityValue); [EOL]             out.write(chrs[0]); [EOL]             out.write(chrs[1]); [EOL]         } else { [EOL]             out.write(entityValue); [EOL]         } [EOL]         return 2 + end - start + (isHex ? 1 : 0) + (semiNext ? 1 : 0); [EOL]     } [EOL]     return 0; [EOL] } 
 [LINE] return 0; [LINE] @Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     final int seqEnd = input.length(); [EOL]     if (input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') { [EOL]         int start = index + 2; [EOL]         boolean isHex = false; [EOL]         final char firstChar = input.charAt(start); [EOL]         if (firstChar == 'x' || firstChar == 'X') { [EOL]             start++; [EOL]             isHex = true; [EOL]             if (start == seqEnd) { [EOL]                 return 0; [EOL]             } [EOL]         } [EOL]         int end = start; [EOL]         while (end < seqEnd && (input.charAt(end) >= '0' && input.charAt(end) <= '9' || input.charAt(end) >= 'a' && input.charAt(end) <= 'f' || input.charAt(end) >= 'A' && input.charAt(end) <= 'F')) { [EOL]             end++; [EOL]         } [EOL]         final boolean semiNext = end != seqEnd && input.charAt(end) == ';'; [EOL]         if (!semiNext) { [EOL]             if (isSet(OPTION.semiColonRequired)) { [EOL]                 return 0; [EOL]             } else if (isSet(OPTION.errorIfNoSemiColon)) { [EOL]                 throw new IllegalArgumentException("Semi-colon required at end of numeric entity"); [EOL]             } [EOL]         } [EOL]         int entityValue; [EOL]         try { [EOL]             if (isHex) { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16); [EOL]             } else { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10); [EOL]             } [EOL]         } catch (final NumberFormatException nfe) { [EOL]             return 0; [EOL]         } [EOL]         if (entityValue > 0xFFFF) { [EOL]             final char[] chrs = Character.toChars(entityValue); [EOL]             out.write(chrs[0]); [EOL]             out.write(chrs[1]); [EOL]         } else { [EOL]             out.write(entityValue); [EOL]         } [EOL]         return 2 + end - start + (isHex ? 1 : 0) + (semiNext ? 1 : 0); [EOL]     } [EOL]     return 0; [EOL] } 
 [LINE] if(entityValue > 0xFFFF) { [LINE] @Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     final int seqEnd = input.length(); [EOL]     if (input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') { [EOL]         int start = index + 2; [EOL]         boolean isHex = false; [EOL]         final char firstChar = input.charAt(start); [EOL]         if (firstChar == 'x' || firstChar == 'X') { [EOL]             start++; [EOL]             isHex = true; [EOL]             if (start == seqEnd) { [EOL]                 return 0; [EOL]             } [EOL]         } [EOL]         int end = start; [EOL]         while (end < seqEnd && (input.charAt(end) >= '0' && input.charAt(end) <= '9' || input.charAt(end) >= 'a' && input.charAt(end) <= 'f' || input.charAt(end) >= 'A' && input.charAt(end) <= 'F')) { [EOL]             end++; [EOL]         } [EOL]         final boolean semiNext = end != seqEnd && input.charAt(end) == ';'; [EOL]         if (!semiNext) { [EOL]             if (isSet(OPTION.semiColonRequired)) { [EOL]                 return 0; [EOL]             } else if (isSet(OPTION.errorIfNoSemiColon)) { [EOL]                 throw new IllegalArgumentException("Semi-colon required at end of numeric entity"); [EOL]             } [EOL]         } [EOL]         int entityValue; [EOL]         try { [EOL]             if (isHex) { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16); [EOL]             } else { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10); [EOL]             } [EOL]         } catch (final NumberFormatException nfe) { [EOL]             return 0; [EOL]         } [EOL]         if (entityValue > 0xFFFF) { [EOL]             final char[] chrs = Character.toChars(entityValue); [EOL]             out.write(chrs[0]); [EOL]             out.write(chrs[1]); [EOL]         } else { [EOL]             out.write(entityValue); [EOL]         } [EOL]         return 2 + end - start + (isHex ? 1 : 0) + (semiNext ? 1 : 0); [EOL]     } [EOL]     return 0; [EOL] } 
 [LINE] final char[] chrs = Character.toChars(entityValue); [LINE] @Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     final int seqEnd = input.length(); [EOL]     if (input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') { [EOL]         int start = index + 2; [EOL]         boolean isHex = false; [EOL]         final char firstChar = input.charAt(start); [EOL]         if (firstChar == 'x' || firstChar == 'X') { [EOL]             start++; [EOL]             isHex = true; [EOL]             if (start == seqEnd) { [EOL]                 return 0; [EOL]             } [EOL]         } [EOL]         int end = start; [EOL]         while (end < seqEnd && (input.charAt(end) >= '0' && input.charAt(end) <= '9' || input.charAt(end) >= 'a' && input.charAt(end) <= 'f' || input.charAt(end) >= 'A' && input.charAt(end) <= 'F')) { [EOL]             end++; [EOL]         } [EOL]         final boolean semiNext = end != seqEnd && input.charAt(end) == ';'; [EOL]         if (!semiNext) { [EOL]             if (isSet(OPTION.semiColonRequired)) { [EOL]                 return 0; [EOL]             } else if (isSet(OPTION.errorIfNoSemiColon)) { [EOL]                 throw new IllegalArgumentException("Semi-colon required at end of numeric entity"); [EOL]             } [EOL]         } [EOL]         int entityValue; [EOL]         try { [EOL]             if (isHex) { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16); [EOL]             } else { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10); [EOL]             } [EOL]         } catch (final NumberFormatException nfe) { [EOL]             return 0; [EOL]         } [EOL]         if (entityValue > 0xFFFF) { [EOL]             final char[] chrs = Character.toChars(entityValue); [EOL]             out.write(chrs[0]); [EOL]             out.write(chrs[1]); [EOL]         } else { [EOL]             out.write(entityValue); [EOL]         } [EOL]         return 2 + end - start + (isHex ? 1 : 0) + (semiNext ? 1 : 0); [EOL]     } [EOL]     return 0; [EOL] } 
 [LINE] out.write(chrs[0]); [LINE] @Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     final int seqEnd = input.length(); [EOL]     if (input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') { [EOL]         int start = index + 2; [EOL]         boolean isHex = false; [EOL]         final char firstChar = input.charAt(start); [EOL]         if (firstChar == 'x' || firstChar == 'X') { [EOL]             start++; [EOL]             isHex = true; [EOL]             if (start == seqEnd) { [EOL]                 return 0; [EOL]             } [EOL]         } [EOL]         int end = start; [EOL]         while (end < seqEnd && (input.charAt(end) >= '0' && input.charAt(end) <= '9' || input.charAt(end) >= 'a' && input.charAt(end) <= 'f' || input.charAt(end) >= 'A' && input.charAt(end) <= 'F')) { [EOL]             end++; [EOL]         } [EOL]         final boolean semiNext = end != seqEnd && input.charAt(end) == ';'; [EOL]         if (!semiNext) { [EOL]             if (isSet(OPTION.semiColonRequired)) { [EOL]                 return 0; [EOL]             } else if (isSet(OPTION.errorIfNoSemiColon)) { [EOL]                 throw new IllegalArgumentException("Semi-colon required at end of numeric entity"); [EOL]             } [EOL]         } [EOL]         int entityValue; [EOL]         try { [EOL]             if (isHex) { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16); [EOL]             } else { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10); [EOL]             } [EOL]         } catch (final NumberFormatException nfe) { [EOL]             return 0; [EOL]         } [EOL]         if (entityValue > 0xFFFF) { [EOL]             final char[] chrs = Character.toChars(entityValue); [EOL]             out.write(chrs[0]); [EOL]             out.write(chrs[1]); [EOL]         } else { [EOL]             out.write(entityValue); [EOL]         } [EOL]         return 2 + end - start + (isHex ? 1 : 0) + (semiNext ? 1 : 0); [EOL]     } [EOL]     return 0; [EOL] } 
 [LINE] out.write(chrs[1]); [LINE] @Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     final int seqEnd = input.length(); [EOL]     if (input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') { [EOL]         int start = index + 2; [EOL]         boolean isHex = false; [EOL]         final char firstChar = input.charAt(start); [EOL]         if (firstChar == 'x' || firstChar == 'X') { [EOL]             start++; [EOL]             isHex = true; [EOL]             if (start == seqEnd) { [EOL]                 return 0; [EOL]             } [EOL]         } [EOL]         int end = start; [EOL]         while (end < seqEnd && (input.charAt(end) >= '0' && input.charAt(end) <= '9' || input.charAt(end) >= 'a' && input.charAt(end) <= 'f' || input.charAt(end) >= 'A' && input.charAt(end) <= 'F')) { [EOL]             end++; [EOL]         } [EOL]         final boolean semiNext = end != seqEnd && input.charAt(end) == ';'; [EOL]         if (!semiNext) { [EOL]             if (isSet(OPTION.semiColonRequired)) { [EOL]                 return 0; [EOL]             } else if (isSet(OPTION.errorIfNoSemiColon)) { [EOL]                 throw new IllegalArgumentException("Semi-colon required at end of numeric entity"); [EOL]             } [EOL]         } [EOL]         int entityValue; [EOL]         try { [EOL]             if (isHex) { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16); [EOL]             } else { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10); [EOL]             } [EOL]         } catch (final NumberFormatException nfe) { [EOL]             return 0; [EOL]         } [EOL]         if (entityValue > 0xFFFF) { [EOL]             final char[] chrs = Character.toChars(entityValue); [EOL]             out.write(chrs[0]); [EOL]             out.write(chrs[1]); [EOL]         } else { [EOL]             out.write(entityValue); [EOL]         } [EOL]         return 2 + end - start + (isHex ? 1 : 0) + (semiNext ? 1 : 0); [EOL]     } [EOL]     return 0; [EOL] } 
 [LINE] out.write(entityValue); [LINE] @Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     final int seqEnd = input.length(); [EOL]     if (input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') { [EOL]         int start = index + 2; [EOL]         boolean isHex = false; [EOL]         final char firstChar = input.charAt(start); [EOL]         if (firstChar == 'x' || firstChar == 'X') { [EOL]             start++; [EOL]             isHex = true; [EOL]             if (start == seqEnd) { [EOL]                 return 0; [EOL]             } [EOL]         } [EOL]         int end = start; [EOL]         while (end < seqEnd && (input.charAt(end) >= '0' && input.charAt(end) <= '9' || input.charAt(end) >= 'a' && input.charAt(end) <= 'f' || input.charAt(end) >= 'A' && input.charAt(end) <= 'F')) { [EOL]             end++; [EOL]         } [EOL]         final boolean semiNext = end != seqEnd && input.charAt(end) == ';'; [EOL]         if (!semiNext) { [EOL]             if (isSet(OPTION.semiColonRequired)) { [EOL]                 return 0; [EOL]             } else if (isSet(OPTION.errorIfNoSemiColon)) { [EOL]                 throw new IllegalArgumentException("Semi-colon required at end of numeric entity"); [EOL]             } [EOL]         } [EOL]         int entityValue; [EOL]         try { [EOL]             if (isHex) { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16); [EOL]             } else { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10); [EOL]             } [EOL]         } catch (final NumberFormatException nfe) { [EOL]             return 0; [EOL]         } [EOL]         if (entityValue > 0xFFFF) { [EOL]             final char[] chrs = Character.toChars(entityValue); [EOL]             out.write(chrs[0]); [EOL]             out.write(chrs[1]); [EOL]         } else { [EOL]             out.write(entityValue); [EOL]         } [EOL]         return 2 + end - start + (isHex ? 1 : 0) + (semiNext ? 1 : 0); [EOL]     } [EOL]     return 0; [EOL] } 
 [LINE] return 2 + end - start + (isHex ? 1 : 0) + (semiNext ? 1 : 0); [LINE] @Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     final int seqEnd = input.length(); [EOL]     if (input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') { [EOL]         int start = index + 2; [EOL]         boolean isHex = false; [EOL]         final char firstChar = input.charAt(start); [EOL]         if (firstChar == 'x' || firstChar == 'X') { [EOL]             start++; [EOL]             isHex = true; [EOL]             if (start == seqEnd) { [EOL]                 return 0; [EOL]             } [EOL]         } [EOL]         int end = start; [EOL]         while (end < seqEnd && (input.charAt(end) >= '0' && input.charAt(end) <= '9' || input.charAt(end) >= 'a' && input.charAt(end) <= 'f' || input.charAt(end) >= 'A' && input.charAt(end) <= 'F')) { [EOL]             end++; [EOL]         } [EOL]         final boolean semiNext = end != seqEnd && input.charAt(end) == ';'; [EOL]         if (!semiNext) { [EOL]             if (isSet(OPTION.semiColonRequired)) { [EOL]                 return 0; [EOL]             } else if (isSet(OPTION.errorIfNoSemiColon)) { [EOL]                 throw new IllegalArgumentException("Semi-colon required at end of numeric entity"); [EOL]             } [EOL]         } [EOL]         int entityValue; [EOL]         try { [EOL]             if (isHex) { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16); [EOL]             } else { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10); [EOL]             } [EOL]         } catch (final NumberFormatException nfe) { [EOL]             return 0; [EOL]         } [EOL]         if (entityValue > 0xFFFF) { [EOL]             final char[] chrs = Character.toChars(entityValue); [EOL]             out.write(chrs[0]); [EOL]             out.write(chrs[1]); [EOL]         } else { [EOL]             out.write(entityValue); [EOL]         } [EOL]         return 2 + end - start + (isHex ? 1 : 0) + (semiNext ? 1 : 0); [EOL]     } [EOL]     return 0; [EOL] } 
 [LINE] @Override [LINE] @Override [EOL] public final T get() throws ConcurrentException { [EOL]     T result; [EOL]     while ((result = reference.get()) == null) { [EOL]         if (factory.compareAndSet(null, this)) { [EOL]             reference.set(initialize()); [EOL]         } [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] T result; [LINE] @Override [EOL] public final T get() throws ConcurrentException { [EOL]     T result; [EOL]     while ((result = reference.get()) == null) { [EOL]         if (factory.compareAndSet(null, this)) { [EOL]             reference.set(initialize()); [EOL]         } [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] while ((result = reference.get()) == null) { [LINE] @Override [EOL] public final T get() throws ConcurrentException { [EOL]     T result; [EOL]     while ((result = reference.get()) == null) { [EOL]         if (factory.compareAndSet(null, this)) { [EOL]             reference.set(initialize()); [EOL]         } [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] if (factory.compareAndSet(null, this)) { [LINE] @Override [EOL] public final T get() throws ConcurrentException { [EOL]     T result; [EOL]     while ((result = reference.get()) == null) { [EOL]         if (factory.compareAndSet(null, this)) { [EOL]             reference.set(initialize()); [EOL]         } [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] reference.set(initialize()); [LINE] @Override [EOL] public final T get() throws ConcurrentException { [EOL]     T result; [EOL]     while ((result = reference.get()) == null) { [EOL]         if (factory.compareAndSet(null, this)) { [EOL]             reference.set(initialize()); [EOL]         } [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] return result; [LINE] @Override [EOL] public final T get() throws ConcurrentException { [EOL]     T result; [EOL]     while ((result = reference.get()) == null) { [EOL]         if (factory.compareAndSet(null, this)) { [EOL]             reference.set(initialize()); [EOL]         } [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] out.write(input.toString()); [LINE] @Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     if (index != 0) { [EOL]         throw new IllegalStateException("CsvUnescaper should never reach the [1] index"); [EOL]     } [EOL]     if (input.charAt(0) != CSV_QUOTE || input.charAt(input.length() - 1) != CSV_QUOTE) { [EOL]         out.write(input.toString()); [EOL]         return input.length(); [EOL]     } [EOL]     final String quoteless = input.subSequence(1, input.length() - 1).toString(); [EOL]     if (StringUtils.containsAny(quoteless, CSV_SEARCH_CHARS)) { [EOL]         out.write(StringUtils.replace(quoteless, CSV_QUOTE_STR + CSV_QUOTE_STR, CSV_QUOTE_STR)); [EOL]     } else { [EOL]         out.write(input.toString()); [EOL]     } [EOL]     return input.length(); [EOL] } 
 [LINE] size = length; [LINE] public StrBuilder setLength(final int length) { [EOL]     if (length < 0) { [EOL]         throw new StringIndexOutOfBoundsException(length); [EOL]     } [EOL]     if (length < size) { [EOL]         size = length; [EOL]     } else if (length > size) { [EOL]         ensureCapacity(length); [EOL]         final int oldEnd = size; [EOL]         final int newEnd = length; [EOL]         size = length; [EOL]         for (int i = oldEnd; i < newEnd; i++) { [EOL]             buffer[i] = '\0'; [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] return ArrayUtils.EMPTY_CHAR_ARRAY; [LINE] public char[] toCharArray() { [EOL]     if (size == 0) { [EOL]         return ArrayUtils.EMPTY_CHAR_ARRAY; [EOL]     } [EOL]     final char[] chars = new char[size]; [EOL]     System.arraycopy(buffer, 0, chars, 0, size); [EOL]     return chars; [EOL] } 
 [LINE] return ArrayUtils.EMPTY_CHAR_ARRAY; [LINE] public char[] toCharArray(final int startIndex, int endIndex) { [EOL]     endIndex = validateRange(startIndex, endIndex); [EOL]     final int len = endIndex - startIndex; [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_CHAR_ARRAY; [EOL]     } [EOL]     final char[] chars = new char[len]; [EOL]     System.arraycopy(buffer, startIndex, chars, 0, len); [EOL]     return chars; [EOL] } 
 [LINE] return appendNull(); [LINE] public StrBuilder append(final StringBuffer str) { [EOL]     if (str == null) { [EOL]         return appendNull(); [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     if (strLen > 0) { [EOL]         final int len = length(); [EOL]         ensureCapacity(len + strLen); [EOL]         str.getChars(0, strLen, buffer, len); [EOL]         size += strLen; [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] return appendNull(); [LINE] public StrBuilder append(final StrBuilder str, final int startIndex, final int length) { [EOL]     if (str == null) { [EOL]         return appendNull(); [EOL]     } [EOL]     if (startIndex < 0 || startIndex > str.length()) { [EOL]         throw new StringIndexOutOfBoundsException("startIndex must be valid"); [EOL]     } [EOL]     if (length < 0 || (startIndex + length) > str.length()) { [EOL]         throw new StringIndexOutOfBoundsException("length must be valid"); [EOL]     } [EOL]     if (length > 0) { [EOL]         final int len = length(); [EOL]         ensureCapacity(len + length); [EOL]         str.getChars(startIndex, startIndex + length, buffer, len); [EOL]         size += length; [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] append(separator); [LINE] public StrBuilder appendWithSeparators(final Iterator<?> it, String separator) { [EOL]     if (it != null) { [EOL]         separator = ObjectUtils.toString(separator); [EOL]         while (it.hasNext()) { [EOL]             append(it.next()); [EOL]             if (it.hasNext()) { [EOL]                 append(separator); [EOL]             } [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] str = ""; [LINE] public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar) { [EOL]     if (width > 0) { [EOL]         ensureCapacity(size + width); [EOL]         String str = (obj == null ? getNullText() : obj.toString()); [EOL]         if (str == null) { [EOL]             str = ""; [EOL]         } [EOL]         final int strLen = str.length(); [EOL]         if (strLen >= width) { [EOL]             str.getChars(0, width, buffer, size); [EOL]         } else { [EOL]             final int padLen = width - strLen; [EOL]             str.getChars(0, strLen, buffer, size); [EOL]             for (int i = 0; i < padLen; i++) { [EOL]                 buffer[size + strLen + i] = padChar; [EOL]             } [EOL]         } [EOL]         size += width; [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] return insert(index, nullText); [LINE] public StrBuilder insert(final int index, final Object obj) { [EOL]     if (obj == null) { [EOL]         return insert(index, nullText); [EOL]     } [EOL]     return insert(index, obj.toString()); [EOL] } 
 [LINE] str = nullText; [LINE] public StrBuilder insert(final int index, String str) { [EOL]     validateIndex(index); [EOL]     if (str == null) { [EOL]         str = nullText; [EOL]     } [EOL]     if (str != null) { [EOL]         final int strLen = str.length(); [EOL]         if (strLen > 0) { [EOL]             final int newSize = size + strLen; [EOL]             ensureCapacity(newSize); [EOL]             System.arraycopy(buffer, index, buffer, index + strLen, size - index); [EOL]             size = newSize; [EOL]             str.getChars(0, strLen, buffer, index); [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] return insert(index, nullText); [LINE] public StrBuilder insert(final int index, final char[] chars) { [EOL]     validateIndex(index); [EOL]     if (chars == null) { [EOL]         return insert(index, nullText); [EOL]     } [EOL]     final int len = chars.length; [EOL]     if (len > 0) { [EOL]         ensureCapacity(size + len); [EOL]         System.arraycopy(buffer, index, buffer, index + len, size - index); [EOL]         System.arraycopy(chars, 0, buffer, index, len); [EOL]         size += len; [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] return insert(index, nullText); [LINE] public StrBuilder insert(final int index, final char[] chars, final int offset, final int length) { [EOL]     validateIndex(index); [EOL]     if (chars == null) { [EOL]         return insert(index, nullText); [EOL]     } [EOL]     if (offset < 0 || offset > chars.length) { [EOL]         throw new StringIndexOutOfBoundsException("Invalid offset: " + offset); [EOL]     } [EOL]     if (length < 0 || offset + length > chars.length) { [EOL]         throw new StringIndexOutOfBoundsException("Invalid length: " + length); [EOL]     } [EOL]     if (length > 0) { [EOL]         ensureCapacity(size + length); [EOL]         System.arraycopy(buffer, index, buffer, index + length, size - index); [EOL]         System.arraycopy(chars, offset, buffer, index, length); [EOL]         size += length; [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] if (length > 0) { [LINE] public StrBuilder insert(final int index, final char[] chars, final int offset, final int length) { [EOL]     validateIndex(index); [EOL]     if (chars == null) { [EOL]         return insert(index, nullText); [EOL]     } [EOL]     if (offset < 0 || offset > chars.length) { [EOL]         throw new StringIndexOutOfBoundsException("Invalid offset: " + offset); [EOL]     } [EOL]     if (length < 0 || offset + length > chars.length) { [EOL]         throw new StringIndexOutOfBoundsException("Invalid length: " + length); [EOL]     } [EOL]     if (length > 0) { [EOL]         ensureCapacity(size + length); [EOL]         System.arraycopy(buffer, index, buffer, index + length, size - index); [EOL]         System.arraycopy(chars, offset, buffer, index, length); [EOL]         size += length; [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] ensureCapacity(size + length); [LINE] public StrBuilder insert(final int index, final char[] chars, final int offset, final int length) { [EOL]     validateIndex(index); [EOL]     if (chars == null) { [EOL]         return insert(index, nullText); [EOL]     } [EOL]     if (offset < 0 || offset > chars.length) { [EOL]         throw new StringIndexOutOfBoundsException("Invalid offset: " + offset); [EOL]     } [EOL]     if (length < 0 || offset + length > chars.length) { [EOL]         throw new StringIndexOutOfBoundsException("Invalid length: " + length); [EOL]     } [EOL]     if (length > 0) { [EOL]         ensureCapacity(size + length); [EOL]         System.arraycopy(buffer, index, buffer, index + length, size - index); [EOL]         System.arraycopy(chars, offset, buffer, index, length); [EOL]         size += length; [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] System.arraycopy(buffer, index, buffer, index + length, size - index); [LINE] public StrBuilder insert(final int index, final char[] chars, final int offset, final int length) { [EOL]     validateIndex(index); [EOL]     if (chars == null) { [EOL]         return insert(index, nullText); [EOL]     } [EOL]     if (offset < 0 || offset > chars.length) { [EOL]         throw new StringIndexOutOfBoundsException("Invalid offset: " + offset); [EOL]     } [EOL]     if (length < 0 || offset + length > chars.length) { [EOL]         throw new StringIndexOutOfBoundsException("Invalid length: " + length); [EOL]     } [EOL]     if (length > 0) { [EOL]         ensureCapacity(size + length); [EOL]         System.arraycopy(buffer, index, buffer, index + length, size - index); [EOL]         System.arraycopy(chars, offset, buffer, index, length); [EOL]         size += length; [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] System.arraycopy(chars, offset, buffer, index, length); [LINE] public StrBuilder insert(final int index, final char[] chars, final int offset, final int length) { [EOL]     validateIndex(index); [EOL]     if (chars == null) { [EOL]         return insert(index, nullText); [EOL]     } [EOL]     if (offset < 0 || offset > chars.length) { [EOL]         throw new StringIndexOutOfBoundsException("Invalid offset: " + offset); [EOL]     } [EOL]     if (length < 0 || offset + length > chars.length) { [EOL]         throw new StringIndexOutOfBoundsException("Invalid length: " + length); [EOL]     } [EOL]     if (length > 0) { [EOL]         ensureCapacity(size + length); [EOL]         System.arraycopy(buffer, index, buffer, index + length, size - index); [EOL]         System.arraycopy(chars, offset, buffer, index, length); [EOL]         size += length; [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] size += length; [LINE] public StrBuilder insert(final int index, final char[] chars, final int offset, final int length) { [EOL]     validateIndex(index); [EOL]     if (chars == null) { [EOL]         return insert(index, nullText); [EOL]     } [EOL]     if (offset < 0 || offset > chars.length) { [EOL]         throw new StringIndexOutOfBoundsException("Invalid offset: " + offset); [EOL]     } [EOL]     if (length < 0 || offset + length > chars.length) { [EOL]         throw new StringIndexOutOfBoundsException("Invalid length: " + length); [EOL]     } [EOL]     if (length > 0) { [EOL]         ensureCapacity(size + length); [EOL]         System.arraycopy(buffer, index, buffer, index + length, size - index); [EOL]         System.arraycopy(chars, offset, buffer, index, length); [EOL]         size += length; [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] return this; [LINE] public StrBuilder insert(final int index, final char[] chars, final int offset, final int length) { [EOL]     validateIndex(index); [EOL]     if (chars == null) { [EOL]         return insert(index, nullText); [EOL]     } [EOL]     if (offset < 0 || offset > chars.length) { [EOL]         throw new StringIndexOutOfBoundsException("Invalid offset: " + offset); [EOL]     } [EOL]     if (length < 0 || offset + length > chars.length) { [EOL]         throw new StringIndexOutOfBoundsException("Invalid length: " + length); [EOL]     } [EOL]     if (length > 0) { [EOL]         ensureCapacity(size + length); [EOL]         System.arraycopy(buffer, index, buffer, index + length, size - index); [EOL]         System.arraycopy(chars, offset, buffer, index, length); [EOL]         size += length; [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] final int start = i; [LINE] public StrBuilder deleteAll(final char ch) { [EOL]     for (int i = 0; i < size; i++) { [EOL]         if (buffer[i] == ch) { [EOL]             final int start = i; [EOL]             while (++i < size) { [EOL]                 if (buffer[i] != ch) { [EOL]                     break; [EOL]                 } [EOL]             } [EOL]             final int len = i - start; [EOL]             deleteImpl(start, i, len); [EOL]             i -= len; [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] while (++i < size) { [LINE] public StrBuilder deleteAll(final char ch) { [EOL]     for (int i = 0; i < size; i++) { [EOL]         if (buffer[i] == ch) { [EOL]             final int start = i; [EOL]             while (++i < size) { [EOL]                 if (buffer[i] != ch) { [EOL]                     break; [EOL]                 } [EOL]             } [EOL]             final int len = i - start; [EOL]             deleteImpl(start, i, len); [EOL]             i -= len; [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] if (buffer[i] != ch) { [LINE] public StrBuilder deleteAll(final char ch) { [EOL]     for (int i = 0; i < size; i++) { [EOL]         if (buffer[i] == ch) { [EOL]             final int start = i; [EOL]             while (++i < size) { [EOL]                 if (buffer[i] != ch) { [EOL]                     break; [EOL]                 } [EOL]             } [EOL]             final int len = i - start; [EOL]             deleteImpl(start, i, len); [EOL]             i -= len; [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] break; [LINE] public StrBuilder deleteAll(final char ch) { [EOL]     for (int i = 0; i < size; i++) { [EOL]         if (buffer[i] == ch) { [EOL]             final int start = i; [EOL]             while (++i < size) { [EOL]                 if (buffer[i] != ch) { [EOL]                     break; [EOL]                 } [EOL]             } [EOL]             final int len = i - start; [EOL]             deleteImpl(start, i, len); [EOL]             i -= len; [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] final int len = i - start; [LINE] public StrBuilder deleteAll(final char ch) { [EOL]     for (int i = 0; i < size; i++) { [EOL]         if (buffer[i] == ch) { [EOL]             final int start = i; [EOL]             while (++i < size) { [EOL]                 if (buffer[i] != ch) { [EOL]                     break; [EOL]                 } [EOL]             } [EOL]             final int len = i - start; [EOL]             deleteImpl(start, i, len); [EOL]             i -= len; [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] deleteImpl(start, i, len); [LINE] public StrBuilder deleteAll(final char ch) { [EOL]     for (int i = 0; i < size; i++) { [EOL]         if (buffer[i] == ch) { [EOL]             final int start = i; [EOL]             while (++i < size) { [EOL]                 if (buffer[i] != ch) { [EOL]                     break; [EOL]                 } [EOL]             } [EOL]             final int len = i - start; [EOL]             deleteImpl(start, i, len); [EOL]             i -= len; [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] i -= len; [LINE] public StrBuilder deleteAll(final char ch) { [EOL]     for (int i = 0; i < size; i++) { [EOL]         if (buffer[i] == ch) { [EOL]             final int start = i; [EOL]             while (++i < size) { [EOL]                 if (buffer[i] != ch) { [EOL]                     break; [EOL]                 } [EOL]             } [EOL]             final int len = i - start; [EOL]             deleteImpl(start, i, len); [EOL]             i -= len; [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] buffer[i] = replace; [LINE] public StrBuilder replaceAll(final char search, final char replace) { [EOL]     if (search != replace) { [EOL]         for (int i = 0; i < size; i++) { [EOL]             if (buffer[i] == search) { [EOL]                 buffer[i] = replace; [EOL]             } [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] buffer[i] = replace; [LINE] public StrBuilder replaceFirst(final char search, final char replace) { [EOL]     if (search != replace) { [EOL]         for (int i = 0; i < size; i++) { [EOL]             if (buffer[i] == search) { [EOL]                 buffer[i] = replace; [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] break; [LINE] public StrBuilder replaceFirst(final char search, final char replace) { [EOL]     if (search != replace) { [EOL]         for (int i = 0; i < size; i++) { [EOL]             if (buffer[i] == search) { [EOL]                 buffer[i] = replace; [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] pos++; [LINE] public StrBuilder trim() { [EOL]     if (size == 0) { [EOL]         return this; [EOL]     } [EOL]     int len = size; [EOL]     final char[] buf = buffer; [EOL]     int pos = 0; [EOL]     while (pos < len && buf[pos] <= ' ') { [EOL]         pos++; [EOL]     } [EOL]     while (pos < len && buf[len - 1] <= ' ') { [EOL]         len--; [EOL]     } [EOL]     if (len < size) { [EOL]         delete(len, size); [EOL]     } [EOL]     if (pos > 0) { [EOL]         delete(0, pos); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] delete(0, pos); [LINE] public StrBuilder trim() { [EOL]     if (size == 0) { [EOL]         return this; [EOL]     } [EOL]     int len = size; [EOL]     final char[] buf = buffer; [EOL]     int pos = 0; [EOL]     while (pos < len && buf[pos] <= ' ') { [EOL]         pos++; [EOL]     } [EOL]     while (pos < len && buf[len - 1] <= ' ') { [EOL]         len--; [EOL]     } [EOL]     if (len < size) { [EOL]         delete(len, size); [EOL]     } [EOL]     if (pos > 0) { [EOL]         delete(0, pos); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] return false; [LINE] public boolean startsWith(final String str) { [EOL]     if (str == null) { [EOL]         return false; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return true; [EOL]     } [EOL]     if (len > size) { [EOL]         return false; [EOL]     } [EOL]     for (int i = 0; i < len; i++) { [EOL]         if (buffer[i] != str.charAt(i)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] public boolean endsWith(final String str) { [LINE] public boolean endsWith(final String str) { [EOL]     if (str == null) { [EOL]         return false; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return true; [EOL]     } [EOL]     if (len > size) { [EOL]         return false; [EOL]     } [EOL]     int pos = size - len; [EOL]     for (int i = 0; i < len; i++, pos++) { [EOL]         if (buffer[pos] != str.charAt(i)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] if (str == null) { [LINE] public boolean endsWith(final String str) { [EOL]     if (str == null) { [EOL]         return false; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return true; [EOL]     } [EOL]     if (len > size) { [EOL]         return false; [EOL]     } [EOL]     int pos = size - len; [EOL]     for (int i = 0; i < len; i++, pos++) { [EOL]         if (buffer[pos] != str.charAt(i)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] return false; [LINE] public boolean endsWith(final String str) { [EOL]     if (str == null) { [EOL]         return false; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return true; [EOL]     } [EOL]     if (len > size) { [EOL]         return false; [EOL]     } [EOL]     int pos = size - len; [EOL]     for (int i = 0; i < len; i++, pos++) { [EOL]         if (buffer[pos] != str.charAt(i)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] final int len = str.length(); [LINE] public boolean endsWith(final String str) { [EOL]     if (str == null) { [EOL]         return false; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return true; [EOL]     } [EOL]     if (len > size) { [EOL]         return false; [EOL]     } [EOL]     int pos = size - len; [EOL]     for (int i = 0; i < len; i++, pos++) { [EOL]         if (buffer[pos] != str.charAt(i)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] if (len == 0) { [LINE] public boolean endsWith(final String str) { [EOL]     if (str == null) { [EOL]         return false; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return true; [EOL]     } [EOL]     if (len > size) { [EOL]         return false; [EOL]     } [EOL]     int pos = size - len; [EOL]     for (int i = 0; i < len; i++, pos++) { [EOL]         if (buffer[pos] != str.charAt(i)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] return true; [LINE] public boolean endsWith(final String str) { [EOL]     if (str == null) { [EOL]         return false; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return true; [EOL]     } [EOL]     if (len > size) { [EOL]         return false; [EOL]     } [EOL]     int pos = size - len; [EOL]     for (int i = 0; i < len; i++, pos++) { [EOL]         if (buffer[pos] != str.charAt(i)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] if (len > size) { [LINE] public boolean endsWith(final String str) { [EOL]     if (str == null) { [EOL]         return false; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return true; [EOL]     } [EOL]     if (len > size) { [EOL]         return false; [EOL]     } [EOL]     int pos = size - len; [EOL]     for (int i = 0; i < len; i++, pos++) { [EOL]         if (buffer[pos] != str.charAt(i)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] return false; [LINE] public boolean endsWith(final String str) { [EOL]     if (str == null) { [EOL]         return false; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return true; [EOL]     } [EOL]     if (len > size) { [EOL]         return false; [EOL]     } [EOL]     int pos = size - len; [EOL]     for (int i = 0; i < len; i++, pos++) { [EOL]         if (buffer[pos] != str.charAt(i)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] int pos = size - len; [LINE] public boolean endsWith(final String str) { [EOL]     if (str == null) { [EOL]         return false; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return true; [EOL]     } [EOL]     if (len > size) { [EOL]         return false; [EOL]     } [EOL]     int pos = size - len; [EOL]     for (int i = 0; i < len; i++, pos++) { [EOL]         if (buffer[pos] != str.charAt(i)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] for (int i = 0; i < len; i++,pos++) { [LINE] public boolean endsWith(final String str) { [EOL]     if (str == null) { [EOL]         return false; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return true; [EOL]     } [EOL]     if (len > size) { [EOL]         return false; [EOL]     } [EOL]     int pos = size - len; [EOL]     for (int i = 0; i < len; i++, pos++) { [EOL]         if (buffer[pos] != str.charAt(i)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] if (buffer[pos] != str.charAt(i)) { [LINE] public boolean endsWith(final String str) { [EOL]     if (str == null) { [EOL]         return false; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return true; [EOL]     } [EOL]     if (len > size) { [EOL]         return false; [EOL]     } [EOL]     int pos = size - len; [EOL]     for (int i = 0; i < len; i++, pos++) { [EOL]         if (buffer[pos] != str.charAt(i)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] return false; [LINE] public boolean endsWith(final String str) { [EOL]     if (str == null) { [EOL]         return false; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return true; [EOL]     } [EOL]     if (len > size) { [EOL]         return false; [EOL]     } [EOL]     int pos = size - len; [EOL]     for (int i = 0; i < len; i++, pos++) { [EOL]         if (buffer[pos] != str.charAt(i)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] return true; [LINE] public boolean endsWith(final String str) { [EOL]     if (str == null) { [EOL]         return false; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return true; [EOL]     } [EOL]     if (len > size) { [EOL]         return false; [EOL]     } [EOL]     int pos = size - len; [EOL]     for (int i = 0; i < len; i++, pos++) { [EOL]         if (buffer[pos] != str.charAt(i)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] return new String(buffer, index, length); [LINE] public String midString(int index, final int length) { [EOL]     if (index < 0) { [EOL]         index = 0; [EOL]     } [EOL]     if (length <= 0 || index >= size) { [EOL]         return ""; [EOL]     } [EOL]     if (size <= index + length) { [EOL]         return new String(buffer, index, size - index); [EOL]     } [EOL]     return new String(buffer, index, length); [EOL] } 
 [LINE] return indexOf(str.charAt(0), startIndex); [LINE] public int indexOf(final String str, int startIndex) { [EOL]     startIndex = (startIndex < 0 ? 0 : startIndex); [EOL]     if (str == null || startIndex >= size) { [EOL]         return -1; [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     if (strLen == 1) { [EOL]         return indexOf(str.charAt(0), startIndex); [EOL]     } [EOL]     if (strLen == 0) { [EOL]         return startIndex; [EOL]     } [EOL]     if (strLen > size) { [EOL]         return -1; [EOL]     } [EOL]     final char[] thisBuf = buffer; [EOL]     final int len = size - strLen + 1; [EOL]     outer: for (int i = startIndex; i < len; i++) { [EOL]         for (int j = 0; j < strLen; j++) { [EOL]             if (str.charAt(j) != thisBuf[i + j]) { [EOL]                 continue outer; [EOL]             } [EOL]         } [EOL]         return i; [EOL]     } [EOL]     return -1; [EOL] } 
 [LINE] return lastIndexOf(str.charAt(0), startIndex); [LINE] public int lastIndexOf(final String str, int startIndex) { [EOL]     startIndex = (startIndex >= size ? size - 1 : startIndex); [EOL]     if (str == null || startIndex < 0) { [EOL]         return -1; [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     if (strLen > 0 && strLen <= size) { [EOL]         if (strLen == 1) { [EOL]             return lastIndexOf(str.charAt(0), startIndex); [EOL]         } [EOL]         outer: for (int i = startIndex - strLen + 1; i >= 0; i--) { [EOL]             for (int j = 0; j < strLen; j++) { [EOL]                 if (str.charAt(j) != buffer[i + j]) { [EOL]                     continue outer; [EOL]                 } [EOL]             } [EOL]             return i; [EOL]         } [EOL]     } else if (strLen == 0) { [EOL]         return startIndex; [EOL]     } [EOL]     return -1; [EOL] } 
 [LINE] for (int i = size - 1; i >= 0; i--) { [LINE] public boolean equalsIgnoreCase(final StrBuilder other) { [EOL]     if (this == other) { [EOL]         return true; [EOL]     } [EOL]     if (this.size != other.size) { [EOL]         return false; [EOL]     } [EOL]     final char[] thisBuf = this.buffer; [EOL]     final char[] otherBuf = other.buffer; [EOL]     for (int i = size - 1; i >= 0; i--) { [EOL]         final char c1 = thisBuf[i]; [EOL]         final char c2 = otherBuf[i]; [EOL]         if (c1 != c2 && Character.toUpperCase(c1) != Character.toUpperCase(c2)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] final char c1 = thisBuf[i]; [LINE] public boolean equalsIgnoreCase(final StrBuilder other) { [EOL]     if (this == other) { [EOL]         return true; [EOL]     } [EOL]     if (this.size != other.size) { [EOL]         return false; [EOL]     } [EOL]     final char[] thisBuf = this.buffer; [EOL]     final char[] otherBuf = other.buffer; [EOL]     for (int i = size - 1; i >= 0; i--) { [EOL]         final char c1 = thisBuf[i]; [EOL]         final char c2 = otherBuf[i]; [EOL]         if (c1 != c2 && Character.toUpperCase(c1) != Character.toUpperCase(c2)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] final char c2 = otherBuf[i]; [LINE] public boolean equalsIgnoreCase(final StrBuilder other) { [EOL]     if (this == other) { [EOL]         return true; [EOL]     } [EOL]     if (this.size != other.size) { [EOL]         return false; [EOL]     } [EOL]     final char[] thisBuf = this.buffer; [EOL]     final char[] otherBuf = other.buffer; [EOL]     for (int i = size - 1; i >= 0; i--) { [EOL]         final char c1 = thisBuf[i]; [EOL]         final char c2 = otherBuf[i]; [EOL]         if (c1 != c2 && Character.toUpperCase(c1) != Character.toUpperCase(c2)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] if (c1 != c2 && Character.toUpperCase(c1) != Character.toUpperCase(c2)) { [LINE] public boolean equalsIgnoreCase(final StrBuilder other) { [EOL]     if (this == other) { [EOL]         return true; [EOL]     } [EOL]     if (this.size != other.size) { [EOL]         return false; [EOL]     } [EOL]     final char[] thisBuf = this.buffer; [EOL]     final char[] otherBuf = other.buffer; [EOL]     for (int i = size - 1; i >= 0; i--) { [EOL]         final char c1 = thisBuf[i]; [EOL]         final char c2 = otherBuf[i]; [EOL]         if (c1 != c2 && Character.toUpperCase(c1) != Character.toUpperCase(c2)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] return true; [LINE] public boolean equalsIgnoreCase(final StrBuilder other) { [EOL]     if (this == other) { [EOL]         return true; [EOL]     } [EOL]     if (this.size != other.size) { [EOL]         return false; [EOL]     } [EOL]     final char[] thisBuf = this.buffer; [EOL]     final char[] otherBuf = other.buffer; [EOL]     for (int i = size - 1; i >= 0; i--) { [EOL]         final char c1 = thisBuf[i]; [EOL]         final char c2 = otherBuf[i]; [EOL]         if (c1 != c2 && Character.toUpperCase(c1) != Character.toUpperCase(c2)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] if (thisBuf[i] != otherBuf[i]) { [LINE] public boolean equals(final StrBuilder other) { [EOL]     if (this == other) { [EOL]         return true; [EOL]     } [EOL]     if (this.size != other.size) { [EOL]         return false; [EOL]     } [EOL]     final char[] thisBuf = this.buffer; [EOL]     final char[] otherBuf = other.buffer; [EOL]     for (int i = size - 1; i >= 0; i--) { [EOL]         if (thisBuf[i] != otherBuf[i]) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] return false; [LINE] public boolean equals(final StrBuilder other) { [EOL]     if (this == other) { [EOL]         return true; [EOL]     } [EOL]     if (this.size != other.size) { [EOL]         return false; [EOL]     } [EOL]     final char[] thisBuf = this.buffer; [EOL]     final char[] otherBuf = other.buffer; [EOL]     for (int i = size - 1; i >= 0; i--) { [EOL]         if (thisBuf[i] != otherBuf[i]) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] return 0; [LINE] @Override [EOL] public int read(final char[] b, final int off, int len) { [EOL]     if (off < 0 || len < 0 || off > b.length || (off + len) > b.length || (off + len) < 0) { [EOL]         throw new IndexOutOfBoundsException(); [EOL]     } [EOL]     if (len == 0) { [EOL]         return 0; [EOL]     } [EOL]     if (pos >= StrBuilder.this.size()) { [EOL]         return -1; [EOL]     } [EOL]     if (pos + len > size()) { [EOL]         len = StrBuilder.this.size() - pos; [EOL]     } [EOL]     StrBuilder.this.getChars(pos, pos + len, b, off); [EOL]     pos += len; [EOL]     return len; [EOL] } 
 [LINE] n = StrBuilder.this.size() - pos; [LINE] @Override [EOL] public long skip(long n) { [EOL]     if (pos + n > StrBuilder.this.size()) { [EOL]         n = StrBuilder.this.size() - pos; [EOL]     } [EOL]     if (n < 0) { [EOL]         return 0; [EOL]     } [EOL]     pos += n; [EOL]     return n; [EOL] } 
 [LINE] return buf.toString(); [LINE] public String replace(final String source) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(source); [EOL]     if (substitute(buf, 0, source.length()) == false) { [EOL]         return source; [EOL]     } [EOL]     return buf.toString(); [EOL] } 
 [LINE] return buf.toString(); [LINE] public String replace(final String source, final int offset, final int length) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(length).append(source, offset, length); [EOL]     if (substitute(buf, 0, length) == false) { [EOL]         return source.substring(offset, offset + length); [EOL]     } [EOL]     return buf.toString(); [EOL] } 
 [LINE] final StrBuilder bufName = new StrBuilder(varName); [LINE] private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables) { [EOL]     final StrMatcher prefixMatcher = getVariablePrefixMatcher(); [EOL]     final StrMatcher suffixMatcher = getVariableSuffixMatcher(); [EOL]     final char escape = getEscapeChar(); [EOL]     final boolean top = priorVariables == null; [EOL]     boolean altered = false; [EOL]     int lengthChange = 0; [EOL]     char[] chars = buf.buffer; [EOL]     int bufEnd = offset + length; [EOL]     int pos = offset; [EOL]     while (pos < bufEnd) { [EOL]         final int startMatchLen = prefixMatcher.isMatch(chars, pos, offset, bufEnd); [EOL]         if (startMatchLen == 0) { [EOL]             pos++; [EOL]         } else { [EOL]             if (pos > offset && chars[pos - 1] == escape) { [EOL]                 buf.deleteCharAt(pos - 1); [EOL]                 chars = buf.buffer; [EOL]                 lengthChange--; [EOL]                 altered = true; [EOL]                 bufEnd--; [EOL]             } else { [EOL]                 final int startPos = pos; [EOL]                 pos += startMatchLen; [EOL]                 int endMatchLen = 0; [EOL]                 int nestedVarCount = 0; [EOL]                 while (pos < bufEnd) { [EOL]                     if (isEnableSubstitutionInVariables() && (endMatchLen = prefixMatcher.isMatch(chars, pos, offset, bufEnd)) != 0) { [EOL]                         nestedVarCount++; [EOL]                         pos += endMatchLen; [EOL]                         continue; [EOL]                     } [EOL]                     endMatchLen = suffixMatcher.isMatch(chars, pos, offset, bufEnd); [EOL]                     if (endMatchLen == 0) { [EOL]                         pos++; [EOL]                     } else { [EOL]                         if (nestedVarCount == 0) { [EOL]                             String varName = new String(chars, startPos + startMatchLen, pos - startPos - startMatchLen); [EOL]                             if (isEnableSubstitutionInVariables()) { [EOL]                                 final StrBuilder bufName = new StrBuilder(varName); [EOL]                                 substitute(bufName, 0, bufName.length()); [EOL]                                 varName = bufName.toString(); [EOL]                             } [EOL]                             pos += endMatchLen; [EOL]                             final int endPos = pos; [EOL]                             if (priorVariables == null) { [EOL]                                 priorVariables = new ArrayList<String>(); [EOL]                                 priorVariables.add(new String(chars, offset, length)); [EOL]                             } [EOL]                             checkCyclicSubstitution(varName, priorVariables); [EOL]                             priorVariables.add(varName); [EOL]                             final String varValue = resolveVariable(varName, buf, startPos, endPos); [EOL]                             if (varValue != null) { [EOL]                                 final int varLen = varValue.length(); [EOL]                                 buf.replace(startPos, endPos, varValue); [EOL]                                 altered = true; [EOL]                                 int change = substitute(buf, startPos, varLen, priorVariables); [EOL]                                 change = change + varLen - (endPos - startPos); [EOL]                                 pos += change; [EOL]                                 bufEnd += change; [EOL]                                 lengthChange += change; [EOL]                                 chars = buf.buffer; [EOL]                             } [EOL]                             priorVariables.remove(priorVariables.size() - 1); [EOL]                             break; [EOL]                         } else { [EOL]                             nestedVarCount--; [EOL]                             pos += endMatchLen; [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (top) { [EOL]         return altered ? 1 : 0; [EOL]     } [EOL]     return lengthChange; [EOL] } 
 [LINE] substitute(bufName, 0, bufName.length()); [LINE] private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables) { [EOL]     final StrMatcher prefixMatcher = getVariablePrefixMatcher(); [EOL]     final StrMatcher suffixMatcher = getVariableSuffixMatcher(); [EOL]     final char escape = getEscapeChar(); [EOL]     final boolean top = priorVariables == null; [EOL]     boolean altered = false; [EOL]     int lengthChange = 0; [EOL]     char[] chars = buf.buffer; [EOL]     int bufEnd = offset + length; [EOL]     int pos = offset; [EOL]     while (pos < bufEnd) { [EOL]         final int startMatchLen = prefixMatcher.isMatch(chars, pos, offset, bufEnd); [EOL]         if (startMatchLen == 0) { [EOL]             pos++; [EOL]         } else { [EOL]             if (pos > offset && chars[pos - 1] == escape) { [EOL]                 buf.deleteCharAt(pos - 1); [EOL]                 chars = buf.buffer; [EOL]                 lengthChange--; [EOL]                 altered = true; [EOL]                 bufEnd--; [EOL]             } else { [EOL]                 final int startPos = pos; [EOL]                 pos += startMatchLen; [EOL]                 int endMatchLen = 0; [EOL]                 int nestedVarCount = 0; [EOL]                 while (pos < bufEnd) { [EOL]                     if (isEnableSubstitutionInVariables() && (endMatchLen = prefixMatcher.isMatch(chars, pos, offset, bufEnd)) != 0) { [EOL]                         nestedVarCount++; [EOL]                         pos += endMatchLen; [EOL]                         continue; [EOL]                     } [EOL]                     endMatchLen = suffixMatcher.isMatch(chars, pos, offset, bufEnd); [EOL]                     if (endMatchLen == 0) { [EOL]                         pos++; [EOL]                     } else { [EOL]                         if (nestedVarCount == 0) { [EOL]                             String varName = new String(chars, startPos + startMatchLen, pos - startPos - startMatchLen); [EOL]                             if (isEnableSubstitutionInVariables()) { [EOL]                                 final StrBuilder bufName = new StrBuilder(varName); [EOL]                                 substitute(bufName, 0, bufName.length()); [EOL]                                 varName = bufName.toString(); [EOL]                             } [EOL]                             pos += endMatchLen; [EOL]                             final int endPos = pos; [EOL]                             if (priorVariables == null) { [EOL]                                 priorVariables = new ArrayList<String>(); [EOL]                                 priorVariables.add(new String(chars, offset, length)); [EOL]                             } [EOL]                             checkCyclicSubstitution(varName, priorVariables); [EOL]                             priorVariables.add(varName); [EOL]                             final String varValue = resolveVariable(varName, buf, startPos, endPos); [EOL]                             if (varValue != null) { [EOL]                                 final int varLen = varValue.length(); [EOL]                                 buf.replace(startPos, endPos, varValue); [EOL]                                 altered = true; [EOL]                                 int change = substitute(buf, startPos, varLen, priorVariables); [EOL]                                 change = change + varLen - (endPos - startPos); [EOL]                                 pos += change; [EOL]                                 bufEnd += change; [EOL]                                 lengthChange += change; [EOL]                                 chars = buf.buffer; [EOL]                             } [EOL]                             priorVariables.remove(priorVariables.size() - 1); [EOL]                             break; [EOL]                         } else { [EOL]                             nestedVarCount--; [EOL]                             pos += endMatchLen; [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (top) { [EOL]         return altered ? 1 : 0; [EOL]     } [EOL]     return lengthChange; [EOL] } 
 [LINE] varName = bufName.toString(); [LINE] private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables) { [EOL]     final StrMatcher prefixMatcher = getVariablePrefixMatcher(); [EOL]     final StrMatcher suffixMatcher = getVariableSuffixMatcher(); [EOL]     final char escape = getEscapeChar(); [EOL]     final boolean top = priorVariables == null; [EOL]     boolean altered = false; [EOL]     int lengthChange = 0; [EOL]     char[] chars = buf.buffer; [EOL]     int bufEnd = offset + length; [EOL]     int pos = offset; [EOL]     while (pos < bufEnd) { [EOL]         final int startMatchLen = prefixMatcher.isMatch(chars, pos, offset, bufEnd); [EOL]         if (startMatchLen == 0) { [EOL]             pos++; [EOL]         } else { [EOL]             if (pos > offset && chars[pos - 1] == escape) { [EOL]                 buf.deleteCharAt(pos - 1); [EOL]                 chars = buf.buffer; [EOL]                 lengthChange--; [EOL]                 altered = true; [EOL]                 bufEnd--; [EOL]             } else { [EOL]                 final int startPos = pos; [EOL]                 pos += startMatchLen; [EOL]                 int endMatchLen = 0; [EOL]                 int nestedVarCount = 0; [EOL]                 while (pos < bufEnd) { [EOL]                     if (isEnableSubstitutionInVariables() && (endMatchLen = prefixMatcher.isMatch(chars, pos, offset, bufEnd)) != 0) { [EOL]                         nestedVarCount++; [EOL]                         pos += endMatchLen; [EOL]                         continue; [EOL]                     } [EOL]                     endMatchLen = suffixMatcher.isMatch(chars, pos, offset, bufEnd); [EOL]                     if (endMatchLen == 0) { [EOL]                         pos++; [EOL]                     } else { [EOL]                         if (nestedVarCount == 0) { [EOL]                             String varName = new String(chars, startPos + startMatchLen, pos - startPos - startMatchLen); [EOL]                             if (isEnableSubstitutionInVariables()) { [EOL]                                 final StrBuilder bufName = new StrBuilder(varName); [EOL]                                 substitute(bufName, 0, bufName.length()); [EOL]                                 varName = bufName.toString(); [EOL]                             } [EOL]                             pos += endMatchLen; [EOL]                             final int endPos = pos; [EOL]                             if (priorVariables == null) { [EOL]                                 priorVariables = new ArrayList<String>(); [EOL]                                 priorVariables.add(new String(chars, offset, length)); [EOL]                             } [EOL]                             checkCyclicSubstitution(varName, priorVariables); [EOL]                             priorVariables.add(varName); [EOL]                             final String varValue = resolveVariable(varName, buf, startPos, endPos); [EOL]                             if (varValue != null) { [EOL]                                 final int varLen = varValue.length(); [EOL]                                 buf.replace(startPos, endPos, varValue); [EOL]                                 altered = true; [EOL]                                 int change = substitute(buf, startPos, varLen, priorVariables); [EOL]                                 change = change + varLen - (endPos - startPos); [EOL]                                 pos += change; [EOL]                                 bufEnd += change; [EOL]                                 lengthChange += change; [EOL]                                 chars = buf.buffer; [EOL]                             } [EOL]                             priorVariables.remove(priorVariables.size() - 1); [EOL]                             break; [EOL]                         } else { [EOL]                             nestedVarCount--; [EOL]                             pos += endMatchLen; [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (top) { [EOL]         return altered ? 1 : 0; [EOL]     } [EOL]     return lengthChange; [EOL] } 
 [LINE] nestedVarCount--; [LINE] private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables) { [EOL]     final StrMatcher prefixMatcher = getVariablePrefixMatcher(); [EOL]     final StrMatcher suffixMatcher = getVariableSuffixMatcher(); [EOL]     final char escape = getEscapeChar(); [EOL]     final boolean top = priorVariables == null; [EOL]     boolean altered = false; [EOL]     int lengthChange = 0; [EOL]     char[] chars = buf.buffer; [EOL]     int bufEnd = offset + length; [EOL]     int pos = offset; [EOL]     while (pos < bufEnd) { [EOL]         final int startMatchLen = prefixMatcher.isMatch(chars, pos, offset, bufEnd); [EOL]         if (startMatchLen == 0) { [EOL]             pos++; [EOL]         } else { [EOL]             if (pos > offset && chars[pos - 1] == escape) { [EOL]                 buf.deleteCharAt(pos - 1); [EOL]                 chars = buf.buffer; [EOL]                 lengthChange--; [EOL]                 altered = true; [EOL]                 bufEnd--; [EOL]             } else { [EOL]                 final int startPos = pos; [EOL]                 pos += startMatchLen; [EOL]                 int endMatchLen = 0; [EOL]                 int nestedVarCount = 0; [EOL]                 while (pos < bufEnd) { [EOL]                     if (isEnableSubstitutionInVariables() && (endMatchLen = prefixMatcher.isMatch(chars, pos, offset, bufEnd)) != 0) { [EOL]                         nestedVarCount++; [EOL]                         pos += endMatchLen; [EOL]                         continue; [EOL]                     } [EOL]                     endMatchLen = suffixMatcher.isMatch(chars, pos, offset, bufEnd); [EOL]                     if (endMatchLen == 0) { [EOL]                         pos++; [EOL]                     } else { [EOL]                         if (nestedVarCount == 0) { [EOL]                             String varName = new String(chars, startPos + startMatchLen, pos - startPos - startMatchLen); [EOL]                             if (isEnableSubstitutionInVariables()) { [EOL]                                 final StrBuilder bufName = new StrBuilder(varName); [EOL]                                 substitute(bufName, 0, bufName.length()); [EOL]                                 varName = bufName.toString(); [EOL]                             } [EOL]                             pos += endMatchLen; [EOL]                             final int endPos = pos; [EOL]                             if (priorVariables == null) { [EOL]                                 priorVariables = new ArrayList<String>(); [EOL]                                 priorVariables.add(new String(chars, offset, length)); [EOL]                             } [EOL]                             checkCyclicSubstitution(varName, priorVariables); [EOL]                             priorVariables.add(varName); [EOL]                             final String varValue = resolveVariable(varName, buf, startPos, endPos); [EOL]                             if (varValue != null) { [EOL]                                 final int varLen = varValue.length(); [EOL]                                 buf.replace(startPos, endPos, varValue); [EOL]                                 altered = true; [EOL]                                 int change = substitute(buf, startPos, varLen, priorVariables); [EOL]                                 change = change + varLen - (endPos - startPos); [EOL]                                 pos += change; [EOL]                                 bufEnd += change; [EOL]                                 lengthChange += change; [EOL]                                 chars = buf.buffer; [EOL]                             } [EOL]                             priorVariables.remove(priorVariables.size() - 1); [EOL]                             break; [EOL]                         } else { [EOL]                             nestedVarCount--; [EOL]                             pos += endMatchLen; [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (top) { [EOL]         return altered ? 1 : 0; [EOL]     } [EOL]     return lengthChange; [EOL] } 
 [LINE] pos += endMatchLen; [LINE] private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables) { [EOL]     final StrMatcher prefixMatcher = getVariablePrefixMatcher(); [EOL]     final StrMatcher suffixMatcher = getVariableSuffixMatcher(); [EOL]     final char escape = getEscapeChar(); [EOL]     final boolean top = priorVariables == null; [EOL]     boolean altered = false; [EOL]     int lengthChange = 0; [EOL]     char[] chars = buf.buffer; [EOL]     int bufEnd = offset + length; [EOL]     int pos = offset; [EOL]     while (pos < bufEnd) { [EOL]         final int startMatchLen = prefixMatcher.isMatch(chars, pos, offset, bufEnd); [EOL]         if (startMatchLen == 0) { [EOL]             pos++; [EOL]         } else { [EOL]             if (pos > offset && chars[pos - 1] == escape) { [EOL]                 buf.deleteCharAt(pos - 1); [EOL]                 chars = buf.buffer; [EOL]                 lengthChange--; [EOL]                 altered = true; [EOL]                 bufEnd--; [EOL]             } else { [EOL]                 final int startPos = pos; [EOL]                 pos += startMatchLen; [EOL]                 int endMatchLen = 0; [EOL]                 int nestedVarCount = 0; [EOL]                 while (pos < bufEnd) { [EOL]                     if (isEnableSubstitutionInVariables() && (endMatchLen = prefixMatcher.isMatch(chars, pos, offset, bufEnd)) != 0) { [EOL]                         nestedVarCount++; [EOL]                         pos += endMatchLen; [EOL]                         continue; [EOL]                     } [EOL]                     endMatchLen = suffixMatcher.isMatch(chars, pos, offset, bufEnd); [EOL]                     if (endMatchLen == 0) { [EOL]                         pos++; [EOL]                     } else { [EOL]                         if (nestedVarCount == 0) { [EOL]                             String varName = new String(chars, startPos + startMatchLen, pos - startPos - startMatchLen); [EOL]                             if (isEnableSubstitutionInVariables()) { [EOL]                                 final StrBuilder bufName = new StrBuilder(varName); [EOL]                                 substitute(bufName, 0, bufName.length()); [EOL]                                 varName = bufName.toString(); [EOL]                             } [EOL]                             pos += endMatchLen; [EOL]                             final int endPos = pos; [EOL]                             if (priorVariables == null) { [EOL]                                 priorVariables = new ArrayList<String>(); [EOL]                                 priorVariables.add(new String(chars, offset, length)); [EOL]                             } [EOL]                             checkCyclicSubstitution(varName, priorVariables); [EOL]                             priorVariables.add(varName); [EOL]                             final String varValue = resolveVariable(varName, buf, startPos, endPos); [EOL]                             if (varValue != null) { [EOL]                                 final int varLen = varValue.length(); [EOL]                                 buf.replace(startPos, endPos, varValue); [EOL]                                 altered = true; [EOL]                                 int change = substitute(buf, startPos, varLen, priorVariables); [EOL]                                 change = change + varLen - (endPos - startPos); [EOL]                                 pos += change; [EOL]                                 bufEnd += change; [EOL]                                 lengthChange += change; [EOL]                                 chars = buf.buffer; [EOL]                             } [EOL]                             priorVariables.remove(priorVariables.size() - 1); [EOL]                             break; [EOL]                         } else { [EOL]                             nestedVarCount--; [EOL]                             pos += endMatchLen; [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (top) { [EOL]         return altered ? 1 : 0; [EOL]     } [EOL]     return lengthChange; [EOL] } 
 [LINE] final StrBuilder buf = new StrBuilder(256); [LINE] private void checkCyclicSubstitution(final String varName, final List<String> priorVariables) { [EOL]     if (priorVariables.contains(varName) == false) { [EOL]         return; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(256); [EOL]     buf.append("Infinite loop in property interpolation of "); [EOL]     buf.append(priorVariables.remove(0)); [EOL]     buf.append(": "); [EOL]     buf.appendWithSeparators(priorVariables, "->"); [EOL]     throw new IllegalStateException(buf.toString()); [EOL] } 
 [LINE] buf.append("Infinite loop in property interpolation of "); [LINE] private void checkCyclicSubstitution(final String varName, final List<String> priorVariables) { [EOL]     if (priorVariables.contains(varName) == false) { [EOL]         return; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(256); [EOL]     buf.append("Infinite loop in property interpolation of "); [EOL]     buf.append(priorVariables.remove(0)); [EOL]     buf.append(": "); [EOL]     buf.appendWithSeparators(priorVariables, "->"); [EOL]     throw new IllegalStateException(buf.toString()); [EOL] } 
 [LINE] buf.append(priorVariables.remove(0)); [LINE] private void checkCyclicSubstitution(final String varName, final List<String> priorVariables) { [EOL]     if (priorVariables.contains(varName) == false) { [EOL]         return; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(256); [EOL]     buf.append("Infinite loop in property interpolation of "); [EOL]     buf.append(priorVariables.remove(0)); [EOL]     buf.append(": "); [EOL]     buf.appendWithSeparators(priorVariables, "->"); [EOL]     throw new IllegalStateException(buf.toString()); [EOL] } 
 [LINE] buf.append(": "); [LINE] private void checkCyclicSubstitution(final String varName, final List<String> priorVariables) { [EOL]     if (priorVariables.contains(varName) == false) { [EOL]         return; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(256); [EOL]     buf.append("Infinite loop in property interpolation of "); [EOL]     buf.append(priorVariables.remove(0)); [EOL]     buf.append(": "); [EOL]     buf.appendWithSeparators(priorVariables, "->"); [EOL]     throw new IllegalStateException(buf.toString()); [EOL] } 
 [LINE] buf.appendWithSeparators(priorVariables, "->"); [LINE] private void checkCyclicSubstitution(final String varName, final List<String> priorVariables) { [EOL]     if (priorVariables.contains(varName) == false) { [EOL]         return; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(256); [EOL]     buf.append("Infinite loop in property interpolation of "); [EOL]     buf.append(priorVariables.remove(0)); [EOL]     buf.append(": "); [EOL]     buf.appendWithSeparators(priorVariables, "->"); [EOL]     throw new IllegalStateException(buf.toString()); [EOL] } 
 [LINE] throw new IllegalStateException(buf.toString()); [LINE] private void checkCyclicSubstitution(final String varName, final List<String> priorVariables) { [EOL]     if (priorVariables.contains(varName) == false) { [EOL]         return; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(256); [EOL]     buf.append("Infinite loop in property interpolation of "); [EOL]     buf.append(priorVariables.remove(0)); [EOL]     buf.append(": "); [EOL]     buf.appendWithSeparators(priorVariables, "->"); [EOL]     throw new IllegalStateException(buf.toString()); [EOL] } 
 [LINE] throw new IllegalArgumentException("Variable suffix matcher must not be null!"); [LINE] public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher) { [EOL]     if (suffixMatcher == null) { [EOL]         throw new IllegalArgumentException("Variable suffix matcher must not be null!"); [EOL]     } [EOL]     this.suffixMatcher = suffixMatcher; [EOL]     return this; [EOL] } 
 [LINE] append((long[]) lhs, (long[]) rhs); [LINE] public CompareToBuilder append(final Object lhs, final Object rhs, final Comparator<?> comparator) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.getClass().isArray()) { [EOL]         if (lhs instanceof long[]) { [EOL]             append((long[]) lhs, (long[]) rhs); [EOL]         } else if (lhs instanceof int[]) { [EOL]             append((int[]) lhs, (int[]) rhs); [EOL]         } else if (lhs instanceof short[]) { [EOL]             append((short[]) lhs, (short[]) rhs); [EOL]         } else if (lhs instanceof char[]) { [EOL]             append((char[]) lhs, (char[]) rhs); [EOL]         } else if (lhs instanceof byte[]) { [EOL]             append((byte[]) lhs, (byte[]) rhs); [EOL]         } else if (lhs instanceof double[]) { [EOL]             append((double[]) lhs, (double[]) rhs); [EOL]         } else if (lhs instanceof float[]) { [EOL]             append((float[]) lhs, (float[]) rhs); [EOL]         } else if (lhs instanceof boolean[]) { [EOL]             append((boolean[]) lhs, (boolean[]) rhs); [EOL]         } else { [EOL]             append((Object[]) lhs, (Object[]) rhs, comparator); [EOL]         } [EOL]     } else { [EOL]         if (comparator == null) { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparable<Object> comparable = (Comparable<Object>) lhs; [EOL]             comparison = comparable.compareTo(rhs); [EOL]         } else { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparator<Object> comparator2 = (Comparator<Object>) comparator; [EOL]             comparison = comparator2.compare(lhs, rhs); [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] append((int[]) lhs, (int[]) rhs); [LINE] public CompareToBuilder append(final Object lhs, final Object rhs, final Comparator<?> comparator) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.getClass().isArray()) { [EOL]         if (lhs instanceof long[]) { [EOL]             append((long[]) lhs, (long[]) rhs); [EOL]         } else if (lhs instanceof int[]) { [EOL]             append((int[]) lhs, (int[]) rhs); [EOL]         } else if (lhs instanceof short[]) { [EOL]             append((short[]) lhs, (short[]) rhs); [EOL]         } else if (lhs instanceof char[]) { [EOL]             append((char[]) lhs, (char[]) rhs); [EOL]         } else if (lhs instanceof byte[]) { [EOL]             append((byte[]) lhs, (byte[]) rhs); [EOL]         } else if (lhs instanceof double[]) { [EOL]             append((double[]) lhs, (double[]) rhs); [EOL]         } else if (lhs instanceof float[]) { [EOL]             append((float[]) lhs, (float[]) rhs); [EOL]         } else if (lhs instanceof boolean[]) { [EOL]             append((boolean[]) lhs, (boolean[]) rhs); [EOL]         } else { [EOL]             append((Object[]) lhs, (Object[]) rhs, comparator); [EOL]         } [EOL]     } else { [EOL]         if (comparator == null) { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparable<Object> comparable = (Comparable<Object>) lhs; [EOL]             comparison = comparable.compareTo(rhs); [EOL]         } else { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparator<Object> comparator2 = (Comparator<Object>) comparator; [EOL]             comparison = comparator2.compare(lhs, rhs); [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] append((short[]) lhs, (short[]) rhs); [LINE] public CompareToBuilder append(final Object lhs, final Object rhs, final Comparator<?> comparator) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.getClass().isArray()) { [EOL]         if (lhs instanceof long[]) { [EOL]             append((long[]) lhs, (long[]) rhs); [EOL]         } else if (lhs instanceof int[]) { [EOL]             append((int[]) lhs, (int[]) rhs); [EOL]         } else if (lhs instanceof short[]) { [EOL]             append((short[]) lhs, (short[]) rhs); [EOL]         } else if (lhs instanceof char[]) { [EOL]             append((char[]) lhs, (char[]) rhs); [EOL]         } else if (lhs instanceof byte[]) { [EOL]             append((byte[]) lhs, (byte[]) rhs); [EOL]         } else if (lhs instanceof double[]) { [EOL]             append((double[]) lhs, (double[]) rhs); [EOL]         } else if (lhs instanceof float[]) { [EOL]             append((float[]) lhs, (float[]) rhs); [EOL]         } else if (lhs instanceof boolean[]) { [EOL]             append((boolean[]) lhs, (boolean[]) rhs); [EOL]         } else { [EOL]             append((Object[]) lhs, (Object[]) rhs, comparator); [EOL]         } [EOL]     } else { [EOL]         if (comparator == null) { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparable<Object> comparable = (Comparable<Object>) lhs; [EOL]             comparison = comparable.compareTo(rhs); [EOL]         } else { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparator<Object> comparator2 = (Comparator<Object>) comparator; [EOL]             comparison = comparator2.compare(lhs, rhs); [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] } else if (lhs instanceof byte[]) { [LINE] public CompareToBuilder append(final Object lhs, final Object rhs, final Comparator<?> comparator) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.getClass().isArray()) { [EOL]         if (lhs instanceof long[]) { [EOL]             append((long[]) lhs, (long[]) rhs); [EOL]         } else if (lhs instanceof int[]) { [EOL]             append((int[]) lhs, (int[]) rhs); [EOL]         } else if (lhs instanceof short[]) { [EOL]             append((short[]) lhs, (short[]) rhs); [EOL]         } else if (lhs instanceof char[]) { [EOL]             append((char[]) lhs, (char[]) rhs); [EOL]         } else if (lhs instanceof byte[]) { [EOL]             append((byte[]) lhs, (byte[]) rhs); [EOL]         } else if (lhs instanceof double[]) { [EOL]             append((double[]) lhs, (double[]) rhs); [EOL]         } else if (lhs instanceof float[]) { [EOL]             append((float[]) lhs, (float[]) rhs); [EOL]         } else if (lhs instanceof boolean[]) { [EOL]             append((boolean[]) lhs, (boolean[]) rhs); [EOL]         } else { [EOL]             append((Object[]) lhs, (Object[]) rhs, comparator); [EOL]         } [EOL]     } else { [EOL]         if (comparator == null) { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparable<Object> comparable = (Comparable<Object>) lhs; [EOL]             comparison = comparable.compareTo(rhs); [EOL]         } else { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparator<Object> comparator2 = (Comparator<Object>) comparator; [EOL]             comparison = comparator2.compare(lhs, rhs); [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] append((byte[]) lhs, (byte[]) rhs); [LINE] public CompareToBuilder append(final Object lhs, final Object rhs, final Comparator<?> comparator) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.getClass().isArray()) { [EOL]         if (lhs instanceof long[]) { [EOL]             append((long[]) lhs, (long[]) rhs); [EOL]         } else if (lhs instanceof int[]) { [EOL]             append((int[]) lhs, (int[]) rhs); [EOL]         } else if (lhs instanceof short[]) { [EOL]             append((short[]) lhs, (short[]) rhs); [EOL]         } else if (lhs instanceof char[]) { [EOL]             append((char[]) lhs, (char[]) rhs); [EOL]         } else if (lhs instanceof byte[]) { [EOL]             append((byte[]) lhs, (byte[]) rhs); [EOL]         } else if (lhs instanceof double[]) { [EOL]             append((double[]) lhs, (double[]) rhs); [EOL]         } else if (lhs instanceof float[]) { [EOL]             append((float[]) lhs, (float[]) rhs); [EOL]         } else if (lhs instanceof boolean[]) { [EOL]             append((boolean[]) lhs, (boolean[]) rhs); [EOL]         } else { [EOL]             append((Object[]) lhs, (Object[]) rhs, comparator); [EOL]         } [EOL]     } else { [EOL]         if (comparator == null) { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparable<Object> comparable = (Comparable<Object>) lhs; [EOL]             comparison = comparable.compareTo(rhs); [EOL]         } else { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparator<Object> comparator2 = (Comparator<Object>) comparator; [EOL]             comparison = comparator2.compare(lhs, rhs); [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] } else if (lhs instanceof double[]) { [LINE] public CompareToBuilder append(final Object lhs, final Object rhs, final Comparator<?> comparator) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.getClass().isArray()) { [EOL]         if (lhs instanceof long[]) { [EOL]             append((long[]) lhs, (long[]) rhs); [EOL]         } else if (lhs instanceof int[]) { [EOL]             append((int[]) lhs, (int[]) rhs); [EOL]         } else if (lhs instanceof short[]) { [EOL]             append((short[]) lhs, (short[]) rhs); [EOL]         } else if (lhs instanceof char[]) { [EOL]             append((char[]) lhs, (char[]) rhs); [EOL]         } else if (lhs instanceof byte[]) { [EOL]             append((byte[]) lhs, (byte[]) rhs); [EOL]         } else if (lhs instanceof double[]) { [EOL]             append((double[]) lhs, (double[]) rhs); [EOL]         } else if (lhs instanceof float[]) { [EOL]             append((float[]) lhs, (float[]) rhs); [EOL]         } else if (lhs instanceof boolean[]) { [EOL]             append((boolean[]) lhs, (boolean[]) rhs); [EOL]         } else { [EOL]             append((Object[]) lhs, (Object[]) rhs, comparator); [EOL]         } [EOL]     } else { [EOL]         if (comparator == null) { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparable<Object> comparable = (Comparable<Object>) lhs; [EOL]             comparison = comparable.compareTo(rhs); [EOL]         } else { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparator<Object> comparator2 = (Comparator<Object>) comparator; [EOL]             comparison = comparator2.compare(lhs, rhs); [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] append((double[]) lhs, (double[]) rhs); [LINE] public CompareToBuilder append(final Object lhs, final Object rhs, final Comparator<?> comparator) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.getClass().isArray()) { [EOL]         if (lhs instanceof long[]) { [EOL]             append((long[]) lhs, (long[]) rhs); [EOL]         } else if (lhs instanceof int[]) { [EOL]             append((int[]) lhs, (int[]) rhs); [EOL]         } else if (lhs instanceof short[]) { [EOL]             append((short[]) lhs, (short[]) rhs); [EOL]         } else if (lhs instanceof char[]) { [EOL]             append((char[]) lhs, (char[]) rhs); [EOL]         } else if (lhs instanceof byte[]) { [EOL]             append((byte[]) lhs, (byte[]) rhs); [EOL]         } else if (lhs instanceof double[]) { [EOL]             append((double[]) lhs, (double[]) rhs); [EOL]         } else if (lhs instanceof float[]) { [EOL]             append((float[]) lhs, (float[]) rhs); [EOL]         } else if (lhs instanceof boolean[]) { [EOL]             append((boolean[]) lhs, (boolean[]) rhs); [EOL]         } else { [EOL]             append((Object[]) lhs, (Object[]) rhs, comparator); [EOL]         } [EOL]     } else { [EOL]         if (comparator == null) { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparable<Object> comparable = (Comparable<Object>) lhs; [EOL]             comparison = comparable.compareTo(rhs); [EOL]         } else { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparator<Object> comparator2 = (Comparator<Object>) comparator; [EOL]             comparison = comparator2.compare(lhs, rhs); [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] } else if (lhs instanceof float[]) { [LINE] public CompareToBuilder append(final Object lhs, final Object rhs, final Comparator<?> comparator) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.getClass().isArray()) { [EOL]         if (lhs instanceof long[]) { [EOL]             append((long[]) lhs, (long[]) rhs); [EOL]         } else if (lhs instanceof int[]) { [EOL]             append((int[]) lhs, (int[]) rhs); [EOL]         } else if (lhs instanceof short[]) { [EOL]             append((short[]) lhs, (short[]) rhs); [EOL]         } else if (lhs instanceof char[]) { [EOL]             append((char[]) lhs, (char[]) rhs); [EOL]         } else if (lhs instanceof byte[]) { [EOL]             append((byte[]) lhs, (byte[]) rhs); [EOL]         } else if (lhs instanceof double[]) { [EOL]             append((double[]) lhs, (double[]) rhs); [EOL]         } else if (lhs instanceof float[]) { [EOL]             append((float[]) lhs, (float[]) rhs); [EOL]         } else if (lhs instanceof boolean[]) { [EOL]             append((boolean[]) lhs, (boolean[]) rhs); [EOL]         } else { [EOL]             append((Object[]) lhs, (Object[]) rhs, comparator); [EOL]         } [EOL]     } else { [EOL]         if (comparator == null) { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparable<Object> comparable = (Comparable<Object>) lhs; [EOL]             comparison = comparable.compareTo(rhs); [EOL]         } else { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparator<Object> comparator2 = (Comparator<Object>) comparator; [EOL]             comparison = comparator2.compare(lhs, rhs); [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] append((float[]) lhs, (float[]) rhs); [LINE] public CompareToBuilder append(final Object lhs, final Object rhs, final Comparator<?> comparator) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.getClass().isArray()) { [EOL]         if (lhs instanceof long[]) { [EOL]             append((long[]) lhs, (long[]) rhs); [EOL]         } else if (lhs instanceof int[]) { [EOL]             append((int[]) lhs, (int[]) rhs); [EOL]         } else if (lhs instanceof short[]) { [EOL]             append((short[]) lhs, (short[]) rhs); [EOL]         } else if (lhs instanceof char[]) { [EOL]             append((char[]) lhs, (char[]) rhs); [EOL]         } else if (lhs instanceof byte[]) { [EOL]             append((byte[]) lhs, (byte[]) rhs); [EOL]         } else if (lhs instanceof double[]) { [EOL]             append((double[]) lhs, (double[]) rhs); [EOL]         } else if (lhs instanceof float[]) { [EOL]             append((float[]) lhs, (float[]) rhs); [EOL]         } else if (lhs instanceof boolean[]) { [EOL]             append((boolean[]) lhs, (boolean[]) rhs); [EOL]         } else { [EOL]             append((Object[]) lhs, (Object[]) rhs, comparator); [EOL]         } [EOL]     } else { [EOL]         if (comparator == null) { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparable<Object> comparable = (Comparable<Object>) lhs; [EOL]             comparison = comparable.compareTo(rhs); [EOL]         } else { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparator<Object> comparator2 = (Comparator<Object>) comparator; [EOL]             comparison = comparator2.compare(lhs, rhs); [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] } else if (lhs instanceof boolean[]) { [LINE] public CompareToBuilder append(final Object lhs, final Object rhs, final Comparator<?> comparator) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.getClass().isArray()) { [EOL]         if (lhs instanceof long[]) { [EOL]             append((long[]) lhs, (long[]) rhs); [EOL]         } else if (lhs instanceof int[]) { [EOL]             append((int[]) lhs, (int[]) rhs); [EOL]         } else if (lhs instanceof short[]) { [EOL]             append((short[]) lhs, (short[]) rhs); [EOL]         } else if (lhs instanceof char[]) { [EOL]             append((char[]) lhs, (char[]) rhs); [EOL]         } else if (lhs instanceof byte[]) { [EOL]             append((byte[]) lhs, (byte[]) rhs); [EOL]         } else if (lhs instanceof double[]) { [EOL]             append((double[]) lhs, (double[]) rhs); [EOL]         } else if (lhs instanceof float[]) { [EOL]             append((float[]) lhs, (float[]) rhs); [EOL]         } else if (lhs instanceof boolean[]) { [EOL]             append((boolean[]) lhs, (boolean[]) rhs); [EOL]         } else { [EOL]             append((Object[]) lhs, (Object[]) rhs, comparator); [EOL]         } [EOL]     } else { [EOL]         if (comparator == null) { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparable<Object> comparable = (Comparable<Object>) lhs; [EOL]             comparison = comparable.compareTo(rhs); [EOL]         } else { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparator<Object> comparator2 = (Comparator<Object>) comparator; [EOL]             comparison = comparator2.compare(lhs, rhs); [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] append((boolean[]) lhs, (boolean[]) rhs); [LINE] public CompareToBuilder append(final Object lhs, final Object rhs, final Comparator<?> comparator) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.getClass().isArray()) { [EOL]         if (lhs instanceof long[]) { [EOL]             append((long[]) lhs, (long[]) rhs); [EOL]         } else if (lhs instanceof int[]) { [EOL]             append((int[]) lhs, (int[]) rhs); [EOL]         } else if (lhs instanceof short[]) { [EOL]             append((short[]) lhs, (short[]) rhs); [EOL]         } else if (lhs instanceof char[]) { [EOL]             append((char[]) lhs, (char[]) rhs); [EOL]         } else if (lhs instanceof byte[]) { [EOL]             append((byte[]) lhs, (byte[]) rhs); [EOL]         } else if (lhs instanceof double[]) { [EOL]             append((double[]) lhs, (double[]) rhs); [EOL]         } else if (lhs instanceof float[]) { [EOL]             append((float[]) lhs, (float[]) rhs); [EOL]         } else if (lhs instanceof boolean[]) { [EOL]             append((boolean[]) lhs, (boolean[]) rhs); [EOL]         } else { [EOL]             append((Object[]) lhs, (Object[]) rhs, comparator); [EOL]         } [EOL]     } else { [EOL]         if (comparator == null) { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparable<Object> comparable = (Comparable<Object>) lhs; [EOL]             comparison = comparable.compareTo(rhs); [EOL]         } else { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparator<Object> comparator2 = (Comparator<Object>) comparator; [EOL]             comparison = comparator2.compare(lhs, rhs); [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] append((Object[]) lhs, (Object[]) rhs, comparator); [LINE] public CompareToBuilder append(final Object lhs, final Object rhs, final Comparator<?> comparator) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.getClass().isArray()) { [EOL]         if (lhs instanceof long[]) { [EOL]             append((long[]) lhs, (long[]) rhs); [EOL]         } else if (lhs instanceof int[]) { [EOL]             append((int[]) lhs, (int[]) rhs); [EOL]         } else if (lhs instanceof short[]) { [EOL]             append((short[]) lhs, (short[]) rhs); [EOL]         } else if (lhs instanceof char[]) { [EOL]             append((char[]) lhs, (char[]) rhs); [EOL]         } else if (lhs instanceof byte[]) { [EOL]             append((byte[]) lhs, (byte[]) rhs); [EOL]         } else if (lhs instanceof double[]) { [EOL]             append((double[]) lhs, (double[]) rhs); [EOL]         } else if (lhs instanceof float[]) { [EOL]             append((float[]) lhs, (float[]) rhs); [EOL]         } else if (lhs instanceof boolean[]) { [EOL]             append((boolean[]) lhs, (boolean[]) rhs); [EOL]         } else { [EOL]             append((Object[]) lhs, (Object[]) rhs, comparator); [EOL]         } [EOL]     } else { [EOL]         if (comparator == null) { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparable<Object> comparable = (Comparable<Object>) lhs; [EOL]             comparison = comparable.compareTo(rhs); [EOL]         } else { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparator<Object> comparator2 = (Comparator<Object>) comparator; [EOL]             comparison = comparator2.compare(lhs, rhs); [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] comparison = -1; [LINE] public CompareToBuilder append(final Object[] lhs, final Object[] rhs, final Comparator<?> comparator) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i], comparator); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] return this; [LINE] public CompareToBuilder append(final Object[] lhs, final Object[] rhs, final Comparator<?> comparator) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i], comparator); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] comparison = -1; [LINE] public CompareToBuilder append(final long[] lhs, final long[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] return this; [LINE] public CompareToBuilder append(final long[] lhs, final long[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] comparison = +1; [LINE] public CompareToBuilder append(final long[] lhs, final long[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] return this; [LINE] public CompareToBuilder append(final long[] lhs, final long[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] comparison = -1; [LINE] public CompareToBuilder append(final int[] lhs, final int[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] return this; [LINE] public CompareToBuilder append(final int[] lhs, final int[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] for (int i = 0; i < lhs.length && comparison == 0; i++) { [LINE] public CompareToBuilder append(final int[] lhs, final int[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] append(lhs[i], rhs[i]); [LINE] public CompareToBuilder append(final int[] lhs, final int[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] return this; [LINE] public CompareToBuilder append(final int[] lhs, final int[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] comparison = +1; [LINE] public CompareToBuilder append(final short[] lhs, final short[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] return this; [LINE] public CompareToBuilder append(final short[] lhs, final short[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] comparison = -1; [LINE] public CompareToBuilder append(final char[] lhs, final char[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] return this; [LINE] public CompareToBuilder append(final char[] lhs, final char[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] comparison = +1; [LINE] public CompareToBuilder append(final char[] lhs, final char[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] return this; [LINE] public CompareToBuilder append(final char[] lhs, final char[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] comparison = -1; [LINE] public CompareToBuilder append(final byte[] lhs, final byte[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] return this; [LINE] public CompareToBuilder append(final byte[] lhs, final byte[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] comparison = +1; [LINE] public CompareToBuilder append(final byte[] lhs, final byte[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] return this; [LINE] public CompareToBuilder append(final byte[] lhs, final byte[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] for (int i = 0; i < lhs.length && comparison == 0; i++) { [LINE] public CompareToBuilder append(final double[] lhs, final double[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] append(lhs[i], rhs[i]); [LINE] public CompareToBuilder append(final double[] lhs, final double[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] return this; [LINE] public CompareToBuilder append(final double[] lhs, final double[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] comparison = +1; [LINE] public CompareToBuilder append(final float[] lhs, final float[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] return this; [LINE] public CompareToBuilder append(final float[] lhs, final float[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] for (int i = 0; i < lhs.length && comparison == 0; i++) { [LINE] public CompareToBuilder append(final float[] lhs, final float[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] append(lhs[i], rhs[i]); [LINE] public CompareToBuilder append(final float[] lhs, final float[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] return this; [LINE] public CompareToBuilder append(final float[] lhs, final float[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] comparison = +1; [LINE] public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] return this; [LINE] public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] for (int i = 0; i < lhs.length && comparison == 0; i++) { [LINE] public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] append(lhs[i], rhs[i]); [LINE] public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] return this; [LINE] public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] excepts.put(e.getKey(), cex); [LINE] @Override [EOL] protected MultiBackgroundInitializerResults initialize() throws Exception { [EOL]     Map<String, BackgroundInitializer<?>> inits; [EOL]     synchronized (this) { [EOL]         inits = new HashMap<String, BackgroundInitializer<?>>(childInitializers); [EOL]     } [EOL]     final ExecutorService exec = getActiveExecutor(); [EOL]     for (final BackgroundInitializer<?> bi : inits.values()) { [EOL]         if (bi.getExternalExecutor() == null) { [EOL]             bi.setExternalExecutor(exec); [EOL]         } [EOL]         bi.start(); [EOL]     } [EOL]     final Map<String, Object> results = new HashMap<String, Object>(); [EOL]     final Map<String, ConcurrentException> excepts = new HashMap<String, ConcurrentException>(); [EOL]     for (final Map.Entry<String, BackgroundInitializer<?>> e : inits.entrySet()) { [EOL]         try { [EOL]             results.put(e.getKey(), e.getValue().get()); [EOL]         } catch (final ConcurrentException cex) { [EOL]             excepts.put(e.getKey(), cex); [EOL]         } [EOL]     } [EOL]     return new MultiBackgroundInitializerResults(inits, results, excepts); [EOL] } 
 [LINE] return resultObjects.get(name); [LINE] public Object getResultObject(final String name) { [EOL]     checkName(name); [EOL]     return resultObjects.get(name); [EOL] } 
 [LINE] return exceptions.containsKey(name); [LINE] public boolean isException(final String name) { [EOL]     checkName(name); [EOL]     return exceptions.containsKey(name); [EOL] } 
 [LINE] return exceptions.get(name); [LINE] public ConcurrentException getException(final String name) { [EOL]     checkName(name); [EOL]     return exceptions.get(name); [EOL] } 
 [LINE] public static UnicodeEscaper below(final int codepoint) { [LINE] public static UnicodeEscaper below(final int codepoint) { [EOL]     return outsideOf(codepoint, Integer.MAX_VALUE); [EOL] } 
 [LINE] return outsideOf(codepoint, Integer.MAX_VALUE); [LINE] public static UnicodeEscaper below(final int codepoint) { [EOL]     return outsideOf(codepoint, Integer.MAX_VALUE); [EOL] } 
 [LINE] public static UnicodeEscaper above(final int codepoint) { [LINE] public static UnicodeEscaper above(final int codepoint) { [EOL]     return outsideOf(0, codepoint); [EOL] } 
 [LINE] return outsideOf(0, codepoint); [LINE] public static UnicodeEscaper above(final int codepoint) { [EOL]     return outsideOf(0, codepoint); [EOL] } 
 [LINE] public static UnicodeEscaper outsideOf(final int codepointLow, final int codepointHigh) { [LINE] public static UnicodeEscaper outsideOf(final int codepointLow, final int codepointHigh) { [EOL]     return new UnicodeEscaper(codepointLow, codepointHigh, false); [EOL] } 
 [LINE] return new UnicodeEscaper(codepointLow, codepointHigh, false); [LINE] public static UnicodeEscaper outsideOf(final int codepointLow, final int codepointHigh) { [EOL]     return new UnicodeEscaper(codepointLow, codepointHigh, false); [EOL] } 
 [LINE] public static UnicodeEscaper between(final int codepointLow, final int codepointHigh) { [LINE] public static UnicodeEscaper between(final int codepointLow, final int codepointHigh) { [EOL]     return new UnicodeEscaper(codepointLow, codepointHigh, true); [EOL] } 
 [LINE] return new UnicodeEscaper(codepointLow, codepointHigh, true); [LINE] public static UnicodeEscaper between(final int codepointLow, final int codepointHigh) { [EOL]     return new UnicodeEscaper(codepointLow, codepointHigh, true); [EOL] } 
 [LINE] if (codepoint < below || codepoint > above) { [LINE] @Override [EOL] public boolean translate(final int codepoint, final Writer out) throws IOException { [EOL]     if (between) { [EOL]         if (codepoint < below || codepoint > above) { [EOL]             return false; [EOL]         } [EOL]     } else { [EOL]         if (codepoint >= below && codepoint <= above) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     if (codepoint > 0xffff) { [EOL]         out.write(toUtf16Escape(codepoint)); [EOL]     } else if (codepoint > 0xfff) { [EOL]         out.write("\\u" + hex(codepoint)); [EOL]     } else if (codepoint > 0xff) { [EOL]         out.write("\\u0" + hex(codepoint)); [EOL]     } else if (codepoint > 0xf) { [EOL]         out.write("\\u00" + hex(codepoint)); [EOL]     } else { [EOL]         out.write("\\u000" + hex(codepoint)); [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] return false; [LINE] @Override [EOL] public boolean translate(final int codepoint, final Writer out) throws IOException { [EOL]     if (between) { [EOL]         if (codepoint < below || codepoint > above) { [EOL]             return false; [EOL]         } [EOL]     } else { [EOL]         if (codepoint >= below && codepoint <= above) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     if (codepoint > 0xffff) { [EOL]         out.write(toUtf16Escape(codepoint)); [EOL]     } else if (codepoint > 0xfff) { [EOL]         out.write("\\u" + hex(codepoint)); [EOL]     } else if (codepoint > 0xff) { [EOL]         out.write("\\u0" + hex(codepoint)); [EOL]     } else if (codepoint > 0xf) { [EOL]         out.write("\\u00" + hex(codepoint)); [EOL]     } else { [EOL]         out.write("\\u000" + hex(codepoint)); [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] if (codepoint > 0xffff) { [LINE] @Override [EOL] public boolean translate(final int codepoint, final Writer out) throws IOException { [EOL]     if (between) { [EOL]         if (codepoint < below || codepoint > above) { [EOL]             return false; [EOL]         } [EOL]     } else { [EOL]         if (codepoint >= below && codepoint <= above) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     if (codepoint > 0xffff) { [EOL]         out.write(toUtf16Escape(codepoint)); [EOL]     } else if (codepoint > 0xfff) { [EOL]         out.write("\\u" + hex(codepoint)); [EOL]     } else if (codepoint > 0xff) { [EOL]         out.write("\\u0" + hex(codepoint)); [EOL]     } else if (codepoint > 0xf) { [EOL]         out.write("\\u00" + hex(codepoint)); [EOL]     } else { [EOL]         out.write("\\u000" + hex(codepoint)); [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] out.write(toUtf16Escape(codepoint)); [LINE] @Override [EOL] public boolean translate(final int codepoint, final Writer out) throws IOException { [EOL]     if (between) { [EOL]         if (codepoint < below || codepoint > above) { [EOL]             return false; [EOL]         } [EOL]     } else { [EOL]         if (codepoint >= below && codepoint <= above) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     if (codepoint > 0xffff) { [EOL]         out.write(toUtf16Escape(codepoint)); [EOL]     } else if (codepoint > 0xfff) { [EOL]         out.write("\\u" + hex(codepoint)); [EOL]     } else if (codepoint > 0xff) { [EOL]         out.write("\\u0" + hex(codepoint)); [EOL]     } else if (codepoint > 0xf) { [EOL]         out.write("\\u00" + hex(codepoint)); [EOL]     } else { [EOL]         out.write("\\u000" + hex(codepoint)); [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] } else if (codepoint > 0xfff) { [LINE] @Override [EOL] public boolean translate(final int codepoint, final Writer out) throws IOException { [EOL]     if (between) { [EOL]         if (codepoint < below || codepoint > above) { [EOL]             return false; [EOL]         } [EOL]     } else { [EOL]         if (codepoint >= below && codepoint <= above) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     if (codepoint > 0xffff) { [EOL]         out.write(toUtf16Escape(codepoint)); [EOL]     } else if (codepoint > 0xfff) { [EOL]         out.write("\\u" + hex(codepoint)); [EOL]     } else if (codepoint > 0xff) { [EOL]         out.write("\\u0" + hex(codepoint)); [EOL]     } else if (codepoint > 0xf) { [EOL]         out.write("\\u00" + hex(codepoint)); [EOL]     } else { [EOL]         out.write("\\u000" + hex(codepoint)); [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] out.write("\\u" + hex(codepoint)); [LINE] @Override [EOL] public boolean translate(final int codepoint, final Writer out) throws IOException { [EOL]     if (between) { [EOL]         if (codepoint < below || codepoint > above) { [EOL]             return false; [EOL]         } [EOL]     } else { [EOL]         if (codepoint >= below && codepoint <= above) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     if (codepoint > 0xffff) { [EOL]         out.write(toUtf16Escape(codepoint)); [EOL]     } else if (codepoint > 0xfff) { [EOL]         out.write("\\u" + hex(codepoint)); [EOL]     } else if (codepoint > 0xff) { [EOL]         out.write("\\u0" + hex(codepoint)); [EOL]     } else if (codepoint > 0xf) { [EOL]         out.write("\\u00" + hex(codepoint)); [EOL]     } else { [EOL]         out.write("\\u000" + hex(codepoint)); [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] } else if (codepoint > 0xff) { [LINE] @Override [EOL] public boolean translate(final int codepoint, final Writer out) throws IOException { [EOL]     if (between) { [EOL]         if (codepoint < below || codepoint > above) { [EOL]             return false; [EOL]         } [EOL]     } else { [EOL]         if (codepoint >= below && codepoint <= above) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     if (codepoint > 0xffff) { [EOL]         out.write(toUtf16Escape(codepoint)); [EOL]     } else if (codepoint > 0xfff) { [EOL]         out.write("\\u" + hex(codepoint)); [EOL]     } else if (codepoint > 0xff) { [EOL]         out.write("\\u0" + hex(codepoint)); [EOL]     } else if (codepoint > 0xf) { [EOL]         out.write("\\u00" + hex(codepoint)); [EOL]     } else { [EOL]         out.write("\\u000" + hex(codepoint)); [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] out.write("\\u0" + hex(codepoint)); [LINE] @Override [EOL] public boolean translate(final int codepoint, final Writer out) throws IOException { [EOL]     if (between) { [EOL]         if (codepoint < below || codepoint > above) { [EOL]             return false; [EOL]         } [EOL]     } else { [EOL]         if (codepoint >= below && codepoint <= above) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     if (codepoint > 0xffff) { [EOL]         out.write(toUtf16Escape(codepoint)); [EOL]     } else if (codepoint > 0xfff) { [EOL]         out.write("\\u" + hex(codepoint)); [EOL]     } else if (codepoint > 0xff) { [EOL]         out.write("\\u0" + hex(codepoint)); [EOL]     } else if (codepoint > 0xf) { [EOL]         out.write("\\u00" + hex(codepoint)); [EOL]     } else { [EOL]         out.write("\\u000" + hex(codepoint)); [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] } else if (codepoint > 0xf) { [LINE] @Override [EOL] public boolean translate(final int codepoint, final Writer out) throws IOException { [EOL]     if (between) { [EOL]         if (codepoint < below || codepoint > above) { [EOL]             return false; [EOL]         } [EOL]     } else { [EOL]         if (codepoint >= below && codepoint <= above) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     if (codepoint > 0xffff) { [EOL]         out.write(toUtf16Escape(codepoint)); [EOL]     } else if (codepoint > 0xfff) { [EOL]         out.write("\\u" + hex(codepoint)); [EOL]     } else if (codepoint > 0xff) { [EOL]         out.write("\\u0" + hex(codepoint)); [EOL]     } else if (codepoint > 0xf) { [EOL]         out.write("\\u00" + hex(codepoint)); [EOL]     } else { [EOL]         out.write("\\u000" + hex(codepoint)); [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] out.write("\\u00" + hex(codepoint)); [LINE] @Override [EOL] public boolean translate(final int codepoint, final Writer out) throws IOException { [EOL]     if (between) { [EOL]         if (codepoint < below || codepoint > above) { [EOL]             return false; [EOL]         } [EOL]     } else { [EOL]         if (codepoint >= below && codepoint <= above) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     if (codepoint > 0xffff) { [EOL]         out.write(toUtf16Escape(codepoint)); [EOL]     } else if (codepoint > 0xfff) { [EOL]         out.write("\\u" + hex(codepoint)); [EOL]     } else if (codepoint > 0xff) { [EOL]         out.write("\\u0" + hex(codepoint)); [EOL]     } else if (codepoint > 0xf) { [EOL]         out.write("\\u00" + hex(codepoint)); [EOL]     } else { [EOL]         out.write("\\u000" + hex(codepoint)); [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] out.write("\\u000" + hex(codepoint)); [LINE] @Override [EOL] public boolean translate(final int codepoint, final Writer out) throws IOException { [EOL]     if (between) { [EOL]         if (codepoint < below || codepoint > above) { [EOL]             return false; [EOL]         } [EOL]     } else { [EOL]         if (codepoint >= below && codepoint <= above) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     if (codepoint > 0xffff) { [EOL]         out.write(toUtf16Escape(codepoint)); [EOL]     } else if (codepoint > 0xfff) { [EOL]         out.write("\\u" + hex(codepoint)); [EOL]     } else if (codepoint > 0xff) { [EOL]         out.write("\\u0" + hex(codepoint)); [EOL]     } else if (codepoint > 0xf) { [EOL]         out.write("\\u00" + hex(codepoint)); [EOL]     } else { [EOL]         out.write("\\u000" + hex(codepoint)); [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] return true; [LINE] @Override [EOL] public boolean translate(final int codepoint, final Writer out) throws IOException { [EOL]     if (between) { [EOL]         if (codepoint < below || codepoint > above) { [EOL]             return false; [EOL]         } [EOL]     } else { [EOL]         if (codepoint >= below && codepoint <= above) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     if (codepoint > 0xffff) { [EOL]         out.write(toUtf16Escape(codepoint)); [EOL]     } else if (codepoint > 0xfff) { [EOL]         out.write("\\u" + hex(codepoint)); [EOL]     } else if (codepoint > 0xff) { [EOL]         out.write("\\u0" + hex(codepoint)); [EOL]     } else if (codepoint > 0xf) { [EOL]         out.write("\\u00" + hex(codepoint)); [EOL]     } else { [EOL]         out.write("\\u000" + hex(codepoint)); [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] return b; [LINE] public static double min(final double a, final double b) { [EOL]     if (Double.isNaN(a)) { [EOL]         return b; [EOL]     } else if (Double.isNaN(b)) { [EOL]         return a; [EOL]     } else { [EOL]         return Math.min(a, b); [EOL]     } [EOL] } 
 [LINE] return a; [LINE] public static double min(final double a, final double b) { [EOL]     if (Double.isNaN(a)) { [EOL]         return b; [EOL]     } else if (Double.isNaN(b)) { [EOL]         return a; [EOL]     } else { [EOL]         return Math.min(a, b); [EOL]     } [EOL] } 
 [LINE] return b; [LINE] public static float min(final float a, final float b) { [EOL]     if (Float.isNaN(a)) { [EOL]         return b; [EOL]     } else if (Float.isNaN(b)) { [EOL]         return a; [EOL]     } else { [EOL]         return Math.min(a, b); [EOL]     } [EOL] } 
 [LINE] return a; [LINE] public static float min(final float a, final float b) { [EOL]     if (Float.isNaN(a)) { [EOL]         return b; [EOL]     } else if (Float.isNaN(b)) { [EOL]         return a; [EOL]     } else { [EOL]         return Math.min(a, b); [EOL]     } [EOL] } 
 [LINE] return b; [LINE] public static double max(final double a, final double b) { [EOL]     if (Double.isNaN(a)) { [EOL]         return b; [EOL]     } else if (Double.isNaN(b)) { [EOL]         return a; [EOL]     } else { [EOL]         return Math.max(a, b); [EOL]     } [EOL] } 
 [LINE] return a; [LINE] public static double max(final double a, final double b) { [EOL]     if (Double.isNaN(a)) { [EOL]         return b; [EOL]     } else if (Double.isNaN(b)) { [EOL]         return a; [EOL]     } else { [EOL]         return Math.max(a, b); [EOL]     } [EOL] } 
 [LINE] return b; [LINE] public static float max(final float a, final float b) { [EOL]     if (Float.isNaN(a)) { [EOL]         return b; [EOL]     } else if (Float.isNaN(b)) { [EOL]         return a; [EOL]     } else { [EOL]         return Math.max(a, b); [EOL]     } [EOL] } 
 [LINE] return a; [LINE] public static float max(final float a, final float b) { [EOL]     if (Float.isNaN(a)) { [EOL]         return b; [EOL]     } else if (Float.isNaN(b)) { [EOL]         return a; [EOL]     } else { [EOL]         return Math.max(a, b); [EOL]     } [EOL] } 
 [LINE] stripCustom.append(START_FE).append(index); [LINE] @Override [EOL] public final void applyPattern(final String pattern) { [EOL]     if (registry == null) { [EOL]         super.applyPattern(pattern); [EOL]         toPattern = super.toPattern(); [EOL]         return; [EOL]     } [EOL]     final ArrayList<Format> foundFormats = new ArrayList<Format>(); [EOL]     final ArrayList<String> foundDescriptions = new ArrayList<String>(); [EOL]     final StringBuilder stripCustom = new StringBuilder(pattern.length()); [EOL]     final ParsePosition pos = new ParsePosition(0); [EOL]     final char[] c = pattern.toCharArray(); [EOL]     int fmtCount = 0; [EOL]     while (pos.getIndex() < pattern.length()) { [EOL]         switch(c[pos.getIndex()]) { [EOL]             case QUOTE: [EOL]                 appendQuotedString(pattern, pos, stripCustom, true); [EOL]                 break; [EOL]             case START_FE: [EOL]                 fmtCount++; [EOL]                 seekNonWs(pattern, pos); [EOL]                 final int start = pos.getIndex(); [EOL]                 final int index = readArgumentIndex(pattern, next(pos)); [EOL]                 stripCustom.append(START_FE).append(index); [EOL]                 seekNonWs(pattern, pos); [EOL]                 Format format = null; [EOL]                 String formatDescription = null; [EOL]                 if (c[pos.getIndex()] == START_FMT) { [EOL]                     formatDescription = parseFormatDescription(pattern, next(pos)); [EOL]                     format = getFormat(formatDescription); [EOL]                     if (format == null) { [EOL]                         stripCustom.append(START_FMT).append(formatDescription); [EOL]                     } [EOL]                 } [EOL]                 foundFormats.add(format); [EOL]                 foundDescriptions.add(format == null ? null : formatDescription); [EOL]                 Validate.isTrue(foundFormats.size() == fmtCount); [EOL]                 Validate.isTrue(foundDescriptions.size() == fmtCount); [EOL]                 if (c[pos.getIndex()] != END_FE) { [EOL]                     throw new IllegalArgumentException("Unreadable format element at position " + start); [EOL]                 } [EOL]             default: [EOL]                 stripCustom.append(c[pos.getIndex()]); [EOL]                 next(pos); [EOL]         } [EOL]     } [EOL]     super.applyPattern(stripCustom.toString()); [EOL]     toPattern = insertFormats(super.toPattern(), foundDescriptions); [EOL]     if (containsElements(foundFormats)) { [EOL]         final Format[] origFormats = getFormats(); [EOL]         int i = 0; [EOL]         for (final Iterator<Format> it = foundFormats.iterator(); it.hasNext(); i++) { [EOL]             final Format f = it.next(); [EOL]             if (f != null) { [EOL]                 origFormats[i] = f; [EOL]             } [EOL]         } [EOL]         super.setFormats(origFormats); [EOL]     } [EOL] } 
 [LINE] seekNonWs(pattern, pos); [LINE] @Override [EOL] public final void applyPattern(final String pattern) { [EOL]     if (registry == null) { [EOL]         super.applyPattern(pattern); [EOL]         toPattern = super.toPattern(); [EOL]         return; [EOL]     } [EOL]     final ArrayList<Format> foundFormats = new ArrayList<Format>(); [EOL]     final ArrayList<String> foundDescriptions = new ArrayList<String>(); [EOL]     final StringBuilder stripCustom = new StringBuilder(pattern.length()); [EOL]     final ParsePosition pos = new ParsePosition(0); [EOL]     final char[] c = pattern.toCharArray(); [EOL]     int fmtCount = 0; [EOL]     while (pos.getIndex() < pattern.length()) { [EOL]         switch(c[pos.getIndex()]) { [EOL]             case QUOTE: [EOL]                 appendQuotedString(pattern, pos, stripCustom, true); [EOL]                 break; [EOL]             case START_FE: [EOL]                 fmtCount++; [EOL]                 seekNonWs(pattern, pos); [EOL]                 final int start = pos.getIndex(); [EOL]                 final int index = readArgumentIndex(pattern, next(pos)); [EOL]                 stripCustom.append(START_FE).append(index); [EOL]                 seekNonWs(pattern, pos); [EOL]                 Format format = null; [EOL]                 String formatDescription = null; [EOL]                 if (c[pos.getIndex()] == START_FMT) { [EOL]                     formatDescription = parseFormatDescription(pattern, next(pos)); [EOL]                     format = getFormat(formatDescription); [EOL]                     if (format == null) { [EOL]                         stripCustom.append(START_FMT).append(formatDescription); [EOL]                     } [EOL]                 } [EOL]                 foundFormats.add(format); [EOL]                 foundDescriptions.add(format == null ? null : formatDescription); [EOL]                 Validate.isTrue(foundFormats.size() == fmtCount); [EOL]                 Validate.isTrue(foundDescriptions.size() == fmtCount); [EOL]                 if (c[pos.getIndex()] != END_FE) { [EOL]                     throw new IllegalArgumentException("Unreadable format element at position " + start); [EOL]                 } [EOL]             default: [EOL]                 stripCustom.append(c[pos.getIndex()]); [EOL]                 next(pos); [EOL]         } [EOL]     } [EOL]     super.applyPattern(stripCustom.toString()); [EOL]     toPattern = insertFormats(super.toPattern(), foundDescriptions); [EOL]     if (containsElements(foundFormats)) { [EOL]         final Format[] origFormats = getFormats(); [EOL]         int i = 0; [EOL]         for (final Iterator<Format> it = foundFormats.iterator(); it.hasNext(); i++) { [EOL]             final Format f = it.next(); [EOL]             if (f != null) { [EOL]                 origFormats[i] = f; [EOL]             } [EOL]         } [EOL]         super.setFormats(origFormats); [EOL]     } [EOL] } 
 [LINE] Format format = null; [LINE] @Override [EOL] public final void applyPattern(final String pattern) { [EOL]     if (registry == null) { [EOL]         super.applyPattern(pattern); [EOL]         toPattern = super.toPattern(); [EOL]         return; [EOL]     } [EOL]     final ArrayList<Format> foundFormats = new ArrayList<Format>(); [EOL]     final ArrayList<String> foundDescriptions = new ArrayList<String>(); [EOL]     final StringBuilder stripCustom = new StringBuilder(pattern.length()); [EOL]     final ParsePosition pos = new ParsePosition(0); [EOL]     final char[] c = pattern.toCharArray(); [EOL]     int fmtCount = 0; [EOL]     while (pos.getIndex() < pattern.length()) { [EOL]         switch(c[pos.getIndex()]) { [EOL]             case QUOTE: [EOL]                 appendQuotedString(pattern, pos, stripCustom, true); [EOL]                 break; [EOL]             case START_FE: [EOL]                 fmtCount++; [EOL]                 seekNonWs(pattern, pos); [EOL]                 final int start = pos.getIndex(); [EOL]                 final int index = readArgumentIndex(pattern, next(pos)); [EOL]                 stripCustom.append(START_FE).append(index); [EOL]                 seekNonWs(pattern, pos); [EOL]                 Format format = null; [EOL]                 String formatDescription = null; [EOL]                 if (c[pos.getIndex()] == START_FMT) { [EOL]                     formatDescription = parseFormatDescription(pattern, next(pos)); [EOL]                     format = getFormat(formatDescription); [EOL]                     if (format == null) { [EOL]                         stripCustom.append(START_FMT).append(formatDescription); [EOL]                     } [EOL]                 } [EOL]                 foundFormats.add(format); [EOL]                 foundDescriptions.add(format == null ? null : formatDescription); [EOL]                 Validate.isTrue(foundFormats.size() == fmtCount); [EOL]                 Validate.isTrue(foundDescriptions.size() == fmtCount); [EOL]                 if (c[pos.getIndex()] != END_FE) { [EOL]                     throw new IllegalArgumentException("Unreadable format element at position " + start); [EOL]                 } [EOL]             default: [EOL]                 stripCustom.append(c[pos.getIndex()]); [EOL]                 next(pos); [EOL]         } [EOL]     } [EOL]     super.applyPattern(stripCustom.toString()); [EOL]     toPattern = insertFormats(super.toPattern(), foundDescriptions); [EOL]     if (containsElements(foundFormats)) { [EOL]         final Format[] origFormats = getFormats(); [EOL]         int i = 0; [EOL]         for (final Iterator<Format> it = foundFormats.iterator(); it.hasNext(); i++) { [EOL]             final Format f = it.next(); [EOL]             if (f != null) { [EOL]                 origFormats[i] = f; [EOL]             } [EOL]         } [EOL]         super.setFormats(origFormats); [EOL]     } [EOL] } 
 [LINE] String formatDescription = null; [LINE] @Override [EOL] public final void applyPattern(final String pattern) { [EOL]     if (registry == null) { [EOL]         super.applyPattern(pattern); [EOL]         toPattern = super.toPattern(); [EOL]         return; [EOL]     } [EOL]     final ArrayList<Format> foundFormats = new ArrayList<Format>(); [EOL]     final ArrayList<String> foundDescriptions = new ArrayList<String>(); [EOL]     final StringBuilder stripCustom = new StringBuilder(pattern.length()); [EOL]     final ParsePosition pos = new ParsePosition(0); [EOL]     final char[] c = pattern.toCharArray(); [EOL]     int fmtCount = 0; [EOL]     while (pos.getIndex() < pattern.length()) { [EOL]         switch(c[pos.getIndex()]) { [EOL]             case QUOTE: [EOL]                 appendQuotedString(pattern, pos, stripCustom, true); [EOL]                 break; [EOL]             case START_FE: [EOL]                 fmtCount++; [EOL]                 seekNonWs(pattern, pos); [EOL]                 final int start = pos.getIndex(); [EOL]                 final int index = readArgumentIndex(pattern, next(pos)); [EOL]                 stripCustom.append(START_FE).append(index); [EOL]                 seekNonWs(pattern, pos); [EOL]                 Format format = null; [EOL]                 String formatDescription = null; [EOL]                 if (c[pos.getIndex()] == START_FMT) { [EOL]                     formatDescription = parseFormatDescription(pattern, next(pos)); [EOL]                     format = getFormat(formatDescription); [EOL]                     if (format == null) { [EOL]                         stripCustom.append(START_FMT).append(formatDescription); [EOL]                     } [EOL]                 } [EOL]                 foundFormats.add(format); [EOL]                 foundDescriptions.add(format == null ? null : formatDescription); [EOL]                 Validate.isTrue(foundFormats.size() == fmtCount); [EOL]                 Validate.isTrue(foundDescriptions.size() == fmtCount); [EOL]                 if (c[pos.getIndex()] != END_FE) { [EOL]                     throw new IllegalArgumentException("Unreadable format element at position " + start); [EOL]                 } [EOL]             default: [EOL]                 stripCustom.append(c[pos.getIndex()]); [EOL]                 next(pos); [EOL]         } [EOL]     } [EOL]     super.applyPattern(stripCustom.toString()); [EOL]     toPattern = insertFormats(super.toPattern(), foundDescriptions); [EOL]     if (containsElements(foundFormats)) { [EOL]         final Format[] origFormats = getFormats(); [EOL]         int i = 0; [EOL]         for (final Iterator<Format> it = foundFormats.iterator(); it.hasNext(); i++) { [EOL]             final Format f = it.next(); [EOL]             if (f != null) { [EOL]                 origFormats[i] = f; [EOL]             } [EOL]         } [EOL]         super.setFormats(origFormats); [EOL]     } [EOL] } 
 [LINE] if (c[pos.getIndex()] == START_FMT) { [LINE] @Override [EOL] public final void applyPattern(final String pattern) { [EOL]     if (registry == null) { [EOL]         super.applyPattern(pattern); [EOL]         toPattern = super.toPattern(); [EOL]         return; [EOL]     } [EOL]     final ArrayList<Format> foundFormats = new ArrayList<Format>(); [EOL]     final ArrayList<String> foundDescriptions = new ArrayList<String>(); [EOL]     final StringBuilder stripCustom = new StringBuilder(pattern.length()); [EOL]     final ParsePosition pos = new ParsePosition(0); [EOL]     final char[] c = pattern.toCharArray(); [EOL]     int fmtCount = 0; [EOL]     while (pos.getIndex() < pattern.length()) { [EOL]         switch(c[pos.getIndex()]) { [EOL]             case QUOTE: [EOL]                 appendQuotedString(pattern, pos, stripCustom, true); [EOL]                 break; [EOL]             case START_FE: [EOL]                 fmtCount++; [EOL]                 seekNonWs(pattern, pos); [EOL]                 final int start = pos.getIndex(); [EOL]                 final int index = readArgumentIndex(pattern, next(pos)); [EOL]                 stripCustom.append(START_FE).append(index); [EOL]                 seekNonWs(pattern, pos); [EOL]                 Format format = null; [EOL]                 String formatDescription = null; [EOL]                 if (c[pos.getIndex()] == START_FMT) { [EOL]                     formatDescription = parseFormatDescription(pattern, next(pos)); [EOL]                     format = getFormat(formatDescription); [EOL]                     if (format == null) { [EOL]                         stripCustom.append(START_FMT).append(formatDescription); [EOL]                     } [EOL]                 } [EOL]                 foundFormats.add(format); [EOL]                 foundDescriptions.add(format == null ? null : formatDescription); [EOL]                 Validate.isTrue(foundFormats.size() == fmtCount); [EOL]                 Validate.isTrue(foundDescriptions.size() == fmtCount); [EOL]                 if (c[pos.getIndex()] != END_FE) { [EOL]                     throw new IllegalArgumentException("Unreadable format element at position " + start); [EOL]                 } [EOL]             default: [EOL]                 stripCustom.append(c[pos.getIndex()]); [EOL]                 next(pos); [EOL]         } [EOL]     } [EOL]     super.applyPattern(stripCustom.toString()); [EOL]     toPattern = insertFormats(super.toPattern(), foundDescriptions); [EOL]     if (containsElements(foundFormats)) { [EOL]         final Format[] origFormats = getFormats(); [EOL]         int i = 0; [EOL]         for (final Iterator<Format> it = foundFormats.iterator(); it.hasNext(); i++) { [EOL]             final Format f = it.next(); [EOL]             if (f != null) { [EOL]                 origFormats[i] = f; [EOL]             } [EOL]         } [EOL]         super.setFormats(origFormats); [EOL]     } [EOL] } 
 [LINE] formatDescription = parseFormatDescription(pattern, [LINE] @Override [EOL] public final void applyPattern(final String pattern) { [EOL]     if (registry == null) { [EOL]         super.applyPattern(pattern); [EOL]         toPattern = super.toPattern(); [EOL]         return; [EOL]     } [EOL]     final ArrayList<Format> foundFormats = new ArrayList<Format>(); [EOL]     final ArrayList<String> foundDescriptions = new ArrayList<String>(); [EOL]     final StringBuilder stripCustom = new StringBuilder(pattern.length()); [EOL]     final ParsePosition pos = new ParsePosition(0); [EOL]     final char[] c = pattern.toCharArray(); [EOL]     int fmtCount = 0; [EOL]     while (pos.getIndex() < pattern.length()) { [EOL]         switch(c[pos.getIndex()]) { [EOL]             case QUOTE: [EOL]                 appendQuotedString(pattern, pos, stripCustom, true); [EOL]                 break; [EOL]             case START_FE: [EOL]                 fmtCount++; [EOL]                 seekNonWs(pattern, pos); [EOL]                 final int start = pos.getIndex(); [EOL]                 final int index = readArgumentIndex(pattern, next(pos)); [EOL]                 stripCustom.append(START_FE).append(index); [EOL]                 seekNonWs(pattern, pos); [EOL]                 Format format = null; [EOL]                 String formatDescription = null; [EOL]                 if (c[pos.getIndex()] == START_FMT) { [EOL]                     formatDescription = parseFormatDescription(pattern, next(pos)); [EOL]                     format = getFormat(formatDescription); [EOL]                     if (format == null) { [EOL]                         stripCustom.append(START_FMT).append(formatDescription); [EOL]                     } [EOL]                 } [EOL]                 foundFormats.add(format); [EOL]                 foundDescriptions.add(format == null ? null : formatDescription); [EOL]                 Validate.isTrue(foundFormats.size() == fmtCount); [EOL]                 Validate.isTrue(foundDescriptions.size() == fmtCount); [EOL]                 if (c[pos.getIndex()] != END_FE) { [EOL]                     throw new IllegalArgumentException("Unreadable format element at position " + start); [EOL]                 } [EOL]             default: [EOL]                 stripCustom.append(c[pos.getIndex()]); [EOL]                 next(pos); [EOL]         } [EOL]     } [EOL]     super.applyPattern(stripCustom.toString()); [EOL]     toPattern = insertFormats(super.toPattern(), foundDescriptions); [EOL]     if (containsElements(foundFormats)) { [EOL]         final Format[] origFormats = getFormats(); [EOL]         int i = 0; [EOL]         for (final Iterator<Format> it = foundFormats.iterator(); it.hasNext(); i++) { [EOL]             final Format f = it.next(); [EOL]             if (f != null) { [EOL]                 origFormats[i] = f; [EOL]             } [EOL]         } [EOL]         super.setFormats(origFormats); [EOL]     } [EOL] } 
 [LINE] format = getFormat(formatDescription); [LINE] @Override [EOL] public final void applyPattern(final String pattern) { [EOL]     if (registry == null) { [EOL]         super.applyPattern(pattern); [EOL]         toPattern = super.toPattern(); [EOL]         return; [EOL]     } [EOL]     final ArrayList<Format> foundFormats = new ArrayList<Format>(); [EOL]     final ArrayList<String> foundDescriptions = new ArrayList<String>(); [EOL]     final StringBuilder stripCustom = new StringBuilder(pattern.length()); [EOL]     final ParsePosition pos = new ParsePosition(0); [EOL]     final char[] c = pattern.toCharArray(); [EOL]     int fmtCount = 0; [EOL]     while (pos.getIndex() < pattern.length()) { [EOL]         switch(c[pos.getIndex()]) { [EOL]             case QUOTE: [EOL]                 appendQuotedString(pattern, pos, stripCustom, true); [EOL]                 break; [EOL]             case START_FE: [EOL]                 fmtCount++; [EOL]                 seekNonWs(pattern, pos); [EOL]                 final int start = pos.getIndex(); [EOL]                 final int index = readArgumentIndex(pattern, next(pos)); [EOL]                 stripCustom.append(START_FE).append(index); [EOL]                 seekNonWs(pattern, pos); [EOL]                 Format format = null; [EOL]                 String formatDescription = null; [EOL]                 if (c[pos.getIndex()] == START_FMT) { [EOL]                     formatDescription = parseFormatDescription(pattern, next(pos)); [EOL]                     format = getFormat(formatDescription); [EOL]                     if (format == null) { [EOL]                         stripCustom.append(START_FMT).append(formatDescription); [EOL]                     } [EOL]                 } [EOL]                 foundFormats.add(format); [EOL]                 foundDescriptions.add(format == null ? null : formatDescription); [EOL]                 Validate.isTrue(foundFormats.size() == fmtCount); [EOL]                 Validate.isTrue(foundDescriptions.size() == fmtCount); [EOL]                 if (c[pos.getIndex()] != END_FE) { [EOL]                     throw new IllegalArgumentException("Unreadable format element at position " + start); [EOL]                 } [EOL]             default: [EOL]                 stripCustom.append(c[pos.getIndex()]); [EOL]                 next(pos); [EOL]         } [EOL]     } [EOL]     super.applyPattern(stripCustom.toString()); [EOL]     toPattern = insertFormats(super.toPattern(), foundDescriptions); [EOL]     if (containsElements(foundFormats)) { [EOL]         final Format[] origFormats = getFormats(); [EOL]         int i = 0; [EOL]         for (final Iterator<Format> it = foundFormats.iterator(); it.hasNext(); i++) { [EOL]             final Format f = it.next(); [EOL]             if (f != null) { [EOL]                 origFormats[i] = f; [EOL]             } [EOL]         } [EOL]         super.setFormats(origFormats); [EOL]     } [EOL] } 
 [LINE] if (format == null) { [LINE] @Override [EOL] public final void applyPattern(final String pattern) { [EOL]     if (registry == null) { [EOL]         super.applyPattern(pattern); [EOL]         toPattern = super.toPattern(); [EOL]         return; [EOL]     } [EOL]     final ArrayList<Format> foundFormats = new ArrayList<Format>(); [EOL]     final ArrayList<String> foundDescriptions = new ArrayList<String>(); [EOL]     final StringBuilder stripCustom = new StringBuilder(pattern.length()); [EOL]     final ParsePosition pos = new ParsePosition(0); [EOL]     final char[] c = pattern.toCharArray(); [EOL]     int fmtCount = 0; [EOL]     while (pos.getIndex() < pattern.length()) { [EOL]         switch(c[pos.getIndex()]) { [EOL]             case QUOTE: [EOL]                 appendQuotedString(pattern, pos, stripCustom, true); [EOL]                 break; [EOL]             case START_FE: [EOL]                 fmtCount++; [EOL]                 seekNonWs(pattern, pos); [EOL]                 final int start = pos.getIndex(); [EOL]                 final int index = readArgumentIndex(pattern, next(pos)); [EOL]                 stripCustom.append(START_FE).append(index); [EOL]                 seekNonWs(pattern, pos); [EOL]                 Format format = null; [EOL]                 String formatDescription = null; [EOL]                 if (c[pos.getIndex()] == START_FMT) { [EOL]                     formatDescription = parseFormatDescription(pattern, next(pos)); [EOL]                     format = getFormat(formatDescription); [EOL]                     if (format == null) { [EOL]                         stripCustom.append(START_FMT).append(formatDescription); [EOL]                     } [EOL]                 } [EOL]                 foundFormats.add(format); [EOL]                 foundDescriptions.add(format == null ? null : formatDescription); [EOL]                 Validate.isTrue(foundFormats.size() == fmtCount); [EOL]                 Validate.isTrue(foundDescriptions.size() == fmtCount); [EOL]                 if (c[pos.getIndex()] != END_FE) { [EOL]                     throw new IllegalArgumentException("Unreadable format element at position " + start); [EOL]                 } [EOL]             default: [EOL]                 stripCustom.append(c[pos.getIndex()]); [EOL]                 next(pos); [EOL]         } [EOL]     } [EOL]     super.applyPattern(stripCustom.toString()); [EOL]     toPattern = insertFormats(super.toPattern(), foundDescriptions); [EOL]     if (containsElements(foundFormats)) { [EOL]         final Format[] origFormats = getFormats(); [EOL]         int i = 0; [EOL]         for (final Iterator<Format> it = foundFormats.iterator(); it.hasNext(); i++) { [EOL]             final Format f = it.next(); [EOL]             if (f != null) { [EOL]                 origFormats[i] = f; [EOL]             } [EOL]         } [EOL]         super.setFormats(origFormats); [EOL]     } [EOL] } 
 [LINE] stripCustom.append(START_FMT).append(formatDescription); [LINE] @Override [EOL] public final void applyPattern(final String pattern) { [EOL]     if (registry == null) { [EOL]         super.applyPattern(pattern); [EOL]         toPattern = super.toPattern(); [EOL]         return; [EOL]     } [EOL]     final ArrayList<Format> foundFormats = new ArrayList<Format>(); [EOL]     final ArrayList<String> foundDescriptions = new ArrayList<String>(); [EOL]     final StringBuilder stripCustom = new StringBuilder(pattern.length()); [EOL]     final ParsePosition pos = new ParsePosition(0); [EOL]     final char[] c = pattern.toCharArray(); [EOL]     int fmtCount = 0; [EOL]     while (pos.getIndex() < pattern.length()) { [EOL]         switch(c[pos.getIndex()]) { [EOL]             case QUOTE: [EOL]                 appendQuotedString(pattern, pos, stripCustom, true); [EOL]                 break; [EOL]             case START_FE: [EOL]                 fmtCount++; [EOL]                 seekNonWs(pattern, pos); [EOL]                 final int start = pos.getIndex(); [EOL]                 final int index = readArgumentIndex(pattern, next(pos)); [EOL]                 stripCustom.append(START_FE).append(index); [EOL]                 seekNonWs(pattern, pos); [EOL]                 Format format = null; [EOL]                 String formatDescription = null; [EOL]                 if (c[pos.getIndex()] == START_FMT) { [EOL]                     formatDescription = parseFormatDescription(pattern, next(pos)); [EOL]                     format = getFormat(formatDescription); [EOL]                     if (format == null) { [EOL]                         stripCustom.append(START_FMT).append(formatDescription); [EOL]                     } [EOL]                 } [EOL]                 foundFormats.add(format); [EOL]                 foundDescriptions.add(format == null ? null : formatDescription); [EOL]                 Validate.isTrue(foundFormats.size() == fmtCount); [EOL]                 Validate.isTrue(foundDescriptions.size() == fmtCount); [EOL]                 if (c[pos.getIndex()] != END_FE) { [EOL]                     throw new IllegalArgumentException("Unreadable format element at position " + start); [EOL]                 } [EOL]             default: [EOL]                 stripCustom.append(c[pos.getIndex()]); [EOL]                 next(pos); [EOL]         } [EOL]     } [EOL]     super.applyPattern(stripCustom.toString()); [EOL]     toPattern = insertFormats(super.toPattern(), foundDescriptions); [EOL]     if (containsElements(foundFormats)) { [EOL]         final Format[] origFormats = getFormats(); [EOL]         int i = 0; [EOL]         for (final Iterator<Format> it = foundFormats.iterator(); it.hasNext(); i++) { [EOL]             final Format f = it.next(); [EOL]             if (f != null) { [EOL]                 origFormats[i] = f; [EOL]             } [EOL]         } [EOL]         super.setFormats(origFormats); [EOL]     } [EOL] } 
 [LINE] foundFormats.add(format); [LINE] @Override [EOL] public final void applyPattern(final String pattern) { [EOL]     if (registry == null) { [EOL]         super.applyPattern(pattern); [EOL]         toPattern = super.toPattern(); [EOL]         return; [EOL]     } [EOL]     final ArrayList<Format> foundFormats = new ArrayList<Format>(); [EOL]     final ArrayList<String> foundDescriptions = new ArrayList<String>(); [EOL]     final StringBuilder stripCustom = new StringBuilder(pattern.length()); [EOL]     final ParsePosition pos = new ParsePosition(0); [EOL]     final char[] c = pattern.toCharArray(); [EOL]     int fmtCount = 0; [EOL]     while (pos.getIndex() < pattern.length()) { [EOL]         switch(c[pos.getIndex()]) { [EOL]             case QUOTE: [EOL]                 appendQuotedString(pattern, pos, stripCustom, true); [EOL]                 break; [EOL]             case START_FE: [EOL]                 fmtCount++; [EOL]                 seekNonWs(pattern, pos); [EOL]                 final int start = pos.getIndex(); [EOL]                 final int index = readArgumentIndex(pattern, next(pos)); [EOL]                 stripCustom.append(START_FE).append(index); [EOL]                 seekNonWs(pattern, pos); [EOL]                 Format format = null; [EOL]                 String formatDescription = null; [EOL]                 if (c[pos.getIndex()] == START_FMT) { [EOL]                     formatDescription = parseFormatDescription(pattern, next(pos)); [EOL]                     format = getFormat(formatDescription); [EOL]                     if (format == null) { [EOL]                         stripCustom.append(START_FMT).append(formatDescription); [EOL]                     } [EOL]                 } [EOL]                 foundFormats.add(format); [EOL]                 foundDescriptions.add(format == null ? null : formatDescription); [EOL]                 Validate.isTrue(foundFormats.size() == fmtCount); [EOL]                 Validate.isTrue(foundDescriptions.size() == fmtCount); [EOL]                 if (c[pos.getIndex()] != END_FE) { [EOL]                     throw new IllegalArgumentException("Unreadable format element at position " + start); [EOL]                 } [EOL]             default: [EOL]                 stripCustom.append(c[pos.getIndex()]); [EOL]                 next(pos); [EOL]         } [EOL]     } [EOL]     super.applyPattern(stripCustom.toString()); [EOL]     toPattern = insertFormats(super.toPattern(), foundDescriptions); [EOL]     if (containsElements(foundFormats)) { [EOL]         final Format[] origFormats = getFormats(); [EOL]         int i = 0; [EOL]         for (final Iterator<Format> it = foundFormats.iterator(); it.hasNext(); i++) { [EOL]             final Format f = it.next(); [EOL]             if (f != null) { [EOL]                 origFormats[i] = f; [EOL]             } [EOL]         } [EOL]         super.setFormats(origFormats); [EOL]     } [EOL] } 
 [LINE] foundDescriptions.add(format == null ? null : formatDescription); [LINE] @Override [EOL] public final void applyPattern(final String pattern) { [EOL]     if (registry == null) { [EOL]         super.applyPattern(pattern); [EOL]         toPattern = super.toPattern(); [EOL]         return; [EOL]     } [EOL]     final ArrayList<Format> foundFormats = new ArrayList<Format>(); [EOL]     final ArrayList<String> foundDescriptions = new ArrayList<String>(); [EOL]     final StringBuilder stripCustom = new StringBuilder(pattern.length()); [EOL]     final ParsePosition pos = new ParsePosition(0); [EOL]     final char[] c = pattern.toCharArray(); [EOL]     int fmtCount = 0; [EOL]     while (pos.getIndex() < pattern.length()) { [EOL]         switch(c[pos.getIndex()]) { [EOL]             case QUOTE: [EOL]                 appendQuotedString(pattern, pos, stripCustom, true); [EOL]                 break; [EOL]             case START_FE: [EOL]                 fmtCount++; [EOL]                 seekNonWs(pattern, pos); [EOL]                 final int start = pos.getIndex(); [EOL]                 final int index = readArgumentIndex(pattern, next(pos)); [EOL]                 stripCustom.append(START_FE).append(index); [EOL]                 seekNonWs(pattern, pos); [EOL]                 Format format = null; [EOL]                 String formatDescription = null; [EOL]                 if (c[pos.getIndex()] == START_FMT) { [EOL]                     formatDescription = parseFormatDescription(pattern, next(pos)); [EOL]                     format = getFormat(formatDescription); [EOL]                     if (format == null) { [EOL]                         stripCustom.append(START_FMT).append(formatDescription); [EOL]                     } [EOL]                 } [EOL]                 foundFormats.add(format); [EOL]                 foundDescriptions.add(format == null ? null : formatDescription); [EOL]                 Validate.isTrue(foundFormats.size() == fmtCount); [EOL]                 Validate.isTrue(foundDescriptions.size() == fmtCount); [EOL]                 if (c[pos.getIndex()] != END_FE) { [EOL]                     throw new IllegalArgumentException("Unreadable format element at position " + start); [EOL]                 } [EOL]             default: [EOL]                 stripCustom.append(c[pos.getIndex()]); [EOL]                 next(pos); [EOL]         } [EOL]     } [EOL]     super.applyPattern(stripCustom.toString()); [EOL]     toPattern = insertFormats(super.toPattern(), foundDescriptions); [EOL]     if (containsElements(foundFormats)) { [EOL]         final Format[] origFormats = getFormats(); [EOL]         int i = 0; [EOL]         for (final Iterator<Format> it = foundFormats.iterator(); it.hasNext(); i++) { [EOL]             final Format f = it.next(); [EOL]             if (f != null) { [EOL]                 origFormats[i] = f; [EOL]             } [EOL]         } [EOL]         super.setFormats(origFormats); [EOL]     } [EOL] } 
 [LINE] Validate.isTrue(foundFormats.size() == fmtCount); [LINE] @Override [EOL] public final void applyPattern(final String pattern) { [EOL]     if (registry == null) { [EOL]         super.applyPattern(pattern); [EOL]         toPattern = super.toPattern(); [EOL]         return; [EOL]     } [EOL]     final ArrayList<Format> foundFormats = new ArrayList<Format>(); [EOL]     final ArrayList<String> foundDescriptions = new ArrayList<String>(); [EOL]     final StringBuilder stripCustom = new StringBuilder(pattern.length()); [EOL]     final ParsePosition pos = new ParsePosition(0); [EOL]     final char[] c = pattern.toCharArray(); [EOL]     int fmtCount = 0; [EOL]     while (pos.getIndex() < pattern.length()) { [EOL]         switch(c[pos.getIndex()]) { [EOL]             case QUOTE: [EOL]                 appendQuotedString(pattern, pos, stripCustom, true); [EOL]                 break; [EOL]             case START_FE: [EOL]                 fmtCount++; [EOL]                 seekNonWs(pattern, pos); [EOL]                 final int start = pos.getIndex(); [EOL]                 final int index = readArgumentIndex(pattern, next(pos)); [EOL]                 stripCustom.append(START_FE).append(index); [EOL]                 seekNonWs(pattern, pos); [EOL]                 Format format = null; [EOL]                 String formatDescription = null; [EOL]                 if (c[pos.getIndex()] == START_FMT) { [EOL]                     formatDescription = parseFormatDescription(pattern, next(pos)); [EOL]                     format = getFormat(formatDescription); [EOL]                     if (format == null) { [EOL]                         stripCustom.append(START_FMT).append(formatDescription); [EOL]                     } [EOL]                 } [EOL]                 foundFormats.add(format); [EOL]                 foundDescriptions.add(format == null ? null : formatDescription); [EOL]                 Validate.isTrue(foundFormats.size() == fmtCount); [EOL]                 Validate.isTrue(foundDescriptions.size() == fmtCount); [EOL]                 if (c[pos.getIndex()] != END_FE) { [EOL]                     throw new IllegalArgumentException("Unreadable format element at position " + start); [EOL]                 } [EOL]             default: [EOL]                 stripCustom.append(c[pos.getIndex()]); [EOL]                 next(pos); [EOL]         } [EOL]     } [EOL]     super.applyPattern(stripCustom.toString()); [EOL]     toPattern = insertFormats(super.toPattern(), foundDescriptions); [EOL]     if (containsElements(foundFormats)) { [EOL]         final Format[] origFormats = getFormats(); [EOL]         int i = 0; [EOL]         for (final Iterator<Format> it = foundFormats.iterator(); it.hasNext(); i++) { [EOL]             final Format f = it.next(); [EOL]             if (f != null) { [EOL]                 origFormats[i] = f; [EOL]             } [EOL]         } [EOL]         super.setFormats(origFormats); [EOL]     } [EOL] } 
 [LINE] Validate.isTrue(foundDescriptions.size() == fmtCount); [LINE] @Override [EOL] public final void applyPattern(final String pattern) { [EOL]     if (registry == null) { [EOL]         super.applyPattern(pattern); [EOL]         toPattern = super.toPattern(); [EOL]         return; [EOL]     } [EOL]     final ArrayList<Format> foundFormats = new ArrayList<Format>(); [EOL]     final ArrayList<String> foundDescriptions = new ArrayList<String>(); [EOL]     final StringBuilder stripCustom = new StringBuilder(pattern.length()); [EOL]     final ParsePosition pos = new ParsePosition(0); [EOL]     final char[] c = pattern.toCharArray(); [EOL]     int fmtCount = 0; [EOL]     while (pos.getIndex() < pattern.length()) { [EOL]         switch(c[pos.getIndex()]) { [EOL]             case QUOTE: [EOL]                 appendQuotedString(pattern, pos, stripCustom, true); [EOL]                 break; [EOL]             case START_FE: [EOL]                 fmtCount++; [EOL]                 seekNonWs(pattern, pos); [EOL]                 final int start = pos.getIndex(); [EOL]                 final int index = readArgumentIndex(pattern, next(pos)); [EOL]                 stripCustom.append(START_FE).append(index); [EOL]                 seekNonWs(pattern, pos); [EOL]                 Format format = null; [EOL]                 String formatDescription = null; [EOL]                 if (c[pos.getIndex()] == START_FMT) { [EOL]                     formatDescription = parseFormatDescription(pattern, next(pos)); [EOL]                     format = getFormat(formatDescription); [EOL]                     if (format == null) { [EOL]                         stripCustom.append(START_FMT).append(formatDescription); [EOL]                     } [EOL]                 } [EOL]                 foundFormats.add(format); [EOL]                 foundDescriptions.add(format == null ? null : formatDescription); [EOL]                 Validate.isTrue(foundFormats.size() == fmtCount); [EOL]                 Validate.isTrue(foundDescriptions.size() == fmtCount); [EOL]                 if (c[pos.getIndex()] != END_FE) { [EOL]                     throw new IllegalArgumentException("Unreadable format element at position " + start); [EOL]                 } [EOL]             default: [EOL]                 stripCustom.append(c[pos.getIndex()]); [EOL]                 next(pos); [EOL]         } [EOL]     } [EOL]     super.applyPattern(stripCustom.toString()); [EOL]     toPattern = insertFormats(super.toPattern(), foundDescriptions); [EOL]     if (containsElements(foundFormats)) { [EOL]         final Format[] origFormats = getFormats(); [EOL]         int i = 0; [EOL]         for (final Iterator<Format> it = foundFormats.iterator(); it.hasNext(); i++) { [EOL]             final Format f = it.next(); [EOL]             if (f != null) { [EOL]                 origFormats[i] = f; [EOL]             } [EOL]         } [EOL]         super.setFormats(origFormats); [EOL]     } [EOL] } 
 [LINE] if (c[pos.getIndex()] != END_FE) { [LINE] @Override [EOL] public final void applyPattern(final String pattern) { [EOL]     if (registry == null) { [EOL]         super.applyPattern(pattern); [EOL]         toPattern = super.toPattern(); [EOL]         return; [EOL]     } [EOL]     final ArrayList<Format> foundFormats = new ArrayList<Format>(); [EOL]     final ArrayList<String> foundDescriptions = new ArrayList<String>(); [EOL]     final StringBuilder stripCustom = new StringBuilder(pattern.length()); [EOL]     final ParsePosition pos = new ParsePosition(0); [EOL]     final char[] c = pattern.toCharArray(); [EOL]     int fmtCount = 0; [EOL]     while (pos.getIndex() < pattern.length()) { [EOL]         switch(c[pos.getIndex()]) { [EOL]             case QUOTE: [EOL]                 appendQuotedString(pattern, pos, stripCustom, true); [EOL]                 break; [EOL]             case START_FE: [EOL]                 fmtCount++; [EOL]                 seekNonWs(pattern, pos); [EOL]                 final int start = pos.getIndex(); [EOL]                 final int index = readArgumentIndex(pattern, next(pos)); [EOL]                 stripCustom.append(START_FE).append(index); [EOL]                 seekNonWs(pattern, pos); [EOL]                 Format format = null; [EOL]                 String formatDescription = null; [EOL]                 if (c[pos.getIndex()] == START_FMT) { [EOL]                     formatDescription = parseFormatDescription(pattern, next(pos)); [EOL]                     format = getFormat(formatDescription); [EOL]                     if (format == null) { [EOL]                         stripCustom.append(START_FMT).append(formatDescription); [EOL]                     } [EOL]                 } [EOL]                 foundFormats.add(format); [EOL]                 foundDescriptions.add(format == null ? null : formatDescription); [EOL]                 Validate.isTrue(foundFormats.size() == fmtCount); [EOL]                 Validate.isTrue(foundDescriptions.size() == fmtCount); [EOL]                 if (c[pos.getIndex()] != END_FE) { [EOL]                     throw new IllegalArgumentException("Unreadable format element at position " + start); [EOL]                 } [EOL]             default: [EOL]                 stripCustom.append(c[pos.getIndex()]); [EOL]                 next(pos); [EOL]         } [EOL]     } [EOL]     super.applyPattern(stripCustom.toString()); [EOL]     toPattern = insertFormats(super.toPattern(), foundDescriptions); [EOL]     if (containsElements(foundFormats)) { [EOL]         final Format[] origFormats = getFormats(); [EOL]         int i = 0; [EOL]         for (final Iterator<Format> it = foundFormats.iterator(); it.hasNext(); i++) { [EOL]             final Format f = it.next(); [EOL]             if (f != null) { [EOL]                 origFormats[i] = f; [EOL]             } [EOL]         } [EOL]         super.setFormats(origFormats); [EOL]     } [EOL] } 
 [LINE] final Format[] origFormats = getFormats(); [LINE] @Override [EOL] public final void applyPattern(final String pattern) { [EOL]     if (registry == null) { [EOL]         super.applyPattern(pattern); [EOL]         toPattern = super.toPattern(); [EOL]         return; [EOL]     } [EOL]     final ArrayList<Format> foundFormats = new ArrayList<Format>(); [EOL]     final ArrayList<String> foundDescriptions = new ArrayList<String>(); [EOL]     final StringBuilder stripCustom = new StringBuilder(pattern.length()); [EOL]     final ParsePosition pos = new ParsePosition(0); [EOL]     final char[] c = pattern.toCharArray(); [EOL]     int fmtCount = 0; [EOL]     while (pos.getIndex() < pattern.length()) { [EOL]         switch(c[pos.getIndex()]) { [EOL]             case QUOTE: [EOL]                 appendQuotedString(pattern, pos, stripCustom, true); [EOL]                 break; [EOL]             case START_FE: [EOL]                 fmtCount++; [EOL]                 seekNonWs(pattern, pos); [EOL]                 final int start = pos.getIndex(); [EOL]                 final int index = readArgumentIndex(pattern, next(pos)); [EOL]                 stripCustom.append(START_FE).append(index); [EOL]                 seekNonWs(pattern, pos); [EOL]                 Format format = null; [EOL]                 String formatDescription = null; [EOL]                 if (c[pos.getIndex()] == START_FMT) { [EOL]                     formatDescription = parseFormatDescription(pattern, next(pos)); [EOL]                     format = getFormat(formatDescription); [EOL]                     if (format == null) { [EOL]                         stripCustom.append(START_FMT).append(formatDescription); [EOL]                     } [EOL]                 } [EOL]                 foundFormats.add(format); [EOL]                 foundDescriptions.add(format == null ? null : formatDescription); [EOL]                 Validate.isTrue(foundFormats.size() == fmtCount); [EOL]                 Validate.isTrue(foundDescriptions.size() == fmtCount); [EOL]                 if (c[pos.getIndex()] != END_FE) { [EOL]                     throw new IllegalArgumentException("Unreadable format element at position " + start); [EOL]                 } [EOL]             default: [EOL]                 stripCustom.append(c[pos.getIndex()]); [EOL]                 next(pos); [EOL]         } [EOL]     } [EOL]     super.applyPattern(stripCustom.toString()); [EOL]     toPattern = insertFormats(super.toPattern(), foundDescriptions); [EOL]     if (containsElements(foundFormats)) { [EOL]         final Format[] origFormats = getFormats(); [EOL]         int i = 0; [EOL]         for (final Iterator<Format> it = foundFormats.iterator(); it.hasNext(); i++) { [EOL]             final Format f = it.next(); [EOL]             if (f != null) { [EOL]                 origFormats[i] = f; [EOL]             } [EOL]         } [EOL]         super.setFormats(origFormats); [EOL]     } [EOL] } 
 [LINE] int i = 0; [LINE] @Override [EOL] public final void applyPattern(final String pattern) { [EOL]     if (registry == null) { [EOL]         super.applyPattern(pattern); [EOL]         toPattern = super.toPattern(); [EOL]         return; [EOL]     } [EOL]     final ArrayList<Format> foundFormats = new ArrayList<Format>(); [EOL]     final ArrayList<String> foundDescriptions = new ArrayList<String>(); [EOL]     final StringBuilder stripCustom = new StringBuilder(pattern.length()); [EOL]     final ParsePosition pos = new ParsePosition(0); [EOL]     final char[] c = pattern.toCharArray(); [EOL]     int fmtCount = 0; [EOL]     while (pos.getIndex() < pattern.length()) { [EOL]         switch(c[pos.getIndex()]) { [EOL]             case QUOTE: [EOL]                 appendQuotedString(pattern, pos, stripCustom, true); [EOL]                 break; [EOL]             case START_FE: [EOL]                 fmtCount++; [EOL]                 seekNonWs(pattern, pos); [EOL]                 final int start = pos.getIndex(); [EOL]                 final int index = readArgumentIndex(pattern, next(pos)); [EOL]                 stripCustom.append(START_FE).append(index); [EOL]                 seekNonWs(pattern, pos); [EOL]                 Format format = null; [EOL]                 String formatDescription = null; [EOL]                 if (c[pos.getIndex()] == START_FMT) { [EOL]                     formatDescription = parseFormatDescription(pattern, next(pos)); [EOL]                     format = getFormat(formatDescription); [EOL]                     if (format == null) { [EOL]                         stripCustom.append(START_FMT).append(formatDescription); [EOL]                     } [EOL]                 } [EOL]                 foundFormats.add(format); [EOL]                 foundDescriptions.add(format == null ? null : formatDescription); [EOL]                 Validate.isTrue(foundFormats.size() == fmtCount); [EOL]                 Validate.isTrue(foundDescriptions.size() == fmtCount); [EOL]                 if (c[pos.getIndex()] != END_FE) { [EOL]                     throw new IllegalArgumentException("Unreadable format element at position " + start); [EOL]                 } [EOL]             default: [EOL]                 stripCustom.append(c[pos.getIndex()]); [EOL]                 next(pos); [EOL]         } [EOL]     } [EOL]     super.applyPattern(stripCustom.toString()); [EOL]     toPattern = insertFormats(super.toPattern(), foundDescriptions); [EOL]     if (containsElements(foundFormats)) { [EOL]         final Format[] origFormats = getFormats(); [EOL]         int i = 0; [EOL]         for (final Iterator<Format> it = foundFormats.iterator(); it.hasNext(); i++) { [EOL]             final Format f = it.next(); [EOL]             if (f != null) { [EOL]                 origFormats[i] = f; [EOL]             } [EOL]         } [EOL]         super.setFormats(origFormats); [EOL]     } [EOL] } 
 [LINE] for (final Iterator<Format> it = foundFormats.iterator(); it.hasNext(); i++) { [LINE] @Override [EOL] public final void applyPattern(final String pattern) { [EOL]     if (registry == null) { [EOL]         super.applyPattern(pattern); [EOL]         toPattern = super.toPattern(); [EOL]         return; [EOL]     } [EOL]     final ArrayList<Format> foundFormats = new ArrayList<Format>(); [EOL]     final ArrayList<String> foundDescriptions = new ArrayList<String>(); [EOL]     final StringBuilder stripCustom = new StringBuilder(pattern.length()); [EOL]     final ParsePosition pos = new ParsePosition(0); [EOL]     final char[] c = pattern.toCharArray(); [EOL]     int fmtCount = 0; [EOL]     while (pos.getIndex() < pattern.length()) { [EOL]         switch(c[pos.getIndex()]) { [EOL]             case QUOTE: [EOL]                 appendQuotedString(pattern, pos, stripCustom, true); [EOL]                 break; [EOL]             case START_FE: [EOL]                 fmtCount++; [EOL]                 seekNonWs(pattern, pos); [EOL]                 final int start = pos.getIndex(); [EOL]                 final int index = readArgumentIndex(pattern, next(pos)); [EOL]                 stripCustom.append(START_FE).append(index); [EOL]                 seekNonWs(pattern, pos); [EOL]                 Format format = null; [EOL]                 String formatDescription = null; [EOL]                 if (c[pos.getIndex()] == START_FMT) { [EOL]                     formatDescription = parseFormatDescription(pattern, next(pos)); [EOL]                     format = getFormat(formatDescription); [EOL]                     if (format == null) { [EOL]                         stripCustom.append(START_FMT).append(formatDescription); [EOL]                     } [EOL]                 } [EOL]                 foundFormats.add(format); [EOL]                 foundDescriptions.add(format == null ? null : formatDescription); [EOL]                 Validate.isTrue(foundFormats.size() == fmtCount); [EOL]                 Validate.isTrue(foundDescriptions.size() == fmtCount); [EOL]                 if (c[pos.getIndex()] != END_FE) { [EOL]                     throw new IllegalArgumentException("Unreadable format element at position " + start); [EOL]                 } [EOL]             default: [EOL]                 stripCustom.append(c[pos.getIndex()]); [EOL]                 next(pos); [EOL]         } [EOL]     } [EOL]     super.applyPattern(stripCustom.toString()); [EOL]     toPattern = insertFormats(super.toPattern(), foundDescriptions); [EOL]     if (containsElements(foundFormats)) { [EOL]         final Format[] origFormats = getFormats(); [EOL]         int i = 0; [EOL]         for (final Iterator<Format> it = foundFormats.iterator(); it.hasNext(); i++) { [EOL]             final Format f = it.next(); [EOL]             if (f != null) { [EOL]                 origFormats[i] = f; [EOL]             } [EOL]         } [EOL]         super.setFormats(origFormats); [EOL]     } [EOL] } 
 [LINE] final Format f = it.next(); [LINE] @Override [EOL] public final void applyPattern(final String pattern) { [EOL]     if (registry == null) { [EOL]         super.applyPattern(pattern); [EOL]         toPattern = super.toPattern(); [EOL]         return; [EOL]     } [EOL]     final ArrayList<Format> foundFormats = new ArrayList<Format>(); [EOL]     final ArrayList<String> foundDescriptions = new ArrayList<String>(); [EOL]     final StringBuilder stripCustom = new StringBuilder(pattern.length()); [EOL]     final ParsePosition pos = new ParsePosition(0); [EOL]     final char[] c = pattern.toCharArray(); [EOL]     int fmtCount = 0; [EOL]     while (pos.getIndex() < pattern.length()) { [EOL]         switch(c[pos.getIndex()]) { [EOL]             case QUOTE: [EOL]                 appendQuotedString(pattern, pos, stripCustom, true); [EOL]                 break; [EOL]             case START_FE: [EOL]                 fmtCount++; [EOL]                 seekNonWs(pattern, pos); [EOL]                 final int start = pos.getIndex(); [EOL]                 final int index = readArgumentIndex(pattern, next(pos)); [EOL]                 stripCustom.append(START_FE).append(index); [EOL]                 seekNonWs(pattern, pos); [EOL]                 Format format = null; [EOL]                 String formatDescription = null; [EOL]                 if (c[pos.getIndex()] == START_FMT) { [EOL]                     formatDescription = parseFormatDescription(pattern, next(pos)); [EOL]                     format = getFormat(formatDescription); [EOL]                     if (format == null) { [EOL]                         stripCustom.append(START_FMT).append(formatDescription); [EOL]                     } [EOL]                 } [EOL]                 foundFormats.add(format); [EOL]                 foundDescriptions.add(format == null ? null : formatDescription); [EOL]                 Validate.isTrue(foundFormats.size() == fmtCount); [EOL]                 Validate.isTrue(foundDescriptions.size() == fmtCount); [EOL]                 if (c[pos.getIndex()] != END_FE) { [EOL]                     throw new IllegalArgumentException("Unreadable format element at position " + start); [EOL]                 } [EOL]             default: [EOL]                 stripCustom.append(c[pos.getIndex()]); [EOL]                 next(pos); [EOL]         } [EOL]     } [EOL]     super.applyPattern(stripCustom.toString()); [EOL]     toPattern = insertFormats(super.toPattern(), foundDescriptions); [EOL]     if (containsElements(foundFormats)) { [EOL]         final Format[] origFormats = getFormats(); [EOL]         int i = 0; [EOL]         for (final Iterator<Format> it = foundFormats.iterator(); it.hasNext(); i++) { [EOL]             final Format f = it.next(); [EOL]             if (f != null) { [EOL]                 origFormats[i] = f; [EOL]             } [EOL]         } [EOL]         super.setFormats(origFormats); [EOL]     } [EOL] } 
 [LINE] if (f != null) { [LINE] @Override [EOL] public final void applyPattern(final String pattern) { [EOL]     if (registry == null) { [EOL]         super.applyPattern(pattern); [EOL]         toPattern = super.toPattern(); [EOL]         return; [EOL]     } [EOL]     final ArrayList<Format> foundFormats = new ArrayList<Format>(); [EOL]     final ArrayList<String> foundDescriptions = new ArrayList<String>(); [EOL]     final StringBuilder stripCustom = new StringBuilder(pattern.length()); [EOL]     final ParsePosition pos = new ParsePosition(0); [EOL]     final char[] c = pattern.toCharArray(); [EOL]     int fmtCount = 0; [EOL]     while (pos.getIndex() < pattern.length()) { [EOL]         switch(c[pos.getIndex()]) { [EOL]             case QUOTE: [EOL]                 appendQuotedString(pattern, pos, stripCustom, true); [EOL]                 break; [EOL]             case START_FE: [EOL]                 fmtCount++; [EOL]                 seekNonWs(pattern, pos); [EOL]                 final int start = pos.getIndex(); [EOL]                 final int index = readArgumentIndex(pattern, next(pos)); [EOL]                 stripCustom.append(START_FE).append(index); [EOL]                 seekNonWs(pattern, pos); [EOL]                 Format format = null; [EOL]                 String formatDescription = null; [EOL]                 if (c[pos.getIndex()] == START_FMT) { [EOL]                     formatDescription = parseFormatDescription(pattern, next(pos)); [EOL]                     format = getFormat(formatDescription); [EOL]                     if (format == null) { [EOL]                         stripCustom.append(START_FMT).append(formatDescription); [EOL]                     } [EOL]                 } [EOL]                 foundFormats.add(format); [EOL]                 foundDescriptions.add(format == null ? null : formatDescription); [EOL]                 Validate.isTrue(foundFormats.size() == fmtCount); [EOL]                 Validate.isTrue(foundDescriptions.size() == fmtCount); [EOL]                 if (c[pos.getIndex()] != END_FE) { [EOL]                     throw new IllegalArgumentException("Unreadable format element at position " + start); [EOL]                 } [EOL]             default: [EOL]                 stripCustom.append(c[pos.getIndex()]); [EOL]                 next(pos); [EOL]         } [EOL]     } [EOL]     super.applyPattern(stripCustom.toString()); [EOL]     toPattern = insertFormats(super.toPattern(), foundDescriptions); [EOL]     if (containsElements(foundFormats)) { [EOL]         final Format[] origFormats = getFormats(); [EOL]         int i = 0; [EOL]         for (final Iterator<Format> it = foundFormats.iterator(); it.hasNext(); i++) { [EOL]             final Format f = it.next(); [EOL]             if (f != null) { [EOL]                 origFormats[i] = f; [EOL]             } [EOL]         } [EOL]         super.setFormats(origFormats); [EOL]     } [EOL] } 
 [LINE] origFormats[i] = f; [LINE] @Override [EOL] public final void applyPattern(final String pattern) { [EOL]     if (registry == null) { [EOL]         super.applyPattern(pattern); [EOL]         toPattern = super.toPattern(); [EOL]         return; [EOL]     } [EOL]     final ArrayList<Format> foundFormats = new ArrayList<Format>(); [EOL]     final ArrayList<String> foundDescriptions = new ArrayList<String>(); [EOL]     final StringBuilder stripCustom = new StringBuilder(pattern.length()); [EOL]     final ParsePosition pos = new ParsePosition(0); [EOL]     final char[] c = pattern.toCharArray(); [EOL]     int fmtCount = 0; [EOL]     while (pos.getIndex() < pattern.length()) { [EOL]         switch(c[pos.getIndex()]) { [EOL]             case QUOTE: [EOL]                 appendQuotedString(pattern, pos, stripCustom, true); [EOL]                 break; [EOL]             case START_FE: [EOL]                 fmtCount++; [EOL]                 seekNonWs(pattern, pos); [EOL]                 final int start = pos.getIndex(); [EOL]                 final int index = readArgumentIndex(pattern, next(pos)); [EOL]                 stripCustom.append(START_FE).append(index); [EOL]                 seekNonWs(pattern, pos); [EOL]                 Format format = null; [EOL]                 String formatDescription = null; [EOL]                 if (c[pos.getIndex()] == START_FMT) { [EOL]                     formatDescription = parseFormatDescription(pattern, next(pos)); [EOL]                     format = getFormat(formatDescription); [EOL]                     if (format == null) { [EOL]                         stripCustom.append(START_FMT).append(formatDescription); [EOL]                     } [EOL]                 } [EOL]                 foundFormats.add(format); [EOL]                 foundDescriptions.add(format == null ? null : formatDescription); [EOL]                 Validate.isTrue(foundFormats.size() == fmtCount); [EOL]                 Validate.isTrue(foundDescriptions.size() == fmtCount); [EOL]                 if (c[pos.getIndex()] != END_FE) { [EOL]                     throw new IllegalArgumentException("Unreadable format element at position " + start); [EOL]                 } [EOL]             default: [EOL]                 stripCustom.append(c[pos.getIndex()]); [EOL]                 next(pos); [EOL]         } [EOL]     } [EOL]     super.applyPattern(stripCustom.toString()); [EOL]     toPattern = insertFormats(super.toPattern(), foundDescriptions); [EOL]     if (containsElements(foundFormats)) { [EOL]         final Format[] origFormats = getFormats(); [EOL]         int i = 0; [EOL]         for (final Iterator<Format> it = foundFormats.iterator(); it.hasNext(); i++) { [EOL]             final Format f = it.next(); [EOL]             if (f != null) { [EOL]                 origFormats[i] = f; [EOL]             } [EOL]         } [EOL]         super.setFormats(origFormats); [EOL]     } [EOL] } 
 [LINE] super.setFormats(origFormats); [LINE] @Override [EOL] public final void applyPattern(final String pattern) { [EOL]     if (registry == null) { [EOL]         super.applyPattern(pattern); [EOL]         toPattern = super.toPattern(); [EOL]         return; [EOL]     } [EOL]     final ArrayList<Format> foundFormats = new ArrayList<Format>(); [EOL]     final ArrayList<String> foundDescriptions = new ArrayList<String>(); [EOL]     final StringBuilder stripCustom = new StringBuilder(pattern.length()); [EOL]     final ParsePosition pos = new ParsePosition(0); [EOL]     final char[] c = pattern.toCharArray(); [EOL]     int fmtCount = 0; [EOL]     while (pos.getIndex() < pattern.length()) { [EOL]         switch(c[pos.getIndex()]) { [EOL]             case QUOTE: [EOL]                 appendQuotedString(pattern, pos, stripCustom, true); [EOL]                 break; [EOL]             case START_FE: [EOL]                 fmtCount++; [EOL]                 seekNonWs(pattern, pos); [EOL]                 final int start = pos.getIndex(); [EOL]                 final int index = readArgumentIndex(pattern, next(pos)); [EOL]                 stripCustom.append(START_FE).append(index); [EOL]                 seekNonWs(pattern, pos); [EOL]                 Format format = null; [EOL]                 String formatDescription = null; [EOL]                 if (c[pos.getIndex()] == START_FMT) { [EOL]                     formatDescription = parseFormatDescription(pattern, next(pos)); [EOL]                     format = getFormat(formatDescription); [EOL]                     if (format == null) { [EOL]                         stripCustom.append(START_FMT).append(formatDescription); [EOL]                     } [EOL]                 } [EOL]                 foundFormats.add(format); [EOL]                 foundDescriptions.add(format == null ? null : formatDescription); [EOL]                 Validate.isTrue(foundFormats.size() == fmtCount); [EOL]                 Validate.isTrue(foundDescriptions.size() == fmtCount); [EOL]                 if (c[pos.getIndex()] != END_FE) { [EOL]                     throw new IllegalArgumentException("Unreadable format element at position " + start); [EOL]                 } [EOL]             default: [EOL]                 stripCustom.append(c[pos.getIndex()]); [EOL]                 next(pos); [EOL]         } [EOL]     } [EOL]     super.applyPattern(stripCustom.toString()); [EOL]     toPattern = insertFormats(super.toPattern(), foundDescriptions); [EOL]     if (containsElements(foundFormats)) { [EOL]         final Format[] origFormats = getFormats(); [EOL]         int i = 0; [EOL]         for (final Iterator<Format> it = foundFormats.iterator(); it.hasNext(); i++) { [EOL]             final Format f = it.next(); [EOL]             if (f != null) { [EOL]                 origFormats[i] = f; [EOL]             } [EOL]         } [EOL]         super.setFormats(origFormats); [EOL]     } [EOL] } 
 [LINE] private Format getFormat(final String desc) { [LINE] private Format getFormat(final String desc) { [EOL]     if (registry != null) { [EOL]         String name = desc; [EOL]         String args = null; [EOL]         final int i = desc.indexOf(START_FMT); [EOL]         if (i > 0) { [EOL]             name = desc.substring(0, i).trim(); [EOL]             args = desc.substring(i + 1).trim(); [EOL]         } [EOL]         final FormatFactory factory = registry.get(name); [EOL]         if (factory != null) { [EOL]             return factory.getFormat(name, args, getLocale()); [EOL]         } [EOL]     } [EOL]     return null; [EOL] } 
 [LINE] if (registry != null) { [LINE] private Format getFormat(final String desc) { [EOL]     if (registry != null) { [EOL]         String name = desc; [EOL]         String args = null; [EOL]         final int i = desc.indexOf(START_FMT); [EOL]         if (i > 0) { [EOL]             name = desc.substring(0, i).trim(); [EOL]             args = desc.substring(i + 1).trim(); [EOL]         } [EOL]         final FormatFactory factory = registry.get(name); [EOL]         if (factory != null) { [EOL]             return factory.getFormat(name, args, getLocale()); [EOL]         } [EOL]     } [EOL]     return null; [EOL] } 
 [LINE] String name = desc; [LINE] private Format getFormat(final String desc) { [EOL]     if (registry != null) { [EOL]         String name = desc; [EOL]         String args = null; [EOL]         final int i = desc.indexOf(START_FMT); [EOL]         if (i > 0) { [EOL]             name = desc.substring(0, i).trim(); [EOL]             args = desc.substring(i + 1).trim(); [EOL]         } [EOL]         final FormatFactory factory = registry.get(name); [EOL]         if (factory != null) { [EOL]             return factory.getFormat(name, args, getLocale()); [EOL]         } [EOL]     } [EOL]     return null; [EOL] } 
 [LINE] String args = null; [LINE] private Format getFormat(final String desc) { [EOL]     if (registry != null) { [EOL]         String name = desc; [EOL]         String args = null; [EOL]         final int i = desc.indexOf(START_FMT); [EOL]         if (i > 0) { [EOL]             name = desc.substring(0, i).trim(); [EOL]             args = desc.substring(i + 1).trim(); [EOL]         } [EOL]         final FormatFactory factory = registry.get(name); [EOL]         if (factory != null) { [EOL]             return factory.getFormat(name, args, getLocale()); [EOL]         } [EOL]     } [EOL]     return null; [EOL] } 
 [LINE] final int i = desc.indexOf(START_FMT); [LINE] private Format getFormat(final String desc) { [EOL]     if (registry != null) { [EOL]         String name = desc; [EOL]         String args = null; [EOL]         final int i = desc.indexOf(START_FMT); [EOL]         if (i > 0) { [EOL]             name = desc.substring(0, i).trim(); [EOL]             args = desc.substring(i + 1).trim(); [EOL]         } [EOL]         final FormatFactory factory = registry.get(name); [EOL]         if (factory != null) { [EOL]             return factory.getFormat(name, args, getLocale()); [EOL]         } [EOL]     } [EOL]     return null; [EOL] } 
 [LINE] if (i > 0) { [LINE] private Format getFormat(final String desc) { [EOL]     if (registry != null) { [EOL]         String name = desc; [EOL]         String args = null; [EOL]         final int i = desc.indexOf(START_FMT); [EOL]         if (i > 0) { [EOL]             name = desc.substring(0, i).trim(); [EOL]             args = desc.substring(i + 1).trim(); [EOL]         } [EOL]         final FormatFactory factory = registry.get(name); [EOL]         if (factory != null) { [EOL]             return factory.getFormat(name, args, getLocale()); [EOL]         } [EOL]     } [EOL]     return null; [EOL] } 
 [LINE] name = desc.substring(0, i).trim(); [LINE] private Format getFormat(final String desc) { [EOL]     if (registry != null) { [EOL]         String name = desc; [EOL]         String args = null; [EOL]         final int i = desc.indexOf(START_FMT); [EOL]         if (i > 0) { [EOL]             name = desc.substring(0, i).trim(); [EOL]             args = desc.substring(i + 1).trim(); [EOL]         } [EOL]         final FormatFactory factory = registry.get(name); [EOL]         if (factory != null) { [EOL]             return factory.getFormat(name, args, getLocale()); [EOL]         } [EOL]     } [EOL]     return null; [EOL] } 
 [LINE] args = desc.substring(i + 1).trim(); [LINE] private Format getFormat(final String desc) { [EOL]     if (registry != null) { [EOL]         String name = desc; [EOL]         String args = null; [EOL]         final int i = desc.indexOf(START_FMT); [EOL]         if (i > 0) { [EOL]             name = desc.substring(0, i).trim(); [EOL]             args = desc.substring(i + 1).trim(); [EOL]         } [EOL]         final FormatFactory factory = registry.get(name); [EOL]         if (factory != null) { [EOL]             return factory.getFormat(name, args, getLocale()); [EOL]         } [EOL]     } [EOL]     return null; [EOL] } 
 [LINE] final FormatFactory factory = registry.get(name); [LINE] private Format getFormat(final String desc) { [EOL]     if (registry != null) { [EOL]         String name = desc; [EOL]         String args = null; [EOL]         final int i = desc.indexOf(START_FMT); [EOL]         if (i > 0) { [EOL]             name = desc.substring(0, i).trim(); [EOL]             args = desc.substring(i + 1).trim(); [EOL]         } [EOL]         final FormatFactory factory = registry.get(name); [EOL]         if (factory != null) { [EOL]             return factory.getFormat(name, args, getLocale()); [EOL]         } [EOL]     } [EOL]     return null; [EOL] } 
 [LINE] if (factory != null) { [LINE] private Format getFormat(final String desc) { [EOL]     if (registry != null) { [EOL]         String name = desc; [EOL]         String args = null; [EOL]         final int i = desc.indexOf(START_FMT); [EOL]         if (i > 0) { [EOL]             name = desc.substring(0, i).trim(); [EOL]             args = desc.substring(i + 1).trim(); [EOL]         } [EOL]         final FormatFactory factory = registry.get(name); [EOL]         if (factory != null) { [EOL]             return factory.getFormat(name, args, getLocale()); [EOL]         } [EOL]     } [EOL]     return null; [EOL] } 
 [LINE] return factory.getFormat(name, args, getLocale()); [LINE] private Format getFormat(final String desc) { [EOL]     if (registry != null) { [EOL]         String name = desc; [EOL]         String args = null; [EOL]         final int i = desc.indexOf(START_FMT); [EOL]         if (i > 0) { [EOL]             name = desc.substring(0, i).trim(); [EOL]             args = desc.substring(i + 1).trim(); [EOL]         } [EOL]         final FormatFactory factory = registry.get(name); [EOL]         if (factory != null) { [EOL]             return factory.getFormat(name, args, getLocale()); [EOL]         } [EOL]     } [EOL]     return null; [EOL] } 
 [LINE] return null; [LINE] private Format getFormat(final String desc) { [EOL]     if (registry != null) { [EOL]         String name = desc; [EOL]         String args = null; [EOL]         final int i = desc.indexOf(START_FMT); [EOL]         if (i > 0) { [EOL]             name = desc.substring(0, i).trim(); [EOL]             args = desc.substring(i + 1).trim(); [EOL]         } [EOL]         final FormatFactory factory = registry.get(name); [EOL]         if (factory != null) { [EOL]             return factory.getFormat(name, args, getLocale()); [EOL]         } [EOL]     } [EOL]     return null; [EOL] } 
 [LINE] try { [LINE] private int readArgumentIndex(final String pattern, final ParsePosition pos) { [EOL]     final int start = pos.getIndex(); [EOL]     seekNonWs(pattern, pos); [EOL]     final StringBuilder result = new StringBuilder(); [EOL]     boolean error = false; [EOL]     for (; !error && pos.getIndex() < pattern.length(); next(pos)) { [EOL]         char c = pattern.charAt(pos.getIndex()); [EOL]         if (Character.isWhitespace(c)) { [EOL]             seekNonWs(pattern, pos); [EOL]             c = pattern.charAt(pos.getIndex()); [EOL]             if (c != START_FMT && c != END_FE) { [EOL]                 error = true; [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         if ((c == START_FMT || c == END_FE) && result.length() > 0) { [EOL]             try { [EOL]                 return Integer.parseInt(result.toString()); [EOL]             } catch (final NumberFormatException e) { [EOL]             } [EOL]         } [EOL]         error = !Character.isDigit(c); [EOL]         result.append(c); [EOL]     } [EOL]     if (error) { [EOL]         throw new IllegalArgumentException("Invalid format argument index at position " + start + ": " + pattern.substring(start, pos.getIndex())); [EOL]     } [EOL]     throw new IllegalArgumentException("Unterminated format element at position " + start); [EOL] } 
 [LINE] return Integer.parseInt(result.toString()); [LINE] private int readArgumentIndex(final String pattern, final ParsePosition pos) { [EOL]     final int start = pos.getIndex(); [EOL]     seekNonWs(pattern, pos); [EOL]     final StringBuilder result = new StringBuilder(); [EOL]     boolean error = false; [EOL]     for (; !error && pos.getIndex() < pattern.length(); next(pos)) { [EOL]         char c = pattern.charAt(pos.getIndex()); [EOL]         if (Character.isWhitespace(c)) { [EOL]             seekNonWs(pattern, pos); [EOL]             c = pattern.charAt(pos.getIndex()); [EOL]             if (c != START_FMT && c != END_FE) { [EOL]                 error = true; [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         if ((c == START_FMT || c == END_FE) && result.length() > 0) { [EOL]             try { [EOL]                 return Integer.parseInt(result.toString()); [EOL]             } catch (final NumberFormatException e) { [EOL]             } [EOL]         } [EOL]         error = !Character.isDigit(c); [EOL]         result.append(c); [EOL]     } [EOL]     if (error) { [EOL]         throw new IllegalArgumentException("Invalid format argument index at position " + start + ": " + pattern.substring(start, pos.getIndex())); [EOL]     } [EOL]     throw new IllegalArgumentException("Unterminated format element at position " + start); [EOL] } 
 [LINE] private String parseFormatDescription(final String pattern, final ParsePosition pos) { [LINE] private String parseFormatDescription(final String pattern, final ParsePosition pos) { [EOL]     final int start = pos.getIndex(); [EOL]     seekNonWs(pattern, pos); [EOL]     final int text = pos.getIndex(); [EOL]     int depth = 1; [EOL]     for (; pos.getIndex() < pattern.length(); next(pos)) { [EOL]         switch(pattern.charAt(pos.getIndex())) { [EOL]             case START_FE: [EOL]                 depth++; [EOL]                 break; [EOL]             case END_FE: [EOL]                 depth--; [EOL]                 if (depth == 0) { [EOL]                     return pattern.substring(text, pos.getIndex()); [EOL]                 } [EOL]                 break; [EOL]             case QUOTE: [EOL]                 getQuotedString(pattern, pos, false); [EOL]                 break; [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("Unterminated format element at position " + start); [EOL] } 
 [LINE] final int start = pos.getIndex(); [LINE] private String parseFormatDescription(final String pattern, final ParsePosition pos) { [EOL]     final int start = pos.getIndex(); [EOL]     seekNonWs(pattern, pos); [EOL]     final int text = pos.getIndex(); [EOL]     int depth = 1; [EOL]     for (; pos.getIndex() < pattern.length(); next(pos)) { [EOL]         switch(pattern.charAt(pos.getIndex())) { [EOL]             case START_FE: [EOL]                 depth++; [EOL]                 break; [EOL]             case END_FE: [EOL]                 depth--; [EOL]                 if (depth == 0) { [EOL]                     return pattern.substring(text, pos.getIndex()); [EOL]                 } [EOL]                 break; [EOL]             case QUOTE: [EOL]                 getQuotedString(pattern, pos, false); [EOL]                 break; [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("Unterminated format element at position " + start); [EOL] } 
 [LINE] seekNonWs(pattern, pos); [LINE] private String parseFormatDescription(final String pattern, final ParsePosition pos) { [EOL]     final int start = pos.getIndex(); [EOL]     seekNonWs(pattern, pos); [EOL]     final int text = pos.getIndex(); [EOL]     int depth = 1; [EOL]     for (; pos.getIndex() < pattern.length(); next(pos)) { [EOL]         switch(pattern.charAt(pos.getIndex())) { [EOL]             case START_FE: [EOL]                 depth++; [EOL]                 break; [EOL]             case END_FE: [EOL]                 depth--; [EOL]                 if (depth == 0) { [EOL]                     return pattern.substring(text, pos.getIndex()); [EOL]                 } [EOL]                 break; [EOL]             case QUOTE: [EOL]                 getQuotedString(pattern, pos, false); [EOL]                 break; [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("Unterminated format element at position " + start); [EOL] } 
 [LINE] final int text = pos.getIndex(); [LINE] private String parseFormatDescription(final String pattern, final ParsePosition pos) { [EOL]     final int start = pos.getIndex(); [EOL]     seekNonWs(pattern, pos); [EOL]     final int text = pos.getIndex(); [EOL]     int depth = 1; [EOL]     for (; pos.getIndex() < pattern.length(); next(pos)) { [EOL]         switch(pattern.charAt(pos.getIndex())) { [EOL]             case START_FE: [EOL]                 depth++; [EOL]                 break; [EOL]             case END_FE: [EOL]                 depth--; [EOL]                 if (depth == 0) { [EOL]                     return pattern.substring(text, pos.getIndex()); [EOL]                 } [EOL]                 break; [EOL]             case QUOTE: [EOL]                 getQuotedString(pattern, pos, false); [EOL]                 break; [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("Unterminated format element at position " + start); [EOL] } 
 [LINE] int depth = 1; [LINE] private String parseFormatDescription(final String pattern, final ParsePosition pos) { [EOL]     final int start = pos.getIndex(); [EOL]     seekNonWs(pattern, pos); [EOL]     final int text = pos.getIndex(); [EOL]     int depth = 1; [EOL]     for (; pos.getIndex() < pattern.length(); next(pos)) { [EOL]         switch(pattern.charAt(pos.getIndex())) { [EOL]             case START_FE: [EOL]                 depth++; [EOL]                 break; [EOL]             case END_FE: [EOL]                 depth--; [EOL]                 if (depth == 0) { [EOL]                     return pattern.substring(text, pos.getIndex()); [EOL]                 } [EOL]                 break; [EOL]             case QUOTE: [EOL]                 getQuotedString(pattern, pos, false); [EOL]                 break; [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("Unterminated format element at position " + start); [EOL] } 
 [LINE] for (; pos.getIndex() < pattern.length(); next(pos)) { [LINE] private String parseFormatDescription(final String pattern, final ParsePosition pos) { [EOL]     final int start = pos.getIndex(); [EOL]     seekNonWs(pattern, pos); [EOL]     final int text = pos.getIndex(); [EOL]     int depth = 1; [EOL]     for (; pos.getIndex() < pattern.length(); next(pos)) { [EOL]         switch(pattern.charAt(pos.getIndex())) { [EOL]             case START_FE: [EOL]                 depth++; [EOL]                 break; [EOL]             case END_FE: [EOL]                 depth--; [EOL]                 if (depth == 0) { [EOL]                     return pattern.substring(text, pos.getIndex()); [EOL]                 } [EOL]                 break; [EOL]             case QUOTE: [EOL]                 getQuotedString(pattern, pos, false); [EOL]                 break; [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("Unterminated format element at position " + start); [EOL] } 
 [LINE] switch (pattern.charAt(pos.getIndex())) { [LINE] private String parseFormatDescription(final String pattern, final ParsePosition pos) { [EOL]     final int start = pos.getIndex(); [EOL]     seekNonWs(pattern, pos); [EOL]     final int text = pos.getIndex(); [EOL]     int depth = 1; [EOL]     for (; pos.getIndex() < pattern.length(); next(pos)) { [EOL]         switch(pattern.charAt(pos.getIndex())) { [EOL]             case START_FE: [EOL]                 depth++; [EOL]                 break; [EOL]             case END_FE: [EOL]                 depth--; [EOL]                 if (depth == 0) { [EOL]                     return pattern.substring(text, pos.getIndex()); [EOL]                 } [EOL]                 break; [EOL]             case QUOTE: [EOL]                 getQuotedString(pattern, pos, false); [EOL]                 break; [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("Unterminated format element at position " + start); [EOL] } 
 [LINE] case END_FE: [LINE] private String parseFormatDescription(final String pattern, final ParsePosition pos) { [EOL]     final int start = pos.getIndex(); [EOL]     seekNonWs(pattern, pos); [EOL]     final int text = pos.getIndex(); [EOL]     int depth = 1; [EOL]     for (; pos.getIndex() < pattern.length(); next(pos)) { [EOL]         switch(pattern.charAt(pos.getIndex())) { [EOL]             case START_FE: [EOL]                 depth++; [EOL]                 break; [EOL]             case END_FE: [EOL]                 depth--; [EOL]                 if (depth == 0) { [EOL]                     return pattern.substring(text, pos.getIndex()); [EOL]                 } [EOL]                 break; [EOL]             case QUOTE: [EOL]                 getQuotedString(pattern, pos, false); [EOL]                 break; [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("Unterminated format element at position " + start); [EOL] } 
 [LINE] depth--; [LINE] private String parseFormatDescription(final String pattern, final ParsePosition pos) { [EOL]     final int start = pos.getIndex(); [EOL]     seekNonWs(pattern, pos); [EOL]     final int text = pos.getIndex(); [EOL]     int depth = 1; [EOL]     for (; pos.getIndex() < pattern.length(); next(pos)) { [EOL]         switch(pattern.charAt(pos.getIndex())) { [EOL]             case START_FE: [EOL]                 depth++; [EOL]                 break; [EOL]             case END_FE: [EOL]                 depth--; [EOL]                 if (depth == 0) { [EOL]                     return pattern.substring(text, pos.getIndex()); [EOL]                 } [EOL]                 break; [EOL]             case QUOTE: [EOL]                 getQuotedString(pattern, pos, false); [EOL]                 break; [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("Unterminated format element at position " + start); [EOL] } 
 [LINE] if (depth == 0) { [LINE] private String parseFormatDescription(final String pattern, final ParsePosition pos) { [EOL]     final int start = pos.getIndex(); [EOL]     seekNonWs(pattern, pos); [EOL]     final int text = pos.getIndex(); [EOL]     int depth = 1; [EOL]     for (; pos.getIndex() < pattern.length(); next(pos)) { [EOL]         switch(pattern.charAt(pos.getIndex())) { [EOL]             case START_FE: [EOL]                 depth++; [EOL]                 break; [EOL]             case END_FE: [EOL]                 depth--; [EOL]                 if (depth == 0) { [EOL]                     return pattern.substring(text, pos.getIndex()); [EOL]                 } [EOL]                 break; [EOL]             case QUOTE: [EOL]                 getQuotedString(pattern, pos, false); [EOL]                 break; [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("Unterminated format element at position " + start); [EOL] } 
 [LINE] return pattern.substring(text, pos.getIndex()); [LINE] private String parseFormatDescription(final String pattern, final ParsePosition pos) { [EOL]     final int start = pos.getIndex(); [EOL]     seekNonWs(pattern, pos); [EOL]     final int text = pos.getIndex(); [EOL]     int depth = 1; [EOL]     for (; pos.getIndex() < pattern.length(); next(pos)) { [EOL]         switch(pattern.charAt(pos.getIndex())) { [EOL]             case START_FE: [EOL]                 depth++; [EOL]                 break; [EOL]             case END_FE: [EOL]                 depth--; [EOL]                 if (depth == 0) { [EOL]                     return pattern.substring(text, pos.getIndex()); [EOL]                 } [EOL]                 break; [EOL]             case QUOTE: [EOL]                 getQuotedString(pattern, pos, false); [EOL]                 break; [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("Unterminated format element at position " + start); [EOL] } 
 [LINE] final StringBuilder sb = new StringBuilder(pattern.length() * 2); [LINE] private String insertFormats(final String pattern, final ArrayList<String> customPatterns) { [EOL]     if (!containsElements(customPatterns)) { [EOL]         return pattern; [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(pattern.length() * 2); [EOL]     final ParsePosition pos = new ParsePosition(0); [EOL]     int fe = -1; [EOL]     int depth = 0; [EOL]     while (pos.getIndex() < pattern.length()) { [EOL]         final char c = pattern.charAt(pos.getIndex()); [EOL]         switch(c) { [EOL]             case QUOTE: [EOL]                 appendQuotedString(pattern, pos, sb, false); [EOL]                 break; [EOL]             case START_FE: [EOL]                 depth++; [EOL]                 if (depth == 1) { [EOL]                     fe++; [EOL]                     sb.append(START_FE).append(readArgumentIndex(pattern, next(pos))); [EOL]                     final String customPattern = customPatterns.get(fe); [EOL]                     if (customPattern != null) { [EOL]                         sb.append(START_FMT).append(customPattern); [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             case END_FE: [EOL]                 depth--; [EOL]             default: [EOL]                 sb.append(c); [EOL]                 next(pos); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] } 
 [LINE] final ParsePosition pos = new ParsePosition(0); [LINE] private String insertFormats(final String pattern, final ArrayList<String> customPatterns) { [EOL]     if (!containsElements(customPatterns)) { [EOL]         return pattern; [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(pattern.length() * 2); [EOL]     final ParsePosition pos = new ParsePosition(0); [EOL]     int fe = -1; [EOL]     int depth = 0; [EOL]     while (pos.getIndex() < pattern.length()) { [EOL]         final char c = pattern.charAt(pos.getIndex()); [EOL]         switch(c) { [EOL]             case QUOTE: [EOL]                 appendQuotedString(pattern, pos, sb, false); [EOL]                 break; [EOL]             case START_FE: [EOL]                 depth++; [EOL]                 if (depth == 1) { [EOL]                     fe++; [EOL]                     sb.append(START_FE).append(readArgumentIndex(pattern, next(pos))); [EOL]                     final String customPattern = customPatterns.get(fe); [EOL]                     if (customPattern != null) { [EOL]                         sb.append(START_FMT).append(customPattern); [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             case END_FE: [EOL]                 depth--; [EOL]             default: [EOL]                 sb.append(c); [EOL]                 next(pos); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] } 
 [LINE] int fe = -1; [LINE] private String insertFormats(final String pattern, final ArrayList<String> customPatterns) { [EOL]     if (!containsElements(customPatterns)) { [EOL]         return pattern; [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(pattern.length() * 2); [EOL]     final ParsePosition pos = new ParsePosition(0); [EOL]     int fe = -1; [EOL]     int depth = 0; [EOL]     while (pos.getIndex() < pattern.length()) { [EOL]         final char c = pattern.charAt(pos.getIndex()); [EOL]         switch(c) { [EOL]             case QUOTE: [EOL]                 appendQuotedString(pattern, pos, sb, false); [EOL]                 break; [EOL]             case START_FE: [EOL]                 depth++; [EOL]                 if (depth == 1) { [EOL]                     fe++; [EOL]                     sb.append(START_FE).append(readArgumentIndex(pattern, next(pos))); [EOL]                     final String customPattern = customPatterns.get(fe); [EOL]                     if (customPattern != null) { [EOL]                         sb.append(START_FMT).append(customPattern); [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             case END_FE: [EOL]                 depth--; [EOL]             default: [EOL]                 sb.append(c); [EOL]                 next(pos); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] } 
 [LINE] int depth = 0; [LINE] private String insertFormats(final String pattern, final ArrayList<String> customPatterns) { [EOL]     if (!containsElements(customPatterns)) { [EOL]         return pattern; [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(pattern.length() * 2); [EOL]     final ParsePosition pos = new ParsePosition(0); [EOL]     int fe = -1; [EOL]     int depth = 0; [EOL]     while (pos.getIndex() < pattern.length()) { [EOL]         final char c = pattern.charAt(pos.getIndex()); [EOL]         switch(c) { [EOL]             case QUOTE: [EOL]                 appendQuotedString(pattern, pos, sb, false); [EOL]                 break; [EOL]             case START_FE: [EOL]                 depth++; [EOL]                 if (depth == 1) { [EOL]                     fe++; [EOL]                     sb.append(START_FE).append(readArgumentIndex(pattern, next(pos))); [EOL]                     final String customPattern = customPatterns.get(fe); [EOL]                     if (customPattern != null) { [EOL]                         sb.append(START_FMT).append(customPattern); [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             case END_FE: [EOL]                 depth--; [EOL]             default: [EOL]                 sb.append(c); [EOL]                 next(pos); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] } 
 [LINE] while (pos.getIndex() < pattern.length()) { [LINE] private String insertFormats(final String pattern, final ArrayList<String> customPatterns) { [EOL]     if (!containsElements(customPatterns)) { [EOL]         return pattern; [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(pattern.length() * 2); [EOL]     final ParsePosition pos = new ParsePosition(0); [EOL]     int fe = -1; [EOL]     int depth = 0; [EOL]     while (pos.getIndex() < pattern.length()) { [EOL]         final char c = pattern.charAt(pos.getIndex()); [EOL]         switch(c) { [EOL]             case QUOTE: [EOL]                 appendQuotedString(pattern, pos, sb, false); [EOL]                 break; [EOL]             case START_FE: [EOL]                 depth++; [EOL]                 if (depth == 1) { [EOL]                     fe++; [EOL]                     sb.append(START_FE).append(readArgumentIndex(pattern, next(pos))); [EOL]                     final String customPattern = customPatterns.get(fe); [EOL]                     if (customPattern != null) { [EOL]                         sb.append(START_FMT).append(customPattern); [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             case END_FE: [EOL]                 depth--; [EOL]             default: [EOL]                 sb.append(c); [EOL]                 next(pos); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] } 
 [LINE] final char c = pattern.charAt(pos.getIndex()); [LINE] private String insertFormats(final String pattern, final ArrayList<String> customPatterns) { [EOL]     if (!containsElements(customPatterns)) { [EOL]         return pattern; [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(pattern.length() * 2); [EOL]     final ParsePosition pos = new ParsePosition(0); [EOL]     int fe = -1; [EOL]     int depth = 0; [EOL]     while (pos.getIndex() < pattern.length()) { [EOL]         final char c = pattern.charAt(pos.getIndex()); [EOL]         switch(c) { [EOL]             case QUOTE: [EOL]                 appendQuotedString(pattern, pos, sb, false); [EOL]                 break; [EOL]             case START_FE: [EOL]                 depth++; [EOL]                 if (depth == 1) { [EOL]                     fe++; [EOL]                     sb.append(START_FE).append(readArgumentIndex(pattern, next(pos))); [EOL]                     final String customPattern = customPatterns.get(fe); [EOL]                     if (customPattern != null) { [EOL]                         sb.append(START_FMT).append(customPattern); [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             case END_FE: [EOL]                 depth--; [EOL]             default: [EOL]                 sb.append(c); [EOL]                 next(pos); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] } 
 [LINE] switch (c) { [LINE] private String insertFormats(final String pattern, final ArrayList<String> customPatterns) { [EOL]     if (!containsElements(customPatterns)) { [EOL]         return pattern; [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(pattern.length() * 2); [EOL]     final ParsePosition pos = new ParsePosition(0); [EOL]     int fe = -1; [EOL]     int depth = 0; [EOL]     while (pos.getIndex() < pattern.length()) { [EOL]         final char c = pattern.charAt(pos.getIndex()); [EOL]         switch(c) { [EOL]             case QUOTE: [EOL]                 appendQuotedString(pattern, pos, sb, false); [EOL]                 break; [EOL]             case START_FE: [EOL]                 depth++; [EOL]                 if (depth == 1) { [EOL]                     fe++; [EOL]                     sb.append(START_FE).append(readArgumentIndex(pattern, next(pos))); [EOL]                     final String customPattern = customPatterns.get(fe); [EOL]                     if (customPattern != null) { [EOL]                         sb.append(START_FMT).append(customPattern); [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             case END_FE: [EOL]                 depth--; [EOL]             default: [EOL]                 sb.append(c); [EOL]                 next(pos); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] } 
 [LINE] case QUOTE: [LINE] private String insertFormats(final String pattern, final ArrayList<String> customPatterns) { [EOL]     if (!containsElements(customPatterns)) { [EOL]         return pattern; [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(pattern.length() * 2); [EOL]     final ParsePosition pos = new ParsePosition(0); [EOL]     int fe = -1; [EOL]     int depth = 0; [EOL]     while (pos.getIndex() < pattern.length()) { [EOL]         final char c = pattern.charAt(pos.getIndex()); [EOL]         switch(c) { [EOL]             case QUOTE: [EOL]                 appendQuotedString(pattern, pos, sb, false); [EOL]                 break; [EOL]             case START_FE: [EOL]                 depth++; [EOL]                 if (depth == 1) { [EOL]                     fe++; [EOL]                     sb.append(START_FE).append(readArgumentIndex(pattern, next(pos))); [EOL]                     final String customPattern = customPatterns.get(fe); [EOL]                     if (customPattern != null) { [EOL]                         sb.append(START_FMT).append(customPattern); [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             case END_FE: [EOL]                 depth--; [EOL]             default: [EOL]                 sb.append(c); [EOL]                 next(pos); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] } 
 [LINE] appendQuotedString(pattern, pos, sb, false); [LINE] private String insertFormats(final String pattern, final ArrayList<String> customPatterns) { [EOL]     if (!containsElements(customPatterns)) { [EOL]         return pattern; [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(pattern.length() * 2); [EOL]     final ParsePosition pos = new ParsePosition(0); [EOL]     int fe = -1; [EOL]     int depth = 0; [EOL]     while (pos.getIndex() < pattern.length()) { [EOL]         final char c = pattern.charAt(pos.getIndex()); [EOL]         switch(c) { [EOL]             case QUOTE: [EOL]                 appendQuotedString(pattern, pos, sb, false); [EOL]                 break; [EOL]             case START_FE: [EOL]                 depth++; [EOL]                 if (depth == 1) { [EOL]                     fe++; [EOL]                     sb.append(START_FE).append(readArgumentIndex(pattern, next(pos))); [EOL]                     final String customPattern = customPatterns.get(fe); [EOL]                     if (customPattern != null) { [EOL]                         sb.append(START_FMT).append(customPattern); [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             case END_FE: [EOL]                 depth--; [EOL]             default: [EOL]                 sb.append(c); [EOL]                 next(pos); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] } 
 [LINE] break; [LINE] private String insertFormats(final String pattern, final ArrayList<String> customPatterns) { [EOL]     if (!containsElements(customPatterns)) { [EOL]         return pattern; [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(pattern.length() * 2); [EOL]     final ParsePosition pos = new ParsePosition(0); [EOL]     int fe = -1; [EOL]     int depth = 0; [EOL]     while (pos.getIndex() < pattern.length()) { [EOL]         final char c = pattern.charAt(pos.getIndex()); [EOL]         switch(c) { [EOL]             case QUOTE: [EOL]                 appendQuotedString(pattern, pos, sb, false); [EOL]                 break; [EOL]             case START_FE: [EOL]                 depth++; [EOL]                 if (depth == 1) { [EOL]                     fe++; [EOL]                     sb.append(START_FE).append(readArgumentIndex(pattern, next(pos))); [EOL]                     final String customPattern = customPatterns.get(fe); [EOL]                     if (customPattern != null) { [EOL]                         sb.append(START_FMT).append(customPattern); [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             case END_FE: [EOL]                 depth--; [EOL]             default: [EOL]                 sb.append(c); [EOL]                 next(pos); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] } 
 [LINE] case START_FE: [LINE] private String insertFormats(final String pattern, final ArrayList<String> customPatterns) { [EOL]     if (!containsElements(customPatterns)) { [EOL]         return pattern; [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(pattern.length() * 2); [EOL]     final ParsePosition pos = new ParsePosition(0); [EOL]     int fe = -1; [EOL]     int depth = 0; [EOL]     while (pos.getIndex() < pattern.length()) { [EOL]         final char c = pattern.charAt(pos.getIndex()); [EOL]         switch(c) { [EOL]             case QUOTE: [EOL]                 appendQuotedString(pattern, pos, sb, false); [EOL]                 break; [EOL]             case START_FE: [EOL]                 depth++; [EOL]                 if (depth == 1) { [EOL]                     fe++; [EOL]                     sb.append(START_FE).append(readArgumentIndex(pattern, next(pos))); [EOL]                     final String customPattern = customPatterns.get(fe); [EOL]                     if (customPattern != null) { [EOL]                         sb.append(START_FMT).append(customPattern); [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             case END_FE: [EOL]                 depth--; [EOL]             default: [EOL]                 sb.append(c); [EOL]                 next(pos); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] } 
 [LINE] depth++; [LINE] private String insertFormats(final String pattern, final ArrayList<String> customPatterns) { [EOL]     if (!containsElements(customPatterns)) { [EOL]         return pattern; [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(pattern.length() * 2); [EOL]     final ParsePosition pos = new ParsePosition(0); [EOL]     int fe = -1; [EOL]     int depth = 0; [EOL]     while (pos.getIndex() < pattern.length()) { [EOL]         final char c = pattern.charAt(pos.getIndex()); [EOL]         switch(c) { [EOL]             case QUOTE: [EOL]                 appendQuotedString(pattern, pos, sb, false); [EOL]                 break; [EOL]             case START_FE: [EOL]                 depth++; [EOL]                 if (depth == 1) { [EOL]                     fe++; [EOL]                     sb.append(START_FE).append(readArgumentIndex(pattern, next(pos))); [EOL]                     final String customPattern = customPatterns.get(fe); [EOL]                     if (customPattern != null) { [EOL]                         sb.append(START_FMT).append(customPattern); [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             case END_FE: [EOL]                 depth--; [EOL]             default: [EOL]                 sb.append(c); [EOL]                 next(pos); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] } 
 [LINE] if (depth == 1) { [LINE] private String insertFormats(final String pattern, final ArrayList<String> customPatterns) { [EOL]     if (!containsElements(customPatterns)) { [EOL]         return pattern; [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(pattern.length() * 2); [EOL]     final ParsePosition pos = new ParsePosition(0); [EOL]     int fe = -1; [EOL]     int depth = 0; [EOL]     while (pos.getIndex() < pattern.length()) { [EOL]         final char c = pattern.charAt(pos.getIndex()); [EOL]         switch(c) { [EOL]             case QUOTE: [EOL]                 appendQuotedString(pattern, pos, sb, false); [EOL]                 break; [EOL]             case START_FE: [EOL]                 depth++; [EOL]                 if (depth == 1) { [EOL]                     fe++; [EOL]                     sb.append(START_FE).append(readArgumentIndex(pattern, next(pos))); [EOL]                     final String customPattern = customPatterns.get(fe); [EOL]                     if (customPattern != null) { [EOL]                         sb.append(START_FMT).append(customPattern); [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             case END_FE: [EOL]                 depth--; [EOL]             default: [EOL]                 sb.append(c); [EOL]                 next(pos); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] } 
 [LINE] fe++; [LINE] private String insertFormats(final String pattern, final ArrayList<String> customPatterns) { [EOL]     if (!containsElements(customPatterns)) { [EOL]         return pattern; [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(pattern.length() * 2); [EOL]     final ParsePosition pos = new ParsePosition(0); [EOL]     int fe = -1; [EOL]     int depth = 0; [EOL]     while (pos.getIndex() < pattern.length()) { [EOL]         final char c = pattern.charAt(pos.getIndex()); [EOL]         switch(c) { [EOL]             case QUOTE: [EOL]                 appendQuotedString(pattern, pos, sb, false); [EOL]                 break; [EOL]             case START_FE: [EOL]                 depth++; [EOL]                 if (depth == 1) { [EOL]                     fe++; [EOL]                     sb.append(START_FE).append(readArgumentIndex(pattern, next(pos))); [EOL]                     final String customPattern = customPatterns.get(fe); [EOL]                     if (customPattern != null) { [EOL]                         sb.append(START_FMT).append(customPattern); [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             case END_FE: [EOL]                 depth--; [EOL]             default: [EOL]                 sb.append(c); [EOL]                 next(pos); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] } 
 [LINE] sb.append(START_FE).append( [LINE] private String insertFormats(final String pattern, final ArrayList<String> customPatterns) { [EOL]     if (!containsElements(customPatterns)) { [EOL]         return pattern; [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(pattern.length() * 2); [EOL]     final ParsePosition pos = new ParsePosition(0); [EOL]     int fe = -1; [EOL]     int depth = 0; [EOL]     while (pos.getIndex() < pattern.length()) { [EOL]         final char c = pattern.charAt(pos.getIndex()); [EOL]         switch(c) { [EOL]             case QUOTE: [EOL]                 appendQuotedString(pattern, pos, sb, false); [EOL]                 break; [EOL]             case START_FE: [EOL]                 depth++; [EOL]                 if (depth == 1) { [EOL]                     fe++; [EOL]                     sb.append(START_FE).append(readArgumentIndex(pattern, next(pos))); [EOL]                     final String customPattern = customPatterns.get(fe); [EOL]                     if (customPattern != null) { [EOL]                         sb.append(START_FMT).append(customPattern); [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             case END_FE: [EOL]                 depth--; [EOL]             default: [EOL]                 sb.append(c); [EOL]                 next(pos); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] } 
 [LINE] final String customPattern = customPatterns.get(fe); [LINE] private String insertFormats(final String pattern, final ArrayList<String> customPatterns) { [EOL]     if (!containsElements(customPatterns)) { [EOL]         return pattern; [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(pattern.length() * 2); [EOL]     final ParsePosition pos = new ParsePosition(0); [EOL]     int fe = -1; [EOL]     int depth = 0; [EOL]     while (pos.getIndex() < pattern.length()) { [EOL]         final char c = pattern.charAt(pos.getIndex()); [EOL]         switch(c) { [EOL]             case QUOTE: [EOL]                 appendQuotedString(pattern, pos, sb, false); [EOL]                 break; [EOL]             case START_FE: [EOL]                 depth++; [EOL]                 if (depth == 1) { [EOL]                     fe++; [EOL]                     sb.append(START_FE).append(readArgumentIndex(pattern, next(pos))); [EOL]                     final String customPattern = customPatterns.get(fe); [EOL]                     if (customPattern != null) { [EOL]                         sb.append(START_FMT).append(customPattern); [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             case END_FE: [EOL]                 depth--; [EOL]             default: [EOL]                 sb.append(c); [EOL]                 next(pos); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] } 
 [LINE] if (customPattern != null) { [LINE] private String insertFormats(final String pattern, final ArrayList<String> customPatterns) { [EOL]     if (!containsElements(customPatterns)) { [EOL]         return pattern; [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(pattern.length() * 2); [EOL]     final ParsePosition pos = new ParsePosition(0); [EOL]     int fe = -1; [EOL]     int depth = 0; [EOL]     while (pos.getIndex() < pattern.length()) { [EOL]         final char c = pattern.charAt(pos.getIndex()); [EOL]         switch(c) { [EOL]             case QUOTE: [EOL]                 appendQuotedString(pattern, pos, sb, false); [EOL]                 break; [EOL]             case START_FE: [EOL]                 depth++; [EOL]                 if (depth == 1) { [EOL]                     fe++; [EOL]                     sb.append(START_FE).append(readArgumentIndex(pattern, next(pos))); [EOL]                     final String customPattern = customPatterns.get(fe); [EOL]                     if (customPattern != null) { [EOL]                         sb.append(START_FMT).append(customPattern); [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             case END_FE: [EOL]                 depth--; [EOL]             default: [EOL]                 sb.append(c); [EOL]                 next(pos); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] } 
 [LINE] sb.append(START_FMT).append(customPattern); [LINE] private String insertFormats(final String pattern, final ArrayList<String> customPatterns) { [EOL]     if (!containsElements(customPatterns)) { [EOL]         return pattern; [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(pattern.length() * 2); [EOL]     final ParsePosition pos = new ParsePosition(0); [EOL]     int fe = -1; [EOL]     int depth = 0; [EOL]     while (pos.getIndex() < pattern.length()) { [EOL]         final char c = pattern.charAt(pos.getIndex()); [EOL]         switch(c) { [EOL]             case QUOTE: [EOL]                 appendQuotedString(pattern, pos, sb, false); [EOL]                 break; [EOL]             case START_FE: [EOL]                 depth++; [EOL]                 if (depth == 1) { [EOL]                     fe++; [EOL]                     sb.append(START_FE).append(readArgumentIndex(pattern, next(pos))); [EOL]                     final String customPattern = customPatterns.get(fe); [EOL]                     if (customPattern != null) { [EOL]                         sb.append(START_FMT).append(customPattern); [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             case END_FE: [EOL]                 depth--; [EOL]             default: [EOL]                 sb.append(c); [EOL]                 next(pos); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] } 
 [LINE] break; [LINE] private String insertFormats(final String pattern, final ArrayList<String> customPatterns) { [EOL]     if (!containsElements(customPatterns)) { [EOL]         return pattern; [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(pattern.length() * 2); [EOL]     final ParsePosition pos = new ParsePosition(0); [EOL]     int fe = -1; [EOL]     int depth = 0; [EOL]     while (pos.getIndex() < pattern.length()) { [EOL]         final char c = pattern.charAt(pos.getIndex()); [EOL]         switch(c) { [EOL]             case QUOTE: [EOL]                 appendQuotedString(pattern, pos, sb, false); [EOL]                 break; [EOL]             case START_FE: [EOL]                 depth++; [EOL]                 if (depth == 1) { [EOL]                     fe++; [EOL]                     sb.append(START_FE).append(readArgumentIndex(pattern, next(pos))); [EOL]                     final String customPattern = customPatterns.get(fe); [EOL]                     if (customPattern != null) { [EOL]                         sb.append(START_FMT).append(customPattern); [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             case END_FE: [EOL]                 depth--; [EOL]             default: [EOL]                 sb.append(c); [EOL]                 next(pos); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] } 
 [LINE] case END_FE: [LINE] private String insertFormats(final String pattern, final ArrayList<String> customPatterns) { [EOL]     if (!containsElements(customPatterns)) { [EOL]         return pattern; [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(pattern.length() * 2); [EOL]     final ParsePosition pos = new ParsePosition(0); [EOL]     int fe = -1; [EOL]     int depth = 0; [EOL]     while (pos.getIndex() < pattern.length()) { [EOL]         final char c = pattern.charAt(pos.getIndex()); [EOL]         switch(c) { [EOL]             case QUOTE: [EOL]                 appendQuotedString(pattern, pos, sb, false); [EOL]                 break; [EOL]             case START_FE: [EOL]                 depth++; [EOL]                 if (depth == 1) { [EOL]                     fe++; [EOL]                     sb.append(START_FE).append(readArgumentIndex(pattern, next(pos))); [EOL]                     final String customPattern = customPatterns.get(fe); [EOL]                     if (customPattern != null) { [EOL]                         sb.append(START_FMT).append(customPattern); [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             case END_FE: [EOL]                 depth--; [EOL]             default: [EOL]                 sb.append(c); [EOL]                 next(pos); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] } 
 [LINE] depth--; [LINE] private String insertFormats(final String pattern, final ArrayList<String> customPatterns) { [EOL]     if (!containsElements(customPatterns)) { [EOL]         return pattern; [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(pattern.length() * 2); [EOL]     final ParsePosition pos = new ParsePosition(0); [EOL]     int fe = -1; [EOL]     int depth = 0; [EOL]     while (pos.getIndex() < pattern.length()) { [EOL]         final char c = pattern.charAt(pos.getIndex()); [EOL]         switch(c) { [EOL]             case QUOTE: [EOL]                 appendQuotedString(pattern, pos, sb, false); [EOL]                 break; [EOL]             case START_FE: [EOL]                 depth++; [EOL]                 if (depth == 1) { [EOL]                     fe++; [EOL]                     sb.append(START_FE).append(readArgumentIndex(pattern, next(pos))); [EOL]                     final String customPattern = customPatterns.get(fe); [EOL]                     if (customPattern != null) { [EOL]                         sb.append(START_FMT).append(customPattern); [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             case END_FE: [EOL]                 depth--; [EOL]             default: [EOL]                 sb.append(c); [EOL]                 next(pos); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] } 
 [LINE] default: [LINE] private String insertFormats(final String pattern, final ArrayList<String> customPatterns) { [EOL]     if (!containsElements(customPatterns)) { [EOL]         return pattern; [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(pattern.length() * 2); [EOL]     final ParsePosition pos = new ParsePosition(0); [EOL]     int fe = -1; [EOL]     int depth = 0; [EOL]     while (pos.getIndex() < pattern.length()) { [EOL]         final char c = pattern.charAt(pos.getIndex()); [EOL]         switch(c) { [EOL]             case QUOTE: [EOL]                 appendQuotedString(pattern, pos, sb, false); [EOL]                 break; [EOL]             case START_FE: [EOL]                 depth++; [EOL]                 if (depth == 1) { [EOL]                     fe++; [EOL]                     sb.append(START_FE).append(readArgumentIndex(pattern, next(pos))); [EOL]                     final String customPattern = customPatterns.get(fe); [EOL]                     if (customPattern != null) { [EOL]                         sb.append(START_FMT).append(customPattern); [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             case END_FE: [EOL]                 depth--; [EOL]             default: [EOL]                 sb.append(c); [EOL]                 next(pos); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] } 
 [LINE] sb.append(c); [LINE] private String insertFormats(final String pattern, final ArrayList<String> customPatterns) { [EOL]     if (!containsElements(customPatterns)) { [EOL]         return pattern; [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(pattern.length() * 2); [EOL]     final ParsePosition pos = new ParsePosition(0); [EOL]     int fe = -1; [EOL]     int depth = 0; [EOL]     while (pos.getIndex() < pattern.length()) { [EOL]         final char c = pattern.charAt(pos.getIndex()); [EOL]         switch(c) { [EOL]             case QUOTE: [EOL]                 appendQuotedString(pattern, pos, sb, false); [EOL]                 break; [EOL]             case START_FE: [EOL]                 depth++; [EOL]                 if (depth == 1) { [EOL]                     fe++; [EOL]                     sb.append(START_FE).append(readArgumentIndex(pattern, next(pos))); [EOL]                     final String customPattern = customPatterns.get(fe); [EOL]                     if (customPattern != null) { [EOL]                         sb.append(START_FMT).append(customPattern); [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             case END_FE: [EOL]                 depth--; [EOL]             default: [EOL]                 sb.append(c); [EOL]                 next(pos); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] } 
 [LINE] next(pos); [LINE] private String insertFormats(final String pattern, final ArrayList<String> customPatterns) { [EOL]     if (!containsElements(customPatterns)) { [EOL]         return pattern; [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(pattern.length() * 2); [EOL]     final ParsePosition pos = new ParsePosition(0); [EOL]     int fe = -1; [EOL]     int depth = 0; [EOL]     while (pos.getIndex() < pattern.length()) { [EOL]         final char c = pattern.charAt(pos.getIndex()); [EOL]         switch(c) { [EOL]             case QUOTE: [EOL]                 appendQuotedString(pattern, pos, sb, false); [EOL]                 break; [EOL]             case START_FE: [EOL]                 depth++; [EOL]                 if (depth == 1) { [EOL]                     fe++; [EOL]                     sb.append(START_FE).append(readArgumentIndex(pattern, next(pos))); [EOL]                     final String customPattern = customPatterns.get(fe); [EOL]                     if (customPattern != null) { [EOL]                         sb.append(START_FMT).append(customPattern); [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             case END_FE: [EOL]                 depth--; [EOL]             default: [EOL]                 sb.append(c); [EOL]                 next(pos); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] } 
 [LINE] return sb.toString(); [LINE] private String insertFormats(final String pattern, final ArrayList<String> customPatterns) { [EOL]     if (!containsElements(customPatterns)) { [EOL]         return pattern; [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(pattern.length() * 2); [EOL]     final ParsePosition pos = new ParsePosition(0); [EOL]     int fe = -1; [EOL]     int depth = 0; [EOL]     while (pos.getIndex() < pattern.length()) { [EOL]         final char c = pattern.charAt(pos.getIndex()); [EOL]         switch(c) { [EOL]             case QUOTE: [EOL]                 appendQuotedString(pattern, pos, sb, false); [EOL]                 break; [EOL]             case START_FE: [EOL]                 depth++; [EOL]                 if (depth == 1) { [EOL]                     fe++; [EOL]                     sb.append(START_FE).append(readArgumentIndex(pattern, next(pos))); [EOL]                     final String customPattern = customPatterns.get(fe); [EOL]                     if (customPattern != null) { [EOL]                         sb.append(START_FMT).append(customPattern); [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             case END_FE: [EOL]                 depth--; [EOL]             default: [EOL]                 sb.append(c); [EOL]                 next(pos); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] } 
 [LINE] int lastHold = start; [LINE] private StringBuilder appendQuotedString(final String pattern, final ParsePosition pos, final StringBuilder appendTo, final boolean escapingOn) { [EOL]     final int start = pos.getIndex(); [EOL]     final char[] c = pattern.toCharArray(); [EOL]     if (escapingOn && c[start] == QUOTE) { [EOL]         next(pos); [EOL]         return appendTo == null ? null : appendTo.append(QUOTE); [EOL]     } [EOL]     int lastHold = start; [EOL]     for (int i = pos.getIndex(); i < pattern.length(); i++) { [EOL]         if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) { [EOL]             appendTo.append(c, lastHold, pos.getIndex() - lastHold).append(QUOTE); [EOL]             pos.setIndex(i + ESCAPED_QUOTE.length()); [EOL]             lastHold = pos.getIndex(); [EOL]             continue; [EOL]         } [EOL]         switch(c[pos.getIndex()]) { [EOL]             case QUOTE: [EOL]                 next(pos); [EOL]                 return appendTo == null ? null : appendTo.append(c, lastHold, pos.getIndex() - lastHold); [EOL]             default: [EOL]                 next(pos); [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("Unterminated quoted string at position " + start); [EOL] } 
 [LINE] for (int i = pos.getIndex(); i < pattern.length(); i++) { [LINE] private StringBuilder appendQuotedString(final String pattern, final ParsePosition pos, final StringBuilder appendTo, final boolean escapingOn) { [EOL]     final int start = pos.getIndex(); [EOL]     final char[] c = pattern.toCharArray(); [EOL]     if (escapingOn && c[start] == QUOTE) { [EOL]         next(pos); [EOL]         return appendTo == null ? null : appendTo.append(QUOTE); [EOL]     } [EOL]     int lastHold = start; [EOL]     for (int i = pos.getIndex(); i < pattern.length(); i++) { [EOL]         if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) { [EOL]             appendTo.append(c, lastHold, pos.getIndex() - lastHold).append(QUOTE); [EOL]             pos.setIndex(i + ESCAPED_QUOTE.length()); [EOL]             lastHold = pos.getIndex(); [EOL]             continue; [EOL]         } [EOL]         switch(c[pos.getIndex()]) { [EOL]             case QUOTE: [EOL]                 next(pos); [EOL]                 return appendTo == null ? null : appendTo.append(c, lastHold, pos.getIndex() - lastHold); [EOL]             default: [EOL]                 next(pos); [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("Unterminated quoted string at position " + start); [EOL] } 
 [LINE] if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) { [LINE] private StringBuilder appendQuotedString(final String pattern, final ParsePosition pos, final StringBuilder appendTo, final boolean escapingOn) { [EOL]     final int start = pos.getIndex(); [EOL]     final char[] c = pattern.toCharArray(); [EOL]     if (escapingOn && c[start] == QUOTE) { [EOL]         next(pos); [EOL]         return appendTo == null ? null : appendTo.append(QUOTE); [EOL]     } [EOL]     int lastHold = start; [EOL]     for (int i = pos.getIndex(); i < pattern.length(); i++) { [EOL]         if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) { [EOL]             appendTo.append(c, lastHold, pos.getIndex() - lastHold).append(QUOTE); [EOL]             pos.setIndex(i + ESCAPED_QUOTE.length()); [EOL]             lastHold = pos.getIndex(); [EOL]             continue; [EOL]         } [EOL]         switch(c[pos.getIndex()]) { [EOL]             case QUOTE: [EOL]                 next(pos); [EOL]                 return appendTo == null ? null : appendTo.append(c, lastHold, pos.getIndex() - lastHold); [EOL]             default: [EOL]                 next(pos); [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("Unterminated quoted string at position " + start); [EOL] } 
 [LINE] switch (c[pos.getIndex()]) { [LINE] private StringBuilder appendQuotedString(final String pattern, final ParsePosition pos, final StringBuilder appendTo, final boolean escapingOn) { [EOL]     final int start = pos.getIndex(); [EOL]     final char[] c = pattern.toCharArray(); [EOL]     if (escapingOn && c[start] == QUOTE) { [EOL]         next(pos); [EOL]         return appendTo == null ? null : appendTo.append(QUOTE); [EOL]     } [EOL]     int lastHold = start; [EOL]     for (int i = pos.getIndex(); i < pattern.length(); i++) { [EOL]         if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) { [EOL]             appendTo.append(c, lastHold, pos.getIndex() - lastHold).append(QUOTE); [EOL]             pos.setIndex(i + ESCAPED_QUOTE.length()); [EOL]             lastHold = pos.getIndex(); [EOL]             continue; [EOL]         } [EOL]         switch(c[pos.getIndex()]) { [EOL]             case QUOTE: [EOL]                 next(pos); [EOL]                 return appendTo == null ? null : appendTo.append(c, lastHold, pos.getIndex() - lastHold); [EOL]             default: [EOL]                 next(pos); [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("Unterminated quoted string at position " + start); [EOL] } 
 [LINE] case QUOTE: [LINE] private StringBuilder appendQuotedString(final String pattern, final ParsePosition pos, final StringBuilder appendTo, final boolean escapingOn) { [EOL]     final int start = pos.getIndex(); [EOL]     final char[] c = pattern.toCharArray(); [EOL]     if (escapingOn && c[start] == QUOTE) { [EOL]         next(pos); [EOL]         return appendTo == null ? null : appendTo.append(QUOTE); [EOL]     } [EOL]     int lastHold = start; [EOL]     for (int i = pos.getIndex(); i < pattern.length(); i++) { [EOL]         if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) { [EOL]             appendTo.append(c, lastHold, pos.getIndex() - lastHold).append(QUOTE); [EOL]             pos.setIndex(i + ESCAPED_QUOTE.length()); [EOL]             lastHold = pos.getIndex(); [EOL]             continue; [EOL]         } [EOL]         switch(c[pos.getIndex()]) { [EOL]             case QUOTE: [EOL]                 next(pos); [EOL]                 return appendTo == null ? null : appendTo.append(c, lastHold, pos.getIndex() - lastHold); [EOL]             default: [EOL]                 next(pos); [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("Unterminated quoted string at position " + start); [EOL] } 
 [LINE] next(pos); [LINE] private StringBuilder appendQuotedString(final String pattern, final ParsePosition pos, final StringBuilder appendTo, final boolean escapingOn) { [EOL]     final int start = pos.getIndex(); [EOL]     final char[] c = pattern.toCharArray(); [EOL]     if (escapingOn && c[start] == QUOTE) { [EOL]         next(pos); [EOL]         return appendTo == null ? null : appendTo.append(QUOTE); [EOL]     } [EOL]     int lastHold = start; [EOL]     for (int i = pos.getIndex(); i < pattern.length(); i++) { [EOL]         if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) { [EOL]             appendTo.append(c, lastHold, pos.getIndex() - lastHold).append(QUOTE); [EOL]             pos.setIndex(i + ESCAPED_QUOTE.length()); [EOL]             lastHold = pos.getIndex(); [EOL]             continue; [EOL]         } [EOL]         switch(c[pos.getIndex()]) { [EOL]             case QUOTE: [EOL]                 next(pos); [EOL]                 return appendTo == null ? null : appendTo.append(c, lastHold, pos.getIndex() - lastHold); [EOL]             default: [EOL]                 next(pos); [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("Unterminated quoted string at position " + start); [EOL] } 
 [LINE] return appendTo == null ? null : appendTo.append(c, lastHold, [LINE] private StringBuilder appendQuotedString(final String pattern, final ParsePosition pos, final StringBuilder appendTo, final boolean escapingOn) { [EOL]     final int start = pos.getIndex(); [EOL]     final char[] c = pattern.toCharArray(); [EOL]     if (escapingOn && c[start] == QUOTE) { [EOL]         next(pos); [EOL]         return appendTo == null ? null : appendTo.append(QUOTE); [EOL]     } [EOL]     int lastHold = start; [EOL]     for (int i = pos.getIndex(); i < pattern.length(); i++) { [EOL]         if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) { [EOL]             appendTo.append(c, lastHold, pos.getIndex() - lastHold).append(QUOTE); [EOL]             pos.setIndex(i + ESCAPED_QUOTE.length()); [EOL]             lastHold = pos.getIndex(); [EOL]             continue; [EOL]         } [EOL]         switch(c[pos.getIndex()]) { [EOL]             case QUOTE: [EOL]                 next(pos); [EOL]                 return appendTo == null ? null : appendTo.append(c, lastHold, pos.getIndex() - lastHold); [EOL]             default: [EOL]                 next(pos); [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("Unterminated quoted string at position " + start); [EOL] } 
 [LINE] for (final Object name : coll) { [LINE] private boolean containsElements(final Collection<?> coll) { [EOL]     if (coll == null || coll.isEmpty()) { [EOL]         return false; [EOL]     } [EOL]     for (final Object name : coll) { [EOL]         if (name != null) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } 
 [LINE] if (name != null) { [LINE] private boolean containsElements(final Collection<?> coll) { [EOL]     if (coll == null || coll.isEmpty()) { [EOL]         return false; [EOL]     } [EOL]     for (final Object name : coll) { [EOL]         if (name != null) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } 
 [LINE] return true; [LINE] private boolean containsElements(final Collection<?> coll) { [EOL]     if (coll == null || coll.isEmpty()) { [EOL]         return false; [EOL]     } [EOL]     for (final Object name : coll) { [EOL]         if (name != null) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } 
 [LINE] className = className.substring(1, className.length() - 1); [LINE] public static String getShortClassName(String className) { [EOL]     if (StringUtils.isEmpty(className)) { [EOL]         return StringUtils.EMPTY; [EOL]     } [EOL]     final StringBuilder arrayPrefix = new StringBuilder(); [EOL]     if (className.startsWith("[")) { [EOL]         while (className.charAt(0) == '[') { [EOL]             className = className.substring(1); [EOL]             arrayPrefix.append("[]"); [EOL]         } [EOL]         if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') { [EOL]             className = className.substring(1, className.length() - 1); [EOL]         } [EOL]         if (reverseAbbreviationMap.containsKey(className)) { [EOL]             className = reverseAbbreviationMap.get(className); [EOL]         } [EOL]     } [EOL]     final int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); [EOL]     final int innerIdx = className.indexOf(INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1); [EOL]     String out = className.substring(lastDotIdx + 1); [EOL]     if (innerIdx != -1) { [EOL]         out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); [EOL]     } [EOL]     return out + arrayPrefix; [EOL] } 
 [LINE] className = reverseAbbreviationMap.get(className); [LINE] public static String getShortClassName(String className) { [EOL]     if (StringUtils.isEmpty(className)) { [EOL]         return StringUtils.EMPTY; [EOL]     } [EOL]     final StringBuilder arrayPrefix = new StringBuilder(); [EOL]     if (className.startsWith("[")) { [EOL]         while (className.charAt(0) == '[') { [EOL]             className = className.substring(1); [EOL]             arrayPrefix.append("[]"); [EOL]         } [EOL]         if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') { [EOL]             className = className.substring(1, className.length() - 1); [EOL]         } [EOL]         if (reverseAbbreviationMap.containsKey(className)) { [EOL]             className = reverseAbbreviationMap.get(className); [EOL]         } [EOL]     } [EOL]     final int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); [EOL]     final int innerIdx = className.indexOf(INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1); [EOL]     String out = className.substring(lastDotIdx + 1); [EOL]     if (innerIdx != -1) { [EOL]         out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); [EOL]     } [EOL]     return out + arrayPrefix; [EOL] } 
 [LINE] return StringUtils.EMPTY; [LINE] public static String getSimpleName(final Class<?> cls) { [EOL]     if (cls == null) { [EOL]         return StringUtils.EMPTY; [EOL]     } [EOL]     return cls.getSimpleName(); [EOL] } 
 [LINE] return StringUtils.EMPTY; [LINE] public static String getPackageName(final Class<?> cls) { [EOL]     if (cls == null) { [EOL]         return StringUtils.EMPTY; [EOL]     } [EOL]     return getPackageName(cls.getName()); [EOL] } 
 [LINE] className = className.substring(1); [LINE] public static String getPackageName(String className) { [EOL]     if (StringUtils.isEmpty(className)) { [EOL]         return StringUtils.EMPTY; [EOL]     } [EOL]     while (className.charAt(0) == '[') { [EOL]         className = className.substring(1); [EOL]     } [EOL]     if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') { [EOL]         className = className.substring(1); [EOL]     } [EOL]     final int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); [EOL]     if (i == -1) { [EOL]         return StringUtils.EMPTY; [EOL]     } [EOL]     return className.substring(0, i); [EOL] } 
 [LINE] classNames.add(null); [LINE] public static List<String> convertClassesToClassNames(final List<Class<?>> classes) { [EOL]     if (classes == null) { [EOL]         return null; [EOL]     } [EOL]     final List<String> classNames = new ArrayList<String>(classes.size()); [EOL]     for (final Class<?> cls : classes) { [EOL]         if (cls == null) { [EOL]             classNames.add(null); [EOL]         } else { [EOL]             classNames.add(cls.getName()); [EOL]         } [EOL]     } [EOL]     return classNames; [EOL] } 
 [LINE] if (Integer.TYPE.equals(cls)) { [LINE] public static boolean isAssignable(Class<?> cls, final Class<?> toClass, final boolean autoboxing) { [EOL]     if (toClass == null) { [EOL]         return false; [EOL]     } [EOL]     if (cls == null) { [EOL]         return !toClass.isPrimitive(); [EOL]     } [EOL]     if (autoboxing) { [EOL]         if (cls.isPrimitive() && !toClass.isPrimitive()) { [EOL]             cls = primitiveToWrapper(cls); [EOL]             if (cls == null) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         if (toClass.isPrimitive() && !cls.isPrimitive()) { [EOL]             cls = wrapperToPrimitive(cls); [EOL]             if (cls == null) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (cls.equals(toClass)) { [EOL]         return true; [EOL]     } [EOL]     if (cls.isPrimitive()) { [EOL]         if (toClass.isPrimitive() == false) { [EOL]             return false; [EOL]         } [EOL]         if (Integer.TYPE.equals(cls)) { [EOL]             return Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Long.TYPE.equals(cls)) { [EOL]             return Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Boolean.TYPE.equals(cls)) { [EOL]             return false; [EOL]         } [EOL]         if (Double.TYPE.equals(cls)) { [EOL]             return false; [EOL]         } [EOL]         if (Float.TYPE.equals(cls)) { [EOL]             return Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Character.TYPE.equals(cls)) { [EOL]             return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Short.TYPE.equals(cls)) { [EOL]             return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Byte.TYPE.equals(cls)) { [EOL]             return Short.TYPE.equals(toClass) || Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return toClass.isAssignableFrom(cls); [EOL] } 
 [LINE] return Long.TYPE.equals(toClass) [LINE] public static boolean isAssignable(Class<?> cls, final Class<?> toClass, final boolean autoboxing) { [EOL]     if (toClass == null) { [EOL]         return false; [EOL]     } [EOL]     if (cls == null) { [EOL]         return !toClass.isPrimitive(); [EOL]     } [EOL]     if (autoboxing) { [EOL]         if (cls.isPrimitive() && !toClass.isPrimitive()) { [EOL]             cls = primitiveToWrapper(cls); [EOL]             if (cls == null) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         if (toClass.isPrimitive() && !cls.isPrimitive()) { [EOL]             cls = wrapperToPrimitive(cls); [EOL]             if (cls == null) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (cls.equals(toClass)) { [EOL]         return true; [EOL]     } [EOL]     if (cls.isPrimitive()) { [EOL]         if (toClass.isPrimitive() == false) { [EOL]             return false; [EOL]         } [EOL]         if (Integer.TYPE.equals(cls)) { [EOL]             return Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Long.TYPE.equals(cls)) { [EOL]             return Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Boolean.TYPE.equals(cls)) { [EOL]             return false; [EOL]         } [EOL]         if (Double.TYPE.equals(cls)) { [EOL]             return false; [EOL]         } [EOL]         if (Float.TYPE.equals(cls)) { [EOL]             return Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Character.TYPE.equals(cls)) { [EOL]             return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Short.TYPE.equals(cls)) { [EOL]             return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Byte.TYPE.equals(cls)) { [EOL]             return Short.TYPE.equals(toClass) || Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return toClass.isAssignableFrom(cls); [EOL] } 
 [LINE] if (Long.TYPE.equals(cls)) { [LINE] public static boolean isAssignable(Class<?> cls, final Class<?> toClass, final boolean autoboxing) { [EOL]     if (toClass == null) { [EOL]         return false; [EOL]     } [EOL]     if (cls == null) { [EOL]         return !toClass.isPrimitive(); [EOL]     } [EOL]     if (autoboxing) { [EOL]         if (cls.isPrimitive() && !toClass.isPrimitive()) { [EOL]             cls = primitiveToWrapper(cls); [EOL]             if (cls == null) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         if (toClass.isPrimitive() && !cls.isPrimitive()) { [EOL]             cls = wrapperToPrimitive(cls); [EOL]             if (cls == null) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (cls.equals(toClass)) { [EOL]         return true; [EOL]     } [EOL]     if (cls.isPrimitive()) { [EOL]         if (toClass.isPrimitive() == false) { [EOL]             return false; [EOL]         } [EOL]         if (Integer.TYPE.equals(cls)) { [EOL]             return Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Long.TYPE.equals(cls)) { [EOL]             return Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Boolean.TYPE.equals(cls)) { [EOL]             return false; [EOL]         } [EOL]         if (Double.TYPE.equals(cls)) { [EOL]             return false; [EOL]         } [EOL]         if (Float.TYPE.equals(cls)) { [EOL]             return Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Character.TYPE.equals(cls)) { [EOL]             return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Short.TYPE.equals(cls)) { [EOL]             return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Byte.TYPE.equals(cls)) { [EOL]             return Short.TYPE.equals(toClass) || Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return toClass.isAssignableFrom(cls); [EOL] } 
 [LINE] return Float.TYPE.equals(toClass) [LINE] public static boolean isAssignable(Class<?> cls, final Class<?> toClass, final boolean autoboxing) { [EOL]     if (toClass == null) { [EOL]         return false; [EOL]     } [EOL]     if (cls == null) { [EOL]         return !toClass.isPrimitive(); [EOL]     } [EOL]     if (autoboxing) { [EOL]         if (cls.isPrimitive() && !toClass.isPrimitive()) { [EOL]             cls = primitiveToWrapper(cls); [EOL]             if (cls == null) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         if (toClass.isPrimitive() && !cls.isPrimitive()) { [EOL]             cls = wrapperToPrimitive(cls); [EOL]             if (cls == null) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (cls.equals(toClass)) { [EOL]         return true; [EOL]     } [EOL]     if (cls.isPrimitive()) { [EOL]         if (toClass.isPrimitive() == false) { [EOL]             return false; [EOL]         } [EOL]         if (Integer.TYPE.equals(cls)) { [EOL]             return Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Long.TYPE.equals(cls)) { [EOL]             return Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Boolean.TYPE.equals(cls)) { [EOL]             return false; [EOL]         } [EOL]         if (Double.TYPE.equals(cls)) { [EOL]             return false; [EOL]         } [EOL]         if (Float.TYPE.equals(cls)) { [EOL]             return Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Character.TYPE.equals(cls)) { [EOL]             return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Short.TYPE.equals(cls)) { [EOL]             return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Byte.TYPE.equals(cls)) { [EOL]             return Short.TYPE.equals(toClass) || Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return toClass.isAssignableFrom(cls); [EOL] } 
 [LINE] if (Boolean.TYPE.equals(cls)) { [LINE] public static boolean isAssignable(Class<?> cls, final Class<?> toClass, final boolean autoboxing) { [EOL]     if (toClass == null) { [EOL]         return false; [EOL]     } [EOL]     if (cls == null) { [EOL]         return !toClass.isPrimitive(); [EOL]     } [EOL]     if (autoboxing) { [EOL]         if (cls.isPrimitive() && !toClass.isPrimitive()) { [EOL]             cls = primitiveToWrapper(cls); [EOL]             if (cls == null) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         if (toClass.isPrimitive() && !cls.isPrimitive()) { [EOL]             cls = wrapperToPrimitive(cls); [EOL]             if (cls == null) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (cls.equals(toClass)) { [EOL]         return true; [EOL]     } [EOL]     if (cls.isPrimitive()) { [EOL]         if (toClass.isPrimitive() == false) { [EOL]             return false; [EOL]         } [EOL]         if (Integer.TYPE.equals(cls)) { [EOL]             return Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Long.TYPE.equals(cls)) { [EOL]             return Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Boolean.TYPE.equals(cls)) { [EOL]             return false; [EOL]         } [EOL]         if (Double.TYPE.equals(cls)) { [EOL]             return false; [EOL]         } [EOL]         if (Float.TYPE.equals(cls)) { [EOL]             return Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Character.TYPE.equals(cls)) { [EOL]             return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Short.TYPE.equals(cls)) { [EOL]             return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Byte.TYPE.equals(cls)) { [EOL]             return Short.TYPE.equals(toClass) || Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return toClass.isAssignableFrom(cls); [EOL] } 
 [LINE] return false; [LINE] public static boolean isAssignable(Class<?> cls, final Class<?> toClass, final boolean autoboxing) { [EOL]     if (toClass == null) { [EOL]         return false; [EOL]     } [EOL]     if (cls == null) { [EOL]         return !toClass.isPrimitive(); [EOL]     } [EOL]     if (autoboxing) { [EOL]         if (cls.isPrimitive() && !toClass.isPrimitive()) { [EOL]             cls = primitiveToWrapper(cls); [EOL]             if (cls == null) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         if (toClass.isPrimitive() && !cls.isPrimitive()) { [EOL]             cls = wrapperToPrimitive(cls); [EOL]             if (cls == null) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (cls.equals(toClass)) { [EOL]         return true; [EOL]     } [EOL]     if (cls.isPrimitive()) { [EOL]         if (toClass.isPrimitive() == false) { [EOL]             return false; [EOL]         } [EOL]         if (Integer.TYPE.equals(cls)) { [EOL]             return Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Long.TYPE.equals(cls)) { [EOL]             return Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Boolean.TYPE.equals(cls)) { [EOL]             return false; [EOL]         } [EOL]         if (Double.TYPE.equals(cls)) { [EOL]             return false; [EOL]         } [EOL]         if (Float.TYPE.equals(cls)) { [EOL]             return Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Character.TYPE.equals(cls)) { [EOL]             return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Short.TYPE.equals(cls)) { [EOL]             return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Byte.TYPE.equals(cls)) { [EOL]             return Short.TYPE.equals(toClass) || Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return toClass.isAssignableFrom(cls); [EOL] } 
 [LINE] if (Double.TYPE.equals(cls)) { [LINE] public static boolean isAssignable(Class<?> cls, final Class<?> toClass, final boolean autoboxing) { [EOL]     if (toClass == null) { [EOL]         return false; [EOL]     } [EOL]     if (cls == null) { [EOL]         return !toClass.isPrimitive(); [EOL]     } [EOL]     if (autoboxing) { [EOL]         if (cls.isPrimitive() && !toClass.isPrimitive()) { [EOL]             cls = primitiveToWrapper(cls); [EOL]             if (cls == null) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         if (toClass.isPrimitive() && !cls.isPrimitive()) { [EOL]             cls = wrapperToPrimitive(cls); [EOL]             if (cls == null) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (cls.equals(toClass)) { [EOL]         return true; [EOL]     } [EOL]     if (cls.isPrimitive()) { [EOL]         if (toClass.isPrimitive() == false) { [EOL]             return false; [EOL]         } [EOL]         if (Integer.TYPE.equals(cls)) { [EOL]             return Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Long.TYPE.equals(cls)) { [EOL]             return Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Boolean.TYPE.equals(cls)) { [EOL]             return false; [EOL]         } [EOL]         if (Double.TYPE.equals(cls)) { [EOL]             return false; [EOL]         } [EOL]         if (Float.TYPE.equals(cls)) { [EOL]             return Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Character.TYPE.equals(cls)) { [EOL]             return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Short.TYPE.equals(cls)) { [EOL]             return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Byte.TYPE.equals(cls)) { [EOL]             return Short.TYPE.equals(toClass) || Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return toClass.isAssignableFrom(cls); [EOL] } 
 [LINE] return false; [LINE] public static boolean isAssignable(Class<?> cls, final Class<?> toClass, final boolean autoboxing) { [EOL]     if (toClass == null) { [EOL]         return false; [EOL]     } [EOL]     if (cls == null) { [EOL]         return !toClass.isPrimitive(); [EOL]     } [EOL]     if (autoboxing) { [EOL]         if (cls.isPrimitive() && !toClass.isPrimitive()) { [EOL]             cls = primitiveToWrapper(cls); [EOL]             if (cls == null) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         if (toClass.isPrimitive() && !cls.isPrimitive()) { [EOL]             cls = wrapperToPrimitive(cls); [EOL]             if (cls == null) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (cls.equals(toClass)) { [EOL]         return true; [EOL]     } [EOL]     if (cls.isPrimitive()) { [EOL]         if (toClass.isPrimitive() == false) { [EOL]             return false; [EOL]         } [EOL]         if (Integer.TYPE.equals(cls)) { [EOL]             return Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Long.TYPE.equals(cls)) { [EOL]             return Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Boolean.TYPE.equals(cls)) { [EOL]             return false; [EOL]         } [EOL]         if (Double.TYPE.equals(cls)) { [EOL]             return false; [EOL]         } [EOL]         if (Float.TYPE.equals(cls)) { [EOL]             return Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Character.TYPE.equals(cls)) { [EOL]             return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Short.TYPE.equals(cls)) { [EOL]             return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Byte.TYPE.equals(cls)) { [EOL]             return Short.TYPE.equals(toClass) || Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return toClass.isAssignableFrom(cls); [EOL] } 
 [LINE] if (Float.TYPE.equals(cls)) { [LINE] public static boolean isAssignable(Class<?> cls, final Class<?> toClass, final boolean autoboxing) { [EOL]     if (toClass == null) { [EOL]         return false; [EOL]     } [EOL]     if (cls == null) { [EOL]         return !toClass.isPrimitive(); [EOL]     } [EOL]     if (autoboxing) { [EOL]         if (cls.isPrimitive() && !toClass.isPrimitive()) { [EOL]             cls = primitiveToWrapper(cls); [EOL]             if (cls == null) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         if (toClass.isPrimitive() && !cls.isPrimitive()) { [EOL]             cls = wrapperToPrimitive(cls); [EOL]             if (cls == null) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (cls.equals(toClass)) { [EOL]         return true; [EOL]     } [EOL]     if (cls.isPrimitive()) { [EOL]         if (toClass.isPrimitive() == false) { [EOL]             return false; [EOL]         } [EOL]         if (Integer.TYPE.equals(cls)) { [EOL]             return Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Long.TYPE.equals(cls)) { [EOL]             return Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Boolean.TYPE.equals(cls)) { [EOL]             return false; [EOL]         } [EOL]         if (Double.TYPE.equals(cls)) { [EOL]             return false; [EOL]         } [EOL]         if (Float.TYPE.equals(cls)) { [EOL]             return Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Character.TYPE.equals(cls)) { [EOL]             return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Short.TYPE.equals(cls)) { [EOL]             return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Byte.TYPE.equals(cls)) { [EOL]             return Short.TYPE.equals(toClass) || Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return toClass.isAssignableFrom(cls); [EOL] } 
 [LINE] return Double.TYPE.equals(toClass); [LINE] public static boolean isAssignable(Class<?> cls, final Class<?> toClass, final boolean autoboxing) { [EOL]     if (toClass == null) { [EOL]         return false; [EOL]     } [EOL]     if (cls == null) { [EOL]         return !toClass.isPrimitive(); [EOL]     } [EOL]     if (autoboxing) { [EOL]         if (cls.isPrimitive() && !toClass.isPrimitive()) { [EOL]             cls = primitiveToWrapper(cls); [EOL]             if (cls == null) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         if (toClass.isPrimitive() && !cls.isPrimitive()) { [EOL]             cls = wrapperToPrimitive(cls); [EOL]             if (cls == null) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (cls.equals(toClass)) { [EOL]         return true; [EOL]     } [EOL]     if (cls.isPrimitive()) { [EOL]         if (toClass.isPrimitive() == false) { [EOL]             return false; [EOL]         } [EOL]         if (Integer.TYPE.equals(cls)) { [EOL]             return Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Long.TYPE.equals(cls)) { [EOL]             return Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Boolean.TYPE.equals(cls)) { [EOL]             return false; [EOL]         } [EOL]         if (Double.TYPE.equals(cls)) { [EOL]             return false; [EOL]         } [EOL]         if (Float.TYPE.equals(cls)) { [EOL]             return Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Character.TYPE.equals(cls)) { [EOL]             return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Short.TYPE.equals(cls)) { [EOL]             return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Byte.TYPE.equals(cls)) { [EOL]             return Short.TYPE.equals(toClass) || Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return toClass.isAssignableFrom(cls); [EOL] } 
 [LINE] if (Character.TYPE.equals(cls)) { [LINE] public static boolean isAssignable(Class<?> cls, final Class<?> toClass, final boolean autoboxing) { [EOL]     if (toClass == null) { [EOL]         return false; [EOL]     } [EOL]     if (cls == null) { [EOL]         return !toClass.isPrimitive(); [EOL]     } [EOL]     if (autoboxing) { [EOL]         if (cls.isPrimitive() && !toClass.isPrimitive()) { [EOL]             cls = primitiveToWrapper(cls); [EOL]             if (cls == null) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         if (toClass.isPrimitive() && !cls.isPrimitive()) { [EOL]             cls = wrapperToPrimitive(cls); [EOL]             if (cls == null) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (cls.equals(toClass)) { [EOL]         return true; [EOL]     } [EOL]     if (cls.isPrimitive()) { [EOL]         if (toClass.isPrimitive() == false) { [EOL]             return false; [EOL]         } [EOL]         if (Integer.TYPE.equals(cls)) { [EOL]             return Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Long.TYPE.equals(cls)) { [EOL]             return Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Boolean.TYPE.equals(cls)) { [EOL]             return false; [EOL]         } [EOL]         if (Double.TYPE.equals(cls)) { [EOL]             return false; [EOL]         } [EOL]         if (Float.TYPE.equals(cls)) { [EOL]             return Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Character.TYPE.equals(cls)) { [EOL]             return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Short.TYPE.equals(cls)) { [EOL]             return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Byte.TYPE.equals(cls)) { [EOL]             return Short.TYPE.equals(toClass) || Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return toClass.isAssignableFrom(cls); [EOL] } 
 [LINE] return Integer.TYPE.equals(toClass) [LINE] public static boolean isAssignable(Class<?> cls, final Class<?> toClass, final boolean autoboxing) { [EOL]     if (toClass == null) { [EOL]         return false; [EOL]     } [EOL]     if (cls == null) { [EOL]         return !toClass.isPrimitive(); [EOL]     } [EOL]     if (autoboxing) { [EOL]         if (cls.isPrimitive() && !toClass.isPrimitive()) { [EOL]             cls = primitiveToWrapper(cls); [EOL]             if (cls == null) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         if (toClass.isPrimitive() && !cls.isPrimitive()) { [EOL]             cls = wrapperToPrimitive(cls); [EOL]             if (cls == null) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (cls.equals(toClass)) { [EOL]         return true; [EOL]     } [EOL]     if (cls.isPrimitive()) { [EOL]         if (toClass.isPrimitive() == false) { [EOL]             return false; [EOL]         } [EOL]         if (Integer.TYPE.equals(cls)) { [EOL]             return Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Long.TYPE.equals(cls)) { [EOL]             return Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Boolean.TYPE.equals(cls)) { [EOL]             return false; [EOL]         } [EOL]         if (Double.TYPE.equals(cls)) { [EOL]             return false; [EOL]         } [EOL]         if (Float.TYPE.equals(cls)) { [EOL]             return Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Character.TYPE.equals(cls)) { [EOL]             return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Short.TYPE.equals(cls)) { [EOL]             return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Byte.TYPE.equals(cls)) { [EOL]             return Short.TYPE.equals(toClass) || Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return toClass.isAssignableFrom(cls); [EOL] } 
 [LINE] if (Short.TYPE.equals(cls)) { [LINE] public static boolean isAssignable(Class<?> cls, final Class<?> toClass, final boolean autoboxing) { [EOL]     if (toClass == null) { [EOL]         return false; [EOL]     } [EOL]     if (cls == null) { [EOL]         return !toClass.isPrimitive(); [EOL]     } [EOL]     if (autoboxing) { [EOL]         if (cls.isPrimitive() && !toClass.isPrimitive()) { [EOL]             cls = primitiveToWrapper(cls); [EOL]             if (cls == null) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         if (toClass.isPrimitive() && !cls.isPrimitive()) { [EOL]             cls = wrapperToPrimitive(cls); [EOL]             if (cls == null) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (cls.equals(toClass)) { [EOL]         return true; [EOL]     } [EOL]     if (cls.isPrimitive()) { [EOL]         if (toClass.isPrimitive() == false) { [EOL]             return false; [EOL]         } [EOL]         if (Integer.TYPE.equals(cls)) { [EOL]             return Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Long.TYPE.equals(cls)) { [EOL]             return Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Boolean.TYPE.equals(cls)) { [EOL]             return false; [EOL]         } [EOL]         if (Double.TYPE.equals(cls)) { [EOL]             return false; [EOL]         } [EOL]         if (Float.TYPE.equals(cls)) { [EOL]             return Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Character.TYPE.equals(cls)) { [EOL]             return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Short.TYPE.equals(cls)) { [EOL]             return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Byte.TYPE.equals(cls)) { [EOL]             return Short.TYPE.equals(toClass) || Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return toClass.isAssignableFrom(cls); [EOL] } 
 [LINE] return Integer.TYPE.equals(toClass) [LINE] public static boolean isAssignable(Class<?> cls, final Class<?> toClass, final boolean autoboxing) { [EOL]     if (toClass == null) { [EOL]         return false; [EOL]     } [EOL]     if (cls == null) { [EOL]         return !toClass.isPrimitive(); [EOL]     } [EOL]     if (autoboxing) { [EOL]         if (cls.isPrimitive() && !toClass.isPrimitive()) { [EOL]             cls = primitiveToWrapper(cls); [EOL]             if (cls == null) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         if (toClass.isPrimitive() && !cls.isPrimitive()) { [EOL]             cls = wrapperToPrimitive(cls); [EOL]             if (cls == null) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (cls.equals(toClass)) { [EOL]         return true; [EOL]     } [EOL]     if (cls.isPrimitive()) { [EOL]         if (toClass.isPrimitive() == false) { [EOL]             return false; [EOL]         } [EOL]         if (Integer.TYPE.equals(cls)) { [EOL]             return Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Long.TYPE.equals(cls)) { [EOL]             return Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Boolean.TYPE.equals(cls)) { [EOL]             return false; [EOL]         } [EOL]         if (Double.TYPE.equals(cls)) { [EOL]             return false; [EOL]         } [EOL]         if (Float.TYPE.equals(cls)) { [EOL]             return Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Character.TYPE.equals(cls)) { [EOL]             return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Short.TYPE.equals(cls)) { [EOL]             return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Byte.TYPE.equals(cls)) { [EOL]             return Short.TYPE.equals(toClass) || Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return toClass.isAssignableFrom(cls); [EOL] } 
 [LINE] if (Byte.TYPE.equals(cls)) { [LINE] public static boolean isAssignable(Class<?> cls, final Class<?> toClass, final boolean autoboxing) { [EOL]     if (toClass == null) { [EOL]         return false; [EOL]     } [EOL]     if (cls == null) { [EOL]         return !toClass.isPrimitive(); [EOL]     } [EOL]     if (autoboxing) { [EOL]         if (cls.isPrimitive() && !toClass.isPrimitive()) { [EOL]             cls = primitiveToWrapper(cls); [EOL]             if (cls == null) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         if (toClass.isPrimitive() && !cls.isPrimitive()) { [EOL]             cls = wrapperToPrimitive(cls); [EOL]             if (cls == null) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (cls.equals(toClass)) { [EOL]         return true; [EOL]     } [EOL]     if (cls.isPrimitive()) { [EOL]         if (toClass.isPrimitive() == false) { [EOL]             return false; [EOL]         } [EOL]         if (Integer.TYPE.equals(cls)) { [EOL]             return Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Long.TYPE.equals(cls)) { [EOL]             return Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Boolean.TYPE.equals(cls)) { [EOL]             return false; [EOL]         } [EOL]         if (Double.TYPE.equals(cls)) { [EOL]             return false; [EOL]         } [EOL]         if (Float.TYPE.equals(cls)) { [EOL]             return Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Character.TYPE.equals(cls)) { [EOL]             return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Short.TYPE.equals(cls)) { [EOL]             return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Byte.TYPE.equals(cls)) { [EOL]             return Short.TYPE.equals(toClass) || Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return toClass.isAssignableFrom(cls); [EOL] } 
 [LINE] return Short.TYPE.equals(toClass) [LINE] public static boolean isAssignable(Class<?> cls, final Class<?> toClass, final boolean autoboxing) { [EOL]     if (toClass == null) { [EOL]         return false; [EOL]     } [EOL]     if (cls == null) { [EOL]         return !toClass.isPrimitive(); [EOL]     } [EOL]     if (autoboxing) { [EOL]         if (cls.isPrimitive() && !toClass.isPrimitive()) { [EOL]             cls = primitiveToWrapper(cls); [EOL]             if (cls == null) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         if (toClass.isPrimitive() && !cls.isPrimitive()) { [EOL]             cls = wrapperToPrimitive(cls); [EOL]             if (cls == null) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (cls.equals(toClass)) { [EOL]         return true; [EOL]     } [EOL]     if (cls.isPrimitive()) { [EOL]         if (toClass.isPrimitive() == false) { [EOL]             return false; [EOL]         } [EOL]         if (Integer.TYPE.equals(cls)) { [EOL]             return Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Long.TYPE.equals(cls)) { [EOL]             return Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Boolean.TYPE.equals(cls)) { [EOL]             return false; [EOL]         } [EOL]         if (Double.TYPE.equals(cls)) { [EOL]             return false; [EOL]         } [EOL]         if (Float.TYPE.equals(cls)) { [EOL]             return Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Character.TYPE.equals(cls)) { [EOL]             return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Short.TYPE.equals(cls)) { [EOL]             return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Byte.TYPE.equals(cls)) { [EOL]             return Short.TYPE.equals(toClass) || Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return toClass.isAssignableFrom(cls); [EOL] } 
 [LINE] if (Modifier.isPublic(declaredMethod.getDeclaringClass().getModifiers())) { [LINE] public static Method getPublicMethod(final Class<?> cls, final String methodName, final Class<?>... parameterTypes) throws SecurityException, NoSuchMethodException { [EOL]     final Method declaredMethod = cls.getMethod(methodName, parameterTypes); [EOL]     if (Modifier.isPublic(declaredMethod.getDeclaringClass().getModifiers())) { [EOL]         return declaredMethod; [EOL]     } [EOL]     final List<Class<?>> candidateClasses = new ArrayList<Class<?>>(); [EOL]     candidateClasses.addAll(getAllInterfaces(cls)); [EOL]     candidateClasses.addAll(getAllSuperclasses(cls)); [EOL]     for (final Class<?> candidateClass : candidateClasses) { [EOL]         if (!Modifier.isPublic(candidateClass.getModifiers())) { [EOL]             continue; [EOL]         } [EOL]         Method candidateMethod; [EOL]         try { [EOL]             candidateMethod = candidateClass.getMethod(methodName, parameterTypes); [EOL]         } catch (final NoSuchMethodException ex) { [EOL]             continue; [EOL]         } [EOL]         if (Modifier.isPublic(candidateMethod.getDeclaringClass().getModifiers())) { [EOL]             return candidateMethod; [EOL]         } [EOL]     } [EOL]     throw new NoSuchMethodException("Can't find a public method for " + methodName + " " + ArrayUtils.toString(parameterTypes)); [EOL] } 
 [LINE] return declaredMethod; [LINE] public static Method getPublicMethod(final Class<?> cls, final String methodName, final Class<?>... parameterTypes) throws SecurityException, NoSuchMethodException { [EOL]     final Method declaredMethod = cls.getMethod(methodName, parameterTypes); [EOL]     if (Modifier.isPublic(declaredMethod.getDeclaringClass().getModifiers())) { [EOL]         return declaredMethod; [EOL]     } [EOL]     final List<Class<?>> candidateClasses = new ArrayList<Class<?>>(); [EOL]     candidateClasses.addAll(getAllInterfaces(cls)); [EOL]     candidateClasses.addAll(getAllSuperclasses(cls)); [EOL]     for (final Class<?> candidateClass : candidateClasses) { [EOL]         if (!Modifier.isPublic(candidateClass.getModifiers())) { [EOL]             continue; [EOL]         } [EOL]         Method candidateMethod; [EOL]         try { [EOL]             candidateMethod = candidateClass.getMethod(methodName, parameterTypes); [EOL]         } catch (final NoSuchMethodException ex) { [EOL]             continue; [EOL]         } [EOL]         if (Modifier.isPublic(candidateMethod.getDeclaringClass().getModifiers())) { [EOL]             return candidateMethod; [EOL]         } [EOL]     } [EOL]     throw new NoSuchMethodException("Can't find a public method for " + methodName + " " + ArrayUtils.toString(parameterTypes)); [EOL] } 
 [LINE] final List<Class<?>> candidateClasses = new ArrayList<Class<?>>(); [LINE] public static Method getPublicMethod(final Class<?> cls, final String methodName, final Class<?>... parameterTypes) throws SecurityException, NoSuchMethodException { [EOL]     final Method declaredMethod = cls.getMethod(methodName, parameterTypes); [EOL]     if (Modifier.isPublic(declaredMethod.getDeclaringClass().getModifiers())) { [EOL]         return declaredMethod; [EOL]     } [EOL]     final List<Class<?>> candidateClasses = new ArrayList<Class<?>>(); [EOL]     candidateClasses.addAll(getAllInterfaces(cls)); [EOL]     candidateClasses.addAll(getAllSuperclasses(cls)); [EOL]     for (final Class<?> candidateClass : candidateClasses) { [EOL]         if (!Modifier.isPublic(candidateClass.getModifiers())) { [EOL]             continue; [EOL]         } [EOL]         Method candidateMethod; [EOL]         try { [EOL]             candidateMethod = candidateClass.getMethod(methodName, parameterTypes); [EOL]         } catch (final NoSuchMethodException ex) { [EOL]             continue; [EOL]         } [EOL]         if (Modifier.isPublic(candidateMethod.getDeclaringClass().getModifiers())) { [EOL]             return candidateMethod; [EOL]         } [EOL]     } [EOL]     throw new NoSuchMethodException("Can't find a public method for " + methodName + " " + ArrayUtils.toString(parameterTypes)); [EOL] } 
 [LINE] candidateClasses.addAll(getAllInterfaces(cls)); [LINE] public static Method getPublicMethod(final Class<?> cls, final String methodName, final Class<?>... parameterTypes) throws SecurityException, NoSuchMethodException { [EOL]     final Method declaredMethod = cls.getMethod(methodName, parameterTypes); [EOL]     if (Modifier.isPublic(declaredMethod.getDeclaringClass().getModifiers())) { [EOL]         return declaredMethod; [EOL]     } [EOL]     final List<Class<?>> candidateClasses = new ArrayList<Class<?>>(); [EOL]     candidateClasses.addAll(getAllInterfaces(cls)); [EOL]     candidateClasses.addAll(getAllSuperclasses(cls)); [EOL]     for (final Class<?> candidateClass : candidateClasses) { [EOL]         if (!Modifier.isPublic(candidateClass.getModifiers())) { [EOL]             continue; [EOL]         } [EOL]         Method candidateMethod; [EOL]         try { [EOL]             candidateMethod = candidateClass.getMethod(methodName, parameterTypes); [EOL]         } catch (final NoSuchMethodException ex) { [EOL]             continue; [EOL]         } [EOL]         if (Modifier.isPublic(candidateMethod.getDeclaringClass().getModifiers())) { [EOL]             return candidateMethod; [EOL]         } [EOL]     } [EOL]     throw new NoSuchMethodException("Can't find a public method for " + methodName + " " + ArrayUtils.toString(parameterTypes)); [EOL] } 
 [LINE] candidateClasses.addAll(getAllSuperclasses(cls)); [LINE] public static Method getPublicMethod(final Class<?> cls, final String methodName, final Class<?>... parameterTypes) throws SecurityException, NoSuchMethodException { [EOL]     final Method declaredMethod = cls.getMethod(methodName, parameterTypes); [EOL]     if (Modifier.isPublic(declaredMethod.getDeclaringClass().getModifiers())) { [EOL]         return declaredMethod; [EOL]     } [EOL]     final List<Class<?>> candidateClasses = new ArrayList<Class<?>>(); [EOL]     candidateClasses.addAll(getAllInterfaces(cls)); [EOL]     candidateClasses.addAll(getAllSuperclasses(cls)); [EOL]     for (final Class<?> candidateClass : candidateClasses) { [EOL]         if (!Modifier.isPublic(candidateClass.getModifiers())) { [EOL]             continue; [EOL]         } [EOL]         Method candidateMethod; [EOL]         try { [EOL]             candidateMethod = candidateClass.getMethod(methodName, parameterTypes); [EOL]         } catch (final NoSuchMethodException ex) { [EOL]             continue; [EOL]         } [EOL]         if (Modifier.isPublic(candidateMethod.getDeclaringClass().getModifiers())) { [EOL]             return candidateMethod; [EOL]         } [EOL]     } [EOL]     throw new NoSuchMethodException("Can't find a public method for " + methodName + " " + ArrayUtils.toString(parameterTypes)); [EOL] } 
 [LINE] for (final Class<?> candidateClass : candidateClasses) { [LINE] public static Method getPublicMethod(final Class<?> cls, final String methodName, final Class<?>... parameterTypes) throws SecurityException, NoSuchMethodException { [EOL]     final Method declaredMethod = cls.getMethod(methodName, parameterTypes); [EOL]     if (Modifier.isPublic(declaredMethod.getDeclaringClass().getModifiers())) { [EOL]         return declaredMethod; [EOL]     } [EOL]     final List<Class<?>> candidateClasses = new ArrayList<Class<?>>(); [EOL]     candidateClasses.addAll(getAllInterfaces(cls)); [EOL]     candidateClasses.addAll(getAllSuperclasses(cls)); [EOL]     for (final Class<?> candidateClass : candidateClasses) { [EOL]         if (!Modifier.isPublic(candidateClass.getModifiers())) { [EOL]             continue; [EOL]         } [EOL]         Method candidateMethod; [EOL]         try { [EOL]             candidateMethod = candidateClass.getMethod(methodName, parameterTypes); [EOL]         } catch (final NoSuchMethodException ex) { [EOL]             continue; [EOL]         } [EOL]         if (Modifier.isPublic(candidateMethod.getDeclaringClass().getModifiers())) { [EOL]             return candidateMethod; [EOL]         } [EOL]     } [EOL]     throw new NoSuchMethodException("Can't find a public method for " + methodName + " " + ArrayUtils.toString(parameterTypes)); [EOL] } 
 [LINE] if (!Modifier.isPublic(candidateClass.getModifiers())) { [LINE] public static Method getPublicMethod(final Class<?> cls, final String methodName, final Class<?>... parameterTypes) throws SecurityException, NoSuchMethodException { [EOL]     final Method declaredMethod = cls.getMethod(methodName, parameterTypes); [EOL]     if (Modifier.isPublic(declaredMethod.getDeclaringClass().getModifiers())) { [EOL]         return declaredMethod; [EOL]     } [EOL]     final List<Class<?>> candidateClasses = new ArrayList<Class<?>>(); [EOL]     candidateClasses.addAll(getAllInterfaces(cls)); [EOL]     candidateClasses.addAll(getAllSuperclasses(cls)); [EOL]     for (final Class<?> candidateClass : candidateClasses) { [EOL]         if (!Modifier.isPublic(candidateClass.getModifiers())) { [EOL]             continue; [EOL]         } [EOL]         Method candidateMethod; [EOL]         try { [EOL]             candidateMethod = candidateClass.getMethod(methodName, parameterTypes); [EOL]         } catch (final NoSuchMethodException ex) { [EOL]             continue; [EOL]         } [EOL]         if (Modifier.isPublic(candidateMethod.getDeclaringClass().getModifiers())) { [EOL]             return candidateMethod; [EOL]         } [EOL]     } [EOL]     throw new NoSuchMethodException("Can't find a public method for " + methodName + " " + ArrayUtils.toString(parameterTypes)); [EOL] } 
 [LINE] Method candidateMethod; [LINE] public static Method getPublicMethod(final Class<?> cls, final String methodName, final Class<?>... parameterTypes) throws SecurityException, NoSuchMethodException { [EOL]     final Method declaredMethod = cls.getMethod(methodName, parameterTypes); [EOL]     if (Modifier.isPublic(declaredMethod.getDeclaringClass().getModifiers())) { [EOL]         return declaredMethod; [EOL]     } [EOL]     final List<Class<?>> candidateClasses = new ArrayList<Class<?>>(); [EOL]     candidateClasses.addAll(getAllInterfaces(cls)); [EOL]     candidateClasses.addAll(getAllSuperclasses(cls)); [EOL]     for (final Class<?> candidateClass : candidateClasses) { [EOL]         if (!Modifier.isPublic(candidateClass.getModifiers())) { [EOL]             continue; [EOL]         } [EOL]         Method candidateMethod; [EOL]         try { [EOL]             candidateMethod = candidateClass.getMethod(methodName, parameterTypes); [EOL]         } catch (final NoSuchMethodException ex) { [EOL]             continue; [EOL]         } [EOL]         if (Modifier.isPublic(candidateMethod.getDeclaringClass().getModifiers())) { [EOL]             return candidateMethod; [EOL]         } [EOL]     } [EOL]     throw new NoSuchMethodException("Can't find a public method for " + methodName + " " + ArrayUtils.toString(parameterTypes)); [EOL] } 
 [LINE] try { [LINE] public static Method getPublicMethod(final Class<?> cls, final String methodName, final Class<?>... parameterTypes) throws SecurityException, NoSuchMethodException { [EOL]     final Method declaredMethod = cls.getMethod(methodName, parameterTypes); [EOL]     if (Modifier.isPublic(declaredMethod.getDeclaringClass().getModifiers())) { [EOL]         return declaredMethod; [EOL]     } [EOL]     final List<Class<?>> candidateClasses = new ArrayList<Class<?>>(); [EOL]     candidateClasses.addAll(getAllInterfaces(cls)); [EOL]     candidateClasses.addAll(getAllSuperclasses(cls)); [EOL]     for (final Class<?> candidateClass : candidateClasses) { [EOL]         if (!Modifier.isPublic(candidateClass.getModifiers())) { [EOL]             continue; [EOL]         } [EOL]         Method candidateMethod; [EOL]         try { [EOL]             candidateMethod = candidateClass.getMethod(methodName, parameterTypes); [EOL]         } catch (final NoSuchMethodException ex) { [EOL]             continue; [EOL]         } [EOL]         if (Modifier.isPublic(candidateMethod.getDeclaringClass().getModifiers())) { [EOL]             return candidateMethod; [EOL]         } [EOL]     } [EOL]     throw new NoSuchMethodException("Can't find a public method for " + methodName + " " + ArrayUtils.toString(parameterTypes)); [EOL] } 
 [LINE] candidateMethod = candidateClass.getMethod(methodName, parameterTypes); [LINE] public static Method getPublicMethod(final Class<?> cls, final String methodName, final Class<?>... parameterTypes) throws SecurityException, NoSuchMethodException { [EOL]     final Method declaredMethod = cls.getMethod(methodName, parameterTypes); [EOL]     if (Modifier.isPublic(declaredMethod.getDeclaringClass().getModifiers())) { [EOL]         return declaredMethod; [EOL]     } [EOL]     final List<Class<?>> candidateClasses = new ArrayList<Class<?>>(); [EOL]     candidateClasses.addAll(getAllInterfaces(cls)); [EOL]     candidateClasses.addAll(getAllSuperclasses(cls)); [EOL]     for (final Class<?> candidateClass : candidateClasses) { [EOL]         if (!Modifier.isPublic(candidateClass.getModifiers())) { [EOL]             continue; [EOL]         } [EOL]         Method candidateMethod; [EOL]         try { [EOL]             candidateMethod = candidateClass.getMethod(methodName, parameterTypes); [EOL]         } catch (final NoSuchMethodException ex) { [EOL]             continue; [EOL]         } [EOL]         if (Modifier.isPublic(candidateMethod.getDeclaringClass().getModifiers())) { [EOL]             return candidateMethod; [EOL]         } [EOL]     } [EOL]     throw new NoSuchMethodException("Can't find a public method for " + methodName + " " + ArrayUtils.toString(parameterTypes)); [EOL] } 
 [LINE] if (Modifier.isPublic(candidateMethod.getDeclaringClass().getModifiers())) { [LINE] public static Method getPublicMethod(final Class<?> cls, final String methodName, final Class<?>... parameterTypes) throws SecurityException, NoSuchMethodException { [EOL]     final Method declaredMethod = cls.getMethod(methodName, parameterTypes); [EOL]     if (Modifier.isPublic(declaredMethod.getDeclaringClass().getModifiers())) { [EOL]         return declaredMethod; [EOL]     } [EOL]     final List<Class<?>> candidateClasses = new ArrayList<Class<?>>(); [EOL]     candidateClasses.addAll(getAllInterfaces(cls)); [EOL]     candidateClasses.addAll(getAllSuperclasses(cls)); [EOL]     for (final Class<?> candidateClass : candidateClasses) { [EOL]         if (!Modifier.isPublic(candidateClass.getModifiers())) { [EOL]             continue; [EOL]         } [EOL]         Method candidateMethod; [EOL]         try { [EOL]             candidateMethod = candidateClass.getMethod(methodName, parameterTypes); [EOL]         } catch (final NoSuchMethodException ex) { [EOL]             continue; [EOL]         } [EOL]         if (Modifier.isPublic(candidateMethod.getDeclaringClass().getModifiers())) { [EOL]             return candidateMethod; [EOL]         } [EOL]     } [EOL]     throw new NoSuchMethodException("Can't find a public method for " + methodName + " " + ArrayUtils.toString(parameterTypes)); [EOL] } 
 [LINE] return candidateMethod; [LINE] public static Method getPublicMethod(final Class<?> cls, final String methodName, final Class<?>... parameterTypes) throws SecurityException, NoSuchMethodException { [EOL]     final Method declaredMethod = cls.getMethod(methodName, parameterTypes); [EOL]     if (Modifier.isPublic(declaredMethod.getDeclaringClass().getModifiers())) { [EOL]         return declaredMethod; [EOL]     } [EOL]     final List<Class<?>> candidateClasses = new ArrayList<Class<?>>(); [EOL]     candidateClasses.addAll(getAllInterfaces(cls)); [EOL]     candidateClasses.addAll(getAllSuperclasses(cls)); [EOL]     for (final Class<?> candidateClass : candidateClasses) { [EOL]         if (!Modifier.isPublic(candidateClass.getModifiers())) { [EOL]             continue; [EOL]         } [EOL]         Method candidateMethod; [EOL]         try { [EOL]             candidateMethod = candidateClass.getMethod(methodName, parameterTypes); [EOL]         } catch (final NoSuchMethodException ex) { [EOL]             continue; [EOL]         } [EOL]         if (Modifier.isPublic(candidateMethod.getDeclaringClass().getModifiers())) { [EOL]             return candidateMethod; [EOL]         } [EOL]     } [EOL]     throw new NoSuchMethodException("Can't find a public method for " + methodName + " " + ArrayUtils.toString(parameterTypes)); [EOL] } 
 [LINE] classNameBuffer.append(abbreviation); [LINE] private static String toCanonicalName(String className) { [EOL]     className = StringUtils.deleteWhitespace(className); [EOL]     if (className == null) { [EOL]         throw new NullPointerException("className must not be null."); [EOL]     } else if (className.endsWith("[]")) { [EOL]         final StringBuilder classNameBuffer = new StringBuilder(); [EOL]         while (className.endsWith("[]")) { [EOL]             className = className.substring(0, className.length() - 2); [EOL]             classNameBuffer.append("["); [EOL]         } [EOL]         final String abbreviation = abbreviationMap.get(className); [EOL]         if (abbreviation != null) { [EOL]             classNameBuffer.append(abbreviation); [EOL]         } else { [EOL]             classNameBuffer.append("L").append(className).append(";"); [EOL]         } [EOL]         className = classNameBuffer.toString(); [EOL]     } [EOL]     return className; [EOL] } 
 [LINE] className = className.substring( [LINE] private static String getCanonicalName(String className) { [EOL]     className = StringUtils.deleteWhitespace(className); [EOL]     if (className == null) { [EOL]         return null; [EOL]     } else { [EOL]         int dim = 0; [EOL]         while (className.startsWith("[")) { [EOL]             dim++; [EOL]             className = className.substring(1); [EOL]         } [EOL]         if (dim < 1) { [EOL]             return className; [EOL]         } else { [EOL]             if (className.startsWith("L")) { [EOL]                 className = className.substring(1, className.endsWith(";") ? className.length() - 1 : className.length()); [EOL]             } else { [EOL]                 if (className.length() > 0) { [EOL]                     className = reverseAbbreviationMap.get(className.substring(0, 1)); [EOL]                 } [EOL]             } [EOL]             final StringBuilder canonicalClassNameBuffer = new StringBuilder(className); [EOL]             for (int i = 0; i < dim; i++) { [EOL]                 canonicalClassNameBuffer.append("[]"); [EOL]             } [EOL]             return canonicalClassNameBuffer.toString(); [EOL]         } [EOL]     } [EOL] } 
 [LINE] className.endsWith(";") [LINE] private static String getCanonicalName(String className) { [EOL]     className = StringUtils.deleteWhitespace(className); [EOL]     if (className == null) { [EOL]         return null; [EOL]     } else { [EOL]         int dim = 0; [EOL]         while (className.startsWith("[")) { [EOL]             dim++; [EOL]             className = className.substring(1); [EOL]         } [EOL]         if (dim < 1) { [EOL]             return className; [EOL]         } else { [EOL]             if (className.startsWith("L")) { [EOL]                 className = className.substring(1, className.endsWith(";") ? className.length() - 1 : className.length()); [EOL]             } else { [EOL]                 if (className.length() > 0) { [EOL]                     className = reverseAbbreviationMap.get(className.substring(0, 1)); [EOL]                 } [EOL]             } [EOL]             final StringBuilder canonicalClassNameBuffer = new StringBuilder(className); [EOL]             for (int i = 0; i < dim; i++) { [EOL]                 canonicalClassNameBuffer.append("[]"); [EOL]             } [EOL]             return canonicalClassNameBuffer.toString(); [EOL]         } [EOL]     } [EOL] } 
 [LINE] for (int i = 0; i < dim; i++) { [LINE] private static String getCanonicalName(String className) { [EOL]     className = StringUtils.deleteWhitespace(className); [EOL]     if (className == null) { [EOL]         return null; [EOL]     } else { [EOL]         int dim = 0; [EOL]         while (className.startsWith("[")) { [EOL]             dim++; [EOL]             className = className.substring(1); [EOL]         } [EOL]         if (dim < 1) { [EOL]             return className; [EOL]         } else { [EOL]             if (className.startsWith("L")) { [EOL]                 className = className.substring(1, className.endsWith(";") ? className.length() - 1 : className.length()); [EOL]             } else { [EOL]                 if (className.length() > 0) { [EOL]                     className = reverseAbbreviationMap.get(className.substring(0, 1)); [EOL]                 } [EOL]             } [EOL]             final StringBuilder canonicalClassNameBuffer = new StringBuilder(className); [EOL]             for (int i = 0; i < dim; i++) { [EOL]                 canonicalClassNameBuffer.append("[]"); [EOL]             } [EOL]             return canonicalClassNameBuffer.toString(); [EOL]         } [EOL]     } [EOL] } 
 [LINE] canonicalClassNameBuffer.append("[]"); [LINE] private static String getCanonicalName(String className) { [EOL]     className = StringUtils.deleteWhitespace(className); [EOL]     if (className == null) { [EOL]         return null; [EOL]     } else { [EOL]         int dim = 0; [EOL]         while (className.startsWith("[")) { [EOL]             dim++; [EOL]             className = className.substring(1); [EOL]         } [EOL]         if (dim < 1) { [EOL]             return className; [EOL]         } else { [EOL]             if (className.startsWith("L")) { [EOL]                 className = className.substring(1, className.endsWith(";") ? className.length() - 1 : className.length()); [EOL]             } else { [EOL]                 if (className.length() > 0) { [EOL]                     className = reverseAbbreviationMap.get(className.substring(0, 1)); [EOL]                 } [EOL]             } [EOL]             final StringBuilder canonicalClassNameBuffer = new StringBuilder(className); [EOL]             for (int i = 0; i < dim; i++) { [EOL]                 canonicalClassNameBuffer.append("[]"); [EOL]             } [EOL]             return canonicalClassNameBuffer.toString(); [EOL]         } [EOL]     } [EOL] } 
 [LINE] return canonicalClassNameBuffer.toString(); [LINE] private static String getCanonicalName(String className) { [EOL]     className = StringUtils.deleteWhitespace(className); [EOL]     if (className == null) { [EOL]         return null; [EOL]     } else { [EOL]         int dim = 0; [EOL]         while (className.startsWith("[")) { [EOL]             dim++; [EOL]             className = className.substring(1); [EOL]         } [EOL]         if (dim < 1) { [EOL]             return className; [EOL]         } else { [EOL]             if (className.startsWith("L")) { [EOL]                 className = className.substring(1, className.endsWith(";") ? className.length() - 1 : className.length()); [EOL]             } else { [EOL]                 if (className.length() > 0) { [EOL]                     className = reverseAbbreviationMap.get(className.substring(0, 1)); [EOL]                 } [EOL]             } [EOL]             final StringBuilder canonicalClassNameBuffer = new StringBuilder(className); [EOL]             for (int i = 0; i < dim; i++) { [EOL]                 canonicalClassNameBuffer.append("[]"); [EOL]             } [EOL]             return canonicalClassNameBuffer.toString(); [EOL]         } [EOL]     } [EOL] } 
 [LINE] return Boolean.TRUE; [LINE] public static Boolean toBooleanObject(final String str) { [EOL]     if (str == "true") { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     switch(str.length()) { [EOL]         case 1: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 if (ch0 == 'y' || ch0 == 'Y' || ch0 == 't' || ch0 == 'T') { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if (ch0 == 'n' || ch0 == 'N' || ch0 == 'f' || ch0 == 'F') { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 2: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 if ((ch0 == 'o' || ch0 == 'O') && (ch1 == 'n' || ch1 == 'N')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if ((ch0 == 'n' || ch0 == 'N') && (ch1 == 'o' || ch1 == 'O')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 3: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 if ((ch0 == 'y' || ch0 == 'Y') && (ch1 == 'e' || ch1 == 'E') && (ch2 == 's' || ch2 == 'S')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if ((ch0 == 'o' || ch0 == 'O') && (ch1 == 'f' || ch1 == 'F') && (ch2 == 'f' || ch2 == 'F')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 4: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 final char ch3 = str.charAt(3); [EOL]                 if ((ch0 == 't' || ch0 == 'T') && (ch1 == 'r' || ch1 == 'R') && (ch2 == 'u' || ch2 == 'U') && (ch3 == 'e' || ch3 == 'E')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 5: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 final char ch3 = str.charAt(3); [EOL]                 final char ch4 = str.charAt(4); [EOL]                 if ((ch0 == 'f' || ch0 == 'F') && (ch1 == 'a' || ch1 == 'A') && (ch2 == 'l' || ch2 == 'L') && (ch3 == 's' || ch3 == 'S') && (ch4 == 'e' || ch4 == 'E')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]     } [EOL]     return null; [EOL] } 
 [LINE] return Boolean.TRUE; [LINE] public static Boolean toBooleanObject(final String str) { [EOL]     if (str == "true") { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     switch(str.length()) { [EOL]         case 1: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 if (ch0 == 'y' || ch0 == 'Y' || ch0 == 't' || ch0 == 'T') { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if (ch0 == 'n' || ch0 == 'N' || ch0 == 'f' || ch0 == 'F') { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 2: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 if ((ch0 == 'o' || ch0 == 'O') && (ch1 == 'n' || ch1 == 'N')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if ((ch0 == 'n' || ch0 == 'N') && (ch1 == 'o' || ch1 == 'O')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 3: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 if ((ch0 == 'y' || ch0 == 'Y') && (ch1 == 'e' || ch1 == 'E') && (ch2 == 's' || ch2 == 'S')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if ((ch0 == 'o' || ch0 == 'O') && (ch1 == 'f' || ch1 == 'F') && (ch2 == 'f' || ch2 == 'F')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 4: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 final char ch3 = str.charAt(3); [EOL]                 if ((ch0 == 't' || ch0 == 'T') && (ch1 == 'r' || ch1 == 'R') && (ch2 == 'u' || ch2 == 'U') && (ch3 == 'e' || ch3 == 'E')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 5: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 final char ch3 = str.charAt(3); [EOL]                 final char ch4 = str.charAt(4); [EOL]                 if ((ch0 == 'f' || ch0 == 'F') && (ch1 == 'a' || ch1 == 'A') && (ch2 == 'l' || ch2 == 'L') && (ch3 == 's' || ch3 == 'S') && (ch4 == 'e' || ch4 == 'E')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]     } [EOL]     return null; [EOL] } 
 [LINE] return true; [LINE] public static boolean toBoolean(final String str, final String trueString, final String falseString) { [EOL]     if (str == trueString) { [EOL]         return true; [EOL]     } else if (str == falseString) { [EOL]         return false; [EOL]     } else if (str != null) { [EOL]         if (str.equals(trueString)) { [EOL]             return true; [EOL]         } else if (str.equals(falseString)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match either specified value"); [EOL] } 
 [LINE] return false; [LINE] public static boolean toBoolean(final String str, final String trueString, final String falseString) { [EOL]     if (str == trueString) { [EOL]         return true; [EOL]     } else if (str == falseString) { [EOL]         return false; [EOL]     } else if (str != null) { [EOL]         if (str.equals(trueString)) { [EOL]             return true; [EOL]         } else if (str.equals(falseString)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match either specified value"); [EOL] } 
 [LINE] public EventListenerSupport(final Class<L> listenerInterface) { [LINE] public EventListenerSupport(final Class<L> listenerInterface) { [EOL]     this(listenerInterface, Thread.currentThread().getContextClassLoader()); [EOL] } 
 [LINE] this(listenerInterface, Thread.currentThread().getContextClassLoader()); [LINE] public EventListenerSupport(final Class<L> listenerInterface) { [EOL]     this(listenerInterface, Thread.currentThread().getContextClassLoader()); [EOL] } 
 [LINE] initializeTransientFields(listenerInterface, classLoader); [LINE] public EventListenerSupport(final Class<L> listenerInterface, final ClassLoader classLoader) { [EOL]     this(); [EOL]     Validate.notNull(listenerInterface, "Listener interface cannot be null."); [EOL]     Validate.notNull(classLoader, "ClassLoader cannot be null."); [EOL]     Validate.isTrue(listenerInterface.isInterface(), "Class {0} is not an interface", listenerInterface.getName()); [EOL]     initializeTransientFields(listenerInterface, classLoader); [EOL] } 
 [LINE] public L fire() { [LINE] public L fire() { [EOL]     return proxy; [EOL] } 
 [LINE] return proxy; [LINE] public L fire() { [EOL]     return proxy; [EOL] } 
 [LINE] public void addListener(final L listener) { [LINE] public void addListener(final L listener) { [EOL]     Validate.notNull(listener, "Listener object cannot be null."); [EOL]     listeners.add(listener); [EOL] } 
 [LINE] Validate.notNull(listener, "Listener object cannot be null."); [LINE] public void addListener(final L listener) { [EOL]     Validate.notNull(listener, "Listener object cannot be null."); [EOL]     listeners.add(listener); [EOL] } 
 [LINE] listeners.add(listener); [LINE] public void addListener(final L listener) { [EOL]     Validate.notNull(listener, "Listener object cannot be null."); [EOL]     listeners.add(listener); [EOL] } 
 [LINE] int getListenerCount() { [LINE] int getListenerCount() { [EOL]     return listeners.size(); [EOL] } 
 [LINE] return listeners.size(); [LINE] int getListenerCount() { [EOL]     return listeners.size(); [EOL] } 
 [LINE] public void removeListener(final L listener) { [LINE] public void removeListener(final L listener) { [EOL]     Validate.notNull(listener, "Listener object cannot be null."); [EOL]     listeners.remove(listener); [EOL] } 
 [LINE] Validate.notNull(listener, "Listener object cannot be null."); [LINE] public void removeListener(final L listener) { [EOL]     Validate.notNull(listener, "Listener object cannot be null."); [EOL]     listeners.remove(listener); [EOL] } 
 [LINE] listeners.remove(listener); [LINE] public void removeListener(final L listener) { [EOL]     Validate.notNull(listener, "Listener object cannot be null."); [EOL]     listeners.remove(listener); [EOL] } 
 [LINE] public L[] getListeners() { [LINE] public L[] getListeners() { [EOL]     return listeners.toArray(prototypeArray); [EOL] } 
 [LINE] return listeners.toArray(prototypeArray); [LINE] public L[] getListeners() { [EOL]     return listeners.toArray(prototypeArray); [EOL] } 
 [LINE] private void writeObject(final ObjectOutputStream objectOutputStream) throws IOException { [LINE] private void writeObject(final ObjectOutputStream objectOutputStream) throws IOException { [EOL]     final ArrayList<L> serializableListeners = new ArrayList<L>(); [EOL]     ObjectOutputStream testObjectOutputStream = new ObjectOutputStream(new ByteArrayOutputStream()); [EOL]     for (final L listener : listeners) { [EOL]         try { [EOL]             testObjectOutputStream.writeObject(listener); [EOL]             serializableListeners.add(listener); [EOL]         } catch (final IOException exception) { [EOL]             testObjectOutputStream = new ObjectOutputStream(new ByteArrayOutputStream()); [EOL]         } [EOL]     } [EOL]     objectOutputStream.writeObject(serializableListeners.toArray(prototypeArray)); [EOL] } 
 [LINE] final ArrayList<L> serializableListeners = new ArrayList<L>(); [LINE] private void writeObject(final ObjectOutputStream objectOutputStream) throws IOException { [EOL]     final ArrayList<L> serializableListeners = new ArrayList<L>(); [EOL]     ObjectOutputStream testObjectOutputStream = new ObjectOutputStream(new ByteArrayOutputStream()); [EOL]     for (final L listener : listeners) { [EOL]         try { [EOL]             testObjectOutputStream.writeObject(listener); [EOL]             serializableListeners.add(listener); [EOL]         } catch (final IOException exception) { [EOL]             testObjectOutputStream = new ObjectOutputStream(new ByteArrayOutputStream()); [EOL]         } [EOL]     } [EOL]     objectOutputStream.writeObject(serializableListeners.toArray(prototypeArray)); [EOL] } 
 [LINE] ObjectOutputStream testObjectOutputStream = new ObjectOutputStream(new ByteArrayOutputStream()); [LINE] private void writeObject(final ObjectOutputStream objectOutputStream) throws IOException { [EOL]     final ArrayList<L> serializableListeners = new ArrayList<L>(); [EOL]     ObjectOutputStream testObjectOutputStream = new ObjectOutputStream(new ByteArrayOutputStream()); [EOL]     for (final L listener : listeners) { [EOL]         try { [EOL]             testObjectOutputStream.writeObject(listener); [EOL]             serializableListeners.add(listener); [EOL]         } catch (final IOException exception) { [EOL]             testObjectOutputStream = new ObjectOutputStream(new ByteArrayOutputStream()); [EOL]         } [EOL]     } [EOL]     objectOutputStream.writeObject(serializableListeners.toArray(prototypeArray)); [EOL] } 
 [LINE] for (final L listener : listeners) { [LINE] private void writeObject(final ObjectOutputStream objectOutputStream) throws IOException { [EOL]     final ArrayList<L> serializableListeners = new ArrayList<L>(); [EOL]     ObjectOutputStream testObjectOutputStream = new ObjectOutputStream(new ByteArrayOutputStream()); [EOL]     for (final L listener : listeners) { [EOL]         try { [EOL]             testObjectOutputStream.writeObject(listener); [EOL]             serializableListeners.add(listener); [EOL]         } catch (final IOException exception) { [EOL]             testObjectOutputStream = new ObjectOutputStream(new ByteArrayOutputStream()); [EOL]         } [EOL]     } [EOL]     objectOutputStream.writeObject(serializableListeners.toArray(prototypeArray)); [EOL] } 
 [LINE] try { [LINE] private void writeObject(final ObjectOutputStream objectOutputStream) throws IOException { [EOL]     final ArrayList<L> serializableListeners = new ArrayList<L>(); [EOL]     ObjectOutputStream testObjectOutputStream = new ObjectOutputStream(new ByteArrayOutputStream()); [EOL]     for (final L listener : listeners) { [EOL]         try { [EOL]             testObjectOutputStream.writeObject(listener); [EOL]             serializableListeners.add(listener); [EOL]         } catch (final IOException exception) { [EOL]             testObjectOutputStream = new ObjectOutputStream(new ByteArrayOutputStream()); [EOL]         } [EOL]     } [EOL]     objectOutputStream.writeObject(serializableListeners.toArray(prototypeArray)); [EOL] } 
 [LINE] testObjectOutputStream.writeObject(listener); [LINE] private void writeObject(final ObjectOutputStream objectOutputStream) throws IOException { [EOL]     final ArrayList<L> serializableListeners = new ArrayList<L>(); [EOL]     ObjectOutputStream testObjectOutputStream = new ObjectOutputStream(new ByteArrayOutputStream()); [EOL]     for (final L listener : listeners) { [EOL]         try { [EOL]             testObjectOutputStream.writeObject(listener); [EOL]             serializableListeners.add(listener); [EOL]         } catch (final IOException exception) { [EOL]             testObjectOutputStream = new ObjectOutputStream(new ByteArrayOutputStream()); [EOL]         } [EOL]     } [EOL]     objectOutputStream.writeObject(serializableListeners.toArray(prototypeArray)); [EOL] } 
 [LINE] serializableListeners.add(listener); [LINE] private void writeObject(final ObjectOutputStream objectOutputStream) throws IOException { [EOL]     final ArrayList<L> serializableListeners = new ArrayList<L>(); [EOL]     ObjectOutputStream testObjectOutputStream = new ObjectOutputStream(new ByteArrayOutputStream()); [EOL]     for (final L listener : listeners) { [EOL]         try { [EOL]             testObjectOutputStream.writeObject(listener); [EOL]             serializableListeners.add(listener); [EOL]         } catch (final IOException exception) { [EOL]             testObjectOutputStream = new ObjectOutputStream(new ByteArrayOutputStream()); [EOL]         } [EOL]     } [EOL]     objectOutputStream.writeObject(serializableListeners.toArray(prototypeArray)); [EOL] } 
 [LINE] testObjectOutputStream = new ObjectOutputStream(new ByteArrayOutputStream()); [LINE] private void writeObject(final ObjectOutputStream objectOutputStream) throws IOException { [EOL]     final ArrayList<L> serializableListeners = new ArrayList<L>(); [EOL]     ObjectOutputStream testObjectOutputStream = new ObjectOutputStream(new ByteArrayOutputStream()); [EOL]     for (final L listener : listeners) { [EOL]         try { [EOL]             testObjectOutputStream.writeObject(listener); [EOL]             serializableListeners.add(listener); [EOL]         } catch (final IOException exception) { [EOL]             testObjectOutputStream = new ObjectOutputStream(new ByteArrayOutputStream()); [EOL]         } [EOL]     } [EOL]     objectOutputStream.writeObject(serializableListeners.toArray(prototypeArray)); [EOL] } 
 [LINE] objectOutputStream.writeObject(serializableListeners.toArray(prototypeArray)); [LINE] private void writeObject(final ObjectOutputStream objectOutputStream) throws IOException { [EOL]     final ArrayList<L> serializableListeners = new ArrayList<L>(); [EOL]     ObjectOutputStream testObjectOutputStream = new ObjectOutputStream(new ByteArrayOutputStream()); [EOL]     for (final L listener : listeners) { [EOL]         try { [EOL]             testObjectOutputStream.writeObject(listener); [EOL]             serializableListeners.add(listener); [EOL]         } catch (final IOException exception) { [EOL]             testObjectOutputStream = new ObjectOutputStream(new ByteArrayOutputStream()); [EOL]         } [EOL]     } [EOL]     objectOutputStream.writeObject(serializableListeners.toArray(prototypeArray)); [EOL] } 
 [LINE] private void readObject(final ObjectInputStream objectInputStream) throws IOException, ClassNotFoundException { [LINE] private void readObject(final ObjectInputStream objectInputStream) throws IOException, ClassNotFoundException { [EOL]     @SuppressWarnings("unchecked") [EOL]     final L[] listeners = (L[]) objectInputStream.readObject(); [EOL]     this.listeners = new CopyOnWriteArrayList<L>(listeners); [EOL]     @SuppressWarnings("unchecked") [EOL]     final Class<L> listenerInterface = (Class<L>) listeners.getClass().getComponentType(); [EOL]     initializeTransientFields(listenerInterface, Thread.currentThread().getContextClassLoader()); [EOL] } 
 [LINE] @SuppressWarnings("unchecked") // Will throw CCE here if not correct [LINE] private void readObject(final ObjectInputStream objectInputStream) throws IOException, ClassNotFoundException { [EOL]     @SuppressWarnings("unchecked") [EOL]     final L[] listeners = (L[]) objectInputStream.readObject(); [EOL]     this.listeners = new CopyOnWriteArrayList<L>(listeners); [EOL]     @SuppressWarnings("unchecked") [EOL]     final Class<L> listenerInterface = (Class<L>) listeners.getClass().getComponentType(); [EOL]     initializeTransientFields(listenerInterface, Thread.currentThread().getContextClassLoader()); [EOL] } 
 [LINE] this.listeners = new CopyOnWriteArrayList<L>(listeners); [LINE] private void readObject(final ObjectInputStream objectInputStream) throws IOException, ClassNotFoundException { [EOL]     @SuppressWarnings("unchecked") [EOL]     final L[] listeners = (L[]) objectInputStream.readObject(); [EOL]     this.listeners = new CopyOnWriteArrayList<L>(listeners); [EOL]     @SuppressWarnings("unchecked") [EOL]     final Class<L> listenerInterface = (Class<L>) listeners.getClass().getComponentType(); [EOL]     initializeTransientFields(listenerInterface, Thread.currentThread().getContextClassLoader()); [EOL] } 
 [LINE] @SuppressWarnings("unchecked") // Will throw CCE here if not correct [LINE] private void readObject(final ObjectInputStream objectInputStream) throws IOException, ClassNotFoundException { [EOL]     @SuppressWarnings("unchecked") [EOL]     final L[] listeners = (L[]) objectInputStream.readObject(); [EOL]     this.listeners = new CopyOnWriteArrayList<L>(listeners); [EOL]     @SuppressWarnings("unchecked") [EOL]     final Class<L> listenerInterface = (Class<L>) listeners.getClass().getComponentType(); [EOL]     initializeTransientFields(listenerInterface, Thread.currentThread().getContextClassLoader()); [EOL] } 
 [LINE] initializeTransientFields(listenerInterface, Thread.currentThread().getContextClassLoader()); [LINE] private void readObject(final ObjectInputStream objectInputStream) throws IOException, ClassNotFoundException { [EOL]     @SuppressWarnings("unchecked") [EOL]     final L[] listeners = (L[]) objectInputStream.readObject(); [EOL]     this.listeners = new CopyOnWriteArrayList<L>(listeners); [EOL]     @SuppressWarnings("unchecked") [EOL]     final Class<L> listenerInterface = (Class<L>) listeners.getClass().getComponentType(); [EOL]     initializeTransientFields(listenerInterface, Thread.currentThread().getContextClassLoader()); [EOL] } 
 [LINE] private void initializeTransientFields(final Class<L> listenerInterface, final ClassLoader classLoader) { [LINE] private void initializeTransientFields(final Class<L> listenerInterface, final ClassLoader classLoader) { [EOL]     @SuppressWarnings("unchecked") [EOL]     final L[] array = (L[]) Array.newInstance(listenerInterface, 0); [EOL]     this.prototypeArray = array; [EOL]     createProxy(listenerInterface, classLoader); [EOL] } 
 [LINE] @SuppressWarnings("unchecked") // Will throw CCE here if not correct [LINE] private void initializeTransientFields(final Class<L> listenerInterface, final ClassLoader classLoader) { [EOL]     @SuppressWarnings("unchecked") [EOL]     final L[] array = (L[]) Array.newInstance(listenerInterface, 0); [EOL]     this.prototypeArray = array; [EOL]     createProxy(listenerInterface, classLoader); [EOL] } 
 [LINE] this.prototypeArray = array; [LINE] private void initializeTransientFields(final Class<L> listenerInterface, final ClassLoader classLoader) { [EOL]     @SuppressWarnings("unchecked") [EOL]     final L[] array = (L[]) Array.newInstance(listenerInterface, 0); [EOL]     this.prototypeArray = array; [EOL]     createProxy(listenerInterface, classLoader); [EOL] } 
 [LINE] createProxy(listenerInterface, classLoader); [LINE] private void initializeTransientFields(final Class<L> listenerInterface, final ClassLoader classLoader) { [EOL]     @SuppressWarnings("unchecked") [EOL]     final L[] array = (L[]) Array.newInstance(listenerInterface, 0); [EOL]     this.prototypeArray = array; [EOL]     createProxy(listenerInterface, classLoader); [EOL] } 
 [LINE] private void createProxy(final Class<L> listenerInterface, final ClassLoader classLoader) { [LINE] private void createProxy(final Class<L> listenerInterface, final ClassLoader classLoader) { [EOL]     proxy = listenerInterface.cast(Proxy.newProxyInstance(classLoader, new Class[] { listenerInterface }, createInvocationHandler())); [EOL] } 
 [LINE] proxy = listenerInterface.cast(Proxy.newProxyInstance(classLoader, [LINE] private void createProxy(final Class<L> listenerInterface, final ClassLoader classLoader) { [EOL]     proxy = listenerInterface.cast(Proxy.newProxyInstance(classLoader, new Class[] { listenerInterface }, createInvocationHandler())); [EOL] } 
 [LINE] protected InvocationHandler createInvocationHandler() { [LINE] protected InvocationHandler createInvocationHandler() { [EOL]     return new ProxyInvocationHandler(); [EOL] } 
 [LINE] return new ProxyInvocationHandler(); [LINE] protected InvocationHandler createInvocationHandler() { [EOL]     return new ProxyInvocationHandler(); [EOL] } 
 [LINE] @Override [LINE] @Override [EOL] public Object invoke(final Object proxy, final Method method, final Object[] args) throws Throwable { [EOL]     for (final L listener : listeners) { [EOL]         method.invoke(listener, args); [EOL]     } [EOL]     return null; [EOL] } 
 [LINE] for (final L listener : listeners) { [LINE] @Override [EOL] public Object invoke(final Object proxy, final Method method, final Object[] args) throws Throwable { [EOL]     for (final L listener : listeners) { [EOL]         method.invoke(listener, args); [EOL]     } [EOL]     return null; [EOL] } 
 [LINE] method.invoke(listener, args); [LINE] @Override [EOL] public Object invoke(final Object proxy, final Method method, final Object[] args) throws Throwable { [EOL]     for (final L listener : listeners) { [EOL]         method.invoke(listener, args); [EOL]     } [EOL]     return null; [EOL] } 
 [LINE] return null; [LINE] @Override [EOL] public Object invoke(final Object proxy, final Method method, final Object[] args) throws Throwable { [EOL]     for (final L listener : listeners) { [EOL]         method.invoke(listener, args); [EOL]     } [EOL]     return null; [EOL] } 
 [LINE] pfxLen++; [LINE] public static Number createNumber(final String str) throws NumberFormatException { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (StringUtils.isBlank(str)) { [EOL]         throw new NumberFormatException("A blank string is not a valid number"); [EOL]     } [EOL]     final String[] hex_prefixes = { "0x", "0X", "-0x", "-0X", "#", "-#" }; [EOL]     int pfxLen = 0; [EOL]     for (final String pfx : hex_prefixes) { [EOL]         if (str.startsWith(pfx)) { [EOL]             pfxLen += pfx.length(); [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (pfxLen > 0) { [EOL]         char firstSigDigit = 0; [EOL]         for (int i = pfxLen; i < str.length(); i++) { [EOL]             firstSigDigit = str.charAt(i); [EOL]             if (firstSigDigit == '0') { [EOL]                 pfxLen++; [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         final int hexDigits = str.length() - pfxLen; [EOL]         if (hexDigits > 16 || (hexDigits == 16 && firstSigDigit > '7')) { [EOL]             return createBigInteger(str); [EOL]         } [EOL]         if (hexDigits > 8 || (hexDigits == 8 && firstSigDigit > '7')) { [EOL]             return createLong(str); [EOL]         } [EOL]         return createInteger(str); [EOL]     } [EOL]     final char lastChar = str.charAt(str.length() - 1); [EOL]     String mant; [EOL]     String dec; [EOL]     String exp; [EOL]     final int decPos = str.indexOf('.'); [EOL]     final int expPos = str.indexOf('e') + str.indexOf('E') + 1; [EOL]     int numDecimals = 0; [EOL]     if (decPos > -1) { [EOL]         if (expPos > -1) { [EOL]             if (expPos < decPos || expPos > str.length()) { [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             } [EOL]             dec = str.substring(decPos + 1, expPos); [EOL]         } else { [EOL]             dec = str.substring(decPos + 1); [EOL]         } [EOL]         mant = str.substring(0, decPos); [EOL]         numDecimals = dec.length(); [EOL]     } else { [EOL]         if (expPos > -1) { [EOL]             if (expPos > str.length()) { [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             } [EOL]             mant = str.substring(0, expPos); [EOL]         } else { [EOL]             mant = str; [EOL]         } [EOL]         dec = null; [EOL]     } [EOL]     if (!Character.isDigit(lastChar) && lastChar != '.') { [EOL]         if (expPos > -1 && expPos < str.length() - 1) { [EOL]             exp = str.substring(expPos + 1, str.length() - 1); [EOL]         } else { [EOL]             exp = null; [EOL]         } [EOL]         final String numeric = str.substring(0, str.length() - 1); [EOL]         final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL]         switch(lastChar) { [EOL]             case 'l': [EOL]             case 'L': [EOL]                 if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { [EOL]                     try { [EOL]                         return createLong(numeric); [EOL]                     } catch (final NumberFormatException nfe) { [EOL]                     } [EOL]                     return createBigInteger(numeric); [EOL]                 } [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             case 'f': [EOL]             case 'F': [EOL]                 try { [EOL]                     final Float f = NumberUtils.createFloat(numeric); [EOL]                     if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL]                         return f; [EOL]                     } [EOL]                 } catch (final NumberFormatException nfe) { [EOL]                 } [EOL]             case 'd': [EOL]             case 'D': [EOL]                 try { [EOL]                     final Double d = NumberUtils.createDouble(numeric); [EOL]                     if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { [EOL]                         return d; [EOL]                     } [EOL]                 } catch (final NumberFormatException nfe) { [EOL]                 } [EOL]                 try { [EOL]                     return createBigDecimal(numeric); [EOL]                 } catch (final NumberFormatException e) { [EOL]                 } [EOL]             default: [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]         } [EOL]     } [EOL]     if (expPos > -1 && expPos < str.length() - 1) { [EOL]         exp = str.substring(expPos + 1, str.length()); [EOL]     } else { [EOL]         exp = null; [EOL]     } [EOL]     if (dec == null && exp == null) { [EOL]         try { [EOL]             return createInteger(str); [EOL]         } catch (final NumberFormatException nfe) { [EOL]         } [EOL]         try { [EOL]             return createLong(str); [EOL]         } catch (final NumberFormatException nfe) { [EOL]         } [EOL]         return createBigInteger(str); [EOL]     } [EOL]     final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL]     try { [EOL]         if (numDecimals <= 7) { [EOL]             final Float f = createFloat(str); [EOL]             if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL]                 return f; [EOL]             } [EOL]         } [EOL]     } catch (final NumberFormatException nfe) { [EOL]     } [EOL]     try { [EOL]         if (numDecimals <= 16) { [EOL]             final Double d = createDouble(str); [EOL]             if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { [EOL]                 return d; [EOL]             } [EOL]         } [EOL]     } catch (final NumberFormatException nfe) { [EOL]     } [EOL]     return createBigDecimal(str); [EOL] } 
 [LINE] return createLong(str); [LINE] public static Number createNumber(final String str) throws NumberFormatException { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (StringUtils.isBlank(str)) { [EOL]         throw new NumberFormatException("A blank string is not a valid number"); [EOL]     } [EOL]     final String[] hex_prefixes = { "0x", "0X", "-0x", "-0X", "#", "-#" }; [EOL]     int pfxLen = 0; [EOL]     for (final String pfx : hex_prefixes) { [EOL]         if (str.startsWith(pfx)) { [EOL]             pfxLen += pfx.length(); [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (pfxLen > 0) { [EOL]         char firstSigDigit = 0; [EOL]         for (int i = pfxLen; i < str.length(); i++) { [EOL]             firstSigDigit = str.charAt(i); [EOL]             if (firstSigDigit == '0') { [EOL]                 pfxLen++; [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         final int hexDigits = str.length() - pfxLen; [EOL]         if (hexDigits > 16 || (hexDigits == 16 && firstSigDigit > '7')) { [EOL]             return createBigInteger(str); [EOL]         } [EOL]         if (hexDigits > 8 || (hexDigits == 8 && firstSigDigit > '7')) { [EOL]             return createLong(str); [EOL]         } [EOL]         return createInteger(str); [EOL]     } [EOL]     final char lastChar = str.charAt(str.length() - 1); [EOL]     String mant; [EOL]     String dec; [EOL]     String exp; [EOL]     final int decPos = str.indexOf('.'); [EOL]     final int expPos = str.indexOf('e') + str.indexOf('E') + 1; [EOL]     int numDecimals = 0; [EOL]     if (decPos > -1) { [EOL]         if (expPos > -1) { [EOL]             if (expPos < decPos || expPos > str.length()) { [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             } [EOL]             dec = str.substring(decPos + 1, expPos); [EOL]         } else { [EOL]             dec = str.substring(decPos + 1); [EOL]         } [EOL]         mant = str.substring(0, decPos); [EOL]         numDecimals = dec.length(); [EOL]     } else { [EOL]         if (expPos > -1) { [EOL]             if (expPos > str.length()) { [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             } [EOL]             mant = str.substring(0, expPos); [EOL]         } else { [EOL]             mant = str; [EOL]         } [EOL]         dec = null; [EOL]     } [EOL]     if (!Character.isDigit(lastChar) && lastChar != '.') { [EOL]         if (expPos > -1 && expPos < str.length() - 1) { [EOL]             exp = str.substring(expPos + 1, str.length() - 1); [EOL]         } else { [EOL]             exp = null; [EOL]         } [EOL]         final String numeric = str.substring(0, str.length() - 1); [EOL]         final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL]         switch(lastChar) { [EOL]             case 'l': [EOL]             case 'L': [EOL]                 if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { [EOL]                     try { [EOL]                         return createLong(numeric); [EOL]                     } catch (final NumberFormatException nfe) { [EOL]                     } [EOL]                     return createBigInteger(numeric); [EOL]                 } [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             case 'f': [EOL]             case 'F': [EOL]                 try { [EOL]                     final Float f = NumberUtils.createFloat(numeric); [EOL]                     if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL]                         return f; [EOL]                     } [EOL]                 } catch (final NumberFormatException nfe) { [EOL]                 } [EOL]             case 'd': [EOL]             case 'D': [EOL]                 try { [EOL]                     final Double d = NumberUtils.createDouble(numeric); [EOL]                     if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { [EOL]                         return d; [EOL]                     } [EOL]                 } catch (final NumberFormatException nfe) { [EOL]                 } [EOL]                 try { [EOL]                     return createBigDecimal(numeric); [EOL]                 } catch (final NumberFormatException e) { [EOL]                 } [EOL]             default: [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]         } [EOL]     } [EOL]     if (expPos > -1 && expPos < str.length() - 1) { [EOL]         exp = str.substring(expPos + 1, str.length()); [EOL]     } else { [EOL]         exp = null; [EOL]     } [EOL]     if (dec == null && exp == null) { [EOL]         try { [EOL]             return createInteger(str); [EOL]         } catch (final NumberFormatException nfe) { [EOL]         } [EOL]         try { [EOL]             return createLong(str); [EOL]         } catch (final NumberFormatException nfe) { [EOL]         } [EOL]         return createBigInteger(str); [EOL]     } [EOL]     final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL]     try { [EOL]         if (numDecimals <= 7) { [EOL]             final Float f = createFloat(str); [EOL]             if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL]                 return f; [EOL]             } [EOL]         } [EOL]     } catch (final NumberFormatException nfe) { [EOL]     } [EOL]     try { [EOL]         if (numDecimals <= 16) { [EOL]             final Double d = createDouble(str); [EOL]             if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { [EOL]                 return d; [EOL]             } [EOL]         } [EOL]     } catch (final NumberFormatException nfe) { [EOL]     } [EOL]     return createBigDecimal(str); [EOL] } 
 [LINE] throw new NumberFormatException(str + " is not a valid number."); [LINE] public static Number createNumber(final String str) throws NumberFormatException { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (StringUtils.isBlank(str)) { [EOL]         throw new NumberFormatException("A blank string is not a valid number"); [EOL]     } [EOL]     final String[] hex_prefixes = { "0x", "0X", "-0x", "-0X", "#", "-#" }; [EOL]     int pfxLen = 0; [EOL]     for (final String pfx : hex_prefixes) { [EOL]         if (str.startsWith(pfx)) { [EOL]             pfxLen += pfx.length(); [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (pfxLen > 0) { [EOL]         char firstSigDigit = 0; [EOL]         for (int i = pfxLen; i < str.length(); i++) { [EOL]             firstSigDigit = str.charAt(i); [EOL]             if (firstSigDigit == '0') { [EOL]                 pfxLen++; [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         final int hexDigits = str.length() - pfxLen; [EOL]         if (hexDigits > 16 || (hexDigits == 16 && firstSigDigit > '7')) { [EOL]             return createBigInteger(str); [EOL]         } [EOL]         if (hexDigits > 8 || (hexDigits == 8 && firstSigDigit > '7')) { [EOL]             return createLong(str); [EOL]         } [EOL]         return createInteger(str); [EOL]     } [EOL]     final char lastChar = str.charAt(str.length() - 1); [EOL]     String mant; [EOL]     String dec; [EOL]     String exp; [EOL]     final int decPos = str.indexOf('.'); [EOL]     final int expPos = str.indexOf('e') + str.indexOf('E') + 1; [EOL]     int numDecimals = 0; [EOL]     if (decPos > -1) { [EOL]         if (expPos > -1) { [EOL]             if (expPos < decPos || expPos > str.length()) { [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             } [EOL]             dec = str.substring(decPos + 1, expPos); [EOL]         } else { [EOL]             dec = str.substring(decPos + 1); [EOL]         } [EOL]         mant = str.substring(0, decPos); [EOL]         numDecimals = dec.length(); [EOL]     } else { [EOL]         if (expPos > -1) { [EOL]             if (expPos > str.length()) { [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             } [EOL]             mant = str.substring(0, expPos); [EOL]         } else { [EOL]             mant = str; [EOL]         } [EOL]         dec = null; [EOL]     } [EOL]     if (!Character.isDigit(lastChar) && lastChar != '.') { [EOL]         if (expPos > -1 && expPos < str.length() - 1) { [EOL]             exp = str.substring(expPos + 1, str.length() - 1); [EOL]         } else { [EOL]             exp = null; [EOL]         } [EOL]         final String numeric = str.substring(0, str.length() - 1); [EOL]         final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL]         switch(lastChar) { [EOL]             case 'l': [EOL]             case 'L': [EOL]                 if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { [EOL]                     try { [EOL]                         return createLong(numeric); [EOL]                     } catch (final NumberFormatException nfe) { [EOL]                     } [EOL]                     return createBigInteger(numeric); [EOL]                 } [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             case 'f': [EOL]             case 'F': [EOL]                 try { [EOL]                     final Float f = NumberUtils.createFloat(numeric); [EOL]                     if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL]                         return f; [EOL]                     } [EOL]                 } catch (final NumberFormatException nfe) { [EOL]                 } [EOL]             case 'd': [EOL]             case 'D': [EOL]                 try { [EOL]                     final Double d = NumberUtils.createDouble(numeric); [EOL]                     if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { [EOL]                         return d; [EOL]                     } [EOL]                 } catch (final NumberFormatException nfe) { [EOL]                 } [EOL]                 try { [EOL]                     return createBigDecimal(numeric); [EOL]                 } catch (final NumberFormatException e) { [EOL]                 } [EOL]             default: [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]         } [EOL]     } [EOL]     if (expPos > -1 && expPos < str.length() - 1) { [EOL]         exp = str.substring(expPos + 1, str.length()); [EOL]     } else { [EOL]         exp = null; [EOL]     } [EOL]     if (dec == null && exp == null) { [EOL]         try { [EOL]             return createInteger(str); [EOL]         } catch (final NumberFormatException nfe) { [EOL]         } [EOL]         try { [EOL]             return createLong(str); [EOL]         } catch (final NumberFormatException nfe) { [EOL]         } [EOL]         return createBigInteger(str); [EOL]     } [EOL]     final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL]     try { [EOL]         if (numDecimals <= 7) { [EOL]             final Float f = createFloat(str); [EOL]             if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL]                 return f; [EOL]             } [EOL]         } [EOL]     } catch (final NumberFormatException nfe) { [EOL]     } [EOL]     try { [EOL]         if (numDecimals <= 16) { [EOL]             final Double d = createDouble(str); [EOL]             if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { [EOL]                 return d; [EOL]             } [EOL]         } [EOL]     } catch (final NumberFormatException nfe) { [EOL]     } [EOL]     return createBigDecimal(str); [EOL] } 
 [LINE] case 'l' : [LINE] public static Number createNumber(final String str) throws NumberFormatException { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (StringUtils.isBlank(str)) { [EOL]         throw new NumberFormatException("A blank string is not a valid number"); [EOL]     } [EOL]     final String[] hex_prefixes = { "0x", "0X", "-0x", "-0X", "#", "-#" }; [EOL]     int pfxLen = 0; [EOL]     for (final String pfx : hex_prefixes) { [EOL]         if (str.startsWith(pfx)) { [EOL]             pfxLen += pfx.length(); [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (pfxLen > 0) { [EOL]         char firstSigDigit = 0; [EOL]         for (int i = pfxLen; i < str.length(); i++) { [EOL]             firstSigDigit = str.charAt(i); [EOL]             if (firstSigDigit == '0') { [EOL]                 pfxLen++; [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         final int hexDigits = str.length() - pfxLen; [EOL]         if (hexDigits > 16 || (hexDigits == 16 && firstSigDigit > '7')) { [EOL]             return createBigInteger(str); [EOL]         } [EOL]         if (hexDigits > 8 || (hexDigits == 8 && firstSigDigit > '7')) { [EOL]             return createLong(str); [EOL]         } [EOL]         return createInteger(str); [EOL]     } [EOL]     final char lastChar = str.charAt(str.length() - 1); [EOL]     String mant; [EOL]     String dec; [EOL]     String exp; [EOL]     final int decPos = str.indexOf('.'); [EOL]     final int expPos = str.indexOf('e') + str.indexOf('E') + 1; [EOL]     int numDecimals = 0; [EOL]     if (decPos > -1) { [EOL]         if (expPos > -1) { [EOL]             if (expPos < decPos || expPos > str.length()) { [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             } [EOL]             dec = str.substring(decPos + 1, expPos); [EOL]         } else { [EOL]             dec = str.substring(decPos + 1); [EOL]         } [EOL]         mant = str.substring(0, decPos); [EOL]         numDecimals = dec.length(); [EOL]     } else { [EOL]         if (expPos > -1) { [EOL]             if (expPos > str.length()) { [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             } [EOL]             mant = str.substring(0, expPos); [EOL]         } else { [EOL]             mant = str; [EOL]         } [EOL]         dec = null; [EOL]     } [EOL]     if (!Character.isDigit(lastChar) && lastChar != '.') { [EOL]         if (expPos > -1 && expPos < str.length() - 1) { [EOL]             exp = str.substring(expPos + 1, str.length() - 1); [EOL]         } else { [EOL]             exp = null; [EOL]         } [EOL]         final String numeric = str.substring(0, str.length() - 1); [EOL]         final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL]         switch(lastChar) { [EOL]             case 'l': [EOL]             case 'L': [EOL]                 if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { [EOL]                     try { [EOL]                         return createLong(numeric); [EOL]                     } catch (final NumberFormatException nfe) { [EOL]                     } [EOL]                     return createBigInteger(numeric); [EOL]                 } [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             case 'f': [EOL]             case 'F': [EOL]                 try { [EOL]                     final Float f = NumberUtils.createFloat(numeric); [EOL]                     if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL]                         return f; [EOL]                     } [EOL]                 } catch (final NumberFormatException nfe) { [EOL]                 } [EOL]             case 'd': [EOL]             case 'D': [EOL]                 try { [EOL]                     final Double d = NumberUtils.createDouble(numeric); [EOL]                     if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { [EOL]                         return d; [EOL]                     } [EOL]                 } catch (final NumberFormatException nfe) { [EOL]                 } [EOL]                 try { [EOL]                     return createBigDecimal(numeric); [EOL]                 } catch (final NumberFormatException e) { [EOL]                 } [EOL]             default: [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]         } [EOL]     } [EOL]     if (expPos > -1 && expPos < str.length() - 1) { [EOL]         exp = str.substring(expPos + 1, str.length()); [EOL]     } else { [EOL]         exp = null; [EOL]     } [EOL]     if (dec == null && exp == null) { [EOL]         try { [EOL]             return createInteger(str); [EOL]         } catch (final NumberFormatException nfe) { [EOL]         } [EOL]         try { [EOL]             return createLong(str); [EOL]         } catch (final NumberFormatException nfe) { [EOL]         } [EOL]         return createBigInteger(str); [EOL]     } [EOL]     final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL]     try { [EOL]         if (numDecimals <= 7) { [EOL]             final Float f = createFloat(str); [EOL]             if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL]                 return f; [EOL]             } [EOL]         } [EOL]     } catch (final NumberFormatException nfe) { [EOL]     } [EOL]     try { [EOL]         if (numDecimals <= 16) { [EOL]             final Double d = createDouble(str); [EOL]             if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { [EOL]                 return d; [EOL]             } [EOL]         } [EOL]     } catch (final NumberFormatException nfe) { [EOL]     } [EOL]     return createBigDecimal(str); [EOL] } 
 [LINE] try { [LINE] public static Number createNumber(final String str) throws NumberFormatException { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (StringUtils.isBlank(str)) { [EOL]         throw new NumberFormatException("A blank string is not a valid number"); [EOL]     } [EOL]     final String[] hex_prefixes = { "0x", "0X", "-0x", "-0X", "#", "-#" }; [EOL]     int pfxLen = 0; [EOL]     for (final String pfx : hex_prefixes) { [EOL]         if (str.startsWith(pfx)) { [EOL]             pfxLen += pfx.length(); [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (pfxLen > 0) { [EOL]         char firstSigDigit = 0; [EOL]         for (int i = pfxLen; i < str.length(); i++) { [EOL]             firstSigDigit = str.charAt(i); [EOL]             if (firstSigDigit == '0') { [EOL]                 pfxLen++; [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         final int hexDigits = str.length() - pfxLen; [EOL]         if (hexDigits > 16 || (hexDigits == 16 && firstSigDigit > '7')) { [EOL]             return createBigInteger(str); [EOL]         } [EOL]         if (hexDigits > 8 || (hexDigits == 8 && firstSigDigit > '7')) { [EOL]             return createLong(str); [EOL]         } [EOL]         return createInteger(str); [EOL]     } [EOL]     final char lastChar = str.charAt(str.length() - 1); [EOL]     String mant; [EOL]     String dec; [EOL]     String exp; [EOL]     final int decPos = str.indexOf('.'); [EOL]     final int expPos = str.indexOf('e') + str.indexOf('E') + 1; [EOL]     int numDecimals = 0; [EOL]     if (decPos > -1) { [EOL]         if (expPos > -1) { [EOL]             if (expPos < decPos || expPos > str.length()) { [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             } [EOL]             dec = str.substring(decPos + 1, expPos); [EOL]         } else { [EOL]             dec = str.substring(decPos + 1); [EOL]         } [EOL]         mant = str.substring(0, decPos); [EOL]         numDecimals = dec.length(); [EOL]     } else { [EOL]         if (expPos > -1) { [EOL]             if (expPos > str.length()) { [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             } [EOL]             mant = str.substring(0, expPos); [EOL]         } else { [EOL]             mant = str; [EOL]         } [EOL]         dec = null; [EOL]     } [EOL]     if (!Character.isDigit(lastChar) && lastChar != '.') { [EOL]         if (expPos > -1 && expPos < str.length() - 1) { [EOL]             exp = str.substring(expPos + 1, str.length() - 1); [EOL]         } else { [EOL]             exp = null; [EOL]         } [EOL]         final String numeric = str.substring(0, str.length() - 1); [EOL]         final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL]         switch(lastChar) { [EOL]             case 'l': [EOL]             case 'L': [EOL]                 if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { [EOL]                     try { [EOL]                         return createLong(numeric); [EOL]                     } catch (final NumberFormatException nfe) { [EOL]                     } [EOL]                     return createBigInteger(numeric); [EOL]                 } [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             case 'f': [EOL]             case 'F': [EOL]                 try { [EOL]                     final Float f = NumberUtils.createFloat(numeric); [EOL]                     if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL]                         return f; [EOL]                     } [EOL]                 } catch (final NumberFormatException nfe) { [EOL]                 } [EOL]             case 'd': [EOL]             case 'D': [EOL]                 try { [EOL]                     final Double d = NumberUtils.createDouble(numeric); [EOL]                     if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { [EOL]                         return d; [EOL]                     } [EOL]                 } catch (final NumberFormatException nfe) { [EOL]                 } [EOL]                 try { [EOL]                     return createBigDecimal(numeric); [EOL]                 } catch (final NumberFormatException e) { [EOL]                 } [EOL]             default: [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]         } [EOL]     } [EOL]     if (expPos > -1 && expPos < str.length() - 1) { [EOL]         exp = str.substring(expPos + 1, str.length()); [EOL]     } else { [EOL]         exp = null; [EOL]     } [EOL]     if (dec == null && exp == null) { [EOL]         try { [EOL]             return createInteger(str); [EOL]         } catch (final NumberFormatException nfe) { [EOL]         } [EOL]         try { [EOL]             return createLong(str); [EOL]         } catch (final NumberFormatException nfe) { [EOL]         } [EOL]         return createBigInteger(str); [EOL]     } [EOL]     final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL]     try { [EOL]         if (numDecimals <= 7) { [EOL]             final Float f = createFloat(str); [EOL]             if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL]                 return f; [EOL]             } [EOL]         } [EOL]     } catch (final NumberFormatException nfe) { [EOL]     } [EOL]     try { [EOL]         if (numDecimals <= 16) { [EOL]             final Double d = createDouble(str); [EOL]             if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { [EOL]                 return d; [EOL]             } [EOL]         } [EOL]     } catch (final NumberFormatException nfe) { [EOL]     } [EOL]     return createBigDecimal(str); [EOL] } 
 [LINE] return createLong(numeric); [LINE] public static Number createNumber(final String str) throws NumberFormatException { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (StringUtils.isBlank(str)) { [EOL]         throw new NumberFormatException("A blank string is not a valid number"); [EOL]     } [EOL]     final String[] hex_prefixes = { "0x", "0X", "-0x", "-0X", "#", "-#" }; [EOL]     int pfxLen = 0; [EOL]     for (final String pfx : hex_prefixes) { [EOL]         if (str.startsWith(pfx)) { [EOL]             pfxLen += pfx.length(); [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (pfxLen > 0) { [EOL]         char firstSigDigit = 0; [EOL]         for (int i = pfxLen; i < str.length(); i++) { [EOL]             firstSigDigit = str.charAt(i); [EOL]             if (firstSigDigit == '0') { [EOL]                 pfxLen++; [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         final int hexDigits = str.length() - pfxLen; [EOL]         if (hexDigits > 16 || (hexDigits == 16 && firstSigDigit > '7')) { [EOL]             return createBigInteger(str); [EOL]         } [EOL]         if (hexDigits > 8 || (hexDigits == 8 && firstSigDigit > '7')) { [EOL]             return createLong(str); [EOL]         } [EOL]         return createInteger(str); [EOL]     } [EOL]     final char lastChar = str.charAt(str.length() - 1); [EOL]     String mant; [EOL]     String dec; [EOL]     String exp; [EOL]     final int decPos = str.indexOf('.'); [EOL]     final int expPos = str.indexOf('e') + str.indexOf('E') + 1; [EOL]     int numDecimals = 0; [EOL]     if (decPos > -1) { [EOL]         if (expPos > -1) { [EOL]             if (expPos < decPos || expPos > str.length()) { [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             } [EOL]             dec = str.substring(decPos + 1, expPos); [EOL]         } else { [EOL]             dec = str.substring(decPos + 1); [EOL]         } [EOL]         mant = str.substring(0, decPos); [EOL]         numDecimals = dec.length(); [EOL]     } else { [EOL]         if (expPos > -1) { [EOL]             if (expPos > str.length()) { [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             } [EOL]             mant = str.substring(0, expPos); [EOL]         } else { [EOL]             mant = str; [EOL]         } [EOL]         dec = null; [EOL]     } [EOL]     if (!Character.isDigit(lastChar) && lastChar != '.') { [EOL]         if (expPos > -1 && expPos < str.length() - 1) { [EOL]             exp = str.substring(expPos + 1, str.length() - 1); [EOL]         } else { [EOL]             exp = null; [EOL]         } [EOL]         final String numeric = str.substring(0, str.length() - 1); [EOL]         final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL]         switch(lastChar) { [EOL]             case 'l': [EOL]             case 'L': [EOL]                 if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { [EOL]                     try { [EOL]                         return createLong(numeric); [EOL]                     } catch (final NumberFormatException nfe) { [EOL]                     } [EOL]                     return createBigInteger(numeric); [EOL]                 } [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             case 'f': [EOL]             case 'F': [EOL]                 try { [EOL]                     final Float f = NumberUtils.createFloat(numeric); [EOL]                     if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL]                         return f; [EOL]                     } [EOL]                 } catch (final NumberFormatException nfe) { [EOL]                 } [EOL]             case 'd': [EOL]             case 'D': [EOL]                 try { [EOL]                     final Double d = NumberUtils.createDouble(numeric); [EOL]                     if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { [EOL]                         return d; [EOL]                     } [EOL]                 } catch (final NumberFormatException nfe) { [EOL]                 } [EOL]                 try { [EOL]                     return createBigDecimal(numeric); [EOL]                 } catch (final NumberFormatException e) { [EOL]                 } [EOL]             default: [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]         } [EOL]     } [EOL]     if (expPos > -1 && expPos < str.length() - 1) { [EOL]         exp = str.substring(expPos + 1, str.length()); [EOL]     } else { [EOL]         exp = null; [EOL]     } [EOL]     if (dec == null && exp == null) { [EOL]         try { [EOL]             return createInteger(str); [EOL]         } catch (final NumberFormatException nfe) { [EOL]         } [EOL]         try { [EOL]             return createLong(str); [EOL]         } catch (final NumberFormatException nfe) { [EOL]         } [EOL]         return createBigInteger(str); [EOL]     } [EOL]     final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL]     try { [EOL]         if (numDecimals <= 7) { [EOL]             final Float f = createFloat(str); [EOL]             if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL]                 return f; [EOL]             } [EOL]         } [EOL]     } catch (final NumberFormatException nfe) { [EOL]     } [EOL]     try { [EOL]         if (numDecimals <= 16) { [EOL]             final Double d = createDouble(str); [EOL]             if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { [EOL]                 return d; [EOL]             } [EOL]         } [EOL]     } catch (final NumberFormatException nfe) { [EOL]     } [EOL]     return createBigDecimal(str); [EOL] } 
 [LINE] return createBigInteger(numeric); [LINE] public static Number createNumber(final String str) throws NumberFormatException { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (StringUtils.isBlank(str)) { [EOL]         throw new NumberFormatException("A blank string is not a valid number"); [EOL]     } [EOL]     final String[] hex_prefixes = { "0x", "0X", "-0x", "-0X", "#", "-#" }; [EOL]     int pfxLen = 0; [EOL]     for (final String pfx : hex_prefixes) { [EOL]         if (str.startsWith(pfx)) { [EOL]             pfxLen += pfx.length(); [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (pfxLen > 0) { [EOL]         char firstSigDigit = 0; [EOL]         for (int i = pfxLen; i < str.length(); i++) { [EOL]             firstSigDigit = str.charAt(i); [EOL]             if (firstSigDigit == '0') { [EOL]                 pfxLen++; [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         final int hexDigits = str.length() - pfxLen; [EOL]         if (hexDigits > 16 || (hexDigits == 16 && firstSigDigit > '7')) { [EOL]             return createBigInteger(str); [EOL]         } [EOL]         if (hexDigits > 8 || (hexDigits == 8 && firstSigDigit > '7')) { [EOL]             return createLong(str); [EOL]         } [EOL]         return createInteger(str); [EOL]     } [EOL]     final char lastChar = str.charAt(str.length() - 1); [EOL]     String mant; [EOL]     String dec; [EOL]     String exp; [EOL]     final int decPos = str.indexOf('.'); [EOL]     final int expPos = str.indexOf('e') + str.indexOf('E') + 1; [EOL]     int numDecimals = 0; [EOL]     if (decPos > -1) { [EOL]         if (expPos > -1) { [EOL]             if (expPos < decPos || expPos > str.length()) { [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             } [EOL]             dec = str.substring(decPos + 1, expPos); [EOL]         } else { [EOL]             dec = str.substring(decPos + 1); [EOL]         } [EOL]         mant = str.substring(0, decPos); [EOL]         numDecimals = dec.length(); [EOL]     } else { [EOL]         if (expPos > -1) { [EOL]             if (expPos > str.length()) { [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             } [EOL]             mant = str.substring(0, expPos); [EOL]         } else { [EOL]             mant = str; [EOL]         } [EOL]         dec = null; [EOL]     } [EOL]     if (!Character.isDigit(lastChar) && lastChar != '.') { [EOL]         if (expPos > -1 && expPos < str.length() - 1) { [EOL]             exp = str.substring(expPos + 1, str.length() - 1); [EOL]         } else { [EOL]             exp = null; [EOL]         } [EOL]         final String numeric = str.substring(0, str.length() - 1); [EOL]         final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL]         switch(lastChar) { [EOL]             case 'l': [EOL]             case 'L': [EOL]                 if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { [EOL]                     try { [EOL]                         return createLong(numeric); [EOL]                     } catch (final NumberFormatException nfe) { [EOL]                     } [EOL]                     return createBigInteger(numeric); [EOL]                 } [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             case 'f': [EOL]             case 'F': [EOL]                 try { [EOL]                     final Float f = NumberUtils.createFloat(numeric); [EOL]                     if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL]                         return f; [EOL]                     } [EOL]                 } catch (final NumberFormatException nfe) { [EOL]                 } [EOL]             case 'd': [EOL]             case 'D': [EOL]                 try { [EOL]                     final Double d = NumberUtils.createDouble(numeric); [EOL]                     if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { [EOL]                         return d; [EOL]                     } [EOL]                 } catch (final NumberFormatException nfe) { [EOL]                 } [EOL]                 try { [EOL]                     return createBigDecimal(numeric); [EOL]                 } catch (final NumberFormatException e) { [EOL]                 } [EOL]             default: [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]         } [EOL]     } [EOL]     if (expPos > -1 && expPos < str.length() - 1) { [EOL]         exp = str.substring(expPos + 1, str.length()); [EOL]     } else { [EOL]         exp = null; [EOL]     } [EOL]     if (dec == null && exp == null) { [EOL]         try { [EOL]             return createInteger(str); [EOL]         } catch (final NumberFormatException nfe) { [EOL]         } [EOL]         try { [EOL]             return createLong(str); [EOL]         } catch (final NumberFormatException nfe) { [EOL]         } [EOL]         return createBigInteger(str); [EOL]     } [EOL]     final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL]     try { [EOL]         if (numDecimals <= 7) { [EOL]             final Float f = createFloat(str); [EOL]             if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL]                 return f; [EOL]             } [EOL]         } [EOL]     } catch (final NumberFormatException nfe) { [EOL]     } [EOL]     try { [EOL]         if (numDecimals <= 16) { [EOL]             final Double d = createDouble(str); [EOL]             if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { [EOL]                 return d; [EOL]             } [EOL]         } [EOL]     } catch (final NumberFormatException nfe) { [EOL]     } [EOL]     return createBigDecimal(str); [EOL] } 
 [LINE] throw new NumberFormatException(str + " is not a valid number."); [LINE] public static Number createNumber(final String str) throws NumberFormatException { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (StringUtils.isBlank(str)) { [EOL]         throw new NumberFormatException("A blank string is not a valid number"); [EOL]     } [EOL]     final String[] hex_prefixes = { "0x", "0X", "-0x", "-0X", "#", "-#" }; [EOL]     int pfxLen = 0; [EOL]     for (final String pfx : hex_prefixes) { [EOL]         if (str.startsWith(pfx)) { [EOL]             pfxLen += pfx.length(); [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (pfxLen > 0) { [EOL]         char firstSigDigit = 0; [EOL]         for (int i = pfxLen; i < str.length(); i++) { [EOL]             firstSigDigit = str.charAt(i); [EOL]             if (firstSigDigit == '0') { [EOL]                 pfxLen++; [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         final int hexDigits = str.length() - pfxLen; [EOL]         if (hexDigits > 16 || (hexDigits == 16 && firstSigDigit > '7')) { [EOL]             return createBigInteger(str); [EOL]         } [EOL]         if (hexDigits > 8 || (hexDigits == 8 && firstSigDigit > '7')) { [EOL]             return createLong(str); [EOL]         } [EOL]         return createInteger(str); [EOL]     } [EOL]     final char lastChar = str.charAt(str.length() - 1); [EOL]     String mant; [EOL]     String dec; [EOL]     String exp; [EOL]     final int decPos = str.indexOf('.'); [EOL]     final int expPos = str.indexOf('e') + str.indexOf('E') + 1; [EOL]     int numDecimals = 0; [EOL]     if (decPos > -1) { [EOL]         if (expPos > -1) { [EOL]             if (expPos < decPos || expPos > str.length()) { [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             } [EOL]             dec = str.substring(decPos + 1, expPos); [EOL]         } else { [EOL]             dec = str.substring(decPos + 1); [EOL]         } [EOL]         mant = str.substring(0, decPos); [EOL]         numDecimals = dec.length(); [EOL]     } else { [EOL]         if (expPos > -1) { [EOL]             if (expPos > str.length()) { [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             } [EOL]             mant = str.substring(0, expPos); [EOL]         } else { [EOL]             mant = str; [EOL]         } [EOL]         dec = null; [EOL]     } [EOL]     if (!Character.isDigit(lastChar) && lastChar != '.') { [EOL]         if (expPos > -1 && expPos < str.length() - 1) { [EOL]             exp = str.substring(expPos + 1, str.length() - 1); [EOL]         } else { [EOL]             exp = null; [EOL]         } [EOL]         final String numeric = str.substring(0, str.length() - 1); [EOL]         final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL]         switch(lastChar) { [EOL]             case 'l': [EOL]             case 'L': [EOL]                 if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { [EOL]                     try { [EOL]                         return createLong(numeric); [EOL]                     } catch (final NumberFormatException nfe) { [EOL]                     } [EOL]                     return createBigInteger(numeric); [EOL]                 } [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             case 'f': [EOL]             case 'F': [EOL]                 try { [EOL]                     final Float f = NumberUtils.createFloat(numeric); [EOL]                     if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL]                         return f; [EOL]                     } [EOL]                 } catch (final NumberFormatException nfe) { [EOL]                 } [EOL]             case 'd': [EOL]             case 'D': [EOL]                 try { [EOL]                     final Double d = NumberUtils.createDouble(numeric); [EOL]                     if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { [EOL]                         return d; [EOL]                     } [EOL]                 } catch (final NumberFormatException nfe) { [EOL]                 } [EOL]                 try { [EOL]                     return createBigDecimal(numeric); [EOL]                 } catch (final NumberFormatException e) { [EOL]                 } [EOL]             default: [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]         } [EOL]     } [EOL]     if (expPos > -1 && expPos < str.length() - 1) { [EOL]         exp = str.substring(expPos + 1, str.length()); [EOL]     } else { [EOL]         exp = null; [EOL]     } [EOL]     if (dec == null && exp == null) { [EOL]         try { [EOL]             return createInteger(str); [EOL]         } catch (final NumberFormatException nfe) { [EOL]         } [EOL]         try { [EOL]             return createLong(str); [EOL]         } catch (final NumberFormatException nfe) { [EOL]         } [EOL]         return createBigInteger(str); [EOL]     } [EOL]     final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL]     try { [EOL]         if (numDecimals <= 7) { [EOL]             final Float f = createFloat(str); [EOL]             if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL]                 return f; [EOL]             } [EOL]         } [EOL]     } catch (final NumberFormatException nfe) { [EOL]     } [EOL]     try { [EOL]         if (numDecimals <= 16) { [EOL]             final Double d = createDouble(str); [EOL]             if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { [EOL]                 return d; [EOL]             } [EOL]         } [EOL]     } catch (final NumberFormatException nfe) { [EOL]     } [EOL]     return createBigDecimal(str); [EOL] } 
 [LINE] case 'f' : [LINE] public static Number createNumber(final String str) throws NumberFormatException { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (StringUtils.isBlank(str)) { [EOL]         throw new NumberFormatException("A blank string is not a valid number"); [EOL]     } [EOL]     final String[] hex_prefixes = { "0x", "0X", "-0x", "-0X", "#", "-#" }; [EOL]     int pfxLen = 0; [EOL]     for (final String pfx : hex_prefixes) { [EOL]         if (str.startsWith(pfx)) { [EOL]             pfxLen += pfx.length(); [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (pfxLen > 0) { [EOL]         char firstSigDigit = 0; [EOL]         for (int i = pfxLen; i < str.length(); i++) { [EOL]             firstSigDigit = str.charAt(i); [EOL]             if (firstSigDigit == '0') { [EOL]                 pfxLen++; [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         final int hexDigits = str.length() - pfxLen; [EOL]         if (hexDigits > 16 || (hexDigits == 16 && firstSigDigit > '7')) { [EOL]             return createBigInteger(str); [EOL]         } [EOL]         if (hexDigits > 8 || (hexDigits == 8 && firstSigDigit > '7')) { [EOL]             return createLong(str); [EOL]         } [EOL]         return createInteger(str); [EOL]     } [EOL]     final char lastChar = str.charAt(str.length() - 1); [EOL]     String mant; [EOL]     String dec; [EOL]     String exp; [EOL]     final int decPos = str.indexOf('.'); [EOL]     final int expPos = str.indexOf('e') + str.indexOf('E') + 1; [EOL]     int numDecimals = 0; [EOL]     if (decPos > -1) { [EOL]         if (expPos > -1) { [EOL]             if (expPos < decPos || expPos > str.length()) { [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             } [EOL]             dec = str.substring(decPos + 1, expPos); [EOL]         } else { [EOL]             dec = str.substring(decPos + 1); [EOL]         } [EOL]         mant = str.substring(0, decPos); [EOL]         numDecimals = dec.length(); [EOL]     } else { [EOL]         if (expPos > -1) { [EOL]             if (expPos > str.length()) { [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             } [EOL]             mant = str.substring(0, expPos); [EOL]         } else { [EOL]             mant = str; [EOL]         } [EOL]         dec = null; [EOL]     } [EOL]     if (!Character.isDigit(lastChar) && lastChar != '.') { [EOL]         if (expPos > -1 && expPos < str.length() - 1) { [EOL]             exp = str.substring(expPos + 1, str.length() - 1); [EOL]         } else { [EOL]             exp = null; [EOL]         } [EOL]         final String numeric = str.substring(0, str.length() - 1); [EOL]         final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL]         switch(lastChar) { [EOL]             case 'l': [EOL]             case 'L': [EOL]                 if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { [EOL]                     try { [EOL]                         return createLong(numeric); [EOL]                     } catch (final NumberFormatException nfe) { [EOL]                     } [EOL]                     return createBigInteger(numeric); [EOL]                 } [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             case 'f': [EOL]             case 'F': [EOL]                 try { [EOL]                     final Float f = NumberUtils.createFloat(numeric); [EOL]                     if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL]                         return f; [EOL]                     } [EOL]                 } catch (final NumberFormatException nfe) { [EOL]                 } [EOL]             case 'd': [EOL]             case 'D': [EOL]                 try { [EOL]                     final Double d = NumberUtils.createDouble(numeric); [EOL]                     if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { [EOL]                         return d; [EOL]                     } [EOL]                 } catch (final NumberFormatException nfe) { [EOL]                 } [EOL]                 try { [EOL]                     return createBigDecimal(numeric); [EOL]                 } catch (final NumberFormatException e) { [EOL]                 } [EOL]             default: [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]         } [EOL]     } [EOL]     if (expPos > -1 && expPos < str.length() - 1) { [EOL]         exp = str.substring(expPos + 1, str.length()); [EOL]     } else { [EOL]         exp = null; [EOL]     } [EOL]     if (dec == null && exp == null) { [EOL]         try { [EOL]             return createInteger(str); [EOL]         } catch (final NumberFormatException nfe) { [EOL]         } [EOL]         try { [EOL]             return createLong(str); [EOL]         } catch (final NumberFormatException nfe) { [EOL]         } [EOL]         return createBigInteger(str); [EOL]     } [EOL]     final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL]     try { [EOL]         if (numDecimals <= 7) { [EOL]             final Float f = createFloat(str); [EOL]             if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL]                 return f; [EOL]             } [EOL]         } [EOL]     } catch (final NumberFormatException nfe) { [EOL]     } [EOL]     try { [EOL]         if (numDecimals <= 16) { [EOL]             final Double d = createDouble(str); [EOL]             if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { [EOL]                 return d; [EOL]             } [EOL]         } [EOL]     } catch (final NumberFormatException nfe) { [EOL]     } [EOL]     return createBigDecimal(str); [EOL] } 
 [LINE] if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [LINE] public static Number createNumber(final String str) throws NumberFormatException { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (StringUtils.isBlank(str)) { [EOL]         throw new NumberFormatException("A blank string is not a valid number"); [EOL]     } [EOL]     final String[] hex_prefixes = { "0x", "0X", "-0x", "-0X", "#", "-#" }; [EOL]     int pfxLen = 0; [EOL]     for (final String pfx : hex_prefixes) { [EOL]         if (str.startsWith(pfx)) { [EOL]             pfxLen += pfx.length(); [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (pfxLen > 0) { [EOL]         char firstSigDigit = 0; [EOL]         for (int i = pfxLen; i < str.length(); i++) { [EOL]             firstSigDigit = str.charAt(i); [EOL]             if (firstSigDigit == '0') { [EOL]                 pfxLen++; [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         final int hexDigits = str.length() - pfxLen; [EOL]         if (hexDigits > 16 || (hexDigits == 16 && firstSigDigit > '7')) { [EOL]             return createBigInteger(str); [EOL]         } [EOL]         if (hexDigits > 8 || (hexDigits == 8 && firstSigDigit > '7')) { [EOL]             return createLong(str); [EOL]         } [EOL]         return createInteger(str); [EOL]     } [EOL]     final char lastChar = str.charAt(str.length() - 1); [EOL]     String mant; [EOL]     String dec; [EOL]     String exp; [EOL]     final int decPos = str.indexOf('.'); [EOL]     final int expPos = str.indexOf('e') + str.indexOf('E') + 1; [EOL]     int numDecimals = 0; [EOL]     if (decPos > -1) { [EOL]         if (expPos > -1) { [EOL]             if (expPos < decPos || expPos > str.length()) { [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             } [EOL]             dec = str.substring(decPos + 1, expPos); [EOL]         } else { [EOL]             dec = str.substring(decPos + 1); [EOL]         } [EOL]         mant = str.substring(0, decPos); [EOL]         numDecimals = dec.length(); [EOL]     } else { [EOL]         if (expPos > -1) { [EOL]             if (expPos > str.length()) { [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             } [EOL]             mant = str.substring(0, expPos); [EOL]         } else { [EOL]             mant = str; [EOL]         } [EOL]         dec = null; [EOL]     } [EOL]     if (!Character.isDigit(lastChar) && lastChar != '.') { [EOL]         if (expPos > -1 && expPos < str.length() - 1) { [EOL]             exp = str.substring(expPos + 1, str.length() - 1); [EOL]         } else { [EOL]             exp = null; [EOL]         } [EOL]         final String numeric = str.substring(0, str.length() - 1); [EOL]         final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL]         switch(lastChar) { [EOL]             case 'l': [EOL]             case 'L': [EOL]                 if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { [EOL]                     try { [EOL]                         return createLong(numeric); [EOL]                     } catch (final NumberFormatException nfe) { [EOL]                     } [EOL]                     return createBigInteger(numeric); [EOL]                 } [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             case 'f': [EOL]             case 'F': [EOL]                 try { [EOL]                     final Float f = NumberUtils.createFloat(numeric); [EOL]                     if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL]                         return f; [EOL]                     } [EOL]                 } catch (final NumberFormatException nfe) { [EOL]                 } [EOL]             case 'd': [EOL]             case 'D': [EOL]                 try { [EOL]                     final Double d = NumberUtils.createDouble(numeric); [EOL]                     if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { [EOL]                         return d; [EOL]                     } [EOL]                 } catch (final NumberFormatException nfe) { [EOL]                 } [EOL]                 try { [EOL]                     return createBigDecimal(numeric); [EOL]                 } catch (final NumberFormatException e) { [EOL]                 } [EOL]             default: [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]         } [EOL]     } [EOL]     if (expPos > -1 && expPos < str.length() - 1) { [EOL]         exp = str.substring(expPos + 1, str.length()); [EOL]     } else { [EOL]         exp = null; [EOL]     } [EOL]     if (dec == null && exp == null) { [EOL]         try { [EOL]             return createInteger(str); [EOL]         } catch (final NumberFormatException nfe) { [EOL]         } [EOL]         try { [EOL]             return createLong(str); [EOL]         } catch (final NumberFormatException nfe) { [EOL]         } [EOL]         return createBigInteger(str); [EOL]     } [EOL]     final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL]     try { [EOL]         if (numDecimals <= 7) { [EOL]             final Float f = createFloat(str); [EOL]             if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL]                 return f; [EOL]             } [EOL]         } [EOL]     } catch (final NumberFormatException nfe) { [EOL]     } [EOL]     try { [EOL]         if (numDecimals <= 16) { [EOL]             final Double d = createDouble(str); [EOL]             if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { [EOL]                 return d; [EOL]             } [EOL]         } [EOL]     } catch (final NumberFormatException nfe) { [EOL]     } [EOL]     return createBigDecimal(str); [EOL] } 
 [LINE] return f; [LINE] public static Number createNumber(final String str) throws NumberFormatException { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (StringUtils.isBlank(str)) { [EOL]         throw new NumberFormatException("A blank string is not a valid number"); [EOL]     } [EOL]     final String[] hex_prefixes = { "0x", "0X", "-0x", "-0X", "#", "-#" }; [EOL]     int pfxLen = 0; [EOL]     for (final String pfx : hex_prefixes) { [EOL]         if (str.startsWith(pfx)) { [EOL]             pfxLen += pfx.length(); [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (pfxLen > 0) { [EOL]         char firstSigDigit = 0; [EOL]         for (int i = pfxLen; i < str.length(); i++) { [EOL]             firstSigDigit = str.charAt(i); [EOL]             if (firstSigDigit == '0') { [EOL]                 pfxLen++; [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         final int hexDigits = str.length() - pfxLen; [EOL]         if (hexDigits > 16 || (hexDigits == 16 && firstSigDigit > '7')) { [EOL]             return createBigInteger(str); [EOL]         } [EOL]         if (hexDigits > 8 || (hexDigits == 8 && firstSigDigit > '7')) { [EOL]             return createLong(str); [EOL]         } [EOL]         return createInteger(str); [EOL]     } [EOL]     final char lastChar = str.charAt(str.length() - 1); [EOL]     String mant; [EOL]     String dec; [EOL]     String exp; [EOL]     final int decPos = str.indexOf('.'); [EOL]     final int expPos = str.indexOf('e') + str.indexOf('E') + 1; [EOL]     int numDecimals = 0; [EOL]     if (decPos > -1) { [EOL]         if (expPos > -1) { [EOL]             if (expPos < decPos || expPos > str.length()) { [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             } [EOL]             dec = str.substring(decPos + 1, expPos); [EOL]         } else { [EOL]             dec = str.substring(decPos + 1); [EOL]         } [EOL]         mant = str.substring(0, decPos); [EOL]         numDecimals = dec.length(); [EOL]     } else { [EOL]         if (expPos > -1) { [EOL]             if (expPos > str.length()) { [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             } [EOL]             mant = str.substring(0, expPos); [EOL]         } else { [EOL]             mant = str; [EOL]         } [EOL]         dec = null; [EOL]     } [EOL]     if (!Character.isDigit(lastChar) && lastChar != '.') { [EOL]         if (expPos > -1 && expPos < str.length() - 1) { [EOL]             exp = str.substring(expPos + 1, str.length() - 1); [EOL]         } else { [EOL]             exp = null; [EOL]         } [EOL]         final String numeric = str.substring(0, str.length() - 1); [EOL]         final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL]         switch(lastChar) { [EOL]             case 'l': [EOL]             case 'L': [EOL]                 if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { [EOL]                     try { [EOL]                         return createLong(numeric); [EOL]                     } catch (final NumberFormatException nfe) { [EOL]                     } [EOL]                     return createBigInteger(numeric); [EOL]                 } [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             case 'f': [EOL]             case 'F': [EOL]                 try { [EOL]                     final Float f = NumberUtils.createFloat(numeric); [EOL]                     if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL]                         return f; [EOL]                     } [EOL]                 } catch (final NumberFormatException nfe) { [EOL]                 } [EOL]             case 'd': [EOL]             case 'D': [EOL]                 try { [EOL]                     final Double d = NumberUtils.createDouble(numeric); [EOL]                     if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { [EOL]                         return d; [EOL]                     } [EOL]                 } catch (final NumberFormatException nfe) { [EOL]                 } [EOL]                 try { [EOL]                     return createBigDecimal(numeric); [EOL]                 } catch (final NumberFormatException e) { [EOL]                 } [EOL]             default: [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]         } [EOL]     } [EOL]     if (expPos > -1 && expPos < str.length() - 1) { [EOL]         exp = str.substring(expPos + 1, str.length()); [EOL]     } else { [EOL]         exp = null; [EOL]     } [EOL]     if (dec == null && exp == null) { [EOL]         try { [EOL]             return createInteger(str); [EOL]         } catch (final NumberFormatException nfe) { [EOL]         } [EOL]         try { [EOL]             return createLong(str); [EOL]         } catch (final NumberFormatException nfe) { [EOL]         } [EOL]         return createBigInteger(str); [EOL]     } [EOL]     final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL]     try { [EOL]         if (numDecimals <= 7) { [EOL]             final Float f = createFloat(str); [EOL]             if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL]                 return f; [EOL]             } [EOL]         } [EOL]     } catch (final NumberFormatException nfe) { [EOL]     } [EOL]     try { [EOL]         if (numDecimals <= 16) { [EOL]             final Double d = createDouble(str); [EOL]             if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { [EOL]                 return d; [EOL]             } [EOL]         } [EOL]     } catch (final NumberFormatException nfe) { [EOL]     } [EOL]     return createBigDecimal(str); [EOL] } 
 [LINE] case 'D' : [LINE] public static Number createNumber(final String str) throws NumberFormatException { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (StringUtils.isBlank(str)) { [EOL]         throw new NumberFormatException("A blank string is not a valid number"); [EOL]     } [EOL]     final String[] hex_prefixes = { "0x", "0X", "-0x", "-0X", "#", "-#" }; [EOL]     int pfxLen = 0; [EOL]     for (final String pfx : hex_prefixes) { [EOL]         if (str.startsWith(pfx)) { [EOL]             pfxLen += pfx.length(); [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (pfxLen > 0) { [EOL]         char firstSigDigit = 0; [EOL]         for (int i = pfxLen; i < str.length(); i++) { [EOL]             firstSigDigit = str.charAt(i); [EOL]             if (firstSigDigit == '0') { [EOL]                 pfxLen++; [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         final int hexDigits = str.length() - pfxLen; [EOL]         if (hexDigits > 16 || (hexDigits == 16 && firstSigDigit > '7')) { [EOL]             return createBigInteger(str); [EOL]         } [EOL]         if (hexDigits > 8 || (hexDigits == 8 && firstSigDigit > '7')) { [EOL]             return createLong(str); [EOL]         } [EOL]         return createInteger(str); [EOL]     } [EOL]     final char lastChar = str.charAt(str.length() - 1); [EOL]     String mant; [EOL]     String dec; [EOL]     String exp; [EOL]     final int decPos = str.indexOf('.'); [EOL]     final int expPos = str.indexOf('e') + str.indexOf('E') + 1; [EOL]     int numDecimals = 0; [EOL]     if (decPos > -1) { [EOL]         if (expPos > -1) { [EOL]             if (expPos < decPos || expPos > str.length()) { [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             } [EOL]             dec = str.substring(decPos + 1, expPos); [EOL]         } else { [EOL]             dec = str.substring(decPos + 1); [EOL]         } [EOL]         mant = str.substring(0, decPos); [EOL]         numDecimals = dec.length(); [EOL]     } else { [EOL]         if (expPos > -1) { [EOL]             if (expPos > str.length()) { [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             } [EOL]             mant = str.substring(0, expPos); [EOL]         } else { [EOL]             mant = str; [EOL]         } [EOL]         dec = null; [EOL]     } [EOL]     if (!Character.isDigit(lastChar) && lastChar != '.') { [EOL]         if (expPos > -1 && expPos < str.length() - 1) { [EOL]             exp = str.substring(expPos + 1, str.length() - 1); [EOL]         } else { [EOL]             exp = null; [EOL]         } [EOL]         final String numeric = str.substring(0, str.length() - 1); [EOL]         final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL]         switch(lastChar) { [EOL]             case 'l': [EOL]             case 'L': [EOL]                 if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { [EOL]                     try { [EOL]                         return createLong(numeric); [EOL]                     } catch (final NumberFormatException nfe) { [EOL]                     } [EOL]                     return createBigInteger(numeric); [EOL]                 } [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             case 'f': [EOL]             case 'F': [EOL]                 try { [EOL]                     final Float f = NumberUtils.createFloat(numeric); [EOL]                     if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL]                         return f; [EOL]                     } [EOL]                 } catch (final NumberFormatException nfe) { [EOL]                 } [EOL]             case 'd': [EOL]             case 'D': [EOL]                 try { [EOL]                     final Double d = NumberUtils.createDouble(numeric); [EOL]                     if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { [EOL]                         return d; [EOL]                     } [EOL]                 } catch (final NumberFormatException nfe) { [EOL]                 } [EOL]                 try { [EOL]                     return createBigDecimal(numeric); [EOL]                 } catch (final NumberFormatException e) { [EOL]                 } [EOL]             default: [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]         } [EOL]     } [EOL]     if (expPos > -1 && expPos < str.length() - 1) { [EOL]         exp = str.substring(expPos + 1, str.length()); [EOL]     } else { [EOL]         exp = null; [EOL]     } [EOL]     if (dec == null && exp == null) { [EOL]         try { [EOL]             return createInteger(str); [EOL]         } catch (final NumberFormatException nfe) { [EOL]         } [EOL]         try { [EOL]             return createLong(str); [EOL]         } catch (final NumberFormatException nfe) { [EOL]         } [EOL]         return createBigInteger(str); [EOL]     } [EOL]     final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL]     try { [EOL]         if (numDecimals <= 7) { [EOL]             final Float f = createFloat(str); [EOL]             if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL]                 return f; [EOL]             } [EOL]         } [EOL]     } catch (final NumberFormatException nfe) { [EOL]     } [EOL]     try { [EOL]         if (numDecimals <= 16) { [EOL]             final Double d = createDouble(str); [EOL]             if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { [EOL]                 return d; [EOL]             } [EOL]         } [EOL]     } catch (final NumberFormatException nfe) { [EOL]     } [EOL]     return createBigDecimal(str); [EOL] } 
 [LINE] if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { [LINE] public static Number createNumber(final String str) throws NumberFormatException { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (StringUtils.isBlank(str)) { [EOL]         throw new NumberFormatException("A blank string is not a valid number"); [EOL]     } [EOL]     final String[] hex_prefixes = { "0x", "0X", "-0x", "-0X", "#", "-#" }; [EOL]     int pfxLen = 0; [EOL]     for (final String pfx : hex_prefixes) { [EOL]         if (str.startsWith(pfx)) { [EOL]             pfxLen += pfx.length(); [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (pfxLen > 0) { [EOL]         char firstSigDigit = 0; [EOL]         for (int i = pfxLen; i < str.length(); i++) { [EOL]             firstSigDigit = str.charAt(i); [EOL]             if (firstSigDigit == '0') { [EOL]                 pfxLen++; [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         final int hexDigits = str.length() - pfxLen; [EOL]         if (hexDigits > 16 || (hexDigits == 16 && firstSigDigit > '7')) { [EOL]             return createBigInteger(str); [EOL]         } [EOL]         if (hexDigits > 8 || (hexDigits == 8 && firstSigDigit > '7')) { [EOL]             return createLong(str); [EOL]         } [EOL]         return createInteger(str); [EOL]     } [EOL]     final char lastChar = str.charAt(str.length() - 1); [EOL]     String mant; [EOL]     String dec; [EOL]     String exp; [EOL]     final int decPos = str.indexOf('.'); [EOL]     final int expPos = str.indexOf('e') + str.indexOf('E') + 1; [EOL]     int numDecimals = 0; [EOL]     if (decPos > -1) { [EOL]         if (expPos > -1) { [EOL]             if (expPos < decPos || expPos > str.length()) { [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             } [EOL]             dec = str.substring(decPos + 1, expPos); [EOL]         } else { [EOL]             dec = str.substring(decPos + 1); [EOL]         } [EOL]         mant = str.substring(0, decPos); [EOL]         numDecimals = dec.length(); [EOL]     } else { [EOL]         if (expPos > -1) { [EOL]             if (expPos > str.length()) { [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             } [EOL]             mant = str.substring(0, expPos); [EOL]         } else { [EOL]             mant = str; [EOL]         } [EOL]         dec = null; [EOL]     } [EOL]     if (!Character.isDigit(lastChar) && lastChar != '.') { [EOL]         if (expPos > -1 && expPos < str.length() - 1) { [EOL]             exp = str.substring(expPos + 1, str.length() - 1); [EOL]         } else { [EOL]             exp = null; [EOL]         } [EOL]         final String numeric = str.substring(0, str.length() - 1); [EOL]         final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL]         switch(lastChar) { [EOL]             case 'l': [EOL]             case 'L': [EOL]                 if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { [EOL]                     try { [EOL]                         return createLong(numeric); [EOL]                     } catch (final NumberFormatException nfe) { [EOL]                     } [EOL]                     return createBigInteger(numeric); [EOL]                 } [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             case 'f': [EOL]             case 'F': [EOL]                 try { [EOL]                     final Float f = NumberUtils.createFloat(numeric); [EOL]                     if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL]                         return f; [EOL]                     } [EOL]                 } catch (final NumberFormatException nfe) { [EOL]                 } [EOL]             case 'd': [EOL]             case 'D': [EOL]                 try { [EOL]                     final Double d = NumberUtils.createDouble(numeric); [EOL]                     if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { [EOL]                         return d; [EOL]                     } [EOL]                 } catch (final NumberFormatException nfe) { [EOL]                 } [EOL]                 try { [EOL]                     return createBigDecimal(numeric); [EOL]                 } catch (final NumberFormatException e) { [EOL]                 } [EOL]             default: [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]         } [EOL]     } [EOL]     if (expPos > -1 && expPos < str.length() - 1) { [EOL]         exp = str.substring(expPos + 1, str.length()); [EOL]     } else { [EOL]         exp = null; [EOL]     } [EOL]     if (dec == null && exp == null) { [EOL]         try { [EOL]             return createInteger(str); [EOL]         } catch (final NumberFormatException nfe) { [EOL]         } [EOL]         try { [EOL]             return createLong(str); [EOL]         } catch (final NumberFormatException nfe) { [EOL]         } [EOL]         return createBigInteger(str); [EOL]     } [EOL]     final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL]     try { [EOL]         if (numDecimals <= 7) { [EOL]             final Float f = createFloat(str); [EOL]             if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL]                 return f; [EOL]             } [EOL]         } [EOL]     } catch (final NumberFormatException nfe) { [EOL]     } [EOL]     try { [EOL]         if (numDecimals <= 16) { [EOL]             final Double d = createDouble(str); [EOL]             if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { [EOL]                 return d; [EOL]             } [EOL]         } [EOL]     } catch (final NumberFormatException nfe) { [EOL]     } [EOL]     return createBigDecimal(str); [EOL] } 
 [LINE] return d; [LINE] public static Number createNumber(final String str) throws NumberFormatException { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (StringUtils.isBlank(str)) { [EOL]         throw new NumberFormatException("A blank string is not a valid number"); [EOL]     } [EOL]     final String[] hex_prefixes = { "0x", "0X", "-0x", "-0X", "#", "-#" }; [EOL]     int pfxLen = 0; [EOL]     for (final String pfx : hex_prefixes) { [EOL]         if (str.startsWith(pfx)) { [EOL]             pfxLen += pfx.length(); [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (pfxLen > 0) { [EOL]         char firstSigDigit = 0; [EOL]         for (int i = pfxLen; i < str.length(); i++) { [EOL]             firstSigDigit = str.charAt(i); [EOL]             if (firstSigDigit == '0') { [EOL]                 pfxLen++; [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         final int hexDigits = str.length() - pfxLen; [EOL]         if (hexDigits > 16 || (hexDigits == 16 && firstSigDigit > '7')) { [EOL]             return createBigInteger(str); [EOL]         } [EOL]         if (hexDigits > 8 || (hexDigits == 8 && firstSigDigit > '7')) { [EOL]             return createLong(str); [EOL]         } [EOL]         return createInteger(str); [EOL]     } [EOL]     final char lastChar = str.charAt(str.length() - 1); [EOL]     String mant; [EOL]     String dec; [EOL]     String exp; [EOL]     final int decPos = str.indexOf('.'); [EOL]     final int expPos = str.indexOf('e') + str.indexOf('E') + 1; [EOL]     int numDecimals = 0; [EOL]     if (decPos > -1) { [EOL]         if (expPos > -1) { [EOL]             if (expPos < decPos || expPos > str.length()) { [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             } [EOL]             dec = str.substring(decPos + 1, expPos); [EOL]         } else { [EOL]             dec = str.substring(decPos + 1); [EOL]         } [EOL]         mant = str.substring(0, decPos); [EOL]         numDecimals = dec.length(); [EOL]     } else { [EOL]         if (expPos > -1) { [EOL]             if (expPos > str.length()) { [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             } [EOL]             mant = str.substring(0, expPos); [EOL]         } else { [EOL]             mant = str; [EOL]         } [EOL]         dec = null; [EOL]     } [EOL]     if (!Character.isDigit(lastChar) && lastChar != '.') { [EOL]         if (expPos > -1 && expPos < str.length() - 1) { [EOL]             exp = str.substring(expPos + 1, str.length() - 1); [EOL]         } else { [EOL]             exp = null; [EOL]         } [EOL]         final String numeric = str.substring(0, str.length() - 1); [EOL]         final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL]         switch(lastChar) { [EOL]             case 'l': [EOL]             case 'L': [EOL]                 if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { [EOL]                     try { [EOL]                         return createLong(numeric); [EOL]                     } catch (final NumberFormatException nfe) { [EOL]                     } [EOL]                     return createBigInteger(numeric); [EOL]                 } [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             case 'f': [EOL]             case 'F': [EOL]                 try { [EOL]                     final Float f = NumberUtils.createFloat(numeric); [EOL]                     if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL]                         return f; [EOL]                     } [EOL]                 } catch (final NumberFormatException nfe) { [EOL]                 } [EOL]             case 'd': [EOL]             case 'D': [EOL]                 try { [EOL]                     final Double d = NumberUtils.createDouble(numeric); [EOL]                     if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { [EOL]                         return d; [EOL]                     } [EOL]                 } catch (final NumberFormatException nfe) { [EOL]                 } [EOL]                 try { [EOL]                     return createBigDecimal(numeric); [EOL]                 } catch (final NumberFormatException e) { [EOL]                 } [EOL]             default: [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]         } [EOL]     } [EOL]     if (expPos > -1 && expPos < str.length() - 1) { [EOL]         exp = str.substring(expPos + 1, str.length()); [EOL]     } else { [EOL]         exp = null; [EOL]     } [EOL]     if (dec == null && exp == null) { [EOL]         try { [EOL]             return createInteger(str); [EOL]         } catch (final NumberFormatException nfe) { [EOL]         } [EOL]         try { [EOL]             return createLong(str); [EOL]         } catch (final NumberFormatException nfe) { [EOL]         } [EOL]         return createBigInteger(str); [EOL]     } [EOL]     final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL]     try { [EOL]         if (numDecimals <= 7) { [EOL]             final Float f = createFloat(str); [EOL]             if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL]                 return f; [EOL]             } [EOL]         } [EOL]     } catch (final NumberFormatException nfe) { [EOL]     } [EOL]     try { [EOL]         if (numDecimals <= 16) { [EOL]             final Double d = createDouble(str); [EOL]             if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { [EOL]                 return d; [EOL]             } [EOL]         } [EOL]     } catch (final NumberFormatException nfe) { [EOL]     } [EOL]     return createBigDecimal(str); [EOL] } 
 [LINE] exp = str.substring(expPos + 1, str.length()); [LINE] public static Number createNumber(final String str) throws NumberFormatException { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (StringUtils.isBlank(str)) { [EOL]         throw new NumberFormatException("A blank string is not a valid number"); [EOL]     } [EOL]     final String[] hex_prefixes = { "0x", "0X", "-0x", "-0X", "#", "-#" }; [EOL]     int pfxLen = 0; [EOL]     for (final String pfx : hex_prefixes) { [EOL]         if (str.startsWith(pfx)) { [EOL]             pfxLen += pfx.length(); [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (pfxLen > 0) { [EOL]         char firstSigDigit = 0; [EOL]         for (int i = pfxLen; i < str.length(); i++) { [EOL]             firstSigDigit = str.charAt(i); [EOL]             if (firstSigDigit == '0') { [EOL]                 pfxLen++; [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         final int hexDigits = str.length() - pfxLen; [EOL]         if (hexDigits > 16 || (hexDigits == 16 && firstSigDigit > '7')) { [EOL]             return createBigInteger(str); [EOL]         } [EOL]         if (hexDigits > 8 || (hexDigits == 8 && firstSigDigit > '7')) { [EOL]             return createLong(str); [EOL]         } [EOL]         return createInteger(str); [EOL]     } [EOL]     final char lastChar = str.charAt(str.length() - 1); [EOL]     String mant; [EOL]     String dec; [EOL]     String exp; [EOL]     final int decPos = str.indexOf('.'); [EOL]     final int expPos = str.indexOf('e') + str.indexOf('E') + 1; [EOL]     int numDecimals = 0; [EOL]     if (decPos > -1) { [EOL]         if (expPos > -1) { [EOL]             if (expPos < decPos || expPos > str.length()) { [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             } [EOL]             dec = str.substring(decPos + 1, expPos); [EOL]         } else { [EOL]             dec = str.substring(decPos + 1); [EOL]         } [EOL]         mant = str.substring(0, decPos); [EOL]         numDecimals = dec.length(); [EOL]     } else { [EOL]         if (expPos > -1) { [EOL]             if (expPos > str.length()) { [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             } [EOL]             mant = str.substring(0, expPos); [EOL]         } else { [EOL]             mant = str; [EOL]         } [EOL]         dec = null; [EOL]     } [EOL]     if (!Character.isDigit(lastChar) && lastChar != '.') { [EOL]         if (expPos > -1 && expPos < str.length() - 1) { [EOL]             exp = str.substring(expPos + 1, str.length() - 1); [EOL]         } else { [EOL]             exp = null; [EOL]         } [EOL]         final String numeric = str.substring(0, str.length() - 1); [EOL]         final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL]         switch(lastChar) { [EOL]             case 'l': [EOL]             case 'L': [EOL]                 if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { [EOL]                     try { [EOL]                         return createLong(numeric); [EOL]                     } catch (final NumberFormatException nfe) { [EOL]                     } [EOL]                     return createBigInteger(numeric); [EOL]                 } [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             case 'f': [EOL]             case 'F': [EOL]                 try { [EOL]                     final Float f = NumberUtils.createFloat(numeric); [EOL]                     if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL]                         return f; [EOL]                     } [EOL]                 } catch (final NumberFormatException nfe) { [EOL]                 } [EOL]             case 'd': [EOL]             case 'D': [EOL]                 try { [EOL]                     final Double d = NumberUtils.createDouble(numeric); [EOL]                     if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { [EOL]                         return d; [EOL]                     } [EOL]                 } catch (final NumberFormatException nfe) { [EOL]                 } [EOL]                 try { [EOL]                     return createBigDecimal(numeric); [EOL]                 } catch (final NumberFormatException e) { [EOL]                 } [EOL]             default: [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]         } [EOL]     } [EOL]     if (expPos > -1 && expPos < str.length() - 1) { [EOL]         exp = str.substring(expPos + 1, str.length()); [EOL]     } else { [EOL]         exp = null; [EOL]     } [EOL]     if (dec == null && exp == null) { [EOL]         try { [EOL]             return createInteger(str); [EOL]         } catch (final NumberFormatException nfe) { [EOL]         } [EOL]         try { [EOL]             return createLong(str); [EOL]         } catch (final NumberFormatException nfe) { [EOL]         } [EOL]         return createBigInteger(str); [EOL]     } [EOL]     final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL]     try { [EOL]         if (numDecimals <= 7) { [EOL]             final Float f = createFloat(str); [EOL]             if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL]                 return f; [EOL]             } [EOL]         } [EOL]     } catch (final NumberFormatException nfe) { [EOL]     } [EOL]     try { [EOL]         if (numDecimals <= 16) { [EOL]             final Double d = createDouble(str); [EOL]             if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { [EOL]                 return d; [EOL]             } [EOL]         } [EOL]     } catch (final NumberFormatException nfe) { [EOL]     } [EOL]     return createBigDecimal(str); [EOL] } 
 [LINE] try { [LINE] public static Number createNumber(final String str) throws NumberFormatException { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (StringUtils.isBlank(str)) { [EOL]         throw new NumberFormatException("A blank string is not a valid number"); [EOL]     } [EOL]     final String[] hex_prefixes = { "0x", "0X", "-0x", "-0X", "#", "-#" }; [EOL]     int pfxLen = 0; [EOL]     for (final String pfx : hex_prefixes) { [EOL]         if (str.startsWith(pfx)) { [EOL]             pfxLen += pfx.length(); [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (pfxLen > 0) { [EOL]         char firstSigDigit = 0; [EOL]         for (int i = pfxLen; i < str.length(); i++) { [EOL]             firstSigDigit = str.charAt(i); [EOL]             if (firstSigDigit == '0') { [EOL]                 pfxLen++; [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         final int hexDigits = str.length() - pfxLen; [EOL]         if (hexDigits > 16 || (hexDigits == 16 && firstSigDigit > '7')) { [EOL]             return createBigInteger(str); [EOL]         } [EOL]         if (hexDigits > 8 || (hexDigits == 8 && firstSigDigit > '7')) { [EOL]             return createLong(str); [EOL]         } [EOL]         return createInteger(str); [EOL]     } [EOL]     final char lastChar = str.charAt(str.length() - 1); [EOL]     String mant; [EOL]     String dec; [EOL]     String exp; [EOL]     final int decPos = str.indexOf('.'); [EOL]     final int expPos = str.indexOf('e') + str.indexOf('E') + 1; [EOL]     int numDecimals = 0; [EOL]     if (decPos > -1) { [EOL]         if (expPos > -1) { [EOL]             if (expPos < decPos || expPos > str.length()) { [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             } [EOL]             dec = str.substring(decPos + 1, expPos); [EOL]         } else { [EOL]             dec = str.substring(decPos + 1); [EOL]         } [EOL]         mant = str.substring(0, decPos); [EOL]         numDecimals = dec.length(); [EOL]     } else { [EOL]         if (expPos > -1) { [EOL]             if (expPos > str.length()) { [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             } [EOL]             mant = str.substring(0, expPos); [EOL]         } else { [EOL]             mant = str; [EOL]         } [EOL]         dec = null; [EOL]     } [EOL]     if (!Character.isDigit(lastChar) && lastChar != '.') { [EOL]         if (expPos > -1 && expPos < str.length() - 1) { [EOL]             exp = str.substring(expPos + 1, str.length() - 1); [EOL]         } else { [EOL]             exp = null; [EOL]         } [EOL]         final String numeric = str.substring(0, str.length() - 1); [EOL]         final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL]         switch(lastChar) { [EOL]             case 'l': [EOL]             case 'L': [EOL]                 if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { [EOL]                     try { [EOL]                         return createLong(numeric); [EOL]                     } catch (final NumberFormatException nfe) { [EOL]                     } [EOL]                     return createBigInteger(numeric); [EOL]                 } [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             case 'f': [EOL]             case 'F': [EOL]                 try { [EOL]                     final Float f = NumberUtils.createFloat(numeric); [EOL]                     if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL]                         return f; [EOL]                     } [EOL]                 } catch (final NumberFormatException nfe) { [EOL]                 } [EOL]             case 'd': [EOL]             case 'D': [EOL]                 try { [EOL]                     final Double d = NumberUtils.createDouble(numeric); [EOL]                     if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { [EOL]                         return d; [EOL]                     } [EOL]                 } catch (final NumberFormatException nfe) { [EOL]                 } [EOL]                 try { [EOL]                     return createBigDecimal(numeric); [EOL]                 } catch (final NumberFormatException e) { [EOL]                 } [EOL]             default: [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]         } [EOL]     } [EOL]     if (expPos > -1 && expPos < str.length() - 1) { [EOL]         exp = str.substring(expPos + 1, str.length()); [EOL]     } else { [EOL]         exp = null; [EOL]     } [EOL]     if (dec == null && exp == null) { [EOL]         try { [EOL]             return createInteger(str); [EOL]         } catch (final NumberFormatException nfe) { [EOL]         } [EOL]         try { [EOL]             return createLong(str); [EOL]         } catch (final NumberFormatException nfe) { [EOL]         } [EOL]         return createBigInteger(str); [EOL]     } [EOL]     final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL]     try { [EOL]         if (numDecimals <= 7) { [EOL]             final Float f = createFloat(str); [EOL]             if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL]                 return f; [EOL]             } [EOL]         } [EOL]     } catch (final NumberFormatException nfe) { [EOL]     } [EOL]     try { [EOL]         if (numDecimals <= 16) { [EOL]             final Double d = createDouble(str); [EOL]             if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { [EOL]                 return d; [EOL]             } [EOL]         } [EOL]     } catch (final NumberFormatException nfe) { [EOL]     } [EOL]     return createBigDecimal(str); [EOL] } 
 [LINE] return createLong(str); [LINE] public static Number createNumber(final String str) throws NumberFormatException { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (StringUtils.isBlank(str)) { [EOL]         throw new NumberFormatException("A blank string is not a valid number"); [EOL]     } [EOL]     final String[] hex_prefixes = { "0x", "0X", "-0x", "-0X", "#", "-#" }; [EOL]     int pfxLen = 0; [EOL]     for (final String pfx : hex_prefixes) { [EOL]         if (str.startsWith(pfx)) { [EOL]             pfxLen += pfx.length(); [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (pfxLen > 0) { [EOL]         char firstSigDigit = 0; [EOL]         for (int i = pfxLen; i < str.length(); i++) { [EOL]             firstSigDigit = str.charAt(i); [EOL]             if (firstSigDigit == '0') { [EOL]                 pfxLen++; [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         final int hexDigits = str.length() - pfxLen; [EOL]         if (hexDigits > 16 || (hexDigits == 16 && firstSigDigit > '7')) { [EOL]             return createBigInteger(str); [EOL]         } [EOL]         if (hexDigits > 8 || (hexDigits == 8 && firstSigDigit > '7')) { [EOL]             return createLong(str); [EOL]         } [EOL]         return createInteger(str); [EOL]     } [EOL]     final char lastChar = str.charAt(str.length() - 1); [EOL]     String mant; [EOL]     String dec; [EOL]     String exp; [EOL]     final int decPos = str.indexOf('.'); [EOL]     final int expPos = str.indexOf('e') + str.indexOf('E') + 1; [EOL]     int numDecimals = 0; [EOL]     if (decPos > -1) { [EOL]         if (expPos > -1) { [EOL]             if (expPos < decPos || expPos > str.length()) { [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             } [EOL]             dec = str.substring(decPos + 1, expPos); [EOL]         } else { [EOL]             dec = str.substring(decPos + 1); [EOL]         } [EOL]         mant = str.substring(0, decPos); [EOL]         numDecimals = dec.length(); [EOL]     } else { [EOL]         if (expPos > -1) { [EOL]             if (expPos > str.length()) { [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             } [EOL]             mant = str.substring(0, expPos); [EOL]         } else { [EOL]             mant = str; [EOL]         } [EOL]         dec = null; [EOL]     } [EOL]     if (!Character.isDigit(lastChar) && lastChar != '.') { [EOL]         if (expPos > -1 && expPos < str.length() - 1) { [EOL]             exp = str.substring(expPos + 1, str.length() - 1); [EOL]         } else { [EOL]             exp = null; [EOL]         } [EOL]         final String numeric = str.substring(0, str.length() - 1); [EOL]         final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL]         switch(lastChar) { [EOL]             case 'l': [EOL]             case 'L': [EOL]                 if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { [EOL]                     try { [EOL]                         return createLong(numeric); [EOL]                     } catch (final NumberFormatException nfe) { [EOL]                     } [EOL]                     return createBigInteger(numeric); [EOL]                 } [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             case 'f': [EOL]             case 'F': [EOL]                 try { [EOL]                     final Float f = NumberUtils.createFloat(numeric); [EOL]                     if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL]                         return f; [EOL]                     } [EOL]                 } catch (final NumberFormatException nfe) { [EOL]                 } [EOL]             case 'd': [EOL]             case 'D': [EOL]                 try { [EOL]                     final Double d = NumberUtils.createDouble(numeric); [EOL]                     if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { [EOL]                         return d; [EOL]                     } [EOL]                 } catch (final NumberFormatException nfe) { [EOL]                 } [EOL]                 try { [EOL]                     return createBigDecimal(numeric); [EOL]                 } catch (final NumberFormatException e) { [EOL]                 } [EOL]             default: [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]         } [EOL]     } [EOL]     if (expPos > -1 && expPos < str.length() - 1) { [EOL]         exp = str.substring(expPos + 1, str.length()); [EOL]     } else { [EOL]         exp = null; [EOL]     } [EOL]     if (dec == null && exp == null) { [EOL]         try { [EOL]             return createInteger(str); [EOL]         } catch (final NumberFormatException nfe) { [EOL]         } [EOL]         try { [EOL]             return createLong(str); [EOL]         } catch (final NumberFormatException nfe) { [EOL]         } [EOL]         return createBigInteger(str); [EOL]     } [EOL]     final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL]     try { [EOL]         if (numDecimals <= 7) { [EOL]             final Float f = createFloat(str); [EOL]             if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL]                 return f; [EOL]             } [EOL]         } [EOL]     } catch (final NumberFormatException nfe) { [EOL]     } [EOL]     try { [EOL]         if (numDecimals <= 16) { [EOL]             final Double d = createDouble(str); [EOL]             if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { [EOL]                 return d; [EOL]             } [EOL]         } [EOL]     } catch (final NumberFormatException nfe) { [EOL]     } [EOL]     return createBigDecimal(str); [EOL] } 
 [LINE] return createBigInteger(str); [LINE] public static Number createNumber(final String str) throws NumberFormatException { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (StringUtils.isBlank(str)) { [EOL]         throw new NumberFormatException("A blank string is not a valid number"); [EOL]     } [EOL]     final String[] hex_prefixes = { "0x", "0X", "-0x", "-0X", "#", "-#" }; [EOL]     int pfxLen = 0; [EOL]     for (final String pfx : hex_prefixes) { [EOL]         if (str.startsWith(pfx)) { [EOL]             pfxLen += pfx.length(); [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (pfxLen > 0) { [EOL]         char firstSigDigit = 0; [EOL]         for (int i = pfxLen; i < str.length(); i++) { [EOL]             firstSigDigit = str.charAt(i); [EOL]             if (firstSigDigit == '0') { [EOL]                 pfxLen++; [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         final int hexDigits = str.length() - pfxLen; [EOL]         if (hexDigits > 16 || (hexDigits == 16 && firstSigDigit > '7')) { [EOL]             return createBigInteger(str); [EOL]         } [EOL]         if (hexDigits > 8 || (hexDigits == 8 && firstSigDigit > '7')) { [EOL]             return createLong(str); [EOL]         } [EOL]         return createInteger(str); [EOL]     } [EOL]     final char lastChar = str.charAt(str.length() - 1); [EOL]     String mant; [EOL]     String dec; [EOL]     String exp; [EOL]     final int decPos = str.indexOf('.'); [EOL]     final int expPos = str.indexOf('e') + str.indexOf('E') + 1; [EOL]     int numDecimals = 0; [EOL]     if (decPos > -1) { [EOL]         if (expPos > -1) { [EOL]             if (expPos < decPos || expPos > str.length()) { [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             } [EOL]             dec = str.substring(decPos + 1, expPos); [EOL]         } else { [EOL]             dec = str.substring(decPos + 1); [EOL]         } [EOL]         mant = str.substring(0, decPos); [EOL]         numDecimals = dec.length(); [EOL]     } else { [EOL]         if (expPos > -1) { [EOL]             if (expPos > str.length()) { [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             } [EOL]             mant = str.substring(0, expPos); [EOL]         } else { [EOL]             mant = str; [EOL]         } [EOL]         dec = null; [EOL]     } [EOL]     if (!Character.isDigit(lastChar) && lastChar != '.') { [EOL]         if (expPos > -1 && expPos < str.length() - 1) { [EOL]             exp = str.substring(expPos + 1, str.length() - 1); [EOL]         } else { [EOL]             exp = null; [EOL]         } [EOL]         final String numeric = str.substring(0, str.length() - 1); [EOL]         final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL]         switch(lastChar) { [EOL]             case 'l': [EOL]             case 'L': [EOL]                 if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { [EOL]                     try { [EOL]                         return createLong(numeric); [EOL]                     } catch (final NumberFormatException nfe) { [EOL]                     } [EOL]                     return createBigInteger(numeric); [EOL]                 } [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             case 'f': [EOL]             case 'F': [EOL]                 try { [EOL]                     final Float f = NumberUtils.createFloat(numeric); [EOL]                     if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL]                         return f; [EOL]                     } [EOL]                 } catch (final NumberFormatException nfe) { [EOL]                 } [EOL]             case 'd': [EOL]             case 'D': [EOL]                 try { [EOL]                     final Double d = NumberUtils.createDouble(numeric); [EOL]                     if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { [EOL]                         return d; [EOL]                     } [EOL]                 } catch (final NumberFormatException nfe) { [EOL]                 } [EOL]                 try { [EOL]                     return createBigDecimal(numeric); [EOL]                 } catch (final NumberFormatException e) { [EOL]                 } [EOL]             default: [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]         } [EOL]     } [EOL]     if (expPos > -1 && expPos < str.length() - 1) { [EOL]         exp = str.substring(expPos + 1, str.length()); [EOL]     } else { [EOL]         exp = null; [EOL]     } [EOL]     if (dec == null && exp == null) { [EOL]         try { [EOL]             return createInteger(str); [EOL]         } catch (final NumberFormatException nfe) { [EOL]         } [EOL]         try { [EOL]             return createLong(str); [EOL]         } catch (final NumberFormatException nfe) { [EOL]         } [EOL]         return createBigInteger(str); [EOL]     } [EOL]     final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL]     try { [EOL]         if (numDecimals <= 7) { [EOL]             final Float f = createFloat(str); [EOL]             if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL]                 return f; [EOL]             } [EOL]         } [EOL]     } catch (final NumberFormatException nfe) { [EOL]     } [EOL]     try { [EOL]         if (numDecimals <= 16) { [EOL]             final Double d = createDouble(str); [EOL]             if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { [EOL]                 return d; [EOL]             } [EOL]         } [EOL]     } catch (final NumberFormatException nfe) { [EOL]     } [EOL]     return createBigDecimal(str); [EOL] } 
 [LINE] final Float f = createFloat(str); [LINE] public static Number createNumber(final String str) throws NumberFormatException { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (StringUtils.isBlank(str)) { [EOL]         throw new NumberFormatException("A blank string is not a valid number"); [EOL]     } [EOL]     final String[] hex_prefixes = { "0x", "0X", "-0x", "-0X", "#", "-#" }; [EOL]     int pfxLen = 0; [EOL]     for (final String pfx : hex_prefixes) { [EOL]         if (str.startsWith(pfx)) { [EOL]             pfxLen += pfx.length(); [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (pfxLen > 0) { [EOL]         char firstSigDigit = 0; [EOL]         for (int i = pfxLen; i < str.length(); i++) { [EOL]             firstSigDigit = str.charAt(i); [EOL]             if (firstSigDigit == '0') { [EOL]                 pfxLen++; [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         final int hexDigits = str.length() - pfxLen; [EOL]         if (hexDigits > 16 || (hexDigits == 16 && firstSigDigit > '7')) { [EOL]             return createBigInteger(str); [EOL]         } [EOL]         if (hexDigits > 8 || (hexDigits == 8 && firstSigDigit > '7')) { [EOL]             return createLong(str); [EOL]         } [EOL]         return createInteger(str); [EOL]     } [EOL]     final char lastChar = str.charAt(str.length() - 1); [EOL]     String mant; [EOL]     String dec; [EOL]     String exp; [EOL]     final int decPos = str.indexOf('.'); [EOL]     final int expPos = str.indexOf('e') + str.indexOf('E') + 1; [EOL]     int numDecimals = 0; [EOL]     if (decPos > -1) { [EOL]         if (expPos > -1) { [EOL]             if (expPos < decPos || expPos > str.length()) { [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             } [EOL]             dec = str.substring(decPos + 1, expPos); [EOL]         } else { [EOL]             dec = str.substring(decPos + 1); [EOL]         } [EOL]         mant = str.substring(0, decPos); [EOL]         numDecimals = dec.length(); [EOL]     } else { [EOL]         if (expPos > -1) { [EOL]             if (expPos > str.length()) { [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             } [EOL]             mant = str.substring(0, expPos); [EOL]         } else { [EOL]             mant = str; [EOL]         } [EOL]         dec = null; [EOL]     } [EOL]     if (!Character.isDigit(lastChar) && lastChar != '.') { [EOL]         if (expPos > -1 && expPos < str.length() - 1) { [EOL]             exp = str.substring(expPos + 1, str.length() - 1); [EOL]         } else { [EOL]             exp = null; [EOL]         } [EOL]         final String numeric = str.substring(0, str.length() - 1); [EOL]         final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL]         switch(lastChar) { [EOL]             case 'l': [EOL]             case 'L': [EOL]                 if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { [EOL]                     try { [EOL]                         return createLong(numeric); [EOL]                     } catch (final NumberFormatException nfe) { [EOL]                     } [EOL]                     return createBigInteger(numeric); [EOL]                 } [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             case 'f': [EOL]             case 'F': [EOL]                 try { [EOL]                     final Float f = NumberUtils.createFloat(numeric); [EOL]                     if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL]                         return f; [EOL]                     } [EOL]                 } catch (final NumberFormatException nfe) { [EOL]                 } [EOL]             case 'd': [EOL]             case 'D': [EOL]                 try { [EOL]                     final Double d = NumberUtils.createDouble(numeric); [EOL]                     if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { [EOL]                         return d; [EOL]                     } [EOL]                 } catch (final NumberFormatException nfe) { [EOL]                 } [EOL]                 try { [EOL]                     return createBigDecimal(numeric); [EOL]                 } catch (final NumberFormatException e) { [EOL]                 } [EOL]             default: [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]         } [EOL]     } [EOL]     if (expPos > -1 && expPos < str.length() - 1) { [EOL]         exp = str.substring(expPos + 1, str.length()); [EOL]     } else { [EOL]         exp = null; [EOL]     } [EOL]     if (dec == null && exp == null) { [EOL]         try { [EOL]             return createInteger(str); [EOL]         } catch (final NumberFormatException nfe) { [EOL]         } [EOL]         try { [EOL]             return createLong(str); [EOL]         } catch (final NumberFormatException nfe) { [EOL]         } [EOL]         return createBigInteger(str); [EOL]     } [EOL]     final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL]     try { [EOL]         if (numDecimals <= 7) { [EOL]             final Float f = createFloat(str); [EOL]             if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL]                 return f; [EOL]             } [EOL]         } [EOL]     } catch (final NumberFormatException nfe) { [EOL]     } [EOL]     try { [EOL]         if (numDecimals <= 16) { [EOL]             final Double d = createDouble(str); [EOL]             if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { [EOL]                 return d; [EOL]             } [EOL]         } [EOL]     } catch (final NumberFormatException nfe) { [EOL]     } [EOL]     return createBigDecimal(str); [EOL] } 
 [LINE] if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [LINE] public static Number createNumber(final String str) throws NumberFormatException { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (StringUtils.isBlank(str)) { [EOL]         throw new NumberFormatException("A blank string is not a valid number"); [EOL]     } [EOL]     final String[] hex_prefixes = { "0x", "0X", "-0x", "-0X", "#", "-#" }; [EOL]     int pfxLen = 0; [EOL]     for (final String pfx : hex_prefixes) { [EOL]         if (str.startsWith(pfx)) { [EOL]             pfxLen += pfx.length(); [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (pfxLen > 0) { [EOL]         char firstSigDigit = 0; [EOL]         for (int i = pfxLen; i < str.length(); i++) { [EOL]             firstSigDigit = str.charAt(i); [EOL]             if (firstSigDigit == '0') { [EOL]                 pfxLen++; [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         final int hexDigits = str.length() - pfxLen; [EOL]         if (hexDigits > 16 || (hexDigits == 16 && firstSigDigit > '7')) { [EOL]             return createBigInteger(str); [EOL]         } [EOL]         if (hexDigits > 8 || (hexDigits == 8 && firstSigDigit > '7')) { [EOL]             return createLong(str); [EOL]         } [EOL]         return createInteger(str); [EOL]     } [EOL]     final char lastChar = str.charAt(str.length() - 1); [EOL]     String mant; [EOL]     String dec; [EOL]     String exp; [EOL]     final int decPos = str.indexOf('.'); [EOL]     final int expPos = str.indexOf('e') + str.indexOf('E') + 1; [EOL]     int numDecimals = 0; [EOL]     if (decPos > -1) { [EOL]         if (expPos > -1) { [EOL]             if (expPos < decPos || expPos > str.length()) { [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             } [EOL]             dec = str.substring(decPos + 1, expPos); [EOL]         } else { [EOL]             dec = str.substring(decPos + 1); [EOL]         } [EOL]         mant = str.substring(0, decPos); [EOL]         numDecimals = dec.length(); [EOL]     } else { [EOL]         if (expPos > -1) { [EOL]             if (expPos > str.length()) { [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             } [EOL]             mant = str.substring(0, expPos); [EOL]         } else { [EOL]             mant = str; [EOL]         } [EOL]         dec = null; [EOL]     } [EOL]     if (!Character.isDigit(lastChar) && lastChar != '.') { [EOL]         if (expPos > -1 && expPos < str.length() - 1) { [EOL]             exp = str.substring(expPos + 1, str.length() - 1); [EOL]         } else { [EOL]             exp = null; [EOL]         } [EOL]         final String numeric = str.substring(0, str.length() - 1); [EOL]         final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL]         switch(lastChar) { [EOL]             case 'l': [EOL]             case 'L': [EOL]                 if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { [EOL]                     try { [EOL]                         return createLong(numeric); [EOL]                     } catch (final NumberFormatException nfe) { [EOL]                     } [EOL]                     return createBigInteger(numeric); [EOL]                 } [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             case 'f': [EOL]             case 'F': [EOL]                 try { [EOL]                     final Float f = NumberUtils.createFloat(numeric); [EOL]                     if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL]                         return f; [EOL]                     } [EOL]                 } catch (final NumberFormatException nfe) { [EOL]                 } [EOL]             case 'd': [EOL]             case 'D': [EOL]                 try { [EOL]                     final Double d = NumberUtils.createDouble(numeric); [EOL]                     if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { [EOL]                         return d; [EOL]                     } [EOL]                 } catch (final NumberFormatException nfe) { [EOL]                 } [EOL]                 try { [EOL]                     return createBigDecimal(numeric); [EOL]                 } catch (final NumberFormatException e) { [EOL]                 } [EOL]             default: [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]         } [EOL]     } [EOL]     if (expPos > -1 && expPos < str.length() - 1) { [EOL]         exp = str.substring(expPos + 1, str.length()); [EOL]     } else { [EOL]         exp = null; [EOL]     } [EOL]     if (dec == null && exp == null) { [EOL]         try { [EOL]             return createInteger(str); [EOL]         } catch (final NumberFormatException nfe) { [EOL]         } [EOL]         try { [EOL]             return createLong(str); [EOL]         } catch (final NumberFormatException nfe) { [EOL]         } [EOL]         return createBigInteger(str); [EOL]     } [EOL]     final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL]     try { [EOL]         if (numDecimals <= 7) { [EOL]             final Float f = createFloat(str); [EOL]             if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL]                 return f; [EOL]             } [EOL]         } [EOL]     } catch (final NumberFormatException nfe) { [EOL]     } [EOL]     try { [EOL]         if (numDecimals <= 16) { [EOL]             final Double d = createDouble(str); [EOL]             if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { [EOL]                 return d; [EOL]             } [EOL]         } [EOL]     } catch (final NumberFormatException nfe) { [EOL]     } [EOL]     return createBigDecimal(str); [EOL] } 
 [LINE] return f; [LINE] public static Number createNumber(final String str) throws NumberFormatException { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (StringUtils.isBlank(str)) { [EOL]         throw new NumberFormatException("A blank string is not a valid number"); [EOL]     } [EOL]     final String[] hex_prefixes = { "0x", "0X", "-0x", "-0X", "#", "-#" }; [EOL]     int pfxLen = 0; [EOL]     for (final String pfx : hex_prefixes) { [EOL]         if (str.startsWith(pfx)) { [EOL]             pfxLen += pfx.length(); [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (pfxLen > 0) { [EOL]         char firstSigDigit = 0; [EOL]         for (int i = pfxLen; i < str.length(); i++) { [EOL]             firstSigDigit = str.charAt(i); [EOL]             if (firstSigDigit == '0') { [EOL]                 pfxLen++; [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         final int hexDigits = str.length() - pfxLen; [EOL]         if (hexDigits > 16 || (hexDigits == 16 && firstSigDigit > '7')) { [EOL]             return createBigInteger(str); [EOL]         } [EOL]         if (hexDigits > 8 || (hexDigits == 8 && firstSigDigit > '7')) { [EOL]             return createLong(str); [EOL]         } [EOL]         return createInteger(str); [EOL]     } [EOL]     final char lastChar = str.charAt(str.length() - 1); [EOL]     String mant; [EOL]     String dec; [EOL]     String exp; [EOL]     final int decPos = str.indexOf('.'); [EOL]     final int expPos = str.indexOf('e') + str.indexOf('E') + 1; [EOL]     int numDecimals = 0; [EOL]     if (decPos > -1) { [EOL]         if (expPos > -1) { [EOL]             if (expPos < decPos || expPos > str.length()) { [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             } [EOL]             dec = str.substring(decPos + 1, expPos); [EOL]         } else { [EOL]             dec = str.substring(decPos + 1); [EOL]         } [EOL]         mant = str.substring(0, decPos); [EOL]         numDecimals = dec.length(); [EOL]     } else { [EOL]         if (expPos > -1) { [EOL]             if (expPos > str.length()) { [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             } [EOL]             mant = str.substring(0, expPos); [EOL]         } else { [EOL]             mant = str; [EOL]         } [EOL]         dec = null; [EOL]     } [EOL]     if (!Character.isDigit(lastChar) && lastChar != '.') { [EOL]         if (expPos > -1 && expPos < str.length() - 1) { [EOL]             exp = str.substring(expPos + 1, str.length() - 1); [EOL]         } else { [EOL]             exp = null; [EOL]         } [EOL]         final String numeric = str.substring(0, str.length() - 1); [EOL]         final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL]         switch(lastChar) { [EOL]             case 'l': [EOL]             case 'L': [EOL]                 if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { [EOL]                     try { [EOL]                         return createLong(numeric); [EOL]                     } catch (final NumberFormatException nfe) { [EOL]                     } [EOL]                     return createBigInteger(numeric); [EOL]                 } [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             case 'f': [EOL]             case 'F': [EOL]                 try { [EOL]                     final Float f = NumberUtils.createFloat(numeric); [EOL]                     if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL]                         return f; [EOL]                     } [EOL]                 } catch (final NumberFormatException nfe) { [EOL]                 } [EOL]             case 'd': [EOL]             case 'D': [EOL]                 try { [EOL]                     final Double d = NumberUtils.createDouble(numeric); [EOL]                     if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { [EOL]                         return d; [EOL]                     } [EOL]                 } catch (final NumberFormatException nfe) { [EOL]                 } [EOL]                 try { [EOL]                     return createBigDecimal(numeric); [EOL]                 } catch (final NumberFormatException e) { [EOL]                 } [EOL]             default: [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]         } [EOL]     } [EOL]     if (expPos > -1 && expPos < str.length() - 1) { [EOL]         exp = str.substring(expPos + 1, str.length()); [EOL]     } else { [EOL]         exp = null; [EOL]     } [EOL]     if (dec == null && exp == null) { [EOL]         try { [EOL]             return createInteger(str); [EOL]         } catch (final NumberFormatException nfe) { [EOL]         } [EOL]         try { [EOL]             return createLong(str); [EOL]         } catch (final NumberFormatException nfe) { [EOL]         } [EOL]         return createBigInteger(str); [EOL]     } [EOL]     final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL]     try { [EOL]         if (numDecimals <= 7) { [EOL]             final Float f = createFloat(str); [EOL]             if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL]                 return f; [EOL]             } [EOL]         } [EOL]     } catch (final NumberFormatException nfe) { [EOL]     } [EOL]     try { [EOL]         if (numDecimals <= 16) { [EOL]             final Double d = createDouble(str); [EOL]             if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { [EOL]                 return d; [EOL]             } [EOL]         } [EOL]     } catch (final NumberFormatException nfe) { [EOL]     } [EOL]     return createBigDecimal(str); [EOL] } 
 [LINE] if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { [LINE] public static Number createNumber(final String str) throws NumberFormatException { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (StringUtils.isBlank(str)) { [EOL]         throw new NumberFormatException("A blank string is not a valid number"); [EOL]     } [EOL]     final String[] hex_prefixes = { "0x", "0X", "-0x", "-0X", "#", "-#" }; [EOL]     int pfxLen = 0; [EOL]     for (final String pfx : hex_prefixes) { [EOL]         if (str.startsWith(pfx)) { [EOL]             pfxLen += pfx.length(); [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (pfxLen > 0) { [EOL]         char firstSigDigit = 0; [EOL]         for (int i = pfxLen; i < str.length(); i++) { [EOL]             firstSigDigit = str.charAt(i); [EOL]             if (firstSigDigit == '0') { [EOL]                 pfxLen++; [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         final int hexDigits = str.length() - pfxLen; [EOL]         if (hexDigits > 16 || (hexDigits == 16 && firstSigDigit > '7')) { [EOL]             return createBigInteger(str); [EOL]         } [EOL]         if (hexDigits > 8 || (hexDigits == 8 && firstSigDigit > '7')) { [EOL]             return createLong(str); [EOL]         } [EOL]         return createInteger(str); [EOL]     } [EOL]     final char lastChar = str.charAt(str.length() - 1); [EOL]     String mant; [EOL]     String dec; [EOL]     String exp; [EOL]     final int decPos = str.indexOf('.'); [EOL]     final int expPos = str.indexOf('e') + str.indexOf('E') + 1; [EOL]     int numDecimals = 0; [EOL]     if (decPos > -1) { [EOL]         if (expPos > -1) { [EOL]             if (expPos < decPos || expPos > str.length()) { [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             } [EOL]             dec = str.substring(decPos + 1, expPos); [EOL]         } else { [EOL]             dec = str.substring(decPos + 1); [EOL]         } [EOL]         mant = str.substring(0, decPos); [EOL]         numDecimals = dec.length(); [EOL]     } else { [EOL]         if (expPos > -1) { [EOL]             if (expPos > str.length()) { [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             } [EOL]             mant = str.substring(0, expPos); [EOL]         } else { [EOL]             mant = str; [EOL]         } [EOL]         dec = null; [EOL]     } [EOL]     if (!Character.isDigit(lastChar) && lastChar != '.') { [EOL]         if (expPos > -1 && expPos < str.length() - 1) { [EOL]             exp = str.substring(expPos + 1, str.length() - 1); [EOL]         } else { [EOL]             exp = null; [EOL]         } [EOL]         final String numeric = str.substring(0, str.length() - 1); [EOL]         final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL]         switch(lastChar) { [EOL]             case 'l': [EOL]             case 'L': [EOL]                 if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { [EOL]                     try { [EOL]                         return createLong(numeric); [EOL]                     } catch (final NumberFormatException nfe) { [EOL]                     } [EOL]                     return createBigInteger(numeric); [EOL]                 } [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             case 'f': [EOL]             case 'F': [EOL]                 try { [EOL]                     final Float f = NumberUtils.createFloat(numeric); [EOL]                     if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL]                         return f; [EOL]                     } [EOL]                 } catch (final NumberFormatException nfe) { [EOL]                 } [EOL]             case 'd': [EOL]             case 'D': [EOL]                 try { [EOL]                     final Double d = NumberUtils.createDouble(numeric); [EOL]                     if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { [EOL]                         return d; [EOL]                     } [EOL]                 } catch (final NumberFormatException nfe) { [EOL]                 } [EOL]                 try { [EOL]                     return createBigDecimal(numeric); [EOL]                 } catch (final NumberFormatException e) { [EOL]                 } [EOL]             default: [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]         } [EOL]     } [EOL]     if (expPos > -1 && expPos < str.length() - 1) { [EOL]         exp = str.substring(expPos + 1, str.length()); [EOL]     } else { [EOL]         exp = null; [EOL]     } [EOL]     if (dec == null && exp == null) { [EOL]         try { [EOL]             return createInteger(str); [EOL]         } catch (final NumberFormatException nfe) { [EOL]         } [EOL]         try { [EOL]             return createLong(str); [EOL]         } catch (final NumberFormatException nfe) { [EOL]         } [EOL]         return createBigInteger(str); [EOL]     } [EOL]     final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL]     try { [EOL]         if (numDecimals <= 7) { [EOL]             final Float f = createFloat(str); [EOL]             if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL]                 return f; [EOL]             } [EOL]         } [EOL]     } catch (final NumberFormatException nfe) { [EOL]     } [EOL]     try { [EOL]         if (numDecimals <= 16) { [EOL]             final Double d = createDouble(str); [EOL]             if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { [EOL]                 return d; [EOL]             } [EOL]         } [EOL]     } catch (final NumberFormatException nfe) { [EOL]     } [EOL]     return createBigDecimal(str); [EOL] } 
 [LINE] return d; [LINE] public static Number createNumber(final String str) throws NumberFormatException { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (StringUtils.isBlank(str)) { [EOL]         throw new NumberFormatException("A blank string is not a valid number"); [EOL]     } [EOL]     final String[] hex_prefixes = { "0x", "0X", "-0x", "-0X", "#", "-#" }; [EOL]     int pfxLen = 0; [EOL]     for (final String pfx : hex_prefixes) { [EOL]         if (str.startsWith(pfx)) { [EOL]             pfxLen += pfx.length(); [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (pfxLen > 0) { [EOL]         char firstSigDigit = 0; [EOL]         for (int i = pfxLen; i < str.length(); i++) { [EOL]             firstSigDigit = str.charAt(i); [EOL]             if (firstSigDigit == '0') { [EOL]                 pfxLen++; [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         final int hexDigits = str.length() - pfxLen; [EOL]         if (hexDigits > 16 || (hexDigits == 16 && firstSigDigit > '7')) { [EOL]             return createBigInteger(str); [EOL]         } [EOL]         if (hexDigits > 8 || (hexDigits == 8 && firstSigDigit > '7')) { [EOL]             return createLong(str); [EOL]         } [EOL]         return createInteger(str); [EOL]     } [EOL]     final char lastChar = str.charAt(str.length() - 1); [EOL]     String mant; [EOL]     String dec; [EOL]     String exp; [EOL]     final int decPos = str.indexOf('.'); [EOL]     final int expPos = str.indexOf('e') + str.indexOf('E') + 1; [EOL]     int numDecimals = 0; [EOL]     if (decPos > -1) { [EOL]         if (expPos > -1) { [EOL]             if (expPos < decPos || expPos > str.length()) { [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             } [EOL]             dec = str.substring(decPos + 1, expPos); [EOL]         } else { [EOL]             dec = str.substring(decPos + 1); [EOL]         } [EOL]         mant = str.substring(0, decPos); [EOL]         numDecimals = dec.length(); [EOL]     } else { [EOL]         if (expPos > -1) { [EOL]             if (expPos > str.length()) { [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             } [EOL]             mant = str.substring(0, expPos); [EOL]         } else { [EOL]             mant = str; [EOL]         } [EOL]         dec = null; [EOL]     } [EOL]     if (!Character.isDigit(lastChar) && lastChar != '.') { [EOL]         if (expPos > -1 && expPos < str.length() - 1) { [EOL]             exp = str.substring(expPos + 1, str.length() - 1); [EOL]         } else { [EOL]             exp = null; [EOL]         } [EOL]         final String numeric = str.substring(0, str.length() - 1); [EOL]         final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL]         switch(lastChar) { [EOL]             case 'l': [EOL]             case 'L': [EOL]                 if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { [EOL]                     try { [EOL]                         return createLong(numeric); [EOL]                     } catch (final NumberFormatException nfe) { [EOL]                     } [EOL]                     return createBigInteger(numeric); [EOL]                 } [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             case 'f': [EOL]             case 'F': [EOL]                 try { [EOL]                     final Float f = NumberUtils.createFloat(numeric); [EOL]                     if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL]                         return f; [EOL]                     } [EOL]                 } catch (final NumberFormatException nfe) { [EOL]                 } [EOL]             case 'd': [EOL]             case 'D': [EOL]                 try { [EOL]                     final Double d = NumberUtils.createDouble(numeric); [EOL]                     if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { [EOL]                         return d; [EOL]                     } [EOL]                 } catch (final NumberFormatException nfe) { [EOL]                 } [EOL]                 try { [EOL]                     return createBigDecimal(numeric); [EOL]                 } catch (final NumberFormatException e) { [EOL]                 } [EOL]             default: [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]         } [EOL]     } [EOL]     if (expPos > -1 && expPos < str.length() - 1) { [EOL]         exp = str.substring(expPos + 1, str.length()); [EOL]     } else { [EOL]         exp = null; [EOL]     } [EOL]     if (dec == null && exp == null) { [EOL]         try { [EOL]             return createInteger(str); [EOL]         } catch (final NumberFormatException nfe) { [EOL]         } [EOL]         try { [EOL]             return createLong(str); [EOL]         } catch (final NumberFormatException nfe) { [EOL]         } [EOL]         return createBigInteger(str); [EOL]     } [EOL]     final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL]     try { [EOL]         if (numDecimals <= 7) { [EOL]             final Float f = createFloat(str); [EOL]             if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL]                 return f; [EOL]             } [EOL]         } [EOL]     } catch (final NumberFormatException nfe) { [EOL]     } [EOL]     try { [EOL]         if (numDecimals <= 16) { [EOL]             final Double d = createDouble(str); [EOL]             if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { [EOL]                 return d; [EOL]             } [EOL]         } [EOL]     } catch (final NumberFormatException nfe) { [EOL]     } [EOL]     return createBigDecimal(str); [EOL] } 
 [LINE] return str.length() > 0; [LINE] private static boolean isAllZeros(final String str) { [EOL]     if (str == null) { [EOL]         return true; [EOL]     } [EOL]     for (int i = str.length() - 1; i >= 0; i--) { [EOL]         if (str.charAt(i) != '0') { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return str.length() > 0; [EOL] } 
 [LINE] return true; [LINE] public static boolean isDigits(final String str) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return false; [EOL]     } [EOL]     for (int i = 0; i < str.length(); i++) { [EOL]         if (!Character.isDigit(str.charAt(i))) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] return true; [LINE] public static boolean isNumber(final String str) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return false; [EOL]     } [EOL]     final char[] chars = str.toCharArray(); [EOL]     int sz = chars.length; [EOL]     boolean hasExp = false; [EOL]     boolean hasDecPoint = false; [EOL]     boolean allowSigns = false; [EOL]     boolean foundDigit = false; [EOL]     final int start = (chars[0] == '-') ? 1 : 0; [EOL]     if (sz > start + 1 && chars[start] == '0' && chars[start + 1] == 'x') { [EOL]         int i = start + 2; [EOL]         if (i == sz) { [EOL]             return false; [EOL]         } [EOL]         for (; i < chars.length; i++) { [EOL]             if ((chars[i] < '0' || chars[i] > '9') && (chars[i] < 'a' || chars[i] > 'f') && (chars[i] < 'A' || chars[i] > 'F')) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     sz--; [EOL]     int i = start; [EOL]     while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             foundDigit = true; [EOL]             allowSigns = false; [EOL]         } else if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             hasDecPoint = true; [EOL]         } else if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             if (hasExp) { [EOL]                 return false; [EOL]             } [EOL]             if (!foundDigit) { [EOL]                 return false; [EOL]             } [EOL]             hasExp = true; [EOL]             allowSigns = true; [EOL]         } else if (chars[i] == '+' || chars[i] == '-') { [EOL]             if (!allowSigns) { [EOL]                 return false; [EOL]             } [EOL]             allowSigns = false; [EOL]             foundDigit = false; [EOL]         } else { [EOL]             return false; [EOL]         } [EOL]         i++; [EOL]     } [EOL]     if (i < chars.length) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             return true; [EOL]         } [EOL]         if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             return false; [EOL]         } [EOL]         if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             return foundDigit; [EOL]         } [EOL]         if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D' || chars[i] == 'f' || chars[i] == 'F')) { [EOL]             return foundDigit; [EOL]         } [EOL]         if (chars[i] == 'l' || chars[i] == 'L') { [EOL]             return foundDigit && !hasExp && !hasDecPoint; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return !allowSigns && foundDigit; [EOL] } 
 [LINE] if (hasDecPoint || hasExp) { [LINE] public static boolean isNumber(final String str) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return false; [EOL]     } [EOL]     final char[] chars = str.toCharArray(); [EOL]     int sz = chars.length; [EOL]     boolean hasExp = false; [EOL]     boolean hasDecPoint = false; [EOL]     boolean allowSigns = false; [EOL]     boolean foundDigit = false; [EOL]     final int start = (chars[0] == '-') ? 1 : 0; [EOL]     if (sz > start + 1 && chars[start] == '0' && chars[start + 1] == 'x') { [EOL]         int i = start + 2; [EOL]         if (i == sz) { [EOL]             return false; [EOL]         } [EOL]         for (; i < chars.length; i++) { [EOL]             if ((chars[i] < '0' || chars[i] > '9') && (chars[i] < 'a' || chars[i] > 'f') && (chars[i] < 'A' || chars[i] > 'F')) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     sz--; [EOL]     int i = start; [EOL]     while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             foundDigit = true; [EOL]             allowSigns = false; [EOL]         } else if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             hasDecPoint = true; [EOL]         } else if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             if (hasExp) { [EOL]                 return false; [EOL]             } [EOL]             if (!foundDigit) { [EOL]                 return false; [EOL]             } [EOL]             hasExp = true; [EOL]             allowSigns = true; [EOL]         } else if (chars[i] == '+' || chars[i] == '-') { [EOL]             if (!allowSigns) { [EOL]                 return false; [EOL]             } [EOL]             allowSigns = false; [EOL]             foundDigit = false; [EOL]         } else { [EOL]             return false; [EOL]         } [EOL]         i++; [EOL]     } [EOL]     if (i < chars.length) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             return true; [EOL]         } [EOL]         if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             return false; [EOL]         } [EOL]         if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             return foundDigit; [EOL]         } [EOL]         if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D' || chars[i] == 'f' || chars[i] == 'F')) { [EOL]             return foundDigit; [EOL]         } [EOL]         if (chars[i] == 'l' || chars[i] == 'L') { [EOL]             return foundDigit && !hasExp && !hasDecPoint; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return !allowSigns && foundDigit; [EOL] } 
 [LINE] return false; [LINE] public static boolean isNumber(final String str) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return false; [EOL]     } [EOL]     final char[] chars = str.toCharArray(); [EOL]     int sz = chars.length; [EOL]     boolean hasExp = false; [EOL]     boolean hasDecPoint = false; [EOL]     boolean allowSigns = false; [EOL]     boolean foundDigit = false; [EOL]     final int start = (chars[0] == '-') ? 1 : 0; [EOL]     if (sz > start + 1 && chars[start] == '0' && chars[start + 1] == 'x') { [EOL]         int i = start + 2; [EOL]         if (i == sz) { [EOL]             return false; [EOL]         } [EOL]         for (; i < chars.length; i++) { [EOL]             if ((chars[i] < '0' || chars[i] > '9') && (chars[i] < 'a' || chars[i] > 'f') && (chars[i] < 'A' || chars[i] > 'F')) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     sz--; [EOL]     int i = start; [EOL]     while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             foundDigit = true; [EOL]             allowSigns = false; [EOL]         } else if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             hasDecPoint = true; [EOL]         } else if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             if (hasExp) { [EOL]                 return false; [EOL]             } [EOL]             if (!foundDigit) { [EOL]                 return false; [EOL]             } [EOL]             hasExp = true; [EOL]             allowSigns = true; [EOL]         } else if (chars[i] == '+' || chars[i] == '-') { [EOL]             if (!allowSigns) { [EOL]                 return false; [EOL]             } [EOL]             allowSigns = false; [EOL]             foundDigit = false; [EOL]         } else { [EOL]             return false; [EOL]         } [EOL]         i++; [EOL]     } [EOL]     if (i < chars.length) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             return true; [EOL]         } [EOL]         if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             return false; [EOL]         } [EOL]         if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             return foundDigit; [EOL]         } [EOL]         if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D' || chars[i] == 'f' || chars[i] == 'F')) { [EOL]             return foundDigit; [EOL]         } [EOL]         if (chars[i] == 'l' || chars[i] == 'L') { [EOL]             return foundDigit && !hasExp && !hasDecPoint; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return !allowSigns && foundDigit; [EOL] } 
 [LINE] hasDecPoint = true; [LINE] public static boolean isNumber(final String str) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return false; [EOL]     } [EOL]     final char[] chars = str.toCharArray(); [EOL]     int sz = chars.length; [EOL]     boolean hasExp = false; [EOL]     boolean hasDecPoint = false; [EOL]     boolean allowSigns = false; [EOL]     boolean foundDigit = false; [EOL]     final int start = (chars[0] == '-') ? 1 : 0; [EOL]     if (sz > start + 1 && chars[start] == '0' && chars[start + 1] == 'x') { [EOL]         int i = start + 2; [EOL]         if (i == sz) { [EOL]             return false; [EOL]         } [EOL]         for (; i < chars.length; i++) { [EOL]             if ((chars[i] < '0' || chars[i] > '9') && (chars[i] < 'a' || chars[i] > 'f') && (chars[i] < 'A' || chars[i] > 'F')) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     sz--; [EOL]     int i = start; [EOL]     while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             foundDigit = true; [EOL]             allowSigns = false; [EOL]         } else if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             hasDecPoint = true; [EOL]         } else if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             if (hasExp) { [EOL]                 return false; [EOL]             } [EOL]             if (!foundDigit) { [EOL]                 return false; [EOL]             } [EOL]             hasExp = true; [EOL]             allowSigns = true; [EOL]         } else if (chars[i] == '+' || chars[i] == '-') { [EOL]             if (!allowSigns) { [EOL]                 return false; [EOL]             } [EOL]             allowSigns = false; [EOL]             foundDigit = false; [EOL]         } else { [EOL]             return false; [EOL]         } [EOL]         i++; [EOL]     } [EOL]     if (i < chars.length) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             return true; [EOL]         } [EOL]         if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             return false; [EOL]         } [EOL]         if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             return foundDigit; [EOL]         } [EOL]         if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D' || chars[i] == 'f' || chars[i] == 'F')) { [EOL]             return foundDigit; [EOL]         } [EOL]         if (chars[i] == 'l' || chars[i] == 'L') { [EOL]             return foundDigit && !hasExp && !hasDecPoint; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return !allowSigns && foundDigit; [EOL] } 
 [LINE] hasExp = true; [LINE] public static boolean isNumber(final String str) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return false; [EOL]     } [EOL]     final char[] chars = str.toCharArray(); [EOL]     int sz = chars.length; [EOL]     boolean hasExp = false; [EOL]     boolean hasDecPoint = false; [EOL]     boolean allowSigns = false; [EOL]     boolean foundDigit = false; [EOL]     final int start = (chars[0] == '-') ? 1 : 0; [EOL]     if (sz > start + 1 && chars[start] == '0' && chars[start + 1] == 'x') { [EOL]         int i = start + 2; [EOL]         if (i == sz) { [EOL]             return false; [EOL]         } [EOL]         for (; i < chars.length; i++) { [EOL]             if ((chars[i] < '0' || chars[i] > '9') && (chars[i] < 'a' || chars[i] > 'f') && (chars[i] < 'A' || chars[i] > 'F')) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     sz--; [EOL]     int i = start; [EOL]     while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             foundDigit = true; [EOL]             allowSigns = false; [EOL]         } else if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             hasDecPoint = true; [EOL]         } else if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             if (hasExp) { [EOL]                 return false; [EOL]             } [EOL]             if (!foundDigit) { [EOL]                 return false; [EOL]             } [EOL]             hasExp = true; [EOL]             allowSigns = true; [EOL]         } else if (chars[i] == '+' || chars[i] == '-') { [EOL]             if (!allowSigns) { [EOL]                 return false; [EOL]             } [EOL]             allowSigns = false; [EOL]             foundDigit = false; [EOL]         } else { [EOL]             return false; [EOL]         } [EOL]         i++; [EOL]     } [EOL]     if (i < chars.length) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             return true; [EOL]         } [EOL]         if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             return false; [EOL]         } [EOL]         if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             return foundDigit; [EOL]         } [EOL]         if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D' || chars[i] == 'f' || chars[i] == 'F')) { [EOL]             return foundDigit; [EOL]         } [EOL]         if (chars[i] == 'l' || chars[i] == 'L') { [EOL]             return foundDigit && !hasExp && !hasDecPoint; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return !allowSigns && foundDigit; [EOL] } 
 [LINE] allowSigns = true; [LINE] public static boolean isNumber(final String str) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return false; [EOL]     } [EOL]     final char[] chars = str.toCharArray(); [EOL]     int sz = chars.length; [EOL]     boolean hasExp = false; [EOL]     boolean hasDecPoint = false; [EOL]     boolean allowSigns = false; [EOL]     boolean foundDigit = false; [EOL]     final int start = (chars[0] == '-') ? 1 : 0; [EOL]     if (sz > start + 1 && chars[start] == '0' && chars[start + 1] == 'x') { [EOL]         int i = start + 2; [EOL]         if (i == sz) { [EOL]             return false; [EOL]         } [EOL]         for (; i < chars.length; i++) { [EOL]             if ((chars[i] < '0' || chars[i] > '9') && (chars[i] < 'a' || chars[i] > 'f') && (chars[i] < 'A' || chars[i] > 'F')) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     sz--; [EOL]     int i = start; [EOL]     while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             foundDigit = true; [EOL]             allowSigns = false; [EOL]         } else if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             hasDecPoint = true; [EOL]         } else if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             if (hasExp) { [EOL]                 return false; [EOL]             } [EOL]             if (!foundDigit) { [EOL]                 return false; [EOL]             } [EOL]             hasExp = true; [EOL]             allowSigns = true; [EOL]         } else if (chars[i] == '+' || chars[i] == '-') { [EOL]             if (!allowSigns) { [EOL]                 return false; [EOL]             } [EOL]             allowSigns = false; [EOL]             foundDigit = false; [EOL]         } else { [EOL]             return false; [EOL]         } [EOL]         i++; [EOL]     } [EOL]     if (i < chars.length) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             return true; [EOL]         } [EOL]         if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             return false; [EOL]         } [EOL]         if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             return foundDigit; [EOL]         } [EOL]         if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D' || chars[i] == 'f' || chars[i] == 'F')) { [EOL]             return foundDigit; [EOL]         } [EOL]         if (chars[i] == 'l' || chars[i] == 'L') { [EOL]             return foundDigit && !hasExp && !hasDecPoint; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return !allowSigns && foundDigit; [EOL] } 
 [LINE] allowSigns = false; [LINE] public static boolean isNumber(final String str) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return false; [EOL]     } [EOL]     final char[] chars = str.toCharArray(); [EOL]     int sz = chars.length; [EOL]     boolean hasExp = false; [EOL]     boolean hasDecPoint = false; [EOL]     boolean allowSigns = false; [EOL]     boolean foundDigit = false; [EOL]     final int start = (chars[0] == '-') ? 1 : 0; [EOL]     if (sz > start + 1 && chars[start] == '0' && chars[start + 1] == 'x') { [EOL]         int i = start + 2; [EOL]         if (i == sz) { [EOL]             return false; [EOL]         } [EOL]         for (; i < chars.length; i++) { [EOL]             if ((chars[i] < '0' || chars[i] > '9') && (chars[i] < 'a' || chars[i] > 'f') && (chars[i] < 'A' || chars[i] > 'F')) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     sz--; [EOL]     int i = start; [EOL]     while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             foundDigit = true; [EOL]             allowSigns = false; [EOL]         } else if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             hasDecPoint = true; [EOL]         } else if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             if (hasExp) { [EOL]                 return false; [EOL]             } [EOL]             if (!foundDigit) { [EOL]                 return false; [EOL]             } [EOL]             hasExp = true; [EOL]             allowSigns = true; [EOL]         } else if (chars[i] == '+' || chars[i] == '-') { [EOL]             if (!allowSigns) { [EOL]                 return false; [EOL]             } [EOL]             allowSigns = false; [EOL]             foundDigit = false; [EOL]         } else { [EOL]             return false; [EOL]         } [EOL]         i++; [EOL]     } [EOL]     if (i < chars.length) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             return true; [EOL]         } [EOL]         if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             return false; [EOL]         } [EOL]         if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             return foundDigit; [EOL]         } [EOL]         if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D' || chars[i] == 'f' || chars[i] == 'F')) { [EOL]             return foundDigit; [EOL]         } [EOL]         if (chars[i] == 'l' || chars[i] == 'L') { [EOL]             return foundDigit && !hasExp && !hasDecPoint; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return !allowSigns && foundDigit; [EOL] } 
 [LINE] foundDigit = false; // we need a digit after the E [LINE] public static boolean isNumber(final String str) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return false; [EOL]     } [EOL]     final char[] chars = str.toCharArray(); [EOL]     int sz = chars.length; [EOL]     boolean hasExp = false; [EOL]     boolean hasDecPoint = false; [EOL]     boolean allowSigns = false; [EOL]     boolean foundDigit = false; [EOL]     final int start = (chars[0] == '-') ? 1 : 0; [EOL]     if (sz > start + 1 && chars[start] == '0' && chars[start + 1] == 'x') { [EOL]         int i = start + 2; [EOL]         if (i == sz) { [EOL]             return false; [EOL]         } [EOL]         for (; i < chars.length; i++) { [EOL]             if ((chars[i] < '0' || chars[i] > '9') && (chars[i] < 'a' || chars[i] > 'f') && (chars[i] < 'A' || chars[i] > 'F')) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     sz--; [EOL]     int i = start; [EOL]     while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             foundDigit = true; [EOL]             allowSigns = false; [EOL]         } else if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             hasDecPoint = true; [EOL]         } else if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             if (hasExp) { [EOL]                 return false; [EOL]             } [EOL]             if (!foundDigit) { [EOL]                 return false; [EOL]             } [EOL]             hasExp = true; [EOL]             allowSigns = true; [EOL]         } else if (chars[i] == '+' || chars[i] == '-') { [EOL]             if (!allowSigns) { [EOL]                 return false; [EOL]             } [EOL]             allowSigns = false; [EOL]             foundDigit = false; [EOL]         } else { [EOL]             return false; [EOL]         } [EOL]         i++; [EOL]     } [EOL]     if (i < chars.length) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             return true; [EOL]         } [EOL]         if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             return false; [EOL]         } [EOL]         if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             return foundDigit; [EOL]         } [EOL]         if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D' || chars[i] == 'f' || chars[i] == 'F')) { [EOL]             return foundDigit; [EOL]         } [EOL]         if (chars[i] == 'l' || chars[i] == 'L') { [EOL]             return foundDigit && !hasExp && !hasDecPoint; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return !allowSigns && foundDigit; [EOL] } 
 [LINE] return false; [LINE] public static boolean isNumber(final String str) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return false; [EOL]     } [EOL]     final char[] chars = str.toCharArray(); [EOL]     int sz = chars.length; [EOL]     boolean hasExp = false; [EOL]     boolean hasDecPoint = false; [EOL]     boolean allowSigns = false; [EOL]     boolean foundDigit = false; [EOL]     final int start = (chars[0] == '-') ? 1 : 0; [EOL]     if (sz > start + 1 && chars[start] == '0' && chars[start + 1] == 'x') { [EOL]         int i = start + 2; [EOL]         if (i == sz) { [EOL]             return false; [EOL]         } [EOL]         for (; i < chars.length; i++) { [EOL]             if ((chars[i] < '0' || chars[i] > '9') && (chars[i] < 'a' || chars[i] > 'f') && (chars[i] < 'A' || chars[i] > 'F')) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     sz--; [EOL]     int i = start; [EOL]     while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             foundDigit = true; [EOL]             allowSigns = false; [EOL]         } else if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             hasDecPoint = true; [EOL]         } else if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             if (hasExp) { [EOL]                 return false; [EOL]             } [EOL]             if (!foundDigit) { [EOL]                 return false; [EOL]             } [EOL]             hasExp = true; [EOL]             allowSigns = true; [EOL]         } else if (chars[i] == '+' || chars[i] == '-') { [EOL]             if (!allowSigns) { [EOL]                 return false; [EOL]             } [EOL]             allowSigns = false; [EOL]             foundDigit = false; [EOL]         } else { [EOL]             return false; [EOL]         } [EOL]         i++; [EOL]     } [EOL]     if (i < chars.length) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             return true; [EOL]         } [EOL]         if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             return false; [EOL]         } [EOL]         if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             return foundDigit; [EOL]         } [EOL]         if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D' || chars[i] == 'f' || chars[i] == 'F')) { [EOL]             return foundDigit; [EOL]         } [EOL]         if (chars[i] == 'l' || chars[i] == 'L') { [EOL]             return foundDigit && !hasExp && !hasDecPoint; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return !allowSigns && foundDigit; [EOL] } 
 [LINE] if (hasDecPoint || hasExp) { [LINE] public static boolean isNumber(final String str) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return false; [EOL]     } [EOL]     final char[] chars = str.toCharArray(); [EOL]     int sz = chars.length; [EOL]     boolean hasExp = false; [EOL]     boolean hasDecPoint = false; [EOL]     boolean allowSigns = false; [EOL]     boolean foundDigit = false; [EOL]     final int start = (chars[0] == '-') ? 1 : 0; [EOL]     if (sz > start + 1 && chars[start] == '0' && chars[start + 1] == 'x') { [EOL]         int i = start + 2; [EOL]         if (i == sz) { [EOL]             return false; [EOL]         } [EOL]         for (; i < chars.length; i++) { [EOL]             if ((chars[i] < '0' || chars[i] > '9') && (chars[i] < 'a' || chars[i] > 'f') && (chars[i] < 'A' || chars[i] > 'F')) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     sz--; [EOL]     int i = start; [EOL]     while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             foundDigit = true; [EOL]             allowSigns = false; [EOL]         } else if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             hasDecPoint = true; [EOL]         } else if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             if (hasExp) { [EOL]                 return false; [EOL]             } [EOL]             if (!foundDigit) { [EOL]                 return false; [EOL]             } [EOL]             hasExp = true; [EOL]             allowSigns = true; [EOL]         } else if (chars[i] == '+' || chars[i] == '-') { [EOL]             if (!allowSigns) { [EOL]                 return false; [EOL]             } [EOL]             allowSigns = false; [EOL]             foundDigit = false; [EOL]         } else { [EOL]             return false; [EOL]         } [EOL]         i++; [EOL]     } [EOL]     if (i < chars.length) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             return true; [EOL]         } [EOL]         if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             return false; [EOL]         } [EOL]         if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             return foundDigit; [EOL]         } [EOL]         if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D' || chars[i] == 'f' || chars[i] == 'F')) { [EOL]             return foundDigit; [EOL]         } [EOL]         if (chars[i] == 'l' || chars[i] == 'L') { [EOL]             return foundDigit && !hasExp && !hasDecPoint; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return !allowSigns && foundDigit; [EOL] } 
 [LINE] return foundDigit; [LINE] public static boolean isNumber(final String str) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return false; [EOL]     } [EOL]     final char[] chars = str.toCharArray(); [EOL]     int sz = chars.length; [EOL]     boolean hasExp = false; [EOL]     boolean hasDecPoint = false; [EOL]     boolean allowSigns = false; [EOL]     boolean foundDigit = false; [EOL]     final int start = (chars[0] == '-') ? 1 : 0; [EOL]     if (sz > start + 1 && chars[start] == '0' && chars[start + 1] == 'x') { [EOL]         int i = start + 2; [EOL]         if (i == sz) { [EOL]             return false; [EOL]         } [EOL]         for (; i < chars.length; i++) { [EOL]             if ((chars[i] < '0' || chars[i] > '9') && (chars[i] < 'a' || chars[i] > 'f') && (chars[i] < 'A' || chars[i] > 'F')) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     sz--; [EOL]     int i = start; [EOL]     while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             foundDigit = true; [EOL]             allowSigns = false; [EOL]         } else if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             hasDecPoint = true; [EOL]         } else if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             if (hasExp) { [EOL]                 return false; [EOL]             } [EOL]             if (!foundDigit) { [EOL]                 return false; [EOL]             } [EOL]             hasExp = true; [EOL]             allowSigns = true; [EOL]         } else if (chars[i] == '+' || chars[i] == '-') { [EOL]             if (!allowSigns) { [EOL]                 return false; [EOL]             } [EOL]             allowSigns = false; [EOL]             foundDigit = false; [EOL]         } else { [EOL]             return false; [EOL]         } [EOL]         i++; [EOL]     } [EOL]     if (i < chars.length) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             return true; [EOL]         } [EOL]         if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             return false; [EOL]         } [EOL]         if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             return foundDigit; [EOL]         } [EOL]         if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D' || chars[i] == 'f' || chars[i] == 'F')) { [EOL]             return foundDigit; [EOL]         } [EOL]         if (chars[i] == 'l' || chars[i] == 'L') { [EOL]             return foundDigit && !hasExp && !hasDecPoint; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return !allowSigns && foundDigit; [EOL] } 
 [LINE] return foundDigit; [LINE] public static boolean isNumber(final String str) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return false; [EOL]     } [EOL]     final char[] chars = str.toCharArray(); [EOL]     int sz = chars.length; [EOL]     boolean hasExp = false; [EOL]     boolean hasDecPoint = false; [EOL]     boolean allowSigns = false; [EOL]     boolean foundDigit = false; [EOL]     final int start = (chars[0] == '-') ? 1 : 0; [EOL]     if (sz > start + 1 && chars[start] == '0' && chars[start + 1] == 'x') { [EOL]         int i = start + 2; [EOL]         if (i == sz) { [EOL]             return false; [EOL]         } [EOL]         for (; i < chars.length; i++) { [EOL]             if ((chars[i] < '0' || chars[i] > '9') && (chars[i] < 'a' || chars[i] > 'f') && (chars[i] < 'A' || chars[i] > 'F')) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     sz--; [EOL]     int i = start; [EOL]     while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             foundDigit = true; [EOL]             allowSigns = false; [EOL]         } else if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             hasDecPoint = true; [EOL]         } else if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             if (hasExp) { [EOL]                 return false; [EOL]             } [EOL]             if (!foundDigit) { [EOL]                 return false; [EOL]             } [EOL]             hasExp = true; [EOL]             allowSigns = true; [EOL]         } else if (chars[i] == '+' || chars[i] == '-') { [EOL]             if (!allowSigns) { [EOL]                 return false; [EOL]             } [EOL]             allowSigns = false; [EOL]             foundDigit = false; [EOL]         } else { [EOL]             return false; [EOL]         } [EOL]         i++; [EOL]     } [EOL]     if (i < chars.length) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             return true; [EOL]         } [EOL]         if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             return false; [EOL]         } [EOL]         if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             return foundDigit; [EOL]         } [EOL]         if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D' || chars[i] == 'f' || chars[i] == 'F')) { [EOL]             return foundDigit; [EOL]         } [EOL]         if (chars[i] == 'l' || chars[i] == 'L') { [EOL]             return foundDigit && !hasExp && !hasDecPoint; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return !allowSigns && foundDigit; [EOL] } 
 [LINE] return foundDigit && !hasExp && !hasDecPoint; [LINE] public static boolean isNumber(final String str) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return false; [EOL]     } [EOL]     final char[] chars = str.toCharArray(); [EOL]     int sz = chars.length; [EOL]     boolean hasExp = false; [EOL]     boolean hasDecPoint = false; [EOL]     boolean allowSigns = false; [EOL]     boolean foundDigit = false; [EOL]     final int start = (chars[0] == '-') ? 1 : 0; [EOL]     if (sz > start + 1 && chars[start] == '0' && chars[start + 1] == 'x') { [EOL]         int i = start + 2; [EOL]         if (i == sz) { [EOL]             return false; [EOL]         } [EOL]         for (; i < chars.length; i++) { [EOL]             if ((chars[i] < '0' || chars[i] > '9') && (chars[i] < 'a' || chars[i] > 'f') && (chars[i] < 'A' || chars[i] > 'F')) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     sz--; [EOL]     int i = start; [EOL]     while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             foundDigit = true; [EOL]             allowSigns = false; [EOL]         } else if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             hasDecPoint = true; [EOL]         } else if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             if (hasExp) { [EOL]                 return false; [EOL]             } [EOL]             if (!foundDigit) { [EOL]                 return false; [EOL]             } [EOL]             hasExp = true; [EOL]             allowSigns = true; [EOL]         } else if (chars[i] == '+' || chars[i] == '-') { [EOL]             if (!allowSigns) { [EOL]                 return false; [EOL]             } [EOL]             allowSigns = false; [EOL]             foundDigit = false; [EOL]         } else { [EOL]             return false; [EOL]         } [EOL]         i++; [EOL]     } [EOL]     if (i < chars.length) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             return true; [EOL]         } [EOL]         if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             return false; [EOL]         } [EOL]         if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             return foundDigit; [EOL]         } [EOL]         if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D' || chars[i] == 'f' || chars[i] == 'F')) { [EOL]             return foundDigit; [EOL]         } [EOL]         if (chars[i] == 'l' || chars[i] == 'L') { [EOL]             return foundDigit && !hasExp && !hasDecPoint; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return !allowSigns && foundDigit; [EOL] } 
 [LINE] return null; [LINE] public static String stripToNull(String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     str = strip(str, null); [EOL]     return str.isEmpty() ? null : str; [EOL] } 
 [LINE] return null; [LINE] public static String stripAccents(final String input) { [EOL]     if (input == null) { [EOL]         return null; [EOL]     } [EOL]     final Pattern pattern = Pattern.compile("\\p{InCombiningDiacriticalMarks}+"); [EOL]     final String decomposed = Normalizer.normalize(input, Normalizer.Form.NFD); [EOL]     return pattern.matcher(decomposed).replaceAll(""); [EOL] } 
 [LINE] return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [LINE] public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] } 
 [LINE] return CharSequenceUtils.regionMatches(str1, true, 0, str2, 0, str1.length()); [LINE] public static boolean equalsIgnoreCase(final CharSequence str1, final CharSequence str2) { [EOL]     if (str1 == null || str2 == null) { [EOL]         return str1 == str2; [EOL]     } else if (str1 == str2) { [EOL]         return true; [EOL]     } else if (str1.length() != str2.length()) { [EOL]         return false; [EOL]     } else { [EOL]         return CharSequenceUtils.regionMatches(str1, true, 0, str2, 0, str1.length()); [EOL]     } [EOL] } 
 [LINE] return INDEX_NOT_FOUND; [LINE] public static int indexOf(final CharSequence seq, final CharSequence searchSeq) { [EOL]     if (seq == null || searchSeq == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     return CharSequenceUtils.indexOf(seq, searchSeq, 0); [EOL] } 
 [LINE] return index; [LINE] private static int ordinalIndexOf(final CharSequence str, final CharSequence searchStr, final int ordinal, final boolean lastIndex) { [EOL]     if (str == null || searchStr == null || ordinal <= 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (searchStr.length() == 0) { [EOL]         return lastIndex ? str.length() : 0; [EOL]     } [EOL]     int found = 0; [EOL]     int index = lastIndex ? str.length() : INDEX_NOT_FOUND; [EOL]     do { [EOL]         if (lastIndex) { [EOL]             index = CharSequenceUtils.lastIndexOf(str, searchStr, index - 1); [EOL]         } else { [EOL]             index = CharSequenceUtils.indexOf(str, searchStr, index + 1); [EOL]         } [EOL]         if (index < 0) { [EOL]             return index; [EOL]         } [EOL]         found++; [EOL]     } while (found < ordinal); [EOL]     return index; [EOL] } 
 [LINE] return INDEX_NOT_FOUND; [LINE] public static int indexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int startPos) { [EOL]     if (str == null || searchStr == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startPos < 0) { [EOL]         startPos = 0; [EOL]     } [EOL]     final int endLimit = str.length() - searchStr.length() + 1; [EOL]     if (startPos > endLimit) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (searchStr.length() == 0) { [EOL]         return startPos; [EOL]     } [EOL]     for (int i = startPos; i < endLimit; i++) { [EOL]         if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStr.length())) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] } 
 [LINE] return INDEX_NOT_FOUND; [LINE] public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) { [EOL]     if (seq == null || searchSeq == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos); [EOL] } 
 [LINE] return INDEX_NOT_FOUND; [LINE] public static int lastIndexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int startPos) { [EOL]     if (str == null || searchStr == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startPos > str.length() - searchStr.length()) { [EOL]         startPos = str.length() - searchStr.length(); [EOL]     } [EOL]     if (startPos < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (searchStr.length() == 0) { [EOL]         return startPos; [EOL]     } [EOL]     for (int i = startPos; i >= 0; i--) { [EOL]         if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStr.length())) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] } 
 [LINE] if (searchChars[j + 1] == cs.charAt(i + 1)) { [LINE] public static int indexOfAny(final CharSequence cs, final char... searchChars) { [EOL]     if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     final int csLen = cs.length(); [EOL]     final int csLast = csLen - 1; [EOL]     final int searchLen = searchChars.length; [EOL]     final int searchLast = searchLen - 1; [EOL]     for (int i = 0; i < csLen; i++) { [EOL]         final char ch = cs.charAt(i); [EOL]         for (int j = 0; j < searchLen; j++) { [EOL]             if (searchChars[j] == ch) { [EOL]                 if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) { [EOL]                     if (searchChars[j + 1] == cs.charAt(i + 1)) { [EOL]                         return i; [EOL]                     } [EOL]                 } else { [EOL]                     return i; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] } 
 [LINE] return i; [LINE] public static int indexOfAny(final CharSequence cs, final char... searchChars) { [EOL]     if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     final int csLen = cs.length(); [EOL]     final int csLast = csLen - 1; [EOL]     final int searchLen = searchChars.length; [EOL]     final int searchLast = searchLen - 1; [EOL]     for (int i = 0; i < csLen; i++) { [EOL]         final char ch = cs.charAt(i); [EOL]         for (int j = 0; j < searchLen; j++) { [EOL]             if (searchChars[j] == ch) { [EOL]                 if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) { [EOL]                     if (searchChars[j + 1] == cs.charAt(i + 1)) { [EOL]                         return i; [EOL]                     } [EOL]                 } else { [EOL]                     return i; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] } 
 [LINE] if (j == searchLast) { [LINE] public static boolean containsAny(final CharSequence cs, final char... searchChars) { [EOL]     if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { [EOL]         return false; [EOL]     } [EOL]     final int csLength = cs.length(); [EOL]     final int searchLength = searchChars.length; [EOL]     final int csLast = csLength - 1; [EOL]     final int searchLast = searchLength - 1; [EOL]     for (int i = 0; i < csLength; i++) { [EOL]         final char ch = cs.charAt(i); [EOL]         for (int j = 0; j < searchLength; j++) { [EOL]             if (searchChars[j] == ch) { [EOL]                 if (Character.isHighSurrogate(ch)) { [EOL]                     if (j == searchLast) { [EOL]                         return true; [EOL]                     } [EOL]                     if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) { [EOL]                         return true; [EOL]                     } [EOL]                 } else { [EOL]                     return true; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return false; [EOL] } 
 [LINE] return true; [LINE] public static boolean containsAny(final CharSequence cs, final char... searchChars) { [EOL]     if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { [EOL]         return false; [EOL]     } [EOL]     final int csLength = cs.length(); [EOL]     final int searchLength = searchChars.length; [EOL]     final int csLast = csLength - 1; [EOL]     final int searchLast = searchLength - 1; [EOL]     for (int i = 0; i < csLength; i++) { [EOL]         final char ch = cs.charAt(i); [EOL]         for (int j = 0; j < searchLength; j++) { [EOL]             if (searchChars[j] == ch) { [EOL]                 if (Character.isHighSurrogate(ch)) { [EOL]                     if (j == searchLast) { [EOL]                         return true; [EOL]                     } [EOL]                     if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) { [EOL]                         return true; [EOL]                     } [EOL]                 } else { [EOL]                     return true; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return false; [EOL] } 
 [LINE] if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) { [LINE] public static boolean containsAny(final CharSequence cs, final char... searchChars) { [EOL]     if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { [EOL]         return false; [EOL]     } [EOL]     final int csLength = cs.length(); [EOL]     final int searchLength = searchChars.length; [EOL]     final int csLast = csLength - 1; [EOL]     final int searchLast = searchLength - 1; [EOL]     for (int i = 0; i < csLength; i++) { [EOL]         final char ch = cs.charAt(i); [EOL]         for (int j = 0; j < searchLength; j++) { [EOL]             if (searchChars[j] == ch) { [EOL]                 if (Character.isHighSurrogate(ch)) { [EOL]                     if (j == searchLast) { [EOL]                         return true; [EOL]                     } [EOL]                     if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) { [EOL]                         return true; [EOL]                     } [EOL]                 } else { [EOL]                     return true; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return false; [EOL] } 
 [LINE] return true; [LINE] public static boolean containsAny(final CharSequence cs, final char... searchChars) { [EOL]     if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { [EOL]         return false; [EOL]     } [EOL]     final int csLength = cs.length(); [EOL]     final int searchLength = searchChars.length; [EOL]     final int csLast = csLength - 1; [EOL]     final int searchLast = searchLength - 1; [EOL]     for (int i = 0; i < csLength; i++) { [EOL]         final char ch = cs.charAt(i); [EOL]         for (int j = 0; j < searchLength; j++) { [EOL]             if (searchChars[j] == ch) { [EOL]                 if (Character.isHighSurrogate(ch)) { [EOL]                     if (j == searchLast) { [EOL]                         return true; [EOL]                     } [EOL]                     if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) { [EOL]                         return true; [EOL]                     } [EOL]                 } else { [EOL]                     return true; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return false; [EOL] } 
 [LINE] if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) { [LINE] public static int indexOfAnyBut(final CharSequence cs, final char... searchChars) { [EOL]     if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     final int csLen = cs.length(); [EOL]     final int csLast = csLen - 1; [EOL]     final int searchLen = searchChars.length; [EOL]     final int searchLast = searchLen - 1; [EOL]     outer: for (int i = 0; i < csLen; i++) { [EOL]         final char ch = cs.charAt(i); [EOL]         for (int j = 0; j < searchLen; j++) { [EOL]             if (searchChars[j] == ch) { [EOL]                 if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) { [EOL]                     if (searchChars[j + 1] == cs.charAt(i + 1)) { [EOL]                         continue outer; [EOL]                     } [EOL]                 } else { [EOL]                     continue outer; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return i; [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] } 
 [LINE] if (searchChars[j + 1] == cs.charAt(i + 1)) { [LINE] public static int indexOfAnyBut(final CharSequence cs, final char... searchChars) { [EOL]     if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     final int csLen = cs.length(); [EOL]     final int csLast = csLen - 1; [EOL]     final int searchLen = searchChars.length; [EOL]     final int searchLast = searchLen - 1; [EOL]     outer: for (int i = 0; i < csLen; i++) { [EOL]         final char ch = cs.charAt(i); [EOL]         for (int j = 0; j < searchLen; j++) { [EOL]             if (searchChars[j] == ch) { [EOL]                 if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) { [EOL]                     if (searchChars[j + 1] == cs.charAt(i + 1)) { [EOL]                         continue outer; [EOL]                     } [EOL]                 } else { [EOL]                     continue outer; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return i; [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] } 
 [LINE] continue outer; [LINE] public static int indexOfAnyBut(final CharSequence cs, final char... searchChars) { [EOL]     if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     final int csLen = cs.length(); [EOL]     final int csLast = csLen - 1; [EOL]     final int searchLen = searchChars.length; [EOL]     final int searchLast = searchLen - 1; [EOL]     outer: for (int i = 0; i < csLen; i++) { [EOL]         final char ch = cs.charAt(i); [EOL]         for (int j = 0; j < searchLen; j++) { [EOL]             if (searchChars[j] == ch) { [EOL]                 if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) { [EOL]                     if (searchChars[j + 1] == cs.charAt(i + 1)) { [EOL]                         continue outer; [EOL]                     } [EOL]                 } else { [EOL]                     continue outer; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return i; [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] } 
 [LINE] continue outer; [LINE] public static int indexOfAnyBut(final CharSequence cs, final char... searchChars) { [EOL]     if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     final int csLen = cs.length(); [EOL]     final int csLast = csLen - 1; [EOL]     final int searchLen = searchChars.length; [EOL]     final int searchLast = searchLen - 1; [EOL]     outer: for (int i = 0; i < csLen; i++) { [EOL]         final char ch = cs.charAt(i); [EOL]         for (int j = 0; j < searchLen; j++) { [EOL]             if (searchChars[j] == ch) { [EOL]                 if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) { [EOL]                     if (searchChars[j + 1] == cs.charAt(i + 1)) { [EOL]                         continue outer; [EOL]                     } [EOL]                 } else { [EOL]                     continue outer; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return i; [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] } 
 [LINE] return INDEX_NOT_FOUND; [LINE] public static int indexOfAnyBut(final CharSequence cs, final char... searchChars) { [EOL]     if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     final int csLen = cs.length(); [EOL]     final int csLast = csLen - 1; [EOL]     final int searchLen = searchChars.length; [EOL]     final int searchLast = searchLen - 1; [EOL]     outer: for (int i = 0; i < csLen; i++) { [EOL]         final char ch = cs.charAt(i); [EOL]         for (int j = 0; j < searchLen; j++) { [EOL]             if (searchChars[j] == ch) { [EOL]                 if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) { [EOL]                     if (searchChars[j + 1] == cs.charAt(i + 1)) { [EOL]                         continue outer; [EOL]                     } [EOL]                 } else { [EOL]                     continue outer; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return i; [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] } 
 [LINE] final char ch2 = seq.charAt(i + 1); [LINE] public static int indexOfAnyBut(final CharSequence seq, final CharSequence searchChars) { [EOL]     if (isEmpty(seq) || isEmpty(searchChars)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     final int strLen = seq.length(); [EOL]     for (int i = 0; i < strLen; i++) { [EOL]         final char ch = seq.charAt(i); [EOL]         final boolean chFound = CharSequenceUtils.indexOf(searchChars, ch, 0) >= 0; [EOL]         if (i + 1 < strLen && Character.isHighSurrogate(ch)) { [EOL]             final char ch2 = seq.charAt(i + 1); [EOL]             if (chFound && CharSequenceUtils.indexOf(searchChars, ch2, 0) < 0) { [EOL]                 return i; [EOL]             } [EOL]         } else { [EOL]             if (!chFound) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] } 
 [LINE] if (chFound && CharSequenceUtils.indexOf(searchChars, ch2, 0) < 0) { [LINE] public static int indexOfAnyBut(final CharSequence seq, final CharSequence searchChars) { [EOL]     if (isEmpty(seq) || isEmpty(searchChars)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     final int strLen = seq.length(); [EOL]     for (int i = 0; i < strLen; i++) { [EOL]         final char ch = seq.charAt(i); [EOL]         final boolean chFound = CharSequenceUtils.indexOf(searchChars, ch, 0) >= 0; [EOL]         if (i + 1 < strLen && Character.isHighSurrogate(ch)) { [EOL]             final char ch2 = seq.charAt(i + 1); [EOL]             if (chFound && CharSequenceUtils.indexOf(searchChars, ch2, 0) < 0) { [EOL]                 return i; [EOL]             } [EOL]         } else { [EOL]             if (!chFound) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] } 
 [LINE] return i; [LINE] public static int indexOfAnyBut(final CharSequence seq, final CharSequence searchChars) { [EOL]     if (isEmpty(seq) || isEmpty(searchChars)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     final int strLen = seq.length(); [EOL]     for (int i = 0; i < strLen; i++) { [EOL]         final char ch = seq.charAt(i); [EOL]         final boolean chFound = CharSequenceUtils.indexOf(searchChars, ch, 0) >= 0; [EOL]         if (i + 1 < strLen && Character.isHighSurrogate(ch)) { [EOL]             final char ch2 = seq.charAt(i + 1); [EOL]             if (chFound && CharSequenceUtils.indexOf(searchChars, ch2, 0) < 0) { [EOL]                 return i; [EOL]             } [EOL]         } else { [EOL]             if (!chFound) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] } 
 [LINE] return i; [LINE] public static int indexOfAnyBut(final CharSequence seq, final CharSequence searchChars) { [EOL]     if (isEmpty(seq) || isEmpty(searchChars)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     final int strLen = seq.length(); [EOL]     for (int i = 0; i < strLen; i++) { [EOL]         final char ch = seq.charAt(i); [EOL]         final boolean chFound = CharSequenceUtils.indexOf(searchChars, ch, 0) >= 0; [EOL]         if (i + 1 < strLen && Character.isHighSurrogate(ch)) { [EOL]             final char ch2 = seq.charAt(i + 1); [EOL]             if (chFound && CharSequenceUtils.indexOf(searchChars, ch2, 0) < 0) { [EOL]                 return i; [EOL]             } [EOL]         } else { [EOL]             if (!chFound) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] } 
 [LINE] return false; [LINE] public static boolean containsOnly(final CharSequence cs, final char... valid) { [EOL]     if (valid == null || cs == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs.length() == 0) { [EOL]         return true; [EOL]     } [EOL]     if (valid.length == 0) { [EOL]         return false; [EOL]     } [EOL]     return indexOfAnyBut(cs, valid) == INDEX_NOT_FOUND; [EOL] } 
 [LINE] return false; [LINE] public static boolean containsOnly(final CharSequence cs, final char... valid) { [EOL]     if (valid == null || cs == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs.length() == 0) { [EOL]         return true; [EOL]     } [EOL]     if (valid.length == 0) { [EOL]         return false; [EOL]     } [EOL]     return indexOfAnyBut(cs, valid) == INDEX_NOT_FOUND; [EOL] } 
 [LINE] return false; [LINE] public static boolean containsOnly(final CharSequence cs, final String validChars) { [EOL]     if (cs == null || validChars == null) { [EOL]         return false; [EOL]     } [EOL]     return containsOnly(cs, validChars.toCharArray()); [EOL] } 
 [LINE] if (j == searchLast) { [LINE] public static boolean containsNone(final CharSequence cs, final char... searchChars) { [EOL]     if (cs == null || searchChars == null) { [EOL]         return true; [EOL]     } [EOL]     final int csLen = cs.length(); [EOL]     final int csLast = csLen - 1; [EOL]     final int searchLen = searchChars.length; [EOL]     final int searchLast = searchLen - 1; [EOL]     for (int i = 0; i < csLen; i++) { [EOL]         final char ch = cs.charAt(i); [EOL]         for (int j = 0; j < searchLen; j++) { [EOL]             if (searchChars[j] == ch) { [EOL]                 if (Character.isHighSurrogate(ch)) { [EOL]                     if (j == searchLast) { [EOL]                         return false; [EOL]                     } [EOL]                     if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) { [EOL]                         return false; [EOL]                     } [EOL]                 } else { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] return false; [LINE] public static boolean containsNone(final CharSequence cs, final char... searchChars) { [EOL]     if (cs == null || searchChars == null) { [EOL]         return true; [EOL]     } [EOL]     final int csLen = cs.length(); [EOL]     final int csLast = csLen - 1; [EOL]     final int searchLen = searchChars.length; [EOL]     final int searchLast = searchLen - 1; [EOL]     for (int i = 0; i < csLen; i++) { [EOL]         final char ch = cs.charAt(i); [EOL]         for (int j = 0; j < searchLen; j++) { [EOL]             if (searchChars[j] == ch) { [EOL]                 if (Character.isHighSurrogate(ch)) { [EOL]                     if (j == searchLast) { [EOL]                         return false; [EOL]                     } [EOL]                     if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) { [EOL]                         return false; [EOL]                     } [EOL]                 } else { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) { [LINE] public static boolean containsNone(final CharSequence cs, final char... searchChars) { [EOL]     if (cs == null || searchChars == null) { [EOL]         return true; [EOL]     } [EOL]     final int csLen = cs.length(); [EOL]     final int csLast = csLen - 1; [EOL]     final int searchLen = searchChars.length; [EOL]     final int searchLast = searchLen - 1; [EOL]     for (int i = 0; i < csLen; i++) { [EOL]         final char ch = cs.charAt(i); [EOL]         for (int j = 0; j < searchLen; j++) { [EOL]             if (searchChars[j] == ch) { [EOL]                 if (Character.isHighSurrogate(ch)) { [EOL]                     if (j == searchLast) { [EOL]                         return false; [EOL]                     } [EOL]                     if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) { [EOL]                         return false; [EOL]                     } [EOL]                 } else { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] return false; [LINE] public static boolean containsNone(final CharSequence cs, final char... searchChars) { [EOL]     if (cs == null || searchChars == null) { [EOL]         return true; [EOL]     } [EOL]     final int csLen = cs.length(); [EOL]     final int csLast = csLen - 1; [EOL]     final int searchLen = searchChars.length; [EOL]     final int searchLast = searchLen - 1; [EOL]     for (int i = 0; i < csLen; i++) { [EOL]         final char ch = cs.charAt(i); [EOL]         for (int j = 0; j < searchLen; j++) { [EOL]             if (searchChars[j] == ch) { [EOL]                 if (Character.isHighSurrogate(ch)) { [EOL]                     if (j == searchLast) { [EOL]                         return false; [EOL]                     } [EOL]                     if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) { [EOL]                         return false; [EOL]                     } [EOL]                 } else { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] return null; [LINE] public static String mid(final String str, int pos, final int len) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (len < 0 || pos > str.length()) { [EOL]         return EMPTY; [EOL]     } [EOL]     if (pos < 0) { [EOL]         pos = 0; [EOL]     } [EOL]     if (str.length() <= pos + len) { [EOL]         return str.substring(pos); [EOL]     } [EOL]     return str.substring(pos, pos + len); [EOL] } 
 [LINE] pos = 0; [LINE] public static String mid(final String str, int pos, final int len) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (len < 0 || pos > str.length()) { [EOL]         return EMPTY; [EOL]     } [EOL]     if (pos < 0) { [EOL]         pos = 0; [EOL]     } [EOL]     if (str.length() <= pos + len) { [EOL]         return str.substring(pos); [EOL]     } [EOL]     return str.substring(pos, pos + len); [EOL] } 
 [LINE] return str.substring(pos, pos + len); [LINE] public static String mid(final String str, int pos, final int len) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (len < 0 || pos > str.length()) { [EOL]         return EMPTY; [EOL]     } [EOL]     if (pos < 0) { [EOL]         pos = 0; [EOL]     } [EOL]     if (str.length() <= pos + len) { [EOL]         return str.substring(pos); [EOL]     } [EOL]     return str.substring(pos, pos + len); [EOL] } 
 [LINE] return EMPTY; [LINE] public static String substringAfter(final String str, final String separator) { [EOL]     if (isEmpty(str)) { [EOL]         return str; [EOL]     } [EOL]     if (separator == null) { [EOL]         return EMPTY; [EOL]     } [EOL]     final int pos = str.indexOf(separator); [EOL]     if (pos == INDEX_NOT_FOUND) { [EOL]         return EMPTY; [EOL]     } [EOL]     return str.substring(pos + separator.length()); [EOL] } 
 [LINE] return EMPTY; [LINE] public static String substringAfterLast(final String str, final String separator) { [EOL]     if (isEmpty(str)) { [EOL]         return str; [EOL]     } [EOL]     if (isEmpty(separator)) { [EOL]         return EMPTY; [EOL]     } [EOL]     final int pos = str.lastIndexOf(separator); [EOL]     if (pos == INDEX_NOT_FOUND || pos == str.length() - separator.length()) { [EOL]         return EMPTY; [EOL]     } [EOL]     return str.substring(pos + separator.length()); [EOL] } 
 [LINE] return str.substring(pos + separator.length()); [LINE] public static String substringAfterLast(final String str, final String separator) { [EOL]     if (isEmpty(str)) { [EOL]         return str; [EOL]     } [EOL]     if (isEmpty(separator)) { [EOL]         return EMPTY; [EOL]     } [EOL]     final int pos = str.lastIndexOf(separator); [EOL]     if (pos == INDEX_NOT_FOUND || pos == str.length() - separator.length()) { [EOL]         return EMPTY; [EOL]     } [EOL]     return str.substring(pos + separator.length()); [EOL] } 
 [LINE] return ArrayUtils.EMPTY_STRING_ARRAY; [LINE] public static String[] substringsBetween(final String str, final String open, final String close) { [EOL]     if (str == null || isEmpty(open) || isEmpty(close)) { [EOL]         return null; [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     if (strLen == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final int closeLen = close.length(); [EOL]     final int openLen = open.length(); [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int pos = 0; [EOL]     while (pos < strLen - closeLen) { [EOL]         int start = str.indexOf(open, pos); [EOL]         if (start < 0) { [EOL]             break; [EOL]         } [EOL]         start += openLen; [EOL]         final int end = str.indexOf(close, start); [EOL]         if (end < 0) { [EOL]             break; [EOL]         } [EOL]         list.add(str.substring(start, end)); [EOL]         pos = end + closeLen; [EOL]     } [EOL]     if (list.isEmpty()) { [EOL]         return null; [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] } 
 [LINE] start += openLen; [LINE] public static String[] substringsBetween(final String str, final String open, final String close) { [EOL]     if (str == null || isEmpty(open) || isEmpty(close)) { [EOL]         return null; [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     if (strLen == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final int closeLen = close.length(); [EOL]     final int openLen = open.length(); [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int pos = 0; [EOL]     while (pos < strLen - closeLen) { [EOL]         int start = str.indexOf(open, pos); [EOL]         if (start < 0) { [EOL]             break; [EOL]         } [EOL]         start += openLen; [EOL]         final int end = str.indexOf(close, start); [EOL]         if (end < 0) { [EOL]             break; [EOL]         } [EOL]         list.add(str.substring(start, end)); [EOL]         pos = end + closeLen; [EOL]     } [EOL]     if (list.isEmpty()) { [EOL]         return null; [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] } 
 [LINE] final int end = str.indexOf(close, start); [LINE] public static String[] substringsBetween(final String str, final String open, final String close) { [EOL]     if (str == null || isEmpty(open) || isEmpty(close)) { [EOL]         return null; [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     if (strLen == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final int closeLen = close.length(); [EOL]     final int openLen = open.length(); [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int pos = 0; [EOL]     while (pos < strLen - closeLen) { [EOL]         int start = str.indexOf(open, pos); [EOL]         if (start < 0) { [EOL]             break; [EOL]         } [EOL]         start += openLen; [EOL]         final int end = str.indexOf(close, start); [EOL]         if (end < 0) { [EOL]             break; [EOL]         } [EOL]         list.add(str.substring(start, end)); [EOL]         pos = end + closeLen; [EOL]     } [EOL]     if (list.isEmpty()) { [EOL]         return null; [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] } 
 [LINE] if (end < 0) { [LINE] public static String[] substringsBetween(final String str, final String open, final String close) { [EOL]     if (str == null || isEmpty(open) || isEmpty(close)) { [EOL]         return null; [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     if (strLen == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final int closeLen = close.length(); [EOL]     final int openLen = open.length(); [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int pos = 0; [EOL]     while (pos < strLen - closeLen) { [EOL]         int start = str.indexOf(open, pos); [EOL]         if (start < 0) { [EOL]             break; [EOL]         } [EOL]         start += openLen; [EOL]         final int end = str.indexOf(close, start); [EOL]         if (end < 0) { [EOL]             break; [EOL]         } [EOL]         list.add(str.substring(start, end)); [EOL]         pos = end + closeLen; [EOL]     } [EOL]     if (list.isEmpty()) { [EOL]         return null; [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] } 
 [LINE] break; [LINE] public static String[] substringsBetween(final String str, final String open, final String close) { [EOL]     if (str == null || isEmpty(open) || isEmpty(close)) { [EOL]         return null; [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     if (strLen == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final int closeLen = close.length(); [EOL]     final int openLen = open.length(); [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int pos = 0; [EOL]     while (pos < strLen - closeLen) { [EOL]         int start = str.indexOf(open, pos); [EOL]         if (start < 0) { [EOL]             break; [EOL]         } [EOL]         start += openLen; [EOL]         final int end = str.indexOf(close, start); [EOL]         if (end < 0) { [EOL]             break; [EOL]         } [EOL]         list.add(str.substring(start, end)); [EOL]         pos = end + closeLen; [EOL]     } [EOL]     if (list.isEmpty()) { [EOL]         return null; [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] } 
 [LINE] list.add(str.substring(start, end)); [LINE] public static String[] substringsBetween(final String str, final String open, final String close) { [EOL]     if (str == null || isEmpty(open) || isEmpty(close)) { [EOL]         return null; [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     if (strLen == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final int closeLen = close.length(); [EOL]     final int openLen = open.length(); [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int pos = 0; [EOL]     while (pos < strLen - closeLen) { [EOL]         int start = str.indexOf(open, pos); [EOL]         if (start < 0) { [EOL]             break; [EOL]         } [EOL]         start += openLen; [EOL]         final int end = str.indexOf(close, start); [EOL]         if (end < 0) { [EOL]             break; [EOL]         } [EOL]         list.add(str.substring(start, end)); [EOL]         pos = end + closeLen; [EOL]     } [EOL]     if (list.isEmpty()) { [EOL]         return null; [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] } 
 [LINE] pos = end + closeLen; [LINE] public static String[] substringsBetween(final String str, final String open, final String close) { [EOL]     if (str == null || isEmpty(open) || isEmpty(close)) { [EOL]         return null; [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     if (strLen == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final int closeLen = close.length(); [EOL]     final int openLen = open.length(); [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int pos = 0; [EOL]     while (pos < strLen - closeLen) { [EOL]         int start = str.indexOf(open, pos); [EOL]         if (start < 0) { [EOL]             break; [EOL]         } [EOL]         start += openLen; [EOL]         final int end = str.indexOf(close, start); [EOL]         if (end < 0) { [EOL]             break; [EOL]         } [EOL]         list.add(str.substring(start, end)); [EOL]         pos = end + closeLen; [EOL]     } [EOL]     if (list.isEmpty()) { [EOL]         return null; [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] } 
 [LINE] return list.toArray(new String [list.size()]); [LINE] public static String[] substringsBetween(final String str, final String open, final String close) { [EOL]     if (str == null || isEmpty(open) || isEmpty(close)) { [EOL]         return null; [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     if (strLen == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final int closeLen = close.length(); [EOL]     final int openLen = open.length(); [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int pos = 0; [EOL]     while (pos < strLen - closeLen) { [EOL]         int start = str.indexOf(open, pos); [EOL]         if (start < 0) { [EOL]             break; [EOL]         } [EOL]         start += openLen; [EOL]         final int end = str.indexOf(close, start); [EOL]         if (end < 0) { [EOL]             break; [EOL]         } [EOL]         list.add(str.substring(start, end)); [EOL]         pos = end + closeLen; [EOL]     } [EOL]     if (list.isEmpty()) { [EOL]         return null; [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] } 
 [LINE] numberOfSubstrings += 1; [LINE] private static String[] splitByWholeSeparatorWorker(final String str, final String separator, final int max, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     if (separator == null || EMPTY.equals(separator)) { [EOL]         return splitWorker(str, null, max, preserveAllTokens); [EOL]     } [EOL]     final int separatorLength = separator.length(); [EOL]     final ArrayList<String> substrings = new ArrayList<String>(); [EOL]     int numberOfSubstrings = 0; [EOL]     int beg = 0; [EOL]     int end = 0; [EOL]     while (end < len) { [EOL]         end = str.indexOf(separator, beg); [EOL]         if (end > -1) { [EOL]             if (end > beg) { [EOL]                 numberOfSubstrings += 1; [EOL]                 if (numberOfSubstrings == max) { [EOL]                     end = len; [EOL]                     substrings.add(str.substring(beg)); [EOL]                 } else { [EOL]                     substrings.add(str.substring(beg, end)); [EOL]                     beg = end + separatorLength; [EOL]                 } [EOL]             } else { [EOL]                 if (preserveAllTokens) { [EOL]                     numberOfSubstrings += 1; [EOL]                     if (numberOfSubstrings == max) { [EOL]                         end = len; [EOL]                         substrings.add(str.substring(beg)); [EOL]                     } else { [EOL]                         substrings.add(EMPTY); [EOL]                     } [EOL]                 } [EOL]                 beg = end + separatorLength; [EOL]             } [EOL]         } else { [EOL]             substrings.add(str.substring(beg)); [EOL]             end = len; [EOL]         } [EOL]     } [EOL]     return substrings.toArray(new String[substrings.size()]); [EOL] } 
 [LINE] if (numberOfSubstrings == max) { [LINE] private static String[] splitByWholeSeparatorWorker(final String str, final String separator, final int max, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     if (separator == null || EMPTY.equals(separator)) { [EOL]         return splitWorker(str, null, max, preserveAllTokens); [EOL]     } [EOL]     final int separatorLength = separator.length(); [EOL]     final ArrayList<String> substrings = new ArrayList<String>(); [EOL]     int numberOfSubstrings = 0; [EOL]     int beg = 0; [EOL]     int end = 0; [EOL]     while (end < len) { [EOL]         end = str.indexOf(separator, beg); [EOL]         if (end > -1) { [EOL]             if (end > beg) { [EOL]                 numberOfSubstrings += 1; [EOL]                 if (numberOfSubstrings == max) { [EOL]                     end = len; [EOL]                     substrings.add(str.substring(beg)); [EOL]                 } else { [EOL]                     substrings.add(str.substring(beg, end)); [EOL]                     beg = end + separatorLength; [EOL]                 } [EOL]             } else { [EOL]                 if (preserveAllTokens) { [EOL]                     numberOfSubstrings += 1; [EOL]                     if (numberOfSubstrings == max) { [EOL]                         end = len; [EOL]                         substrings.add(str.substring(beg)); [EOL]                     } else { [EOL]                         substrings.add(EMPTY); [EOL]                     } [EOL]                 } [EOL]                 beg = end + separatorLength; [EOL]             } [EOL]         } else { [EOL]             substrings.add(str.substring(beg)); [EOL]             end = len; [EOL]         } [EOL]     } [EOL]     return substrings.toArray(new String[substrings.size()]); [EOL] } 
 [LINE] end = len; [LINE] private static String[] splitByWholeSeparatorWorker(final String str, final String separator, final int max, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     if (separator == null || EMPTY.equals(separator)) { [EOL]         return splitWorker(str, null, max, preserveAllTokens); [EOL]     } [EOL]     final int separatorLength = separator.length(); [EOL]     final ArrayList<String> substrings = new ArrayList<String>(); [EOL]     int numberOfSubstrings = 0; [EOL]     int beg = 0; [EOL]     int end = 0; [EOL]     while (end < len) { [EOL]         end = str.indexOf(separator, beg); [EOL]         if (end > -1) { [EOL]             if (end > beg) { [EOL]                 numberOfSubstrings += 1; [EOL]                 if (numberOfSubstrings == max) { [EOL]                     end = len; [EOL]                     substrings.add(str.substring(beg)); [EOL]                 } else { [EOL]                     substrings.add(str.substring(beg, end)); [EOL]                     beg = end + separatorLength; [EOL]                 } [EOL]             } else { [EOL]                 if (preserveAllTokens) { [EOL]                     numberOfSubstrings += 1; [EOL]                     if (numberOfSubstrings == max) { [EOL]                         end = len; [EOL]                         substrings.add(str.substring(beg)); [EOL]                     } else { [EOL]                         substrings.add(EMPTY); [EOL]                     } [EOL]                 } [EOL]                 beg = end + separatorLength; [EOL]             } [EOL]         } else { [EOL]             substrings.add(str.substring(beg)); [EOL]             end = len; [EOL]         } [EOL]     } [EOL]     return substrings.toArray(new String[substrings.size()]); [EOL] } 
 [LINE] substrings.add(str.substring(beg)); [LINE] private static String[] splitByWholeSeparatorWorker(final String str, final String separator, final int max, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     if (separator == null || EMPTY.equals(separator)) { [EOL]         return splitWorker(str, null, max, preserveAllTokens); [EOL]     } [EOL]     final int separatorLength = separator.length(); [EOL]     final ArrayList<String> substrings = new ArrayList<String>(); [EOL]     int numberOfSubstrings = 0; [EOL]     int beg = 0; [EOL]     int end = 0; [EOL]     while (end < len) { [EOL]         end = str.indexOf(separator, beg); [EOL]         if (end > -1) { [EOL]             if (end > beg) { [EOL]                 numberOfSubstrings += 1; [EOL]                 if (numberOfSubstrings == max) { [EOL]                     end = len; [EOL]                     substrings.add(str.substring(beg)); [EOL]                 } else { [EOL]                     substrings.add(str.substring(beg, end)); [EOL]                     beg = end + separatorLength; [EOL]                 } [EOL]             } else { [EOL]                 if (preserveAllTokens) { [EOL]                     numberOfSubstrings += 1; [EOL]                     if (numberOfSubstrings == max) { [EOL]                         end = len; [EOL]                         substrings.add(str.substring(beg)); [EOL]                     } else { [EOL]                         substrings.add(EMPTY); [EOL]                     } [EOL]                 } [EOL]                 beg = end + separatorLength; [EOL]             } [EOL]         } else { [EOL]             substrings.add(str.substring(beg)); [EOL]             end = len; [EOL]         } [EOL]     } [EOL]     return substrings.toArray(new String[substrings.size()]); [EOL] } 
 [LINE] substrings.add(str.substring(beg, end)); [LINE] private static String[] splitByWholeSeparatorWorker(final String str, final String separator, final int max, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     if (separator == null || EMPTY.equals(separator)) { [EOL]         return splitWorker(str, null, max, preserveAllTokens); [EOL]     } [EOL]     final int separatorLength = separator.length(); [EOL]     final ArrayList<String> substrings = new ArrayList<String>(); [EOL]     int numberOfSubstrings = 0; [EOL]     int beg = 0; [EOL]     int end = 0; [EOL]     while (end < len) { [EOL]         end = str.indexOf(separator, beg); [EOL]         if (end > -1) { [EOL]             if (end > beg) { [EOL]                 numberOfSubstrings += 1; [EOL]                 if (numberOfSubstrings == max) { [EOL]                     end = len; [EOL]                     substrings.add(str.substring(beg)); [EOL]                 } else { [EOL]                     substrings.add(str.substring(beg, end)); [EOL]                     beg = end + separatorLength; [EOL]                 } [EOL]             } else { [EOL]                 if (preserveAllTokens) { [EOL]                     numberOfSubstrings += 1; [EOL]                     if (numberOfSubstrings == max) { [EOL]                         end = len; [EOL]                         substrings.add(str.substring(beg)); [EOL]                     } else { [EOL]                         substrings.add(EMPTY); [EOL]                     } [EOL]                 } [EOL]                 beg = end + separatorLength; [EOL]             } [EOL]         } else { [EOL]             substrings.add(str.substring(beg)); [EOL]             end = len; [EOL]         } [EOL]     } [EOL]     return substrings.toArray(new String[substrings.size()]); [EOL] } 
 [LINE] beg = end + separatorLength; [LINE] private static String[] splitByWholeSeparatorWorker(final String str, final String separator, final int max, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     if (separator == null || EMPTY.equals(separator)) { [EOL]         return splitWorker(str, null, max, preserveAllTokens); [EOL]     } [EOL]     final int separatorLength = separator.length(); [EOL]     final ArrayList<String> substrings = new ArrayList<String>(); [EOL]     int numberOfSubstrings = 0; [EOL]     int beg = 0; [EOL]     int end = 0; [EOL]     while (end < len) { [EOL]         end = str.indexOf(separator, beg); [EOL]         if (end > -1) { [EOL]             if (end > beg) { [EOL]                 numberOfSubstrings += 1; [EOL]                 if (numberOfSubstrings == max) { [EOL]                     end = len; [EOL]                     substrings.add(str.substring(beg)); [EOL]                 } else { [EOL]                     substrings.add(str.substring(beg, end)); [EOL]                     beg = end + separatorLength; [EOL]                 } [EOL]             } else { [EOL]                 if (preserveAllTokens) { [EOL]                     numberOfSubstrings += 1; [EOL]                     if (numberOfSubstrings == max) { [EOL]                         end = len; [EOL]                         substrings.add(str.substring(beg)); [EOL]                     } else { [EOL]                         substrings.add(EMPTY); [EOL]                     } [EOL]                 } [EOL]                 beg = end + separatorLength; [EOL]             } [EOL]         } else { [EOL]             substrings.add(str.substring(beg)); [EOL]             end = len; [EOL]         } [EOL]     } [EOL]     return substrings.toArray(new String[substrings.size()]); [EOL] } 
 [LINE] end = len; [LINE] private static String[] splitByWholeSeparatorWorker(final String str, final String separator, final int max, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     if (separator == null || EMPTY.equals(separator)) { [EOL]         return splitWorker(str, null, max, preserveAllTokens); [EOL]     } [EOL]     final int separatorLength = separator.length(); [EOL]     final ArrayList<String> substrings = new ArrayList<String>(); [EOL]     int numberOfSubstrings = 0; [EOL]     int beg = 0; [EOL]     int end = 0; [EOL]     while (end < len) { [EOL]         end = str.indexOf(separator, beg); [EOL]         if (end > -1) { [EOL]             if (end > beg) { [EOL]                 numberOfSubstrings += 1; [EOL]                 if (numberOfSubstrings == max) { [EOL]                     end = len; [EOL]                     substrings.add(str.substring(beg)); [EOL]                 } else { [EOL]                     substrings.add(str.substring(beg, end)); [EOL]                     beg = end + separatorLength; [EOL]                 } [EOL]             } else { [EOL]                 if (preserveAllTokens) { [EOL]                     numberOfSubstrings += 1; [EOL]                     if (numberOfSubstrings == max) { [EOL]                         end = len; [EOL]                         substrings.add(str.substring(beg)); [EOL]                     } else { [EOL]                         substrings.add(EMPTY); [EOL]                     } [EOL]                 } [EOL]                 beg = end + separatorLength; [EOL]             } [EOL]         } else { [EOL]             substrings.add(str.substring(beg)); [EOL]             end = len; [EOL]         } [EOL]     } [EOL]     return substrings.toArray(new String[substrings.size()]); [EOL] } 
 [LINE] substrings.add(str.substring(beg)); [LINE] private static String[] splitByWholeSeparatorWorker(final String str, final String separator, final int max, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     if (separator == null || EMPTY.equals(separator)) { [EOL]         return splitWorker(str, null, max, preserveAllTokens); [EOL]     } [EOL]     final int separatorLength = separator.length(); [EOL]     final ArrayList<String> substrings = new ArrayList<String>(); [EOL]     int numberOfSubstrings = 0; [EOL]     int beg = 0; [EOL]     int end = 0; [EOL]     while (end < len) { [EOL]         end = str.indexOf(separator, beg); [EOL]         if (end > -1) { [EOL]             if (end > beg) { [EOL]                 numberOfSubstrings += 1; [EOL]                 if (numberOfSubstrings == max) { [EOL]                     end = len; [EOL]                     substrings.add(str.substring(beg)); [EOL]                 } else { [EOL]                     substrings.add(str.substring(beg, end)); [EOL]                     beg = end + separatorLength; [EOL]                 } [EOL]             } else { [EOL]                 if (preserveAllTokens) { [EOL]                     numberOfSubstrings += 1; [EOL]                     if (numberOfSubstrings == max) { [EOL]                         end = len; [EOL]                         substrings.add(str.substring(beg)); [EOL]                     } else { [EOL]                         substrings.add(EMPTY); [EOL]                     } [EOL]                 } [EOL]                 beg = end + separatorLength; [EOL]             } [EOL]         } else { [EOL]             substrings.add(str.substring(beg)); [EOL]             end = len; [EOL]         } [EOL]     } [EOL]     return substrings.toArray(new String[substrings.size()]); [EOL] } 
 [LINE] i = len; [LINE] private static String[] splitWorker(final String str, final String separatorChars, final int max, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int sizePlus1 = 1; [EOL]     int i = 0, start = 0; [EOL]     boolean match = false; [EOL]     boolean lastMatch = false; [EOL]     if (separatorChars == null) { [EOL]         while (i < len) { [EOL]             if (Character.isWhitespace(str.charAt(i))) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else if (separatorChars.length() == 1) { [EOL]         final char sep = separatorChars.charAt(0); [EOL]         while (i < len) { [EOL]             if (str.charAt(i) == sep) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else { [EOL]         while (i < len) { [EOL]             if (separatorChars.indexOf(str.charAt(i)) >= 0) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } [EOL]     if (match || preserveAllTokens && lastMatch) { [EOL]         list.add(str.substring(start, i)); [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] } 
 [LINE] lastMatch = false; [LINE] private static String[] splitWorker(final String str, final String separatorChars, final int max, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int sizePlus1 = 1; [EOL]     int i = 0, start = 0; [EOL]     boolean match = false; [EOL]     boolean lastMatch = false; [EOL]     if (separatorChars == null) { [EOL]         while (i < len) { [EOL]             if (Character.isWhitespace(str.charAt(i))) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else if (separatorChars.length() == 1) { [EOL]         final char sep = separatorChars.charAt(0); [EOL]         while (i < len) { [EOL]             if (str.charAt(i) == sep) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else { [EOL]         while (i < len) { [EOL]             if (separatorChars.indexOf(str.charAt(i)) >= 0) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } [EOL]     if (match || preserveAllTokens && lastMatch) { [EOL]         list.add(str.substring(start, i)); [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] } 
 [LINE] final char sep = separatorChars.charAt(0); [LINE] private static String[] splitWorker(final String str, final String separatorChars, final int max, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int sizePlus1 = 1; [EOL]     int i = 0, start = 0; [EOL]     boolean match = false; [EOL]     boolean lastMatch = false; [EOL]     if (separatorChars == null) { [EOL]         while (i < len) { [EOL]             if (Character.isWhitespace(str.charAt(i))) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else if (separatorChars.length() == 1) { [EOL]         final char sep = separatorChars.charAt(0); [EOL]         while (i < len) { [EOL]             if (str.charAt(i) == sep) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else { [EOL]         while (i < len) { [EOL]             if (separatorChars.indexOf(str.charAt(i)) >= 0) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } [EOL]     if (match || preserveAllTokens && lastMatch) { [EOL]         list.add(str.substring(start, i)); [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] } 
 [LINE] while (i < len) { [LINE] private static String[] splitWorker(final String str, final String separatorChars, final int max, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int sizePlus1 = 1; [EOL]     int i = 0, start = 0; [EOL]     boolean match = false; [EOL]     boolean lastMatch = false; [EOL]     if (separatorChars == null) { [EOL]         while (i < len) { [EOL]             if (Character.isWhitespace(str.charAt(i))) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else if (separatorChars.length() == 1) { [EOL]         final char sep = separatorChars.charAt(0); [EOL]         while (i < len) { [EOL]             if (str.charAt(i) == sep) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else { [EOL]         while (i < len) { [EOL]             if (separatorChars.indexOf(str.charAt(i)) >= 0) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } [EOL]     if (match || preserveAllTokens && lastMatch) { [EOL]         list.add(str.substring(start, i)); [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] } 
 [LINE] if (str.charAt(i) == sep) { [LINE] private static String[] splitWorker(final String str, final String separatorChars, final int max, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int sizePlus1 = 1; [EOL]     int i = 0, start = 0; [EOL]     boolean match = false; [EOL]     boolean lastMatch = false; [EOL]     if (separatorChars == null) { [EOL]         while (i < len) { [EOL]             if (Character.isWhitespace(str.charAt(i))) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else if (separatorChars.length() == 1) { [EOL]         final char sep = separatorChars.charAt(0); [EOL]         while (i < len) { [EOL]             if (str.charAt(i) == sep) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else { [EOL]         while (i < len) { [EOL]             if (separatorChars.indexOf(str.charAt(i)) >= 0) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } [EOL]     if (match || preserveAllTokens && lastMatch) { [EOL]         list.add(str.substring(start, i)); [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] } 
 [LINE] if (match || preserveAllTokens) { [LINE] private static String[] splitWorker(final String str, final String separatorChars, final int max, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int sizePlus1 = 1; [EOL]     int i = 0, start = 0; [EOL]     boolean match = false; [EOL]     boolean lastMatch = false; [EOL]     if (separatorChars == null) { [EOL]         while (i < len) { [EOL]             if (Character.isWhitespace(str.charAt(i))) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else if (separatorChars.length() == 1) { [EOL]         final char sep = separatorChars.charAt(0); [EOL]         while (i < len) { [EOL]             if (str.charAt(i) == sep) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else { [EOL]         while (i < len) { [EOL]             if (separatorChars.indexOf(str.charAt(i)) >= 0) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } [EOL]     if (match || preserveAllTokens && lastMatch) { [EOL]         list.add(str.substring(start, i)); [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] } 
 [LINE] lastMatch = true; [LINE] private static String[] splitWorker(final String str, final String separatorChars, final int max, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int sizePlus1 = 1; [EOL]     int i = 0, start = 0; [EOL]     boolean match = false; [EOL]     boolean lastMatch = false; [EOL]     if (separatorChars == null) { [EOL]         while (i < len) { [EOL]             if (Character.isWhitespace(str.charAt(i))) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else if (separatorChars.length() == 1) { [EOL]         final char sep = separatorChars.charAt(0); [EOL]         while (i < len) { [EOL]             if (str.charAt(i) == sep) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else { [EOL]         while (i < len) { [EOL]             if (separatorChars.indexOf(str.charAt(i)) >= 0) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } [EOL]     if (match || preserveAllTokens && lastMatch) { [EOL]         list.add(str.substring(start, i)); [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] } 
 [LINE] if (sizePlus1++ == max) { [LINE] private static String[] splitWorker(final String str, final String separatorChars, final int max, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int sizePlus1 = 1; [EOL]     int i = 0, start = 0; [EOL]     boolean match = false; [EOL]     boolean lastMatch = false; [EOL]     if (separatorChars == null) { [EOL]         while (i < len) { [EOL]             if (Character.isWhitespace(str.charAt(i))) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else if (separatorChars.length() == 1) { [EOL]         final char sep = separatorChars.charAt(0); [EOL]         while (i < len) { [EOL]             if (str.charAt(i) == sep) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else { [EOL]         while (i < len) { [EOL]             if (separatorChars.indexOf(str.charAt(i)) >= 0) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } [EOL]     if (match || preserveAllTokens && lastMatch) { [EOL]         list.add(str.substring(start, i)); [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] } 
 [LINE] i = len; [LINE] private static String[] splitWorker(final String str, final String separatorChars, final int max, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int sizePlus1 = 1; [EOL]     int i = 0, start = 0; [EOL]     boolean match = false; [EOL]     boolean lastMatch = false; [EOL]     if (separatorChars == null) { [EOL]         while (i < len) { [EOL]             if (Character.isWhitespace(str.charAt(i))) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else if (separatorChars.length() == 1) { [EOL]         final char sep = separatorChars.charAt(0); [EOL]         while (i < len) { [EOL]             if (str.charAt(i) == sep) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else { [EOL]         while (i < len) { [EOL]             if (separatorChars.indexOf(str.charAt(i)) >= 0) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } [EOL]     if (match || preserveAllTokens && lastMatch) { [EOL]         list.add(str.substring(start, i)); [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] } 
 [LINE] lastMatch = false; [LINE] private static String[] splitWorker(final String str, final String separatorChars, final int max, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int sizePlus1 = 1; [EOL]     int i = 0, start = 0; [EOL]     boolean match = false; [EOL]     boolean lastMatch = false; [EOL]     if (separatorChars == null) { [EOL]         while (i < len) { [EOL]             if (Character.isWhitespace(str.charAt(i))) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else if (separatorChars.length() == 1) { [EOL]         final char sep = separatorChars.charAt(0); [EOL]         while (i < len) { [EOL]             if (str.charAt(i) == sep) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else { [EOL]         while (i < len) { [EOL]             if (separatorChars.indexOf(str.charAt(i)) >= 0) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } [EOL]     if (match || preserveAllTokens && lastMatch) { [EOL]         list.add(str.substring(start, i)); [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] } 
 [LINE] list.add(str.substring(start, i)); [LINE] private static String[] splitWorker(final String str, final String separatorChars, final int max, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int sizePlus1 = 1; [EOL]     int i = 0, start = 0; [EOL]     boolean match = false; [EOL]     boolean lastMatch = false; [EOL]     if (separatorChars == null) { [EOL]         while (i < len) { [EOL]             if (Character.isWhitespace(str.charAt(i))) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else if (separatorChars.length() == 1) { [EOL]         final char sep = separatorChars.charAt(0); [EOL]         while (i < len) { [EOL]             if (str.charAt(i) == sep) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else { [EOL]         while (i < len) { [EOL]             if (separatorChars.indexOf(str.charAt(i)) >= 0) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } [EOL]     if (match || preserveAllTokens && lastMatch) { [EOL]         list.add(str.substring(start, i)); [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] } 
 [LINE] match = false; [LINE] private static String[] splitWorker(final String str, final String separatorChars, final int max, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int sizePlus1 = 1; [EOL]     int i = 0, start = 0; [EOL]     boolean match = false; [EOL]     boolean lastMatch = false; [EOL]     if (separatorChars == null) { [EOL]         while (i < len) { [EOL]             if (Character.isWhitespace(str.charAt(i))) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else if (separatorChars.length() == 1) { [EOL]         final char sep = separatorChars.charAt(0); [EOL]         while (i < len) { [EOL]             if (str.charAt(i) == sep) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else { [EOL]         while (i < len) { [EOL]             if (separatorChars.indexOf(str.charAt(i)) >= 0) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } [EOL]     if (match || preserveAllTokens && lastMatch) { [EOL]         list.add(str.substring(start, i)); [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] } 
 [LINE] start = ++i; [LINE] private static String[] splitWorker(final String str, final String separatorChars, final int max, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int sizePlus1 = 1; [EOL]     int i = 0, start = 0; [EOL]     boolean match = false; [EOL]     boolean lastMatch = false; [EOL]     if (separatorChars == null) { [EOL]         while (i < len) { [EOL]             if (Character.isWhitespace(str.charAt(i))) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else if (separatorChars.length() == 1) { [EOL]         final char sep = separatorChars.charAt(0); [EOL]         while (i < len) { [EOL]             if (str.charAt(i) == sep) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else { [EOL]         while (i < len) { [EOL]             if (separatorChars.indexOf(str.charAt(i)) >= 0) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } [EOL]     if (match || preserveAllTokens && lastMatch) { [EOL]         list.add(str.substring(start, i)); [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] } 
 [LINE] continue; [LINE] private static String[] splitWorker(final String str, final String separatorChars, final int max, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int sizePlus1 = 1; [EOL]     int i = 0, start = 0; [EOL]     boolean match = false; [EOL]     boolean lastMatch = false; [EOL]     if (separatorChars == null) { [EOL]         while (i < len) { [EOL]             if (Character.isWhitespace(str.charAt(i))) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else if (separatorChars.length() == 1) { [EOL]         final char sep = separatorChars.charAt(0); [EOL]         while (i < len) { [EOL]             if (str.charAt(i) == sep) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else { [EOL]         while (i < len) { [EOL]             if (separatorChars.indexOf(str.charAt(i)) >= 0) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } [EOL]     if (match || preserveAllTokens && lastMatch) { [EOL]         list.add(str.substring(start, i)); [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] } 
 [LINE] lastMatch = false; [LINE] private static String[] splitWorker(final String str, final String separatorChars, final int max, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int sizePlus1 = 1; [EOL]     int i = 0, start = 0; [EOL]     boolean match = false; [EOL]     boolean lastMatch = false; [EOL]     if (separatorChars == null) { [EOL]         while (i < len) { [EOL]             if (Character.isWhitespace(str.charAt(i))) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else if (separatorChars.length() == 1) { [EOL]         final char sep = separatorChars.charAt(0); [EOL]         while (i < len) { [EOL]             if (str.charAt(i) == sep) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else { [EOL]         while (i < len) { [EOL]             if (separatorChars.indexOf(str.charAt(i)) >= 0) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } [EOL]     if (match || preserveAllTokens && lastMatch) { [EOL]         list.add(str.substring(start, i)); [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] } 
 [LINE] match = true; [LINE] private static String[] splitWorker(final String str, final String separatorChars, final int max, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int sizePlus1 = 1; [EOL]     int i = 0, start = 0; [EOL]     boolean match = false; [EOL]     boolean lastMatch = false; [EOL]     if (separatorChars == null) { [EOL]         while (i < len) { [EOL]             if (Character.isWhitespace(str.charAt(i))) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else if (separatorChars.length() == 1) { [EOL]         final char sep = separatorChars.charAt(0); [EOL]         while (i < len) { [EOL]             if (str.charAt(i) == sep) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else { [EOL]         while (i < len) { [EOL]             if (separatorChars.indexOf(str.charAt(i)) >= 0) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } [EOL]     if (match || preserveAllTokens && lastMatch) { [EOL]         list.add(str.substring(start, i)); [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] } 
 [LINE] i++; [LINE] private static String[] splitWorker(final String str, final String separatorChars, final int max, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int sizePlus1 = 1; [EOL]     int i = 0, start = 0; [EOL]     boolean match = false; [EOL]     boolean lastMatch = false; [EOL]     if (separatorChars == null) { [EOL]         while (i < len) { [EOL]             if (Character.isWhitespace(str.charAt(i))) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else if (separatorChars.length() == 1) { [EOL]         final char sep = separatorChars.charAt(0); [EOL]         while (i < len) { [EOL]             if (str.charAt(i) == sep) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else { [EOL]         while (i < len) { [EOL]             if (separatorChars.indexOf(str.charAt(i)) >= 0) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } [EOL]     if (match || preserveAllTokens && lastMatch) { [EOL]         list.add(str.substring(start, i)); [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] } 
 [LINE] return null; [LINE] public static String join(final float[] array, final char separator) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     return join(array, separator, 0, array.length); [EOL] } 
 [LINE] return null; [LINE] public static String join(final double[] array, final char separator) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     return join(array, separator, 0, array.length); [EOL] } 
 [LINE] return null; [LINE] public static String join(final Iterator<?> iterator, final char separator) { [EOL]     if (iterator == null) { [EOL]         return null; [EOL]     } [EOL]     if (!iterator.hasNext()) { [EOL]         return EMPTY; [EOL]     } [EOL]     final Object first = iterator.next(); [EOL]     if (!iterator.hasNext()) { [EOL]         return ObjectUtils.toString(first); [EOL]     } [EOL]     final StringBuilder buf = new StringBuilder(256); [EOL]     if (first != null) { [EOL]         buf.append(first); [EOL]     } [EOL]     while (iterator.hasNext()) { [EOL]         buf.append(separator); [EOL]         final Object obj = iterator.next(); [EOL]         if (obj != null) { [EOL]             buf.append(obj); [EOL]         } [EOL]     } [EOL]     return buf.toString(); [EOL] } 
 [LINE] break; [LINE] public static String replace(final String text, final String searchString, final String replacement, int max) { [EOL]     if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) { [EOL]         return text; [EOL]     } [EOL]     int start = 0; [EOL]     int end = text.indexOf(searchString, start); [EOL]     if (end == INDEX_NOT_FOUND) { [EOL]         return text; [EOL]     } [EOL]     final int replLength = searchString.length(); [EOL]     int increase = replacement.length() - replLength; [EOL]     increase = increase < 0 ? 0 : increase; [EOL]     increase *= max < 0 ? 16 : max > 64 ? 64 : max; [EOL]     final StringBuilder buf = new StringBuilder(text.length() + increase); [EOL]     while (end != INDEX_NOT_FOUND) { [EOL]         buf.append(text.substring(start, end)).append(replacement); [EOL]         start = end + replLength; [EOL]         if (--max == 0) { [EOL]             break; [EOL]         } [EOL]         end = text.indexOf(searchString, start); [EOL]     } [EOL]     buf.append(text.substring(start)); [EOL]     return buf.toString(); [EOL] } 
 [LINE] increase += 3 * greater; // assume 3 matches [LINE] private static String replaceEach(final String text, final String[] searchList, final String[] replacementList, final boolean repeat, final int timeToLive) { [EOL]     if (text == null || text.isEmpty() || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) { [EOL]         return text; [EOL]     } [EOL]     if (timeToLive < 0) { [EOL]         throw new IllegalStateException("Aborting to protect against StackOverflowError - " + "output of one loop is the input of another"); [EOL]     } [EOL]     final int searchLength = searchList.length; [EOL]     final int replacementLength = replacementList.length; [EOL]     if (searchLength != replacementLength) { [EOL]         throw new IllegalArgumentException("Search and Replace array lengths don't match: " + searchLength + " vs " + replacementLength); [EOL]     } [EOL]     final boolean[] noMoreMatchesForReplIndex = new boolean[searchLength]; [EOL]     int textIndex = -1; [EOL]     int replaceIndex = -1; [EOL]     int tempIndex = -1; [EOL]     for (int i = 0; i < searchLength; i++) { [EOL]         if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) { [EOL]             continue; [EOL]         } [EOL]         tempIndex = text.indexOf(searchList[i]); [EOL]         if (tempIndex == -1) { [EOL]             noMoreMatchesForReplIndex[i] = true; [EOL]         } else { [EOL]             if (textIndex == -1 || tempIndex < textIndex) { [EOL]                 textIndex = tempIndex; [EOL]                 replaceIndex = i; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (textIndex == -1) { [EOL]         return text; [EOL]     } [EOL]     int start = 0; [EOL]     int increase = 0; [EOL]     for (int i = 0; i < searchList.length; i++) { [EOL]         if (searchList[i] == null || replacementList[i] == null) { [EOL]             continue; [EOL]         } [EOL]         final int greater = replacementList[i].length() - searchList[i].length(); [EOL]         if (greater > 0) { [EOL]             increase += 3 * greater; [EOL]         } [EOL]     } [EOL]     increase = Math.min(increase, text.length() / 5); [EOL]     final StringBuilder buf = new StringBuilder(text.length() + increase); [EOL]     while (textIndex != -1) { [EOL]         for (int i = start; i < textIndex; i++) { [EOL]             buf.append(text.charAt(i)); [EOL]         } [EOL]         buf.append(replacementList[replaceIndex]); [EOL]         start = textIndex + searchList[replaceIndex].length(); [EOL]         textIndex = -1; [EOL]         replaceIndex = -1; [EOL]         tempIndex = -1; [EOL]         for (int i = 0; i < searchLength; i++) { [EOL]             if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) { [EOL]                 continue; [EOL]             } [EOL]             tempIndex = text.indexOf(searchList[i], start); [EOL]             if (tempIndex == -1) { [EOL]                 noMoreMatchesForReplIndex[i] = true; [EOL]             } else { [EOL]                 if (textIndex == -1 || tempIndex < textIndex) { [EOL]                     textIndex = tempIndex; [EOL]                     replaceIndex = i; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     final int textLength = text.length(); [EOL]     for (int i = start; i < textLength; i++) { [EOL]         buf.append(text.charAt(i)); [EOL]     } [EOL]     final String result = buf.toString(); [EOL]     if (!repeat) { [EOL]         return result; [EOL]     } [EOL]     return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1); [EOL] } 
 [LINE] buf.append(text.charAt(i)); [LINE] private static String replaceEach(final String text, final String[] searchList, final String[] replacementList, final boolean repeat, final int timeToLive) { [EOL]     if (text == null || text.isEmpty() || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) { [EOL]         return text; [EOL]     } [EOL]     if (timeToLive < 0) { [EOL]         throw new IllegalStateException("Aborting to protect against StackOverflowError - " + "output of one loop is the input of another"); [EOL]     } [EOL]     final int searchLength = searchList.length; [EOL]     final int replacementLength = replacementList.length; [EOL]     if (searchLength != replacementLength) { [EOL]         throw new IllegalArgumentException("Search and Replace array lengths don't match: " + searchLength + " vs " + replacementLength); [EOL]     } [EOL]     final boolean[] noMoreMatchesForReplIndex = new boolean[searchLength]; [EOL]     int textIndex = -1; [EOL]     int replaceIndex = -1; [EOL]     int tempIndex = -1; [EOL]     for (int i = 0; i < searchLength; i++) { [EOL]         if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) { [EOL]             continue; [EOL]         } [EOL]         tempIndex = text.indexOf(searchList[i]); [EOL]         if (tempIndex == -1) { [EOL]             noMoreMatchesForReplIndex[i] = true; [EOL]         } else { [EOL]             if (textIndex == -1 || tempIndex < textIndex) { [EOL]                 textIndex = tempIndex; [EOL]                 replaceIndex = i; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (textIndex == -1) { [EOL]         return text; [EOL]     } [EOL]     int start = 0; [EOL]     int increase = 0; [EOL]     for (int i = 0; i < searchList.length; i++) { [EOL]         if (searchList[i] == null || replacementList[i] == null) { [EOL]             continue; [EOL]         } [EOL]         final int greater = replacementList[i].length() - searchList[i].length(); [EOL]         if (greater > 0) { [EOL]             increase += 3 * greater; [EOL]         } [EOL]     } [EOL]     increase = Math.min(increase, text.length() / 5); [EOL]     final StringBuilder buf = new StringBuilder(text.length() + increase); [EOL]     while (textIndex != -1) { [EOL]         for (int i = start; i < textIndex; i++) { [EOL]             buf.append(text.charAt(i)); [EOL]         } [EOL]         buf.append(replacementList[replaceIndex]); [EOL]         start = textIndex + searchList[replaceIndex].length(); [EOL]         textIndex = -1; [EOL]         replaceIndex = -1; [EOL]         tempIndex = -1; [EOL]         for (int i = 0; i < searchLength; i++) { [EOL]             if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) { [EOL]                 continue; [EOL]             } [EOL]             tempIndex = text.indexOf(searchList[i], start); [EOL]             if (tempIndex == -1) { [EOL]                 noMoreMatchesForReplIndex[i] = true; [EOL]             } else { [EOL]                 if (textIndex == -1 || tempIndex < textIndex) { [EOL]                     textIndex = tempIndex; [EOL]                     replaceIndex = i; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     final int textLength = text.length(); [EOL]     for (int i = start; i < textLength; i++) { [EOL]         buf.append(text.charAt(i)); [EOL]     } [EOL]     final String result = buf.toString(); [EOL]     if (!repeat) { [EOL]         return result; [EOL]     } [EOL]     return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1); [EOL] } 
 [LINE] if (textIndex == -1 || tempIndex < textIndex) { [LINE] private static String replaceEach(final String text, final String[] searchList, final String[] replacementList, final boolean repeat, final int timeToLive) { [EOL]     if (text == null || text.isEmpty() || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) { [EOL]         return text; [EOL]     } [EOL]     if (timeToLive < 0) { [EOL]         throw new IllegalStateException("Aborting to protect against StackOverflowError - " + "output of one loop is the input of another"); [EOL]     } [EOL]     final int searchLength = searchList.length; [EOL]     final int replacementLength = replacementList.length; [EOL]     if (searchLength != replacementLength) { [EOL]         throw new IllegalArgumentException("Search and Replace array lengths don't match: " + searchLength + " vs " + replacementLength); [EOL]     } [EOL]     final boolean[] noMoreMatchesForReplIndex = new boolean[searchLength]; [EOL]     int textIndex = -1; [EOL]     int replaceIndex = -1; [EOL]     int tempIndex = -1; [EOL]     for (int i = 0; i < searchLength; i++) { [EOL]         if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) { [EOL]             continue; [EOL]         } [EOL]         tempIndex = text.indexOf(searchList[i]); [EOL]         if (tempIndex == -1) { [EOL]             noMoreMatchesForReplIndex[i] = true; [EOL]         } else { [EOL]             if (textIndex == -1 || tempIndex < textIndex) { [EOL]                 textIndex = tempIndex; [EOL]                 replaceIndex = i; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (textIndex == -1) { [EOL]         return text; [EOL]     } [EOL]     int start = 0; [EOL]     int increase = 0; [EOL]     for (int i = 0; i < searchList.length; i++) { [EOL]         if (searchList[i] == null || replacementList[i] == null) { [EOL]             continue; [EOL]         } [EOL]         final int greater = replacementList[i].length() - searchList[i].length(); [EOL]         if (greater > 0) { [EOL]             increase += 3 * greater; [EOL]         } [EOL]     } [EOL]     increase = Math.min(increase, text.length() / 5); [EOL]     final StringBuilder buf = new StringBuilder(text.length() + increase); [EOL]     while (textIndex != -1) { [EOL]         for (int i = start; i < textIndex; i++) { [EOL]             buf.append(text.charAt(i)); [EOL]         } [EOL]         buf.append(replacementList[replaceIndex]); [EOL]         start = textIndex + searchList[replaceIndex].length(); [EOL]         textIndex = -1; [EOL]         replaceIndex = -1; [EOL]         tempIndex = -1; [EOL]         for (int i = 0; i < searchLength; i++) { [EOL]             if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) { [EOL]                 continue; [EOL]             } [EOL]             tempIndex = text.indexOf(searchList[i], start); [EOL]             if (tempIndex == -1) { [EOL]                 noMoreMatchesForReplIndex[i] = true; [EOL]             } else { [EOL]                 if (textIndex == -1 || tempIndex < textIndex) { [EOL]                     textIndex = tempIndex; [EOL]                     replaceIndex = i; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     final int textLength = text.length(); [EOL]     for (int i = start; i < textLength; i++) { [EOL]         buf.append(text.charAt(i)); [EOL]     } [EOL]     final String result = buf.toString(); [EOL]     if (!repeat) { [EOL]         return result; [EOL]     } [EOL]     return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1); [EOL] } 
 [LINE] textIndex = tempIndex; [LINE] private static String replaceEach(final String text, final String[] searchList, final String[] replacementList, final boolean repeat, final int timeToLive) { [EOL]     if (text == null || text.isEmpty() || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) { [EOL]         return text; [EOL]     } [EOL]     if (timeToLive < 0) { [EOL]         throw new IllegalStateException("Aborting to protect against StackOverflowError - " + "output of one loop is the input of another"); [EOL]     } [EOL]     final int searchLength = searchList.length; [EOL]     final int replacementLength = replacementList.length; [EOL]     if (searchLength != replacementLength) { [EOL]         throw new IllegalArgumentException("Search and Replace array lengths don't match: " + searchLength + " vs " + replacementLength); [EOL]     } [EOL]     final boolean[] noMoreMatchesForReplIndex = new boolean[searchLength]; [EOL]     int textIndex = -1; [EOL]     int replaceIndex = -1; [EOL]     int tempIndex = -1; [EOL]     for (int i = 0; i < searchLength; i++) { [EOL]         if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) { [EOL]             continue; [EOL]         } [EOL]         tempIndex = text.indexOf(searchList[i]); [EOL]         if (tempIndex == -1) { [EOL]             noMoreMatchesForReplIndex[i] = true; [EOL]         } else { [EOL]             if (textIndex == -1 || tempIndex < textIndex) { [EOL]                 textIndex = tempIndex; [EOL]                 replaceIndex = i; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (textIndex == -1) { [EOL]         return text; [EOL]     } [EOL]     int start = 0; [EOL]     int increase = 0; [EOL]     for (int i = 0; i < searchList.length; i++) { [EOL]         if (searchList[i] == null || replacementList[i] == null) { [EOL]             continue; [EOL]         } [EOL]         final int greater = replacementList[i].length() - searchList[i].length(); [EOL]         if (greater > 0) { [EOL]             increase += 3 * greater; [EOL]         } [EOL]     } [EOL]     increase = Math.min(increase, text.length() / 5); [EOL]     final StringBuilder buf = new StringBuilder(text.length() + increase); [EOL]     while (textIndex != -1) { [EOL]         for (int i = start; i < textIndex; i++) { [EOL]             buf.append(text.charAt(i)); [EOL]         } [EOL]         buf.append(replacementList[replaceIndex]); [EOL]         start = textIndex + searchList[replaceIndex].length(); [EOL]         textIndex = -1; [EOL]         replaceIndex = -1; [EOL]         tempIndex = -1; [EOL]         for (int i = 0; i < searchLength; i++) { [EOL]             if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) { [EOL]                 continue; [EOL]             } [EOL]             tempIndex = text.indexOf(searchList[i], start); [EOL]             if (tempIndex == -1) { [EOL]                 noMoreMatchesForReplIndex[i] = true; [EOL]             } else { [EOL]                 if (textIndex == -1 || tempIndex < textIndex) { [EOL]                     textIndex = tempIndex; [EOL]                     replaceIndex = i; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     final int textLength = text.length(); [EOL]     for (int i = start; i < textLength; i++) { [EOL]         buf.append(text.charAt(i)); [EOL]     } [EOL]     final String result = buf.toString(); [EOL]     if (!repeat) { [EOL]         return result; [EOL]     } [EOL]     return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1); [EOL] } 
 [LINE] replaceIndex = i; [LINE] private static String replaceEach(final String text, final String[] searchList, final String[] replacementList, final boolean repeat, final int timeToLive) { [EOL]     if (text == null || text.isEmpty() || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) { [EOL]         return text; [EOL]     } [EOL]     if (timeToLive < 0) { [EOL]         throw new IllegalStateException("Aborting to protect against StackOverflowError - " + "output of one loop is the input of another"); [EOL]     } [EOL]     final int searchLength = searchList.length; [EOL]     final int replacementLength = replacementList.length; [EOL]     if (searchLength != replacementLength) { [EOL]         throw new IllegalArgumentException("Search and Replace array lengths don't match: " + searchLength + " vs " + replacementLength); [EOL]     } [EOL]     final boolean[] noMoreMatchesForReplIndex = new boolean[searchLength]; [EOL]     int textIndex = -1; [EOL]     int replaceIndex = -1; [EOL]     int tempIndex = -1; [EOL]     for (int i = 0; i < searchLength; i++) { [EOL]         if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) { [EOL]             continue; [EOL]         } [EOL]         tempIndex = text.indexOf(searchList[i]); [EOL]         if (tempIndex == -1) { [EOL]             noMoreMatchesForReplIndex[i] = true; [EOL]         } else { [EOL]             if (textIndex == -1 || tempIndex < textIndex) { [EOL]                 textIndex = tempIndex; [EOL]                 replaceIndex = i; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (textIndex == -1) { [EOL]         return text; [EOL]     } [EOL]     int start = 0; [EOL]     int increase = 0; [EOL]     for (int i = 0; i < searchList.length; i++) { [EOL]         if (searchList[i] == null || replacementList[i] == null) { [EOL]             continue; [EOL]         } [EOL]         final int greater = replacementList[i].length() - searchList[i].length(); [EOL]         if (greater > 0) { [EOL]             increase += 3 * greater; [EOL]         } [EOL]     } [EOL]     increase = Math.min(increase, text.length() / 5); [EOL]     final StringBuilder buf = new StringBuilder(text.length() + increase); [EOL]     while (textIndex != -1) { [EOL]         for (int i = start; i < textIndex; i++) { [EOL]             buf.append(text.charAt(i)); [EOL]         } [EOL]         buf.append(replacementList[replaceIndex]); [EOL]         start = textIndex + searchList[replaceIndex].length(); [EOL]         textIndex = -1; [EOL]         replaceIndex = -1; [EOL]         tempIndex = -1; [EOL]         for (int i = 0; i < searchLength; i++) { [EOL]             if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) { [EOL]                 continue; [EOL]             } [EOL]             tempIndex = text.indexOf(searchList[i], start); [EOL]             if (tempIndex == -1) { [EOL]                 noMoreMatchesForReplIndex[i] = true; [EOL]             } else { [EOL]                 if (textIndex == -1 || tempIndex < textIndex) { [EOL]                     textIndex = tempIndex; [EOL]                     replaceIndex = i; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     final int textLength = text.length(); [EOL]     for (int i = start; i < textLength; i++) { [EOL]         buf.append(text.charAt(i)); [EOL]     } [EOL]     final String result = buf.toString(); [EOL]     if (!repeat) { [EOL]         return result; [EOL]     } [EOL]     return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1); [EOL] } 
 [LINE] buf.append(text.charAt(i)); [LINE] private static String replaceEach(final String text, final String[] searchList, final String[] replacementList, final boolean repeat, final int timeToLive) { [EOL]     if (text == null || text.isEmpty() || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) { [EOL]         return text; [EOL]     } [EOL]     if (timeToLive < 0) { [EOL]         throw new IllegalStateException("Aborting to protect against StackOverflowError - " + "output of one loop is the input of another"); [EOL]     } [EOL]     final int searchLength = searchList.length; [EOL]     final int replacementLength = replacementList.length; [EOL]     if (searchLength != replacementLength) { [EOL]         throw new IllegalArgumentException("Search and Replace array lengths don't match: " + searchLength + " vs " + replacementLength); [EOL]     } [EOL]     final boolean[] noMoreMatchesForReplIndex = new boolean[searchLength]; [EOL]     int textIndex = -1; [EOL]     int replaceIndex = -1; [EOL]     int tempIndex = -1; [EOL]     for (int i = 0; i < searchLength; i++) { [EOL]         if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) { [EOL]             continue; [EOL]         } [EOL]         tempIndex = text.indexOf(searchList[i]); [EOL]         if (tempIndex == -1) { [EOL]             noMoreMatchesForReplIndex[i] = true; [EOL]         } else { [EOL]             if (textIndex == -1 || tempIndex < textIndex) { [EOL]                 textIndex = tempIndex; [EOL]                 replaceIndex = i; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (textIndex == -1) { [EOL]         return text; [EOL]     } [EOL]     int start = 0; [EOL]     int increase = 0; [EOL]     for (int i = 0; i < searchList.length; i++) { [EOL]         if (searchList[i] == null || replacementList[i] == null) { [EOL]             continue; [EOL]         } [EOL]         final int greater = replacementList[i].length() - searchList[i].length(); [EOL]         if (greater > 0) { [EOL]             increase += 3 * greater; [EOL]         } [EOL]     } [EOL]     increase = Math.min(increase, text.length() / 5); [EOL]     final StringBuilder buf = new StringBuilder(text.length() + increase); [EOL]     while (textIndex != -1) { [EOL]         for (int i = start; i < textIndex; i++) { [EOL]             buf.append(text.charAt(i)); [EOL]         } [EOL]         buf.append(replacementList[replaceIndex]); [EOL]         start = textIndex + searchList[replaceIndex].length(); [EOL]         textIndex = -1; [EOL]         replaceIndex = -1; [EOL]         tempIndex = -1; [EOL]         for (int i = 0; i < searchLength; i++) { [EOL]             if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) { [EOL]                 continue; [EOL]             } [EOL]             tempIndex = text.indexOf(searchList[i], start); [EOL]             if (tempIndex == -1) { [EOL]                 noMoreMatchesForReplIndex[i] = true; [EOL]             } else { [EOL]                 if (textIndex == -1 || tempIndex < textIndex) { [EOL]                     textIndex = tempIndex; [EOL]                     replaceIndex = i; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     final int textLength = text.length(); [EOL]     for (int i = start; i < textLength; i++) { [EOL]         buf.append(text.charAt(i)); [EOL]     } [EOL]     final String result = buf.toString(); [EOL]     if (!repeat) { [EOL]         return result; [EOL]     } [EOL]     return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1); [EOL] } 
 [LINE] replaceChars = EMPTY; [LINE] public static String replaceChars(final String str, final String searchChars, String replaceChars) { [EOL]     if (isEmpty(str) || isEmpty(searchChars)) { [EOL]         return str; [EOL]     } [EOL]     if (replaceChars == null) { [EOL]         replaceChars = EMPTY; [EOL]     } [EOL]     boolean modified = false; [EOL]     final int replaceCharsLength = replaceChars.length(); [EOL]     final int strLength = str.length(); [EOL]     final StringBuilder buf = new StringBuilder(strLength); [EOL]     for (int i = 0; i < strLength; i++) { [EOL]         final char ch = str.charAt(i); [EOL]         final int index = searchChars.indexOf(ch); [EOL]         if (index >= 0) { [EOL]             modified = true; [EOL]             if (index < replaceCharsLength) { [EOL]                 buf.append(replaceChars.charAt(index)); [EOL]             } [EOL]         } else { [EOL]             buf.append(ch); [EOL]         } [EOL]     } [EOL]     if (modified) { [EOL]         return buf.toString(); [EOL]     } [EOL]     return str; [EOL] } 
 [LINE] return str; [LINE] public static String replaceChars(final String str, final String searchChars, String replaceChars) { [EOL]     if (isEmpty(str) || isEmpty(searchChars)) { [EOL]         return str; [EOL]     } [EOL]     if (replaceChars == null) { [EOL]         replaceChars = EMPTY; [EOL]     } [EOL]     boolean modified = false; [EOL]     final int replaceCharsLength = replaceChars.length(); [EOL]     final int strLength = str.length(); [EOL]     final StringBuilder buf = new StringBuilder(strLength); [EOL]     for (int i = 0; i < strLength; i++) { [EOL]         final char ch = str.charAt(i); [EOL]         final int index = searchChars.indexOf(ch); [EOL]         if (index >= 0) { [EOL]             modified = true; [EOL]             if (index < replaceCharsLength) { [EOL]                 buf.append(replaceChars.charAt(index)); [EOL]             } [EOL]         } else { [EOL]             buf.append(ch); [EOL]         } [EOL]     } [EOL]     if (modified) { [EOL]         return buf.toString(); [EOL]     } [EOL]     return str; [EOL] } 
 [LINE] final char ch = str.charAt(0); [LINE] public static String chomp(final String str) { [EOL]     if (isEmpty(str)) { [EOL]         return str; [EOL]     } [EOL]     if (str.length() == 1) { [EOL]         final char ch = str.charAt(0); [EOL]         if (ch == CharUtils.CR || ch == CharUtils.LF) { [EOL]             return EMPTY; [EOL]         } [EOL]         return str; [EOL]     } [EOL]     int lastIdx = str.length() - 1; [EOL]     final char last = str.charAt(lastIdx); [EOL]     if (last == CharUtils.LF) { [EOL]         if (str.charAt(lastIdx - 1) == CharUtils.CR) { [EOL]             lastIdx--; [EOL]         } [EOL]     } else if (last != CharUtils.CR) { [EOL]         lastIdx++; [EOL]     } [EOL]     return str.substring(0, lastIdx); [EOL] } 
 [LINE] if (ch == CharUtils.CR || ch == CharUtils.LF) { [LINE] public static String chomp(final String str) { [EOL]     if (isEmpty(str)) { [EOL]         return str; [EOL]     } [EOL]     if (str.length() == 1) { [EOL]         final char ch = str.charAt(0); [EOL]         if (ch == CharUtils.CR || ch == CharUtils.LF) { [EOL]             return EMPTY; [EOL]         } [EOL]         return str; [EOL]     } [EOL]     int lastIdx = str.length() - 1; [EOL]     final char last = str.charAt(lastIdx); [EOL]     if (last == CharUtils.LF) { [EOL]         if (str.charAt(lastIdx - 1) == CharUtils.CR) { [EOL]             lastIdx--; [EOL]         } [EOL]     } else if (last != CharUtils.CR) { [EOL]         lastIdx++; [EOL]     } [EOL]     return str.substring(0, lastIdx); [EOL] } 
 [LINE] return EMPTY; [LINE] public static String chomp(final String str) { [EOL]     if (isEmpty(str)) { [EOL]         return str; [EOL]     } [EOL]     if (str.length() == 1) { [EOL]         final char ch = str.charAt(0); [EOL]         if (ch == CharUtils.CR || ch == CharUtils.LF) { [EOL]             return EMPTY; [EOL]         } [EOL]         return str; [EOL]     } [EOL]     int lastIdx = str.length() - 1; [EOL]     final char last = str.charAt(lastIdx); [EOL]     if (last == CharUtils.LF) { [EOL]         if (str.charAt(lastIdx - 1) == CharUtils.CR) { [EOL]             lastIdx--; [EOL]         } [EOL]     } else if (last != CharUtils.CR) { [EOL]         lastIdx++; [EOL]     } [EOL]     return str.substring(0, lastIdx); [EOL] } 
 [LINE] return str; [LINE] public static String chomp(final String str) { [EOL]     if (isEmpty(str)) { [EOL]         return str; [EOL]     } [EOL]     if (str.length() == 1) { [EOL]         final char ch = str.charAt(0); [EOL]         if (ch == CharUtils.CR || ch == CharUtils.LF) { [EOL]             return EMPTY; [EOL]         } [EOL]         return str; [EOL]     } [EOL]     int lastIdx = str.length() - 1; [EOL]     final char last = str.charAt(lastIdx); [EOL]     if (last == CharUtils.LF) { [EOL]         if (str.charAt(lastIdx - 1) == CharUtils.CR) { [EOL]             lastIdx--; [EOL]         } [EOL]     } else if (last != CharUtils.CR) { [EOL]         lastIdx++; [EOL]     } [EOL]     return str.substring(0, lastIdx); [EOL] } 
 [LINE] if (str.charAt(lastIdx - 1) == CharUtils.CR) { [LINE] public static String chomp(final String str) { [EOL]     if (isEmpty(str)) { [EOL]         return str; [EOL]     } [EOL]     if (str.length() == 1) { [EOL]         final char ch = str.charAt(0); [EOL]         if (ch == CharUtils.CR || ch == CharUtils.LF) { [EOL]             return EMPTY; [EOL]         } [EOL]         return str; [EOL]     } [EOL]     int lastIdx = str.length() - 1; [EOL]     final char last = str.charAt(lastIdx); [EOL]     if (last == CharUtils.LF) { [EOL]         if (str.charAt(lastIdx - 1) == CharUtils.CR) { [EOL]             lastIdx--; [EOL]         } [EOL]     } else if (last != CharUtils.CR) { [EOL]         lastIdx++; [EOL]     } [EOL]     return str.substring(0, lastIdx); [EOL] } 
 [LINE] lastIdx--; [LINE] public static String chomp(final String str) { [EOL]     if (isEmpty(str)) { [EOL]         return str; [EOL]     } [EOL]     if (str.length() == 1) { [EOL]         final char ch = str.charAt(0); [EOL]         if (ch == CharUtils.CR || ch == CharUtils.LF) { [EOL]             return EMPTY; [EOL]         } [EOL]         return str; [EOL]     } [EOL]     int lastIdx = str.length() - 1; [EOL]     final char last = str.charAt(lastIdx); [EOL]     if (last == CharUtils.LF) { [EOL]         if (str.charAt(lastIdx - 1) == CharUtils.CR) { [EOL]             lastIdx--; [EOL]         } [EOL]     } else if (last != CharUtils.CR) { [EOL]         lastIdx++; [EOL]     } [EOL]     return str.substring(0, lastIdx); [EOL] } 
 [LINE] return ret.substring(0, lastIdx - 1); [LINE] public static String chop(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     if (strLen < 2) { [EOL]         return EMPTY; [EOL]     } [EOL]     final int lastIdx = strLen - 1; [EOL]     final String ret = str.substring(0, lastIdx); [EOL]     final char last = str.charAt(lastIdx); [EOL]     if (last == CharUtils.LF && ret.charAt(lastIdx - 1) == CharUtils.CR) { [EOL]         return ret.substring(0, lastIdx - 1); [EOL]     } [EOL]     return ret; [EOL] } 
 [LINE] return repeat(str.charAt(0), repeat); [LINE] public static String repeat(final String str, final int repeat) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (repeat <= 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final int inputLength = str.length(); [EOL]     if (repeat == 1 || inputLength == 0) { [EOL]         return str; [EOL]     } [EOL]     if (inputLength == 1 && repeat <= PAD_LIMIT) { [EOL]         return repeat(str.charAt(0), repeat); [EOL]     } [EOL]     final int outputLength = inputLength * repeat; [EOL]     switch(inputLength) { [EOL]         case 1: [EOL]             return repeat(str.charAt(0), repeat); [EOL]         case 2: [EOL]             final char ch0 = str.charAt(0); [EOL]             final char ch1 = str.charAt(1); [EOL]             final char[] output2 = new char[outputLength]; [EOL]             for (int i = repeat * 2 - 2; i >= 0; i--, i--) { [EOL]                 output2[i] = ch0; [EOL]                 output2[i + 1] = ch1; [EOL]             } [EOL]             return new String(output2); [EOL]         default: [EOL]             final StringBuilder buf = new StringBuilder(outputLength); [EOL]             for (int i = 0; i < repeat; i++) { [EOL]                 buf.append(str); [EOL]             } [EOL]             return buf.toString(); [EOL]     } [EOL] } 
 [LINE] case 1 : [LINE] public static String repeat(final String str, final int repeat) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (repeat <= 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final int inputLength = str.length(); [EOL]     if (repeat == 1 || inputLength == 0) { [EOL]         return str; [EOL]     } [EOL]     if (inputLength == 1 && repeat <= PAD_LIMIT) { [EOL]         return repeat(str.charAt(0), repeat); [EOL]     } [EOL]     final int outputLength = inputLength * repeat; [EOL]     switch(inputLength) { [EOL]         case 1: [EOL]             return repeat(str.charAt(0), repeat); [EOL]         case 2: [EOL]             final char ch0 = str.charAt(0); [EOL]             final char ch1 = str.charAt(1); [EOL]             final char[] output2 = new char[outputLength]; [EOL]             for (int i = repeat * 2 - 2; i >= 0; i--, i--) { [EOL]                 output2[i] = ch0; [EOL]                 output2[i + 1] = ch1; [EOL]             } [EOL]             return new String(output2); [EOL]         default: [EOL]             final StringBuilder buf = new StringBuilder(outputLength); [EOL]             for (int i = 0; i < repeat; i++) { [EOL]                 buf.append(str); [EOL]             } [EOL]             return buf.toString(); [EOL]     } [EOL] } 
 [LINE] return repeat(str.charAt(0), repeat); [LINE] public static String repeat(final String str, final int repeat) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (repeat <= 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final int inputLength = str.length(); [EOL]     if (repeat == 1 || inputLength == 0) { [EOL]         return str; [EOL]     } [EOL]     if (inputLength == 1 && repeat <= PAD_LIMIT) { [EOL]         return repeat(str.charAt(0), repeat); [EOL]     } [EOL]     final int outputLength = inputLength * repeat; [EOL]     switch(inputLength) { [EOL]         case 1: [EOL]             return repeat(str.charAt(0), repeat); [EOL]         case 2: [EOL]             final char ch0 = str.charAt(0); [EOL]             final char ch1 = str.charAt(1); [EOL]             final char[] output2 = new char[outputLength]; [EOL]             for (int i = repeat * 2 - 2; i >= 0; i--, i--) { [EOL]                 output2[i] = ch0; [EOL]                 output2[i + 1] = ch1; [EOL]             } [EOL]             return new String(output2); [EOL]         default: [EOL]             final StringBuilder buf = new StringBuilder(outputLength); [EOL]             for (int i = 0; i < repeat; i++) { [EOL]                 buf.append(str); [EOL]             } [EOL]             return buf.toString(); [EOL]     } [EOL] } 
 [LINE] return rightPad(str, size, String.valueOf(padChar)); [LINE] public static String rightPad(final String str, final int size, final char padChar) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int pads = size - str.length(); [EOL]     if (pads <= 0) { [EOL]         return str; [EOL]     } [EOL]     if (pads > PAD_LIMIT) { [EOL]         return rightPad(str, size, String.valueOf(padChar)); [EOL]     } [EOL]     return str.concat(repeat(padChar, pads)); [EOL] } 
 [LINE] return null; [LINE] public static String rightPad(final String str, final int size, String padStr) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (isEmpty(padStr)) { [EOL]         padStr = SPACE; [EOL]     } [EOL]     final int padLen = padStr.length(); [EOL]     final int strLen = str.length(); [EOL]     final int pads = size - strLen; [EOL]     if (pads <= 0) { [EOL]         return str; [EOL]     } [EOL]     if (padLen == 1 && pads <= PAD_LIMIT) { [EOL]         return rightPad(str, size, padStr.charAt(0)); [EOL]     } [EOL]     if (pads == padLen) { [EOL]         return str.concat(padStr); [EOL]     } else if (pads < padLen) { [EOL]         return str.concat(padStr.substring(0, pads)); [EOL]     } else { [EOL]         final char[] padding = new char[pads]; [EOL]         final char[] padChars = padStr.toCharArray(); [EOL]         for (int i = 0; i < pads; i++) { [EOL]             padding[i] = padChars[i % padLen]; [EOL]         } [EOL]         return str.concat(new String(padding)); [EOL]     } [EOL] } 
 [LINE] return str.concat(padStr); [LINE] public static String rightPad(final String str, final int size, String padStr) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (isEmpty(padStr)) { [EOL]         padStr = SPACE; [EOL]     } [EOL]     final int padLen = padStr.length(); [EOL]     final int strLen = str.length(); [EOL]     final int pads = size - strLen; [EOL]     if (pads <= 0) { [EOL]         return str; [EOL]     } [EOL]     if (padLen == 1 && pads <= PAD_LIMIT) { [EOL]         return rightPad(str, size, padStr.charAt(0)); [EOL]     } [EOL]     if (pads == padLen) { [EOL]         return str.concat(padStr); [EOL]     } else if (pads < padLen) { [EOL]         return str.concat(padStr.substring(0, pads)); [EOL]     } else { [EOL]         final char[] padding = new char[pads]; [EOL]         final char[] padChars = padStr.toCharArray(); [EOL]         for (int i = 0; i < pads; i++) { [EOL]             padding[i] = padChars[i % padLen]; [EOL]         } [EOL]         return str.concat(new String(padding)); [EOL]     } [EOL] } 
 [LINE] return leftPad(str, size, String.valueOf(padChar)); [LINE] public static String leftPad(final String str, final int size, final char padChar) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int pads = size - str.length(); [EOL]     if (pads <= 0) { [EOL]         return str; [EOL]     } [EOL]     if (pads > PAD_LIMIT) { [EOL]         return leftPad(str, size, String.valueOf(padChar)); [EOL]     } [EOL]     return repeat(padChar, pads).concat(str); [EOL] } 
 [LINE] return padStr.concat(str); [LINE] public static String leftPad(final String str, final int size, String padStr) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (isEmpty(padStr)) { [EOL]         padStr = SPACE; [EOL]     } [EOL]     final int padLen = padStr.length(); [EOL]     final int strLen = str.length(); [EOL]     final int pads = size - strLen; [EOL]     if (pads <= 0) { [EOL]         return str; [EOL]     } [EOL]     if (padLen == 1 && pads <= PAD_LIMIT) { [EOL]         return leftPad(str, size, padStr.charAt(0)); [EOL]     } [EOL]     if (pads == padLen) { [EOL]         return padStr.concat(str); [EOL]     } else if (pads < padLen) { [EOL]         return padStr.substring(0, pads).concat(str); [EOL]     } else { [EOL]         final char[] padding = new char[pads]; [EOL]         final char[] padChars = padStr.toCharArray(); [EOL]         for (int i = 0; i < pads; i++) { [EOL]             padding[i] = padChars[i % padLen]; [EOL]         } [EOL]         return new String(padding).concat(str); [EOL]     } [EOL] } 
 [LINE] return padStr.substring(0, pads).concat(str); [LINE] public static String leftPad(final String str, final int size, String padStr) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (isEmpty(padStr)) { [EOL]         padStr = SPACE; [EOL]     } [EOL]     final int padLen = padStr.length(); [EOL]     final int strLen = str.length(); [EOL]     final int pads = size - strLen; [EOL]     if (pads <= 0) { [EOL]         return str; [EOL]     } [EOL]     if (padLen == 1 && pads <= PAD_LIMIT) { [EOL]         return leftPad(str, size, padStr.charAt(0)); [EOL]     } [EOL]     if (pads == padLen) { [EOL]         return padStr.concat(str); [EOL]     } else if (pads < padLen) { [EOL]         return padStr.substring(0, pads).concat(str); [EOL]     } else { [EOL]         final char[] padding = new char[pads]; [EOL]         final char[] padChars = padStr.toCharArray(); [EOL]         for (int i = 0; i < pads; i++) { [EOL]             padding[i] = padChars[i % padLen]; [EOL]         } [EOL]         return new String(padding).concat(str); [EOL]     } [EOL] } 
 [LINE] return true; [LINE] public static boolean isAlpha(final CharSequence cs) { [EOL]     if (cs == null || cs.length() == 0) { [EOL]         return false; [EOL]     } [EOL]     final int sz = cs.length(); [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (Character.isLetter(cs.charAt(i)) == false) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] return false; [LINE] public static boolean isAlphaSpace(final CharSequence cs) { [EOL]     if (cs == null) { [EOL]         return false; [EOL]     } [EOL]     final int sz = cs.length(); [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (Character.isLetter(cs.charAt(i)) == false && cs.charAt(i) != ' ') { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] return true; [LINE] public static boolean isAlphanumeric(final CharSequence cs) { [EOL]     if (cs == null || cs.length() == 0) { [EOL]         return false; [EOL]     } [EOL]     final int sz = cs.length(); [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (Character.isLetterOrDigit(cs.charAt(i)) == false) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] return false; [LINE] public static boolean isAsciiPrintable(final CharSequence cs) { [EOL]     if (cs == null) { [EOL]         return false; [EOL]     } [EOL]     final int sz = cs.length(); [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (CharUtils.isAsciiPrintable(cs.charAt(i)) == false) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] return true; [LINE] public static boolean isNumeric(final CharSequence cs) { [EOL]     if (cs == null || cs.length() == 0) { [EOL]         return false; [EOL]     } [EOL]     final int sz = cs.length(); [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (Character.isDigit(cs.charAt(i)) == false) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] return true; [LINE] public static boolean isAllLowerCase(final CharSequence cs) { [EOL]     if (cs == null || isEmpty(cs)) { [EOL]         return false; [EOL]     } [EOL]     final int sz = cs.length(); [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (Character.isLowerCase(cs.charAt(i)) == false) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] return true; [LINE] public static boolean isAllUpperCase(final CharSequence cs) { [EOL]     if (cs == null || isEmpty(cs)) { [EOL]         return false; [EOL]     } [EOL]     final int sz = cs.length(); [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (Character.isUpperCase(cs.charAt(i)) == false) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3); [LINE] public static String abbreviate(final String str, int offset, final int maxWidth) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (maxWidth < 4) { [EOL]         throw new IllegalArgumentException("Minimum abbreviation width is 4"); [EOL]     } [EOL]     if (str.length() <= maxWidth) { [EOL]         return str; [EOL]     } [EOL]     if (offset > str.length()) { [EOL]         offset = str.length(); [EOL]     } [EOL]     if (str.length() - offset < maxWidth - 3) { [EOL]         offset = str.length() - (maxWidth - 3); [EOL]     } [EOL]     final String abrevMarker = "..."; [EOL]     if (offset <= 4) { [EOL]         return str.substring(0, maxWidth - 3) + abrevMarker; [EOL]     } [EOL]     if (maxWidth < 7) { [EOL]         throw new IllegalArgumentException("Minimum abbreviation width with offset is 7"); [EOL]     } [EOL]     if (offset + maxWidth - 3 < str.length()) { [EOL]         return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3); [EOL]     } [EOL]     return abrevMarker + str.substring(str.length() - (maxWidth - 3)); [EOL] } 
 [LINE] final int targetSting = length-middle.length(); [LINE] public static String abbreviateMiddle(final String str, final String middle, final int length) { [EOL]     if (isEmpty(str) || isEmpty(middle)) { [EOL]         return str; [EOL]     } [EOL]     if (length >= str.length() || length < middle.length() + 2) { [EOL]         return str; [EOL]     } [EOL]     final int targetSting = length - middle.length(); [EOL]     final int startOffset = targetSting / 2 + targetSting % 2; [EOL]     final int endOffset = str.length() - targetSting / 2; [EOL]     final StringBuilder builder = new StringBuilder(length); [EOL]     builder.append(str.substring(0, startOffset)); [EOL]     builder.append(middle); [EOL]     builder.append(str.substring(endOffset)); [EOL]     return builder.toString(); [EOL] } 
 [LINE] final int startOffset = targetSting/2+targetSting%2; [LINE] public static String abbreviateMiddle(final String str, final String middle, final int length) { [EOL]     if (isEmpty(str) || isEmpty(middle)) { [EOL]         return str; [EOL]     } [EOL]     if (length >= str.length() || length < middle.length() + 2) { [EOL]         return str; [EOL]     } [EOL]     final int targetSting = length - middle.length(); [EOL]     final int startOffset = targetSting / 2 + targetSting % 2; [EOL]     final int endOffset = str.length() - targetSting / 2; [EOL]     final StringBuilder builder = new StringBuilder(length); [EOL]     builder.append(str.substring(0, startOffset)); [EOL]     builder.append(middle); [EOL]     builder.append(str.substring(endOffset)); [EOL]     return builder.toString(); [EOL] } 
 [LINE] final int endOffset = str.length()-targetSting/2; [LINE] public static String abbreviateMiddle(final String str, final String middle, final int length) { [EOL]     if (isEmpty(str) || isEmpty(middle)) { [EOL]         return str; [EOL]     } [EOL]     if (length >= str.length() || length < middle.length() + 2) { [EOL]         return str; [EOL]     } [EOL]     final int targetSting = length - middle.length(); [EOL]     final int startOffset = targetSting / 2 + targetSting % 2; [EOL]     final int endOffset = str.length() - targetSting / 2; [EOL]     final StringBuilder builder = new StringBuilder(length); [EOL]     builder.append(str.substring(0, startOffset)); [EOL]     builder.append(middle); [EOL]     builder.append(str.substring(endOffset)); [EOL]     return builder.toString(); [EOL] } 
 [LINE] final StringBuilder builder = new StringBuilder(length); [LINE] public static String abbreviateMiddle(final String str, final String middle, final int length) { [EOL]     if (isEmpty(str) || isEmpty(middle)) { [EOL]         return str; [EOL]     } [EOL]     if (length >= str.length() || length < middle.length() + 2) { [EOL]         return str; [EOL]     } [EOL]     final int targetSting = length - middle.length(); [EOL]     final int startOffset = targetSting / 2 + targetSting % 2; [EOL]     final int endOffset = str.length() - targetSting / 2; [EOL]     final StringBuilder builder = new StringBuilder(length); [EOL]     builder.append(str.substring(0, startOffset)); [EOL]     builder.append(middle); [EOL]     builder.append(str.substring(endOffset)); [EOL]     return builder.toString(); [EOL] } 
 [LINE] builder.append(str.substring(0,startOffset)); [LINE] public static String abbreviateMiddle(final String str, final String middle, final int length) { [EOL]     if (isEmpty(str) || isEmpty(middle)) { [EOL]         return str; [EOL]     } [EOL]     if (length >= str.length() || length < middle.length() + 2) { [EOL]         return str; [EOL]     } [EOL]     final int targetSting = length - middle.length(); [EOL]     final int startOffset = targetSting / 2 + targetSting % 2; [EOL]     final int endOffset = str.length() - targetSting / 2; [EOL]     final StringBuilder builder = new StringBuilder(length); [EOL]     builder.append(str.substring(0, startOffset)); [EOL]     builder.append(middle); [EOL]     builder.append(str.substring(endOffset)); [EOL]     return builder.toString(); [EOL] } 
 [LINE] builder.append(middle); [LINE] public static String abbreviateMiddle(final String str, final String middle, final int length) { [EOL]     if (isEmpty(str) || isEmpty(middle)) { [EOL]         return str; [EOL]     } [EOL]     if (length >= str.length() || length < middle.length() + 2) { [EOL]         return str; [EOL]     } [EOL]     final int targetSting = length - middle.length(); [EOL]     final int startOffset = targetSting / 2 + targetSting % 2; [EOL]     final int endOffset = str.length() - targetSting / 2; [EOL]     final StringBuilder builder = new StringBuilder(length); [EOL]     builder.append(str.substring(0, startOffset)); [EOL]     builder.append(middle); [EOL]     builder.append(str.substring(endOffset)); [EOL]     return builder.toString(); [EOL] } 
 [LINE] builder.append(str.substring(endOffset)); [LINE] public static String abbreviateMiddle(final String str, final String middle, final int length) { [EOL]     if (isEmpty(str) || isEmpty(middle)) { [EOL]         return str; [EOL]     } [EOL]     if (length >= str.length() || length < middle.length() + 2) { [EOL]         return str; [EOL]     } [EOL]     final int targetSting = length - middle.length(); [EOL]     final int startOffset = targetSting / 2 + targetSting % 2; [EOL]     final int endOffset = str.length() - targetSting / 2; [EOL]     final StringBuilder builder = new StringBuilder(length); [EOL]     builder.append(str.substring(0, startOffset)); [EOL]     builder.append(middle); [EOL]     builder.append(str.substring(endOffset)); [EOL]     return builder.toString(); [EOL] } 
 [LINE] return builder.toString(); [LINE] public static String abbreviateMiddle(final String str, final String middle, final int length) { [EOL]     if (isEmpty(str) || isEmpty(middle)) { [EOL]         return str; [EOL]     } [EOL]     if (length >= str.length() || length < middle.length() + 2) { [EOL]         return str; [EOL]     } [EOL]     final int targetSting = length - middle.length(); [EOL]     final int startOffset = targetSting / 2 + targetSting % 2; [EOL]     final int endOffset = str.length() - targetSting / 2; [EOL]     final StringBuilder builder = new StringBuilder(length); [EOL]     builder.append(str.substring(0, startOffset)); [EOL]     builder.append(middle); [EOL]     builder.append(str.substring(endOffset)); [EOL]     return builder.toString(); [EOL] } 
 [LINE] return str1; [LINE] public static String difference(final String str1, final String str2) { [EOL]     if (str1 == null) { [EOL]         return str2; [EOL]     } [EOL]     if (str2 == null) { [EOL]         return str1; [EOL]     } [EOL]     final int at = indexOfDifference(str1, str2); [EOL]     if (at == INDEX_NOT_FOUND) { [EOL]         return EMPTY; [EOL]     } [EOL]     return str2.substring(at); [EOL] } 
 [LINE] return shortestStrLen; [LINE] public static int indexOfDifference(final CharSequence... css) { [EOL]     if (css == null || css.length <= 1) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     boolean anyStringNull = false; [EOL]     boolean allStringsNull = true; [EOL]     final int arrayLen = css.length; [EOL]     int shortestStrLen = Integer.MAX_VALUE; [EOL]     int longestStrLen = 0; [EOL]     for (int i = 0; i < arrayLen; i++) { [EOL]         if (css[i] == null) { [EOL]             anyStringNull = true; [EOL]             shortestStrLen = 0; [EOL]         } else { [EOL]             allStringsNull = false; [EOL]             shortestStrLen = Math.min(css[i].length(), shortestStrLen); [EOL]             longestStrLen = Math.max(css[i].length(), longestStrLen); [EOL]         } [EOL]     } [EOL]     if (allStringsNull || longestStrLen == 0 && !anyStringNull) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (shortestStrLen == 0) { [EOL]         return 0; [EOL]     } [EOL]     int firstDiff = -1; [EOL]     for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) { [EOL]         final char comparisonChar = css[0].charAt(stringPos); [EOL]         for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) { [EOL]             if (css[arrayPos].charAt(stringPos) != comparisonChar) { [EOL]                 firstDiff = stringPos; [EOL]                 break; [EOL]             } [EOL]         } [EOL]         if (firstDiff != -1) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (firstDiff == -1 && shortestStrLen != longestStrLen) { [EOL]         return shortestStrLen; [EOL]     } [EOL]     return firstDiff; [EOL] } 
 [LINE] return EMPTY; [LINE] public static String getCommonPrefix(final String... strs) { [EOL]     if (strs == null || strs.length == 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final int smallestIndexOfDiff = indexOfDifference(strs); [EOL]     if (smallestIndexOfDiff == INDEX_NOT_FOUND) { [EOL]         if (strs[0] == null) { [EOL]             return EMPTY; [EOL]         } [EOL]         return strs[0]; [EOL]     } else if (smallestIndexOfDiff == 0) { [EOL]         return EMPTY; [EOL]     } else { [EOL]         return strs[0].substring(0, smallestIndexOfDiff); [EOL]     } [EOL] } 
 [LINE] return strs[0].substring(0, smallestIndexOfDiff); [LINE] public static String getCommonPrefix(final String... strs) { [EOL]     if (strs == null || strs.length == 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final int smallestIndexOfDiff = indexOfDifference(strs); [EOL]     if (smallestIndexOfDiff == INDEX_NOT_FOUND) { [EOL]         if (strs[0] == null) { [EOL]             return EMPTY; [EOL]         } [EOL]         return strs[0]; [EOL]     } else if (smallestIndexOfDiff == 0) { [EOL]         return EMPTY; [EOL]     } else { [EOL]         return strs[0].substring(0, smallestIndexOfDiff); [EOL]     } [EOL] } 
 [LINE] throw new IllegalArgumentException("Strings must not be null"); [LINE] public static int getLevenshteinDistance(CharSequence s, CharSequence t) { [EOL]     if (s == null || t == null) { [EOL]         throw new IllegalArgumentException("Strings must not be null"); [EOL]     } [EOL]     int n = s.length(); [EOL]     int m = t.length(); [EOL]     if (n == 0) { [EOL]         return m; [EOL]     } else if (m == 0) { [EOL]         return n; [EOL]     } [EOL]     if (n > m) { [EOL]         final CharSequence tmp = s; [EOL]         s = t; [EOL]         t = tmp; [EOL]         n = m; [EOL]         m = t.length(); [EOL]     } [EOL]     int[] p = new int[n + 1]; [EOL]     int[] d = new int[n + 1]; [EOL]     int[] _d; [EOL]     int i; [EOL]     int j; [EOL]     char t_j; [EOL]     int cost; [EOL]     for (i = 0; i <= n; i++) { [EOL]         p[i] = i; [EOL]     } [EOL]     for (j = 1; j <= m; j++) { [EOL]         t_j = t.charAt(j - 1); [EOL]         d[0] = j; [EOL]         for (i = 1; i <= n; i++) { [EOL]             cost = s.charAt(i - 1) == t_j ? 0 : 1; [EOL]             d[i] = Math.min(Math.min(d[i - 1] + 1, p[i] + 1), p[i - 1] + cost); [EOL]         } [EOL]         _d = p; [EOL]         p = d; [EOL]         d = _d; [EOL]     } [EOL]     return p[n]; [EOL] } 
 [LINE] return n <= threshold ? n : -1; [LINE] public static int getLevenshteinDistance(CharSequence s, CharSequence t, final int threshold) { [EOL]     if (s == null || t == null) { [EOL]         throw new IllegalArgumentException("Strings must not be null"); [EOL]     } [EOL]     if (threshold < 0) { [EOL]         throw new IllegalArgumentException("Threshold must not be negative"); [EOL]     } [EOL]     int n = s.length(); [EOL]     int m = t.length(); [EOL]     if (n == 0) { [EOL]         return m <= threshold ? m : -1; [EOL]     } else if (m == 0) { [EOL]         return n <= threshold ? n : -1; [EOL]     } [EOL]     if (n > m) { [EOL]         final CharSequence tmp = s; [EOL]         s = t; [EOL]         t = tmp; [EOL]         n = m; [EOL]         m = t.length(); [EOL]     } [EOL]     int[] p = new int[n + 1]; [EOL]     int[] d = new int[n + 1]; [EOL]     int[] _d; [EOL]     final int boundary = Math.min(n, threshold) + 1; [EOL]     for (int i = 0; i < boundary; i++) { [EOL]         p[i] = i; [EOL]     } [EOL]     Arrays.fill(p, boundary, p.length, Integer.MAX_VALUE); [EOL]     Arrays.fill(d, Integer.MAX_VALUE); [EOL]     for (int j = 1; j <= m; j++) { [EOL]         final char t_j = t.charAt(j - 1); [EOL]         d[0] = j; [EOL]         final int min = Math.max(1, j - threshold); [EOL]         final int max = Math.min(n, j + threshold); [EOL]         if (min > max) { [EOL]             return -1; [EOL]         } [EOL]         if (min > 1) { [EOL]             d[min - 1] = Integer.MAX_VALUE; [EOL]         } [EOL]         for (int i = min; i <= max; i++) { [EOL]             if (s.charAt(i - 1) == t_j) { [EOL]                 d[i] = p[i - 1]; [EOL]             } else { [EOL]                 d[i] = 1 + Math.min(Math.min(d[i - 1], p[i]), p[i - 1]); [EOL]             } [EOL]         } [EOL]         _d = p; [EOL]         p = d; [EOL]         d = _d; [EOL]     } [EOL]     if (p[n] <= threshold) { [EOL]         return p[n]; [EOL]     } [EOL]     return -1; [EOL] } 
 [LINE] return true; [LINE] public static boolean startsWithAny(final CharSequence string, final CharSequence... searchStrings) { [EOL]     if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) { [EOL]         return false; [EOL]     } [EOL]     for (final CharSequence searchString : searchStrings) { [EOL]         if (StringUtils.startsWith(string, searchString)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } 
 [LINE] return null; [LINE] public static String normalizeSpace(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     return WHITESPACE_PATTERN.matcher(trim(str)).replaceAll(SPACE); [EOL] } 
 [LINE] rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.LONG); [LINE] protected List<Rule> parsePattern() { [EOL]     final DateFormatSymbols symbols = new DateFormatSymbols(mLocale); [EOL]     final List<Rule> rules = new ArrayList<Rule>(); [EOL]     final String[] ERAs = symbols.getEras(); [EOL]     final String[] months = symbols.getMonths(); [EOL]     final String[] shortMonths = symbols.getShortMonths(); [EOL]     final String[] weekdays = symbols.getWeekdays(); [EOL]     final String[] shortWeekdays = symbols.getShortWeekdays(); [EOL]     final String[] AmPmStrings = symbols.getAmPmStrings(); [EOL]     final int length = mPattern.length(); [EOL]     final int[] indexRef = new int[1]; [EOL]     for (int i = 0; i < length; i++) { [EOL]         indexRef[0] = i; [EOL]         final String token = parseToken(mPattern, indexRef); [EOL]         i = indexRef[0]; [EOL]         final int tokenLen = token.length(); [EOL]         if (tokenLen == 0) { [EOL]             break; [EOL]         } [EOL]         Rule rule; [EOL]         final char c = token.charAt(0); [EOL]         switch(c) { [EOL]             case 'G': [EOL]                 rule = new TextField(Calendar.ERA, ERAs); [EOL]                 break; [EOL]             case 'y': [EOL]                 if (tokenLen == 2) { [EOL]                     rule = TwoDigitYearField.INSTANCE; [EOL]                 } else { [EOL]                     rule = selectNumberRule(Calendar.YEAR, tokenLen < 4 ? 4 : tokenLen); [EOL]                 } [EOL]                 break; [EOL]             case 'M': [EOL]                 if (tokenLen >= 4) { [EOL]                     rule = new TextField(Calendar.MONTH, months); [EOL]                 } else if (tokenLen == 3) { [EOL]                     rule = new TextField(Calendar.MONTH, shortMonths); [EOL]                 } else if (tokenLen == 2) { [EOL]                     rule = TwoDigitMonthField.INSTANCE; [EOL]                 } else { [EOL]                     rule = UnpaddedMonthField.INSTANCE; [EOL]                 } [EOL]                 break; [EOL]             case 'd': [EOL]                 rule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen); [EOL]                 break; [EOL]             case 'h': [EOL]                 rule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen)); [EOL]                 break; [EOL]             case 'H': [EOL]                 rule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen); [EOL]                 break; [EOL]             case 'm': [EOL]                 rule = selectNumberRule(Calendar.MINUTE, tokenLen); [EOL]                 break; [EOL]             case 's': [EOL]                 rule = selectNumberRule(Calendar.SECOND, tokenLen); [EOL]                 break; [EOL]             case 'S': [EOL]                 rule = selectNumberRule(Calendar.MILLISECOND, tokenLen); [EOL]                 break; [EOL]             case 'E': [EOL]                 rule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays); [EOL]                 break; [EOL]             case 'D': [EOL]                 rule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen); [EOL]                 break; [EOL]             case 'F': [EOL]                 rule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen); [EOL]                 break; [EOL]             case 'w': [EOL]                 rule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen); [EOL]                 break; [EOL]             case 'W': [EOL]                 rule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen); [EOL]                 break; [EOL]             case 'a': [EOL]                 rule = new TextField(Calendar.AM_PM, AmPmStrings); [EOL]                 break; [EOL]             case 'k': [EOL]                 rule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen)); [EOL]                 break; [EOL]             case 'K': [EOL]                 rule = selectNumberRule(Calendar.HOUR, tokenLen); [EOL]                 break; [EOL]             case 'z': [EOL]                 if (tokenLen >= 4) { [EOL]                     rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.LONG); [EOL]                 } else { [EOL]                     rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.SHORT); [EOL]                 } [EOL]                 break; [EOL]             case 'Z': [EOL]                 if (tokenLen == 1) { [EOL]                     rule = TimeZoneNumberRule.INSTANCE_NO_COLON; [EOL]                 } else { [EOL]                     rule = TimeZoneNumberRule.INSTANCE_COLON; [EOL]                 } [EOL]                 break; [EOL]             case '\'': [EOL]                 final String sub = token.substring(1); [EOL]                 if (sub.length() == 1) { [EOL]                     rule = new CharacterLiteral(sub.charAt(0)); [EOL]                 } else { [EOL]                     rule = new StringLiteral(sub); [EOL]                 } [EOL]                 break; [EOL]             default: [EOL]                 throw new IllegalArgumentException("Illegal pattern component: " + token); [EOL]         } [EOL]         rules.add(rule); [EOL]     } [EOL]     return rules; [EOL] } 
 [LINE] return format((Date) obj, toAppendTo); [LINE] @Override [EOL] public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos) { [EOL]     if (obj instanceof Date) { [EOL]         return format((Date) obj, toAppendTo); [EOL]     } else if (obj instanceof Calendar) { [EOL]         return format((Calendar) obj, toAppendTo); [EOL]     } else if (obj instanceof Long) { [EOL]         return format(((Long) obj).longValue(), toAppendTo); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Unknown class: " + (obj == null ? "<null>" : obj.getClass().getName())); [EOL]     } [EOL] } 
 [LINE] private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException { [LINE] private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException { [EOL]     in.defaultReadObject(); [EOL]     init(); [EOL] } 
 [LINE] in.defaultReadObject(); [LINE] private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException { [EOL]     in.defaultReadObject(); [EOL]     init(); [EOL] } 
 [LINE] init(); [LINE] private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException { [EOL]     in.defaultReadObject(); [EOL]     init(); [EOL] } 
 [LINE] buffer.append(Integer.toString(value)); [LINE] @Override [EOL] public final void appendTo(final StringBuffer buffer, final int value) { [EOL]     if (value < 10) { [EOL]         buffer.append((char) (value + '0')); [EOL]     } else if (value < 100) { [EOL]         buffer.append((char) (value / 10 + '0')); [EOL]         buffer.append((char) (value % 10 + '0')); [EOL]     } else { [EOL]         buffer.append(Integer.toString(value)); [EOL]     } [EOL] } 
 [LINE] digits = 3; [LINE] @Override [EOL] public final void appendTo(final StringBuffer buffer, final int value) { [EOL]     if (value < 100) { [EOL]         for (int i = mSize; --i >= 2; ) { [EOL]             buffer.append('0'); [EOL]         } [EOL]         buffer.append((char) (value / 10 + '0')); [EOL]         buffer.append((char) (value % 10 + '0')); [EOL]     } else { [EOL]         int digits; [EOL]         if (value < 1000) { [EOL]             digits = 3; [EOL]         } else { [EOL]             Validate.isTrue(value > -1, "Negative values should not be possible", value); [EOL]             digits = Integer.toString(value).length(); [EOL]         } [EOL]         for (int i = mSize; --i >= digits; ) { [EOL]             buffer.append('0'); [EOL]         } [EOL]         buffer.append(Integer.toString(value)); [EOL]     } [EOL] } 
 [LINE] buffer.append('0'); [LINE] @Override [EOL] public final void appendTo(final StringBuffer buffer, final int value) { [EOL]     if (value < 100) { [EOL]         for (int i = mSize; --i >= 2; ) { [EOL]             buffer.append('0'); [EOL]         } [EOL]         buffer.append((char) (value / 10 + '0')); [EOL]         buffer.append((char) (value % 10 + '0')); [EOL]     } else { [EOL]         int digits; [EOL]         if (value < 1000) { [EOL]             digits = 3; [EOL]         } else { [EOL]             Validate.isTrue(value > -1, "Negative values should not be possible", value); [EOL]             digits = Integer.toString(value).length(); [EOL]         } [EOL]         for (int i = mSize; --i >= digits; ) { [EOL]             buffer.append('0'); [EOL]         } [EOL]         buffer.append(Integer.toString(value)); [EOL]     } [EOL] } 
 [LINE] buffer.append(Integer.toString(value)); [LINE] @Override [EOL] public final void appendTo(final StringBuffer buffer, final int value) { [EOL]     if (value < 100) { [EOL]         buffer.append((char) (value / 10 + '0')); [EOL]         buffer.append((char) (value % 10 + '0')); [EOL]     } else { [EOL]         buffer.append(Integer.toString(value)); [EOL]     } [EOL] } 
 [LINE] @Override [LINE] @Override [EOL] public void appendTo(final StringBuffer buffer, final Calendar calendar) { [EOL]     appendTo(buffer, calendar.get(Calendar.YEAR) % 100); [EOL] } 
 [LINE] appendTo(buffer, calendar.get(Calendar.YEAR) % 100); [LINE] @Override [EOL] public void appendTo(final StringBuffer buffer, final Calendar calendar) { [EOL]     appendTo(buffer, calendar.get(Calendar.YEAR) % 100); [EOL] } 
 [LINE] buffer.append(getTimeZoneDisplay(zone, true, mStyle, mLocale)); [LINE] @Override [EOL] public void appendTo(final StringBuffer buffer, final Calendar calendar) { [EOL]     final TimeZone zone = calendar.getTimeZone(); [EOL]     if (zone.useDaylightTime() && calendar.get(Calendar.DST_OFFSET) != 0) { [EOL]         buffer.append(getTimeZoneDisplay(zone, true, mStyle, mLocale)); [EOL]     } else { [EOL]         buffer.append(getTimeZoneDisplay(zone, false, mStyle, mLocale)); [EOL]     } [EOL] } 
 [LINE] buffer.append('-'); [LINE] @Override [EOL] public void appendTo(final StringBuffer buffer, final Calendar calendar) { [EOL]     int offset = calendar.get(Calendar.ZONE_OFFSET) + calendar.get(Calendar.DST_OFFSET); [EOL]     if (offset < 0) { [EOL]         buffer.append('-'); [EOL]         offset = -offset; [EOL]     } else { [EOL]         buffer.append('+'); [EOL]     } [EOL]     final int hours = offset / (60 * 60 * 1000); [EOL]     buffer.append((char) (hours / 10 + '0')); [EOL]     buffer.append((char) (hours % 10 + '0')); [EOL]     if (mColon) { [EOL]         buffer.append(':'); [EOL]     } [EOL]     final int minutes = offset / (60 * 1000) - 60 * hours; [EOL]     buffer.append((char) (minutes / 10 + '0')); [EOL]     buffer.append((char) (minutes % 10 + '0')); [EOL] } 
 [LINE] offset = -offset; [LINE] @Override [EOL] public void appendTo(final StringBuffer buffer, final Calendar calendar) { [EOL]     int offset = calendar.get(Calendar.ZONE_OFFSET) + calendar.get(Calendar.DST_OFFSET); [EOL]     if (offset < 0) { [EOL]         buffer.append('-'); [EOL]         offset = -offset; [EOL]     } else { [EOL]         buffer.append('+'); [EOL]     } [EOL]     final int hours = offset / (60 * 60 * 1000); [EOL]     buffer.append((char) (hours / 10 + '0')); [EOL]     buffer.append((char) (hours % 10 + '0')); [EOL]     if (mColon) { [EOL]         buffer.append(':'); [EOL]     } [EOL]     final int minutes = offset / (60 * 1000) - 60 * hours; [EOL]     buffer.append((char) (minutes / 10 + '0')); [EOL]     buffer.append((char) (minutes % 10 + '0')); [EOL] } 
 [LINE] throw new ArithmeticException("Numerator too large to represent as an Integer."); [LINE] public static Fraction getFraction(final int whole, final int numerator, final int denominator) { [EOL]     if (denominator == 0) { [EOL]         throw new ArithmeticException("The denominator must not be zero"); [EOL]     } [EOL]     if (denominator < 0) { [EOL]         throw new ArithmeticException("The denominator must not be negative"); [EOL]     } [EOL]     if (numerator < 0) { [EOL]         throw new ArithmeticException("The numerator must not be negative"); [EOL]     } [EOL]     long numeratorValue; [EOL]     if (whole < 0) { [EOL]         numeratorValue = whole * (long) denominator - numerator; [EOL]     } else { [EOL]         numeratorValue = whole * (long) denominator + numerator; [EOL]     } [EOL]     if (numeratorValue < Integer.MIN_VALUE || numeratorValue > Integer.MAX_VALUE) { [EOL]         throw new ArithmeticException("Numerator too large to represent as an Integer."); [EOL]     } [EOL]     return new Fraction((int) numeratorValue, denominator); [EOL] } 
 [LINE] throw new NumberFormatException("The fraction could not be parsed as the format X Y/Z"); [LINE] public static Fraction getFraction(String str) { [EOL]     if (str == null) { [EOL]         throw new IllegalArgumentException("The string must not be null"); [EOL]     } [EOL]     int pos = str.indexOf('.'); [EOL]     if (pos >= 0) { [EOL]         return getFraction(Double.parseDouble(str)); [EOL]     } [EOL]     pos = str.indexOf(' '); [EOL]     if (pos > 0) { [EOL]         final int whole = Integer.parseInt(str.substring(0, pos)); [EOL]         str = str.substring(pos + 1); [EOL]         pos = str.indexOf('/'); [EOL]         if (pos < 0) { [EOL]             throw new NumberFormatException("The fraction could not be parsed as the format X Y/Z"); [EOL]         } else { [EOL]             final int numer = Integer.parseInt(str.substring(0, pos)); [EOL]             final int denom = Integer.parseInt(str.substring(pos + 1)); [EOL]             return getFraction(whole, numer, denom); [EOL]         } [EOL]     } [EOL]     pos = str.indexOf('/'); [EOL]     if (pos < 0) { [EOL]         return getFraction(Integer.parseInt(str), 1); [EOL]     } else { [EOL]         final int numer = Integer.parseInt(str.substring(0, pos)); [EOL]         final int denom = Integer.parseInt(str.substring(pos + 1)); [EOL]         return getFraction(numer, denom); [EOL]     } [EOL] } 
 [LINE] throw new ArithmeticException("overflow: can't negate numerator"); [LINE] public Fraction invert() { [EOL]     if (numerator == 0) { [EOL]         throw new ArithmeticException("Unable to invert zero."); [EOL]     } [EOL]     if (numerator == Integer.MIN_VALUE) { [EOL]         throw new ArithmeticException("overflow: can't negate numerator"); [EOL]     } [EOL]     if (numerator < 0) { [EOL]         return new Fraction(-denominator, -numerator); [EOL]     } else { [EOL]         return new Fraction(denominator, numerator); [EOL]     } [EOL] } 
 [LINE] throw new ArithmeticException("overflow: too large to negate"); [LINE] public Fraction negate() { [EOL]     if (numerator == Integer.MIN_VALUE) { [EOL]         throw new ArithmeticException("overflow: too large to negate"); [EOL]     } [EOL]     return new Fraction(-numerator, denominator); [EOL] } 
 [LINE] throw new ArithmeticException("overflow: add"); [LINE] private static int addAndCheck(final int x, final int y) { [EOL]     final long s = (long) x + (long) y; [EOL]     if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) { [EOL]         throw new ArithmeticException("overflow: add"); [EOL]     } [EOL]     return (int) s; [EOL] } 
 [LINE] throw new ArithmeticException("overflow: add"); [LINE] private static int subAndCheck(final int x, final int y) { [EOL]     final long s = (long) x - (long) y; [EOL]     if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) { [EOL]         throw new ArithmeticException("overflow: add"); [EOL]     } [EOL]     return (int) s; [EOL] } 
 [LINE] throw new ArithmeticException [LINE] private Fraction addSub(final Fraction fraction, final boolean isAdd) { [EOL]     if (fraction == null) { [EOL]         throw new IllegalArgumentException("The fraction must not be null"); [EOL]     } [EOL]     if (numerator == 0) { [EOL]         return isAdd ? fraction : fraction.negate(); [EOL]     } [EOL]     if (fraction.numerator == 0) { [EOL]         return this; [EOL]     } [EOL]     final int d1 = greatestCommonDivisor(denominator, fraction.denominator); [EOL]     if (d1 == 1) { [EOL]         final int uvp = mulAndCheck(numerator, fraction.denominator); [EOL]         final int upv = mulAndCheck(fraction.numerator, denominator); [EOL]         return new Fraction(isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv), mulPosAndCheck(denominator, fraction.denominator)); [EOL]     } [EOL]     final BigInteger uvp = BigInteger.valueOf(numerator).multiply(BigInteger.valueOf(fraction.denominator / d1)); [EOL]     final BigInteger upv = BigInteger.valueOf(fraction.numerator).multiply(BigInteger.valueOf(denominator / d1)); [EOL]     final BigInteger t = isAdd ? uvp.add(upv) : uvp.subtract(upv); [EOL]     final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue(); [EOL]     final int d2 = tmodd1 == 0 ? d1 : greatestCommonDivisor(tmodd1, d1); [EOL]     final BigInteger w = t.divide(BigInteger.valueOf(d2)); [EOL]     if (w.bitLength() > 31) { [EOL]         throw new ArithmeticException("overflow: numerator too large after multiply"); [EOL]     } [EOL]     return new Fraction(w.intValue(), mulPosAndCheck(denominator / d1, fraction.denominator / d2)); [EOL] } 
 [LINE] toProperString = "-1"; [LINE] public String toProperString() { [EOL]     if (toProperString == null) { [EOL]         if (numerator == 0) { [EOL]             toProperString = "0"; [EOL]         } else if (numerator == denominator) { [EOL]             toProperString = "1"; [EOL]         } else if (numerator == -1 * denominator) { [EOL]             toProperString = "-1"; [EOL]         } else if ((numerator > 0 ? -numerator : numerator) < -denominator) { [EOL]             final int properNumerator = getProperNumerator(); [EOL]             if (properNumerator == 0) { [EOL]                 toProperString = Integer.toString(getProperWhole()); [EOL]             } else { [EOL]                 toProperString = new StringBuilder(32).append(getProperWhole()).append(' ').append(properNumerator).append('/').append(getDenominator()).toString(); [EOL]             } [EOL]         } else { [EOL]             toProperString = new StringBuilder(32).append(getNumerator()).append('/').append(getDenominator()).toString(); [EOL]         } [EOL]     } [EOL]     return toProperString; [EOL] } 
 [LINE] case '1': [LINE] public static int hexDigitMsb0ToInt(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return 0x0; [EOL]         case '1': [EOL]             return 0x8; [EOL]         case '2': [EOL]             return 0x4; [EOL]         case '3': [EOL]             return 0xC; [EOL]         case '4': [EOL]             return 0x2; [EOL]         case '5': [EOL]             return 0xA; [EOL]         case '6': [EOL]             return 0x6; [EOL]         case '7': [EOL]             return 0xE; [EOL]         case '8': [EOL]             return 0x1; [EOL]         case '9': [EOL]             return 0x9; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return 0x5; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return 0xD; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return 0x3; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return 0xB; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return 0x7; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return 0xF; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] return 0x8; [LINE] public static int hexDigitMsb0ToInt(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return 0x0; [EOL]         case '1': [EOL]             return 0x8; [EOL]         case '2': [EOL]             return 0x4; [EOL]         case '3': [EOL]             return 0xC; [EOL]         case '4': [EOL]             return 0x2; [EOL]         case '5': [EOL]             return 0xA; [EOL]         case '6': [EOL]             return 0x6; [EOL]         case '7': [EOL]             return 0xE; [EOL]         case '8': [EOL]             return 0x1; [EOL]         case '9': [EOL]             return 0x9; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return 0x5; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return 0xD; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return 0x3; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return 0xB; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return 0x7; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return 0xF; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] case '2': [LINE] public static int hexDigitMsb0ToInt(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return 0x0; [EOL]         case '1': [EOL]             return 0x8; [EOL]         case '2': [EOL]             return 0x4; [EOL]         case '3': [EOL]             return 0xC; [EOL]         case '4': [EOL]             return 0x2; [EOL]         case '5': [EOL]             return 0xA; [EOL]         case '6': [EOL]             return 0x6; [EOL]         case '7': [EOL]             return 0xE; [EOL]         case '8': [EOL]             return 0x1; [EOL]         case '9': [EOL]             return 0x9; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return 0x5; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return 0xD; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return 0x3; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return 0xB; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return 0x7; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return 0xF; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] return 0x4; [LINE] public static int hexDigitMsb0ToInt(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return 0x0; [EOL]         case '1': [EOL]             return 0x8; [EOL]         case '2': [EOL]             return 0x4; [EOL]         case '3': [EOL]             return 0xC; [EOL]         case '4': [EOL]             return 0x2; [EOL]         case '5': [EOL]             return 0xA; [EOL]         case '6': [EOL]             return 0x6; [EOL]         case '7': [EOL]             return 0xE; [EOL]         case '8': [EOL]             return 0x1; [EOL]         case '9': [EOL]             return 0x9; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return 0x5; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return 0xD; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return 0x3; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return 0xB; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return 0x7; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return 0xF; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] case '3': [LINE] public static int hexDigitMsb0ToInt(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return 0x0; [EOL]         case '1': [EOL]             return 0x8; [EOL]         case '2': [EOL]             return 0x4; [EOL]         case '3': [EOL]             return 0xC; [EOL]         case '4': [EOL]             return 0x2; [EOL]         case '5': [EOL]             return 0xA; [EOL]         case '6': [EOL]             return 0x6; [EOL]         case '7': [EOL]             return 0xE; [EOL]         case '8': [EOL]             return 0x1; [EOL]         case '9': [EOL]             return 0x9; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return 0x5; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return 0xD; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return 0x3; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return 0xB; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return 0x7; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return 0xF; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] return 0xC; [LINE] public static int hexDigitMsb0ToInt(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return 0x0; [EOL]         case '1': [EOL]             return 0x8; [EOL]         case '2': [EOL]             return 0x4; [EOL]         case '3': [EOL]             return 0xC; [EOL]         case '4': [EOL]             return 0x2; [EOL]         case '5': [EOL]             return 0xA; [EOL]         case '6': [EOL]             return 0x6; [EOL]         case '7': [EOL]             return 0xE; [EOL]         case '8': [EOL]             return 0x1; [EOL]         case '9': [EOL]             return 0x9; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return 0x5; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return 0xD; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return 0x3; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return 0xB; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return 0x7; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return 0xF; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] case '5': [LINE] public static int hexDigitMsb0ToInt(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return 0x0; [EOL]         case '1': [EOL]             return 0x8; [EOL]         case '2': [EOL]             return 0x4; [EOL]         case '3': [EOL]             return 0xC; [EOL]         case '4': [EOL]             return 0x2; [EOL]         case '5': [EOL]             return 0xA; [EOL]         case '6': [EOL]             return 0x6; [EOL]         case '7': [EOL]             return 0xE; [EOL]         case '8': [EOL]             return 0x1; [EOL]         case '9': [EOL]             return 0x9; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return 0x5; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return 0xD; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return 0x3; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return 0xB; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return 0x7; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return 0xF; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] return 0xA; [LINE] public static int hexDigitMsb0ToInt(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return 0x0; [EOL]         case '1': [EOL]             return 0x8; [EOL]         case '2': [EOL]             return 0x4; [EOL]         case '3': [EOL]             return 0xC; [EOL]         case '4': [EOL]             return 0x2; [EOL]         case '5': [EOL]             return 0xA; [EOL]         case '6': [EOL]             return 0x6; [EOL]         case '7': [EOL]             return 0xE; [EOL]         case '8': [EOL]             return 0x1; [EOL]         case '9': [EOL]             return 0x9; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return 0x5; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return 0xD; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return 0x3; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return 0xB; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return 0x7; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return 0xF; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] case '6': [LINE] public static int hexDigitMsb0ToInt(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return 0x0; [EOL]         case '1': [EOL]             return 0x8; [EOL]         case '2': [EOL]             return 0x4; [EOL]         case '3': [EOL]             return 0xC; [EOL]         case '4': [EOL]             return 0x2; [EOL]         case '5': [EOL]             return 0xA; [EOL]         case '6': [EOL]             return 0x6; [EOL]         case '7': [EOL]             return 0xE; [EOL]         case '8': [EOL]             return 0x1; [EOL]         case '9': [EOL]             return 0x9; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return 0x5; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return 0xD; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return 0x3; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return 0xB; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return 0x7; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return 0xF; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] return 0x6; [LINE] public static int hexDigitMsb0ToInt(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return 0x0; [EOL]         case '1': [EOL]             return 0x8; [EOL]         case '2': [EOL]             return 0x4; [EOL]         case '3': [EOL]             return 0xC; [EOL]         case '4': [EOL]             return 0x2; [EOL]         case '5': [EOL]             return 0xA; [EOL]         case '6': [EOL]             return 0x6; [EOL]         case '7': [EOL]             return 0xE; [EOL]         case '8': [EOL]             return 0x1; [EOL]         case '9': [EOL]             return 0x9; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return 0x5; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return 0xD; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return 0x3; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return 0xB; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return 0x7; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return 0xF; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] case '7': [LINE] public static int hexDigitMsb0ToInt(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return 0x0; [EOL]         case '1': [EOL]             return 0x8; [EOL]         case '2': [EOL]             return 0x4; [EOL]         case '3': [EOL]             return 0xC; [EOL]         case '4': [EOL]             return 0x2; [EOL]         case '5': [EOL]             return 0xA; [EOL]         case '6': [EOL]             return 0x6; [EOL]         case '7': [EOL]             return 0xE; [EOL]         case '8': [EOL]             return 0x1; [EOL]         case '9': [EOL]             return 0x9; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return 0x5; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return 0xD; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return 0x3; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return 0xB; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return 0x7; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return 0xF; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] return 0xE; [LINE] public static int hexDigitMsb0ToInt(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return 0x0; [EOL]         case '1': [EOL]             return 0x8; [EOL]         case '2': [EOL]             return 0x4; [EOL]         case '3': [EOL]             return 0xC; [EOL]         case '4': [EOL]             return 0x2; [EOL]         case '5': [EOL]             return 0xA; [EOL]         case '6': [EOL]             return 0x6; [EOL]         case '7': [EOL]             return 0xE; [EOL]         case '8': [EOL]             return 0x1; [EOL]         case '9': [EOL]             return 0x9; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return 0x5; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return 0xD; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return 0x3; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return 0xB; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return 0x7; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return 0xF; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] case '9': [LINE] public static int hexDigitMsb0ToInt(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return 0x0; [EOL]         case '1': [EOL]             return 0x8; [EOL]         case '2': [EOL]             return 0x4; [EOL]         case '3': [EOL]             return 0xC; [EOL]         case '4': [EOL]             return 0x2; [EOL]         case '5': [EOL]             return 0xA; [EOL]         case '6': [EOL]             return 0x6; [EOL]         case '7': [EOL]             return 0xE; [EOL]         case '8': [EOL]             return 0x1; [EOL]         case '9': [EOL]             return 0x9; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return 0x5; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return 0xD; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return 0x3; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return 0xB; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return 0x7; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return 0xF; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] return 0x9; [LINE] public static int hexDigitMsb0ToInt(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return 0x0; [EOL]         case '1': [EOL]             return 0x8; [EOL]         case '2': [EOL]             return 0x4; [EOL]         case '3': [EOL]             return 0xC; [EOL]         case '4': [EOL]             return 0x2; [EOL]         case '5': [EOL]             return 0xA; [EOL]         case '6': [EOL]             return 0x6; [EOL]         case '7': [EOL]             return 0xE; [EOL]         case '8': [EOL]             return 0x1; [EOL]         case '9': [EOL]             return 0x9; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return 0x5; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return 0xD; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return 0x3; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return 0xB; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return 0x7; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return 0xF; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] case 'a':// fall through [LINE] public static int hexDigitMsb0ToInt(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return 0x0; [EOL]         case '1': [EOL]             return 0x8; [EOL]         case '2': [EOL]             return 0x4; [EOL]         case '3': [EOL]             return 0xC; [EOL]         case '4': [EOL]             return 0x2; [EOL]         case '5': [EOL]             return 0xA; [EOL]         case '6': [EOL]             return 0x6; [EOL]         case '7': [EOL]             return 0xE; [EOL]         case '8': [EOL]             return 0x1; [EOL]         case '9': [EOL]             return 0x9; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return 0x5; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return 0xD; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return 0x3; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return 0xB; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return 0x7; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return 0xF; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] case 'A': [LINE] public static int hexDigitMsb0ToInt(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return 0x0; [EOL]         case '1': [EOL]             return 0x8; [EOL]         case '2': [EOL]             return 0x4; [EOL]         case '3': [EOL]             return 0xC; [EOL]         case '4': [EOL]             return 0x2; [EOL]         case '5': [EOL]             return 0xA; [EOL]         case '6': [EOL]             return 0x6; [EOL]         case '7': [EOL]             return 0xE; [EOL]         case '8': [EOL]             return 0x1; [EOL]         case '9': [EOL]             return 0x9; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return 0x5; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return 0xD; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return 0x3; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return 0xB; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return 0x7; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return 0xF; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] return 0x5; [LINE] public static int hexDigitMsb0ToInt(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return 0x0; [EOL]         case '1': [EOL]             return 0x8; [EOL]         case '2': [EOL]             return 0x4; [EOL]         case '3': [EOL]             return 0xC; [EOL]         case '4': [EOL]             return 0x2; [EOL]         case '5': [EOL]             return 0xA; [EOL]         case '6': [EOL]             return 0x6; [EOL]         case '7': [EOL]             return 0xE; [EOL]         case '8': [EOL]             return 0x1; [EOL]         case '9': [EOL]             return 0x9; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return 0x5; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return 0xD; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return 0x3; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return 0xB; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return 0x7; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return 0xF; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] case 'c':// fall through [LINE] public static int hexDigitMsb0ToInt(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return 0x0; [EOL]         case '1': [EOL]             return 0x8; [EOL]         case '2': [EOL]             return 0x4; [EOL]         case '3': [EOL]             return 0xC; [EOL]         case '4': [EOL]             return 0x2; [EOL]         case '5': [EOL]             return 0xA; [EOL]         case '6': [EOL]             return 0x6; [EOL]         case '7': [EOL]             return 0xE; [EOL]         case '8': [EOL]             return 0x1; [EOL]         case '9': [EOL]             return 0x9; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return 0x5; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return 0xD; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return 0x3; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return 0xB; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return 0x7; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return 0xF; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] case 'C': [LINE] public static int hexDigitMsb0ToInt(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return 0x0; [EOL]         case '1': [EOL]             return 0x8; [EOL]         case '2': [EOL]             return 0x4; [EOL]         case '3': [EOL]             return 0xC; [EOL]         case '4': [EOL]             return 0x2; [EOL]         case '5': [EOL]             return 0xA; [EOL]         case '6': [EOL]             return 0x6; [EOL]         case '7': [EOL]             return 0xE; [EOL]         case '8': [EOL]             return 0x1; [EOL]         case '9': [EOL]             return 0x9; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return 0x5; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return 0xD; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return 0x3; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return 0xB; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return 0x7; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return 0xF; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] return 0x3; [LINE] public static int hexDigitMsb0ToInt(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return 0x0; [EOL]         case '1': [EOL]             return 0x8; [EOL]         case '2': [EOL]             return 0x4; [EOL]         case '3': [EOL]             return 0xC; [EOL]         case '4': [EOL]             return 0x2; [EOL]         case '5': [EOL]             return 0xA; [EOL]         case '6': [EOL]             return 0x6; [EOL]         case '7': [EOL]             return 0xE; [EOL]         case '8': [EOL]             return 0x1; [EOL]         case '9': [EOL]             return 0x9; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return 0x5; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return 0xD; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return 0x3; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return 0xB; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return 0x7; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return 0xF; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] case 'E': [LINE] public static int hexDigitMsb0ToInt(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return 0x0; [EOL]         case '1': [EOL]             return 0x8; [EOL]         case '2': [EOL]             return 0x4; [EOL]         case '3': [EOL]             return 0xC; [EOL]         case '4': [EOL]             return 0x2; [EOL]         case '5': [EOL]             return 0xA; [EOL]         case '6': [EOL]             return 0x6; [EOL]         case '7': [EOL]             return 0xE; [EOL]         case '8': [EOL]             return 0x1; [EOL]         case '9': [EOL]             return 0x9; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return 0x5; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return 0xD; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return 0x3; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return 0xB; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return 0x7; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return 0xF; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] case 'f':// fall through [LINE] public static int hexDigitMsb0ToInt(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return 0x0; [EOL]         case '1': [EOL]             return 0x8; [EOL]         case '2': [EOL]             return 0x4; [EOL]         case '3': [EOL]             return 0xC; [EOL]         case '4': [EOL]             return 0x2; [EOL]         case '5': [EOL]             return 0xA; [EOL]         case '6': [EOL]             return 0x6; [EOL]         case '7': [EOL]             return 0xE; [EOL]         case '8': [EOL]             return 0x1; [EOL]         case '9': [EOL]             return 0x9; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return 0x5; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return 0xD; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return 0x3; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return 0xB; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return 0x7; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return 0xF; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] case 'F': [LINE] public static int hexDigitMsb0ToInt(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return 0x0; [EOL]         case '1': [EOL]             return 0x8; [EOL]         case '2': [EOL]             return 0x4; [EOL]         case '3': [EOL]             return 0xC; [EOL]         case '4': [EOL]             return 0x2; [EOL]         case '5': [EOL]             return 0xA; [EOL]         case '6': [EOL]             return 0x6; [EOL]         case '7': [EOL]             return 0xE; [EOL]         case '8': [EOL]             return 0x1; [EOL]         case '9': [EOL]             return 0x9; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return 0x5; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return 0xD; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return 0x3; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return 0xB; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return 0x7; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return 0xF; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] return 0xF; [LINE] public static int hexDigitMsb0ToInt(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return 0x0; [EOL]         case '1': [EOL]             return 0x8; [EOL]         case '2': [EOL]             return 0x4; [EOL]         case '3': [EOL]             return 0xC; [EOL]         case '4': [EOL]             return 0x2; [EOL]         case '5': [EOL]             return 0xA; [EOL]         case '6': [EOL]             return 0x6; [EOL]         case '7': [EOL]             return 0xE; [EOL]         case '8': [EOL]             return 0x1; [EOL]         case '9': [EOL]             return 0x9; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return 0x5; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return 0xD; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return 0x3; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return 0xB; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return 0x7; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return 0xF; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] case '0': [LINE] public static boolean[] hexDigitToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '2': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '3': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case '4': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '5': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case '8': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] return new boolean[]{false, false, false, false}; [LINE] public static boolean[] hexDigitToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '2': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '3': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case '4': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '5': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case '8': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] case '1': [LINE] public static boolean[] hexDigitToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '2': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '3': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case '4': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '5': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case '8': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] return new boolean[]{true, false, false, false}; [LINE] public static boolean[] hexDigitToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '2': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '3': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case '4': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '5': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case '8': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] case '2': [LINE] public static boolean[] hexDigitToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '2': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '3': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case '4': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '5': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case '8': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] return new boolean[]{false, true, false, false}; [LINE] public static boolean[] hexDigitToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '2': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '3': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case '4': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '5': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case '8': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] case '3': [LINE] public static boolean[] hexDigitToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '2': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '3': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case '4': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '5': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case '8': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] return new boolean[]{true, true, false, false}; [LINE] public static boolean[] hexDigitToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '2': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '3': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case '4': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '5': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case '8': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] case '4': [LINE] public static boolean[] hexDigitToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '2': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '3': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case '4': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '5': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case '8': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] return new boolean[]{false, false, true, false}; [LINE] public static boolean[] hexDigitToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '2': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '3': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case '4': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '5': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case '8': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] case '5': [LINE] public static boolean[] hexDigitToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '2': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '3': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case '4': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '5': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case '8': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] return new boolean[]{true, false, true, false}; [LINE] public static boolean[] hexDigitToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '2': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '3': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case '4': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '5': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case '8': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] case '8': [LINE] public static boolean[] hexDigitToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '2': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '3': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case '4': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '5': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case '8': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] return new boolean[]{false, false, false, true}; [LINE] public static boolean[] hexDigitToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '2': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '3': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case '4': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '5': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case '8': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] case '9': [LINE] public static boolean[] hexDigitToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '2': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '3': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case '4': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '5': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case '8': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] return new boolean[]{true, false, false, true}; [LINE] public static boolean[] hexDigitToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '2': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '3': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case '4': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '5': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case '8': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] case 'a':// fall through [LINE] public static boolean[] hexDigitToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '2': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '3': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case '4': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '5': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case '8': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] case 'A': [LINE] public static boolean[] hexDigitToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '2': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '3': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case '4': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '5': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case '8': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] return new boolean[]{false, true, false, true}; [LINE] public static boolean[] hexDigitToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '2': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '3': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case '4': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '5': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case '8': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] case 'B': [LINE] public static boolean[] hexDigitToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '2': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '3': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case '4': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '5': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case '8': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] case 'C': [LINE] public static boolean[] hexDigitToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '2': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '3': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case '4': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '5': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case '8': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] case 'd':// fall through [LINE] public static boolean[] hexDigitToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '2': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '3': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case '4': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '5': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case '8': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] case 'D': [LINE] public static boolean[] hexDigitToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '2': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '3': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case '4': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '5': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case '8': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] return new boolean[]{true, false, true, true}; [LINE] public static boolean[] hexDigitToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '2': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '3': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case '4': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '5': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case '8': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] case 'E': [LINE] public static boolean[] hexDigitToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '2': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '3': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case '4': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '5': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case '8': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] case 'f':// fall through [LINE] public static boolean[] hexDigitToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '2': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '3': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case '4': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '5': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case '8': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] case 'F': [LINE] public static boolean[] hexDigitToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '2': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '3': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case '4': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '5': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case '8': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] return new boolean[]{true, true, true, true}; [LINE] public static boolean[] hexDigitToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '2': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '3': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case '4': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '5': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case '8': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] case '0': [LINE] public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '2': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '3': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case '4': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '5': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case '8': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] return new boolean[]{false, false, false, false}; [LINE] public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '2': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '3': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case '4': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '5': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case '8': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] case '1': [LINE] public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '2': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '3': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case '4': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '5': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case '8': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] return new boolean[]{false, false, false, true}; [LINE] public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '2': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '3': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case '4': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '5': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case '8': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] case '2': [LINE] public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '2': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '3': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case '4': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '5': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case '8': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] return new boolean[]{false, false, true, false}; [LINE] public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '2': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '3': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case '4': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '5': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case '8': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] case '3': [LINE] public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '2': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '3': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case '4': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '5': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case '8': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] return new boolean[]{false, false, true, true}; [LINE] public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '2': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '3': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case '4': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '5': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case '8': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] case '4': [LINE] public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '2': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '3': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case '4': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '5': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case '8': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] return new boolean[]{false, true, false, false}; [LINE] public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '2': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '3': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case '4': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '5': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case '8': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] case '6': [LINE] public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '2': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '3': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case '4': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '5': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case '8': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] return new boolean[]{false, true, true, false}; [LINE] public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '2': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '3': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case '4': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '5': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case '8': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] case '8': [LINE] public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '2': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '3': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case '4': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '5': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case '8': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] return new boolean[]{true, false, false, false}; [LINE] public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '2': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '3': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case '4': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '5': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case '8': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] case '9': [LINE] public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '2': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '3': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case '4': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '5': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case '8': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] return new boolean[]{true, false, false, true}; [LINE] public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '2': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '3': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case '4': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '5': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case '8': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] case 'a':// fall through [LINE] public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '2': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '3': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case '4': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '5': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case '8': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] case 'A': [LINE] public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '2': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '3': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case '4': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '5': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case '8': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] return new boolean[]{true, false, true, false}; [LINE] public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '2': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '3': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case '4': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '5': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case '8': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] case 'b':// fall through [LINE] public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '2': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '3': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case '4': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '5': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case '8': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] case 'B': [LINE] public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '2': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '3': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case '4': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '5': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case '8': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] return new boolean[]{true, false, true, true}; [LINE] public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '2': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '3': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case '4': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '5': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case '8': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] case 'C': [LINE] public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '2': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '3': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case '4': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '5': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case '8': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] case 'd':// fall through [LINE] public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '2': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '3': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case '4': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '5': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case '8': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] case 'D': [LINE] public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '2': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '3': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case '4': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '5': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case '8': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] return new boolean[]{true, true, false, true}; [LINE] public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '2': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '3': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case '4': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '5': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case '8': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] case 'e':// fall through [LINE] public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '2': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '3': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case '4': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '5': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case '8': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] case 'E': [LINE] public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '2': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '3': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case '4': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '5': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case '8': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] return new boolean[]{true, true, true, false}; [LINE] public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '2': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '3': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case '4': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '5': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case '8': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] case 'f':// fall through [LINE] public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '2': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '3': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case '4': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '5': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case '8': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] case 'F': [LINE] public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '2': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '3': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case '4': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '5': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case '8': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] return new boolean[]{true, true, true, true}; [LINE] public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '2': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '3': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case '4': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '5': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case '8': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] return 'e'; [LINE] public static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos) { [EOL]     if (src.length > 8) { [EOL]         throw new IllegalArgumentException("src.length>8: src.length=" + src.length); [EOL]     } [EOL]     if (src.length - srcPos < 4) { [EOL]         throw new IllegalArgumentException("src.length-srcPos<4: src.length=" + src.length + ", srcPos=" + srcPos); [EOL]     } [EOL]     if (src[srcPos + 3]) { [EOL]         if (src[srcPos + 2]) { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return '7'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return '3'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return '5'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '1'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src[srcPos + 2]) { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'e'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'a'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'c'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '8'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] } 
 [LINE] if (src.length > srcPos + 3 && src[srcPos + 3]) { [LINE] public static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     final int beSrcPos = src.length - 1 - srcPos; [EOL]     final int srcLen = Math.min(4, beSrcPos + 1); [EOL]     final boolean[] paddedSrc = new boolean[4]; [EOL]     System.arraycopy(src, beSrcPos + 1 - srcLen, paddedSrc, 4 - srcLen, srcLen); [EOL]     src = paddedSrc; [EOL]     srcPos = 0; [EOL]     if (src[srcPos]) { [EOL]         if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] } 
 [LINE] return 'f'; [LINE] public static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     final int beSrcPos = src.length - 1 - srcPos; [EOL]     final int srcLen = Math.min(4, beSrcPos + 1); [EOL]     final boolean[] paddedSrc = new boolean[4]; [EOL]     System.arraycopy(src, beSrcPos + 1 - srcLen, paddedSrc, 4 - srcLen, srcLen); [EOL]     src = paddedSrc; [EOL]     srcPos = 0; [EOL]     if (src[srcPos]) { [EOL]         if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] } 
 [LINE] return 'e'; [LINE] public static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     final int beSrcPos = src.length - 1 - srcPos; [EOL]     final int srcLen = Math.min(4, beSrcPos + 1); [EOL]     final boolean[] paddedSrc = new boolean[4]; [EOL]     System.arraycopy(src, beSrcPos + 1 - srcLen, paddedSrc, 4 - srcLen, srcLen); [EOL]     src = paddedSrc; [EOL]     srcPos = 0; [EOL]     if (src[srcPos]) { [EOL]         if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] } 
 [LINE] return '5'; [LINE] public static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     final int beSrcPos = src.length - 1 - srcPos; [EOL]     final int srcLen = Math.min(4, beSrcPos + 1); [EOL]     final boolean[] paddedSrc = new boolean[4]; [EOL]     System.arraycopy(src, beSrcPos + 1 - srcLen, paddedSrc, 4 - srcLen, srcLen); [EOL]     src = paddedSrc; [EOL]     srcPos = 0; [EOL]     if (src[srcPos]) { [EOL]         if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] } 
 [LINE] return '3'; [LINE] public static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     final int beSrcPos = src.length - 1 - srcPos; [EOL]     final int srcLen = Math.min(4, beSrcPos + 1); [EOL]     final boolean[] paddedSrc = new boolean[4]; [EOL]     System.arraycopy(src, beSrcPos + 1 - srcLen, paddedSrc, 4 - srcLen, srcLen); [EOL]     src = paddedSrc; [EOL]     srcPos = 0; [EOL]     if (src[srcPos]) { [EOL]         if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] } 
 [LINE] case 0x2: [LINE] public static char intToHexDigitMsb0(final int nibble) { [EOL]     switch(nibble) { [EOL]         case 0x0: [EOL]             return '0'; [EOL]         case 0x1: [EOL]             return '8'; [EOL]         case 0x2: [EOL]             return '4'; [EOL]         case 0x3: [EOL]             return 'c'; [EOL]         case 0x4: [EOL]             return '2'; [EOL]         case 0x5: [EOL]             return 'a'; [EOL]         case 0x6: [EOL]             return '6'; [EOL]         case 0x7: [EOL]             return 'e'; [EOL]         case 0x8: [EOL]             return '1'; [EOL]         case 0x9: [EOL]             return '9'; [EOL]         case 0xA: [EOL]             return '5'; [EOL]         case 0xB: [EOL]             return 'd'; [EOL]         case 0xC: [EOL]             return '3'; [EOL]         case 0xD: [EOL]             return 'b'; [EOL]         case 0xE: [EOL]             return '7'; [EOL]         case 0xF: [EOL]             return 'f'; [EOL]         default: [EOL]             throw new IllegalArgumentException("nibble value not between 0 and 15: " + nibble); [EOL]     } [EOL] } 
 [LINE] return '4'; [LINE] public static char intToHexDigitMsb0(final int nibble) { [EOL]     switch(nibble) { [EOL]         case 0x0: [EOL]             return '0'; [EOL]         case 0x1: [EOL]             return '8'; [EOL]         case 0x2: [EOL]             return '4'; [EOL]         case 0x3: [EOL]             return 'c'; [EOL]         case 0x4: [EOL]             return '2'; [EOL]         case 0x5: [EOL]             return 'a'; [EOL]         case 0x6: [EOL]             return '6'; [EOL]         case 0x7: [EOL]             return 'e'; [EOL]         case 0x8: [EOL]             return '1'; [EOL]         case 0x9: [EOL]             return '9'; [EOL]         case 0xA: [EOL]             return '5'; [EOL]         case 0xB: [EOL]             return 'd'; [EOL]         case 0xC: [EOL]             return '3'; [EOL]         case 0xD: [EOL]             return 'b'; [EOL]         case 0xE: [EOL]             return '7'; [EOL]         case 0xF: [EOL]             return 'f'; [EOL]         default: [EOL]             throw new IllegalArgumentException("nibble value not between 0 and 15: " + nibble); [EOL]     } [EOL] } 
 [LINE] case 0x3: [LINE] public static char intToHexDigitMsb0(final int nibble) { [EOL]     switch(nibble) { [EOL]         case 0x0: [EOL]             return '0'; [EOL]         case 0x1: [EOL]             return '8'; [EOL]         case 0x2: [EOL]             return '4'; [EOL]         case 0x3: [EOL]             return 'c'; [EOL]         case 0x4: [EOL]             return '2'; [EOL]         case 0x5: [EOL]             return 'a'; [EOL]         case 0x6: [EOL]             return '6'; [EOL]         case 0x7: [EOL]             return 'e'; [EOL]         case 0x8: [EOL]             return '1'; [EOL]         case 0x9: [EOL]             return '9'; [EOL]         case 0xA: [EOL]             return '5'; [EOL]         case 0xB: [EOL]             return 'd'; [EOL]         case 0xC: [EOL]             return '3'; [EOL]         case 0xD: [EOL]             return 'b'; [EOL]         case 0xE: [EOL]             return '7'; [EOL]         case 0xF: [EOL]             return 'f'; [EOL]         default: [EOL]             throw new IllegalArgumentException("nibble value not between 0 and 15: " + nibble); [EOL]     } [EOL] } 
 [LINE] return 'c'; [LINE] public static char intToHexDigitMsb0(final int nibble) { [EOL]     switch(nibble) { [EOL]         case 0x0: [EOL]             return '0'; [EOL]         case 0x1: [EOL]             return '8'; [EOL]         case 0x2: [EOL]             return '4'; [EOL]         case 0x3: [EOL]             return 'c'; [EOL]         case 0x4: [EOL]             return '2'; [EOL]         case 0x5: [EOL]             return 'a'; [EOL]         case 0x6: [EOL]             return '6'; [EOL]         case 0x7: [EOL]             return 'e'; [EOL]         case 0x8: [EOL]             return '1'; [EOL]         case 0x9: [EOL]             return '9'; [EOL]         case 0xA: [EOL]             return '5'; [EOL]         case 0xB: [EOL]             return 'd'; [EOL]         case 0xC: [EOL]             return '3'; [EOL]         case 0xD: [EOL]             return 'b'; [EOL]         case 0xE: [EOL]             return '7'; [EOL]         case 0xF: [EOL]             return 'f'; [EOL]         default: [EOL]             throw new IllegalArgumentException("nibble value not between 0 and 15: " + nibble); [EOL]     } [EOL] } 
 [LINE] case 0x4: [LINE] public static char intToHexDigitMsb0(final int nibble) { [EOL]     switch(nibble) { [EOL]         case 0x0: [EOL]             return '0'; [EOL]         case 0x1: [EOL]             return '8'; [EOL]         case 0x2: [EOL]             return '4'; [EOL]         case 0x3: [EOL]             return 'c'; [EOL]         case 0x4: [EOL]             return '2'; [EOL]         case 0x5: [EOL]             return 'a'; [EOL]         case 0x6: [EOL]             return '6'; [EOL]         case 0x7: [EOL]             return 'e'; [EOL]         case 0x8: [EOL]             return '1'; [EOL]         case 0x9: [EOL]             return '9'; [EOL]         case 0xA: [EOL]             return '5'; [EOL]         case 0xB: [EOL]             return 'd'; [EOL]         case 0xC: [EOL]             return '3'; [EOL]         case 0xD: [EOL]             return 'b'; [EOL]         case 0xE: [EOL]             return '7'; [EOL]         case 0xF: [EOL]             return 'f'; [EOL]         default: [EOL]             throw new IllegalArgumentException("nibble value not between 0 and 15: " + nibble); [EOL]     } [EOL] } 
 [LINE] return '2'; [LINE] public static char intToHexDigitMsb0(final int nibble) { [EOL]     switch(nibble) { [EOL]         case 0x0: [EOL]             return '0'; [EOL]         case 0x1: [EOL]             return '8'; [EOL]         case 0x2: [EOL]             return '4'; [EOL]         case 0x3: [EOL]             return 'c'; [EOL]         case 0x4: [EOL]             return '2'; [EOL]         case 0x5: [EOL]             return 'a'; [EOL]         case 0x6: [EOL]             return '6'; [EOL]         case 0x7: [EOL]             return 'e'; [EOL]         case 0x8: [EOL]             return '1'; [EOL]         case 0x9: [EOL]             return '9'; [EOL]         case 0xA: [EOL]             return '5'; [EOL]         case 0xB: [EOL]             return 'd'; [EOL]         case 0xC: [EOL]             return '3'; [EOL]         case 0xD: [EOL]             return 'b'; [EOL]         case 0xE: [EOL]             return '7'; [EOL]         case 0xF: [EOL]             return 'f'; [EOL]         default: [EOL]             throw new IllegalArgumentException("nibble value not between 0 and 15: " + nibble); [EOL]     } [EOL] } 
 [LINE] case 0x6: [LINE] public static char intToHexDigitMsb0(final int nibble) { [EOL]     switch(nibble) { [EOL]         case 0x0: [EOL]             return '0'; [EOL]         case 0x1: [EOL]             return '8'; [EOL]         case 0x2: [EOL]             return '4'; [EOL]         case 0x3: [EOL]             return 'c'; [EOL]         case 0x4: [EOL]             return '2'; [EOL]         case 0x5: [EOL]             return 'a'; [EOL]         case 0x6: [EOL]             return '6'; [EOL]         case 0x7: [EOL]             return 'e'; [EOL]         case 0x8: [EOL]             return '1'; [EOL]         case 0x9: [EOL]             return '9'; [EOL]         case 0xA: [EOL]             return '5'; [EOL]         case 0xB: [EOL]             return 'd'; [EOL]         case 0xC: [EOL]             return '3'; [EOL]         case 0xD: [EOL]             return 'b'; [EOL]         case 0xE: [EOL]             return '7'; [EOL]         case 0xF: [EOL]             return 'f'; [EOL]         default: [EOL]             throw new IllegalArgumentException("nibble value not between 0 and 15: " + nibble); [EOL]     } [EOL] } 
 [LINE] return '6'; [LINE] public static char intToHexDigitMsb0(final int nibble) { [EOL]     switch(nibble) { [EOL]         case 0x0: [EOL]             return '0'; [EOL]         case 0x1: [EOL]             return '8'; [EOL]         case 0x2: [EOL]             return '4'; [EOL]         case 0x3: [EOL]             return 'c'; [EOL]         case 0x4: [EOL]             return '2'; [EOL]         case 0x5: [EOL]             return 'a'; [EOL]         case 0x6: [EOL]             return '6'; [EOL]         case 0x7: [EOL]             return 'e'; [EOL]         case 0x8: [EOL]             return '1'; [EOL]         case 0x9: [EOL]             return '9'; [EOL]         case 0xA: [EOL]             return '5'; [EOL]         case 0xB: [EOL]             return 'd'; [EOL]         case 0xC: [EOL]             return '3'; [EOL]         case 0xD: [EOL]             return 'b'; [EOL]         case 0xE: [EOL]             return '7'; [EOL]         case 0xF: [EOL]             return 'f'; [EOL]         default: [EOL]             throw new IllegalArgumentException("nibble value not between 0 and 15: " + nibble); [EOL]     } [EOL] } 
 [LINE] case 0x7: [LINE] public static char intToHexDigitMsb0(final int nibble) { [EOL]     switch(nibble) { [EOL]         case 0x0: [EOL]             return '0'; [EOL]         case 0x1: [EOL]             return '8'; [EOL]         case 0x2: [EOL]             return '4'; [EOL]         case 0x3: [EOL]             return 'c'; [EOL]         case 0x4: [EOL]             return '2'; [EOL]         case 0x5: [EOL]             return 'a'; [EOL]         case 0x6: [EOL]             return '6'; [EOL]         case 0x7: [EOL]             return 'e'; [EOL]         case 0x8: [EOL]             return '1'; [EOL]         case 0x9: [EOL]             return '9'; [EOL]         case 0xA: [EOL]             return '5'; [EOL]         case 0xB: [EOL]             return 'd'; [EOL]         case 0xC: [EOL]             return '3'; [EOL]         case 0xD: [EOL]             return 'b'; [EOL]         case 0xE: [EOL]             return '7'; [EOL]         case 0xF: [EOL]             return 'f'; [EOL]         default: [EOL]             throw new IllegalArgumentException("nibble value not between 0 and 15: " + nibble); [EOL]     } [EOL] } 
 [LINE] return 'e'; [LINE] public static char intToHexDigitMsb0(final int nibble) { [EOL]     switch(nibble) { [EOL]         case 0x0: [EOL]             return '0'; [EOL]         case 0x1: [EOL]             return '8'; [EOL]         case 0x2: [EOL]             return '4'; [EOL]         case 0x3: [EOL]             return 'c'; [EOL]         case 0x4: [EOL]             return '2'; [EOL]         case 0x5: [EOL]             return 'a'; [EOL]         case 0x6: [EOL]             return '6'; [EOL]         case 0x7: [EOL]             return 'e'; [EOL]         case 0x8: [EOL]             return '1'; [EOL]         case 0x9: [EOL]             return '9'; [EOL]         case 0xA: [EOL]             return '5'; [EOL]         case 0xB: [EOL]             return 'd'; [EOL]         case 0xC: [EOL]             return '3'; [EOL]         case 0xD: [EOL]             return 'b'; [EOL]         case 0xE: [EOL]             return '7'; [EOL]         case 0xF: [EOL]             return 'f'; [EOL]         default: [EOL]             throw new IllegalArgumentException("nibble value not between 0 and 15: " + nibble); [EOL]     } [EOL] } 
 [LINE] case 0x8: [LINE] public static char intToHexDigitMsb0(final int nibble) { [EOL]     switch(nibble) { [EOL]         case 0x0: [EOL]             return '0'; [EOL]         case 0x1: [EOL]             return '8'; [EOL]         case 0x2: [EOL]             return '4'; [EOL]         case 0x3: [EOL]             return 'c'; [EOL]         case 0x4: [EOL]             return '2'; [EOL]         case 0x5: [EOL]             return 'a'; [EOL]         case 0x6: [EOL]             return '6'; [EOL]         case 0x7: [EOL]             return 'e'; [EOL]         case 0x8: [EOL]             return '1'; [EOL]         case 0x9: [EOL]             return '9'; [EOL]         case 0xA: [EOL]             return '5'; [EOL]         case 0xB: [EOL]             return 'd'; [EOL]         case 0xC: [EOL]             return '3'; [EOL]         case 0xD: [EOL]             return 'b'; [EOL]         case 0xE: [EOL]             return '7'; [EOL]         case 0xF: [EOL]             return 'f'; [EOL]         default: [EOL]             throw new IllegalArgumentException("nibble value not between 0 and 15: " + nibble); [EOL]     } [EOL] } 
 [LINE] return '1'; [LINE] public static char intToHexDigitMsb0(final int nibble) { [EOL]     switch(nibble) { [EOL]         case 0x0: [EOL]             return '0'; [EOL]         case 0x1: [EOL]             return '8'; [EOL]         case 0x2: [EOL]             return '4'; [EOL]         case 0x3: [EOL]             return 'c'; [EOL]         case 0x4: [EOL]             return '2'; [EOL]         case 0x5: [EOL]             return 'a'; [EOL]         case 0x6: [EOL]             return '6'; [EOL]         case 0x7: [EOL]             return 'e'; [EOL]         case 0x8: [EOL]             return '1'; [EOL]         case 0x9: [EOL]             return '9'; [EOL]         case 0xA: [EOL]             return '5'; [EOL]         case 0xB: [EOL]             return 'd'; [EOL]         case 0xC: [EOL]             return '3'; [EOL]         case 0xD: [EOL]             return 'b'; [EOL]         case 0xE: [EOL]             return '7'; [EOL]         case 0xF: [EOL]             return 'f'; [EOL]         default: [EOL]             throw new IllegalArgumentException("nibble value not between 0 and 15: " + nibble); [EOL]     } [EOL] } 
 [LINE] case 0x9: [LINE] public static char intToHexDigitMsb0(final int nibble) { [EOL]     switch(nibble) { [EOL]         case 0x0: [EOL]             return '0'; [EOL]         case 0x1: [EOL]             return '8'; [EOL]         case 0x2: [EOL]             return '4'; [EOL]         case 0x3: [EOL]             return 'c'; [EOL]         case 0x4: [EOL]             return '2'; [EOL]         case 0x5: [EOL]             return 'a'; [EOL]         case 0x6: [EOL]             return '6'; [EOL]         case 0x7: [EOL]             return 'e'; [EOL]         case 0x8: [EOL]             return '1'; [EOL]         case 0x9: [EOL]             return '9'; [EOL]         case 0xA: [EOL]             return '5'; [EOL]         case 0xB: [EOL]             return 'd'; [EOL]         case 0xC: [EOL]             return '3'; [EOL]         case 0xD: [EOL]             return 'b'; [EOL]         case 0xE: [EOL]             return '7'; [EOL]         case 0xF: [EOL]             return 'f'; [EOL]         default: [EOL]             throw new IllegalArgumentException("nibble value not between 0 and 15: " + nibble); [EOL]     } [EOL] } 
 [LINE] return '9'; [LINE] public static char intToHexDigitMsb0(final int nibble) { [EOL]     switch(nibble) { [EOL]         case 0x0: [EOL]             return '0'; [EOL]         case 0x1: [EOL]             return '8'; [EOL]         case 0x2: [EOL]             return '4'; [EOL]         case 0x3: [EOL]             return 'c'; [EOL]         case 0x4: [EOL]             return '2'; [EOL]         case 0x5: [EOL]             return 'a'; [EOL]         case 0x6: [EOL]             return '6'; [EOL]         case 0x7: [EOL]             return 'e'; [EOL]         case 0x8: [EOL]             return '1'; [EOL]         case 0x9: [EOL]             return '9'; [EOL]         case 0xA: [EOL]             return '5'; [EOL]         case 0xB: [EOL]             return 'd'; [EOL]         case 0xC: [EOL]             return '3'; [EOL]         case 0xD: [EOL]             return 'b'; [EOL]         case 0xE: [EOL]             return '7'; [EOL]         case 0xF: [EOL]             return 'f'; [EOL]         default: [EOL]             throw new IllegalArgumentException("nibble value not between 0 and 15: " + nibble); [EOL]     } [EOL] } 
 [LINE] case 0xA: [LINE] public static char intToHexDigitMsb0(final int nibble) { [EOL]     switch(nibble) { [EOL]         case 0x0: [EOL]             return '0'; [EOL]         case 0x1: [EOL]             return '8'; [EOL]         case 0x2: [EOL]             return '4'; [EOL]         case 0x3: [EOL]             return 'c'; [EOL]         case 0x4: [EOL]             return '2'; [EOL]         case 0x5: [EOL]             return 'a'; [EOL]         case 0x6: [EOL]             return '6'; [EOL]         case 0x7: [EOL]             return 'e'; [EOL]         case 0x8: [EOL]             return '1'; [EOL]         case 0x9: [EOL]             return '9'; [EOL]         case 0xA: [EOL]             return '5'; [EOL]         case 0xB: [EOL]             return 'd'; [EOL]         case 0xC: [EOL]             return '3'; [EOL]         case 0xD: [EOL]             return 'b'; [EOL]         case 0xE: [EOL]             return '7'; [EOL]         case 0xF: [EOL]             return 'f'; [EOL]         default: [EOL]             throw new IllegalArgumentException("nibble value not between 0 and 15: " + nibble); [EOL]     } [EOL] } 
 [LINE] return '5'; [LINE] public static char intToHexDigitMsb0(final int nibble) { [EOL]     switch(nibble) { [EOL]         case 0x0: [EOL]             return '0'; [EOL]         case 0x1: [EOL]             return '8'; [EOL]         case 0x2: [EOL]             return '4'; [EOL]         case 0x3: [EOL]             return 'c'; [EOL]         case 0x4: [EOL]             return '2'; [EOL]         case 0x5: [EOL]             return 'a'; [EOL]         case 0x6: [EOL]             return '6'; [EOL]         case 0x7: [EOL]             return 'e'; [EOL]         case 0x8: [EOL]             return '1'; [EOL]         case 0x9: [EOL]             return '9'; [EOL]         case 0xA: [EOL]             return '5'; [EOL]         case 0xB: [EOL]             return 'd'; [EOL]         case 0xC: [EOL]             return '3'; [EOL]         case 0xD: [EOL]             return 'b'; [EOL]         case 0xE: [EOL]             return '7'; [EOL]         case 0xF: [EOL]             return 'f'; [EOL]         default: [EOL]             throw new IllegalArgumentException("nibble value not between 0 and 15: " + nibble); [EOL]     } [EOL] } 
 [LINE] case 0xC: [LINE] public static char intToHexDigitMsb0(final int nibble) { [EOL]     switch(nibble) { [EOL]         case 0x0: [EOL]             return '0'; [EOL]         case 0x1: [EOL]             return '8'; [EOL]         case 0x2: [EOL]             return '4'; [EOL]         case 0x3: [EOL]             return 'c'; [EOL]         case 0x4: [EOL]             return '2'; [EOL]         case 0x5: [EOL]             return 'a'; [EOL]         case 0x6: [EOL]             return '6'; [EOL]         case 0x7: [EOL]             return 'e'; [EOL]         case 0x8: [EOL]             return '1'; [EOL]         case 0x9: [EOL]             return '9'; [EOL]         case 0xA: [EOL]             return '5'; [EOL]         case 0xB: [EOL]             return 'd'; [EOL]         case 0xC: [EOL]             return '3'; [EOL]         case 0xD: [EOL]             return 'b'; [EOL]         case 0xE: [EOL]             return '7'; [EOL]         case 0xF: [EOL]             return 'f'; [EOL]         default: [EOL]             throw new IllegalArgumentException("nibble value not between 0 and 15: " + nibble); [EOL]     } [EOL] } 
 [LINE] return '3'; [LINE] public static char intToHexDigitMsb0(final int nibble) { [EOL]     switch(nibble) { [EOL]         case 0x0: [EOL]             return '0'; [EOL]         case 0x1: [EOL]             return '8'; [EOL]         case 0x2: [EOL]             return '4'; [EOL]         case 0x3: [EOL]             return 'c'; [EOL]         case 0x4: [EOL]             return '2'; [EOL]         case 0x5: [EOL]             return 'a'; [EOL]         case 0x6: [EOL]             return '6'; [EOL]         case 0x7: [EOL]             return 'e'; [EOL]         case 0x8: [EOL]             return '1'; [EOL]         case 0x9: [EOL]             return '9'; [EOL]         case 0xA: [EOL]             return '5'; [EOL]         case 0xB: [EOL]             return 'd'; [EOL]         case 0xC: [EOL]             return '3'; [EOL]         case 0xD: [EOL]             return 'b'; [EOL]         case 0xE: [EOL]             return '7'; [EOL]         case 0xF: [EOL]             return 'f'; [EOL]         default: [EOL]             throw new IllegalArgumentException("nibble value not between 0 and 15: " + nibble); [EOL]     } [EOL] } 
 [LINE] case 0xF: [LINE] public static char intToHexDigitMsb0(final int nibble) { [EOL]     switch(nibble) { [EOL]         case 0x0: [EOL]             return '0'; [EOL]         case 0x1: [EOL]             return '8'; [EOL]         case 0x2: [EOL]             return '4'; [EOL]         case 0x3: [EOL]             return 'c'; [EOL]         case 0x4: [EOL]             return '2'; [EOL]         case 0x5: [EOL]             return 'a'; [EOL]         case 0x6: [EOL]             return '6'; [EOL]         case 0x7: [EOL]             return 'e'; [EOL]         case 0x8: [EOL]             return '1'; [EOL]         case 0x9: [EOL]             return '9'; [EOL]         case 0xA: [EOL]             return '5'; [EOL]         case 0xB: [EOL]             return 'd'; [EOL]         case 0xC: [EOL]             return '3'; [EOL]         case 0xD: [EOL]             return 'b'; [EOL]         case 0xE: [EOL]             return '7'; [EOL]         case 0xF: [EOL]             return 'f'; [EOL]         default: [EOL]             throw new IllegalArgumentException("nibble value not between 0 and 15: " + nibble); [EOL]     } [EOL] } 
 [LINE] return 'f'; [LINE] public static char intToHexDigitMsb0(final int nibble) { [EOL]     switch(nibble) { [EOL]         case 0x0: [EOL]             return '0'; [EOL]         case 0x1: [EOL]             return '8'; [EOL]         case 0x2: [EOL]             return '4'; [EOL]         case 0x3: [EOL]             return 'c'; [EOL]         case 0x4: [EOL]             return '2'; [EOL]         case 0x5: [EOL]             return 'a'; [EOL]         case 0x6: [EOL]             return '6'; [EOL]         case 0x7: [EOL]             return 'e'; [EOL]         case 0x8: [EOL]             return '1'; [EOL]         case 0x9: [EOL]             return '9'; [EOL]         case 0xA: [EOL]             return '5'; [EOL]         case 0xB: [EOL]             return 'd'; [EOL]         case 0xC: [EOL]             return '3'; [EOL]         case 0xD: [EOL]             return 'b'; [EOL]         case 0xE: [EOL]             return '7'; [EOL]         case 0xF: [EOL]             return 'f'; [EOL]         default: [EOL]             throw new IllegalArgumentException("nibble value not between 0 and 15: " + nibble); [EOL]     } [EOL] } 
 [LINE] final long mask = 0xffffffffL << shift; [LINE] public static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nInts) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nInts - 1) * 32 + dstPos >= 64) { [EOL]         throw new IllegalArgumentException("(nInts-1)*32+dstPos is greather or equal to than 64"); [EOL]     } [EOL]     long out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nInts; i++) { [EOL]         shift = i * 32 + dstPos; [EOL]         final long bits = ((0xffffffffL & src[i + srcPos]) << shift); [EOL]         final long mask = 0xffffffffL << shift; [EOL]         out = (out & ~mask) | bits; [EOL]     } [EOL]     return out; [EOL] } 
 [LINE] out = (out & ~mask) | bits; [LINE] public static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nInts) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nInts - 1) * 32 + dstPos >= 64) { [EOL]         throw new IllegalArgumentException("(nInts-1)*32+dstPos is greather or equal to than 64"); [EOL]     } [EOL]     long out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nInts; i++) { [EOL]         shift = i * 32 + dstPos; [EOL]         final long bits = ((0xffffffffL & src[i + srcPos]) << shift); [EOL]         final long mask = 0xffffffffL << shift; [EOL]         out = (out & ~mask) | bits; [EOL]     } [EOL]     return out; [EOL] } 
 [LINE] final long mask = 0xffffL << shift; [LINE] public static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nShorts) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nShorts - 1) * 16 + dstPos >= 64) { [EOL]         throw new IllegalArgumentException("(nShorts-1)*16+dstPos is greather or equal to than 64"); [EOL]     } [EOL]     long out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nShorts; i++) { [EOL]         shift = i * 16 + dstPos; [EOL]         final long bits = (0xffffL & src[i + srcPos]) << shift; [EOL]         final long mask = 0xffffL << shift; [EOL]         out = (out & ~mask) | bits; [EOL]     } [EOL]     return out; [EOL] } 
 [LINE] out = (out & ~mask) | bits; [LINE] public static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nShorts) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nShorts - 1) * 16 + dstPos >= 64) { [EOL]         throw new IllegalArgumentException("(nShorts-1)*16+dstPos is greather or equal to than 64"); [EOL]     } [EOL]     long out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nShorts; i++) { [EOL]         shift = i * 16 + dstPos; [EOL]         final long bits = (0xffffL & src[i + srcPos]) << shift; [EOL]         final long mask = 0xffffL << shift; [EOL]         out = (out & ~mask) | bits; [EOL]     } [EOL]     return out; [EOL] } 
 [LINE] shift = i * 16 + dstPos; [LINE] public static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nShorts) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nShorts - 1) * 16 + dstPos >= 32) { [EOL]         throw new IllegalArgumentException("(nShorts-1)*16+dstPos is greather or equal to than 32"); [EOL]     } [EOL]     int out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nShorts; i++) { [EOL]         shift = i * 16 + dstPos; [EOL]         final int bits = (0xffff & src[i + srcPos]) << shift; [EOL]         final int mask = 0xffff << shift; [EOL]         out = (out & ~mask) | bits; [EOL]     } [EOL]     return out; [EOL] } 
 [LINE] final int bits = (0xffff & src[i + srcPos]) << shift; [LINE] public static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nShorts) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nShorts - 1) * 16 + dstPos >= 32) { [EOL]         throw new IllegalArgumentException("(nShorts-1)*16+dstPos is greather or equal to than 32"); [EOL]     } [EOL]     int out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nShorts; i++) { [EOL]         shift = i * 16 + dstPos; [EOL]         final int bits = (0xffff & src[i + srcPos]) << shift; [EOL]         final int mask = 0xffff << shift; [EOL]         out = (out & ~mask) | bits; [EOL]     } [EOL]     return out; [EOL] } 
 [LINE] final int mask = 0xffff << shift; [LINE] public static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nShorts) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nShorts - 1) * 16 + dstPos >= 32) { [EOL]         throw new IllegalArgumentException("(nShorts-1)*16+dstPos is greather or equal to than 32"); [EOL]     } [EOL]     int out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nShorts; i++) { [EOL]         shift = i * 16 + dstPos; [EOL]         final int bits = (0xffff & src[i + srcPos]) << shift; [EOL]         final int mask = 0xffff << shift; [EOL]         out = (out & ~mask) | bits; [EOL]     } [EOL]     return out; [EOL] } 
 [LINE] out = (out & ~mask) | bits; [LINE] public static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nShorts) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nShorts - 1) * 16 + dstPos >= 32) { [EOL]         throw new IllegalArgumentException("(nShorts-1)*16+dstPos is greather or equal to than 32"); [EOL]     } [EOL]     int out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nShorts; i++) { [EOL]         shift = i * 16 + dstPos; [EOL]         final int bits = (0xffff & src[i + srcPos]) << shift; [EOL]         final int mask = 0xffff << shift; [EOL]         out = (out & ~mask) | bits; [EOL]     } [EOL]     return out; [EOL] } 
 [LINE] final long mask = 0xffL << shift; [LINE] public static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nBytes) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nBytes - 1) * 8 + dstPos >= 64) { [EOL]         throw new IllegalArgumentException("(nBytes-1)*8+dstPos is greather or equal to than 64"); [EOL]     } [EOL]     long out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBytes; i++) { [EOL]         shift = i * 8 + dstPos; [EOL]         final long bits = (0xffL & src[i + srcPos]) << shift; [EOL]         final long mask = 0xffL << shift; [EOL]         out = (out & ~mask) | bits; [EOL]     } [EOL]     return out; [EOL] } 
 [LINE] out = (out & ~mask) | bits; [LINE] public static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nBytes) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nBytes - 1) * 8 + dstPos >= 64) { [EOL]         throw new IllegalArgumentException("(nBytes-1)*8+dstPos is greather or equal to than 64"); [EOL]     } [EOL]     long out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBytes; i++) { [EOL]         shift = i * 8 + dstPos; [EOL]         final long bits = (0xffL & src[i + srcPos]) << shift; [EOL]         final long mask = 0xffL << shift; [EOL]         out = (out & ~mask) | bits; [EOL]     } [EOL]     return out; [EOL] } 
 [LINE] final int mask = 0xff << shift; [LINE] public static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nBytes) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nBytes - 1) * 8 + dstPos >= 32) { [EOL]         throw new IllegalArgumentException("(nBytes-1)*8+dstPos is greather or equal to than 32"); [EOL]     } [EOL]     int out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBytes; i++) { [EOL]         shift = i * 8 + dstPos; [EOL]         final int bits = (0xff & src[i + srcPos]) << shift; [EOL]         final int mask = 0xff << shift; [EOL]         out = (out & ~mask) | bits; [EOL]     } [EOL]     return out; [EOL] } 
 [LINE] out = (out & ~mask) | bits; [LINE] public static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nBytes) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nBytes - 1) * 8 + dstPos >= 32) { [EOL]         throw new IllegalArgumentException("(nBytes-1)*8+dstPos is greather or equal to than 32"); [EOL]     } [EOL]     int out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBytes; i++) { [EOL]         shift = i * 8 + dstPos; [EOL]         final int bits = (0xff & src[i + srcPos]) << shift; [EOL]         final int mask = 0xff << shift; [EOL]         out = (out & ~mask) | bits; [EOL]     } [EOL]     return out; [EOL] } 
 [LINE] final int mask = 0xff << shift; [LINE] public static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nBytes) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nBytes - 1) * 8 + dstPos >= 16) { [EOL]         throw new IllegalArgumentException("(nBytes-1)*8+dstPos is greather or equal to than 16"); [EOL]     } [EOL]     short out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBytes; i++) { [EOL]         shift = i * 8 + dstPos; [EOL]         final int bits = (0xff & src[i + srcPos]) << shift; [EOL]         final int mask = 0xff << shift; [EOL]         out = (short) ((out & ~mask) | bits); [EOL]     } [EOL]     return out; [EOL] } 
 [LINE] out = (short)((out & ~mask) | bits); [LINE] public static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nBytes) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nBytes - 1) * 8 + dstPos >= 16) { [EOL]         throw new IllegalArgumentException("(nBytes-1)*8+dstPos is greather or equal to than 16"); [EOL]     } [EOL]     short out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBytes; i++) { [EOL]         shift = i * 8 + dstPos; [EOL]         final int bits = (0xff & src[i + srcPos]) << shift; [EOL]         final int mask = 0xff << shift; [EOL]         out = (short) ((out & ~mask) | bits); [EOL]     } [EOL]     return out; [EOL] } 
 [LINE] final long mask = 0xfL << shift; [LINE] public static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex) { [EOL]     if (0 == nHex) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nHex - 1) * 4 + dstPos >= 64) { [EOL]         throw new IllegalArgumentException("(nHexs-1)*4+dstPos is greather or equal to than 64"); [EOL]     } [EOL]     long out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nHex; i++) { [EOL]         shift = i * 4 + dstPos; [EOL]         final long bits = (0xfL & hexDigitToInt(src.charAt(i + srcPos))) << shift; [EOL]         final long mask = 0xfL << shift; [EOL]         out = (out & ~mask) | bits; [EOL]     } [EOL]     return out; [EOL] } 
 [LINE] out = (out & ~mask) | bits; [LINE] public static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex) { [EOL]     if (0 == nHex) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nHex - 1) * 4 + dstPos >= 64) { [EOL]         throw new IllegalArgumentException("(nHexs-1)*4+dstPos is greather or equal to than 64"); [EOL]     } [EOL]     long out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nHex; i++) { [EOL]         shift = i * 4 + dstPos; [EOL]         final long bits = (0xfL & hexDigitToInt(src.charAt(i + srcPos))) << shift; [EOL]         final long mask = 0xfL << shift; [EOL]         out = (out & ~mask) | bits; [EOL]     } [EOL]     return out; [EOL] } 
 [LINE] final int mask = 0xf << shift; [LINE] public static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex) { [EOL]     if (0 == nHex) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nHex - 1) * 4 + dstPos >= 32) { [EOL]         throw new IllegalArgumentException("(nHexs-1)*4+dstPos is greather or equal to than 32"); [EOL]     } [EOL]     int out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nHex; i++) { [EOL]         shift = i * 4 + dstPos; [EOL]         final int bits = (0xf & hexDigitToInt(src.charAt(i + srcPos))) << shift; [EOL]         final int mask = 0xf << shift; [EOL]         out = (out & ~mask) | bits; [EOL]     } [EOL]     return out; [EOL] } 
 [LINE] out = (out & ~mask) | bits; [LINE] public static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex) { [EOL]     if (0 == nHex) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nHex - 1) * 4 + dstPos >= 32) { [EOL]         throw new IllegalArgumentException("(nHexs-1)*4+dstPos is greather or equal to than 32"); [EOL]     } [EOL]     int out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nHex; i++) { [EOL]         shift = i * 4 + dstPos; [EOL]         final int bits = (0xf & hexDigitToInt(src.charAt(i + srcPos))) << shift; [EOL]         final int mask = 0xf << shift; [EOL]         out = (out & ~mask) | bits; [EOL]     } [EOL]     return out; [EOL] } 
 [LINE] final int mask = 0xf << shift; [LINE] public static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex) { [EOL]     if (0 == nHex) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nHex - 1) * 4 + dstPos >= 16) { [EOL]         throw new IllegalArgumentException("(nHexs-1)*4+dstPos is greather or equal to than 16"); [EOL]     } [EOL]     short out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nHex; i++) { [EOL]         shift = i * 4 + dstPos; [EOL]         final int bits = (0xf & hexDigitToInt(src.charAt(i + srcPos))) << shift; [EOL]         final int mask = 0xf << shift; [EOL]         out = (short) ((out & ~mask) | bits); [EOL]     } [EOL]     return out; [EOL] } 
 [LINE] out = (short)((out & ~mask) | bits); [LINE] public static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex) { [EOL]     if (0 == nHex) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nHex - 1) * 4 + dstPos >= 16) { [EOL]         throw new IllegalArgumentException("(nHexs-1)*4+dstPos is greather or equal to than 16"); [EOL]     } [EOL]     short out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nHex; i++) { [EOL]         shift = i * 4 + dstPos; [EOL]         final int bits = (0xf & hexDigitToInt(src.charAt(i + srcPos))) << shift; [EOL]         final int mask = 0xf << shift; [EOL]         out = (short) ((out & ~mask) | bits); [EOL]     } [EOL]     return out; [EOL] } 
 [LINE] final int mask = 0xf << shift; [LINE] public static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex) { [EOL]     if (0 == nHex) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nHex - 1) * 4 + dstPos >= 8) { [EOL]         throw new IllegalArgumentException("(nHexs-1)*4+dstPos is greather or equal to than 8"); [EOL]     } [EOL]     byte out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nHex; i++) { [EOL]         shift = i * 4 + dstPos; [EOL]         final int bits = (0xf & hexDigitToInt(src.charAt(i + srcPos))) << shift; [EOL]         final int mask = 0xf << shift; [EOL]         out = (byte) ((out & ~mask) | bits); [EOL]     } [EOL]     return out; [EOL] } 
 [LINE] out = (byte)((out & ~mask) | bits); [LINE] public static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex) { [EOL]     if (0 == nHex) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nHex - 1) * 4 + dstPos >= 8) { [EOL]         throw new IllegalArgumentException("(nHexs-1)*4+dstPos is greather or equal to than 8"); [EOL]     } [EOL]     byte out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nHex; i++) { [EOL]         shift = i * 4 + dstPos; [EOL]         final int bits = (0xf & hexDigitToInt(src.charAt(i + srcPos))) << shift; [EOL]         final int mask = 0xf << shift; [EOL]         out = (byte) ((out & ~mask) | bits); [EOL]     } [EOL]     return out; [EOL] } 
 [LINE] final long mask = 0x1L << shift; [LINE] public static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nBools) { [EOL]         return dstInit; [EOL]     } [EOL]     if (nBools - 1 + dstPos >= 64) { [EOL]         throw new IllegalArgumentException("nBools-1+dstPos is greather or equal to than 64"); [EOL]     } [EOL]     long out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBools; i++) { [EOL]         shift = i * 1 + dstPos; [EOL]         final long bits = (src[i + srcPos] ? 1L : 0) << shift; [EOL]         final long mask = 0x1L << shift; [EOL]         out = (out & ~mask) | bits; [EOL]     } [EOL]     return out; [EOL] } 
 [LINE] out = (out & ~mask) | bits; [LINE] public static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nBools) { [EOL]         return dstInit; [EOL]     } [EOL]     if (nBools - 1 + dstPos >= 64) { [EOL]         throw new IllegalArgumentException("nBools-1+dstPos is greather or equal to than 64"); [EOL]     } [EOL]     long out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBools; i++) { [EOL]         shift = i * 1 + dstPos; [EOL]         final long bits = (src[i + srcPos] ? 1L : 0) << shift; [EOL]         final long mask = 0x1L << shift; [EOL]         out = (out & ~mask) | bits; [EOL]     } [EOL]     return out; [EOL] } 
 [LINE] shift = i * 32 + srcPos; [LINE] public static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts) { [EOL]     if (0 == nInts) { [EOL]         return dst; [EOL]     } [EOL]     if ((nInts - 1) * 32 + srcPos >= 64) { [EOL]         throw new IllegalArgumentException("(nInts-1)*32+srcPos is greather or equal to than 64"); [EOL]     } [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nInts; i++) { [EOL]         shift = i * 32 + srcPos; [EOL]         dst[dstPos + i] = (int) (0xffffffff & (src >> shift)); [EOL]     } [EOL]     return dst; [EOL] } 
 [LINE] dst[dstPos + i] = (int)(0xffffffff & (src >> shift)); [LINE] public static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts) { [EOL]     if (0 == nInts) { [EOL]         return dst; [EOL]     } [EOL]     if ((nInts - 1) * 32 + srcPos >= 64) { [EOL]         throw new IllegalArgumentException("(nInts-1)*32+srcPos is greather or equal to than 64"); [EOL]     } [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nInts; i++) { [EOL]         shift = i * 32 + srcPos; [EOL]         dst[dstPos + i] = (int) (0xffffffff & (src >> shift)); [EOL]     } [EOL]     return dst; [EOL] } 
 [LINE] ++append; [LINE] public static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) { [EOL]     if (0 == nHexs) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nHexs - 1) * 4 + srcPos >= 64) { [EOL]         throw new IllegalArgumentException("(nHexs-1)*4+srcPos is greather or equal to than 64"); [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(dstInit); [EOL]     int shift = 0; [EOL]     int append = sb.length(); [EOL]     for (int i = 0; i < nHexs; i++) { [EOL]         shift = i * 4 + srcPos; [EOL]         final int bits = (int) (0xF & (src >> shift)); [EOL]         if (dstPos + i == append) { [EOL]             ++append; [EOL]             sb.append(intToHexDigit(bits)); [EOL]         } else { [EOL]             sb.setCharAt(dstPos + i, intToHexDigit(bits)); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] } 
 [LINE] sb.append(intToHexDigit(bits)); [LINE] public static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) { [EOL]     if (0 == nHexs) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nHexs - 1) * 4 + srcPos >= 64) { [EOL]         throw new IllegalArgumentException("(nHexs-1)*4+srcPos is greather or equal to than 64"); [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(dstInit); [EOL]     int shift = 0; [EOL]     int append = sb.length(); [EOL]     for (int i = 0; i < nHexs; i++) { [EOL]         shift = i * 4 + srcPos; [EOL]         final int bits = (int) (0xF & (src >> shift)); [EOL]         if (dstPos + i == append) { [EOL]             ++append; [EOL]             sb.append(intToHexDigit(bits)); [EOL]         } else { [EOL]             sb.setCharAt(dstPos + i, intToHexDigit(bits)); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] } 
 [LINE] ++append; [LINE] public static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) { [EOL]     if (0 == nHexs) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nHexs - 1) * 4 + srcPos >= 32) { [EOL]         throw new IllegalArgumentException("(nHexs-1)*4+srcPos is greather or equal to than 32"); [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(dstInit); [EOL]     int shift = 0; [EOL]     int append = sb.length(); [EOL]     for (int i = 0; i < nHexs; i++) { [EOL]         shift = i * 4 + srcPos; [EOL]         final int bits = 0xF & (src >> shift); [EOL]         if (dstPos + i == append) { [EOL]             ++append; [EOL]             sb.append(intToHexDigit(bits)); [EOL]         } else { [EOL]             sb.setCharAt(dstPos + i, intToHexDigit(bits)); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] } 
 [LINE] sb.append(intToHexDigit(bits)); [LINE] public static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) { [EOL]     if (0 == nHexs) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nHexs - 1) * 4 + srcPos >= 32) { [EOL]         throw new IllegalArgumentException("(nHexs-1)*4+srcPos is greather or equal to than 32"); [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(dstInit); [EOL]     int shift = 0; [EOL]     int append = sb.length(); [EOL]     for (int i = 0; i < nHexs; i++) { [EOL]         shift = i * 4 + srcPos; [EOL]         final int bits = 0xF & (src >> shift); [EOL]         if (dstPos + i == append) { [EOL]             ++append; [EOL]             sb.append(intToHexDigit(bits)); [EOL]         } else { [EOL]             sb.setCharAt(dstPos + i, intToHexDigit(bits)); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] } 
 [LINE] shift = i * 4 + srcPos; [LINE] public static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) { [EOL]     if (0 == nHexs) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nHexs - 1) * 4 + srcPos >= 16) { [EOL]         throw new IllegalArgumentException("(nHexs-1)*4+srcPos is greather or equal to than 16"); [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(dstInit); [EOL]     int shift = 0; [EOL]     int append = sb.length(); [EOL]     for (int i = 0; i < nHexs; i++) { [EOL]         shift = i * 4 + srcPos; [EOL]         final int bits = 0xF & (src >> shift); [EOL]         if (dstPos + i == append) { [EOL]             ++append; [EOL]             sb.append(intToHexDigit(bits)); [EOL]         } else { [EOL]             sb.setCharAt(dstPos + i, intToHexDigit(bits)); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] } 
 [LINE] final int bits = 0xF & (src >> shift); [LINE] public static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) { [EOL]     if (0 == nHexs) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nHexs - 1) * 4 + srcPos >= 16) { [EOL]         throw new IllegalArgumentException("(nHexs-1)*4+srcPos is greather or equal to than 16"); [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(dstInit); [EOL]     int shift = 0; [EOL]     int append = sb.length(); [EOL]     for (int i = 0; i < nHexs; i++) { [EOL]         shift = i * 4 + srcPos; [EOL]         final int bits = 0xF & (src >> shift); [EOL]         if (dstPos + i == append) { [EOL]             ++append; [EOL]             sb.append(intToHexDigit(bits)); [EOL]         } else { [EOL]             sb.setCharAt(dstPos + i, intToHexDigit(bits)); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] } 
 [LINE] if (dstPos + i == append) { [LINE] public static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) { [EOL]     if (0 == nHexs) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nHexs - 1) * 4 + srcPos >= 16) { [EOL]         throw new IllegalArgumentException("(nHexs-1)*4+srcPos is greather or equal to than 16"); [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(dstInit); [EOL]     int shift = 0; [EOL]     int append = sb.length(); [EOL]     for (int i = 0; i < nHexs; i++) { [EOL]         shift = i * 4 + srcPos; [EOL]         final int bits = 0xF & (src >> shift); [EOL]         if (dstPos + i == append) { [EOL]             ++append; [EOL]             sb.append(intToHexDigit(bits)); [EOL]         } else { [EOL]             sb.setCharAt(dstPos + i, intToHexDigit(bits)); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] } 
 [LINE] ++append; [LINE] public static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) { [EOL]     if (0 == nHexs) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nHexs - 1) * 4 + srcPos >= 16) { [EOL]         throw new IllegalArgumentException("(nHexs-1)*4+srcPos is greather or equal to than 16"); [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(dstInit); [EOL]     int shift = 0; [EOL]     int append = sb.length(); [EOL]     for (int i = 0; i < nHexs; i++) { [EOL]         shift = i * 4 + srcPos; [EOL]         final int bits = 0xF & (src >> shift); [EOL]         if (dstPos + i == append) { [EOL]             ++append; [EOL]             sb.append(intToHexDigit(bits)); [EOL]         } else { [EOL]             sb.setCharAt(dstPos + i, intToHexDigit(bits)); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] } 
 [LINE] sb.append(intToHexDigit(bits)); [LINE] public static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) { [EOL]     if (0 == nHexs) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nHexs - 1) * 4 + srcPos >= 16) { [EOL]         throw new IllegalArgumentException("(nHexs-1)*4+srcPos is greather or equal to than 16"); [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(dstInit); [EOL]     int shift = 0; [EOL]     int append = sb.length(); [EOL]     for (int i = 0; i < nHexs; i++) { [EOL]         shift = i * 4 + srcPos; [EOL]         final int bits = 0xF & (src >> shift); [EOL]         if (dstPos + i == append) { [EOL]             ++append; [EOL]             sb.append(intToHexDigit(bits)); [EOL]         } else { [EOL]             sb.setCharAt(dstPos + i, intToHexDigit(bits)); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] } 
 [LINE] sb.setCharAt(dstPos + i, intToHexDigit(bits)); [LINE] public static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) { [EOL]     if (0 == nHexs) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nHexs - 1) * 4 + srcPos >= 16) { [EOL]         throw new IllegalArgumentException("(nHexs-1)*4+srcPos is greather or equal to than 16"); [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(dstInit); [EOL]     int shift = 0; [EOL]     int append = sb.length(); [EOL]     for (int i = 0; i < nHexs; i++) { [EOL]         shift = i * 4 + srcPos; [EOL]         final int bits = 0xF & (src >> shift); [EOL]         if (dstPos + i == append) { [EOL]             ++append; [EOL]             sb.append(intToHexDigit(bits)); [EOL]         } else { [EOL]             sb.setCharAt(dstPos + i, intToHexDigit(bits)); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] } 
 [LINE] ++append; [LINE] public static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) { [EOL]     if (0 == nHexs) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nHexs - 1) * 4 + srcPos >= 8) { [EOL]         throw new IllegalArgumentException("(nHexs-1)*4+srcPos is greather or equal to than 8"); [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(dstInit); [EOL]     int shift = 0; [EOL]     int append = sb.length(); [EOL]     for (int i = 0; i < nHexs; i++) { [EOL]         shift = i * 4 + srcPos; [EOL]         final int bits = 0xF & (src >> shift); [EOL]         if (dstPos + i == append) { [EOL]             ++append; [EOL]             sb.append(intToHexDigit(bits)); [EOL]         } else { [EOL]             sb.setCharAt(dstPos + i, intToHexDigit(bits)); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] } 
 [LINE] sb.append(intToHexDigit(bits)); [LINE] public static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) { [EOL]     if (0 == nHexs) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nHexs - 1) * 4 + srcPos >= 8) { [EOL]         throw new IllegalArgumentException("(nHexs-1)*4+srcPos is greather or equal to than 8"); [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(dstInit); [EOL]     int shift = 0; [EOL]     int append = sb.length(); [EOL]     for (int i = 0; i < nHexs; i++) { [EOL]         shift = i * 4 + srcPos; [EOL]         final int bits = 0xF & (src >> shift); [EOL]         if (dstPos + i == append) { [EOL]             ++append; [EOL]             sb.append(intToHexDigit(bits)); [EOL]         } else { [EOL]             sb.setCharAt(dstPos + i, intToHexDigit(bits)); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] } 
 [LINE] assert ((nBools - 1) * 1 < 16 - srcPos); [LINE] public static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools) { [EOL]     if (0 == nBools) { [EOL]         return dst; [EOL]     } [EOL]     if (nBools - 1 + srcPos >= 16) { [EOL]         throw new IllegalArgumentException("nBools-1+srcPos is greather or equal to than 16"); [EOL]     } [EOL]     int shift = 0; [EOL]     assert ((nBools - 1) * 1 < 16 - srcPos); [EOL]     for (int i = 0; i < nBools; i++) { [EOL]         shift = i * 1 + srcPos; [EOL]         dst[dstPos + i] = ((0x1 & (src >> shift)) != 0); [EOL]     } [EOL]     return dst; [EOL] } 
 [LINE] shift = i * 1 + srcPos; [LINE] public static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools) { [EOL]     if (0 == nBools) { [EOL]         return dst; [EOL]     } [EOL]     if (nBools - 1 + srcPos >= 8) { [EOL]         throw new IllegalArgumentException("nBools-1+srcPos is greather or equal to than 8"); [EOL]     } [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBools; i++) { [EOL]         shift = i * 1 + srcPos; [EOL]         dst[dstPos + i] = ((0x1 & (src >> shift)) != 0); [EOL]     } [EOL]     return dst; [EOL] } 
 [LINE] dst[dstPos + i] = ((0x1 & (src >> shift)) != 0); [LINE] public static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools) { [EOL]     if (0 == nBools) { [EOL]         return dst; [EOL]     } [EOL]     if (nBools - 1 + srcPos >= 8) { [EOL]         throw new IllegalArgumentException("nBools-1+srcPos is greather or equal to than 8"); [EOL]     } [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBools; i++) { [EOL]         shift = i * 1 + srcPos; [EOL]         dst[dstPos + i] = ((0x1 & (src >> shift)) != 0); [EOL]     } [EOL]     return dst; [EOL] } 
 [LINE] longToByteArray(src.getLeastSignificantBits(), 0, dst, dstPos + 8, nBytes - 8); [LINE] public static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes) { [EOL]     if (0 == nBytes) { [EOL]         return dst; [EOL]     } [EOL]     if (nBytes > 16) { [EOL]         throw new IllegalArgumentException("nBytes is greather than 16"); [EOL]     } [EOL]     longToByteArray(src.getMostSignificantBits(), 0, dst, dstPos, nBytes > 8 ? 8 : nBytes); [EOL]     if (nBytes >= 8) { [EOL]         longToByteArray(src.getLeastSignificantBits(), 0, dst, dstPos + 8, nBytes - 8); [EOL]     } [EOL]     return dst; [EOL] } 
 [LINE] private NumericEntityEscaper(final int below, final int above, final boolean between) { [LINE] private NumericEntityEscaper(final int below, final int above, final boolean between) { [EOL]     this.below = below; [EOL]     this.above = above; [EOL]     this.between = between; [EOL] } 
 [LINE] this.below = below; [LINE] private NumericEntityEscaper(final int below, final int above, final boolean between) { [EOL]     this.below = below; [EOL]     this.above = above; [EOL]     this.between = between; [EOL] } 
 [LINE] this.above = above; [LINE] private NumericEntityEscaper(final int below, final int above, final boolean between) { [EOL]     this.below = below; [EOL]     this.above = above; [EOL]     this.between = between; [EOL] } 
 [LINE] this.between = between; [LINE] private NumericEntityEscaper(final int below, final int above, final boolean between) { [EOL]     this.below = below; [EOL]     this.above = above; [EOL]     this.between = between; [EOL] } 
 [LINE] public NumericEntityEscaper() { [LINE] public NumericEntityEscaper() { [EOL]     this(0, Integer.MAX_VALUE, true); [EOL] } 
 [LINE] this(0, Integer.MAX_VALUE, true); [LINE] public NumericEntityEscaper() { [EOL]     this(0, Integer.MAX_VALUE, true); [EOL] } 
 [LINE] public static NumericEntityEscaper below(final int codepoint) { [LINE] public static NumericEntityEscaper below(final int codepoint) { [EOL]     return outsideOf(codepoint, Integer.MAX_VALUE); [EOL] } 
 [LINE] return outsideOf(codepoint, Integer.MAX_VALUE); [LINE] public static NumericEntityEscaper below(final int codepoint) { [EOL]     return outsideOf(codepoint, Integer.MAX_VALUE); [EOL] } 
 [LINE] public static NumericEntityEscaper above(final int codepoint) { [LINE] public static NumericEntityEscaper above(final int codepoint) { [EOL]     return outsideOf(0, codepoint); [EOL] } 
 [LINE] return outsideOf(0, codepoint); [LINE] public static NumericEntityEscaper above(final int codepoint) { [EOL]     return outsideOf(0, codepoint); [EOL] } 
 [LINE] public static NumericEntityEscaper between(final int codepointLow, final int codepointHigh) { [LINE] public static NumericEntityEscaper between(final int codepointLow, final int codepointHigh) { [EOL]     return new NumericEntityEscaper(codepointLow, codepointHigh, true); [EOL] } 
 [LINE] return new NumericEntityEscaper(codepointLow, codepointHigh, true); [LINE] public static NumericEntityEscaper between(final int codepointLow, final int codepointHigh) { [EOL]     return new NumericEntityEscaper(codepointLow, codepointHigh, true); [EOL] } 
 [LINE] public static NumericEntityEscaper outsideOf(final int codepointLow, final int codepointHigh) { [LINE] public static NumericEntityEscaper outsideOf(final int codepointLow, final int codepointHigh) { [EOL]     return new NumericEntityEscaper(codepointLow, codepointHigh, false); [EOL] } 
 [LINE] return new NumericEntityEscaper(codepointLow, codepointHigh, false); [LINE] public static NumericEntityEscaper outsideOf(final int codepointLow, final int codepointHigh) { [EOL]     return new NumericEntityEscaper(codepointLow, codepointHigh, false); [EOL] } 
 [LINE] @Override [LINE] @Override [EOL] public boolean translate(final int codepoint, final Writer out) throws IOException { [EOL]     if (between) { [EOL]         if (codepoint < below || codepoint > above) { [EOL]             return false; [EOL]         } [EOL]     } else { [EOL]         if (codepoint >= below && codepoint <= above) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     out.write("&#"); [EOL]     out.write(Integer.toString(codepoint, 10)); [EOL]     out.write(';'); [EOL]     return true; [EOL] } 
 [LINE] if(between) { [LINE] @Override [EOL] public boolean translate(final int codepoint, final Writer out) throws IOException { [EOL]     if (between) { [EOL]         if (codepoint < below || codepoint > above) { [EOL]             return false; [EOL]         } [EOL]     } else { [EOL]         if (codepoint >= below && codepoint <= above) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     out.write("&#"); [EOL]     out.write(Integer.toString(codepoint, 10)); [EOL]     out.write(';'); [EOL]     return true; [EOL] } 
 [LINE] if (codepoint < below || codepoint > above) { [LINE] @Override [EOL] public boolean translate(final int codepoint, final Writer out) throws IOException { [EOL]     if (between) { [EOL]         if (codepoint < below || codepoint > above) { [EOL]             return false; [EOL]         } [EOL]     } else { [EOL]         if (codepoint >= below && codepoint <= above) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     out.write("&#"); [EOL]     out.write(Integer.toString(codepoint, 10)); [EOL]     out.write(';'); [EOL]     return true; [EOL] } 
 [LINE] return false; [LINE] @Override [EOL] public boolean translate(final int codepoint, final Writer out) throws IOException { [EOL]     if (between) { [EOL]         if (codepoint < below || codepoint > above) { [EOL]             return false; [EOL]         } [EOL]     } else { [EOL]         if (codepoint >= below && codepoint <= above) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     out.write("&#"); [EOL]     out.write(Integer.toString(codepoint, 10)); [EOL]     out.write(';'); [EOL]     return true; [EOL] } 
 [LINE] if (codepoint >= below && codepoint <= above) { [LINE] @Override [EOL] public boolean translate(final int codepoint, final Writer out) throws IOException { [EOL]     if (between) { [EOL]         if (codepoint < below || codepoint > above) { [EOL]             return false; [EOL]         } [EOL]     } else { [EOL]         if (codepoint >= below && codepoint <= above) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     out.write("&#"); [EOL]     out.write(Integer.toString(codepoint, 10)); [EOL]     out.write(';'); [EOL]     return true; [EOL] } 
 [LINE] return false; [LINE] @Override [EOL] public boolean translate(final int codepoint, final Writer out) throws IOException { [EOL]     if (between) { [EOL]         if (codepoint < below || codepoint > above) { [EOL]             return false; [EOL]         } [EOL]     } else { [EOL]         if (codepoint >= below && codepoint <= above) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     out.write("&#"); [EOL]     out.write(Integer.toString(codepoint, 10)); [EOL]     out.write(';'); [EOL]     return true; [EOL] } 
 [LINE] out.write("&#"); [LINE] @Override [EOL] public boolean translate(final int codepoint, final Writer out) throws IOException { [EOL]     if (between) { [EOL]         if (codepoint < below || codepoint > above) { [EOL]             return false; [EOL]         } [EOL]     } else { [EOL]         if (codepoint >= below && codepoint <= above) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     out.write("&#"); [EOL]     out.write(Integer.toString(codepoint, 10)); [EOL]     out.write(';'); [EOL]     return true; [EOL] } 
 [LINE] out.write(Integer.toString(codepoint, 10)); [LINE] @Override [EOL] public boolean translate(final int codepoint, final Writer out) throws IOException { [EOL]     if (between) { [EOL]         if (codepoint < below || codepoint > above) { [EOL]             return false; [EOL]         } [EOL]     } else { [EOL]         if (codepoint >= below && codepoint <= above) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     out.write("&#"); [EOL]     out.write(Integer.toString(codepoint, 10)); [EOL]     out.write(';'); [EOL]     return true; [EOL] } 
 [LINE] out.write(';'); [LINE] @Override [EOL] public boolean translate(final int codepoint, final Writer out) throws IOException { [EOL]     if (between) { [EOL]         if (codepoint < below || codepoint > above) { [EOL]             return false; [EOL]         } [EOL]     } else { [EOL]         if (codepoint >= below && codepoint <= above) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     out.write("&#"); [EOL]     out.write(Integer.toString(codepoint, 10)); [EOL]     out.write(';'); [EOL]     return true; [EOL] } 
 [LINE] return true; [LINE] @Override [EOL] public boolean translate(final int codepoint, final Writer out) throws IOException { [EOL]     if (between) { [EOL]         if (codepoint < below || codepoint > above) { [EOL]             return false; [EOL]         } [EOL]     } else { [EOL]         if (codepoint >= below && codepoint <= above) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     out.write("&#"); [EOL]     out.write(Integer.toString(codepoint, 10)); [EOL]     out.write(';'); [EOL]     return true; [EOL] } 
 [LINE] throw new NullPointerException("Cannot get the toString of a null identity"); [LINE] public static void identityToString(final Appendable appendable, final Object object) throws IOException { [EOL]     if (object == null) { [EOL]         throw new NullPointerException("Cannot get the toString of a null identity"); [EOL]     } [EOL]     appendable.append(object.getClass().getName()).append('@').append(Integer.toHexString(System.identityHashCode(object))); [EOL] } 
 [LINE] throw new NullPointerException("Cannot get the toString of a null identity"); [LINE] public static void identityToString(final StringBuilder builder, final Object object) { [EOL]     if (object == null) { [EOL]         throw new NullPointerException("Cannot get the toString of a null identity"); [EOL]     } [EOL]     builder.append(object.getClass().getName()).append('@').append(Integer.toHexString(System.identityHashCode(object))); [EOL] } 
 [LINE] result = value; [LINE] public static <T extends Comparable<? super T>> T min(final T... values) { [EOL]     T result = null; [EOL]     if (values != null) { [EOL]         for (final T value : values) { [EOL]             if (compare(value, result, true) < 0) { [EOL]                 result = value; [EOL]             } [EOL]         } [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] result = value; [LINE] public static <T extends Comparable<? super T>> T max(final T... values) { [EOL]     T result = null; [EOL]     if (values != null) { [EOL]         for (final T value : values) { [EOL]             if (compare(value, result, false) > 0) { [EOL]                 result = value; [EOL]             } [EOL]         } [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] final Class<?> componentType = obj.getClass().getComponentType(); [LINE] public static <T> T clone(final T obj) { [EOL]     if (obj instanceof Cloneable) { [EOL]         final Object result; [EOL]         if (obj.getClass().isArray()) { [EOL]             final Class<?> componentType = obj.getClass().getComponentType(); [EOL]             if (!componentType.isPrimitive()) { [EOL]                 result = ((Object[]) obj).clone(); [EOL]             } else { [EOL]                 int length = Array.getLength(obj); [EOL]                 result = Array.newInstance(componentType, length); [EOL]                 while (length-- > 0) { [EOL]                     Array.set(result, length, Array.get(obj, length)); [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             try { [EOL]                 final Method clone = obj.getClass().getMethod("clone"); [EOL]                 result = clone.invoke(obj); [EOL]             } catch (final NoSuchMethodException e) { [EOL]                 throw new CloneFailedException("Cloneable type " + obj.getClass().getName() + " has no clone method", e); [EOL]             } catch (final IllegalAccessException e) { [EOL]                 throw new CloneFailedException("Cannot clone Cloneable type " + obj.getClass().getName(), e); [EOL]             } catch (final InvocationTargetException e) { [EOL]                 throw new CloneFailedException("Exception cloning Cloneable type " + obj.getClass().getName(), e.getCause()); [EOL]             } [EOL]         } [EOL]         @SuppressWarnings("unchecked") [EOL]         final T checked = (T) result; [EOL]         return checked; [EOL]     } [EOL]     return null; [EOL] } 
 [LINE] if (!componentType.isPrimitive()) { [LINE] public static <T> T clone(final T obj) { [EOL]     if (obj instanceof Cloneable) { [EOL]         final Object result; [EOL]         if (obj.getClass().isArray()) { [EOL]             final Class<?> componentType = obj.getClass().getComponentType(); [EOL]             if (!componentType.isPrimitive()) { [EOL]                 result = ((Object[]) obj).clone(); [EOL]             } else { [EOL]                 int length = Array.getLength(obj); [EOL]                 result = Array.newInstance(componentType, length); [EOL]                 while (length-- > 0) { [EOL]                     Array.set(result, length, Array.get(obj, length)); [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             try { [EOL]                 final Method clone = obj.getClass().getMethod("clone"); [EOL]                 result = clone.invoke(obj); [EOL]             } catch (final NoSuchMethodException e) { [EOL]                 throw new CloneFailedException("Cloneable type " + obj.getClass().getName() + " has no clone method", e); [EOL]             } catch (final IllegalAccessException e) { [EOL]                 throw new CloneFailedException("Cannot clone Cloneable type " + obj.getClass().getName(), e); [EOL]             } catch (final InvocationTargetException e) { [EOL]                 throw new CloneFailedException("Exception cloning Cloneable type " + obj.getClass().getName(), e.getCause()); [EOL]             } [EOL]         } [EOL]         @SuppressWarnings("unchecked") [EOL]         final T checked = (T) result; [EOL]         return checked; [EOL]     } [EOL]     return null; [EOL] } 
 [LINE] result = ((Object[]) obj).clone(); [LINE] public static <T> T clone(final T obj) { [EOL]     if (obj instanceof Cloneable) { [EOL]         final Object result; [EOL]         if (obj.getClass().isArray()) { [EOL]             final Class<?> componentType = obj.getClass().getComponentType(); [EOL]             if (!componentType.isPrimitive()) { [EOL]                 result = ((Object[]) obj).clone(); [EOL]             } else { [EOL]                 int length = Array.getLength(obj); [EOL]                 result = Array.newInstance(componentType, length); [EOL]                 while (length-- > 0) { [EOL]                     Array.set(result, length, Array.get(obj, length)); [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             try { [EOL]                 final Method clone = obj.getClass().getMethod("clone"); [EOL]                 result = clone.invoke(obj); [EOL]             } catch (final NoSuchMethodException e) { [EOL]                 throw new CloneFailedException("Cloneable type " + obj.getClass().getName() + " has no clone method", e); [EOL]             } catch (final IllegalAccessException e) { [EOL]                 throw new CloneFailedException("Cannot clone Cloneable type " + obj.getClass().getName(), e); [EOL]             } catch (final InvocationTargetException e) { [EOL]                 throw new CloneFailedException("Exception cloning Cloneable type " + obj.getClass().getName(), e.getCause()); [EOL]             } [EOL]         } [EOL]         @SuppressWarnings("unchecked") [EOL]         final T checked = (T) result; [EOL]         return checked; [EOL]     } [EOL]     return null; [EOL] } 
 [LINE] int length = Array.getLength(obj); [LINE] public static <T> T clone(final T obj) { [EOL]     if (obj instanceof Cloneable) { [EOL]         final Object result; [EOL]         if (obj.getClass().isArray()) { [EOL]             final Class<?> componentType = obj.getClass().getComponentType(); [EOL]             if (!componentType.isPrimitive()) { [EOL]                 result = ((Object[]) obj).clone(); [EOL]             } else { [EOL]                 int length = Array.getLength(obj); [EOL]                 result = Array.newInstance(componentType, length); [EOL]                 while (length-- > 0) { [EOL]                     Array.set(result, length, Array.get(obj, length)); [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             try { [EOL]                 final Method clone = obj.getClass().getMethod("clone"); [EOL]                 result = clone.invoke(obj); [EOL]             } catch (final NoSuchMethodException e) { [EOL]                 throw new CloneFailedException("Cloneable type " + obj.getClass().getName() + " has no clone method", e); [EOL]             } catch (final IllegalAccessException e) { [EOL]                 throw new CloneFailedException("Cannot clone Cloneable type " + obj.getClass().getName(), e); [EOL]             } catch (final InvocationTargetException e) { [EOL]                 throw new CloneFailedException("Exception cloning Cloneable type " + obj.getClass().getName(), e.getCause()); [EOL]             } [EOL]         } [EOL]         @SuppressWarnings("unchecked") [EOL]         final T checked = (T) result; [EOL]         return checked; [EOL]     } [EOL]     return null; [EOL] } 
 [LINE] result = Array.newInstance(componentType, length); [LINE] public static <T> T clone(final T obj) { [EOL]     if (obj instanceof Cloneable) { [EOL]         final Object result; [EOL]         if (obj.getClass().isArray()) { [EOL]             final Class<?> componentType = obj.getClass().getComponentType(); [EOL]             if (!componentType.isPrimitive()) { [EOL]                 result = ((Object[]) obj).clone(); [EOL]             } else { [EOL]                 int length = Array.getLength(obj); [EOL]                 result = Array.newInstance(componentType, length); [EOL]                 while (length-- > 0) { [EOL]                     Array.set(result, length, Array.get(obj, length)); [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             try { [EOL]                 final Method clone = obj.getClass().getMethod("clone"); [EOL]                 result = clone.invoke(obj); [EOL]             } catch (final NoSuchMethodException e) { [EOL]                 throw new CloneFailedException("Cloneable type " + obj.getClass().getName() + " has no clone method", e); [EOL]             } catch (final IllegalAccessException e) { [EOL]                 throw new CloneFailedException("Cannot clone Cloneable type " + obj.getClass().getName(), e); [EOL]             } catch (final InvocationTargetException e) { [EOL]                 throw new CloneFailedException("Exception cloning Cloneable type " + obj.getClass().getName(), e.getCause()); [EOL]             } [EOL]         } [EOL]         @SuppressWarnings("unchecked") [EOL]         final T checked = (T) result; [EOL]         return checked; [EOL]     } [EOL]     return null; [EOL] } 
 [LINE] while (length-- > 0) { [LINE] public static <T> T clone(final T obj) { [EOL]     if (obj instanceof Cloneable) { [EOL]         final Object result; [EOL]         if (obj.getClass().isArray()) { [EOL]             final Class<?> componentType = obj.getClass().getComponentType(); [EOL]             if (!componentType.isPrimitive()) { [EOL]                 result = ((Object[]) obj).clone(); [EOL]             } else { [EOL]                 int length = Array.getLength(obj); [EOL]                 result = Array.newInstance(componentType, length); [EOL]                 while (length-- > 0) { [EOL]                     Array.set(result, length, Array.get(obj, length)); [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             try { [EOL]                 final Method clone = obj.getClass().getMethod("clone"); [EOL]                 result = clone.invoke(obj); [EOL]             } catch (final NoSuchMethodException e) { [EOL]                 throw new CloneFailedException("Cloneable type " + obj.getClass().getName() + " has no clone method", e); [EOL]             } catch (final IllegalAccessException e) { [EOL]                 throw new CloneFailedException("Cannot clone Cloneable type " + obj.getClass().getName(), e); [EOL]             } catch (final InvocationTargetException e) { [EOL]                 throw new CloneFailedException("Exception cloning Cloneable type " + obj.getClass().getName(), e.getCause()); [EOL]             } [EOL]         } [EOL]         @SuppressWarnings("unchecked") [EOL]         final T checked = (T) result; [EOL]         return checked; [EOL]     } [EOL]     return null; [EOL] } 
 [LINE] Array.set(result, length, Array.get(obj, length)); [LINE] public static <T> T clone(final T obj) { [EOL]     if (obj instanceof Cloneable) { [EOL]         final Object result; [EOL]         if (obj.getClass().isArray()) { [EOL]             final Class<?> componentType = obj.getClass().getComponentType(); [EOL]             if (!componentType.isPrimitive()) { [EOL]                 result = ((Object[]) obj).clone(); [EOL]             } else { [EOL]                 int length = Array.getLength(obj); [EOL]                 result = Array.newInstance(componentType, length); [EOL]                 while (length-- > 0) { [EOL]                     Array.set(result, length, Array.get(obj, length)); [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             try { [EOL]                 final Method clone = obj.getClass().getMethod("clone"); [EOL]                 result = clone.invoke(obj); [EOL]             } catch (final NoSuchMethodException e) { [EOL]                 throw new CloneFailedException("Cloneable type " + obj.getClass().getName() + " has no clone method", e); [EOL]             } catch (final IllegalAccessException e) { [EOL]                 throw new CloneFailedException("Cannot clone Cloneable type " + obj.getClass().getName(), e); [EOL]             } catch (final InvocationTargetException e) { [EOL]                 throw new CloneFailedException("Exception cloning Cloneable type " + obj.getClass().getName(), e.getCause()); [EOL]             } [EOL]         } [EOL]         @SuppressWarnings("unchecked") [EOL]         final T checked = (T) result; [EOL]         return checked; [EOL]     } [EOL]     return null; [EOL] } 
 [LINE] throw new CloneFailedException("Cloneable type " [LINE] public static <T> T clone(final T obj) { [EOL]     if (obj instanceof Cloneable) { [EOL]         final Object result; [EOL]         if (obj.getClass().isArray()) { [EOL]             final Class<?> componentType = obj.getClass().getComponentType(); [EOL]             if (!componentType.isPrimitive()) { [EOL]                 result = ((Object[]) obj).clone(); [EOL]             } else { [EOL]                 int length = Array.getLength(obj); [EOL]                 result = Array.newInstance(componentType, length); [EOL]                 while (length-- > 0) { [EOL]                     Array.set(result, length, Array.get(obj, length)); [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             try { [EOL]                 final Method clone = obj.getClass().getMethod("clone"); [EOL]                 result = clone.invoke(obj); [EOL]             } catch (final NoSuchMethodException e) { [EOL]                 throw new CloneFailedException("Cloneable type " + obj.getClass().getName() + " has no clone method", e); [EOL]             } catch (final IllegalAccessException e) { [EOL]                 throw new CloneFailedException("Cannot clone Cloneable type " + obj.getClass().getName(), e); [EOL]             } catch (final InvocationTargetException e) { [EOL]                 throw new CloneFailedException("Exception cloning Cloneable type " + obj.getClass().getName(), e.getCause()); [EOL]             } [EOL]         } [EOL]         @SuppressWarnings("unchecked") [EOL]         final T checked = (T) result; [EOL]         return checked; [EOL]     } [EOL]     return null; [EOL] } 
 [LINE] private Object readResolve() { [LINE] private Object readResolve() { [EOL]     return ObjectUtils.NULL; [EOL] } 
 [LINE] return ObjectUtils.NULL; [LINE] private Object readResolve() { [EOL]     return ObjectUtils.NULL; [EOL] } 
 [LINE] frames.add(trace.get(j)); [LINE] public static String[] getRootCauseStackTrace(final Throwable throwable) { [EOL]     if (throwable == null) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final Throwable[] throwables = getThrowables(throwable); [EOL]     final int count = throwables.length; [EOL]     final List<String> frames = new ArrayList<String>(); [EOL]     List<String> nextTrace = getStackFrameList(throwables[count - 1]); [EOL]     for (int i = count; --i >= 0; ) { [EOL]         final List<String> trace = nextTrace; [EOL]         if (i != 0) { [EOL]             nextTrace = getStackFrameList(throwables[i - 1]); [EOL]             removeCommonFrames(trace, nextTrace); [EOL]         } [EOL]         if (i == count - 1) { [EOL]             frames.add(throwables[i].toString()); [EOL]         } else { [EOL]             frames.add(WRAPPED_MARKER + throwables[i].toString()); [EOL]         } [EOL]         for (int j = 0; j < trace.size(); j++) { [EOL]             frames.add(trace.get(j)); [EOL]         } [EOL]     } [EOL]     return frames.toArray(new String[frames.size()]); [EOL] } 
 [LINE] traceStarted = true; [LINE] static List<String> getStackFrameList(final Throwable t) { [EOL]     final String stackTrace = getStackTrace(t); [EOL]     final String linebreak = SystemUtils.LINE_SEPARATOR; [EOL]     final StringTokenizer frames = new StringTokenizer(stackTrace, linebreak); [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     boolean traceStarted = false; [EOL]     while (frames.hasMoreTokens()) { [EOL]         final String token = frames.nextToken(); [EOL]         final int at = token.indexOf("at"); [EOL]         if (at != -1 && token.substring(0, at).trim().isEmpty()) { [EOL]             traceStarted = true; [EOL]             list.add(token); [EOL]         } else if (traceStarted) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     return list; [EOL] } 
 [LINE] list.add(token); [LINE] static List<String> getStackFrameList(final Throwable t) { [EOL]     final String stackTrace = getStackTrace(t); [EOL]     final String linebreak = SystemUtils.LINE_SEPARATOR; [EOL]     final StringTokenizer frames = new StringTokenizer(stackTrace, linebreak); [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     boolean traceStarted = false; [EOL]     while (frames.hasMoreTokens()) { [EOL]         final String token = frames.nextToken(); [EOL]         final int at = token.indexOf("at"); [EOL]         if (at != -1 && token.substring(0, at).trim().isEmpty()) { [EOL]             traceStarted = true; [EOL]             list.add(token); [EOL]         } else if (traceStarted) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     return list; [EOL] } 
 [LINE] break; [LINE] static List<String> getStackFrameList(final Throwable t) { [EOL]     final String stackTrace = getStackTrace(t); [EOL]     final String linebreak = SystemUtils.LINE_SEPARATOR; [EOL]     final StringTokenizer frames = new StringTokenizer(stackTrace, linebreak); [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     boolean traceStarted = false; [EOL]     while (frames.hasMoreTokens()) { [EOL]         final String token = frames.nextToken(); [EOL]         final int at = token.indexOf("at"); [EOL]         if (at != -1 && token.substring(0, at).trim().isEmpty()) { [EOL]             traceStarted = true; [EOL]             list.add(token); [EOL]         } else if (traceStarted) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     return list; [EOL] } 
 [LINE] @Override [LINE] @Override [EOL] protected String toUtf16Escape(final int codepoint) { [EOL]     final char[] surrogatePair = Character.toChars(codepoint); [EOL]     return "\\u" + hex(surrogatePair[0]) + "\\u" + hex(surrogatePair[1]); [EOL] } 
 [LINE] final char[] surrogatePair = Character.toChars(codepoint); [LINE] @Override [EOL] protected String toUtf16Escape(final int codepoint) { [EOL]     final char[] surrogatePair = Character.toChars(codepoint); [EOL]     return "\\u" + hex(surrogatePair[0]) + "\\u" + hex(surrogatePair[1]); [EOL] } 
 [LINE] return "\\u" + hex(surrogatePair[0]) + "\\u" + hex(surrogatePair[1]); [LINE] @Override [EOL] protected String toUtf16Escape(final int codepoint) { [EOL]     final char[] surrogatePair = Character.toChars(codepoint); [EOL]     return "\\u" + hex(surrogatePair[0]) + "\\u" + hex(surrogatePair[1]); [EOL] } 
 [LINE] @Override [LINE] @Override [EOL] public TimeZone getTimeZone() { [EOL]     return timeZone; [EOL] } 
 [LINE] return timeZone; [LINE] @Override [EOL] public TimeZone getTimeZone() { [EOL]     return timeZone; [EOL] } 
 [LINE] @Override [LINE] @Override [EOL] public boolean equals(final Object obj) { [EOL]     if (!(obj instanceof FastDateParser)) { [EOL]         return false; [EOL]     } [EOL]     final FastDateParser other = (FastDateParser) obj; [EOL]     return pattern.equals(other.pattern) && timeZone.equals(other.timeZone) && locale.equals(other.locale); [EOL] } 
 [LINE] if (! (obj instanceof FastDateParser) ) { [LINE] @Override [EOL] public boolean equals(final Object obj) { [EOL]     if (!(obj instanceof FastDateParser)) { [EOL]         return false; [EOL]     } [EOL]     final FastDateParser other = (FastDateParser) obj; [EOL]     return pattern.equals(other.pattern) && timeZone.equals(other.timeZone) && locale.equals(other.locale); [EOL] } 
 [LINE] return false; [LINE] @Override [EOL] public boolean equals(final Object obj) { [EOL]     if (!(obj instanceof FastDateParser)) { [EOL]         return false; [EOL]     } [EOL]     final FastDateParser other = (FastDateParser) obj; [EOL]     return pattern.equals(other.pattern) && timeZone.equals(other.timeZone) && locale.equals(other.locale); [EOL] } 
 [LINE] final FastDateParser other = (FastDateParser) obj; [LINE] @Override [EOL] public boolean equals(final Object obj) { [EOL]     if (!(obj instanceof FastDateParser)) { [EOL]         return false; [EOL]     } [EOL]     final FastDateParser other = (FastDateParser) obj; [EOL]     return pattern.equals(other.pattern) && timeZone.equals(other.timeZone) && locale.equals(other.locale); [EOL] } 
 [LINE] return pattern.equals(other.pattern) [LINE] @Override [EOL] public boolean equals(final Object obj) { [EOL]     if (!(obj instanceof FastDateParser)) { [EOL]         return false; [EOL]     } [EOL]     final FastDateParser other = (FastDateParser) obj; [EOL]     return pattern.equals(other.pattern) && timeZone.equals(other.timeZone) && locale.equals(other.locale); [EOL] } 
 [LINE] @Override [LINE] @Override [EOL] public int hashCode() { [EOL]     return pattern.hashCode() + 13 * (timeZone.hashCode() + 13 * locale.hashCode()); [EOL] } 
 [LINE] return pattern.hashCode() + 13 * (timeZone.hashCode() + 13 * locale.hashCode()); [LINE] @Override [EOL] public int hashCode() { [EOL]     return pattern.hashCode() + 13 * (timeZone.hashCode() + 13 * locale.hashCode()); [EOL] } 
 [LINE] private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException { [LINE] private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException { [EOL]     in.defaultReadObject(); [EOL]     init(); [EOL] } 
 [LINE] in.defaultReadObject(); [LINE] private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException { [EOL]     in.defaultReadObject(); [EOL]     init(); [EOL] } 
 [LINE] init(); [LINE] private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException { [EOL]     in.defaultReadObject(); [EOL]     init(); [EOL] } 
 [LINE] case '\\': [LINE] private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote) { [EOL]     regex.append("\\Q"); [EOL]     for (int i = 0; i < value.length(); ++i) { [EOL]         char c = value.charAt(i); [EOL]         switch(c) { [EOL]             case '\'': [EOL]                 if (unquote) { [EOL]                     if (++i == value.length()) { [EOL]                         return regex; [EOL]                     } [EOL]                     c = value.charAt(i); [EOL]                 } [EOL]                 break; [EOL]             case '\\': [EOL]                 if (++i == value.length()) { [EOL]                     break; [EOL]                 } [EOL]                 regex.append(c); [EOL]                 c = value.charAt(i); [EOL]                 if (c == 'E') { [EOL]                     regex.append("E\\\\E\\"); [EOL]                     c = 'Q'; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         regex.append(c); [EOL]     } [EOL]     regex.append("\\E"); [EOL]     return regex; [EOL] } 
 [LINE] if(++i==value.length()) { [LINE] private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote) { [EOL]     regex.append("\\Q"); [EOL]     for (int i = 0; i < value.length(); ++i) { [EOL]         char c = value.charAt(i); [EOL]         switch(c) { [EOL]             case '\'': [EOL]                 if (unquote) { [EOL]                     if (++i == value.length()) { [EOL]                         return regex; [EOL]                     } [EOL]                     c = value.charAt(i); [EOL]                 } [EOL]                 break; [EOL]             case '\\': [EOL]                 if (++i == value.length()) { [EOL]                     break; [EOL]                 } [EOL]                 regex.append(c); [EOL]                 c = value.charAt(i); [EOL]                 if (c == 'E') { [EOL]                     regex.append("E\\\\E\\"); [EOL]                     c = 'Q'; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         regex.append(c); [EOL]     } [EOL]     regex.append("\\E"); [EOL]     return regex; [EOL] } 
 [LINE] regex.append(c); // we always want the original \ [LINE] private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote) { [EOL]     regex.append("\\Q"); [EOL]     for (int i = 0; i < value.length(); ++i) { [EOL]         char c = value.charAt(i); [EOL]         switch(c) { [EOL]             case '\'': [EOL]                 if (unquote) { [EOL]                     if (++i == value.length()) { [EOL]                         return regex; [EOL]                     } [EOL]                     c = value.charAt(i); [EOL]                 } [EOL]                 break; [EOL]             case '\\': [EOL]                 if (++i == value.length()) { [EOL]                     break; [EOL]                 } [EOL]                 regex.append(c); [EOL]                 c = value.charAt(i); [EOL]                 if (c == 'E') { [EOL]                     regex.append("E\\\\E\\"); [EOL]                     c = 'Q'; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         regex.append(c); [EOL]     } [EOL]     regex.append("\\E"); [EOL]     return regex; [EOL] } 
 [LINE] c = value.charAt(i); // Is it followed by E ? [LINE] private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote) { [EOL]     regex.append("\\Q"); [EOL]     for (int i = 0; i < value.length(); ++i) { [EOL]         char c = value.charAt(i); [EOL]         switch(c) { [EOL]             case '\'': [EOL]                 if (unquote) { [EOL]                     if (++i == value.length()) { [EOL]                         return regex; [EOL]                     } [EOL]                     c = value.charAt(i); [EOL]                 } [EOL]                 break; [EOL]             case '\\': [EOL]                 if (++i == value.length()) { [EOL]                     break; [EOL]                 } [EOL]                 regex.append(c); [EOL]                 c = value.charAt(i); [EOL]                 if (c == 'E') { [EOL]                     regex.append("E\\\\E\\"); [EOL]                     c = 'Q'; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         regex.append(c); [EOL]     } [EOL]     regex.append("\\E"); [EOL]     return regex; [EOL] } 
 [LINE] if (c == 'E') { // \E detected [LINE] private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote) { [EOL]     regex.append("\\Q"); [EOL]     for (int i = 0; i < value.length(); ++i) { [EOL]         char c = value.charAt(i); [EOL]         switch(c) { [EOL]             case '\'': [EOL]                 if (unquote) { [EOL]                     if (++i == value.length()) { [EOL]                         return regex; [EOL]                     } [EOL]                     c = value.charAt(i); [EOL]                 } [EOL]                 break; [EOL]             case '\\': [EOL]                 if (++i == value.length()) { [EOL]                     break; [EOL]                 } [EOL]                 regex.append(c); [EOL]                 c = value.charAt(i); [EOL]                 if (c == 'E') { [EOL]                     regex.append("E\\\\E\\"); [EOL]                     c = 'Q'; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         regex.append(c); [EOL]     } [EOL]     regex.append("\\E"); [EOL]     return regex; [EOL] } 
 [LINE] regex.append("E\\\\E\\"); // see comment above [LINE] private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote) { [EOL]     regex.append("\\Q"); [EOL]     for (int i = 0; i < value.length(); ++i) { [EOL]         char c = value.charAt(i); [EOL]         switch(c) { [EOL]             case '\'': [EOL]                 if (unquote) { [EOL]                     if (++i == value.length()) { [EOL]                         return regex; [EOL]                     } [EOL]                     c = value.charAt(i); [EOL]                 } [EOL]                 break; [EOL]             case '\\': [EOL]                 if (++i == value.length()) { [EOL]                     break; [EOL]                 } [EOL]                 regex.append(c); [EOL]                 c = value.charAt(i); [EOL]                 if (c == 'E') { [EOL]                     regex.append("E\\\\E\\"); [EOL]                     c = 'Q'; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         regex.append(c); [EOL]     } [EOL]     regex.append("\\E"); [EOL]     return regex; [EOL] } 
 [LINE] c = 'Q'; // appended below [LINE] private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote) { [EOL]     regex.append("\\Q"); [EOL]     for (int i = 0; i < value.length(); ++i) { [EOL]         char c = value.charAt(i); [EOL]         switch(c) { [EOL]             case '\'': [EOL]                 if (unquote) { [EOL]                     if (++i == value.length()) { [EOL]                         return regex; [EOL]                     } [EOL]                     c = value.charAt(i); [EOL]                 } [EOL]                 break; [EOL]             case '\\': [EOL]                 if (++i == value.length()) { [EOL]                     break; [EOL]                 } [EOL]                 regex.append(c); [EOL]                 c = value.charAt(i); [EOL]                 if (c == 'E') { [EOL]                     regex.append("E\\\\E\\"); [EOL]                     c = 'Q'; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         regex.append(c); [EOL]     } [EOL]     regex.append("\\E"); [EOL]     return regex; [EOL] } 
 [LINE] break; [LINE] private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote) { [EOL]     regex.append("\\Q"); [EOL]     for (int i = 0; i < value.length(); ++i) { [EOL]         char c = value.charAt(i); [EOL]         switch(c) { [EOL]             case '\'': [EOL]                 if (unquote) { [EOL]                     if (++i == value.length()) { [EOL]                         return regex; [EOL]                     } [EOL]                     c = value.charAt(i); [EOL]                 } [EOL]                 break; [EOL]             case '\\': [EOL]                 if (++i == value.length()) { [EOL]                     break; [EOL]                 } [EOL]                 regex.append(c); [EOL]                 c = value.charAt(i); [EOL]                 if (c == 'E') { [EOL]                     regex.append("E\\\\E\\"); [EOL]                     c = 'Q'; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         regex.append(c); [EOL]     } [EOL]     regex.append("\\E"); [EOL]     return regex; [EOL] } 
 [LINE] c= formatField.charAt(1); [LINE] @Override [EOL] boolean isNumber() { [EOL]     char c = formatField.charAt(0); [EOL]     if (c == '\'') { [EOL]         c = formatField.charAt(1); [EOL]     } [EOL]     return Character.isDigit(c); [EOL] } 
 [LINE] @Override [LINE] @Override [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value) { [EOL]     int iValue = Integer.parseInt(value); [EOL]     if (iValue < 100) { [EOL]         iValue = parser.adjustYear(iValue); [EOL]     } [EOL]     cal.set(Calendar.YEAR, iValue); [EOL] } 
 [LINE] int iValue= Integer.parseInt(value); [LINE] @Override [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value) { [EOL]     int iValue = Integer.parseInt(value); [EOL]     if (iValue < 100) { [EOL]         iValue = parser.adjustYear(iValue); [EOL]     } [EOL]     cal.set(Calendar.YEAR, iValue); [EOL] } 
 [LINE] if(iValue<100) { [LINE] @Override [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value) { [EOL]     int iValue = Integer.parseInt(value); [EOL]     if (iValue < 100) { [EOL]         iValue = parser.adjustYear(iValue); [EOL]     } [EOL]     cal.set(Calendar.YEAR, iValue); [EOL] } 
 [LINE] iValue= parser.adjustYear(iValue); [LINE] @Override [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value) { [EOL]     int iValue = Integer.parseInt(value); [EOL]     if (iValue < 100) { [EOL]         iValue = parser.adjustYear(iValue); [EOL]     } [EOL]     cal.set(Calendar.YEAR, iValue); [EOL] } 
 [LINE] cal.set(Calendar.YEAR, iValue); [LINE] @Override [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value) { [EOL]     int iValue = Integer.parseInt(value); [EOL]     if (iValue < 100) { [EOL]         iValue = parser.adjustYear(iValue); [EOL]     } [EOL]     cal.set(Calendar.YEAR, iValue); [EOL] } 
 [LINE] @Override [LINE] @Override [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value) { [EOL]     TimeZone tz; [EOL]     if (value.charAt(0) == '+' || value.charAt(0) == '-') { [EOL]         tz = TimeZone.getTimeZone("GMT" + value); [EOL]     } else if (value.startsWith("GMT")) { [EOL]         tz = TimeZone.getTimeZone(value); [EOL]     } else { [EOL]         tz = tzNames.get(value); [EOL]         if (tz == null) { [EOL]             throw new IllegalArgumentException(value + " is not a supported timezone name"); [EOL]         } [EOL]     } [EOL]     cal.setTimeZone(tz); [EOL] } 
 [LINE] TimeZone tz; [LINE] @Override [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value) { [EOL]     TimeZone tz; [EOL]     if (value.charAt(0) == '+' || value.charAt(0) == '-') { [EOL]         tz = TimeZone.getTimeZone("GMT" + value); [EOL]     } else if (value.startsWith("GMT")) { [EOL]         tz = TimeZone.getTimeZone(value); [EOL]     } else { [EOL]         tz = tzNames.get(value); [EOL]         if (tz == null) { [EOL]             throw new IllegalArgumentException(value + " is not a supported timezone name"); [EOL]         } [EOL]     } [EOL]     cal.setTimeZone(tz); [EOL] } 
 [LINE] if(value.charAt(0)=='+' || value.charAt(0)=='-') { [LINE] @Override [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value) { [EOL]     TimeZone tz; [EOL]     if (value.charAt(0) == '+' || value.charAt(0) == '-') { [EOL]         tz = TimeZone.getTimeZone("GMT" + value); [EOL]     } else if (value.startsWith("GMT")) { [EOL]         tz = TimeZone.getTimeZone(value); [EOL]     } else { [EOL]         tz = tzNames.get(value); [EOL]         if (tz == null) { [EOL]             throw new IllegalArgumentException(value + " is not a supported timezone name"); [EOL]         } [EOL]     } [EOL]     cal.setTimeZone(tz); [EOL] } 
 [LINE] tz= TimeZone.getTimeZone("GMT"+value); [LINE] @Override [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value) { [EOL]     TimeZone tz; [EOL]     if (value.charAt(0) == '+' || value.charAt(0) == '-') { [EOL]         tz = TimeZone.getTimeZone("GMT" + value); [EOL]     } else if (value.startsWith("GMT")) { [EOL]         tz = TimeZone.getTimeZone(value); [EOL]     } else { [EOL]         tz = tzNames.get(value); [EOL]         if (tz == null) { [EOL]             throw new IllegalArgumentException(value + " is not a supported timezone name"); [EOL]         } [EOL]     } [EOL]     cal.setTimeZone(tz); [EOL] } 
 [LINE] else if(value.startsWith("GMT")) { [LINE] @Override [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value) { [EOL]     TimeZone tz; [EOL]     if (value.charAt(0) == '+' || value.charAt(0) == '-') { [EOL]         tz = TimeZone.getTimeZone("GMT" + value); [EOL]     } else if (value.startsWith("GMT")) { [EOL]         tz = TimeZone.getTimeZone(value); [EOL]     } else { [EOL]         tz = tzNames.get(value); [EOL]         if (tz == null) { [EOL]             throw new IllegalArgumentException(value + " is not a supported timezone name"); [EOL]         } [EOL]     } [EOL]     cal.setTimeZone(tz); [EOL] } 
 [LINE] tz= TimeZone.getTimeZone(value); [LINE] @Override [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value) { [EOL]     TimeZone tz; [EOL]     if (value.charAt(0) == '+' || value.charAt(0) == '-') { [EOL]         tz = TimeZone.getTimeZone("GMT" + value); [EOL]     } else if (value.startsWith("GMT")) { [EOL]         tz = TimeZone.getTimeZone(value); [EOL]     } else { [EOL]         tz = tzNames.get(value); [EOL]         if (tz == null) { [EOL]             throw new IllegalArgumentException(value + " is not a supported timezone name"); [EOL]         } [EOL]     } [EOL]     cal.setTimeZone(tz); [EOL] } 
 [LINE] cal.setTimeZone(tz); [LINE] @Override [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value) { [EOL]     TimeZone tz; [EOL]     if (value.charAt(0) == '+' || value.charAt(0) == '-') { [EOL]         tz = TimeZone.getTimeZone("GMT" + value); [EOL]     } else if (value.startsWith("GMT")) { [EOL]         tz = TimeZone.getTimeZone(value); [EOL]     } else { [EOL]         tz = tzNames.get(value); [EOL]         if (tz == null) { [EOL]             throw new IllegalArgumentException(value + " is not a supported timezone name"); [EOL]         } [EOL]     } [EOL]     cal.setTimeZone(tz); [EOL] } 
 [LINE] @Override [LINE] @Override [EOL] int modify(final int iValue) { [EOL]     return iValue % 24; [EOL] } 
 [LINE] return iValue%24; [LINE] @Override [EOL] int modify(final int iValue) { [EOL]     return iValue % 24; [EOL] } 
 [LINE] @Override [LINE] @Override [EOL] int modify(final int iValue) { [EOL]     return iValue % 12; [EOL] } 
 [LINE] return iValue%12; [LINE] @Override [EOL] int modify(final int iValue) { [EOL]     return iValue % 12; [EOL] } 
 [LINE] valueStr = "Exception thrown on toString(): " + ExceptionUtils.getStackTrace(e); [LINE] @Override [EOL] public String getFormattedExceptionMessage(final String baseMessage) { [EOL]     final StringBuilder buffer = new StringBuilder(256); [EOL]     if (baseMessage != null) { [EOL]         buffer.append(baseMessage); [EOL]     } [EOL]     if (contextValues.size() > 0) { [EOL]         if (buffer.length() > 0) { [EOL]             buffer.append('\n'); [EOL]         } [EOL]         buffer.append("Exception Context:\n"); [EOL]         int i = 0; [EOL]         for (final Pair<String, Object> pair : contextValues) { [EOL]             buffer.append("\t["); [EOL]             buffer.append(++i); [EOL]             buffer.append(':'); [EOL]             buffer.append(pair.getKey()); [EOL]             buffer.append("="); [EOL]             final Object value = pair.getValue(); [EOL]             if (value == null) { [EOL]                 buffer.append("null"); [EOL]             } else { [EOL]                 String valueStr; [EOL]                 try { [EOL]                     valueStr = value.toString(); [EOL]                 } catch (final Exception e) { [EOL]                     valueStr = "Exception thrown on toString(): " + ExceptionUtils.getStackTrace(e); [EOL]                 } [EOL]                 buffer.append(valueStr); [EOL]             } [EOL]             buffer.append("]\n"); [EOL]         } [EOL]         buffer.append("---------------------------------"); [EOL]     } [EOL]     return buffer.toString(); [EOL] } 
 [LINE] i++; [LINE] @Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     if (input.charAt(index) == '\\' && index + 1 < input.length() && input.charAt(index + 1) == 'u') { [EOL]         int i = 2; [EOL]         while (index + i < input.length() && input.charAt(index + i) == 'u') { [EOL]             i++; [EOL]         } [EOL]         if (index + i < input.length() && input.charAt(index + i) == '+') { [EOL]             i++; [EOL]         } [EOL]         if (index + i + 4 <= input.length()) { [EOL]             final CharSequence unicode = input.subSequence(index + i, index + i + 4); [EOL]             try { [EOL]                 final int value = Integer.parseInt(unicode.toString(), 16); [EOL]                 out.write((char) value); [EOL]             } catch (final NumberFormatException nfe) { [EOL]                 throw new IllegalArgumentException("Unable to parse unicode value: " + unicode, nfe); [EOL]             } [EOL]             return i + 4; [EOL]         } else { [EOL]             throw new IllegalArgumentException("Less than 4 hex digits in unicode value: '" + input.subSequence(index, input.length()) + "' due to end of CharSequence"); [EOL]         } [EOL]     } [EOL]     return 0; [EOL] } 
 [LINE] i++; [LINE] @Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     if (input.charAt(index) == '\\' && index + 1 < input.length() && input.charAt(index + 1) == 'u') { [EOL]         int i = 2; [EOL]         while (index + i < input.length() && input.charAt(index + i) == 'u') { [EOL]             i++; [EOL]         } [EOL]         if (index + i < input.length() && input.charAt(index + i) == '+') { [EOL]             i++; [EOL]         } [EOL]         if (index + i + 4 <= input.length()) { [EOL]             final CharSequence unicode = input.subSequence(index + i, index + i + 4); [EOL]             try { [EOL]                 final int value = Integer.parseInt(unicode.toString(), 16); [EOL]                 out.write((char) value); [EOL]             } catch (final NumberFormatException nfe) { [EOL]                 throw new IllegalArgumentException("Unable to parse unicode value: " + unicode, nfe); [EOL]             } [EOL]             return i + 4; [EOL]         } else { [EOL]             throw new IllegalArgumentException("Less than 4 hex digits in unicode value: '" + input.subSequence(index, input.length()) + "' due to end of CharSequence"); [EOL]         } [EOL]     } [EOL]     return 0; [EOL] } 
 [LINE] final CharSequence unicode = input.subSequence(index + i, index + i + 4); [LINE] @Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     if (input.charAt(index) == '\\' && index + 1 < input.length() && input.charAt(index + 1) == 'u') { [EOL]         int i = 2; [EOL]         while (index + i < input.length() && input.charAt(index + i) == 'u') { [EOL]             i++; [EOL]         } [EOL]         if (index + i < input.length() && input.charAt(index + i) == '+') { [EOL]             i++; [EOL]         } [EOL]         if (index + i + 4 <= input.length()) { [EOL]             final CharSequence unicode = input.subSequence(index + i, index + i + 4); [EOL]             try { [EOL]                 final int value = Integer.parseInt(unicode.toString(), 16); [EOL]                 out.write((char) value); [EOL]             } catch (final NumberFormatException nfe) { [EOL]                 throw new IllegalArgumentException("Unable to parse unicode value: " + unicode, nfe); [EOL]             } [EOL]             return i + 4; [EOL]         } else { [EOL]             throw new IllegalArgumentException("Less than 4 hex digits in unicode value: '" + input.subSequence(index, input.length()) + "' due to end of CharSequence"); [EOL]         } [EOL]     } [EOL]     return 0; [EOL] } 
 [LINE] try { [LINE] @Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     if (input.charAt(index) == '\\' && index + 1 < input.length() && input.charAt(index + 1) == 'u') { [EOL]         int i = 2; [EOL]         while (index + i < input.length() && input.charAt(index + i) == 'u') { [EOL]             i++; [EOL]         } [EOL]         if (index + i < input.length() && input.charAt(index + i) == '+') { [EOL]             i++; [EOL]         } [EOL]         if (index + i + 4 <= input.length()) { [EOL]             final CharSequence unicode = input.subSequence(index + i, index + i + 4); [EOL]             try { [EOL]                 final int value = Integer.parseInt(unicode.toString(), 16); [EOL]                 out.write((char) value); [EOL]             } catch (final NumberFormatException nfe) { [EOL]                 throw new IllegalArgumentException("Unable to parse unicode value: " + unicode, nfe); [EOL]             } [EOL]             return i + 4; [EOL]         } else { [EOL]             throw new IllegalArgumentException("Less than 4 hex digits in unicode value: '" + input.subSequence(index, input.length()) + "' due to end of CharSequence"); [EOL]         } [EOL]     } [EOL]     return 0; [EOL] } 
 [LINE] final int value = Integer.parseInt(unicode.toString(), 16); [LINE] @Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     if (input.charAt(index) == '\\' && index + 1 < input.length() && input.charAt(index + 1) == 'u') { [EOL]         int i = 2; [EOL]         while (index + i < input.length() && input.charAt(index + i) == 'u') { [EOL]             i++; [EOL]         } [EOL]         if (index + i < input.length() && input.charAt(index + i) == '+') { [EOL]             i++; [EOL]         } [EOL]         if (index + i + 4 <= input.length()) { [EOL]             final CharSequence unicode = input.subSequence(index + i, index + i + 4); [EOL]             try { [EOL]                 final int value = Integer.parseInt(unicode.toString(), 16); [EOL]                 out.write((char) value); [EOL]             } catch (final NumberFormatException nfe) { [EOL]                 throw new IllegalArgumentException("Unable to parse unicode value: " + unicode, nfe); [EOL]             } [EOL]             return i + 4; [EOL]         } else { [EOL]             throw new IllegalArgumentException("Less than 4 hex digits in unicode value: '" + input.subSequence(index, input.length()) + "' due to end of CharSequence"); [EOL]         } [EOL]     } [EOL]     return 0; [EOL] } 
 [LINE] out.write((char) value); [LINE] @Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     if (input.charAt(index) == '\\' && index + 1 < input.length() && input.charAt(index + 1) == 'u') { [EOL]         int i = 2; [EOL]         while (index + i < input.length() && input.charAt(index + i) == 'u') { [EOL]             i++; [EOL]         } [EOL]         if (index + i < input.length() && input.charAt(index + i) == '+') { [EOL]             i++; [EOL]         } [EOL]         if (index + i + 4 <= input.length()) { [EOL]             final CharSequence unicode = input.subSequence(index + i, index + i + 4); [EOL]             try { [EOL]                 final int value = Integer.parseInt(unicode.toString(), 16); [EOL]                 out.write((char) value); [EOL]             } catch (final NumberFormatException nfe) { [EOL]                 throw new IllegalArgumentException("Unable to parse unicode value: " + unicode, nfe); [EOL]             } [EOL]             return i + 4; [EOL]         } else { [EOL]             throw new IllegalArgumentException("Less than 4 hex digits in unicode value: '" + input.subSequence(index, input.length()) + "' due to end of CharSequence"); [EOL]         } [EOL]     } [EOL]     return 0; [EOL] } 
 [LINE] throw new IllegalArgumentException("Unable to parse unicode value: " + unicode, nfe); [LINE] @Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     if (input.charAt(index) == '\\' && index + 1 < input.length() && input.charAt(index + 1) == 'u') { [EOL]         int i = 2; [EOL]         while (index + i < input.length() && input.charAt(index + i) == 'u') { [EOL]             i++; [EOL]         } [EOL]         if (index + i < input.length() && input.charAt(index + i) == '+') { [EOL]             i++; [EOL]         } [EOL]         if (index + i + 4 <= input.length()) { [EOL]             final CharSequence unicode = input.subSequence(index + i, index + i + 4); [EOL]             try { [EOL]                 final int value = Integer.parseInt(unicode.toString(), 16); [EOL]                 out.write((char) value); [EOL]             } catch (final NumberFormatException nfe) { [EOL]                 throw new IllegalArgumentException("Unable to parse unicode value: " + unicode, nfe); [EOL]             } [EOL]             return i + 4; [EOL]         } else { [EOL]             throw new IllegalArgumentException("Less than 4 hex digits in unicode value: '" + input.subSequence(index, input.length()) + "' due to end of CharSequence"); [EOL]         } [EOL]     } [EOL]     return 0; [EOL] } 
 [LINE] return i + 4; [LINE] @Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     if (input.charAt(index) == '\\' && index + 1 < input.length() && input.charAt(index + 1) == 'u') { [EOL]         int i = 2; [EOL]         while (index + i < input.length() && input.charAt(index + i) == 'u') { [EOL]             i++; [EOL]         } [EOL]         if (index + i < input.length() && input.charAt(index + i) == '+') { [EOL]             i++; [EOL]         } [EOL]         if (index + i + 4 <= input.length()) { [EOL]             final CharSequence unicode = input.subSequence(index + i, index + i + 4); [EOL]             try { [EOL]                 final int value = Integer.parseInt(unicode.toString(), 16); [EOL]                 out.write((char) value); [EOL]             } catch (final NumberFormatException nfe) { [EOL]                 throw new IllegalArgumentException("Unable to parse unicode value: " + unicode, nfe); [EOL]             } [EOL]             return i + 4; [EOL]         } else { [EOL]             throw new IllegalArgumentException("Less than 4 hex digits in unicode value: '" + input.subSequence(index, input.length()) + "' due to end of CharSequence"); [EOL]         } [EOL]     } [EOL]     return 0; [EOL] } 
 [LINE] append((long[]) object); [LINE] public HashCodeBuilder append(final Object object) { [EOL]     if (object == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         if (object.getClass().isArray()) { [EOL]             if (object instanceof long[]) { [EOL]                 append((long[]) object); [EOL]             } else if (object instanceof int[]) { [EOL]                 append((int[]) object); [EOL]             } else if (object instanceof short[]) { [EOL]                 append((short[]) object); [EOL]             } else if (object instanceof char[]) { [EOL]                 append((char[]) object); [EOL]             } else if (object instanceof byte[]) { [EOL]                 append((byte[]) object); [EOL]             } else if (object instanceof double[]) { [EOL]                 append((double[]) object); [EOL]             } else if (object instanceof float[]) { [EOL]                 append((float[]) object); [EOL]             } else if (object instanceof boolean[]) { [EOL]                 append((boolean[]) object); [EOL]             } else { [EOL]                 append((Object[]) object); [EOL]             } [EOL]         } else { [EOL]             iTotal = iTotal * iConstant + object.hashCode(); [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] append((int[]) object); [LINE] public HashCodeBuilder append(final Object object) { [EOL]     if (object == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         if (object.getClass().isArray()) { [EOL]             if (object instanceof long[]) { [EOL]                 append((long[]) object); [EOL]             } else if (object instanceof int[]) { [EOL]                 append((int[]) object); [EOL]             } else if (object instanceof short[]) { [EOL]                 append((short[]) object); [EOL]             } else if (object instanceof char[]) { [EOL]                 append((char[]) object); [EOL]             } else if (object instanceof byte[]) { [EOL]                 append((byte[]) object); [EOL]             } else if (object instanceof double[]) { [EOL]                 append((double[]) object); [EOL]             } else if (object instanceof float[]) { [EOL]                 append((float[]) object); [EOL]             } else if (object instanceof boolean[]) { [EOL]                 append((boolean[]) object); [EOL]             } else { [EOL]                 append((Object[]) object); [EOL]             } [EOL]         } else { [EOL]             iTotal = iTotal * iConstant + object.hashCode(); [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] append((short[]) object); [LINE] public HashCodeBuilder append(final Object object) { [EOL]     if (object == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         if (object.getClass().isArray()) { [EOL]             if (object instanceof long[]) { [EOL]                 append((long[]) object); [EOL]             } else if (object instanceof int[]) { [EOL]                 append((int[]) object); [EOL]             } else if (object instanceof short[]) { [EOL]                 append((short[]) object); [EOL]             } else if (object instanceof char[]) { [EOL]                 append((char[]) object); [EOL]             } else if (object instanceof byte[]) { [EOL]                 append((byte[]) object); [EOL]             } else if (object instanceof double[]) { [EOL]                 append((double[]) object); [EOL]             } else if (object instanceof float[]) { [EOL]                 append((float[]) object); [EOL]             } else if (object instanceof boolean[]) { [EOL]                 append((boolean[]) object); [EOL]             } else { [EOL]                 append((Object[]) object); [EOL]             } [EOL]         } else { [EOL]             iTotal = iTotal * iConstant + object.hashCode(); [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] } else if (object instanceof byte[]) { [LINE] public HashCodeBuilder append(final Object object) { [EOL]     if (object == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         if (object.getClass().isArray()) { [EOL]             if (object instanceof long[]) { [EOL]                 append((long[]) object); [EOL]             } else if (object instanceof int[]) { [EOL]                 append((int[]) object); [EOL]             } else if (object instanceof short[]) { [EOL]                 append((short[]) object); [EOL]             } else if (object instanceof char[]) { [EOL]                 append((char[]) object); [EOL]             } else if (object instanceof byte[]) { [EOL]                 append((byte[]) object); [EOL]             } else if (object instanceof double[]) { [EOL]                 append((double[]) object); [EOL]             } else if (object instanceof float[]) { [EOL]                 append((float[]) object); [EOL]             } else if (object instanceof boolean[]) { [EOL]                 append((boolean[]) object); [EOL]             } else { [EOL]                 append((Object[]) object); [EOL]             } [EOL]         } else { [EOL]             iTotal = iTotal * iConstant + object.hashCode(); [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] append((byte[]) object); [LINE] public HashCodeBuilder append(final Object object) { [EOL]     if (object == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         if (object.getClass().isArray()) { [EOL]             if (object instanceof long[]) { [EOL]                 append((long[]) object); [EOL]             } else if (object instanceof int[]) { [EOL]                 append((int[]) object); [EOL]             } else if (object instanceof short[]) { [EOL]                 append((short[]) object); [EOL]             } else if (object instanceof char[]) { [EOL]                 append((char[]) object); [EOL]             } else if (object instanceof byte[]) { [EOL]                 append((byte[]) object); [EOL]             } else if (object instanceof double[]) { [EOL]                 append((double[]) object); [EOL]             } else if (object instanceof float[]) { [EOL]                 append((float[]) object); [EOL]             } else if (object instanceof boolean[]) { [EOL]                 append((boolean[]) object); [EOL]             } else { [EOL]                 append((Object[]) object); [EOL]             } [EOL]         } else { [EOL]             iTotal = iTotal * iConstant + object.hashCode(); [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] } else if (object instanceof double[]) { [LINE] public HashCodeBuilder append(final Object object) { [EOL]     if (object == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         if (object.getClass().isArray()) { [EOL]             if (object instanceof long[]) { [EOL]                 append((long[]) object); [EOL]             } else if (object instanceof int[]) { [EOL]                 append((int[]) object); [EOL]             } else if (object instanceof short[]) { [EOL]                 append((short[]) object); [EOL]             } else if (object instanceof char[]) { [EOL]                 append((char[]) object); [EOL]             } else if (object instanceof byte[]) { [EOL]                 append((byte[]) object); [EOL]             } else if (object instanceof double[]) { [EOL]                 append((double[]) object); [EOL]             } else if (object instanceof float[]) { [EOL]                 append((float[]) object); [EOL]             } else if (object instanceof boolean[]) { [EOL]                 append((boolean[]) object); [EOL]             } else { [EOL]                 append((Object[]) object); [EOL]             } [EOL]         } else { [EOL]             iTotal = iTotal * iConstant + object.hashCode(); [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] append((double[]) object); [LINE] public HashCodeBuilder append(final Object object) { [EOL]     if (object == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         if (object.getClass().isArray()) { [EOL]             if (object instanceof long[]) { [EOL]                 append((long[]) object); [EOL]             } else if (object instanceof int[]) { [EOL]                 append((int[]) object); [EOL]             } else if (object instanceof short[]) { [EOL]                 append((short[]) object); [EOL]             } else if (object instanceof char[]) { [EOL]                 append((char[]) object); [EOL]             } else if (object instanceof byte[]) { [EOL]                 append((byte[]) object); [EOL]             } else if (object instanceof double[]) { [EOL]                 append((double[]) object); [EOL]             } else if (object instanceof float[]) { [EOL]                 append((float[]) object); [EOL]             } else if (object instanceof boolean[]) { [EOL]                 append((boolean[]) object); [EOL]             } else { [EOL]                 append((Object[]) object); [EOL]             } [EOL]         } else { [EOL]             iTotal = iTotal * iConstant + object.hashCode(); [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] } else if (object instanceof float[]) { [LINE] public HashCodeBuilder append(final Object object) { [EOL]     if (object == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         if (object.getClass().isArray()) { [EOL]             if (object instanceof long[]) { [EOL]                 append((long[]) object); [EOL]             } else if (object instanceof int[]) { [EOL]                 append((int[]) object); [EOL]             } else if (object instanceof short[]) { [EOL]                 append((short[]) object); [EOL]             } else if (object instanceof char[]) { [EOL]                 append((char[]) object); [EOL]             } else if (object instanceof byte[]) { [EOL]                 append((byte[]) object); [EOL]             } else if (object instanceof double[]) { [EOL]                 append((double[]) object); [EOL]             } else if (object instanceof float[]) { [EOL]                 append((float[]) object); [EOL]             } else if (object instanceof boolean[]) { [EOL]                 append((boolean[]) object); [EOL]             } else { [EOL]                 append((Object[]) object); [EOL]             } [EOL]         } else { [EOL]             iTotal = iTotal * iConstant + object.hashCode(); [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] append((float[]) object); [LINE] public HashCodeBuilder append(final Object object) { [EOL]     if (object == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         if (object.getClass().isArray()) { [EOL]             if (object instanceof long[]) { [EOL]                 append((long[]) object); [EOL]             } else if (object instanceof int[]) { [EOL]                 append((int[]) object); [EOL]             } else if (object instanceof short[]) { [EOL]                 append((short[]) object); [EOL]             } else if (object instanceof char[]) { [EOL]                 append((char[]) object); [EOL]             } else if (object instanceof byte[]) { [EOL]                 append((byte[]) object); [EOL]             } else if (object instanceof double[]) { [EOL]                 append((double[]) object); [EOL]             } else if (object instanceof float[]) { [EOL]                 append((float[]) object); [EOL]             } else if (object instanceof boolean[]) { [EOL]                 append((boolean[]) object); [EOL]             } else { [EOL]                 append((Object[]) object); [EOL]             } [EOL]         } else { [EOL]             iTotal = iTotal * iConstant + object.hashCode(); [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] } else if (object instanceof boolean[]) { [LINE] public HashCodeBuilder append(final Object object) { [EOL]     if (object == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         if (object.getClass().isArray()) { [EOL]             if (object instanceof long[]) { [EOL]                 append((long[]) object); [EOL]             } else if (object instanceof int[]) { [EOL]                 append((int[]) object); [EOL]             } else if (object instanceof short[]) { [EOL]                 append((short[]) object); [EOL]             } else if (object instanceof char[]) { [EOL]                 append((char[]) object); [EOL]             } else if (object instanceof byte[]) { [EOL]                 append((byte[]) object); [EOL]             } else if (object instanceof double[]) { [EOL]                 append((double[]) object); [EOL]             } else if (object instanceof float[]) { [EOL]                 append((float[]) object); [EOL]             } else if (object instanceof boolean[]) { [EOL]                 append((boolean[]) object); [EOL]             } else { [EOL]                 append((Object[]) object); [EOL]             } [EOL]         } else { [EOL]             iTotal = iTotal * iConstant + object.hashCode(); [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] append((boolean[]) object); [LINE] public HashCodeBuilder append(final Object object) { [EOL]     if (object == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         if (object.getClass().isArray()) { [EOL]             if (object instanceof long[]) { [EOL]                 append((long[]) object); [EOL]             } else if (object instanceof int[]) { [EOL]                 append((int[]) object); [EOL]             } else if (object instanceof short[]) { [EOL]                 append((short[]) object); [EOL]             } else if (object instanceof char[]) { [EOL]                 append((char[]) object); [EOL]             } else if (object instanceof byte[]) { [EOL]                 append((byte[]) object); [EOL]             } else if (object instanceof double[]) { [EOL]                 append((double[]) object); [EOL]             } else if (object instanceof float[]) { [EOL]                 append((float[]) object); [EOL]             } else if (object instanceof boolean[]) { [EOL]                 append((boolean[]) object); [EOL]             } else { [EOL]                 append((Object[]) object); [EOL]             } [EOL]         } else { [EOL]             iTotal = iTotal * iConstant + object.hashCode(); [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] append((Object[]) object); [LINE] public HashCodeBuilder append(final Object object) { [EOL]     if (object == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         if (object.getClass().isArray()) { [EOL]             if (object instanceof long[]) { [EOL]                 append((long[]) object); [EOL]             } else if (object instanceof int[]) { [EOL]                 append((int[]) object); [EOL]             } else if (object instanceof short[]) { [EOL]                 append((short[]) object); [EOL]             } else if (object instanceof char[]) { [EOL]                 append((char[]) object); [EOL]             } else if (object instanceof byte[]) { [EOL]                 append((byte[]) object); [EOL]             } else if (object instanceof double[]) { [EOL]                 append((double[]) object); [EOL]             } else if (object instanceof float[]) { [EOL]                 append((float[]) object); [EOL]             } else if (object instanceof boolean[]) { [EOL]                 append((boolean[]) object); [EOL]             } else { [EOL]                 append((Object[]) object); [EOL]             } [EOL]         } else { [EOL]             iTotal = iTotal * iConstant + object.hashCode(); [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] final int start = index + 1; [LINE] @Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     if (input.charAt(index) == '\\' && index < (input.length() - 1) && Character.isDigit(input.charAt(index + 1))) { [EOL]         final int start = index + 1; [EOL]         int end = index + 2; [EOL]         while (end < input.length() && Character.isDigit(input.charAt(end))) { [EOL]             end++; [EOL]             if (Integer.parseInt(input.subSequence(start, end).toString(), 10) > OCTAL_MAX) { [EOL]                 end--; [EOL]                 break; [EOL]             } [EOL]         } [EOL]         out.write(Integer.parseInt(input.subSequence(start, end).toString(), 8)); [EOL]         return 1 + end - start; [EOL]     } [EOL]     return 0; [EOL] } 
 [LINE] int end = index + 2; [LINE] @Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     if (input.charAt(index) == '\\' && index < (input.length() - 1) && Character.isDigit(input.charAt(index + 1))) { [EOL]         final int start = index + 1; [EOL]         int end = index + 2; [EOL]         while (end < input.length() && Character.isDigit(input.charAt(end))) { [EOL]             end++; [EOL]             if (Integer.parseInt(input.subSequence(start, end).toString(), 10) > OCTAL_MAX) { [EOL]                 end--; [EOL]                 break; [EOL]             } [EOL]         } [EOL]         out.write(Integer.parseInt(input.subSequence(start, end).toString(), 8)); [EOL]         return 1 + end - start; [EOL]     } [EOL]     return 0; [EOL] } 
 [LINE] while ( end < input.length() && Character.isDigit(input.charAt(end)) ) { [LINE] @Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     if (input.charAt(index) == '\\' && index < (input.length() - 1) && Character.isDigit(input.charAt(index + 1))) { [EOL]         final int start = index + 1; [EOL]         int end = index + 2; [EOL]         while (end < input.length() && Character.isDigit(input.charAt(end))) { [EOL]             end++; [EOL]             if (Integer.parseInt(input.subSequence(start, end).toString(), 10) > OCTAL_MAX) { [EOL]                 end--; [EOL]                 break; [EOL]             } [EOL]         } [EOL]         out.write(Integer.parseInt(input.subSequence(start, end).toString(), 8)); [EOL]         return 1 + end - start; [EOL]     } [EOL]     return 0; [EOL] } 
 [LINE] end++; [LINE] @Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     if (input.charAt(index) == '\\' && index < (input.length() - 1) && Character.isDigit(input.charAt(index + 1))) { [EOL]         final int start = index + 1; [EOL]         int end = index + 2; [EOL]         while (end < input.length() && Character.isDigit(input.charAt(end))) { [EOL]             end++; [EOL]             if (Integer.parseInt(input.subSequence(start, end).toString(), 10) > OCTAL_MAX) { [EOL]                 end--; [EOL]                 break; [EOL]             } [EOL]         } [EOL]         out.write(Integer.parseInt(input.subSequence(start, end).toString(), 8)); [EOL]         return 1 + end - start; [EOL]     } [EOL]     return 0; [EOL] } 
 [LINE] if ( Integer.parseInt(input.subSequence(start, end).toString(), 10) > OCTAL_MAX) { [LINE] @Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     if (input.charAt(index) == '\\' && index < (input.length() - 1) && Character.isDigit(input.charAt(index + 1))) { [EOL]         final int start = index + 1; [EOL]         int end = index + 2; [EOL]         while (end < input.length() && Character.isDigit(input.charAt(end))) { [EOL]             end++; [EOL]             if (Integer.parseInt(input.subSequence(start, end).toString(), 10) > OCTAL_MAX) { [EOL]                 end--; [EOL]                 break; [EOL]             } [EOL]         } [EOL]         out.write(Integer.parseInt(input.subSequence(start, end).toString(), 8)); [EOL]         return 1 + end - start; [EOL]     } [EOL]     return 0; [EOL] } 
 [LINE] end--; // rollback [LINE] @Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     if (input.charAt(index) == '\\' && index < (input.length() - 1) && Character.isDigit(input.charAt(index + 1))) { [EOL]         final int start = index + 1; [EOL]         int end = index + 2; [EOL]         while (end < input.length() && Character.isDigit(input.charAt(end))) { [EOL]             end++; [EOL]             if (Integer.parseInt(input.subSequence(start, end).toString(), 10) > OCTAL_MAX) { [EOL]                 end--; [EOL]                 break; [EOL]             } [EOL]         } [EOL]         out.write(Integer.parseInt(input.subSequence(start, end).toString(), 8)); [EOL]         return 1 + end - start; [EOL]     } [EOL]     return 0; [EOL] } 
 [LINE] break; [LINE] @Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     if (input.charAt(index) == '\\' && index < (input.length() - 1) && Character.isDigit(input.charAt(index + 1))) { [EOL]         final int start = index + 1; [EOL]         int end = index + 2; [EOL]         while (end < input.length() && Character.isDigit(input.charAt(end))) { [EOL]             end++; [EOL]             if (Integer.parseInt(input.subSequence(start, end).toString(), 10) > OCTAL_MAX) { [EOL]                 end--; [EOL]                 break; [EOL]             } [EOL]         } [EOL]         out.write(Integer.parseInt(input.subSequence(start, end).toString(), 8)); [EOL]         return 1 + end - start; [EOL]     } [EOL]     return 0; [EOL] } 
 [LINE] out.write( Integer.parseInt(input.subSequence(start, end).toString(), 8) ); [LINE] @Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     if (input.charAt(index) == '\\' && index < (input.length() - 1) && Character.isDigit(input.charAt(index + 1))) { [EOL]         final int start = index + 1; [EOL]         int end = index + 2; [EOL]         while (end < input.length() && Character.isDigit(input.charAt(end))) { [EOL]             end++; [EOL]             if (Integer.parseInt(input.subSequence(start, end).toString(), 10) > OCTAL_MAX) { [EOL]                 end--; [EOL]                 break; [EOL]             } [EOL]         } [EOL]         out.write(Integer.parseInt(input.subSequence(start, end).toString(), 8)); [EOL]         return 1 + end - start; [EOL]     } [EOL]     return 0; [EOL] } 
 [LINE] return 1 + end - start; [LINE] @Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     if (input.charAt(index) == '\\' && index < (input.length() - 1) && Character.isDigit(input.charAt(index + 1))) { [EOL]         final int start = index + 1; [EOL]         int end = index + 2; [EOL]         while (end < input.length() && Character.isDigit(input.charAt(end))) { [EOL]             end++; [EOL]             if (Integer.parseInt(input.subSequence(start, end).toString(), 10) > OCTAL_MAX) { [EOL]                 end--; [EOL]                 break; [EOL]             } [EOL]         } [EOL]         out.write(Integer.parseInt(input.subSequence(start, end).toString(), 8)); [EOL]         return 1 + end - start; [EOL]     } [EOL]     return 0; [EOL] } 
 [LINE] throw new IllegalArgumentException("The Writer must not be null"); [LINE] public final void translate(final CharSequence input, final Writer out) throws IOException { [EOL]     if (out == null) { [EOL]         throw new IllegalArgumentException("The Writer must not be null"); [EOL]     } [EOL]     if (input == null) { [EOL]         return; [EOL]     } [EOL]     int pos = 0; [EOL]     final int len = input.length(); [EOL]     while (pos < len) { [EOL]         final int consumed = translate(input, pos, out); [EOL]         if (consumed == 0) { [EOL]             final char[] c = Character.toChars(Character.codePointAt(input, pos)); [EOL]             out.write(c); [EOL]             pos += c.length; [EOL]             continue; [EOL]         } [EOL]         for (int pt = 0; pt < consumed; pt++) { [EOL]             pos += Character.charCount(Character.codePointAt(input, pt)); [EOL]         } [EOL]     } [EOL] } 
 [LINE] return; [LINE] public final void translate(final CharSequence input, final Writer out) throws IOException { [EOL]     if (out == null) { [EOL]         throw new IllegalArgumentException("The Writer must not be null"); [EOL]     } [EOL]     if (input == null) { [EOL]         return; [EOL]     } [EOL]     int pos = 0; [EOL]     final int len = input.length(); [EOL]     while (pos < len) { [EOL]         final int consumed = translate(input, pos, out); [EOL]         if (consumed == 0) { [EOL]             final char[] c = Character.toChars(Character.codePointAt(input, pos)); [EOL]             out.write(c); [EOL]             pos += c.length; [EOL]             continue; [EOL]         } [EOL]         for (int pt = 0; pt < consumed; pt++) { [EOL]             pos += Character.charCount(Character.codePointAt(input, pt)); [EOL]         } [EOL]     } [EOL] } 
 [LINE] public static String hex(final int codepoint) { [LINE] public static String hex(final int codepoint) { [EOL]     return Integer.toHexString(codepoint).toUpperCase(Locale.ENGLISH); [EOL] } 
 [LINE] return Integer.toHexString(codepoint).toUpperCase(Locale.ENGLISH); [LINE] public static String hex(final int codepoint) { [EOL]     return Integer.toHexString(codepoint).toUpperCase(Locale.ENGLISH); [EOL] } 
 [LINE] duration = tmp; [LINE] public static String formatDurationWords(final long durationMillis, final boolean suppressLeadingZeroElements, final boolean suppressTrailingZeroElements) { [EOL]     String duration = formatDuration(durationMillis, "d' days 'H' hours 'm' minutes 's' seconds'"); [EOL]     if (suppressLeadingZeroElements) { [EOL]         duration = " " + duration; [EOL]         String tmp = StringUtils.replaceOnce(duration, " 0 days", ""); [EOL]         if (tmp.length() != duration.length()) { [EOL]             duration = tmp; [EOL]             tmp = StringUtils.replaceOnce(duration, " 0 hours", ""); [EOL]             if (tmp.length() != duration.length()) { [EOL]                 duration = tmp; [EOL]                 tmp = StringUtils.replaceOnce(duration, " 0 minutes", ""); [EOL]                 duration = tmp; [EOL]                 if (tmp.length() != duration.length()) { [EOL]                     duration = StringUtils.replaceOnce(tmp, " 0 seconds", ""); [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (duration.length() != 0) { [EOL]             duration = duration.substring(1); [EOL]         } [EOL]     } [EOL]     if (suppressTrailingZeroElements) { [EOL]         String tmp = StringUtils.replaceOnce(duration, " 0 seconds", ""); [EOL]         if (tmp.length() != duration.length()) { [EOL]             duration = tmp; [EOL]             tmp = StringUtils.replaceOnce(duration, " 0 minutes", ""); [EOL]             if (tmp.length() != duration.length()) { [EOL]                 duration = tmp; [EOL]                 tmp = StringUtils.replaceOnce(duration, " 0 hours", ""); [EOL]                 if (tmp.length() != duration.length()) { [EOL]                     duration = StringUtils.replaceOnce(tmp, " 0 days", ""); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     duration = " " + duration; [EOL]     duration = StringUtils.replaceOnce(duration, " 1 seconds", " 1 second"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 minutes", " 1 minute"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 hours", " 1 hour"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 days", " 1 day"); [EOL]     return duration.trim(); [EOL] } 
 [LINE] tmp = StringUtils.replaceOnce(duration, " 0 hours", ""); [LINE] public static String formatDurationWords(final long durationMillis, final boolean suppressLeadingZeroElements, final boolean suppressTrailingZeroElements) { [EOL]     String duration = formatDuration(durationMillis, "d' days 'H' hours 'm' minutes 's' seconds'"); [EOL]     if (suppressLeadingZeroElements) { [EOL]         duration = " " + duration; [EOL]         String tmp = StringUtils.replaceOnce(duration, " 0 days", ""); [EOL]         if (tmp.length() != duration.length()) { [EOL]             duration = tmp; [EOL]             tmp = StringUtils.replaceOnce(duration, " 0 hours", ""); [EOL]             if (tmp.length() != duration.length()) { [EOL]                 duration = tmp; [EOL]                 tmp = StringUtils.replaceOnce(duration, " 0 minutes", ""); [EOL]                 duration = tmp; [EOL]                 if (tmp.length() != duration.length()) { [EOL]                     duration = StringUtils.replaceOnce(tmp, " 0 seconds", ""); [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (duration.length() != 0) { [EOL]             duration = duration.substring(1); [EOL]         } [EOL]     } [EOL]     if (suppressTrailingZeroElements) { [EOL]         String tmp = StringUtils.replaceOnce(duration, " 0 seconds", ""); [EOL]         if (tmp.length() != duration.length()) { [EOL]             duration = tmp; [EOL]             tmp = StringUtils.replaceOnce(duration, " 0 minutes", ""); [EOL]             if (tmp.length() != duration.length()) { [EOL]                 duration = tmp; [EOL]                 tmp = StringUtils.replaceOnce(duration, " 0 hours", ""); [EOL]                 if (tmp.length() != duration.length()) { [EOL]                     duration = StringUtils.replaceOnce(tmp, " 0 days", ""); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     duration = " " + duration; [EOL]     duration = StringUtils.replaceOnce(duration, " 1 seconds", " 1 second"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 minutes", " 1 minute"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 hours", " 1 hour"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 days", " 1 day"); [EOL]     return duration.trim(); [EOL] } 
 [LINE] if (tmp.length() != duration.length()) { [LINE] public static String formatDurationWords(final long durationMillis, final boolean suppressLeadingZeroElements, final boolean suppressTrailingZeroElements) { [EOL]     String duration = formatDuration(durationMillis, "d' days 'H' hours 'm' minutes 's' seconds'"); [EOL]     if (suppressLeadingZeroElements) { [EOL]         duration = " " + duration; [EOL]         String tmp = StringUtils.replaceOnce(duration, " 0 days", ""); [EOL]         if (tmp.length() != duration.length()) { [EOL]             duration = tmp; [EOL]             tmp = StringUtils.replaceOnce(duration, " 0 hours", ""); [EOL]             if (tmp.length() != duration.length()) { [EOL]                 duration = tmp; [EOL]                 tmp = StringUtils.replaceOnce(duration, " 0 minutes", ""); [EOL]                 duration = tmp; [EOL]                 if (tmp.length() != duration.length()) { [EOL]                     duration = StringUtils.replaceOnce(tmp, " 0 seconds", ""); [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (duration.length() != 0) { [EOL]             duration = duration.substring(1); [EOL]         } [EOL]     } [EOL]     if (suppressTrailingZeroElements) { [EOL]         String tmp = StringUtils.replaceOnce(duration, " 0 seconds", ""); [EOL]         if (tmp.length() != duration.length()) { [EOL]             duration = tmp; [EOL]             tmp = StringUtils.replaceOnce(duration, " 0 minutes", ""); [EOL]             if (tmp.length() != duration.length()) { [EOL]                 duration = tmp; [EOL]                 tmp = StringUtils.replaceOnce(duration, " 0 hours", ""); [EOL]                 if (tmp.length() != duration.length()) { [EOL]                     duration = StringUtils.replaceOnce(tmp, " 0 days", ""); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     duration = " " + duration; [EOL]     duration = StringUtils.replaceOnce(duration, " 1 seconds", " 1 second"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 minutes", " 1 minute"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 hours", " 1 hour"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 days", " 1 day"); [EOL]     return duration.trim(); [EOL] } 
 [LINE] duration = tmp; [LINE] public static String formatDurationWords(final long durationMillis, final boolean suppressLeadingZeroElements, final boolean suppressTrailingZeroElements) { [EOL]     String duration = formatDuration(durationMillis, "d' days 'H' hours 'm' minutes 's' seconds'"); [EOL]     if (suppressLeadingZeroElements) { [EOL]         duration = " " + duration; [EOL]         String tmp = StringUtils.replaceOnce(duration, " 0 days", ""); [EOL]         if (tmp.length() != duration.length()) { [EOL]             duration = tmp; [EOL]             tmp = StringUtils.replaceOnce(duration, " 0 hours", ""); [EOL]             if (tmp.length() != duration.length()) { [EOL]                 duration = tmp; [EOL]                 tmp = StringUtils.replaceOnce(duration, " 0 minutes", ""); [EOL]                 duration = tmp; [EOL]                 if (tmp.length() != duration.length()) { [EOL]                     duration = StringUtils.replaceOnce(tmp, " 0 seconds", ""); [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (duration.length() != 0) { [EOL]             duration = duration.substring(1); [EOL]         } [EOL]     } [EOL]     if (suppressTrailingZeroElements) { [EOL]         String tmp = StringUtils.replaceOnce(duration, " 0 seconds", ""); [EOL]         if (tmp.length() != duration.length()) { [EOL]             duration = tmp; [EOL]             tmp = StringUtils.replaceOnce(duration, " 0 minutes", ""); [EOL]             if (tmp.length() != duration.length()) { [EOL]                 duration = tmp; [EOL]                 tmp = StringUtils.replaceOnce(duration, " 0 hours", ""); [EOL]                 if (tmp.length() != duration.length()) { [EOL]                     duration = StringUtils.replaceOnce(tmp, " 0 days", ""); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     duration = " " + duration; [EOL]     duration = StringUtils.replaceOnce(duration, " 1 seconds", " 1 second"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 minutes", " 1 minute"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 hours", " 1 hour"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 days", " 1 day"); [EOL]     return duration.trim(); [EOL] } 
 [LINE] tmp = StringUtils.replaceOnce(duration, " 0 minutes", ""); [LINE] public static String formatDurationWords(final long durationMillis, final boolean suppressLeadingZeroElements, final boolean suppressTrailingZeroElements) { [EOL]     String duration = formatDuration(durationMillis, "d' days 'H' hours 'm' minutes 's' seconds'"); [EOL]     if (suppressLeadingZeroElements) { [EOL]         duration = " " + duration; [EOL]         String tmp = StringUtils.replaceOnce(duration, " 0 days", ""); [EOL]         if (tmp.length() != duration.length()) { [EOL]             duration = tmp; [EOL]             tmp = StringUtils.replaceOnce(duration, " 0 hours", ""); [EOL]             if (tmp.length() != duration.length()) { [EOL]                 duration = tmp; [EOL]                 tmp = StringUtils.replaceOnce(duration, " 0 minutes", ""); [EOL]                 duration = tmp; [EOL]                 if (tmp.length() != duration.length()) { [EOL]                     duration = StringUtils.replaceOnce(tmp, " 0 seconds", ""); [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (duration.length() != 0) { [EOL]             duration = duration.substring(1); [EOL]         } [EOL]     } [EOL]     if (suppressTrailingZeroElements) { [EOL]         String tmp = StringUtils.replaceOnce(duration, " 0 seconds", ""); [EOL]         if (tmp.length() != duration.length()) { [EOL]             duration = tmp; [EOL]             tmp = StringUtils.replaceOnce(duration, " 0 minutes", ""); [EOL]             if (tmp.length() != duration.length()) { [EOL]                 duration = tmp; [EOL]                 tmp = StringUtils.replaceOnce(duration, " 0 hours", ""); [EOL]                 if (tmp.length() != duration.length()) { [EOL]                     duration = StringUtils.replaceOnce(tmp, " 0 days", ""); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     duration = " " + duration; [EOL]     duration = StringUtils.replaceOnce(duration, " 1 seconds", " 1 second"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 minutes", " 1 minute"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 hours", " 1 hour"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 days", " 1 day"); [EOL]     return duration.trim(); [EOL] } 
 [LINE] duration = tmp; [LINE] public static String formatDurationWords(final long durationMillis, final boolean suppressLeadingZeroElements, final boolean suppressTrailingZeroElements) { [EOL]     String duration = formatDuration(durationMillis, "d' days 'H' hours 'm' minutes 's' seconds'"); [EOL]     if (suppressLeadingZeroElements) { [EOL]         duration = " " + duration; [EOL]         String tmp = StringUtils.replaceOnce(duration, " 0 days", ""); [EOL]         if (tmp.length() != duration.length()) { [EOL]             duration = tmp; [EOL]             tmp = StringUtils.replaceOnce(duration, " 0 hours", ""); [EOL]             if (tmp.length() != duration.length()) { [EOL]                 duration = tmp; [EOL]                 tmp = StringUtils.replaceOnce(duration, " 0 minutes", ""); [EOL]                 duration = tmp; [EOL]                 if (tmp.length() != duration.length()) { [EOL]                     duration = StringUtils.replaceOnce(tmp, " 0 seconds", ""); [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (duration.length() != 0) { [EOL]             duration = duration.substring(1); [EOL]         } [EOL]     } [EOL]     if (suppressTrailingZeroElements) { [EOL]         String tmp = StringUtils.replaceOnce(duration, " 0 seconds", ""); [EOL]         if (tmp.length() != duration.length()) { [EOL]             duration = tmp; [EOL]             tmp = StringUtils.replaceOnce(duration, " 0 minutes", ""); [EOL]             if (tmp.length() != duration.length()) { [EOL]                 duration = tmp; [EOL]                 tmp = StringUtils.replaceOnce(duration, " 0 hours", ""); [EOL]                 if (tmp.length() != duration.length()) { [EOL]                     duration = StringUtils.replaceOnce(tmp, " 0 days", ""); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     duration = " " + duration; [EOL]     duration = StringUtils.replaceOnce(duration, " 1 seconds", " 1 second"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 minutes", " 1 minute"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 hours", " 1 hour"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 days", " 1 day"); [EOL]     return duration.trim(); [EOL] } 
 [LINE] if (tmp.length() != duration.length()) { [LINE] public static String formatDurationWords(final long durationMillis, final boolean suppressLeadingZeroElements, final boolean suppressTrailingZeroElements) { [EOL]     String duration = formatDuration(durationMillis, "d' days 'H' hours 'm' minutes 's' seconds'"); [EOL]     if (suppressLeadingZeroElements) { [EOL]         duration = " " + duration; [EOL]         String tmp = StringUtils.replaceOnce(duration, " 0 days", ""); [EOL]         if (tmp.length() != duration.length()) { [EOL]             duration = tmp; [EOL]             tmp = StringUtils.replaceOnce(duration, " 0 hours", ""); [EOL]             if (tmp.length() != duration.length()) { [EOL]                 duration = tmp; [EOL]                 tmp = StringUtils.replaceOnce(duration, " 0 minutes", ""); [EOL]                 duration = tmp; [EOL]                 if (tmp.length() != duration.length()) { [EOL]                     duration = StringUtils.replaceOnce(tmp, " 0 seconds", ""); [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (duration.length() != 0) { [EOL]             duration = duration.substring(1); [EOL]         } [EOL]     } [EOL]     if (suppressTrailingZeroElements) { [EOL]         String tmp = StringUtils.replaceOnce(duration, " 0 seconds", ""); [EOL]         if (tmp.length() != duration.length()) { [EOL]             duration = tmp; [EOL]             tmp = StringUtils.replaceOnce(duration, " 0 minutes", ""); [EOL]             if (tmp.length() != duration.length()) { [EOL]                 duration = tmp; [EOL]                 tmp = StringUtils.replaceOnce(duration, " 0 hours", ""); [EOL]                 if (tmp.length() != duration.length()) { [EOL]                     duration = StringUtils.replaceOnce(tmp, " 0 days", ""); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     duration = " " + duration; [EOL]     duration = StringUtils.replaceOnce(duration, " 1 seconds", " 1 second"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 minutes", " 1 minute"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 hours", " 1 hour"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 days", " 1 day"); [EOL]     return duration.trim(); [EOL] } 
 [LINE] duration = tmp; [LINE] public static String formatDurationWords(final long durationMillis, final boolean suppressLeadingZeroElements, final boolean suppressTrailingZeroElements) { [EOL]     String duration = formatDuration(durationMillis, "d' days 'H' hours 'm' minutes 's' seconds'"); [EOL]     if (suppressLeadingZeroElements) { [EOL]         duration = " " + duration; [EOL]         String tmp = StringUtils.replaceOnce(duration, " 0 days", ""); [EOL]         if (tmp.length() != duration.length()) { [EOL]             duration = tmp; [EOL]             tmp = StringUtils.replaceOnce(duration, " 0 hours", ""); [EOL]             if (tmp.length() != duration.length()) { [EOL]                 duration = tmp; [EOL]                 tmp = StringUtils.replaceOnce(duration, " 0 minutes", ""); [EOL]                 duration = tmp; [EOL]                 if (tmp.length() != duration.length()) { [EOL]                     duration = StringUtils.replaceOnce(tmp, " 0 seconds", ""); [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (duration.length() != 0) { [EOL]             duration = duration.substring(1); [EOL]         } [EOL]     } [EOL]     if (suppressTrailingZeroElements) { [EOL]         String tmp = StringUtils.replaceOnce(duration, " 0 seconds", ""); [EOL]         if (tmp.length() != duration.length()) { [EOL]             duration = tmp; [EOL]             tmp = StringUtils.replaceOnce(duration, " 0 minutes", ""); [EOL]             if (tmp.length() != duration.length()) { [EOL]                 duration = tmp; [EOL]                 tmp = StringUtils.replaceOnce(duration, " 0 hours", ""); [EOL]                 if (tmp.length() != duration.length()) { [EOL]                     duration = StringUtils.replaceOnce(tmp, " 0 days", ""); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     duration = " " + duration; [EOL]     duration = StringUtils.replaceOnce(duration, " 1 seconds", " 1 second"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 minutes", " 1 minute"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 hours", " 1 hour"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 days", " 1 day"); [EOL]     return duration.trim(); [EOL] } 
 [LINE] tmp = StringUtils.replaceOnce(duration, " 0 minutes", ""); [LINE] public static String formatDurationWords(final long durationMillis, final boolean suppressLeadingZeroElements, final boolean suppressTrailingZeroElements) { [EOL]     String duration = formatDuration(durationMillis, "d' days 'H' hours 'm' minutes 's' seconds'"); [EOL]     if (suppressLeadingZeroElements) { [EOL]         duration = " " + duration; [EOL]         String tmp = StringUtils.replaceOnce(duration, " 0 days", ""); [EOL]         if (tmp.length() != duration.length()) { [EOL]             duration = tmp; [EOL]             tmp = StringUtils.replaceOnce(duration, " 0 hours", ""); [EOL]             if (tmp.length() != duration.length()) { [EOL]                 duration = tmp; [EOL]                 tmp = StringUtils.replaceOnce(duration, " 0 minutes", ""); [EOL]                 duration = tmp; [EOL]                 if (tmp.length() != duration.length()) { [EOL]                     duration = StringUtils.replaceOnce(tmp, " 0 seconds", ""); [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (duration.length() != 0) { [EOL]             duration = duration.substring(1); [EOL]         } [EOL]     } [EOL]     if (suppressTrailingZeroElements) { [EOL]         String tmp = StringUtils.replaceOnce(duration, " 0 seconds", ""); [EOL]         if (tmp.length() != duration.length()) { [EOL]             duration = tmp; [EOL]             tmp = StringUtils.replaceOnce(duration, " 0 minutes", ""); [EOL]             if (tmp.length() != duration.length()) { [EOL]                 duration = tmp; [EOL]                 tmp = StringUtils.replaceOnce(duration, " 0 hours", ""); [EOL]                 if (tmp.length() != duration.length()) { [EOL]                     duration = StringUtils.replaceOnce(tmp, " 0 days", ""); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     duration = " " + duration; [EOL]     duration = StringUtils.replaceOnce(duration, " 1 seconds", " 1 second"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 minutes", " 1 minute"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 hours", " 1 hour"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 days", " 1 day"); [EOL]     return duration.trim(); [EOL] } 
 [LINE] if (tmp.length() != duration.length()) { [LINE] public static String formatDurationWords(final long durationMillis, final boolean suppressLeadingZeroElements, final boolean suppressTrailingZeroElements) { [EOL]     String duration = formatDuration(durationMillis, "d' days 'H' hours 'm' minutes 's' seconds'"); [EOL]     if (suppressLeadingZeroElements) { [EOL]         duration = " " + duration; [EOL]         String tmp = StringUtils.replaceOnce(duration, " 0 days", ""); [EOL]         if (tmp.length() != duration.length()) { [EOL]             duration = tmp; [EOL]             tmp = StringUtils.replaceOnce(duration, " 0 hours", ""); [EOL]             if (tmp.length() != duration.length()) { [EOL]                 duration = tmp; [EOL]                 tmp = StringUtils.replaceOnce(duration, " 0 minutes", ""); [EOL]                 duration = tmp; [EOL]                 if (tmp.length() != duration.length()) { [EOL]                     duration = StringUtils.replaceOnce(tmp, " 0 seconds", ""); [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (duration.length() != 0) { [EOL]             duration = duration.substring(1); [EOL]         } [EOL]     } [EOL]     if (suppressTrailingZeroElements) { [EOL]         String tmp = StringUtils.replaceOnce(duration, " 0 seconds", ""); [EOL]         if (tmp.length() != duration.length()) { [EOL]             duration = tmp; [EOL]             tmp = StringUtils.replaceOnce(duration, " 0 minutes", ""); [EOL]             if (tmp.length() != duration.length()) { [EOL]                 duration = tmp; [EOL]                 tmp = StringUtils.replaceOnce(duration, " 0 hours", ""); [EOL]                 if (tmp.length() != duration.length()) { [EOL]                     duration = StringUtils.replaceOnce(tmp, " 0 days", ""); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     duration = " " + duration; [EOL]     duration = StringUtils.replaceOnce(duration, " 1 seconds", " 1 second"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 minutes", " 1 minute"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 hours", " 1 hour"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 days", " 1 day"); [EOL]     return duration.trim(); [EOL] } 
 [LINE] duration = tmp; [LINE] public static String formatDurationWords(final long durationMillis, final boolean suppressLeadingZeroElements, final boolean suppressTrailingZeroElements) { [EOL]     String duration = formatDuration(durationMillis, "d' days 'H' hours 'm' minutes 's' seconds'"); [EOL]     if (suppressLeadingZeroElements) { [EOL]         duration = " " + duration; [EOL]         String tmp = StringUtils.replaceOnce(duration, " 0 days", ""); [EOL]         if (tmp.length() != duration.length()) { [EOL]             duration = tmp; [EOL]             tmp = StringUtils.replaceOnce(duration, " 0 hours", ""); [EOL]             if (tmp.length() != duration.length()) { [EOL]                 duration = tmp; [EOL]                 tmp = StringUtils.replaceOnce(duration, " 0 minutes", ""); [EOL]                 duration = tmp; [EOL]                 if (tmp.length() != duration.length()) { [EOL]                     duration = StringUtils.replaceOnce(tmp, " 0 seconds", ""); [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (duration.length() != 0) { [EOL]             duration = duration.substring(1); [EOL]         } [EOL]     } [EOL]     if (suppressTrailingZeroElements) { [EOL]         String tmp = StringUtils.replaceOnce(duration, " 0 seconds", ""); [EOL]         if (tmp.length() != duration.length()) { [EOL]             duration = tmp; [EOL]             tmp = StringUtils.replaceOnce(duration, " 0 minutes", ""); [EOL]             if (tmp.length() != duration.length()) { [EOL]                 duration = tmp; [EOL]                 tmp = StringUtils.replaceOnce(duration, " 0 hours", ""); [EOL]                 if (tmp.length() != duration.length()) { [EOL]                     duration = StringUtils.replaceOnce(tmp, " 0 days", ""); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     duration = " " + duration; [EOL]     duration = StringUtils.replaceOnce(duration, " 1 seconds", " 1 second"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 minutes", " 1 minute"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 hours", " 1 hour"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 days", " 1 day"); [EOL]     return duration.trim(); [EOL] } 
 [LINE] tmp = StringUtils.replaceOnce(duration, " 0 hours", ""); [LINE] public static String formatDurationWords(final long durationMillis, final boolean suppressLeadingZeroElements, final boolean suppressTrailingZeroElements) { [EOL]     String duration = formatDuration(durationMillis, "d' days 'H' hours 'm' minutes 's' seconds'"); [EOL]     if (suppressLeadingZeroElements) { [EOL]         duration = " " + duration; [EOL]         String tmp = StringUtils.replaceOnce(duration, " 0 days", ""); [EOL]         if (tmp.length() != duration.length()) { [EOL]             duration = tmp; [EOL]             tmp = StringUtils.replaceOnce(duration, " 0 hours", ""); [EOL]             if (tmp.length() != duration.length()) { [EOL]                 duration = tmp; [EOL]                 tmp = StringUtils.replaceOnce(duration, " 0 minutes", ""); [EOL]                 duration = tmp; [EOL]                 if (tmp.length() != duration.length()) { [EOL]                     duration = StringUtils.replaceOnce(tmp, " 0 seconds", ""); [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (duration.length() != 0) { [EOL]             duration = duration.substring(1); [EOL]         } [EOL]     } [EOL]     if (suppressTrailingZeroElements) { [EOL]         String tmp = StringUtils.replaceOnce(duration, " 0 seconds", ""); [EOL]         if (tmp.length() != duration.length()) { [EOL]             duration = tmp; [EOL]             tmp = StringUtils.replaceOnce(duration, " 0 minutes", ""); [EOL]             if (tmp.length() != duration.length()) { [EOL]                 duration = tmp; [EOL]                 tmp = StringUtils.replaceOnce(duration, " 0 hours", ""); [EOL]                 if (tmp.length() != duration.length()) { [EOL]                     duration = StringUtils.replaceOnce(tmp, " 0 days", ""); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     duration = " " + duration; [EOL]     duration = StringUtils.replaceOnce(duration, " 1 seconds", " 1 second"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 minutes", " 1 minute"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 hours", " 1 hour"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 days", " 1 day"); [EOL]     return duration.trim(); [EOL] } 
 [LINE] if (tmp.length() != duration.length()) { [LINE] public static String formatDurationWords(final long durationMillis, final boolean suppressLeadingZeroElements, final boolean suppressTrailingZeroElements) { [EOL]     String duration = formatDuration(durationMillis, "d' days 'H' hours 'm' minutes 's' seconds'"); [EOL]     if (suppressLeadingZeroElements) { [EOL]         duration = " " + duration; [EOL]         String tmp = StringUtils.replaceOnce(duration, " 0 days", ""); [EOL]         if (tmp.length() != duration.length()) { [EOL]             duration = tmp; [EOL]             tmp = StringUtils.replaceOnce(duration, " 0 hours", ""); [EOL]             if (tmp.length() != duration.length()) { [EOL]                 duration = tmp; [EOL]                 tmp = StringUtils.replaceOnce(duration, " 0 minutes", ""); [EOL]                 duration = tmp; [EOL]                 if (tmp.length() != duration.length()) { [EOL]                     duration = StringUtils.replaceOnce(tmp, " 0 seconds", ""); [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (duration.length() != 0) { [EOL]             duration = duration.substring(1); [EOL]         } [EOL]     } [EOL]     if (suppressTrailingZeroElements) { [EOL]         String tmp = StringUtils.replaceOnce(duration, " 0 seconds", ""); [EOL]         if (tmp.length() != duration.length()) { [EOL]             duration = tmp; [EOL]             tmp = StringUtils.replaceOnce(duration, " 0 minutes", ""); [EOL]             if (tmp.length() != duration.length()) { [EOL]                 duration = tmp; [EOL]                 tmp = StringUtils.replaceOnce(duration, " 0 hours", ""); [EOL]                 if (tmp.length() != duration.length()) { [EOL]                     duration = StringUtils.replaceOnce(tmp, " 0 days", ""); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     duration = " " + duration; [EOL]     duration = StringUtils.replaceOnce(duration, " 1 seconds", " 1 second"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 minutes", " 1 minute"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 hours", " 1 hour"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 days", " 1 day"); [EOL]     return duration.trim(); [EOL] } 
 [LINE] duration = StringUtils.replaceOnce(tmp, " 0 days", ""); [LINE] public static String formatDurationWords(final long durationMillis, final boolean suppressLeadingZeroElements, final boolean suppressTrailingZeroElements) { [EOL]     String duration = formatDuration(durationMillis, "d' days 'H' hours 'm' minutes 's' seconds'"); [EOL]     if (suppressLeadingZeroElements) { [EOL]         duration = " " + duration; [EOL]         String tmp = StringUtils.replaceOnce(duration, " 0 days", ""); [EOL]         if (tmp.length() != duration.length()) { [EOL]             duration = tmp; [EOL]             tmp = StringUtils.replaceOnce(duration, " 0 hours", ""); [EOL]             if (tmp.length() != duration.length()) { [EOL]                 duration = tmp; [EOL]                 tmp = StringUtils.replaceOnce(duration, " 0 minutes", ""); [EOL]                 duration = tmp; [EOL]                 if (tmp.length() != duration.length()) { [EOL]                     duration = StringUtils.replaceOnce(tmp, " 0 seconds", ""); [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (duration.length() != 0) { [EOL]             duration = duration.substring(1); [EOL]         } [EOL]     } [EOL]     if (suppressTrailingZeroElements) { [EOL]         String tmp = StringUtils.replaceOnce(duration, " 0 seconds", ""); [EOL]         if (tmp.length() != duration.length()) { [EOL]             duration = tmp; [EOL]             tmp = StringUtils.replaceOnce(duration, " 0 minutes", ""); [EOL]             if (tmp.length() != duration.length()) { [EOL]                 duration = tmp; [EOL]                 tmp = StringUtils.replaceOnce(duration, " 0 hours", ""); [EOL]                 if (tmp.length() != duration.length()) { [EOL]                     duration = StringUtils.replaceOnce(tmp, " 0 days", ""); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     duration = " " + duration; [EOL]     duration = StringUtils.replaceOnce(duration, " 1 seconds", " 1 second"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 minutes", " 1 minute"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 hours", " 1 hour"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 days", " 1 day"); [EOL]     return duration.trim(); [EOL] } 
 [LINE] while (years != 0) { [LINE] public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, final TimeZone timezone) { [EOL]     final Token[] tokens = lexx(format); [EOL]     final Calendar start = Calendar.getInstance(timezone); [EOL]     start.setTime(new Date(startMillis)); [EOL]     final Calendar end = Calendar.getInstance(timezone); [EOL]     end.setTime(new Date(endMillis)); [EOL]     int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND); [EOL]     int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND); [EOL]     int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE); [EOL]     int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY); [EOL]     int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH); [EOL]     int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH); [EOL]     int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR); [EOL]     while (milliseconds < 0) { [EOL]         milliseconds += 1000; [EOL]         seconds -= 1; [EOL]     } [EOL]     while (seconds < 0) { [EOL]         seconds += 60; [EOL]         minutes -= 1; [EOL]     } [EOL]     while (minutes < 0) { [EOL]         minutes += 60; [EOL]         hours -= 1; [EOL]     } [EOL]     while (hours < 0) { [EOL]         hours += 24; [EOL]         days -= 1; [EOL]     } [EOL]     if (Token.containsTokenWithValue(tokens, M)) { [EOL]         while (days < 0) { [EOL]             days += start.getActualMaximum(Calendar.DAY_OF_MONTH); [EOL]             months -= 1; [EOL]             start.add(Calendar.MONTH, 1); [EOL]         } [EOL]         while (months < 0) { [EOL]             months += 12; [EOL]             years -= 1; [EOL]         } [EOL]         if (!Token.containsTokenWithValue(tokens, y) && years != 0) { [EOL]             while (years != 0) { [EOL]                 months += 12 * years; [EOL]                 years = 0; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (!Token.containsTokenWithValue(tokens, y)) { [EOL]             int target = end.get(Calendar.YEAR); [EOL]             if (months < 0) { [EOL]                 target -= 1; [EOL]             } [EOL]             while (start.get(Calendar.YEAR) != target) { [EOL]                 days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR); [EOL]                 if (start instanceof GregorianCalendar && start.get(Calendar.MONTH) == Calendar.FEBRUARY && start.get(Calendar.DAY_OF_MONTH) == 29) { [EOL]                     days += 1; [EOL]                 } [EOL]                 start.add(Calendar.YEAR, 1); [EOL]                 days += start.get(Calendar.DAY_OF_YEAR); [EOL]             } [EOL]             years = 0; [EOL]         } [EOL]         while (start.get(Calendar.MONTH) != end.get(Calendar.MONTH)) { [EOL]             days += start.getActualMaximum(Calendar.DAY_OF_MONTH); [EOL]             start.add(Calendar.MONTH, 1); [EOL]         } [EOL]         months = 0; [EOL]         while (days < 0) { [EOL]             days += start.getActualMaximum(Calendar.DAY_OF_MONTH); [EOL]             months -= 1; [EOL]             start.add(Calendar.MONTH, 1); [EOL]         } [EOL]     } [EOL]     if (!Token.containsTokenWithValue(tokens, d)) { [EOL]         hours += 24 * days; [EOL]         days = 0; [EOL]     } [EOL]     if (!Token.containsTokenWithValue(tokens, H)) { [EOL]         minutes += 60 * hours; [EOL]         hours = 0; [EOL]     } [EOL]     if (!Token.containsTokenWithValue(tokens, m)) { [EOL]         seconds += 60 * minutes; [EOL]         minutes = 0; [EOL]     } [EOL]     if (!Token.containsTokenWithValue(tokens, s)) { [EOL]         milliseconds += 1000 * seconds; [EOL]         seconds = 0; [EOL]     } [EOL]     return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros); [EOL] } 
 [LINE] months += 12 * years; [LINE] public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, final TimeZone timezone) { [EOL]     final Token[] tokens = lexx(format); [EOL]     final Calendar start = Calendar.getInstance(timezone); [EOL]     start.setTime(new Date(startMillis)); [EOL]     final Calendar end = Calendar.getInstance(timezone); [EOL]     end.setTime(new Date(endMillis)); [EOL]     int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND); [EOL]     int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND); [EOL]     int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE); [EOL]     int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY); [EOL]     int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH); [EOL]     int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH); [EOL]     int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR); [EOL]     while (milliseconds < 0) { [EOL]         milliseconds += 1000; [EOL]         seconds -= 1; [EOL]     } [EOL]     while (seconds < 0) { [EOL]         seconds += 60; [EOL]         minutes -= 1; [EOL]     } [EOL]     while (minutes < 0) { [EOL]         minutes += 60; [EOL]         hours -= 1; [EOL]     } [EOL]     while (hours < 0) { [EOL]         hours += 24; [EOL]         days -= 1; [EOL]     } [EOL]     if (Token.containsTokenWithValue(tokens, M)) { [EOL]         while (days < 0) { [EOL]             days += start.getActualMaximum(Calendar.DAY_OF_MONTH); [EOL]             months -= 1; [EOL]             start.add(Calendar.MONTH, 1); [EOL]         } [EOL]         while (months < 0) { [EOL]             months += 12; [EOL]             years -= 1; [EOL]         } [EOL]         if (!Token.containsTokenWithValue(tokens, y) && years != 0) { [EOL]             while (years != 0) { [EOL]                 months += 12 * years; [EOL]                 years = 0; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (!Token.containsTokenWithValue(tokens, y)) { [EOL]             int target = end.get(Calendar.YEAR); [EOL]             if (months < 0) { [EOL]                 target -= 1; [EOL]             } [EOL]             while (start.get(Calendar.YEAR) != target) { [EOL]                 days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR); [EOL]                 if (start instanceof GregorianCalendar && start.get(Calendar.MONTH) == Calendar.FEBRUARY && start.get(Calendar.DAY_OF_MONTH) == 29) { [EOL]                     days += 1; [EOL]                 } [EOL]                 start.add(Calendar.YEAR, 1); [EOL]                 days += start.get(Calendar.DAY_OF_YEAR); [EOL]             } [EOL]             years = 0; [EOL]         } [EOL]         while (start.get(Calendar.MONTH) != end.get(Calendar.MONTH)) { [EOL]             days += start.getActualMaximum(Calendar.DAY_OF_MONTH); [EOL]             start.add(Calendar.MONTH, 1); [EOL]         } [EOL]         months = 0; [EOL]         while (days < 0) { [EOL]             days += start.getActualMaximum(Calendar.DAY_OF_MONTH); [EOL]             months -= 1; [EOL]             start.add(Calendar.MONTH, 1); [EOL]         } [EOL]     } [EOL]     if (!Token.containsTokenWithValue(tokens, d)) { [EOL]         hours += 24 * days; [EOL]         days = 0; [EOL]     } [EOL]     if (!Token.containsTokenWithValue(tokens, H)) { [EOL]         minutes += 60 * hours; [EOL]         hours = 0; [EOL]     } [EOL]     if (!Token.containsTokenWithValue(tokens, m)) { [EOL]         seconds += 60 * minutes; [EOL]         minutes = 0; [EOL]     } [EOL]     if (!Token.containsTokenWithValue(tokens, s)) { [EOL]         milliseconds += 1000 * seconds; [EOL]         seconds = 0; [EOL]     } [EOL]     return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros); [EOL] } 
 [LINE] years = 0; [LINE] public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, final TimeZone timezone) { [EOL]     final Token[] tokens = lexx(format); [EOL]     final Calendar start = Calendar.getInstance(timezone); [EOL]     start.setTime(new Date(startMillis)); [EOL]     final Calendar end = Calendar.getInstance(timezone); [EOL]     end.setTime(new Date(endMillis)); [EOL]     int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND); [EOL]     int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND); [EOL]     int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE); [EOL]     int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY); [EOL]     int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH); [EOL]     int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH); [EOL]     int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR); [EOL]     while (milliseconds < 0) { [EOL]         milliseconds += 1000; [EOL]         seconds -= 1; [EOL]     } [EOL]     while (seconds < 0) { [EOL]         seconds += 60; [EOL]         minutes -= 1; [EOL]     } [EOL]     while (minutes < 0) { [EOL]         minutes += 60; [EOL]         hours -= 1; [EOL]     } [EOL]     while (hours < 0) { [EOL]         hours += 24; [EOL]         days -= 1; [EOL]     } [EOL]     if (Token.containsTokenWithValue(tokens, M)) { [EOL]         while (days < 0) { [EOL]             days += start.getActualMaximum(Calendar.DAY_OF_MONTH); [EOL]             months -= 1; [EOL]             start.add(Calendar.MONTH, 1); [EOL]         } [EOL]         while (months < 0) { [EOL]             months += 12; [EOL]             years -= 1; [EOL]         } [EOL]         if (!Token.containsTokenWithValue(tokens, y) && years != 0) { [EOL]             while (years != 0) { [EOL]                 months += 12 * years; [EOL]                 years = 0; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (!Token.containsTokenWithValue(tokens, y)) { [EOL]             int target = end.get(Calendar.YEAR); [EOL]             if (months < 0) { [EOL]                 target -= 1; [EOL]             } [EOL]             while (start.get(Calendar.YEAR) != target) { [EOL]                 days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR); [EOL]                 if (start instanceof GregorianCalendar && start.get(Calendar.MONTH) == Calendar.FEBRUARY && start.get(Calendar.DAY_OF_MONTH) == 29) { [EOL]                     days += 1; [EOL]                 } [EOL]                 start.add(Calendar.YEAR, 1); [EOL]                 days += start.get(Calendar.DAY_OF_YEAR); [EOL]             } [EOL]             years = 0; [EOL]         } [EOL]         while (start.get(Calendar.MONTH) != end.get(Calendar.MONTH)) { [EOL]             days += start.getActualMaximum(Calendar.DAY_OF_MONTH); [EOL]             start.add(Calendar.MONTH, 1); [EOL]         } [EOL]         months = 0; [EOL]         while (days < 0) { [EOL]             days += start.getActualMaximum(Calendar.DAY_OF_MONTH); [EOL]             months -= 1; [EOL]             start.add(Calendar.MONTH, 1); [EOL]         } [EOL]     } [EOL]     if (!Token.containsTokenWithValue(tokens, d)) { [EOL]         hours += 24 * days; [EOL]         days = 0; [EOL]     } [EOL]     if (!Token.containsTokenWithValue(tokens, H)) { [EOL]         minutes += 60 * hours; [EOL]         hours = 0; [EOL]     } [EOL]     if (!Token.containsTokenWithValue(tokens, m)) { [EOL]         seconds += 60 * minutes; [EOL]         minutes = 0; [EOL]     } [EOL]     if (!Token.containsTokenWithValue(tokens, s)) { [EOL]         milliseconds += 1000 * seconds; [EOL]         seconds = 0; [EOL]     } [EOL]     return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros); [EOL] } 
 [LINE] days += 1; [LINE] public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, final TimeZone timezone) { [EOL]     final Token[] tokens = lexx(format); [EOL]     final Calendar start = Calendar.getInstance(timezone); [EOL]     start.setTime(new Date(startMillis)); [EOL]     final Calendar end = Calendar.getInstance(timezone); [EOL]     end.setTime(new Date(endMillis)); [EOL]     int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND); [EOL]     int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND); [EOL]     int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE); [EOL]     int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY); [EOL]     int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH); [EOL]     int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH); [EOL]     int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR); [EOL]     while (milliseconds < 0) { [EOL]         milliseconds += 1000; [EOL]         seconds -= 1; [EOL]     } [EOL]     while (seconds < 0) { [EOL]         seconds += 60; [EOL]         minutes -= 1; [EOL]     } [EOL]     while (minutes < 0) { [EOL]         minutes += 60; [EOL]         hours -= 1; [EOL]     } [EOL]     while (hours < 0) { [EOL]         hours += 24; [EOL]         days -= 1; [EOL]     } [EOL]     if (Token.containsTokenWithValue(tokens, M)) { [EOL]         while (days < 0) { [EOL]             days += start.getActualMaximum(Calendar.DAY_OF_MONTH); [EOL]             months -= 1; [EOL]             start.add(Calendar.MONTH, 1); [EOL]         } [EOL]         while (months < 0) { [EOL]             months += 12; [EOL]             years -= 1; [EOL]         } [EOL]         if (!Token.containsTokenWithValue(tokens, y) && years != 0) { [EOL]             while (years != 0) { [EOL]                 months += 12 * years; [EOL]                 years = 0; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (!Token.containsTokenWithValue(tokens, y)) { [EOL]             int target = end.get(Calendar.YEAR); [EOL]             if (months < 0) { [EOL]                 target -= 1; [EOL]             } [EOL]             while (start.get(Calendar.YEAR) != target) { [EOL]                 days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR); [EOL]                 if (start instanceof GregorianCalendar && start.get(Calendar.MONTH) == Calendar.FEBRUARY && start.get(Calendar.DAY_OF_MONTH) == 29) { [EOL]                     days += 1; [EOL]                 } [EOL]                 start.add(Calendar.YEAR, 1); [EOL]                 days += start.get(Calendar.DAY_OF_YEAR); [EOL]             } [EOL]             years = 0; [EOL]         } [EOL]         while (start.get(Calendar.MONTH) != end.get(Calendar.MONTH)) { [EOL]             days += start.getActualMaximum(Calendar.DAY_OF_MONTH); [EOL]             start.add(Calendar.MONTH, 1); [EOL]         } [EOL]         months = 0; [EOL]         while (days < 0) { [EOL]             days += start.getActualMaximum(Calendar.DAY_OF_MONTH); [EOL]             months -= 1; [EOL]             start.add(Calendar.MONTH, 1); [EOL]         } [EOL]     } [EOL]     if (!Token.containsTokenWithValue(tokens, d)) { [EOL]         hours += 24 * days; [EOL]         days = 0; [EOL]     } [EOL]     if (!Token.containsTokenWithValue(tokens, H)) { [EOL]         minutes += 60 * hours; [EOL]         hours = 0; [EOL]     } [EOL]     if (!Token.containsTokenWithValue(tokens, m)) { [EOL]         seconds += 60 * minutes; [EOL]         minutes = 0; [EOL]     } [EOL]     if (!Token.containsTokenWithValue(tokens, s)) { [EOL]         milliseconds += 1000 * seconds; [EOL]         seconds = 0; [EOL]     } [EOL]     return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros); [EOL] } 
 [LINE] return this.value.toString().equals(tok2.value.toString()); [LINE] @Override [EOL] public boolean equals(final Object obj2) { [EOL]     if (obj2 instanceof Token) { [EOL]         final Token tok2 = (Token) obj2; [EOL]         if (this.value.getClass() != tok2.value.getClass()) { [EOL]             return false; [EOL]         } [EOL]         if (this.count != tok2.count) { [EOL]             return false; [EOL]         } [EOL]         if (this.value instanceof StringBuilder) { [EOL]             return this.value.toString().equals(tok2.value.toString()); [EOL]         } else if (this.value instanceof Number) { [EOL]             return this.value.equals(tok2.value); [EOL]         } else { [EOL]             return this.value == tok2.value; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } 
 [LINE] return this.value.equals(tok2.value); [LINE] @Override [EOL] public boolean equals(final Object obj2) { [EOL]     if (obj2 instanceof Token) { [EOL]         final Token tok2 = (Token) obj2; [EOL]         if (this.value.getClass() != tok2.value.getClass()) { [EOL]             return false; [EOL]         } [EOL]         if (this.count != tok2.count) { [EOL]             return false; [EOL]         } [EOL]         if (this.value instanceof StringBuilder) { [EOL]             return this.value.toString().equals(tok2.value.toString()); [EOL]         } else if (this.value instanceof Number) { [EOL]             return this.value.equals(tok2.value); [EOL]         } else { [EOL]             return this.value == tok2.value; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } 
 [LINE] ConcurrentUtils.handleCause(execex); [LINE] @Override [EOL] public T get() throws ConcurrentException { [EOL]     try { [EOL]         return getFuture().get(); [EOL]     } catch (final ExecutionException execex) { [EOL]         ConcurrentUtils.handleCause(execex); [EOL]         return null; [EOL]     } catch (final InterruptedException iex) { [EOL]         Thread.currentThread().interrupt(); [EOL]         throw new ConcurrentException(iex); [EOL]     } [EOL] } 
 [LINE] Thread.currentThread().interrupt(); [LINE] @Override [EOL] public T get() throws ConcurrentException { [EOL]     try { [EOL]         return getFuture().get(); [EOL]     } catch (final ExecutionException execex) { [EOL]         ConcurrentUtils.handleCause(execex); [EOL]         return null; [EOL]     } catch (final InterruptedException iex) { [EOL]         Thread.currentThread().interrupt(); [EOL]         throw new ConcurrentException(iex); [EOL]     } [EOL] } 
 [LINE] throw new ConcurrentException(iex); [LINE] @Override [EOL] public T get() throws ConcurrentException { [EOL]     try { [EOL]         return getFuture().get(); [EOL]     } catch (final ExecutionException execex) { [EOL]         ConcurrentUtils.handleCause(execex); [EOL]         return null; [EOL]     } catch (final InterruptedException iex) { [EOL]         Thread.currentThread().interrupt(); [EOL]         throw new ConcurrentException(iex); [EOL]     } [EOL] } 
 [LINE] public FieldUtils() { [LINE] public FieldUtils() { [EOL]     super(); [EOL] } 
 [LINE] super(); [LINE] public FieldUtils() { [EOL]     super(); [EOL] } 
 [LINE] public static Field getField(final Class<?> cls, final String fieldName) { [LINE] public static Field getField(final Class<?> cls, final String fieldName) { [EOL]     final Field field = getField(cls, fieldName, false); [EOL]     MemberUtils.setAccessibleWorkaround(field); [EOL]     return field; [EOL] } 
 [LINE] final Field field = getField(cls, fieldName, false); [LINE] public static Field getField(final Class<?> cls, final String fieldName) { [EOL]     final Field field = getField(cls, fieldName, false); [EOL]     MemberUtils.setAccessibleWorkaround(field); [EOL]     return field; [EOL] } 
 [LINE] MemberUtils.setAccessibleWorkaround(field); [LINE] public static Field getField(final Class<?> cls, final String fieldName) { [EOL]     final Field field = getField(cls, fieldName, false); [EOL]     MemberUtils.setAccessibleWorkaround(field); [EOL]     return field; [EOL] } 
 [LINE] return field; [LINE] public static Field getField(final Class<?> cls, final String fieldName) { [EOL]     final Field field = getField(cls, fieldName, false); [EOL]     MemberUtils.setAccessibleWorkaround(field); [EOL]     return field; [EOL] } 
 [LINE] throw new IllegalArgumentException("The class must not be null"); [LINE] public static Field getField(final Class<?> cls, final String fieldName, final boolean forceAccess) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     if (fieldName == null) { [EOL]         throw new IllegalArgumentException("The field name must not be null"); [EOL]     } [EOL]     for (Class<?> acls = cls; acls != null; acls = acls.getSuperclass()) { [EOL]         try { [EOL]             final Field field = acls.getDeclaredField(fieldName); [EOL]             if (!Modifier.isPublic(field.getModifiers())) { [EOL]                 if (forceAccess) { [EOL]                     field.setAccessible(true); [EOL]                 } else { [EOL]                     continue; [EOL]                 } [EOL]             } [EOL]             return field; [EOL]         } catch (final NoSuchFieldException ex) { [EOL]         } [EOL]     } [EOL]     Field match = null; [EOL]     for (final Class<?> class1 : ClassUtils.getAllInterfaces(cls)) { [EOL]         try { [EOL]             final Field test = ((Class<?>) class1).getField(fieldName); [EOL]             if (match != null) { [EOL]                 throw new IllegalArgumentException("Reference to field " + fieldName + " is ambiguous relative to " + cls + "; a matching field exists on two or more implemented interfaces."); [EOL]             } [EOL]             match = test; [EOL]         } catch (final NoSuchFieldException ex) { [EOL]         } [EOL]     } [EOL]     return match; [EOL] } 
 [LINE] throw new IllegalArgumentException("The field name must not be null"); [LINE] public static Field getField(final Class<?> cls, final String fieldName, final boolean forceAccess) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     if (fieldName == null) { [EOL]         throw new IllegalArgumentException("The field name must not be null"); [EOL]     } [EOL]     for (Class<?> acls = cls; acls != null; acls = acls.getSuperclass()) { [EOL]         try { [EOL]             final Field field = acls.getDeclaredField(fieldName); [EOL]             if (!Modifier.isPublic(field.getModifiers())) { [EOL]                 if (forceAccess) { [EOL]                     field.setAccessible(true); [EOL]                 } else { [EOL]                     continue; [EOL]                 } [EOL]             } [EOL]             return field; [EOL]         } catch (final NoSuchFieldException ex) { [EOL]         } [EOL]     } [EOL]     Field match = null; [EOL]     for (final Class<?> class1 : ClassUtils.getAllInterfaces(cls)) { [EOL]         try { [EOL]             final Field test = ((Class<?>) class1).getField(fieldName); [EOL]             if (match != null) { [EOL]                 throw new IllegalArgumentException("Reference to field " + fieldName + " is ambiguous relative to " + cls + "; a matching field exists on two or more implemented interfaces."); [EOL]             } [EOL]             match = test; [EOL]         } catch (final NoSuchFieldException ex) { [EOL]         } [EOL]     } [EOL]     return match; [EOL] } 
 [LINE] if (!Modifier.isPublic(field.getModifiers())) { [LINE] public static Field getField(final Class<?> cls, final String fieldName, final boolean forceAccess) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     if (fieldName == null) { [EOL]         throw new IllegalArgumentException("The field name must not be null"); [EOL]     } [EOL]     for (Class<?> acls = cls; acls != null; acls = acls.getSuperclass()) { [EOL]         try { [EOL]             final Field field = acls.getDeclaredField(fieldName); [EOL]             if (!Modifier.isPublic(field.getModifiers())) { [EOL]                 if (forceAccess) { [EOL]                     field.setAccessible(true); [EOL]                 } else { [EOL]                     continue; [EOL]                 } [EOL]             } [EOL]             return field; [EOL]         } catch (final NoSuchFieldException ex) { [EOL]         } [EOL]     } [EOL]     Field match = null; [EOL]     for (final Class<?> class1 : ClassUtils.getAllInterfaces(cls)) { [EOL]         try { [EOL]             final Field test = ((Class<?>) class1).getField(fieldName); [EOL]             if (match != null) { [EOL]                 throw new IllegalArgumentException("Reference to field " + fieldName + " is ambiguous relative to " + cls + "; a matching field exists on two or more implemented interfaces."); [EOL]             } [EOL]             match = test; [EOL]         } catch (final NoSuchFieldException ex) { [EOL]         } [EOL]     } [EOL]     return match; [EOL] } 
 [LINE] if (forceAccess) { [LINE] public static Field getField(final Class<?> cls, final String fieldName, final boolean forceAccess) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     if (fieldName == null) { [EOL]         throw new IllegalArgumentException("The field name must not be null"); [EOL]     } [EOL]     for (Class<?> acls = cls; acls != null; acls = acls.getSuperclass()) { [EOL]         try { [EOL]             final Field field = acls.getDeclaredField(fieldName); [EOL]             if (!Modifier.isPublic(field.getModifiers())) { [EOL]                 if (forceAccess) { [EOL]                     field.setAccessible(true); [EOL]                 } else { [EOL]                     continue; [EOL]                 } [EOL]             } [EOL]             return field; [EOL]         } catch (final NoSuchFieldException ex) { [EOL]         } [EOL]     } [EOL]     Field match = null; [EOL]     for (final Class<?> class1 : ClassUtils.getAllInterfaces(cls)) { [EOL]         try { [EOL]             final Field test = ((Class<?>) class1).getField(fieldName); [EOL]             if (match != null) { [EOL]                 throw new IllegalArgumentException("Reference to field " + fieldName + " is ambiguous relative to " + cls + "; a matching field exists on two or more implemented interfaces."); [EOL]             } [EOL]             match = test; [EOL]         } catch (final NoSuchFieldException ex) { [EOL]         } [EOL]     } [EOL]     return match; [EOL] } 
 [LINE] field.setAccessible(true); [LINE] public static Field getField(final Class<?> cls, final String fieldName, final boolean forceAccess) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     if (fieldName == null) { [EOL]         throw new IllegalArgumentException("The field name must not be null"); [EOL]     } [EOL]     for (Class<?> acls = cls; acls != null; acls = acls.getSuperclass()) { [EOL]         try { [EOL]             final Field field = acls.getDeclaredField(fieldName); [EOL]             if (!Modifier.isPublic(field.getModifiers())) { [EOL]                 if (forceAccess) { [EOL]                     field.setAccessible(true); [EOL]                 } else { [EOL]                     continue; [EOL]                 } [EOL]             } [EOL]             return field; [EOL]         } catch (final NoSuchFieldException ex) { [EOL]         } [EOL]     } [EOL]     Field match = null; [EOL]     for (final Class<?> class1 : ClassUtils.getAllInterfaces(cls)) { [EOL]         try { [EOL]             final Field test = ((Class<?>) class1).getField(fieldName); [EOL]             if (match != null) { [EOL]                 throw new IllegalArgumentException("Reference to field " + fieldName + " is ambiguous relative to " + cls + "; a matching field exists on two or more implemented interfaces."); [EOL]             } [EOL]             match = test; [EOL]         } catch (final NoSuchFieldException ex) { [EOL]         } [EOL]     } [EOL]     return match; [EOL] } 
 [LINE] continue; [LINE] public static Field getField(final Class<?> cls, final String fieldName, final boolean forceAccess) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     if (fieldName == null) { [EOL]         throw new IllegalArgumentException("The field name must not be null"); [EOL]     } [EOL]     for (Class<?> acls = cls; acls != null; acls = acls.getSuperclass()) { [EOL]         try { [EOL]             final Field field = acls.getDeclaredField(fieldName); [EOL]             if (!Modifier.isPublic(field.getModifiers())) { [EOL]                 if (forceAccess) { [EOL]                     field.setAccessible(true); [EOL]                 } else { [EOL]                     continue; [EOL]                 } [EOL]             } [EOL]             return field; [EOL]         } catch (final NoSuchFieldException ex) { [EOL]         } [EOL]     } [EOL]     Field match = null; [EOL]     for (final Class<?> class1 : ClassUtils.getAllInterfaces(cls)) { [EOL]         try { [EOL]             final Field test = ((Class<?>) class1).getField(fieldName); [EOL]             if (match != null) { [EOL]                 throw new IllegalArgumentException("Reference to field " + fieldName + " is ambiguous relative to " + cls + "; a matching field exists on two or more implemented interfaces."); [EOL]             } [EOL]             match = test; [EOL]         } catch (final NoSuchFieldException ex) { [EOL]         } [EOL]     } [EOL]     return match; [EOL] } 
 [LINE] return field; [LINE] public static Field getField(final Class<?> cls, final String fieldName, final boolean forceAccess) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     if (fieldName == null) { [EOL]         throw new IllegalArgumentException("The field name must not be null"); [EOL]     } [EOL]     for (Class<?> acls = cls; acls != null; acls = acls.getSuperclass()) { [EOL]         try { [EOL]             final Field field = acls.getDeclaredField(fieldName); [EOL]             if (!Modifier.isPublic(field.getModifiers())) { [EOL]                 if (forceAccess) { [EOL]                     field.setAccessible(true); [EOL]                 } else { [EOL]                     continue; [EOL]                 } [EOL]             } [EOL]             return field; [EOL]         } catch (final NoSuchFieldException ex) { [EOL]         } [EOL]     } [EOL]     Field match = null; [EOL]     for (final Class<?> class1 : ClassUtils.getAllInterfaces(cls)) { [EOL]         try { [EOL]             final Field test = ((Class<?>) class1).getField(fieldName); [EOL]             if (match != null) { [EOL]                 throw new IllegalArgumentException("Reference to field " + fieldName + " is ambiguous relative to " + cls + "; a matching field exists on two or more implemented interfaces."); [EOL]             } [EOL]             match = test; [EOL]         } catch (final NoSuchFieldException ex) { [EOL]         } [EOL]     } [EOL]     return match; [EOL] } 
 [LINE] if (match != null) { [LINE] public static Field getField(final Class<?> cls, final String fieldName, final boolean forceAccess) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     if (fieldName == null) { [EOL]         throw new IllegalArgumentException("The field name must not be null"); [EOL]     } [EOL]     for (Class<?> acls = cls; acls != null; acls = acls.getSuperclass()) { [EOL]         try { [EOL]             final Field field = acls.getDeclaredField(fieldName); [EOL]             if (!Modifier.isPublic(field.getModifiers())) { [EOL]                 if (forceAccess) { [EOL]                     field.setAccessible(true); [EOL]                 } else { [EOL]                     continue; [EOL]                 } [EOL]             } [EOL]             return field; [EOL]         } catch (final NoSuchFieldException ex) { [EOL]         } [EOL]     } [EOL]     Field match = null; [EOL]     for (final Class<?> class1 : ClassUtils.getAllInterfaces(cls)) { [EOL]         try { [EOL]             final Field test = ((Class<?>) class1).getField(fieldName); [EOL]             if (match != null) { [EOL]                 throw new IllegalArgumentException("Reference to field " + fieldName + " is ambiguous relative to " + cls + "; a matching field exists on two or more implemented interfaces."); [EOL]             } [EOL]             match = test; [EOL]         } catch (final NoSuchFieldException ex) { [EOL]         } [EOL]     } [EOL]     return match; [EOL] } 
 [LINE] throw new IllegalArgumentException("Reference to field " + fieldName + " is ambiguous relative to " + cls + [LINE] public static Field getField(final Class<?> cls, final String fieldName, final boolean forceAccess) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     if (fieldName == null) { [EOL]         throw new IllegalArgumentException("The field name must not be null"); [EOL]     } [EOL]     for (Class<?> acls = cls; acls != null; acls = acls.getSuperclass()) { [EOL]         try { [EOL]             final Field field = acls.getDeclaredField(fieldName); [EOL]             if (!Modifier.isPublic(field.getModifiers())) { [EOL]                 if (forceAccess) { [EOL]                     field.setAccessible(true); [EOL]                 } else { [EOL]                     continue; [EOL]                 } [EOL]             } [EOL]             return field; [EOL]         } catch (final NoSuchFieldException ex) { [EOL]         } [EOL]     } [EOL]     Field match = null; [EOL]     for (final Class<?> class1 : ClassUtils.getAllInterfaces(cls)) { [EOL]         try { [EOL]             final Field test = ((Class<?>) class1).getField(fieldName); [EOL]             if (match != null) { [EOL]                 throw new IllegalArgumentException("Reference to field " + fieldName + " is ambiguous relative to " + cls + "; a matching field exists on two or more implemented interfaces."); [EOL]             } [EOL]             match = test; [EOL]         } catch (final NoSuchFieldException ex) { [EOL]         } [EOL]     } [EOL]     return match; [EOL] } 
 [LINE] match = test; [LINE] public static Field getField(final Class<?> cls, final String fieldName, final boolean forceAccess) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     if (fieldName == null) { [EOL]         throw new IllegalArgumentException("The field name must not be null"); [EOL]     } [EOL]     for (Class<?> acls = cls; acls != null; acls = acls.getSuperclass()) { [EOL]         try { [EOL]             final Field field = acls.getDeclaredField(fieldName); [EOL]             if (!Modifier.isPublic(field.getModifiers())) { [EOL]                 if (forceAccess) { [EOL]                     field.setAccessible(true); [EOL]                 } else { [EOL]                     continue; [EOL]                 } [EOL]             } [EOL]             return field; [EOL]         } catch (final NoSuchFieldException ex) { [EOL]         } [EOL]     } [EOL]     Field match = null; [EOL]     for (final Class<?> class1 : ClassUtils.getAllInterfaces(cls)) { [EOL]         try { [EOL]             final Field test = ((Class<?>) class1).getField(fieldName); [EOL]             if (match != null) { [EOL]                 throw new IllegalArgumentException("Reference to field " + fieldName + " is ambiguous relative to " + cls + "; a matching field exists on two or more implemented interfaces."); [EOL]             } [EOL]             match = test; [EOL]         } catch (final NoSuchFieldException ex) { [EOL]         } [EOL]     } [EOL]     return match; [EOL] } 
 [LINE] public static Field getDeclaredField(final Class<?> cls, final String fieldName) { [LINE] public static Field getDeclaredField(final Class<?> cls, final String fieldName) { [EOL]     return getDeclaredField(cls, fieldName, false); [EOL] } 
 [LINE] return getDeclaredField(cls, fieldName, false); [LINE] public static Field getDeclaredField(final Class<?> cls, final String fieldName) { [EOL]     return getDeclaredField(cls, fieldName, false); [EOL] } 
 [LINE] public static Field getDeclaredField(final Class<?> cls, final String fieldName, final boolean forceAccess) { [LINE] public static Field getDeclaredField(final Class<?> cls, final String fieldName, final boolean forceAccess) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     if (fieldName == null) { [EOL]         throw new IllegalArgumentException("The field name must not be null"); [EOL]     } [EOL]     try { [EOL]         final Field field = cls.getDeclaredField(fieldName); [EOL]         if (!MemberUtils.isAccessible(field)) { [EOL]             if (forceAccess) { [EOL]                 field.setAccessible(true); [EOL]             } else { [EOL]                 return null; [EOL]             } [EOL]         } [EOL]         return field; [EOL]     } catch (final NoSuchFieldException e) { [EOL]     } [EOL]     return null; [EOL] } 
 [LINE] if (cls == null) { [LINE] public static Field getDeclaredField(final Class<?> cls, final String fieldName, final boolean forceAccess) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     if (fieldName == null) { [EOL]         throw new IllegalArgumentException("The field name must not be null"); [EOL]     } [EOL]     try { [EOL]         final Field field = cls.getDeclaredField(fieldName); [EOL]         if (!MemberUtils.isAccessible(field)) { [EOL]             if (forceAccess) { [EOL]                 field.setAccessible(true); [EOL]             } else { [EOL]                 return null; [EOL]             } [EOL]         } [EOL]         return field; [EOL]     } catch (final NoSuchFieldException e) { [EOL]     } [EOL]     return null; [EOL] } 
 [LINE] throw new IllegalArgumentException("The class must not be null"); [LINE] public static Field getDeclaredField(final Class<?> cls, final String fieldName, final boolean forceAccess) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     if (fieldName == null) { [EOL]         throw new IllegalArgumentException("The field name must not be null"); [EOL]     } [EOL]     try { [EOL]         final Field field = cls.getDeclaredField(fieldName); [EOL]         if (!MemberUtils.isAccessible(field)) { [EOL]             if (forceAccess) { [EOL]                 field.setAccessible(true); [EOL]             } else { [EOL]                 return null; [EOL]             } [EOL]         } [EOL]         return field; [EOL]     } catch (final NoSuchFieldException e) { [EOL]     } [EOL]     return null; [EOL] } 
 [LINE] if (fieldName == null) { [LINE] public static Field getDeclaredField(final Class<?> cls, final String fieldName, final boolean forceAccess) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     if (fieldName == null) { [EOL]         throw new IllegalArgumentException("The field name must not be null"); [EOL]     } [EOL]     try { [EOL]         final Field field = cls.getDeclaredField(fieldName); [EOL]         if (!MemberUtils.isAccessible(field)) { [EOL]             if (forceAccess) { [EOL]                 field.setAccessible(true); [EOL]             } else { [EOL]                 return null; [EOL]             } [EOL]         } [EOL]         return field; [EOL]     } catch (final NoSuchFieldException e) { [EOL]     } [EOL]     return null; [EOL] } 
 [LINE] throw new IllegalArgumentException("The field name must not be null"); [LINE] public static Field getDeclaredField(final Class<?> cls, final String fieldName, final boolean forceAccess) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     if (fieldName == null) { [EOL]         throw new IllegalArgumentException("The field name must not be null"); [EOL]     } [EOL]     try { [EOL]         final Field field = cls.getDeclaredField(fieldName); [EOL]         if (!MemberUtils.isAccessible(field)) { [EOL]             if (forceAccess) { [EOL]                 field.setAccessible(true); [EOL]             } else { [EOL]                 return null; [EOL]             } [EOL]         } [EOL]         return field; [EOL]     } catch (final NoSuchFieldException e) { [EOL]     } [EOL]     return null; [EOL] } 
 [LINE] try { [LINE] public static Field getDeclaredField(final Class<?> cls, final String fieldName, final boolean forceAccess) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     if (fieldName == null) { [EOL]         throw new IllegalArgumentException("The field name must not be null"); [EOL]     } [EOL]     try { [EOL]         final Field field = cls.getDeclaredField(fieldName); [EOL]         if (!MemberUtils.isAccessible(field)) { [EOL]             if (forceAccess) { [EOL]                 field.setAccessible(true); [EOL]             } else { [EOL]                 return null; [EOL]             } [EOL]         } [EOL]         return field; [EOL]     } catch (final NoSuchFieldException e) { [EOL]     } [EOL]     return null; [EOL] } 
 [LINE] final Field field = cls.getDeclaredField(fieldName); [LINE] public static Field getDeclaredField(final Class<?> cls, final String fieldName, final boolean forceAccess) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     if (fieldName == null) { [EOL]         throw new IllegalArgumentException("The field name must not be null"); [EOL]     } [EOL]     try { [EOL]         final Field field = cls.getDeclaredField(fieldName); [EOL]         if (!MemberUtils.isAccessible(field)) { [EOL]             if (forceAccess) { [EOL]                 field.setAccessible(true); [EOL]             } else { [EOL]                 return null; [EOL]             } [EOL]         } [EOL]         return field; [EOL]     } catch (final NoSuchFieldException e) { [EOL]     } [EOL]     return null; [EOL] } 
 [LINE] if (!MemberUtils.isAccessible(field)) { [LINE] public static Field getDeclaredField(final Class<?> cls, final String fieldName, final boolean forceAccess) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     if (fieldName == null) { [EOL]         throw new IllegalArgumentException("The field name must not be null"); [EOL]     } [EOL]     try { [EOL]         final Field field = cls.getDeclaredField(fieldName); [EOL]         if (!MemberUtils.isAccessible(field)) { [EOL]             if (forceAccess) { [EOL]                 field.setAccessible(true); [EOL]             } else { [EOL]                 return null; [EOL]             } [EOL]         } [EOL]         return field; [EOL]     } catch (final NoSuchFieldException e) { [EOL]     } [EOL]     return null; [EOL] } 
 [LINE] if (forceAccess) { [LINE] public static Field getDeclaredField(final Class<?> cls, final String fieldName, final boolean forceAccess) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     if (fieldName == null) { [EOL]         throw new IllegalArgumentException("The field name must not be null"); [EOL]     } [EOL]     try { [EOL]         final Field field = cls.getDeclaredField(fieldName); [EOL]         if (!MemberUtils.isAccessible(field)) { [EOL]             if (forceAccess) { [EOL]                 field.setAccessible(true); [EOL]             } else { [EOL]                 return null; [EOL]             } [EOL]         } [EOL]         return field; [EOL]     } catch (final NoSuchFieldException e) { [EOL]     } [EOL]     return null; [EOL] } 
 [LINE] field.setAccessible(true); [LINE] public static Field getDeclaredField(final Class<?> cls, final String fieldName, final boolean forceAccess) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     if (fieldName == null) { [EOL]         throw new IllegalArgumentException("The field name must not be null"); [EOL]     } [EOL]     try { [EOL]         final Field field = cls.getDeclaredField(fieldName); [EOL]         if (!MemberUtils.isAccessible(field)) { [EOL]             if (forceAccess) { [EOL]                 field.setAccessible(true); [EOL]             } else { [EOL]                 return null; [EOL]             } [EOL]         } [EOL]         return field; [EOL]     } catch (final NoSuchFieldException e) { [EOL]     } [EOL]     return null; [EOL] } 
 [LINE] return null; [LINE] public static Field getDeclaredField(final Class<?> cls, final String fieldName, final boolean forceAccess) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     if (fieldName == null) { [EOL]         throw new IllegalArgumentException("The field name must not be null"); [EOL]     } [EOL]     try { [EOL]         final Field field = cls.getDeclaredField(fieldName); [EOL]         if (!MemberUtils.isAccessible(field)) { [EOL]             if (forceAccess) { [EOL]                 field.setAccessible(true); [EOL]             } else { [EOL]                 return null; [EOL]             } [EOL]         } [EOL]         return field; [EOL]     } catch (final NoSuchFieldException e) { [EOL]     } [EOL]     return null; [EOL] } 
 [LINE] return field; [LINE] public static Field getDeclaredField(final Class<?> cls, final String fieldName, final boolean forceAccess) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     if (fieldName == null) { [EOL]         throw new IllegalArgumentException("The field name must not be null"); [EOL]     } [EOL]     try { [EOL]         final Field field = cls.getDeclaredField(fieldName); [EOL]         if (!MemberUtils.isAccessible(field)) { [EOL]             if (forceAccess) { [EOL]                 field.setAccessible(true); [EOL]             } else { [EOL]                 return null; [EOL]             } [EOL]         } [EOL]         return field; [EOL]     } catch (final NoSuchFieldException e) { [EOL]     } [EOL]     return null; [EOL] } 
 [LINE] return null; [LINE] public static Field getDeclaredField(final Class<?> cls, final String fieldName, final boolean forceAccess) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     if (fieldName == null) { [EOL]         throw new IllegalArgumentException("The field name must not be null"); [EOL]     } [EOL]     try { [EOL]         final Field field = cls.getDeclaredField(fieldName); [EOL]         if (!MemberUtils.isAccessible(field)) { [EOL]             if (forceAccess) { [EOL]                 field.setAccessible(true); [EOL]             } else { [EOL]                 return null; [EOL]             } [EOL]         } [EOL]         return field; [EOL]     } catch (final NoSuchFieldException e) { [EOL]     } [EOL]     return null; [EOL] } 
 [LINE] public static Field[] getAllFields(Class<?> cls) { [LINE] public static Field[] getAllFields(Class<?> cls) { [EOL]     final List<Field> allFieldsList = getAllFieldsList(cls); [EOL]     return allFieldsList.toArray(new Field[allFieldsList.size()]); [EOL] } 
 [LINE] final List<Field> allFieldsList = getAllFieldsList(cls); [LINE] public static Field[] getAllFields(Class<?> cls) { [EOL]     final List<Field> allFieldsList = getAllFieldsList(cls); [EOL]     return allFieldsList.toArray(new Field[allFieldsList.size()]); [EOL] } 
 [LINE] return allFieldsList.toArray(new Field[allFieldsList.size()]); [LINE] public static Field[] getAllFields(Class<?> cls) { [EOL]     final List<Field> allFieldsList = getAllFieldsList(cls); [EOL]     return allFieldsList.toArray(new Field[allFieldsList.size()]); [EOL] } 
 [LINE] public static List<Field> getAllFieldsList(Class<?> cls) { [LINE] public static List<Field> getAllFieldsList(Class<?> cls) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     List<Field> allFields = new ArrayList<Field>(); [EOL]     Class<?> currentClass = cls; [EOL]     while (currentClass != null) { [EOL]         final Field[] declaredFields = currentClass.getDeclaredFields(); [EOL]         for (Field field : declaredFields) { [EOL]             allFields.add(field); [EOL]         } [EOL]         currentClass = currentClass.getSuperclass(); [EOL]     } [EOL]     return allFields; [EOL] } 
 [LINE] if (cls == null) { [LINE] public static List<Field> getAllFieldsList(Class<?> cls) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     List<Field> allFields = new ArrayList<Field>(); [EOL]     Class<?> currentClass = cls; [EOL]     while (currentClass != null) { [EOL]         final Field[] declaredFields = currentClass.getDeclaredFields(); [EOL]         for (Field field : declaredFields) { [EOL]             allFields.add(field); [EOL]         } [EOL]         currentClass = currentClass.getSuperclass(); [EOL]     } [EOL]     return allFields; [EOL] } 
 [LINE] List<Field> allFields = new ArrayList<Field>(); [LINE] public static List<Field> getAllFieldsList(Class<?> cls) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     List<Field> allFields = new ArrayList<Field>(); [EOL]     Class<?> currentClass = cls; [EOL]     while (currentClass != null) { [EOL]         final Field[] declaredFields = currentClass.getDeclaredFields(); [EOL]         for (Field field : declaredFields) { [EOL]             allFields.add(field); [EOL]         } [EOL]         currentClass = currentClass.getSuperclass(); [EOL]     } [EOL]     return allFields; [EOL] } 
 [LINE] Class<?> currentClass = cls; [LINE] public static List<Field> getAllFieldsList(Class<?> cls) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     List<Field> allFields = new ArrayList<Field>(); [EOL]     Class<?> currentClass = cls; [EOL]     while (currentClass != null) { [EOL]         final Field[] declaredFields = currentClass.getDeclaredFields(); [EOL]         for (Field field : declaredFields) { [EOL]             allFields.add(field); [EOL]         } [EOL]         currentClass = currentClass.getSuperclass(); [EOL]     } [EOL]     return allFields; [EOL] } 
 [LINE] while (currentClass != null) { [LINE] public static List<Field> getAllFieldsList(Class<?> cls) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     List<Field> allFields = new ArrayList<Field>(); [EOL]     Class<?> currentClass = cls; [EOL]     while (currentClass != null) { [EOL]         final Field[] declaredFields = currentClass.getDeclaredFields(); [EOL]         for (Field field : declaredFields) { [EOL]             allFields.add(field); [EOL]         } [EOL]         currentClass = currentClass.getSuperclass(); [EOL]     } [EOL]     return allFields; [EOL] } 
 [LINE] final Field[] declaredFields = currentClass.getDeclaredFields(); [LINE] public static List<Field> getAllFieldsList(Class<?> cls) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     List<Field> allFields = new ArrayList<Field>(); [EOL]     Class<?> currentClass = cls; [EOL]     while (currentClass != null) { [EOL]         final Field[] declaredFields = currentClass.getDeclaredFields(); [EOL]         for (Field field : declaredFields) { [EOL]             allFields.add(field); [EOL]         } [EOL]         currentClass = currentClass.getSuperclass(); [EOL]     } [EOL]     return allFields; [EOL] } 
 [LINE] for (Field field : declaredFields) { [LINE] public static List<Field> getAllFieldsList(Class<?> cls) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     List<Field> allFields = new ArrayList<Field>(); [EOL]     Class<?> currentClass = cls; [EOL]     while (currentClass != null) { [EOL]         final Field[] declaredFields = currentClass.getDeclaredFields(); [EOL]         for (Field field : declaredFields) { [EOL]             allFields.add(field); [EOL]         } [EOL]         currentClass = currentClass.getSuperclass(); [EOL]     } [EOL]     return allFields; [EOL] } 
 [LINE] allFields.add(field); [LINE] public static List<Field> getAllFieldsList(Class<?> cls) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     List<Field> allFields = new ArrayList<Field>(); [EOL]     Class<?> currentClass = cls; [EOL]     while (currentClass != null) { [EOL]         final Field[] declaredFields = currentClass.getDeclaredFields(); [EOL]         for (Field field : declaredFields) { [EOL]             allFields.add(field); [EOL]         } [EOL]         currentClass = currentClass.getSuperclass(); [EOL]     } [EOL]     return allFields; [EOL] } 
 [LINE] currentClass = currentClass.getSuperclass(); [LINE] public static List<Field> getAllFieldsList(Class<?> cls) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     List<Field> allFields = new ArrayList<Field>(); [EOL]     Class<?> currentClass = cls; [EOL]     while (currentClass != null) { [EOL]         final Field[] declaredFields = currentClass.getDeclaredFields(); [EOL]         for (Field field : declaredFields) { [EOL]             allFields.add(field); [EOL]         } [EOL]         currentClass = currentClass.getSuperclass(); [EOL]     } [EOL]     return allFields; [EOL] } 
 [LINE] return allFields; [LINE] public static List<Field> getAllFieldsList(Class<?> cls) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     List<Field> allFields = new ArrayList<Field>(); [EOL]     Class<?> currentClass = cls; [EOL]     while (currentClass != null) { [EOL]         final Field[] declaredFields = currentClass.getDeclaredFields(); [EOL]         for (Field field : declaredFields) { [EOL]             allFields.add(field); [EOL]         } [EOL]         currentClass = currentClass.getSuperclass(); [EOL]     } [EOL]     return allFields; [EOL] } 
 [LINE] public static Object readStaticField(final Field field) throws IllegalAccessException { [LINE] public static Object readStaticField(final Field field) throws IllegalAccessException { [EOL]     return readStaticField(field, false); [EOL] } 
 [LINE] return readStaticField(field, false); [LINE] public static Object readStaticField(final Field field) throws IllegalAccessException { [EOL]     return readStaticField(field, false); [EOL] } 
 [LINE] public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException { [LINE] public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("The field must not be null"); [EOL]     } [EOL]     if (!Modifier.isStatic(field.getModifiers())) { [EOL]         throw new IllegalArgumentException("The field '" + field.getName() + "' is not static"); [EOL]     } [EOL]     return readField(field, (Object) null, forceAccess); [EOL] } 
 [LINE] if (field == null) { [LINE] public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("The field must not be null"); [EOL]     } [EOL]     if (!Modifier.isStatic(field.getModifiers())) { [EOL]         throw new IllegalArgumentException("The field '" + field.getName() + "' is not static"); [EOL]     } [EOL]     return readField(field, (Object) null, forceAccess); [EOL] } 
 [LINE] throw new IllegalArgumentException("The field must not be null"); [LINE] public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("The field must not be null"); [EOL]     } [EOL]     if (!Modifier.isStatic(field.getModifiers())) { [EOL]         throw new IllegalArgumentException("The field '" + field.getName() + "' is not static"); [EOL]     } [EOL]     return readField(field, (Object) null, forceAccess); [EOL] } 
 [LINE] if (!Modifier.isStatic(field.getModifiers())) { [LINE] public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("The field must not be null"); [EOL]     } [EOL]     if (!Modifier.isStatic(field.getModifiers())) { [EOL]         throw new IllegalArgumentException("The field '" + field.getName() + "' is not static"); [EOL]     } [EOL]     return readField(field, (Object) null, forceAccess); [EOL] } 
 [LINE] throw new IllegalArgumentException("The field '" + field.getName() + "' is not static"); [LINE] public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("The field must not be null"); [EOL]     } [EOL]     if (!Modifier.isStatic(field.getModifiers())) { [EOL]         throw new IllegalArgumentException("The field '" + field.getName() + "' is not static"); [EOL]     } [EOL]     return readField(field, (Object) null, forceAccess); [EOL] } 
 [LINE] return readField(field, (Object) null, forceAccess); [LINE] public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("The field must not be null"); [EOL]     } [EOL]     if (!Modifier.isStatic(field.getModifiers())) { [EOL]         throw new IllegalArgumentException("The field '" + field.getName() + "' is not static"); [EOL]     } [EOL]     return readField(field, (Object) null, forceAccess); [EOL] } 
 [LINE] public static Object readStaticField(final Class<?> cls, final String fieldName) throws IllegalAccessException { [LINE] public static Object readStaticField(final Class<?> cls, final String fieldName) throws IllegalAccessException { [EOL]     return readStaticField(cls, fieldName, false); [EOL] } 
 [LINE] return readStaticField(cls, fieldName, false); [LINE] public static Object readStaticField(final Class<?> cls, final String fieldName) throws IllegalAccessException { [EOL]     return readStaticField(cls, fieldName, false); [EOL] } 
 [LINE] public static Object readStaticField(final Class<?> cls, final String fieldName, final boolean forceAccess) throws IllegalAccessException { [LINE] public static Object readStaticField(final Class<?> cls, final String fieldName, final boolean forceAccess) throws IllegalAccessException { [EOL]     final Field field = getField(cls, fieldName, forceAccess); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Cannot locate field " + fieldName + " on " + cls); [EOL]     } [EOL]     return readStaticField(field, false); [EOL] } 
 [LINE] final Field field = getField(cls, fieldName, forceAccess); [LINE] public static Object readStaticField(final Class<?> cls, final String fieldName, final boolean forceAccess) throws IllegalAccessException { [EOL]     final Field field = getField(cls, fieldName, forceAccess); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Cannot locate field " + fieldName + " on " + cls); [EOL]     } [EOL]     return readStaticField(field, false); [EOL] } 
 [LINE] if (field == null) { [LINE] public static Object readStaticField(final Class<?> cls, final String fieldName, final boolean forceAccess) throws IllegalAccessException { [EOL]     final Field field = getField(cls, fieldName, forceAccess); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Cannot locate field " + fieldName + " on " + cls); [EOL]     } [EOL]     return readStaticField(field, false); [EOL] } 
 [LINE] throw new IllegalArgumentException("Cannot locate field " + fieldName + " on " + cls); [LINE] public static Object readStaticField(final Class<?> cls, final String fieldName, final boolean forceAccess) throws IllegalAccessException { [EOL]     final Field field = getField(cls, fieldName, forceAccess); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Cannot locate field " + fieldName + " on " + cls); [EOL]     } [EOL]     return readStaticField(field, false); [EOL] } 
 [LINE] return readStaticField(field, false); [LINE] public static Object readStaticField(final Class<?> cls, final String fieldName, final boolean forceAccess) throws IllegalAccessException { [EOL]     final Field field = getField(cls, fieldName, forceAccess); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Cannot locate field " + fieldName + " on " + cls); [EOL]     } [EOL]     return readStaticField(field, false); [EOL] } 
 [LINE] public static Object readDeclaredStaticField(final Class<?> cls, final String fieldName) throws IllegalAccessException { [LINE] public static Object readDeclaredStaticField(final Class<?> cls, final String fieldName) throws IllegalAccessException { [EOL]     return readDeclaredStaticField(cls, fieldName, false); [EOL] } 
 [LINE] return readDeclaredStaticField(cls, fieldName, false); [LINE] public static Object readDeclaredStaticField(final Class<?> cls, final String fieldName) throws IllegalAccessException { [EOL]     return readDeclaredStaticField(cls, fieldName, false); [EOL] } 
 [LINE] public static Object readDeclaredStaticField(final Class<?> cls, final String fieldName, final boolean forceAccess) throws IllegalAccessException { [LINE] public static Object readDeclaredStaticField(final Class<?> cls, final String fieldName, final boolean forceAccess) throws IllegalAccessException { [EOL]     final Field field = getDeclaredField(cls, fieldName, forceAccess); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Cannot locate declared field " + cls.getName() + "." + fieldName); [EOL]     } [EOL]     return readStaticField(field, false); [EOL] } 
 [LINE] final Field field = getDeclaredField(cls, fieldName, forceAccess); [LINE] public static Object readDeclaredStaticField(final Class<?> cls, final String fieldName, final boolean forceAccess) throws IllegalAccessException { [EOL]     final Field field = getDeclaredField(cls, fieldName, forceAccess); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Cannot locate declared field " + cls.getName() + "." + fieldName); [EOL]     } [EOL]     return readStaticField(field, false); [EOL] } 
 [LINE] if (field == null) { [LINE] public static Object readDeclaredStaticField(final Class<?> cls, final String fieldName, final boolean forceAccess) throws IllegalAccessException { [EOL]     final Field field = getDeclaredField(cls, fieldName, forceAccess); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Cannot locate declared field " + cls.getName() + "." + fieldName); [EOL]     } [EOL]     return readStaticField(field, false); [EOL] } 
 [LINE] throw new IllegalArgumentException("Cannot locate declared field " + cls.getName() + "." + fieldName); [LINE] public static Object readDeclaredStaticField(final Class<?> cls, final String fieldName, final boolean forceAccess) throws IllegalAccessException { [EOL]     final Field field = getDeclaredField(cls, fieldName, forceAccess); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Cannot locate declared field " + cls.getName() + "." + fieldName); [EOL]     } [EOL]     return readStaticField(field, false); [EOL] } 
 [LINE] return readStaticField(field, false); [LINE] public static Object readDeclaredStaticField(final Class<?> cls, final String fieldName, final boolean forceAccess) throws IllegalAccessException { [EOL]     final Field field = getDeclaredField(cls, fieldName, forceAccess); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Cannot locate declared field " + cls.getName() + "." + fieldName); [EOL]     } [EOL]     return readStaticField(field, false); [EOL] } 
 [LINE] public static Object readField(final Field field, final Object target) throws IllegalAccessException { [LINE] public static Object readField(final Field field, final Object target) throws IllegalAccessException { [EOL]     return readField(field, target, false); [EOL] } 
 [LINE] return readField(field, target, false); [LINE] public static Object readField(final Field field, final Object target) throws IllegalAccessException { [EOL]     return readField(field, target, false); [EOL] } 
 [LINE] public static Object readField(final Field field, final Object target, final boolean forceAccess) throws IllegalAccessException { [LINE] public static Object readField(final Field field, final Object target, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("The field must not be null"); [EOL]     } [EOL]     if (forceAccess && !field.isAccessible()) { [EOL]         field.setAccessible(true); [EOL]     } else { [EOL]         MemberUtils.setAccessibleWorkaround(field); [EOL]     } [EOL]     return field.get(target); [EOL] } 
 [LINE] if (field == null) { [LINE] public static Object readField(final Field field, final Object target, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("The field must not be null"); [EOL]     } [EOL]     if (forceAccess && !field.isAccessible()) { [EOL]         field.setAccessible(true); [EOL]     } else { [EOL]         MemberUtils.setAccessibleWorkaround(field); [EOL]     } [EOL]     return field.get(target); [EOL] } 
 [LINE] throw new IllegalArgumentException("The field must not be null"); [LINE] public static Object readField(final Field field, final Object target, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("The field must not be null"); [EOL]     } [EOL]     if (forceAccess && !field.isAccessible()) { [EOL]         field.setAccessible(true); [EOL]     } else { [EOL]         MemberUtils.setAccessibleWorkaround(field); [EOL]     } [EOL]     return field.get(target); [EOL] } 
 [LINE] if (forceAccess && !field.isAccessible()) { [LINE] public static Object readField(final Field field, final Object target, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("The field must not be null"); [EOL]     } [EOL]     if (forceAccess && !field.isAccessible()) { [EOL]         field.setAccessible(true); [EOL]     } else { [EOL]         MemberUtils.setAccessibleWorkaround(field); [EOL]     } [EOL]     return field.get(target); [EOL] } 
 [LINE] field.setAccessible(true); [LINE] public static Object readField(final Field field, final Object target, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("The field must not be null"); [EOL]     } [EOL]     if (forceAccess && !field.isAccessible()) { [EOL]         field.setAccessible(true); [EOL]     } else { [EOL]         MemberUtils.setAccessibleWorkaround(field); [EOL]     } [EOL]     return field.get(target); [EOL] } 
 [LINE] MemberUtils.setAccessibleWorkaround(field); [LINE] public static Object readField(final Field field, final Object target, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("The field must not be null"); [EOL]     } [EOL]     if (forceAccess && !field.isAccessible()) { [EOL]         field.setAccessible(true); [EOL]     } else { [EOL]         MemberUtils.setAccessibleWorkaround(field); [EOL]     } [EOL]     return field.get(target); [EOL] } 
 [LINE] return field.get(target); [LINE] public static Object readField(final Field field, final Object target, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("The field must not be null"); [EOL]     } [EOL]     if (forceAccess && !field.isAccessible()) { [EOL]         field.setAccessible(true); [EOL]     } else { [EOL]         MemberUtils.setAccessibleWorkaround(field); [EOL]     } [EOL]     return field.get(target); [EOL] } 
 [LINE] public static Object readField(final Object target, final String fieldName) throws IllegalAccessException { [LINE] public static Object readField(final Object target, final String fieldName) throws IllegalAccessException { [EOL]     return readField(target, fieldName, false); [EOL] } 
 [LINE] return readField(target, fieldName, false); [LINE] public static Object readField(final Object target, final String fieldName) throws IllegalAccessException { [EOL]     return readField(target, fieldName, false); [EOL] } 
 [LINE] public static Object readField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException { [LINE] public static Object readField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (target == null) { [EOL]         throw new IllegalArgumentException("target object must not be null"); [EOL]     } [EOL]     final Class<?> cls = target.getClass(); [EOL]     final Field field = getField(cls, fieldName, forceAccess); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Cannot locate field " + fieldName + " on " + cls); [EOL]     } [EOL]     return readField(field, target); [EOL] } 
 [LINE] if (target == null) { [LINE] public static Object readField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (target == null) { [EOL]         throw new IllegalArgumentException("target object must not be null"); [EOL]     } [EOL]     final Class<?> cls = target.getClass(); [EOL]     final Field field = getField(cls, fieldName, forceAccess); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Cannot locate field " + fieldName + " on " + cls); [EOL]     } [EOL]     return readField(field, target); [EOL] } 
 [LINE] throw new IllegalArgumentException("target object must not be null"); [LINE] public static Object readField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (target == null) { [EOL]         throw new IllegalArgumentException("target object must not be null"); [EOL]     } [EOL]     final Class<?> cls = target.getClass(); [EOL]     final Field field = getField(cls, fieldName, forceAccess); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Cannot locate field " + fieldName + " on " + cls); [EOL]     } [EOL]     return readField(field, target); [EOL] } 
 [LINE] final Class<?> cls = target.getClass(); [LINE] public static Object readField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (target == null) { [EOL]         throw new IllegalArgumentException("target object must not be null"); [EOL]     } [EOL]     final Class<?> cls = target.getClass(); [EOL]     final Field field = getField(cls, fieldName, forceAccess); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Cannot locate field " + fieldName + " on " + cls); [EOL]     } [EOL]     return readField(field, target); [EOL] } 
 [LINE] final Field field = getField(cls, fieldName, forceAccess); [LINE] public static Object readField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (target == null) { [EOL]         throw new IllegalArgumentException("target object must not be null"); [EOL]     } [EOL]     final Class<?> cls = target.getClass(); [EOL]     final Field field = getField(cls, fieldName, forceAccess); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Cannot locate field " + fieldName + " on " + cls); [EOL]     } [EOL]     return readField(field, target); [EOL] } 
 [LINE] if (field == null) { [LINE] public static Object readField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (target == null) { [EOL]         throw new IllegalArgumentException("target object must not be null"); [EOL]     } [EOL]     final Class<?> cls = target.getClass(); [EOL]     final Field field = getField(cls, fieldName, forceAccess); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Cannot locate field " + fieldName + " on " + cls); [EOL]     } [EOL]     return readField(field, target); [EOL] } 
 [LINE] throw new IllegalArgumentException("Cannot locate field " + fieldName + " on " + cls); [LINE] public static Object readField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (target == null) { [EOL]         throw new IllegalArgumentException("target object must not be null"); [EOL]     } [EOL]     final Class<?> cls = target.getClass(); [EOL]     final Field field = getField(cls, fieldName, forceAccess); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Cannot locate field " + fieldName + " on " + cls); [EOL]     } [EOL]     return readField(field, target); [EOL] } 
 [LINE] return readField(field, target); [LINE] public static Object readField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (target == null) { [EOL]         throw new IllegalArgumentException("target object must not be null"); [EOL]     } [EOL]     final Class<?> cls = target.getClass(); [EOL]     final Field field = getField(cls, fieldName, forceAccess); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Cannot locate field " + fieldName + " on " + cls); [EOL]     } [EOL]     return readField(field, target); [EOL] } 
 [LINE] public static Object readDeclaredField(final Object target, final String fieldName) throws IllegalAccessException { [LINE] public static Object readDeclaredField(final Object target, final String fieldName) throws IllegalAccessException { [EOL]     return readDeclaredField(target, fieldName, false); [EOL] } 
 [LINE] return readDeclaredField(target, fieldName, false); [LINE] public static Object readDeclaredField(final Object target, final String fieldName) throws IllegalAccessException { [EOL]     return readDeclaredField(target, fieldName, false); [EOL] } 
 [LINE] public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException { [LINE] public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (target == null) { [EOL]         throw new IllegalArgumentException("target object must not be null"); [EOL]     } [EOL]     final Class<?> cls = target.getClass(); [EOL]     final Field field = getDeclaredField(cls, fieldName, forceAccess); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Cannot locate declared field " + cls.getName() + "." + fieldName); [EOL]     } [EOL]     return readField(field, target); [EOL] } 
 [LINE] if (target == null) { [LINE] public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (target == null) { [EOL]         throw new IllegalArgumentException("target object must not be null"); [EOL]     } [EOL]     final Class<?> cls = target.getClass(); [EOL]     final Field field = getDeclaredField(cls, fieldName, forceAccess); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Cannot locate declared field " + cls.getName() + "." + fieldName); [EOL]     } [EOL]     return readField(field, target); [EOL] } 
 [LINE] throw new IllegalArgumentException("target object must not be null"); [LINE] public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (target == null) { [EOL]         throw new IllegalArgumentException("target object must not be null"); [EOL]     } [EOL]     final Class<?> cls = target.getClass(); [EOL]     final Field field = getDeclaredField(cls, fieldName, forceAccess); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Cannot locate declared field " + cls.getName() + "." + fieldName); [EOL]     } [EOL]     return readField(field, target); [EOL] } 
 [LINE] final Class<?> cls = target.getClass(); [LINE] public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (target == null) { [EOL]         throw new IllegalArgumentException("target object must not be null"); [EOL]     } [EOL]     final Class<?> cls = target.getClass(); [EOL]     final Field field = getDeclaredField(cls, fieldName, forceAccess); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Cannot locate declared field " + cls.getName() + "." + fieldName); [EOL]     } [EOL]     return readField(field, target); [EOL] } 
 [LINE] final Field field = getDeclaredField(cls, fieldName, forceAccess); [LINE] public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (target == null) { [EOL]         throw new IllegalArgumentException("target object must not be null"); [EOL]     } [EOL]     final Class<?> cls = target.getClass(); [EOL]     final Field field = getDeclaredField(cls, fieldName, forceAccess); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Cannot locate declared field " + cls.getName() + "." + fieldName); [EOL]     } [EOL]     return readField(field, target); [EOL] } 
 [LINE] if (field == null) { [LINE] public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (target == null) { [EOL]         throw new IllegalArgumentException("target object must not be null"); [EOL]     } [EOL]     final Class<?> cls = target.getClass(); [EOL]     final Field field = getDeclaredField(cls, fieldName, forceAccess); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Cannot locate declared field " + cls.getName() + "." + fieldName); [EOL]     } [EOL]     return readField(field, target); [EOL] } 
 [LINE] throw new IllegalArgumentException("Cannot locate declared field " + cls.getName() + "." + fieldName); [LINE] public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (target == null) { [EOL]         throw new IllegalArgumentException("target object must not be null"); [EOL]     } [EOL]     final Class<?> cls = target.getClass(); [EOL]     final Field field = getDeclaredField(cls, fieldName, forceAccess); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Cannot locate declared field " + cls.getName() + "." + fieldName); [EOL]     } [EOL]     return readField(field, target); [EOL] } 
 [LINE] return readField(field, target); [LINE] public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (target == null) { [EOL]         throw new IllegalArgumentException("target object must not be null"); [EOL]     } [EOL]     final Class<?> cls = target.getClass(); [EOL]     final Field field = getDeclaredField(cls, fieldName, forceAccess); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Cannot locate declared field " + cls.getName() + "." + fieldName); [EOL]     } [EOL]     return readField(field, target); [EOL] } 
 [LINE] public static void writeStaticField(final Field field, final Object value) throws IllegalAccessException { [LINE] public static void writeStaticField(final Field field, final Object value) throws IllegalAccessException { [EOL]     writeStaticField(field, value, false); [EOL] } 
 [LINE] writeStaticField(field, value, false); [LINE] public static void writeStaticField(final Field field, final Object value) throws IllegalAccessException { [EOL]     writeStaticField(field, value, false); [EOL] } 
 [LINE] public static void writeStaticField(final Field field, final Object value, final boolean forceAccess) throws IllegalAccessException { [LINE] public static void writeStaticField(final Field field, final Object value, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("The field must not be null"); [EOL]     } [EOL]     if (!Modifier.isStatic(field.getModifiers())) { [EOL]         throw new IllegalArgumentException("The field '" + field.getName() + "' is not static"); [EOL]     } [EOL]     writeField(field, (Object) null, value, forceAccess); [EOL] } 
 [LINE] if (field == null) { [LINE] public static void writeStaticField(final Field field, final Object value, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("The field must not be null"); [EOL]     } [EOL]     if (!Modifier.isStatic(field.getModifiers())) { [EOL]         throw new IllegalArgumentException("The field '" + field.getName() + "' is not static"); [EOL]     } [EOL]     writeField(field, (Object) null, value, forceAccess); [EOL] } 
 [LINE] if (!Modifier.isStatic(field.getModifiers())) { [LINE] public static void writeStaticField(final Field field, final Object value, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("The field must not be null"); [EOL]     } [EOL]     if (!Modifier.isStatic(field.getModifiers())) { [EOL]         throw new IllegalArgumentException("The field '" + field.getName() + "' is not static"); [EOL]     } [EOL]     writeField(field, (Object) null, value, forceAccess); [EOL] } 
 [LINE] writeField(field, (Object) null, value, forceAccess); [LINE] public static void writeStaticField(final Field field, final Object value, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("The field must not be null"); [EOL]     } [EOL]     if (!Modifier.isStatic(field.getModifiers())) { [EOL]         throw new IllegalArgumentException("The field '" + field.getName() + "' is not static"); [EOL]     } [EOL]     writeField(field, (Object) null, value, forceAccess); [EOL] } 
 [LINE] writeStaticField(field, value); [LINE] public static void writeStaticField(final Class<?> cls, final String fieldName, final Object value, final boolean forceAccess) throws IllegalAccessException { [EOL]     final Field field = getField(cls, fieldName, forceAccess); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Cannot locate field " + fieldName + " on " + cls); [EOL]     } [EOL]     writeStaticField(field, value); [EOL] } 
 [LINE] public static void writeDeclaredStaticField(final Class<?> cls, final String fieldName, final Object value) throws IllegalAccessException { [LINE] public static void writeDeclaredStaticField(final Class<?> cls, final String fieldName, final Object value) throws IllegalAccessException { [EOL]     writeDeclaredStaticField(cls, fieldName, value, false); [EOL] } 
 [LINE] writeDeclaredStaticField(cls, fieldName, value, false); [LINE] public static void writeDeclaredStaticField(final Class<?> cls, final String fieldName, final Object value) throws IllegalAccessException { [EOL]     writeDeclaredStaticField(cls, fieldName, value, false); [EOL] } 
 [LINE] public static void writeDeclaredStaticField(final Class<?> cls, final String fieldName, final Object value, final boolean forceAccess) [LINE] public static void writeDeclaredStaticField(final Class<?> cls, final String fieldName, final Object value, final boolean forceAccess) throws IllegalAccessException { [EOL]     final Field field = getDeclaredField(cls, fieldName, forceAccess); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Cannot locate declared field " + cls.getName() + "." + fieldName); [EOL]     } [EOL]     writeField(field, (Object) null, value); [EOL] } 
 [LINE] final Field field = getDeclaredField(cls, fieldName, forceAccess); [LINE] public static void writeDeclaredStaticField(final Class<?> cls, final String fieldName, final Object value, final boolean forceAccess) throws IllegalAccessException { [EOL]     final Field field = getDeclaredField(cls, fieldName, forceAccess); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Cannot locate declared field " + cls.getName() + "." + fieldName); [EOL]     } [EOL]     writeField(field, (Object) null, value); [EOL] } 
 [LINE] if (field == null) { [LINE] public static void writeDeclaredStaticField(final Class<?> cls, final String fieldName, final Object value, final boolean forceAccess) throws IllegalAccessException { [EOL]     final Field field = getDeclaredField(cls, fieldName, forceAccess); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Cannot locate declared field " + cls.getName() + "." + fieldName); [EOL]     } [EOL]     writeField(field, (Object) null, value); [EOL] } 
 [LINE] throw new IllegalArgumentException("Cannot locate declared field " + cls.getName() + "." + fieldName); [LINE] public static void writeDeclaredStaticField(final Class<?> cls, final String fieldName, final Object value, final boolean forceAccess) throws IllegalAccessException { [EOL]     final Field field = getDeclaredField(cls, fieldName, forceAccess); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Cannot locate declared field " + cls.getName() + "." + fieldName); [EOL]     } [EOL]     writeField(field, (Object) null, value); [EOL] } 
 [LINE] writeField(field, (Object) null, value); [LINE] public static void writeDeclaredStaticField(final Class<?> cls, final String fieldName, final Object value, final boolean forceAccess) throws IllegalAccessException { [EOL]     final Field field = getDeclaredField(cls, fieldName, forceAccess); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Cannot locate declared field " + cls.getName() + "." + fieldName); [EOL]     } [EOL]     writeField(field, (Object) null, value); [EOL] } 
 [LINE] public static void writeField(final Field field, final Object target, final Object value) throws IllegalAccessException { [LINE] public static void writeField(final Field field, final Object target, final Object value) throws IllegalAccessException { [EOL]     writeField(field, target, value, false); [EOL] } 
 [LINE] writeField(field, target, value, false); [LINE] public static void writeField(final Field field, final Object target, final Object value) throws IllegalAccessException { [EOL]     writeField(field, target, value, false); [EOL] } 
 [LINE] public static void writeField(final Field field, final Object target, final Object value, final boolean forceAccess) [LINE] public static void writeField(final Field field, final Object target, final Object value, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("The field must not be null"); [EOL]     } [EOL]     if (forceAccess && !field.isAccessible()) { [EOL]         field.setAccessible(true); [EOL]     } else { [EOL]         MemberUtils.setAccessibleWorkaround(field); [EOL]     } [EOL]     field.set(target, value); [EOL] } 
 [LINE] if (field == null) { [LINE] public static void writeField(final Field field, final Object target, final Object value, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("The field must not be null"); [EOL]     } [EOL]     if (forceAccess && !field.isAccessible()) { [EOL]         field.setAccessible(true); [EOL]     } else { [EOL]         MemberUtils.setAccessibleWorkaround(field); [EOL]     } [EOL]     field.set(target, value); [EOL] } 
 [LINE] if (forceAccess && !field.isAccessible()) { [LINE] public static void writeField(final Field field, final Object target, final Object value, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("The field must not be null"); [EOL]     } [EOL]     if (forceAccess && !field.isAccessible()) { [EOL]         field.setAccessible(true); [EOL]     } else { [EOL]         MemberUtils.setAccessibleWorkaround(field); [EOL]     } [EOL]     field.set(target, value); [EOL] } 
 [LINE] field.setAccessible(true); [LINE] public static void writeField(final Field field, final Object target, final Object value, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("The field must not be null"); [EOL]     } [EOL]     if (forceAccess && !field.isAccessible()) { [EOL]         field.setAccessible(true); [EOL]     } else { [EOL]         MemberUtils.setAccessibleWorkaround(field); [EOL]     } [EOL]     field.set(target, value); [EOL] } 
 [LINE] MemberUtils.setAccessibleWorkaround(field); [LINE] public static void writeField(final Field field, final Object target, final Object value, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("The field must not be null"); [EOL]     } [EOL]     if (forceAccess && !field.isAccessible()) { [EOL]         field.setAccessible(true); [EOL]     } else { [EOL]         MemberUtils.setAccessibleWorkaround(field); [EOL]     } [EOL]     field.set(target, value); [EOL] } 
 [LINE] field.set(target, value); [LINE] public static void writeField(final Field field, final Object target, final Object value, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("The field must not be null"); [EOL]     } [EOL]     if (forceAccess && !field.isAccessible()) { [EOL]         field.setAccessible(true); [EOL]     } else { [EOL]         MemberUtils.setAccessibleWorkaround(field); [EOL]     } [EOL]     field.set(target, value); [EOL] } 
 [LINE] public static void writeField(final Object target, final String fieldName, final Object value) throws IllegalAccessException { [LINE] public static void writeField(final Object target, final String fieldName, final Object value) throws IllegalAccessException { [EOL]     writeField(target, fieldName, value, false); [EOL] } 
 [LINE] writeField(target, fieldName, value, false); [LINE] public static void writeField(final Object target, final String fieldName, final Object value) throws IllegalAccessException { [EOL]     writeField(target, fieldName, value, false); [EOL] } 
 [LINE] public static void writeField(final Object target, final String fieldName, final Object value, final boolean forceAccess) [LINE] public static void writeField(final Object target, final String fieldName, final Object value, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (target == null) { [EOL]         throw new IllegalArgumentException("target object must not be null"); [EOL]     } [EOL]     final Class<?> cls = target.getClass(); [EOL]     final Field field = getField(cls, fieldName, forceAccess); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Cannot locate declared field " + cls.getName() + "." + fieldName); [EOL]     } [EOL]     writeField(field, target, value); [EOL] } 
 [LINE] if (target == null) { [LINE] public static void writeField(final Object target, final String fieldName, final Object value, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (target == null) { [EOL]         throw new IllegalArgumentException("target object must not be null"); [EOL]     } [EOL]     final Class<?> cls = target.getClass(); [EOL]     final Field field = getField(cls, fieldName, forceAccess); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Cannot locate declared field " + cls.getName() + "." + fieldName); [EOL]     } [EOL]     writeField(field, target, value); [EOL] } 
 [LINE] final Class<?> cls = target.getClass(); [LINE] public static void writeField(final Object target, final String fieldName, final Object value, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (target == null) { [EOL]         throw new IllegalArgumentException("target object must not be null"); [EOL]     } [EOL]     final Class<?> cls = target.getClass(); [EOL]     final Field field = getField(cls, fieldName, forceAccess); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Cannot locate declared field " + cls.getName() + "." + fieldName); [EOL]     } [EOL]     writeField(field, target, value); [EOL] } 
 [LINE] final Field field = getField(cls, fieldName, forceAccess); [LINE] public static void writeField(final Object target, final String fieldName, final Object value, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (target == null) { [EOL]         throw new IllegalArgumentException("target object must not be null"); [EOL]     } [EOL]     final Class<?> cls = target.getClass(); [EOL]     final Field field = getField(cls, fieldName, forceAccess); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Cannot locate declared field " + cls.getName() + "." + fieldName); [EOL]     } [EOL]     writeField(field, target, value); [EOL] } 
 [LINE] if (field == null) { [LINE] public static void writeField(final Object target, final String fieldName, final Object value, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (target == null) { [EOL]         throw new IllegalArgumentException("target object must not be null"); [EOL]     } [EOL]     final Class<?> cls = target.getClass(); [EOL]     final Field field = getField(cls, fieldName, forceAccess); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Cannot locate declared field " + cls.getName() + "." + fieldName); [EOL]     } [EOL]     writeField(field, target, value); [EOL] } 
 [LINE] throw new IllegalArgumentException("Cannot locate declared field " + cls.getName() + "." + fieldName); [LINE] public static void writeField(final Object target, final String fieldName, final Object value, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (target == null) { [EOL]         throw new IllegalArgumentException("target object must not be null"); [EOL]     } [EOL]     final Class<?> cls = target.getClass(); [EOL]     final Field field = getField(cls, fieldName, forceAccess); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Cannot locate declared field " + cls.getName() + "." + fieldName); [EOL]     } [EOL]     writeField(field, target, value); [EOL] } 
 [LINE] writeField(field, target, value); [LINE] public static void writeField(final Object target, final String fieldName, final Object value, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (target == null) { [EOL]         throw new IllegalArgumentException("target object must not be null"); [EOL]     } [EOL]     final Class<?> cls = target.getClass(); [EOL]     final Field field = getField(cls, fieldName, forceAccess); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Cannot locate declared field " + cls.getName() + "." + fieldName); [EOL]     } [EOL]     writeField(field, target, value); [EOL] } 
 [LINE] public static void writeDeclaredField(final Object target, final String fieldName, final Object value) throws IllegalAccessException { [LINE] public static void writeDeclaredField(final Object target, final String fieldName, final Object value) throws IllegalAccessException { [EOL]     writeDeclaredField(target, fieldName, value, false); [EOL] } 
 [LINE] writeDeclaredField(target, fieldName, value, false); [LINE] public static void writeDeclaredField(final Object target, final String fieldName, final Object value) throws IllegalAccessException { [EOL]     writeDeclaredField(target, fieldName, value, false); [EOL] } 
 [LINE] public static void writeDeclaredField(final Object target, final String fieldName, final Object value, final boolean forceAccess) [LINE] public static void writeDeclaredField(final Object target, final String fieldName, final Object value, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (target == null) { [EOL]         throw new IllegalArgumentException("target object must not be null"); [EOL]     } [EOL]     final Class<?> cls = target.getClass(); [EOL]     final Field field = getDeclaredField(cls, fieldName, forceAccess); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Cannot locate declared field " + cls.getName() + "." + fieldName); [EOL]     } [EOL]     writeField(field, target, value); [EOL] } 
 [LINE] if (target == null) { [LINE] public static void writeDeclaredField(final Object target, final String fieldName, final Object value, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (target == null) { [EOL]         throw new IllegalArgumentException("target object must not be null"); [EOL]     } [EOL]     final Class<?> cls = target.getClass(); [EOL]     final Field field = getDeclaredField(cls, fieldName, forceAccess); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Cannot locate declared field " + cls.getName() + "." + fieldName); [EOL]     } [EOL]     writeField(field, target, value); [EOL] } 
 [LINE] final Class<?> cls = target.getClass(); [LINE] public static void writeDeclaredField(final Object target, final String fieldName, final Object value, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (target == null) { [EOL]         throw new IllegalArgumentException("target object must not be null"); [EOL]     } [EOL]     final Class<?> cls = target.getClass(); [EOL]     final Field field = getDeclaredField(cls, fieldName, forceAccess); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Cannot locate declared field " + cls.getName() + "." + fieldName); [EOL]     } [EOL]     writeField(field, target, value); [EOL] } 
 [LINE] final Field field = getDeclaredField(cls, fieldName, forceAccess); [LINE] public static void writeDeclaredField(final Object target, final String fieldName, final Object value, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (target == null) { [EOL]         throw new IllegalArgumentException("target object must not be null"); [EOL]     } [EOL]     final Class<?> cls = target.getClass(); [EOL]     final Field field = getDeclaredField(cls, fieldName, forceAccess); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Cannot locate declared field " + cls.getName() + "." + fieldName); [EOL]     } [EOL]     writeField(field, target, value); [EOL] } 
 [LINE] if (field == null) { [LINE] public static void writeDeclaredField(final Object target, final String fieldName, final Object value, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (target == null) { [EOL]         throw new IllegalArgumentException("target object must not be null"); [EOL]     } [EOL]     final Class<?> cls = target.getClass(); [EOL]     final Field field = getDeclaredField(cls, fieldName, forceAccess); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Cannot locate declared field " + cls.getName() + "." + fieldName); [EOL]     } [EOL]     writeField(field, target, value); [EOL] } 
 [LINE] throw new IllegalArgumentException("Cannot locate declared field " + cls.getName() + "." + fieldName); [LINE] public static void writeDeclaredField(final Object target, final String fieldName, final Object value, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (target == null) { [EOL]         throw new IllegalArgumentException("target object must not be null"); [EOL]     } [EOL]     final Class<?> cls = target.getClass(); [EOL]     final Field field = getDeclaredField(cls, fieldName, forceAccess); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Cannot locate declared field " + cls.getName() + "." + fieldName); [EOL]     } [EOL]     writeField(field, target, value); [EOL] } 
 [LINE] writeField(field, target, value); [LINE] public static void writeDeclaredField(final Object target, final String fieldName, final Object value, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (target == null) { [EOL]         throw new IllegalArgumentException("target object must not be null"); [EOL]     } [EOL]     final Class<?> cls = target.getClass(); [EOL]     final Field field = getDeclaredField(cls, fieldName, forceAccess); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Cannot locate declared field " + cls.getName() + "." + fieldName); [EOL]     } [EOL]     writeField(field, target, value); [EOL] } 
 [LINE] buffer[i] = Character.toLowerCase(ch); [LINE] public static String swapCase(final String str) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return str; [EOL]     } [EOL]     final char[] buffer = str.toCharArray(); [EOL]     boolean whitespace = true; [EOL]     for (int i = 0; i < buffer.length; i++) { [EOL]         final char ch = buffer[i]; [EOL]         if (Character.isUpperCase(ch)) { [EOL]             buffer[i] = Character.toLowerCase(ch); [EOL]             whitespace = false; [EOL]         } else if (Character.isTitleCase(ch)) { [EOL]             buffer[i] = Character.toLowerCase(ch); [EOL]             whitespace = false; [EOL]         } else if (Character.isLowerCase(ch)) { [EOL]             if (whitespace) { [EOL]                 buffer[i] = Character.toTitleCase(ch); [EOL]                 whitespace = false; [EOL]             } else { [EOL]                 buffer[i] = Character.toUpperCase(ch); [EOL]             } [EOL]         } else { [EOL]             whitespace = Character.isWhitespace(ch); [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] } 
 [LINE] whitespace = false; [LINE] public static String swapCase(final String str) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return str; [EOL]     } [EOL]     final char[] buffer = str.toCharArray(); [EOL]     boolean whitespace = true; [EOL]     for (int i = 0; i < buffer.length; i++) { [EOL]         final char ch = buffer[i]; [EOL]         if (Character.isUpperCase(ch)) { [EOL]             buffer[i] = Character.toLowerCase(ch); [EOL]             whitespace = false; [EOL]         } else if (Character.isTitleCase(ch)) { [EOL]             buffer[i] = Character.toLowerCase(ch); [EOL]             whitespace = false; [EOL]         } else if (Character.isLowerCase(ch)) { [EOL]             if (whitespace) { [EOL]                 buffer[i] = Character.toTitleCase(ch); [EOL]                 whitespace = false; [EOL]             } else { [EOL]                 buffer[i] = Character.toUpperCase(ch); [EOL]             } [EOL]         } else { [EOL]             whitespace = Character.isWhitespace(ch); [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] } 
 [LINE] throw new IllegalArgumentException("The date must not be null"); [LINE] public static boolean isSameInstant(final Calendar cal1, final Calendar cal2) { [EOL]     if (cal1 == null || cal2 == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     return cal1.getTime().getTime() == cal2.getTime().getTime(); [EOL] } 
 [LINE] return round((Date) date, field); [LINE] public static Date round(final Object date, final int field) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     if (date instanceof Date) { [EOL]         return round((Date) date, field); [EOL]     } else if (date instanceof Calendar) { [EOL]         return round((Calendar) date, field).getTime(); [EOL]     } else { [EOL]         throw new ClassCastException("Could not round " + date); [EOL]     } [EOL] } 
 [LINE] throw new IllegalArgumentException("The date must not be null"); [LINE] public static Date ceiling(final Date date, final int field) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     final Calendar gval = Calendar.getInstance(); [EOL]     gval.setTime(date); [EOL]     modify(gval, field, MODIFY_CEILING); [EOL]     return gval.getTime(); [EOL] } 
 [LINE] done = true; [LINE] private static void modify(final Calendar val, final int field, final int modType) { [EOL]     if (val.get(Calendar.YEAR) > 280000000) { [EOL]         throw new ArithmeticException("Calendar value too large for accurate calculations"); [EOL]     } [EOL]     if (field == Calendar.MILLISECOND) { [EOL]         return; [EOL]     } [EOL]     final Date date = val.getTime(); [EOL]     long time = date.getTime(); [EOL]     boolean done = false; [EOL]     final int millisecs = val.get(Calendar.MILLISECOND); [EOL]     if (MODIFY_TRUNCATE == modType || millisecs < 500) { [EOL]         time = time - millisecs; [EOL]     } [EOL]     if (field == Calendar.SECOND) { [EOL]         done = true; [EOL]     } [EOL]     final int seconds = val.get(Calendar.SECOND); [EOL]     if (!done && (MODIFY_TRUNCATE == modType || seconds < 30)) { [EOL]         time = time - (seconds * 1000L); [EOL]     } [EOL]     if (field == Calendar.MINUTE) { [EOL]         done = true; [EOL]     } [EOL]     final int minutes = val.get(Calendar.MINUTE); [EOL]     if (!done && (MODIFY_TRUNCATE == modType || minutes < 30)) { [EOL]         time = time - (minutes * 60000L); [EOL]     } [EOL]     if (date.getTime() != time) { [EOL]         date.setTime(time); [EOL]         val.setTime(date); [EOL]     } [EOL]     boolean roundUp = false; [EOL]     for (final int[] aField : fields) { [EOL]         for (final int element : aField) { [EOL]             if (element == field) { [EOL]                 if (modType == MODIFY_CEILING || (modType == MODIFY_ROUND && roundUp)) { [EOL]                     if (field == DateUtils.SEMI_MONTH) { [EOL]                         if (val.get(Calendar.DATE) == 1) { [EOL]                             val.add(Calendar.DATE, 15); [EOL]                         } else { [EOL]                             val.add(Calendar.DATE, -15); [EOL]                             val.add(Calendar.MONTH, 1); [EOL]                         } [EOL]                     } else if (field == Calendar.AM_PM) { [EOL]                         if (val.get(Calendar.HOUR_OF_DAY) == 0) { [EOL]                             val.add(Calendar.HOUR_OF_DAY, 12); [EOL]                         } else { [EOL]                             val.add(Calendar.HOUR_OF_DAY, -12); [EOL]                             val.add(Calendar.DATE, 1); [EOL]                         } [EOL]                     } else { [EOL]                         val.add(aField[0], 1); [EOL]                     } [EOL]                 } [EOL]                 return; [EOL]             } [EOL]         } [EOL]         int offset = 0; [EOL]         boolean offsetSet = false; [EOL]         switch(field) { [EOL]             case DateUtils.SEMI_MONTH: [EOL]                 if (aField[0] == Calendar.DATE) { [EOL]                     offset = val.get(Calendar.DATE) - 1; [EOL]                     if (offset >= 15) { [EOL]                         offset -= 15; [EOL]                     } [EOL]                     roundUp = offset > 7; [EOL]                     offsetSet = true; [EOL]                 } [EOL]                 break; [EOL]             case Calendar.AM_PM: [EOL]                 if (aField[0] == Calendar.HOUR_OF_DAY) { [EOL]                     offset = val.get(Calendar.HOUR_OF_DAY); [EOL]                     if (offset >= 12) { [EOL]                         offset -= 12; [EOL]                     } [EOL]                     roundUp = offset >= 6; [EOL]                     offsetSet = true; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         if (!offsetSet) { [EOL]             final int min = val.getActualMinimum(aField[0]); [EOL]             final int max = val.getActualMaximum(aField[0]); [EOL]             offset = val.get(aField[0]) - min; [EOL]             roundUp = offset > ((max - min) / 2); [EOL]         } [EOL]         if (offset != 0) { [EOL]             val.set(aField[0], val.get(aField[0]) - offset); [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The field " + field + " is not supported"); [EOL] } 
 [LINE] val.add(Calendar.DATE, 15); [LINE] private static void modify(final Calendar val, final int field, final int modType) { [EOL]     if (val.get(Calendar.YEAR) > 280000000) { [EOL]         throw new ArithmeticException("Calendar value too large for accurate calculations"); [EOL]     } [EOL]     if (field == Calendar.MILLISECOND) { [EOL]         return; [EOL]     } [EOL]     final Date date = val.getTime(); [EOL]     long time = date.getTime(); [EOL]     boolean done = false; [EOL]     final int millisecs = val.get(Calendar.MILLISECOND); [EOL]     if (MODIFY_TRUNCATE == modType || millisecs < 500) { [EOL]         time = time - millisecs; [EOL]     } [EOL]     if (field == Calendar.SECOND) { [EOL]         done = true; [EOL]     } [EOL]     final int seconds = val.get(Calendar.SECOND); [EOL]     if (!done && (MODIFY_TRUNCATE == modType || seconds < 30)) { [EOL]         time = time - (seconds * 1000L); [EOL]     } [EOL]     if (field == Calendar.MINUTE) { [EOL]         done = true; [EOL]     } [EOL]     final int minutes = val.get(Calendar.MINUTE); [EOL]     if (!done && (MODIFY_TRUNCATE == modType || minutes < 30)) { [EOL]         time = time - (minutes * 60000L); [EOL]     } [EOL]     if (date.getTime() != time) { [EOL]         date.setTime(time); [EOL]         val.setTime(date); [EOL]     } [EOL]     boolean roundUp = false; [EOL]     for (final int[] aField : fields) { [EOL]         for (final int element : aField) { [EOL]             if (element == field) { [EOL]                 if (modType == MODIFY_CEILING || (modType == MODIFY_ROUND && roundUp)) { [EOL]                     if (field == DateUtils.SEMI_MONTH) { [EOL]                         if (val.get(Calendar.DATE) == 1) { [EOL]                             val.add(Calendar.DATE, 15); [EOL]                         } else { [EOL]                             val.add(Calendar.DATE, -15); [EOL]                             val.add(Calendar.MONTH, 1); [EOL]                         } [EOL]                     } else if (field == Calendar.AM_PM) { [EOL]                         if (val.get(Calendar.HOUR_OF_DAY) == 0) { [EOL]                             val.add(Calendar.HOUR_OF_DAY, 12); [EOL]                         } else { [EOL]                             val.add(Calendar.HOUR_OF_DAY, -12); [EOL]                             val.add(Calendar.DATE, 1); [EOL]                         } [EOL]                     } else { [EOL]                         val.add(aField[0], 1); [EOL]                     } [EOL]                 } [EOL]                 return; [EOL]             } [EOL]         } [EOL]         int offset = 0; [EOL]         boolean offsetSet = false; [EOL]         switch(field) { [EOL]             case DateUtils.SEMI_MONTH: [EOL]                 if (aField[0] == Calendar.DATE) { [EOL]                     offset = val.get(Calendar.DATE) - 1; [EOL]                     if (offset >= 15) { [EOL]                         offset -= 15; [EOL]                     } [EOL]                     roundUp = offset > 7; [EOL]                     offsetSet = true; [EOL]                 } [EOL]                 break; [EOL]             case Calendar.AM_PM: [EOL]                 if (aField[0] == Calendar.HOUR_OF_DAY) { [EOL]                     offset = val.get(Calendar.HOUR_OF_DAY); [EOL]                     if (offset >= 12) { [EOL]                         offset -= 12; [EOL]                     } [EOL]                     roundUp = offset >= 6; [EOL]                     offsetSet = true; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         if (!offsetSet) { [EOL]             final int min = val.getActualMinimum(aField[0]); [EOL]             final int max = val.getActualMaximum(aField[0]); [EOL]             offset = val.get(aField[0]) - min; [EOL]             roundUp = offset > ((max - min) / 2); [EOL]         } [EOL]         if (offset != 0) { [EOL]             val.set(aField[0], val.get(aField[0]) - offset); [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The field " + field + " is not supported"); [EOL] } 
 [LINE] if (val.get(Calendar.HOUR_OF_DAY) == 0) { [LINE] private static void modify(final Calendar val, final int field, final int modType) { [EOL]     if (val.get(Calendar.YEAR) > 280000000) { [EOL]         throw new ArithmeticException("Calendar value too large for accurate calculations"); [EOL]     } [EOL]     if (field == Calendar.MILLISECOND) { [EOL]         return; [EOL]     } [EOL]     final Date date = val.getTime(); [EOL]     long time = date.getTime(); [EOL]     boolean done = false; [EOL]     final int millisecs = val.get(Calendar.MILLISECOND); [EOL]     if (MODIFY_TRUNCATE == modType || millisecs < 500) { [EOL]         time = time - millisecs; [EOL]     } [EOL]     if (field == Calendar.SECOND) { [EOL]         done = true; [EOL]     } [EOL]     final int seconds = val.get(Calendar.SECOND); [EOL]     if (!done && (MODIFY_TRUNCATE == modType || seconds < 30)) { [EOL]         time = time - (seconds * 1000L); [EOL]     } [EOL]     if (field == Calendar.MINUTE) { [EOL]         done = true; [EOL]     } [EOL]     final int minutes = val.get(Calendar.MINUTE); [EOL]     if (!done && (MODIFY_TRUNCATE == modType || minutes < 30)) { [EOL]         time = time - (minutes * 60000L); [EOL]     } [EOL]     if (date.getTime() != time) { [EOL]         date.setTime(time); [EOL]         val.setTime(date); [EOL]     } [EOL]     boolean roundUp = false; [EOL]     for (final int[] aField : fields) { [EOL]         for (final int element : aField) { [EOL]             if (element == field) { [EOL]                 if (modType == MODIFY_CEILING || (modType == MODIFY_ROUND && roundUp)) { [EOL]                     if (field == DateUtils.SEMI_MONTH) { [EOL]                         if (val.get(Calendar.DATE) == 1) { [EOL]                             val.add(Calendar.DATE, 15); [EOL]                         } else { [EOL]                             val.add(Calendar.DATE, -15); [EOL]                             val.add(Calendar.MONTH, 1); [EOL]                         } [EOL]                     } else if (field == Calendar.AM_PM) { [EOL]                         if (val.get(Calendar.HOUR_OF_DAY) == 0) { [EOL]                             val.add(Calendar.HOUR_OF_DAY, 12); [EOL]                         } else { [EOL]                             val.add(Calendar.HOUR_OF_DAY, -12); [EOL]                             val.add(Calendar.DATE, 1); [EOL]                         } [EOL]                     } else { [EOL]                         val.add(aField[0], 1); [EOL]                     } [EOL]                 } [EOL]                 return; [EOL]             } [EOL]         } [EOL]         int offset = 0; [EOL]         boolean offsetSet = false; [EOL]         switch(field) { [EOL]             case DateUtils.SEMI_MONTH: [EOL]                 if (aField[0] == Calendar.DATE) { [EOL]                     offset = val.get(Calendar.DATE) - 1; [EOL]                     if (offset >= 15) { [EOL]                         offset -= 15; [EOL]                     } [EOL]                     roundUp = offset > 7; [EOL]                     offsetSet = true; [EOL]                 } [EOL]                 break; [EOL]             case Calendar.AM_PM: [EOL]                 if (aField[0] == Calendar.HOUR_OF_DAY) { [EOL]                     offset = val.get(Calendar.HOUR_OF_DAY); [EOL]                     if (offset >= 12) { [EOL]                         offset -= 12; [EOL]                     } [EOL]                     roundUp = offset >= 6; [EOL]                     offsetSet = true; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         if (!offsetSet) { [EOL]             final int min = val.getActualMinimum(aField[0]); [EOL]             final int max = val.getActualMaximum(aField[0]); [EOL]             offset = val.get(aField[0]) - min; [EOL]             roundUp = offset > ((max - min) / 2); [EOL]         } [EOL]         if (offset != 0) { [EOL]             val.set(aField[0], val.get(aField[0]) - offset); [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The field " + field + " is not supported"); [EOL] } 
 [LINE] val.add(Calendar.HOUR_OF_DAY, 12); [LINE] private static void modify(final Calendar val, final int field, final int modType) { [EOL]     if (val.get(Calendar.YEAR) > 280000000) { [EOL]         throw new ArithmeticException("Calendar value too large for accurate calculations"); [EOL]     } [EOL]     if (field == Calendar.MILLISECOND) { [EOL]         return; [EOL]     } [EOL]     final Date date = val.getTime(); [EOL]     long time = date.getTime(); [EOL]     boolean done = false; [EOL]     final int millisecs = val.get(Calendar.MILLISECOND); [EOL]     if (MODIFY_TRUNCATE == modType || millisecs < 500) { [EOL]         time = time - millisecs; [EOL]     } [EOL]     if (field == Calendar.SECOND) { [EOL]         done = true; [EOL]     } [EOL]     final int seconds = val.get(Calendar.SECOND); [EOL]     if (!done && (MODIFY_TRUNCATE == modType || seconds < 30)) { [EOL]         time = time - (seconds * 1000L); [EOL]     } [EOL]     if (field == Calendar.MINUTE) { [EOL]         done = true; [EOL]     } [EOL]     final int minutes = val.get(Calendar.MINUTE); [EOL]     if (!done && (MODIFY_TRUNCATE == modType || minutes < 30)) { [EOL]         time = time - (minutes * 60000L); [EOL]     } [EOL]     if (date.getTime() != time) { [EOL]         date.setTime(time); [EOL]         val.setTime(date); [EOL]     } [EOL]     boolean roundUp = false; [EOL]     for (final int[] aField : fields) { [EOL]         for (final int element : aField) { [EOL]             if (element == field) { [EOL]                 if (modType == MODIFY_CEILING || (modType == MODIFY_ROUND && roundUp)) { [EOL]                     if (field == DateUtils.SEMI_MONTH) { [EOL]                         if (val.get(Calendar.DATE) == 1) { [EOL]                             val.add(Calendar.DATE, 15); [EOL]                         } else { [EOL]                             val.add(Calendar.DATE, -15); [EOL]                             val.add(Calendar.MONTH, 1); [EOL]                         } [EOL]                     } else if (field == Calendar.AM_PM) { [EOL]                         if (val.get(Calendar.HOUR_OF_DAY) == 0) { [EOL]                             val.add(Calendar.HOUR_OF_DAY, 12); [EOL]                         } else { [EOL]                             val.add(Calendar.HOUR_OF_DAY, -12); [EOL]                             val.add(Calendar.DATE, 1); [EOL]                         } [EOL]                     } else { [EOL]                         val.add(aField[0], 1); [EOL]                     } [EOL]                 } [EOL]                 return; [EOL]             } [EOL]         } [EOL]         int offset = 0; [EOL]         boolean offsetSet = false; [EOL]         switch(field) { [EOL]             case DateUtils.SEMI_MONTH: [EOL]                 if (aField[0] == Calendar.DATE) { [EOL]                     offset = val.get(Calendar.DATE) - 1; [EOL]                     if (offset >= 15) { [EOL]                         offset -= 15; [EOL]                     } [EOL]                     roundUp = offset > 7; [EOL]                     offsetSet = true; [EOL]                 } [EOL]                 break; [EOL]             case Calendar.AM_PM: [EOL]                 if (aField[0] == Calendar.HOUR_OF_DAY) { [EOL]                     offset = val.get(Calendar.HOUR_OF_DAY); [EOL]                     if (offset >= 12) { [EOL]                         offset -= 12; [EOL]                     } [EOL]                     roundUp = offset >= 6; [EOL]                     offsetSet = true; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         if (!offsetSet) { [EOL]             final int min = val.getActualMinimum(aField[0]); [EOL]             final int max = val.getActualMaximum(aField[0]); [EOL]             offset = val.get(aField[0]) - min; [EOL]             roundUp = offset > ((max - min) / 2); [EOL]         } [EOL]         if (offset != 0) { [EOL]             val.set(aField[0], val.get(aField[0]) - offset); [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The field " + field + " is not supported"); [EOL] } 
 [LINE] val.add(Calendar.HOUR_OF_DAY, -12); [LINE] private static void modify(final Calendar val, final int field, final int modType) { [EOL]     if (val.get(Calendar.YEAR) > 280000000) { [EOL]         throw new ArithmeticException("Calendar value too large for accurate calculations"); [EOL]     } [EOL]     if (field == Calendar.MILLISECOND) { [EOL]         return; [EOL]     } [EOL]     final Date date = val.getTime(); [EOL]     long time = date.getTime(); [EOL]     boolean done = false; [EOL]     final int millisecs = val.get(Calendar.MILLISECOND); [EOL]     if (MODIFY_TRUNCATE == modType || millisecs < 500) { [EOL]         time = time - millisecs; [EOL]     } [EOL]     if (field == Calendar.SECOND) { [EOL]         done = true; [EOL]     } [EOL]     final int seconds = val.get(Calendar.SECOND); [EOL]     if (!done && (MODIFY_TRUNCATE == modType || seconds < 30)) { [EOL]         time = time - (seconds * 1000L); [EOL]     } [EOL]     if (field == Calendar.MINUTE) { [EOL]         done = true; [EOL]     } [EOL]     final int minutes = val.get(Calendar.MINUTE); [EOL]     if (!done && (MODIFY_TRUNCATE == modType || minutes < 30)) { [EOL]         time = time - (minutes * 60000L); [EOL]     } [EOL]     if (date.getTime() != time) { [EOL]         date.setTime(time); [EOL]         val.setTime(date); [EOL]     } [EOL]     boolean roundUp = false; [EOL]     for (final int[] aField : fields) { [EOL]         for (final int element : aField) { [EOL]             if (element == field) { [EOL]                 if (modType == MODIFY_CEILING || (modType == MODIFY_ROUND && roundUp)) { [EOL]                     if (field == DateUtils.SEMI_MONTH) { [EOL]                         if (val.get(Calendar.DATE) == 1) { [EOL]                             val.add(Calendar.DATE, 15); [EOL]                         } else { [EOL]                             val.add(Calendar.DATE, -15); [EOL]                             val.add(Calendar.MONTH, 1); [EOL]                         } [EOL]                     } else if (field == Calendar.AM_PM) { [EOL]                         if (val.get(Calendar.HOUR_OF_DAY) == 0) { [EOL]                             val.add(Calendar.HOUR_OF_DAY, 12); [EOL]                         } else { [EOL]                             val.add(Calendar.HOUR_OF_DAY, -12); [EOL]                             val.add(Calendar.DATE, 1); [EOL]                         } [EOL]                     } else { [EOL]                         val.add(aField[0], 1); [EOL]                     } [EOL]                 } [EOL]                 return; [EOL]             } [EOL]         } [EOL]         int offset = 0; [EOL]         boolean offsetSet = false; [EOL]         switch(field) { [EOL]             case DateUtils.SEMI_MONTH: [EOL]                 if (aField[0] == Calendar.DATE) { [EOL]                     offset = val.get(Calendar.DATE) - 1; [EOL]                     if (offset >= 15) { [EOL]                         offset -= 15; [EOL]                     } [EOL]                     roundUp = offset > 7; [EOL]                     offsetSet = true; [EOL]                 } [EOL]                 break; [EOL]             case Calendar.AM_PM: [EOL]                 if (aField[0] == Calendar.HOUR_OF_DAY) { [EOL]                     offset = val.get(Calendar.HOUR_OF_DAY); [EOL]                     if (offset >= 12) { [EOL]                         offset -= 12; [EOL]                     } [EOL]                     roundUp = offset >= 6; [EOL]                     offsetSet = true; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         if (!offsetSet) { [EOL]             final int min = val.getActualMinimum(aField[0]); [EOL]             final int max = val.getActualMaximum(aField[0]); [EOL]             offset = val.get(aField[0]) - min; [EOL]             roundUp = offset > ((max - min) / 2); [EOL]         } [EOL]         if (offset != 0) { [EOL]             val.set(aField[0], val.get(aField[0]) - offset); [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The field " + field + " is not supported"); [EOL] } 
 [LINE] val.add(Calendar.DATE, 1); [LINE] private static void modify(final Calendar val, final int field, final int modType) { [EOL]     if (val.get(Calendar.YEAR) > 280000000) { [EOL]         throw new ArithmeticException("Calendar value too large for accurate calculations"); [EOL]     } [EOL]     if (field == Calendar.MILLISECOND) { [EOL]         return; [EOL]     } [EOL]     final Date date = val.getTime(); [EOL]     long time = date.getTime(); [EOL]     boolean done = false; [EOL]     final int millisecs = val.get(Calendar.MILLISECOND); [EOL]     if (MODIFY_TRUNCATE == modType || millisecs < 500) { [EOL]         time = time - millisecs; [EOL]     } [EOL]     if (field == Calendar.SECOND) { [EOL]         done = true; [EOL]     } [EOL]     final int seconds = val.get(Calendar.SECOND); [EOL]     if (!done && (MODIFY_TRUNCATE == modType || seconds < 30)) { [EOL]         time = time - (seconds * 1000L); [EOL]     } [EOL]     if (field == Calendar.MINUTE) { [EOL]         done = true; [EOL]     } [EOL]     final int minutes = val.get(Calendar.MINUTE); [EOL]     if (!done && (MODIFY_TRUNCATE == modType || minutes < 30)) { [EOL]         time = time - (minutes * 60000L); [EOL]     } [EOL]     if (date.getTime() != time) { [EOL]         date.setTime(time); [EOL]         val.setTime(date); [EOL]     } [EOL]     boolean roundUp = false; [EOL]     for (final int[] aField : fields) { [EOL]         for (final int element : aField) { [EOL]             if (element == field) { [EOL]                 if (modType == MODIFY_CEILING || (modType == MODIFY_ROUND && roundUp)) { [EOL]                     if (field == DateUtils.SEMI_MONTH) { [EOL]                         if (val.get(Calendar.DATE) == 1) { [EOL]                             val.add(Calendar.DATE, 15); [EOL]                         } else { [EOL]                             val.add(Calendar.DATE, -15); [EOL]                             val.add(Calendar.MONTH, 1); [EOL]                         } [EOL]                     } else if (field == Calendar.AM_PM) { [EOL]                         if (val.get(Calendar.HOUR_OF_DAY) == 0) { [EOL]                             val.add(Calendar.HOUR_OF_DAY, 12); [EOL]                         } else { [EOL]                             val.add(Calendar.HOUR_OF_DAY, -12); [EOL]                             val.add(Calendar.DATE, 1); [EOL]                         } [EOL]                     } else { [EOL]                         val.add(aField[0], 1); [EOL]                     } [EOL]                 } [EOL]                 return; [EOL]             } [EOL]         } [EOL]         int offset = 0; [EOL]         boolean offsetSet = false; [EOL]         switch(field) { [EOL]             case DateUtils.SEMI_MONTH: [EOL]                 if (aField[0] == Calendar.DATE) { [EOL]                     offset = val.get(Calendar.DATE) - 1; [EOL]                     if (offset >= 15) { [EOL]                         offset -= 15; [EOL]                     } [EOL]                     roundUp = offset > 7; [EOL]                     offsetSet = true; [EOL]                 } [EOL]                 break; [EOL]             case Calendar.AM_PM: [EOL]                 if (aField[0] == Calendar.HOUR_OF_DAY) { [EOL]                     offset = val.get(Calendar.HOUR_OF_DAY); [EOL]                     if (offset >= 12) { [EOL]                         offset -= 12; [EOL]                     } [EOL]                     roundUp = offset >= 6; [EOL]                     offsetSet = true; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         if (!offsetSet) { [EOL]             final int min = val.getActualMinimum(aField[0]); [EOL]             final int max = val.getActualMaximum(aField[0]); [EOL]             offset = val.get(aField[0]) - min; [EOL]             roundUp = offset > ((max - min) / 2); [EOL]         } [EOL]         if (offset != 0) { [EOL]             val.set(aField[0], val.get(aField[0]) - offset); [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The field " + field + " is not supported"); [EOL] } 
 [LINE] offset -= 12; [LINE] private static void modify(final Calendar val, final int field, final int modType) { [EOL]     if (val.get(Calendar.YEAR) > 280000000) { [EOL]         throw new ArithmeticException("Calendar value too large for accurate calculations"); [EOL]     } [EOL]     if (field == Calendar.MILLISECOND) { [EOL]         return; [EOL]     } [EOL]     final Date date = val.getTime(); [EOL]     long time = date.getTime(); [EOL]     boolean done = false; [EOL]     final int millisecs = val.get(Calendar.MILLISECOND); [EOL]     if (MODIFY_TRUNCATE == modType || millisecs < 500) { [EOL]         time = time - millisecs; [EOL]     } [EOL]     if (field == Calendar.SECOND) { [EOL]         done = true; [EOL]     } [EOL]     final int seconds = val.get(Calendar.SECOND); [EOL]     if (!done && (MODIFY_TRUNCATE == modType || seconds < 30)) { [EOL]         time = time - (seconds * 1000L); [EOL]     } [EOL]     if (field == Calendar.MINUTE) { [EOL]         done = true; [EOL]     } [EOL]     final int minutes = val.get(Calendar.MINUTE); [EOL]     if (!done && (MODIFY_TRUNCATE == modType || minutes < 30)) { [EOL]         time = time - (minutes * 60000L); [EOL]     } [EOL]     if (date.getTime() != time) { [EOL]         date.setTime(time); [EOL]         val.setTime(date); [EOL]     } [EOL]     boolean roundUp = false; [EOL]     for (final int[] aField : fields) { [EOL]         for (final int element : aField) { [EOL]             if (element == field) { [EOL]                 if (modType == MODIFY_CEILING || (modType == MODIFY_ROUND && roundUp)) { [EOL]                     if (field == DateUtils.SEMI_MONTH) { [EOL]                         if (val.get(Calendar.DATE) == 1) { [EOL]                             val.add(Calendar.DATE, 15); [EOL]                         } else { [EOL]                             val.add(Calendar.DATE, -15); [EOL]                             val.add(Calendar.MONTH, 1); [EOL]                         } [EOL]                     } else if (field == Calendar.AM_PM) { [EOL]                         if (val.get(Calendar.HOUR_OF_DAY) == 0) { [EOL]                             val.add(Calendar.HOUR_OF_DAY, 12); [EOL]                         } else { [EOL]                             val.add(Calendar.HOUR_OF_DAY, -12); [EOL]                             val.add(Calendar.DATE, 1); [EOL]                         } [EOL]                     } else { [EOL]                         val.add(aField[0], 1); [EOL]                     } [EOL]                 } [EOL]                 return; [EOL]             } [EOL]         } [EOL]         int offset = 0; [EOL]         boolean offsetSet = false; [EOL]         switch(field) { [EOL]             case DateUtils.SEMI_MONTH: [EOL]                 if (aField[0] == Calendar.DATE) { [EOL]                     offset = val.get(Calendar.DATE) - 1; [EOL]                     if (offset >= 15) { [EOL]                         offset -= 15; [EOL]                     } [EOL]                     roundUp = offset > 7; [EOL]                     offsetSet = true; [EOL]                 } [EOL]                 break; [EOL]             case Calendar.AM_PM: [EOL]                 if (aField[0] == Calendar.HOUR_OF_DAY) { [EOL]                     offset = val.get(Calendar.HOUR_OF_DAY); [EOL]                     if (offset >= 12) { [EOL]                         offset -= 12; [EOL]                     } [EOL]                     roundUp = offset >= 6; [EOL]                     offsetSet = true; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         if (!offsetSet) { [EOL]             final int min = val.getActualMinimum(aField[0]); [EOL]             final int max = val.getActualMaximum(aField[0]); [EOL]             offset = val.get(aField[0]) - min; [EOL]             roundUp = offset > ((max - min) / 2); [EOL]         } [EOL]         if (offset != 0) { [EOL]             val.set(aField[0], val.get(aField[0]) - offset); [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The field " + field + " is not supported"); [EOL] } 
 [LINE] throw new IllegalArgumentException("The date must not be null"); [LINE] public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle) { [EOL]     if (focus == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     final Calendar gval = Calendar.getInstance(); [EOL]     gval.setTime(focus); [EOL]     return iterator(gval, rangeStyle); [EOL] } 
 [LINE] case RANGE_WEEK_MONDAY: [LINE] public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle) { [EOL]     if (focus == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     Calendar start = null; [EOL]     Calendar end = null; [EOL]     int startCutoff = Calendar.SUNDAY; [EOL]     int endCutoff = Calendar.SATURDAY; [EOL]     switch(rangeStyle) { [EOL]         case RANGE_MONTH_SUNDAY: [EOL]         case RANGE_MONTH_MONDAY: [EOL]             start = truncate(focus, Calendar.MONTH); [EOL]             end = (Calendar) start.clone(); [EOL]             end.add(Calendar.MONTH, 1); [EOL]             end.add(Calendar.DATE, -1); [EOL]             if (rangeStyle == RANGE_MONTH_MONDAY) { [EOL]                 startCutoff = Calendar.MONDAY; [EOL]                 endCutoff = Calendar.SUNDAY; [EOL]             } [EOL]             break; [EOL]         case RANGE_WEEK_SUNDAY: [EOL]         case RANGE_WEEK_MONDAY: [EOL]         case RANGE_WEEK_RELATIVE: [EOL]         case RANGE_WEEK_CENTER: [EOL]             start = truncate(focus, Calendar.DATE); [EOL]             end = truncate(focus, Calendar.DATE); [EOL]             switch(rangeStyle) { [EOL]                 case RANGE_WEEK_SUNDAY: [EOL]                     break; [EOL]                 case RANGE_WEEK_MONDAY: [EOL]                     startCutoff = Calendar.MONDAY; [EOL]                     endCutoff = Calendar.SUNDAY; [EOL]                     break; [EOL]                 case RANGE_WEEK_RELATIVE: [EOL]                     startCutoff = focus.get(Calendar.DAY_OF_WEEK); [EOL]                     endCutoff = startCutoff - 1; [EOL]                     break; [EOL]                 case RANGE_WEEK_CENTER: [EOL]                     startCutoff = focus.get(Calendar.DAY_OF_WEEK) - 3; [EOL]                     endCutoff = focus.get(Calendar.DAY_OF_WEEK) + 3; [EOL]                     break; [EOL]             } [EOL]             break; [EOL]         default: [EOL]             throw new IllegalArgumentException("The range style " + rangeStyle + " is not valid."); [EOL]     } [EOL]     if (startCutoff < Calendar.SUNDAY) { [EOL]         startCutoff += 7; [EOL]     } [EOL]     if (startCutoff > Calendar.SATURDAY) { [EOL]         startCutoff -= 7; [EOL]     } [EOL]     if (endCutoff < Calendar.SUNDAY) { [EOL]         endCutoff += 7; [EOL]     } [EOL]     if (endCutoff > Calendar.SATURDAY) { [EOL]         endCutoff -= 7; [EOL]     } [EOL]     while (start.get(Calendar.DAY_OF_WEEK) != startCutoff) { [EOL]         start.add(Calendar.DATE, -1); [EOL]     } [EOL]     while (end.get(Calendar.DAY_OF_WEEK) != endCutoff) { [EOL]         end.add(Calendar.DATE, 1); [EOL]     } [EOL]     return new DateIterator(start, end); [EOL] } 
 [LINE] case RANGE_WEEK_CENTER: [LINE] public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle) { [EOL]     if (focus == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     Calendar start = null; [EOL]     Calendar end = null; [EOL]     int startCutoff = Calendar.SUNDAY; [EOL]     int endCutoff = Calendar.SATURDAY; [EOL]     switch(rangeStyle) { [EOL]         case RANGE_MONTH_SUNDAY: [EOL]         case RANGE_MONTH_MONDAY: [EOL]             start = truncate(focus, Calendar.MONTH); [EOL]             end = (Calendar) start.clone(); [EOL]             end.add(Calendar.MONTH, 1); [EOL]             end.add(Calendar.DATE, -1); [EOL]             if (rangeStyle == RANGE_MONTH_MONDAY) { [EOL]                 startCutoff = Calendar.MONDAY; [EOL]                 endCutoff = Calendar.SUNDAY; [EOL]             } [EOL]             break; [EOL]         case RANGE_WEEK_SUNDAY: [EOL]         case RANGE_WEEK_MONDAY: [EOL]         case RANGE_WEEK_RELATIVE: [EOL]         case RANGE_WEEK_CENTER: [EOL]             start = truncate(focus, Calendar.DATE); [EOL]             end = truncate(focus, Calendar.DATE); [EOL]             switch(rangeStyle) { [EOL]                 case RANGE_WEEK_SUNDAY: [EOL]                     break; [EOL]                 case RANGE_WEEK_MONDAY: [EOL]                     startCutoff = Calendar.MONDAY; [EOL]                     endCutoff = Calendar.SUNDAY; [EOL]                     break; [EOL]                 case RANGE_WEEK_RELATIVE: [EOL]                     startCutoff = focus.get(Calendar.DAY_OF_WEEK); [EOL]                     endCutoff = startCutoff - 1; [EOL]                     break; [EOL]                 case RANGE_WEEK_CENTER: [EOL]                     startCutoff = focus.get(Calendar.DAY_OF_WEEK) - 3; [EOL]                     endCutoff = focus.get(Calendar.DAY_OF_WEEK) + 3; [EOL]                     break; [EOL]             } [EOL]             break; [EOL]         default: [EOL]             throw new IllegalArgumentException("The range style " + rangeStyle + " is not valid."); [EOL]     } [EOL]     if (startCutoff < Calendar.SUNDAY) { [EOL]         startCutoff += 7; [EOL]     } [EOL]     if (startCutoff > Calendar.SATURDAY) { [EOL]         startCutoff -= 7; [EOL]     } [EOL]     if (endCutoff < Calendar.SUNDAY) { [EOL]         endCutoff += 7; [EOL]     } [EOL]     if (endCutoff > Calendar.SATURDAY) { [EOL]         endCutoff -= 7; [EOL]     } [EOL]     while (start.get(Calendar.DAY_OF_WEEK) != startCutoff) { [EOL]         start.add(Calendar.DATE, -1); [EOL]     } [EOL]     while (end.get(Calendar.DAY_OF_WEEK) != endCutoff) { [EOL]         end.add(Calendar.DATE, 1); [EOL]     } [EOL]     return new DateIterator(start, end); [EOL] } 
 [LINE] case RANGE_WEEK_MONDAY: [LINE] public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle) { [EOL]     if (focus == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     Calendar start = null; [EOL]     Calendar end = null; [EOL]     int startCutoff = Calendar.SUNDAY; [EOL]     int endCutoff = Calendar.SATURDAY; [EOL]     switch(rangeStyle) { [EOL]         case RANGE_MONTH_SUNDAY: [EOL]         case RANGE_MONTH_MONDAY: [EOL]             start = truncate(focus, Calendar.MONTH); [EOL]             end = (Calendar) start.clone(); [EOL]             end.add(Calendar.MONTH, 1); [EOL]             end.add(Calendar.DATE, -1); [EOL]             if (rangeStyle == RANGE_MONTH_MONDAY) { [EOL]                 startCutoff = Calendar.MONDAY; [EOL]                 endCutoff = Calendar.SUNDAY; [EOL]             } [EOL]             break; [EOL]         case RANGE_WEEK_SUNDAY: [EOL]         case RANGE_WEEK_MONDAY: [EOL]         case RANGE_WEEK_RELATIVE: [EOL]         case RANGE_WEEK_CENTER: [EOL]             start = truncate(focus, Calendar.DATE); [EOL]             end = truncate(focus, Calendar.DATE); [EOL]             switch(rangeStyle) { [EOL]                 case RANGE_WEEK_SUNDAY: [EOL]                     break; [EOL]                 case RANGE_WEEK_MONDAY: [EOL]                     startCutoff = Calendar.MONDAY; [EOL]                     endCutoff = Calendar.SUNDAY; [EOL]                     break; [EOL]                 case RANGE_WEEK_RELATIVE: [EOL]                     startCutoff = focus.get(Calendar.DAY_OF_WEEK); [EOL]                     endCutoff = startCutoff - 1; [EOL]                     break; [EOL]                 case RANGE_WEEK_CENTER: [EOL]                     startCutoff = focus.get(Calendar.DAY_OF_WEEK) - 3; [EOL]                     endCutoff = focus.get(Calendar.DAY_OF_WEEK) + 3; [EOL]                     break; [EOL]             } [EOL]             break; [EOL]         default: [EOL]             throw new IllegalArgumentException("The range style " + rangeStyle + " is not valid."); [EOL]     } [EOL]     if (startCutoff < Calendar.SUNDAY) { [EOL]         startCutoff += 7; [EOL]     } [EOL]     if (startCutoff > Calendar.SATURDAY) { [EOL]         startCutoff -= 7; [EOL]     } [EOL]     if (endCutoff < Calendar.SUNDAY) { [EOL]         endCutoff += 7; [EOL]     } [EOL]     if (endCutoff > Calendar.SATURDAY) { [EOL]         endCutoff -= 7; [EOL]     } [EOL]     while (start.get(Calendar.DAY_OF_WEEK) != startCutoff) { [EOL]         start.add(Calendar.DATE, -1); [EOL]     } [EOL]     while (end.get(Calendar.DAY_OF_WEEK) != endCutoff) { [EOL]         end.add(Calendar.DATE, 1); [EOL]     } [EOL]     return new DateIterator(start, end); [EOL] } 
 [LINE] startCutoff = Calendar.MONDAY; [LINE] public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle) { [EOL]     if (focus == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     Calendar start = null; [EOL]     Calendar end = null; [EOL]     int startCutoff = Calendar.SUNDAY; [EOL]     int endCutoff = Calendar.SATURDAY; [EOL]     switch(rangeStyle) { [EOL]         case RANGE_MONTH_SUNDAY: [EOL]         case RANGE_MONTH_MONDAY: [EOL]             start = truncate(focus, Calendar.MONTH); [EOL]             end = (Calendar) start.clone(); [EOL]             end.add(Calendar.MONTH, 1); [EOL]             end.add(Calendar.DATE, -1); [EOL]             if (rangeStyle == RANGE_MONTH_MONDAY) { [EOL]                 startCutoff = Calendar.MONDAY; [EOL]                 endCutoff = Calendar.SUNDAY; [EOL]             } [EOL]             break; [EOL]         case RANGE_WEEK_SUNDAY: [EOL]         case RANGE_WEEK_MONDAY: [EOL]         case RANGE_WEEK_RELATIVE: [EOL]         case RANGE_WEEK_CENTER: [EOL]             start = truncate(focus, Calendar.DATE); [EOL]             end = truncate(focus, Calendar.DATE); [EOL]             switch(rangeStyle) { [EOL]                 case RANGE_WEEK_SUNDAY: [EOL]                     break; [EOL]                 case RANGE_WEEK_MONDAY: [EOL]                     startCutoff = Calendar.MONDAY; [EOL]                     endCutoff = Calendar.SUNDAY; [EOL]                     break; [EOL]                 case RANGE_WEEK_RELATIVE: [EOL]                     startCutoff = focus.get(Calendar.DAY_OF_WEEK); [EOL]                     endCutoff = startCutoff - 1; [EOL]                     break; [EOL]                 case RANGE_WEEK_CENTER: [EOL]                     startCutoff = focus.get(Calendar.DAY_OF_WEEK) - 3; [EOL]                     endCutoff = focus.get(Calendar.DAY_OF_WEEK) + 3; [EOL]                     break; [EOL]             } [EOL]             break; [EOL]         default: [EOL]             throw new IllegalArgumentException("The range style " + rangeStyle + " is not valid."); [EOL]     } [EOL]     if (startCutoff < Calendar.SUNDAY) { [EOL]         startCutoff += 7; [EOL]     } [EOL]     if (startCutoff > Calendar.SATURDAY) { [EOL]         startCutoff -= 7; [EOL]     } [EOL]     if (endCutoff < Calendar.SUNDAY) { [EOL]         endCutoff += 7; [EOL]     } [EOL]     if (endCutoff > Calendar.SATURDAY) { [EOL]         endCutoff -= 7; [EOL]     } [EOL]     while (start.get(Calendar.DAY_OF_WEEK) != startCutoff) { [EOL]         start.add(Calendar.DATE, -1); [EOL]     } [EOL]     while (end.get(Calendar.DAY_OF_WEEK) != endCutoff) { [EOL]         end.add(Calendar.DATE, 1); [EOL]     } [EOL]     return new DateIterator(start, end); [EOL] } 
 [LINE] endCutoff = Calendar.SUNDAY; [LINE] public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle) { [EOL]     if (focus == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     Calendar start = null; [EOL]     Calendar end = null; [EOL]     int startCutoff = Calendar.SUNDAY; [EOL]     int endCutoff = Calendar.SATURDAY; [EOL]     switch(rangeStyle) { [EOL]         case RANGE_MONTH_SUNDAY: [EOL]         case RANGE_MONTH_MONDAY: [EOL]             start = truncate(focus, Calendar.MONTH); [EOL]             end = (Calendar) start.clone(); [EOL]             end.add(Calendar.MONTH, 1); [EOL]             end.add(Calendar.DATE, -1); [EOL]             if (rangeStyle == RANGE_MONTH_MONDAY) { [EOL]                 startCutoff = Calendar.MONDAY; [EOL]                 endCutoff = Calendar.SUNDAY; [EOL]             } [EOL]             break; [EOL]         case RANGE_WEEK_SUNDAY: [EOL]         case RANGE_WEEK_MONDAY: [EOL]         case RANGE_WEEK_RELATIVE: [EOL]         case RANGE_WEEK_CENTER: [EOL]             start = truncate(focus, Calendar.DATE); [EOL]             end = truncate(focus, Calendar.DATE); [EOL]             switch(rangeStyle) { [EOL]                 case RANGE_WEEK_SUNDAY: [EOL]                     break; [EOL]                 case RANGE_WEEK_MONDAY: [EOL]                     startCutoff = Calendar.MONDAY; [EOL]                     endCutoff = Calendar.SUNDAY; [EOL]                     break; [EOL]                 case RANGE_WEEK_RELATIVE: [EOL]                     startCutoff = focus.get(Calendar.DAY_OF_WEEK); [EOL]                     endCutoff = startCutoff - 1; [EOL]                     break; [EOL]                 case RANGE_WEEK_CENTER: [EOL]                     startCutoff = focus.get(Calendar.DAY_OF_WEEK) - 3; [EOL]                     endCutoff = focus.get(Calendar.DAY_OF_WEEK) + 3; [EOL]                     break; [EOL]             } [EOL]             break; [EOL]         default: [EOL]             throw new IllegalArgumentException("The range style " + rangeStyle + " is not valid."); [EOL]     } [EOL]     if (startCutoff < Calendar.SUNDAY) { [EOL]         startCutoff += 7; [EOL]     } [EOL]     if (startCutoff > Calendar.SATURDAY) { [EOL]         startCutoff -= 7; [EOL]     } [EOL]     if (endCutoff < Calendar.SUNDAY) { [EOL]         endCutoff += 7; [EOL]     } [EOL]     if (endCutoff > Calendar.SATURDAY) { [EOL]         endCutoff -= 7; [EOL]     } [EOL]     while (start.get(Calendar.DAY_OF_WEEK) != startCutoff) { [EOL]         start.add(Calendar.DATE, -1); [EOL]     } [EOL]     while (end.get(Calendar.DAY_OF_WEEK) != endCutoff) { [EOL]         end.add(Calendar.DATE, 1); [EOL]     } [EOL]     return new DateIterator(start, end); [EOL] } 
 [LINE] break; [LINE] public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle) { [EOL]     if (focus == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     Calendar start = null; [EOL]     Calendar end = null; [EOL]     int startCutoff = Calendar.SUNDAY; [EOL]     int endCutoff = Calendar.SATURDAY; [EOL]     switch(rangeStyle) { [EOL]         case RANGE_MONTH_SUNDAY: [EOL]         case RANGE_MONTH_MONDAY: [EOL]             start = truncate(focus, Calendar.MONTH); [EOL]             end = (Calendar) start.clone(); [EOL]             end.add(Calendar.MONTH, 1); [EOL]             end.add(Calendar.DATE, -1); [EOL]             if (rangeStyle == RANGE_MONTH_MONDAY) { [EOL]                 startCutoff = Calendar.MONDAY; [EOL]                 endCutoff = Calendar.SUNDAY; [EOL]             } [EOL]             break; [EOL]         case RANGE_WEEK_SUNDAY: [EOL]         case RANGE_WEEK_MONDAY: [EOL]         case RANGE_WEEK_RELATIVE: [EOL]         case RANGE_WEEK_CENTER: [EOL]             start = truncate(focus, Calendar.DATE); [EOL]             end = truncate(focus, Calendar.DATE); [EOL]             switch(rangeStyle) { [EOL]                 case RANGE_WEEK_SUNDAY: [EOL]                     break; [EOL]                 case RANGE_WEEK_MONDAY: [EOL]                     startCutoff = Calendar.MONDAY; [EOL]                     endCutoff = Calendar.SUNDAY; [EOL]                     break; [EOL]                 case RANGE_WEEK_RELATIVE: [EOL]                     startCutoff = focus.get(Calendar.DAY_OF_WEEK); [EOL]                     endCutoff = startCutoff - 1; [EOL]                     break; [EOL]                 case RANGE_WEEK_CENTER: [EOL]                     startCutoff = focus.get(Calendar.DAY_OF_WEEK) - 3; [EOL]                     endCutoff = focus.get(Calendar.DAY_OF_WEEK) + 3; [EOL]                     break; [EOL]             } [EOL]             break; [EOL]         default: [EOL]             throw new IllegalArgumentException("The range style " + rangeStyle + " is not valid."); [EOL]     } [EOL]     if (startCutoff < Calendar.SUNDAY) { [EOL]         startCutoff += 7; [EOL]     } [EOL]     if (startCutoff > Calendar.SATURDAY) { [EOL]         startCutoff -= 7; [EOL]     } [EOL]     if (endCutoff < Calendar.SUNDAY) { [EOL]         endCutoff += 7; [EOL]     } [EOL]     if (endCutoff > Calendar.SATURDAY) { [EOL]         endCutoff -= 7; [EOL]     } [EOL]     while (start.get(Calendar.DAY_OF_WEEK) != startCutoff) { [EOL]         start.add(Calendar.DATE, -1); [EOL]     } [EOL]     while (end.get(Calendar.DAY_OF_WEEK) != endCutoff) { [EOL]         end.add(Calendar.DATE, 1); [EOL]     } [EOL]     return new DateIterator(start, end); [EOL] } 
 [LINE] case RANGE_WEEK_CENTER: [LINE] public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle) { [EOL]     if (focus == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     Calendar start = null; [EOL]     Calendar end = null; [EOL]     int startCutoff = Calendar.SUNDAY; [EOL]     int endCutoff = Calendar.SATURDAY; [EOL]     switch(rangeStyle) { [EOL]         case RANGE_MONTH_SUNDAY: [EOL]         case RANGE_MONTH_MONDAY: [EOL]             start = truncate(focus, Calendar.MONTH); [EOL]             end = (Calendar) start.clone(); [EOL]             end.add(Calendar.MONTH, 1); [EOL]             end.add(Calendar.DATE, -1); [EOL]             if (rangeStyle == RANGE_MONTH_MONDAY) { [EOL]                 startCutoff = Calendar.MONDAY; [EOL]                 endCutoff = Calendar.SUNDAY; [EOL]             } [EOL]             break; [EOL]         case RANGE_WEEK_SUNDAY: [EOL]         case RANGE_WEEK_MONDAY: [EOL]         case RANGE_WEEK_RELATIVE: [EOL]         case RANGE_WEEK_CENTER: [EOL]             start = truncate(focus, Calendar.DATE); [EOL]             end = truncate(focus, Calendar.DATE); [EOL]             switch(rangeStyle) { [EOL]                 case RANGE_WEEK_SUNDAY: [EOL]                     break; [EOL]                 case RANGE_WEEK_MONDAY: [EOL]                     startCutoff = Calendar.MONDAY; [EOL]                     endCutoff = Calendar.SUNDAY; [EOL]                     break; [EOL]                 case RANGE_WEEK_RELATIVE: [EOL]                     startCutoff = focus.get(Calendar.DAY_OF_WEEK); [EOL]                     endCutoff = startCutoff - 1; [EOL]                     break; [EOL]                 case RANGE_WEEK_CENTER: [EOL]                     startCutoff = focus.get(Calendar.DAY_OF_WEEK) - 3; [EOL]                     endCutoff = focus.get(Calendar.DAY_OF_WEEK) + 3; [EOL]                     break; [EOL]             } [EOL]             break; [EOL]         default: [EOL]             throw new IllegalArgumentException("The range style " + rangeStyle + " is not valid."); [EOL]     } [EOL]     if (startCutoff < Calendar.SUNDAY) { [EOL]         startCutoff += 7; [EOL]     } [EOL]     if (startCutoff > Calendar.SATURDAY) { [EOL]         startCutoff -= 7; [EOL]     } [EOL]     if (endCutoff < Calendar.SUNDAY) { [EOL]         endCutoff += 7; [EOL]     } [EOL]     if (endCutoff > Calendar.SATURDAY) { [EOL]         endCutoff -= 7; [EOL]     } [EOL]     while (start.get(Calendar.DAY_OF_WEEK) != startCutoff) { [EOL]         start.add(Calendar.DATE, -1); [EOL]     } [EOL]     while (end.get(Calendar.DAY_OF_WEEK) != endCutoff) { [EOL]         end.add(Calendar.DATE, 1); [EOL]     } [EOL]     return new DateIterator(start, end); [EOL] } 
 [LINE] startCutoff = focus.get(Calendar.DAY_OF_WEEK) - 3; [LINE] public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle) { [EOL]     if (focus == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     Calendar start = null; [EOL]     Calendar end = null; [EOL]     int startCutoff = Calendar.SUNDAY; [EOL]     int endCutoff = Calendar.SATURDAY; [EOL]     switch(rangeStyle) { [EOL]         case RANGE_MONTH_SUNDAY: [EOL]         case RANGE_MONTH_MONDAY: [EOL]             start = truncate(focus, Calendar.MONTH); [EOL]             end = (Calendar) start.clone(); [EOL]             end.add(Calendar.MONTH, 1); [EOL]             end.add(Calendar.DATE, -1); [EOL]             if (rangeStyle == RANGE_MONTH_MONDAY) { [EOL]                 startCutoff = Calendar.MONDAY; [EOL]                 endCutoff = Calendar.SUNDAY; [EOL]             } [EOL]             break; [EOL]         case RANGE_WEEK_SUNDAY: [EOL]         case RANGE_WEEK_MONDAY: [EOL]         case RANGE_WEEK_RELATIVE: [EOL]         case RANGE_WEEK_CENTER: [EOL]             start = truncate(focus, Calendar.DATE); [EOL]             end = truncate(focus, Calendar.DATE); [EOL]             switch(rangeStyle) { [EOL]                 case RANGE_WEEK_SUNDAY: [EOL]                     break; [EOL]                 case RANGE_WEEK_MONDAY: [EOL]                     startCutoff = Calendar.MONDAY; [EOL]                     endCutoff = Calendar.SUNDAY; [EOL]                     break; [EOL]                 case RANGE_WEEK_RELATIVE: [EOL]                     startCutoff = focus.get(Calendar.DAY_OF_WEEK); [EOL]                     endCutoff = startCutoff - 1; [EOL]                     break; [EOL]                 case RANGE_WEEK_CENTER: [EOL]                     startCutoff = focus.get(Calendar.DAY_OF_WEEK) - 3; [EOL]                     endCutoff = focus.get(Calendar.DAY_OF_WEEK) + 3; [EOL]                     break; [EOL]             } [EOL]             break; [EOL]         default: [EOL]             throw new IllegalArgumentException("The range style " + rangeStyle + " is not valid."); [EOL]     } [EOL]     if (startCutoff < Calendar.SUNDAY) { [EOL]         startCutoff += 7; [EOL]     } [EOL]     if (startCutoff > Calendar.SATURDAY) { [EOL]         startCutoff -= 7; [EOL]     } [EOL]     if (endCutoff < Calendar.SUNDAY) { [EOL]         endCutoff += 7; [EOL]     } [EOL]     if (endCutoff > Calendar.SATURDAY) { [EOL]         endCutoff -= 7; [EOL]     } [EOL]     while (start.get(Calendar.DAY_OF_WEEK) != startCutoff) { [EOL]         start.add(Calendar.DATE, -1); [EOL]     } [EOL]     while (end.get(Calendar.DAY_OF_WEEK) != endCutoff) { [EOL]         end.add(Calendar.DATE, 1); [EOL]     } [EOL]     return new DateIterator(start, end); [EOL] } 
 [LINE] endCutoff = focus.get(Calendar.DAY_OF_WEEK) + 3; [LINE] public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle) { [EOL]     if (focus == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     Calendar start = null; [EOL]     Calendar end = null; [EOL]     int startCutoff = Calendar.SUNDAY; [EOL]     int endCutoff = Calendar.SATURDAY; [EOL]     switch(rangeStyle) { [EOL]         case RANGE_MONTH_SUNDAY: [EOL]         case RANGE_MONTH_MONDAY: [EOL]             start = truncate(focus, Calendar.MONTH); [EOL]             end = (Calendar) start.clone(); [EOL]             end.add(Calendar.MONTH, 1); [EOL]             end.add(Calendar.DATE, -1); [EOL]             if (rangeStyle == RANGE_MONTH_MONDAY) { [EOL]                 startCutoff = Calendar.MONDAY; [EOL]                 endCutoff = Calendar.SUNDAY; [EOL]             } [EOL]             break; [EOL]         case RANGE_WEEK_SUNDAY: [EOL]         case RANGE_WEEK_MONDAY: [EOL]         case RANGE_WEEK_RELATIVE: [EOL]         case RANGE_WEEK_CENTER: [EOL]             start = truncate(focus, Calendar.DATE); [EOL]             end = truncate(focus, Calendar.DATE); [EOL]             switch(rangeStyle) { [EOL]                 case RANGE_WEEK_SUNDAY: [EOL]                     break; [EOL]                 case RANGE_WEEK_MONDAY: [EOL]                     startCutoff = Calendar.MONDAY; [EOL]                     endCutoff = Calendar.SUNDAY; [EOL]                     break; [EOL]                 case RANGE_WEEK_RELATIVE: [EOL]                     startCutoff = focus.get(Calendar.DAY_OF_WEEK); [EOL]                     endCutoff = startCutoff - 1; [EOL]                     break; [EOL]                 case RANGE_WEEK_CENTER: [EOL]                     startCutoff = focus.get(Calendar.DAY_OF_WEEK) - 3; [EOL]                     endCutoff = focus.get(Calendar.DAY_OF_WEEK) + 3; [EOL]                     break; [EOL]             } [EOL]             break; [EOL]         default: [EOL]             throw new IllegalArgumentException("The range style " + rangeStyle + " is not valid."); [EOL]     } [EOL]     if (startCutoff < Calendar.SUNDAY) { [EOL]         startCutoff += 7; [EOL]     } [EOL]     if (startCutoff > Calendar.SATURDAY) { [EOL]         startCutoff -= 7; [EOL]     } [EOL]     if (endCutoff < Calendar.SUNDAY) { [EOL]         endCutoff += 7; [EOL]     } [EOL]     if (endCutoff > Calendar.SATURDAY) { [EOL]         endCutoff -= 7; [EOL]     } [EOL]     while (start.get(Calendar.DAY_OF_WEEK) != startCutoff) { [EOL]         start.add(Calendar.DATE, -1); [EOL]     } [EOL]     while (end.get(Calendar.DAY_OF_WEEK) != endCutoff) { [EOL]         end.add(Calendar.DATE, 1); [EOL]     } [EOL]     return new DateIterator(start, end); [EOL] } 
 [LINE] break; [LINE] public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle) { [EOL]     if (focus == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     Calendar start = null; [EOL]     Calendar end = null; [EOL]     int startCutoff = Calendar.SUNDAY; [EOL]     int endCutoff = Calendar.SATURDAY; [EOL]     switch(rangeStyle) { [EOL]         case RANGE_MONTH_SUNDAY: [EOL]         case RANGE_MONTH_MONDAY: [EOL]             start = truncate(focus, Calendar.MONTH); [EOL]             end = (Calendar) start.clone(); [EOL]             end.add(Calendar.MONTH, 1); [EOL]             end.add(Calendar.DATE, -1); [EOL]             if (rangeStyle == RANGE_MONTH_MONDAY) { [EOL]                 startCutoff = Calendar.MONDAY; [EOL]                 endCutoff = Calendar.SUNDAY; [EOL]             } [EOL]             break; [EOL]         case RANGE_WEEK_SUNDAY: [EOL]         case RANGE_WEEK_MONDAY: [EOL]         case RANGE_WEEK_RELATIVE: [EOL]         case RANGE_WEEK_CENTER: [EOL]             start = truncate(focus, Calendar.DATE); [EOL]             end = truncate(focus, Calendar.DATE); [EOL]             switch(rangeStyle) { [EOL]                 case RANGE_WEEK_SUNDAY: [EOL]                     break; [EOL]                 case RANGE_WEEK_MONDAY: [EOL]                     startCutoff = Calendar.MONDAY; [EOL]                     endCutoff = Calendar.SUNDAY; [EOL]                     break; [EOL]                 case RANGE_WEEK_RELATIVE: [EOL]                     startCutoff = focus.get(Calendar.DAY_OF_WEEK); [EOL]                     endCutoff = startCutoff - 1; [EOL]                     break; [EOL]                 case RANGE_WEEK_CENTER: [EOL]                     startCutoff = focus.get(Calendar.DAY_OF_WEEK) - 3; [EOL]                     endCutoff = focus.get(Calendar.DAY_OF_WEEK) + 3; [EOL]                     break; [EOL]             } [EOL]             break; [EOL]         default: [EOL]             throw new IllegalArgumentException("The range style " + rangeStyle + " is not valid."); [EOL]     } [EOL]     if (startCutoff < Calendar.SUNDAY) { [EOL]         startCutoff += 7; [EOL]     } [EOL]     if (startCutoff > Calendar.SATURDAY) { [EOL]         startCutoff -= 7; [EOL]     } [EOL]     if (endCutoff < Calendar.SUNDAY) { [EOL]         endCutoff += 7; [EOL]     } [EOL]     if (endCutoff > Calendar.SATURDAY) { [EOL]         endCutoff -= 7; [EOL]     } [EOL]     while (start.get(Calendar.DAY_OF_WEEK) != startCutoff) { [EOL]         start.add(Calendar.DATE, -1); [EOL]     } [EOL]     while (end.get(Calendar.DAY_OF_WEEK) != endCutoff) { [EOL]         end.add(Calendar.DATE, 1); [EOL]     } [EOL]     return new DateIterator(start, end); [EOL] } 
 [LINE] startCutoff += 7; [LINE] public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle) { [EOL]     if (focus == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     Calendar start = null; [EOL]     Calendar end = null; [EOL]     int startCutoff = Calendar.SUNDAY; [EOL]     int endCutoff = Calendar.SATURDAY; [EOL]     switch(rangeStyle) { [EOL]         case RANGE_MONTH_SUNDAY: [EOL]         case RANGE_MONTH_MONDAY: [EOL]             start = truncate(focus, Calendar.MONTH); [EOL]             end = (Calendar) start.clone(); [EOL]             end.add(Calendar.MONTH, 1); [EOL]             end.add(Calendar.DATE, -1); [EOL]             if (rangeStyle == RANGE_MONTH_MONDAY) { [EOL]                 startCutoff = Calendar.MONDAY; [EOL]                 endCutoff = Calendar.SUNDAY; [EOL]             } [EOL]             break; [EOL]         case RANGE_WEEK_SUNDAY: [EOL]         case RANGE_WEEK_MONDAY: [EOL]         case RANGE_WEEK_RELATIVE: [EOL]         case RANGE_WEEK_CENTER: [EOL]             start = truncate(focus, Calendar.DATE); [EOL]             end = truncate(focus, Calendar.DATE); [EOL]             switch(rangeStyle) { [EOL]                 case RANGE_WEEK_SUNDAY: [EOL]                     break; [EOL]                 case RANGE_WEEK_MONDAY: [EOL]                     startCutoff = Calendar.MONDAY; [EOL]                     endCutoff = Calendar.SUNDAY; [EOL]                     break; [EOL]                 case RANGE_WEEK_RELATIVE: [EOL]                     startCutoff = focus.get(Calendar.DAY_OF_WEEK); [EOL]                     endCutoff = startCutoff - 1; [EOL]                     break; [EOL]                 case RANGE_WEEK_CENTER: [EOL]                     startCutoff = focus.get(Calendar.DAY_OF_WEEK) - 3; [EOL]                     endCutoff = focus.get(Calendar.DAY_OF_WEEK) + 3; [EOL]                     break; [EOL]             } [EOL]             break; [EOL]         default: [EOL]             throw new IllegalArgumentException("The range style " + rangeStyle + " is not valid."); [EOL]     } [EOL]     if (startCutoff < Calendar.SUNDAY) { [EOL]         startCutoff += 7; [EOL]     } [EOL]     if (startCutoff > Calendar.SATURDAY) { [EOL]         startCutoff -= 7; [EOL]     } [EOL]     if (endCutoff < Calendar.SUNDAY) { [EOL]         endCutoff += 7; [EOL]     } [EOL]     if (endCutoff > Calendar.SATURDAY) { [EOL]         endCutoff -= 7; [EOL]     } [EOL]     while (start.get(Calendar.DAY_OF_WEEK) != startCutoff) { [EOL]         start.add(Calendar.DATE, -1); [EOL]     } [EOL]     while (end.get(Calendar.DAY_OF_WEEK) != endCutoff) { [EOL]         end.add(Calendar.DATE, 1); [EOL]     } [EOL]     return new DateIterator(start, end); [EOL] } 
 [LINE] endCutoff -= 7; [LINE] public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle) { [EOL]     if (focus == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     Calendar start = null; [EOL]     Calendar end = null; [EOL]     int startCutoff = Calendar.SUNDAY; [EOL]     int endCutoff = Calendar.SATURDAY; [EOL]     switch(rangeStyle) { [EOL]         case RANGE_MONTH_SUNDAY: [EOL]         case RANGE_MONTH_MONDAY: [EOL]             start = truncate(focus, Calendar.MONTH); [EOL]             end = (Calendar) start.clone(); [EOL]             end.add(Calendar.MONTH, 1); [EOL]             end.add(Calendar.DATE, -1); [EOL]             if (rangeStyle == RANGE_MONTH_MONDAY) { [EOL]                 startCutoff = Calendar.MONDAY; [EOL]                 endCutoff = Calendar.SUNDAY; [EOL]             } [EOL]             break; [EOL]         case RANGE_WEEK_SUNDAY: [EOL]         case RANGE_WEEK_MONDAY: [EOL]         case RANGE_WEEK_RELATIVE: [EOL]         case RANGE_WEEK_CENTER: [EOL]             start = truncate(focus, Calendar.DATE); [EOL]             end = truncate(focus, Calendar.DATE); [EOL]             switch(rangeStyle) { [EOL]                 case RANGE_WEEK_SUNDAY: [EOL]                     break; [EOL]                 case RANGE_WEEK_MONDAY: [EOL]                     startCutoff = Calendar.MONDAY; [EOL]                     endCutoff = Calendar.SUNDAY; [EOL]                     break; [EOL]                 case RANGE_WEEK_RELATIVE: [EOL]                     startCutoff = focus.get(Calendar.DAY_OF_WEEK); [EOL]                     endCutoff = startCutoff - 1; [EOL]                     break; [EOL]                 case RANGE_WEEK_CENTER: [EOL]                     startCutoff = focus.get(Calendar.DAY_OF_WEEK) - 3; [EOL]                     endCutoff = focus.get(Calendar.DAY_OF_WEEK) + 3; [EOL]                     break; [EOL]             } [EOL]             break; [EOL]         default: [EOL]             throw new IllegalArgumentException("The range style " + rangeStyle + " is not valid."); [EOL]     } [EOL]     if (startCutoff < Calendar.SUNDAY) { [EOL]         startCutoff += 7; [EOL]     } [EOL]     if (startCutoff > Calendar.SATURDAY) { [EOL]         startCutoff -= 7; [EOL]     } [EOL]     if (endCutoff < Calendar.SUNDAY) { [EOL]         endCutoff += 7; [EOL]     } [EOL]     if (endCutoff > Calendar.SATURDAY) { [EOL]         endCutoff -= 7; [EOL]     } [EOL]     while (start.get(Calendar.DAY_OF_WEEK) != startCutoff) { [EOL]         start.add(Calendar.DATE, -1); [EOL]     } [EOL]     while (end.get(Calendar.DAY_OF_WEEK) != endCutoff) { [EOL]         end.add(Calendar.DATE, 1); [EOL]     } [EOL]     return new DateIterator(start, end); [EOL] } 
 [LINE] return iterator((Calendar) focus, rangeStyle); [LINE] public static Iterator<?> iterator(final Object focus, final int rangeStyle) { [EOL]     if (focus == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     if (focus instanceof Date) { [EOL]         return iterator((Date) focus, rangeStyle); [EOL]     } else if (focus instanceof Calendar) { [EOL]         return iterator((Calendar) focus, rangeStyle); [EOL]     } else { [EOL]         throw new ClassCastException("Could not iterate based on " + focus); [EOL]     } [EOL] } 
 [LINE] case Calendar.DAY_OF_YEAR: [LINE] private static long getFragment(final Calendar calendar, final int fragment, final int unit) { [EOL]     if (calendar == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     final long millisPerUnit = getMillisPerUnit(unit); [EOL]     long result = 0; [EOL]     switch(fragment) { [EOL]         case Calendar.YEAR: [EOL]             result += (calendar.get(Calendar.DAY_OF_YEAR) * MILLIS_PER_DAY) / millisPerUnit; [EOL]             break; [EOL]         case Calendar.MONTH: [EOL]             result += (calendar.get(Calendar.DAY_OF_MONTH) * MILLIS_PER_DAY) / millisPerUnit; [EOL]             break; [EOL]     } [EOL]     switch(fragment) { [EOL]         case Calendar.YEAR: [EOL]         case Calendar.MONTH: [EOL]         case Calendar.DAY_OF_YEAR: [EOL]         case Calendar.DATE: [EOL]             result += (calendar.get(Calendar.HOUR_OF_DAY) * MILLIS_PER_HOUR) / millisPerUnit; [EOL]         case Calendar.HOUR_OF_DAY: [EOL]             result += (calendar.get(Calendar.MINUTE) * MILLIS_PER_MINUTE) / millisPerUnit; [EOL]         case Calendar.MINUTE: [EOL]             result += (calendar.get(Calendar.SECOND) * MILLIS_PER_SECOND) / millisPerUnit; [EOL]         case Calendar.SECOND: [EOL]             result += (calendar.get(Calendar.MILLISECOND) * 1) / millisPerUnit; [EOL]             break; [EOL]         case Calendar.MILLISECOND: [EOL]             break; [EOL]         default: [EOL]             throw new IllegalArgumentException("The fragment " + fragment + " is not supported"); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] case Calendar.HOUR_OF_DAY: [LINE] private static long getFragment(final Calendar calendar, final int fragment, final int unit) { [EOL]     if (calendar == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     final long millisPerUnit = getMillisPerUnit(unit); [EOL]     long result = 0; [EOL]     switch(fragment) { [EOL]         case Calendar.YEAR: [EOL]             result += (calendar.get(Calendar.DAY_OF_YEAR) * MILLIS_PER_DAY) / millisPerUnit; [EOL]             break; [EOL]         case Calendar.MONTH: [EOL]             result += (calendar.get(Calendar.DAY_OF_MONTH) * MILLIS_PER_DAY) / millisPerUnit; [EOL]             break; [EOL]     } [EOL]     switch(fragment) { [EOL]         case Calendar.YEAR: [EOL]         case Calendar.MONTH: [EOL]         case Calendar.DAY_OF_YEAR: [EOL]         case Calendar.DATE: [EOL]             result += (calendar.get(Calendar.HOUR_OF_DAY) * MILLIS_PER_HOUR) / millisPerUnit; [EOL]         case Calendar.HOUR_OF_DAY: [EOL]             result += (calendar.get(Calendar.MINUTE) * MILLIS_PER_MINUTE) / millisPerUnit; [EOL]         case Calendar.MINUTE: [EOL]             result += (calendar.get(Calendar.SECOND) * MILLIS_PER_SECOND) / millisPerUnit; [EOL]         case Calendar.SECOND: [EOL]             result += (calendar.get(Calendar.MILLISECOND) * 1) / millisPerUnit; [EOL]             break; [EOL]         case Calendar.MILLISECOND: [EOL]             break; [EOL]         default: [EOL]             throw new IllegalArgumentException("The fragment " + fragment + " is not supported"); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] case Calendar.MINUTE: [LINE] private static long getFragment(final Calendar calendar, final int fragment, final int unit) { [EOL]     if (calendar == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     final long millisPerUnit = getMillisPerUnit(unit); [EOL]     long result = 0; [EOL]     switch(fragment) { [EOL]         case Calendar.YEAR: [EOL]             result += (calendar.get(Calendar.DAY_OF_YEAR) * MILLIS_PER_DAY) / millisPerUnit; [EOL]             break; [EOL]         case Calendar.MONTH: [EOL]             result += (calendar.get(Calendar.DAY_OF_MONTH) * MILLIS_PER_DAY) / millisPerUnit; [EOL]             break; [EOL]     } [EOL]     switch(fragment) { [EOL]         case Calendar.YEAR: [EOL]         case Calendar.MONTH: [EOL]         case Calendar.DAY_OF_YEAR: [EOL]         case Calendar.DATE: [EOL]             result += (calendar.get(Calendar.HOUR_OF_DAY) * MILLIS_PER_HOUR) / millisPerUnit; [EOL]         case Calendar.HOUR_OF_DAY: [EOL]             result += (calendar.get(Calendar.MINUTE) * MILLIS_PER_MINUTE) / millisPerUnit; [EOL]         case Calendar.MINUTE: [EOL]             result += (calendar.get(Calendar.SECOND) * MILLIS_PER_SECOND) / millisPerUnit; [EOL]         case Calendar.SECOND: [EOL]             result += (calendar.get(Calendar.MILLISECOND) * 1) / millisPerUnit; [EOL]             break; [EOL]         case Calendar.MILLISECOND: [EOL]             break; [EOL]         default: [EOL]             throw new IllegalArgumentException("The fragment " + fragment + " is not supported"); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] case Calendar.MILLISECOND: break;//never useful [LINE] private static long getFragment(final Calendar calendar, final int fragment, final int unit) { [EOL]     if (calendar == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     final long millisPerUnit = getMillisPerUnit(unit); [EOL]     long result = 0; [EOL]     switch(fragment) { [EOL]         case Calendar.YEAR: [EOL]             result += (calendar.get(Calendar.DAY_OF_YEAR) * MILLIS_PER_DAY) / millisPerUnit; [EOL]             break; [EOL]         case Calendar.MONTH: [EOL]             result += (calendar.get(Calendar.DAY_OF_MONTH) * MILLIS_PER_DAY) / millisPerUnit; [EOL]             break; [EOL]     } [EOL]     switch(fragment) { [EOL]         case Calendar.YEAR: [EOL]         case Calendar.MONTH: [EOL]         case Calendar.DAY_OF_YEAR: [EOL]         case Calendar.DATE: [EOL]             result += (calendar.get(Calendar.HOUR_OF_DAY) * MILLIS_PER_HOUR) / millisPerUnit; [EOL]         case Calendar.HOUR_OF_DAY: [EOL]             result += (calendar.get(Calendar.MINUTE) * MILLIS_PER_MINUTE) / millisPerUnit; [EOL]         case Calendar.MINUTE: [EOL]             result += (calendar.get(Calendar.SECOND) * MILLIS_PER_SECOND) / millisPerUnit; [EOL]         case Calendar.SECOND: [EOL]             result += (calendar.get(Calendar.MILLISECOND) * 1) / millisPerUnit; [EOL]             break; [EOL]         case Calendar.MILLISECOND: [EOL]             break; [EOL]         default: [EOL]             throw new IllegalArgumentException("The fragment " + fragment + " is not supported"); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] return true; [LINE] @Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof CharRange == false) { [EOL]         return false; [EOL]     } [EOL]     final CharRange other = (CharRange) obj; [EOL]     return start == other.start && end == other.end && negated == other.negated; [EOL] } 
 [LINE] if (range.end == Character.MAX_VALUE) { [LINE] private CharacterIterator(final CharRange r) { [EOL]     range = r; [EOL]     hasNext = true; [EOL]     if (range.negated) { [EOL]         if (range.start == 0) { [EOL]             if (range.end == Character.MAX_VALUE) { [EOL]                 hasNext = false; [EOL]             } else { [EOL]                 current = (char) (range.end + 1); [EOL]             } [EOL]         } else { [EOL]             current = 0; [EOL]         } [EOL]     } else { [EOL]         current = range.start; [EOL]     } [EOL] } 
 [LINE] hasNext = false; [LINE] private CharacterIterator(final CharRange r) { [EOL]     range = r; [EOL]     hasNext = true; [EOL]     if (range.negated) { [EOL]         if (range.start == 0) { [EOL]             if (range.end == Character.MAX_VALUE) { [EOL]                 hasNext = false; [EOL]             } else { [EOL]                 current = (char) (range.end + 1); [EOL]             } [EOL]         } else { [EOL]             current = 0; [EOL]         } [EOL]     } else { [EOL]         current = range.start; [EOL]     } [EOL] } 
 [LINE] current = (char) (range.end + 1); [LINE] private CharacterIterator(final CharRange r) { [EOL]     range = r; [EOL]     hasNext = true; [EOL]     if (range.negated) { [EOL]         if (range.start == 0) { [EOL]             if (range.end == Character.MAX_VALUE) { [EOL]                 hasNext = false; [EOL]             } else { [EOL]                 current = (char) (range.end + 1); [EOL]             } [EOL]         } else { [EOL]             current = 0; [EOL]         } [EOL]     } else { [EOL]         current = range.start; [EOL]     } [EOL] } 
 [LINE] hasNext = false; [LINE] private void prepareNext() { [EOL]     if (range.negated) { [EOL]         if (current == Character.MAX_VALUE) { [EOL]             hasNext = false; [EOL]         } else if (current + 1 == range.start) { [EOL]             if (range.end == Character.MAX_VALUE) { [EOL]                 hasNext = false; [EOL]             } else { [EOL]                 current = (char) (range.end + 1); [EOL]             } [EOL]         } else { [EOL]             current = (char) (current + 1); [EOL]         } [EOL]     } else if (current < range.end) { [EOL]         current = (char) (current + 1); [EOL]     } else { [EOL]         hasNext = false; [EOL]     } [EOL] } 
 [LINE] hasNext = false; [LINE] private void prepareNext() { [EOL]     if (range.negated) { [EOL]         if (current == Character.MAX_VALUE) { [EOL]             hasNext = false; [EOL]         } else if (current + 1 == range.start) { [EOL]             if (range.end == Character.MAX_VALUE) { [EOL]                 hasNext = false; [EOL]             } else { [EOL]                 current = (char) (range.end + 1); [EOL]             } [EOL]         } else { [EOL]             current = (char) (current + 1); [EOL]         } [EOL]     } else if (current < range.end) { [EOL]         current = (char) (current + 1); [EOL]     } else { [EOL]         hasNext = false; [EOL]     } [EOL] } 
 [LINE] throw new NoSuchElementException(); [LINE] @Override [EOL] public Character next() { [EOL]     if (hasNext == false) { [EOL]         throw new NoSuchElementException(); [EOL]     } [EOL]     final char cur = current; [EOL]     prepareNext(); [EOL]     return Character.valueOf(cur); [EOL] } 
 [LINE] try { [LINE] static void setAccessibleWorkaround(final AccessibleObject o) { [EOL]     if (o == null || o.isAccessible()) { [EOL]         return; [EOL]     } [EOL]     final Member m = (Member) o; [EOL]     if (Modifier.isPublic(m.getModifiers()) && isPackageAccess(m.getDeclaringClass().getModifiers())) { [EOL]         try { [EOL]             o.setAccessible(true); [EOL]         } catch (final SecurityException e) { [EOL]         } [EOL]     } [EOL] } 
 [LINE] o.setAccessible(true); [LINE] static void setAccessibleWorkaround(final AccessibleObject o) { [EOL]     if (o == null || o.isAccessible()) { [EOL]         return; [EOL]     } [EOL]     final Member m = (Member) o; [EOL]     if (Modifier.isPublic(m.getModifiers()) && isPackageAccess(m.getDeclaringClass().getModifiers())) { [EOL]         try { [EOL]             o.setAccessible(true); [EOL]         } catch (final SecurityException e) { [EOL]         } [EOL]     } [EOL] } 
 [LINE] return getPrimitivePromotionCost(srcClass, destClass); [LINE] private static float getObjectTransformationCost(Class<?> srcClass, final Class<?> destClass) { [EOL]     if (destClass.isPrimitive()) { [EOL]         return getPrimitivePromotionCost(srcClass, destClass); [EOL]     } [EOL]     float cost = 0.0f; [EOL]     while (srcClass != null && !destClass.equals(srcClass)) { [EOL]         if (destClass.isInterface() && ClassUtils.isAssignable(srcClass, destClass)) { [EOL]             cost += 0.25f; [EOL]             break; [EOL]         } [EOL]         cost++; [EOL]         srcClass = srcClass.getSuperclass(); [EOL]     } [EOL]     if (srcClass == null) { [EOL]         cost += 1.5f; [EOL]     } [EOL]     return cost; [EOL] } 
 [LINE] cost += 0.25f; [LINE] private static float getObjectTransformationCost(Class<?> srcClass, final Class<?> destClass) { [EOL]     if (destClass.isPrimitive()) { [EOL]         return getPrimitivePromotionCost(srcClass, destClass); [EOL]     } [EOL]     float cost = 0.0f; [EOL]     while (srcClass != null && !destClass.equals(srcClass)) { [EOL]         if (destClass.isInterface() && ClassUtils.isAssignable(srcClass, destClass)) { [EOL]             cost += 0.25f; [EOL]             break; [EOL]         } [EOL]         cost++; [EOL]         srcClass = srcClass.getSuperclass(); [EOL]     } [EOL]     if (srcClass == null) { [EOL]         cost += 1.5f; [EOL]     } [EOL]     return cost; [EOL] } 
 [LINE] break; [LINE] private static float getObjectTransformationCost(Class<?> srcClass, final Class<?> destClass) { [EOL]     if (destClass.isPrimitive()) { [EOL]         return getPrimitivePromotionCost(srcClass, destClass); [EOL]     } [EOL]     float cost = 0.0f; [EOL]     while (srcClass != null && !destClass.equals(srcClass)) { [EOL]         if (destClass.isInterface() && ClassUtils.isAssignable(srcClass, destClass)) { [EOL]             cost += 0.25f; [EOL]             break; [EOL]         } [EOL]         cost++; [EOL]         srcClass = srcClass.getSuperclass(); [EOL]     } [EOL]     if (srcClass == null) { [EOL]         cost += 1.5f; [EOL]     } [EOL]     return cost; [EOL] } 
 [LINE] private static float getPrimitivePromotionCost(final Class<?> srcClass, final Class<?> destClass) { [LINE] private static float getPrimitivePromotionCost(final Class<?> srcClass, final Class<?> destClass) { [EOL]     float cost = 0.0f; [EOL]     Class<?> cls = srcClass; [EOL]     if (!cls.isPrimitive()) { [EOL]         cost += 0.1f; [EOL]         cls = ClassUtils.wrapperToPrimitive(cls); [EOL]     } [EOL]     for (int i = 0; cls != destClass && i < ORDERED_PRIMITIVE_TYPES.length; i++) { [EOL]         if (cls == ORDERED_PRIMITIVE_TYPES[i]) { [EOL]             cost += 0.1f; [EOL]             if (i < ORDERED_PRIMITIVE_TYPES.length - 1) { [EOL]                 cls = ORDERED_PRIMITIVE_TYPES[i + 1]; [EOL]             } [EOL]         } [EOL]     } [EOL]     return cost; [EOL] } 
 [LINE] float cost = 0.0f; [LINE] private static float getPrimitivePromotionCost(final Class<?> srcClass, final Class<?> destClass) { [EOL]     float cost = 0.0f; [EOL]     Class<?> cls = srcClass; [EOL]     if (!cls.isPrimitive()) { [EOL]         cost += 0.1f; [EOL]         cls = ClassUtils.wrapperToPrimitive(cls); [EOL]     } [EOL]     for (int i = 0; cls != destClass && i < ORDERED_PRIMITIVE_TYPES.length; i++) { [EOL]         if (cls == ORDERED_PRIMITIVE_TYPES[i]) { [EOL]             cost += 0.1f; [EOL]             if (i < ORDERED_PRIMITIVE_TYPES.length - 1) { [EOL]                 cls = ORDERED_PRIMITIVE_TYPES[i + 1]; [EOL]             } [EOL]         } [EOL]     } [EOL]     return cost; [EOL] } 
 [LINE] Class<?> cls = srcClass; [LINE] private static float getPrimitivePromotionCost(final Class<?> srcClass, final Class<?> destClass) { [EOL]     float cost = 0.0f; [EOL]     Class<?> cls = srcClass; [EOL]     if (!cls.isPrimitive()) { [EOL]         cost += 0.1f; [EOL]         cls = ClassUtils.wrapperToPrimitive(cls); [EOL]     } [EOL]     for (int i = 0; cls != destClass && i < ORDERED_PRIMITIVE_TYPES.length; i++) { [EOL]         if (cls == ORDERED_PRIMITIVE_TYPES[i]) { [EOL]             cost += 0.1f; [EOL]             if (i < ORDERED_PRIMITIVE_TYPES.length - 1) { [EOL]                 cls = ORDERED_PRIMITIVE_TYPES[i + 1]; [EOL]             } [EOL]         } [EOL]     } [EOL]     return cost; [EOL] } 
 [LINE] if (!cls.isPrimitive()) { [LINE] private static float getPrimitivePromotionCost(final Class<?> srcClass, final Class<?> destClass) { [EOL]     float cost = 0.0f; [EOL]     Class<?> cls = srcClass; [EOL]     if (!cls.isPrimitive()) { [EOL]         cost += 0.1f; [EOL]         cls = ClassUtils.wrapperToPrimitive(cls); [EOL]     } [EOL]     for (int i = 0; cls != destClass && i < ORDERED_PRIMITIVE_TYPES.length; i++) { [EOL]         if (cls == ORDERED_PRIMITIVE_TYPES[i]) { [EOL]             cost += 0.1f; [EOL]             if (i < ORDERED_PRIMITIVE_TYPES.length - 1) { [EOL]                 cls = ORDERED_PRIMITIVE_TYPES[i + 1]; [EOL]             } [EOL]         } [EOL]     } [EOL]     return cost; [EOL] } 
 [LINE] cost += 0.1f; [LINE] private static float getPrimitivePromotionCost(final Class<?> srcClass, final Class<?> destClass) { [EOL]     float cost = 0.0f; [EOL]     Class<?> cls = srcClass; [EOL]     if (!cls.isPrimitive()) { [EOL]         cost += 0.1f; [EOL]         cls = ClassUtils.wrapperToPrimitive(cls); [EOL]     } [EOL]     for (int i = 0; cls != destClass && i < ORDERED_PRIMITIVE_TYPES.length; i++) { [EOL]         if (cls == ORDERED_PRIMITIVE_TYPES[i]) { [EOL]             cost += 0.1f; [EOL]             if (i < ORDERED_PRIMITIVE_TYPES.length - 1) { [EOL]                 cls = ORDERED_PRIMITIVE_TYPES[i + 1]; [EOL]             } [EOL]         } [EOL]     } [EOL]     return cost; [EOL] } 
 [LINE] cls = ClassUtils.wrapperToPrimitive(cls); [LINE] private static float getPrimitivePromotionCost(final Class<?> srcClass, final Class<?> destClass) { [EOL]     float cost = 0.0f; [EOL]     Class<?> cls = srcClass; [EOL]     if (!cls.isPrimitive()) { [EOL]         cost += 0.1f; [EOL]         cls = ClassUtils.wrapperToPrimitive(cls); [EOL]     } [EOL]     for (int i = 0; cls != destClass && i < ORDERED_PRIMITIVE_TYPES.length; i++) { [EOL]         if (cls == ORDERED_PRIMITIVE_TYPES[i]) { [EOL]             cost += 0.1f; [EOL]             if (i < ORDERED_PRIMITIVE_TYPES.length - 1) { [EOL]                 cls = ORDERED_PRIMITIVE_TYPES[i + 1]; [EOL]             } [EOL]         } [EOL]     } [EOL]     return cost; [EOL] } 
 [LINE] for (int i = 0; cls != destClass && i < ORDERED_PRIMITIVE_TYPES.length; i++) { [LINE] private static float getPrimitivePromotionCost(final Class<?> srcClass, final Class<?> destClass) { [EOL]     float cost = 0.0f; [EOL]     Class<?> cls = srcClass; [EOL]     if (!cls.isPrimitive()) { [EOL]         cost += 0.1f; [EOL]         cls = ClassUtils.wrapperToPrimitive(cls); [EOL]     } [EOL]     for (int i = 0; cls != destClass && i < ORDERED_PRIMITIVE_TYPES.length; i++) { [EOL]         if (cls == ORDERED_PRIMITIVE_TYPES[i]) { [EOL]             cost += 0.1f; [EOL]             if (i < ORDERED_PRIMITIVE_TYPES.length - 1) { [EOL]                 cls = ORDERED_PRIMITIVE_TYPES[i + 1]; [EOL]             } [EOL]         } [EOL]     } [EOL]     return cost; [EOL] } 
 [LINE] if (cls == ORDERED_PRIMITIVE_TYPES[i]) { [LINE] private static float getPrimitivePromotionCost(final Class<?> srcClass, final Class<?> destClass) { [EOL]     float cost = 0.0f; [EOL]     Class<?> cls = srcClass; [EOL]     if (!cls.isPrimitive()) { [EOL]         cost += 0.1f; [EOL]         cls = ClassUtils.wrapperToPrimitive(cls); [EOL]     } [EOL]     for (int i = 0; cls != destClass && i < ORDERED_PRIMITIVE_TYPES.length; i++) { [EOL]         if (cls == ORDERED_PRIMITIVE_TYPES[i]) { [EOL]             cost += 0.1f; [EOL]             if (i < ORDERED_PRIMITIVE_TYPES.length - 1) { [EOL]                 cls = ORDERED_PRIMITIVE_TYPES[i + 1]; [EOL]             } [EOL]         } [EOL]     } [EOL]     return cost; [EOL] } 
 [LINE] cost += 0.1f; [LINE] private static float getPrimitivePromotionCost(final Class<?> srcClass, final Class<?> destClass) { [EOL]     float cost = 0.0f; [EOL]     Class<?> cls = srcClass; [EOL]     if (!cls.isPrimitive()) { [EOL]         cost += 0.1f; [EOL]         cls = ClassUtils.wrapperToPrimitive(cls); [EOL]     } [EOL]     for (int i = 0; cls != destClass && i < ORDERED_PRIMITIVE_TYPES.length; i++) { [EOL]         if (cls == ORDERED_PRIMITIVE_TYPES[i]) { [EOL]             cost += 0.1f; [EOL]             if (i < ORDERED_PRIMITIVE_TYPES.length - 1) { [EOL]                 cls = ORDERED_PRIMITIVE_TYPES[i + 1]; [EOL]             } [EOL]         } [EOL]     } [EOL]     return cost; [EOL] } 
 [LINE] if (i < ORDERED_PRIMITIVE_TYPES.length - 1) { [LINE] private static float getPrimitivePromotionCost(final Class<?> srcClass, final Class<?> destClass) { [EOL]     float cost = 0.0f; [EOL]     Class<?> cls = srcClass; [EOL]     if (!cls.isPrimitive()) { [EOL]         cost += 0.1f; [EOL]         cls = ClassUtils.wrapperToPrimitive(cls); [EOL]     } [EOL]     for (int i = 0; cls != destClass && i < ORDERED_PRIMITIVE_TYPES.length; i++) { [EOL]         if (cls == ORDERED_PRIMITIVE_TYPES[i]) { [EOL]             cost += 0.1f; [EOL]             if (i < ORDERED_PRIMITIVE_TYPES.length - 1) { [EOL]                 cls = ORDERED_PRIMITIVE_TYPES[i + 1]; [EOL]             } [EOL]         } [EOL]     } [EOL]     return cost; [EOL] } 
 [LINE] cls = ORDERED_PRIMITIVE_TYPES[i + 1]; [LINE] private static float getPrimitivePromotionCost(final Class<?> srcClass, final Class<?> destClass) { [EOL]     float cost = 0.0f; [EOL]     Class<?> cls = srcClass; [EOL]     if (!cls.isPrimitive()) { [EOL]         cost += 0.1f; [EOL]         cls = ClassUtils.wrapperToPrimitive(cls); [EOL]     } [EOL]     for (int i = 0; cls != destClass && i < ORDERED_PRIMITIVE_TYPES.length; i++) { [EOL]         if (cls == ORDERED_PRIMITIVE_TYPES[i]) { [EOL]             cost += 0.1f; [EOL]             if (i < ORDERED_PRIMITIVE_TYPES.length - 1) { [EOL]                 cls = ORDERED_PRIMITIVE_TYPES[i + 1]; [EOL]             } [EOL]         } [EOL]     } [EOL]     return cost; [EOL] } 
 [LINE] return cost; [LINE] private static float getPrimitivePromotionCost(final Class<?> srcClass, final Class<?> destClass) { [EOL]     float cost = 0.0f; [EOL]     Class<?> cls = srcClass; [EOL]     if (!cls.isPrimitive()) { [EOL]         cost += 0.1f; [EOL]         cls = ClassUtils.wrapperToPrimitive(cls); [EOL]     } [EOL]     for (int i = 0; cls != destClass && i < ORDERED_PRIMITIVE_TYPES.length; i++) { [EOL]         if (cls == ORDERED_PRIMITIVE_TYPES[i]) { [EOL]             cost += 0.1f; [EOL]             if (i < ORDERED_PRIMITIVE_TYPES.length - 1) { [EOL]                 cls = ORDERED_PRIMITIVE_TYPES[i + 1]; [EOL]             } [EOL]         } [EOL]     } [EOL]     return cost; [EOL] } 
 [LINE] return 1; [LINE] @Override [EOL] public final int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     final int codepoint = Character.codePointAt(input, index); [EOL]     final boolean consumed = translate(codepoint, out); [EOL]     if (consumed) { [EOL]         return 1; [EOL]     } else { [EOL]         return 0; [EOL]     } [EOL] } 
 [LINE] throw new SerializationException(ex); [LINE] public static <T> T deserialize(final InputStream inputStream) { [EOL]     if (inputStream == null) { [EOL]         throw new IllegalArgumentException("The InputStream must not be null"); [EOL]     } [EOL]     ObjectInputStream in = null; [EOL]     try { [EOL]         in = new ObjectInputStream(inputStream); [EOL]         @SuppressWarnings("unchecked") [EOL]         final T obj = (T) in.readObject(); [EOL]         return obj; [EOL]     } catch (final ClassCastException ex) { [EOL]         throw new SerializationException(ex); [EOL]     } catch (final ClassNotFoundException ex) { [EOL]         throw new SerializationException(ex); [EOL]     } catch (final IOException ex) { [EOL]         throw new SerializationException(ex); [EOL]     } finally { [EOL]         try { [EOL]             if (in != null) { [EOL]                 in.close(); [EOL]             } [EOL]         } catch (final IOException ex) { [EOL]         } [EOL]     } [EOL] } 
 [LINE] try { [LINE] @Override [EOL] protected Class<?> resolveClass(final ObjectStreamClass desc) throws IOException, ClassNotFoundException { [EOL]     final String name = desc.getName(); [EOL]     try { [EOL]         return Class.forName(name, false, classLoader); [EOL]     } catch (final ClassNotFoundException ex) { [EOL]         try { [EOL]             return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); [EOL]         } catch (final ClassNotFoundException cnfe) { [EOL]             final Class<?> cls = primitiveTypes.get(name); [EOL]             if (cls != null) { [EOL]                 return cls; [EOL]             } else { [EOL]                 throw cnfe; [EOL]             } [EOL]         } [EOL]     } [EOL] } 
 [LINE] return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); [LINE] @Override [EOL] protected Class<?> resolveClass(final ObjectStreamClass desc) throws IOException, ClassNotFoundException { [EOL]     final String name = desc.getName(); [EOL]     try { [EOL]         return Class.forName(name, false, classLoader); [EOL]     } catch (final ClassNotFoundException ex) { [EOL]         try { [EOL]             return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); [EOL]         } catch (final ClassNotFoundException cnfe) { [EOL]             final Class<?> cls = primitiveTypes.get(name); [EOL]             if (cls != null) { [EOL]                 return cls; [EOL]             } else { [EOL]                 throw cnfe; [EOL]             } [EOL]         } [EOL]     } [EOL] } 
 [LINE] final Class<?> cls = primitiveTypes.get(name); [LINE] @Override [EOL] protected Class<?> resolveClass(final ObjectStreamClass desc) throws IOException, ClassNotFoundException { [EOL]     final String name = desc.getName(); [EOL]     try { [EOL]         return Class.forName(name, false, classLoader); [EOL]     } catch (final ClassNotFoundException ex) { [EOL]         try { [EOL]             return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); [EOL]         } catch (final ClassNotFoundException cnfe) { [EOL]             final Class<?> cls = primitiveTypes.get(name); [EOL]             if (cls != null) { [EOL]                 return cls; [EOL]             } else { [EOL]                 throw cnfe; [EOL]             } [EOL]         } [EOL]     } [EOL] } 
 [LINE] if (cls != null) { [LINE] @Override [EOL] protected Class<?> resolveClass(final ObjectStreamClass desc) throws IOException, ClassNotFoundException { [EOL]     final String name = desc.getName(); [EOL]     try { [EOL]         return Class.forName(name, false, classLoader); [EOL]     } catch (final ClassNotFoundException ex) { [EOL]         try { [EOL]             return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); [EOL]         } catch (final ClassNotFoundException cnfe) { [EOL]             final Class<?> cls = primitiveTypes.get(name); [EOL]             if (cls != null) { [EOL]                 return cls; [EOL]             } else { [EOL]                 throw cnfe; [EOL]             } [EOL]         } [EOL]     } [EOL] } 
 [LINE] return cls; [LINE] @Override [EOL] protected Class<?> resolveClass(final ObjectStreamClass desc) throws IOException, ClassNotFoundException { [EOL]     final String name = desc.getName(); [EOL]     try { [EOL]         return Class.forName(name, false, classLoader); [EOL]     } catch (final ClassNotFoundException ex) { [EOL]         try { [EOL]             return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); [EOL]         } catch (final ClassNotFoundException cnfe) { [EOL]             final Class<?> cls = primitiveTypes.get(name); [EOL]             if (cls != null) { [EOL]                 return cls; [EOL]             } else { [EOL]                 throw cnfe; [EOL]             } [EOL]         } [EOL]     } [EOL] } 
 [LINE] return false; [LINE] protected boolean accept(final Field field) { [EOL]     if (field.getName().indexOf(ClassUtils.INNER_CLASS_SEPARATOR_CHAR) != -1) { [EOL]         return false; [EOL]     } [EOL]     if (Modifier.isTransient(field.getModifiers()) && !this.isAppendTransients()) { [EOL]         return false; [EOL]     } [EOL]     if (Modifier.isStatic(field.getModifiers()) && !this.isAppendStatics()) { [EOL]         return false; [EOL]     } [EOL]     if (this.excludeFieldNames != null && Arrays.binarySearch(this.excludeFieldNames, field.getName()) >= 0) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] return false; [LINE] protected boolean accept(final Field field) { [EOL]     if (field.getName().indexOf(ClassUtils.INNER_CLASS_SEPARATOR_CHAR) != -1) { [EOL]         return false; [EOL]     } [EOL]     if (Modifier.isTransient(field.getModifiers()) && !this.isAppendTransients()) { [EOL]         return false; [EOL]     } [EOL]     if (Modifier.isStatic(field.getModifiers()) && !this.isAppendStatics()) { [EOL]         return false; [EOL]     } [EOL]     if (this.excludeFieldNames != null && Arrays.binarySearch(this.excludeFieldNames, field.getName()) >= 0) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] this.reflectionAppendArray(this.getObject()); [LINE] protected void appendFieldsIn(final Class<?> clazz) { [EOL]     if (clazz.isArray()) { [EOL]         this.reflectionAppendArray(this.getObject()); [EOL]         return; [EOL]     } [EOL]     final Field[] fields = clazz.getDeclaredFields(); [EOL]     AccessibleObject.setAccessible(fields, true); [EOL]     for (final Field field : fields) { [EOL]         final String fieldName = field.getName(); [EOL]         if (this.accept(field)) { [EOL]             try { [EOL]                 final Object fieldValue = this.getValue(field); [EOL]                 this.append(fieldName, fieldValue); [EOL]             } catch (final IllegalAccessException ex) { [EOL]                 throw new InternalError("Unexpected IllegalAccessException: " + ex.getMessage()); [EOL]             } [EOL]         } [EOL]     } [EOL] } 
 [LINE] return; [LINE] protected void appendFieldsIn(final Class<?> clazz) { [EOL]     if (clazz.isArray()) { [EOL]         this.reflectionAppendArray(this.getObject()); [EOL]         return; [EOL]     } [EOL]     final Field[] fields = clazz.getDeclaredFields(); [EOL]     AccessibleObject.setAccessible(fields, true); [EOL]     for (final Field field : fields) { [EOL]         final String fieldName = field.getName(); [EOL]         if (this.accept(field)) { [EOL]             try { [EOL]                 final Object fieldValue = this.getValue(field); [EOL]                 this.append(fieldName, fieldValue); [EOL]             } catch (final IllegalAccessException ex) { [EOL]                 throw new InternalError("Unexpected IllegalAccessException: " + ex.getMessage()); [EOL]             } [EOL]         } [EOL]     } [EOL] } 
 [LINE] return this; [LINE] public ReflectionToStringBuilder reflectionAppendArray(final Object array) { [EOL]     this.getStyle().reflectionAppendArrayDetail(this.getStringBuffer(), null, array); [EOL]     return this; [EOL] } 
 [LINE] @Override [LINE] @Override [EOL] public T get() throws ConcurrentException { [EOL]     T result = reference.get(); [EOL]     if (result == null) { [EOL]         result = initialize(); [EOL]         if (!reference.compareAndSet(null, result)) { [EOL]             result = reference.get(); [EOL]         } [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] T result = reference.get(); [LINE] @Override [EOL] public T get() throws ConcurrentException { [EOL]     T result = reference.get(); [EOL]     if (result == null) { [EOL]         result = initialize(); [EOL]         if (!reference.compareAndSet(null, result)) { [EOL]             result = reference.get(); [EOL]         } [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] if (result == null) { [LINE] @Override [EOL] public T get() throws ConcurrentException { [EOL]     T result = reference.get(); [EOL]     if (result == null) { [EOL]         result = initialize(); [EOL]         if (!reference.compareAndSet(null, result)) { [EOL]             result = reference.get(); [EOL]         } [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] result = initialize(); [LINE] @Override [EOL] public T get() throws ConcurrentException { [EOL]     T result = reference.get(); [EOL]     if (result == null) { [EOL]         result = initialize(); [EOL]         if (!reference.compareAndSet(null, result)) { [EOL]             result = reference.get(); [EOL]         } [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] if (!reference.compareAndSet(null, result)) { [LINE] @Override [EOL] public T get() throws ConcurrentException { [EOL]     T result = reference.get(); [EOL]     if (result == null) { [EOL]         result = initialize(); [EOL]         if (!reference.compareAndSet(null, result)) { [EOL]             result = reference.get(); [EOL]         } [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] return result; [LINE] @Override [EOL] public T get() throws ConcurrentException { [EOL]     T result = reference.get(); [EOL]     if (result == null) { [EOL]         result = initialize(); [EOL]         if (!reference.compareAndSet(null, result)) { [EOL]             result = reference.get(); [EOL]         } [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] return true; [LINE] @Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof Triple<?, ?, ?>) { [EOL]         final Triple<?, ?, ?> other = (Triple<?, ?, ?>) obj; [EOL]         return ObjectUtils.equals(getLeft(), other.getLeft()) && ObjectUtils.equals(getMiddle(), other.getMiddle()) && ObjectUtils.equals(getRight(), other.getRight()); [EOL]     } [EOL]     return false; [EOL] } 
 [LINE] return "\\u0" + Integer.toHexString(ch); [LINE] public static String unicodeEscaped(final char ch) { [EOL]     if (ch < 0x10) { [EOL]         return "\\u000" + Integer.toHexString(ch); [EOL]     } else if (ch < 0x100) { [EOL]         return "\\u00" + Integer.toHexString(ch); [EOL]     } else if (ch < 0x1000) { [EOL]         return "\\u0" + Integer.toHexString(ch); [EOL]     } [EOL]     return "\\u" + Integer.toHexString(ch); [EOL] } 
 [LINE] tok = null; [LINE] private void addToken(final List<String> list, String tok) { [EOL]     if (StringUtils.isEmpty(tok)) { [EOL]         if (isIgnoreEmptyTokens()) { [EOL]             return; [EOL]         } [EOL]         if (isEmptyTokenAsNull()) { [EOL]             tok = null; [EOL]         } [EOL]     } [EOL]     list.add(tok); [EOL] } 
 [LINE] return null; [LINE] @Override [EOL] public Object clone() { [EOL]     try { [EOL]         return cloneReset(); [EOL]     } catch (final CloneNotSupportedException ex) { [EOL]         return null; [EOL]     } [EOL] } 
 [LINE] wait(); [LINE] public synchronized void acquire() throws InterruptedException { [EOL]     if (isShutdown()) { [EOL]         throw new IllegalStateException("TimedSemaphore is shut down!"); [EOL]     } [EOL]     if (task == null) { [EOL]         task = startTimer(); [EOL]     } [EOL]     boolean canPass = false; [EOL]     do { [EOL]         canPass = getLimit() <= NO_LIMIT || acquireCount < getLimit(); [EOL]         if (!canPass) { [EOL]             wait(); [EOL]         } else { [EOL]             acquireCount++; [EOL]         } [EOL]     } while (!canPass); [EOL] } 
 [LINE] @Override [LINE] protected ScheduledFuture<?> startTimer() { [EOL]     return getExecutorService().scheduleAtFixedRate(new Runnable() { [EOL]  [EOL]         @Override [EOL]         public void run() { [EOL]             endOfPeriod(); [EOL]         } [EOL]     }, getPeriod(), getPeriod(), getUnit()); [EOL] } 
 [LINE] endOfPeriod(); [LINE] protected ScheduledFuture<?> startTimer() { [EOL]     return getExecutorService().scheduleAtFixedRate(new Runnable() { [EOL]  [EOL]         @Override [EOL]         public void run() { [EOL]             endOfPeriod(); [EOL]         } [EOL]     }, getPeriod(), getPeriod(), getUnit()); [EOL] } 
 [LINE] throw new ConcurrentRuntimeException(cex.getCause()); [LINE] public static <T> T initializeUnchecked(final ConcurrentInitializer<T> initializer) { [EOL]     try { [EOL]         return initialize(initializer); [EOL]     } catch (final ConcurrentException cex) { [EOL]         throw new ConcurrentRuntimeException(cex.getCause()); [EOL]     } [EOL] } 
 [LINE] throw new ConcurrentRuntimeException(cex.getCause()); [LINE] public static <K, V> V createIfAbsentUnchecked(final ConcurrentMap<K, V> map, final K key, final ConcurrentInitializer<V> init) { [EOL]     try { [EOL]         return createIfAbsent(map, key, init); [EOL]     } catch (final ConcurrentException cex) { [EOL]         throw new ConcurrentRuntimeException(cex.getCause()); [EOL]     } [EOL] } 
 [LINE] return true; [LINE] public static boolean equals(final Annotation a1, final Annotation a2) { [EOL]     if (a1 == a2) { [EOL]         return true; [EOL]     } [EOL]     if (a1 == null || a2 == null) { [EOL]         return false; [EOL]     } [EOL]     final Class<? extends Annotation> type = a1.annotationType(); [EOL]     final Class<? extends Annotation> type2 = a2.annotationType(); [EOL]     Validate.notNull(type, "Annotation %s with null annotationType()", a1); [EOL]     Validate.notNull(type2, "Annotation %s with null annotationType()", a2); [EOL]     if (!type.equals(type2)) { [EOL]         return false; [EOL]     } [EOL]     try { [EOL]         for (final Method m : type.getDeclaredMethods()) { [EOL]             if (m.getParameterTypes().length == 0 && isValidAnnotationMemberType(m.getReturnType())) { [EOL]                 final Object v1 = m.invoke(a1); [EOL]                 final Object v2 = m.invoke(a2); [EOL]                 if (!memberEquals(m.getReturnType(), v1, v2)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } catch (final IllegalAccessException ex) { [EOL]         return false; [EOL]     } catch (final InvocationTargetException ex) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] if (value == null) { [LINE] public static int hashCode(final Annotation a) { [EOL]     int result = 0; [EOL]     final Class<? extends Annotation> type = a.annotationType(); [EOL]     for (final Method m : type.getDeclaredMethods()) { [EOL]         try { [EOL]             final Object value = m.invoke(a); [EOL]             if (value == null) { [EOL]                 throw new IllegalStateException(String.format("Annotation method %s returned null", m)); [EOL]             } [EOL]             result += hashMember(m.getName(), value); [EOL]         } catch (final RuntimeException ex) { [EOL]             throw ex; [EOL]         } catch (final Exception ex) { [EOL]             throw new RuntimeException(ex); [EOL]         } [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] result += hashMember(m.getName(), value); [LINE] public static int hashCode(final Annotation a) { [EOL]     int result = 0; [EOL]     final Class<? extends Annotation> type = a.annotationType(); [EOL]     for (final Method m : type.getDeclaredMethods()) { [EOL]         try { [EOL]             final Object value = m.invoke(a); [EOL]             if (value == null) { [EOL]                 throw new IllegalStateException(String.format("Annotation method %s returned null", m)); [EOL]             } [EOL]             result += hashMember(m.getName(), value); [EOL]         } catch (final RuntimeException ex) { [EOL]             throw ex; [EOL]         } catch (final Exception ex) { [EOL]             throw new RuntimeException(ex); [EOL]         } [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] return result; [LINE] public static int hashCode(final Annotation a) { [EOL]     int result = 0; [EOL]     final Class<? extends Annotation> type = a.annotationType(); [EOL]     for (final Method m : type.getDeclaredMethods()) { [EOL]         try { [EOL]             final Object value = m.invoke(a); [EOL]             if (value == null) { [EOL]                 throw new IllegalStateException(String.format("Annotation method %s returned null", m)); [EOL]             } [EOL]             result += hashMember(m.getName(), value); [EOL]         } catch (final RuntimeException ex) { [EOL]             throw ex; [EOL]         } catch (final Exception ex) { [EOL]             throw new RuntimeException(ex); [EOL]         } [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] type = type.getComponentType(); [LINE] public static boolean isValidAnnotationMemberType(Class<?> type) { [EOL]     if (type == null) { [EOL]         return false; [EOL]     } [EOL]     if (type.isArray()) { [EOL]         type = type.getComponentType(); [EOL]     } [EOL]     return type.isPrimitive() || type.isEnum() || type.isAnnotation() || String.class.equals(type) || Class.class.equals(type); [EOL] } 
 [LINE] private static int hashMember(final String name, final Object value) { [LINE] private static int hashMember(final String name, final Object value) { [EOL]     final int part1 = name.hashCode() * 127; [EOL]     if (value.getClass().isArray()) { [EOL]         return part1 ^ arrayMemberHash(value.getClass().getComponentType(), value); [EOL]     } [EOL]     if (value instanceof Annotation) { [EOL]         return part1 ^ hashCode((Annotation) value); [EOL]     } [EOL]     return part1 ^ value.hashCode(); [EOL] } 
 [LINE] final int part1 = name.hashCode() * 127; [LINE] private static int hashMember(final String name, final Object value) { [EOL]     final int part1 = name.hashCode() * 127; [EOL]     if (value.getClass().isArray()) { [EOL]         return part1 ^ arrayMemberHash(value.getClass().getComponentType(), value); [EOL]     } [EOL]     if (value instanceof Annotation) { [EOL]         return part1 ^ hashCode((Annotation) value); [EOL]     } [EOL]     return part1 ^ value.hashCode(); [EOL] } 
 [LINE] if (value.getClass().isArray()) { [LINE] private static int hashMember(final String name, final Object value) { [EOL]     final int part1 = name.hashCode() * 127; [EOL]     if (value.getClass().isArray()) { [EOL]         return part1 ^ arrayMemberHash(value.getClass().getComponentType(), value); [EOL]     } [EOL]     if (value instanceof Annotation) { [EOL]         return part1 ^ hashCode((Annotation) value); [EOL]     } [EOL]     return part1 ^ value.hashCode(); [EOL] } 
 [LINE] return part1 ^ arrayMemberHash(value.getClass().getComponentType(), value); [LINE] private static int hashMember(final String name, final Object value) { [EOL]     final int part1 = name.hashCode() * 127; [EOL]     if (value.getClass().isArray()) { [EOL]         return part1 ^ arrayMemberHash(value.getClass().getComponentType(), value); [EOL]     } [EOL]     if (value instanceof Annotation) { [EOL]         return part1 ^ hashCode((Annotation) value); [EOL]     } [EOL]     return part1 ^ value.hashCode(); [EOL] } 
 [LINE] if (value instanceof Annotation) { [LINE] private static int hashMember(final String name, final Object value) { [EOL]     final int part1 = name.hashCode() * 127; [EOL]     if (value.getClass().isArray()) { [EOL]         return part1 ^ arrayMemberHash(value.getClass().getComponentType(), value); [EOL]     } [EOL]     if (value instanceof Annotation) { [EOL]         return part1 ^ hashCode((Annotation) value); [EOL]     } [EOL]     return part1 ^ value.hashCode(); [EOL] } 
 [LINE] return part1 ^ hashCode((Annotation) value); [LINE] private static int hashMember(final String name, final Object value) { [EOL]     final int part1 = name.hashCode() * 127; [EOL]     if (value.getClass().isArray()) { [EOL]         return part1 ^ arrayMemberHash(value.getClass().getComponentType(), value); [EOL]     } [EOL]     if (value instanceof Annotation) { [EOL]         return part1 ^ hashCode((Annotation) value); [EOL]     } [EOL]     return part1 ^ value.hashCode(); [EOL] } 
 [LINE] return part1 ^ value.hashCode(); [LINE] private static int hashMember(final String name, final Object value) { [EOL]     final int part1 = name.hashCode() * 127; [EOL]     if (value.getClass().isArray()) { [EOL]         return part1 ^ arrayMemberHash(value.getClass().getComponentType(), value); [EOL]     } [EOL]     if (value instanceof Annotation) { [EOL]         return part1 ^ hashCode((Annotation) value); [EOL]     } [EOL]     return part1 ^ value.hashCode(); [EOL] } 
 [LINE] return true; [LINE] private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2) { [EOL]     if (o1 == o2) { [EOL]         return true; [EOL]     } [EOL]     if (o1 == null || o2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (type.isArray()) { [EOL]         return arrayMemberEquals(type.getComponentType(), o1, o2); [EOL]     } [EOL]     if (type.isAnnotation()) { [EOL]         return equals((Annotation) o1, (Annotation) o2); [EOL]     } [EOL]     return o1.equals(o2); [EOL] } 
 [LINE] return arrayMemberEquals(type.getComponentType(), o1, o2); [LINE] private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2) { [EOL]     if (o1 == o2) { [EOL]         return true; [EOL]     } [EOL]     if (o1 == null || o2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (type.isArray()) { [EOL]         return arrayMemberEquals(type.getComponentType(), o1, o2); [EOL]     } [EOL]     if (type.isAnnotation()) { [EOL]         return equals((Annotation) o1, (Annotation) o2); [EOL]     } [EOL]     return o1.equals(o2); [EOL] } 
 [LINE] return equals((Annotation) o1, (Annotation) o2); [LINE] private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2) { [EOL]     if (o1 == o2) { [EOL]         return true; [EOL]     } [EOL]     if (o1 == null || o2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (type.isArray()) { [EOL]         return arrayMemberEquals(type.getComponentType(), o1, o2); [EOL]     } [EOL]     if (type.isAnnotation()) { [EOL]         return equals((Annotation) o1, (Annotation) o2); [EOL]     } [EOL]     return o1.equals(o2); [EOL] } 
 [LINE] private static boolean arrayMemberEquals(final Class<?> componentType, final Object o1, final Object o2) { [LINE] private static boolean arrayMemberEquals(final Class<?> componentType, final Object o1, final Object o2) { [EOL]     if (componentType.isAnnotation()) { [EOL]         return annotationArrayMemberEquals((Annotation[]) o1, (Annotation[]) o2); [EOL]     } [EOL]     if (componentType.equals(Byte.TYPE)) { [EOL]         return Arrays.equals((byte[]) o1, (byte[]) o2); [EOL]     } [EOL]     if (componentType.equals(Short.TYPE)) { [EOL]         return Arrays.equals((short[]) o1, (short[]) o2); [EOL]     } [EOL]     if (componentType.equals(Integer.TYPE)) { [EOL]         return Arrays.equals((int[]) o1, (int[]) o2); [EOL]     } [EOL]     if (componentType.equals(Character.TYPE)) { [EOL]         return Arrays.equals((char[]) o1, (char[]) o2); [EOL]     } [EOL]     if (componentType.equals(Long.TYPE)) { [EOL]         return Arrays.equals((long[]) o1, (long[]) o2); [EOL]     } [EOL]     if (componentType.equals(Float.TYPE)) { [EOL]         return Arrays.equals((float[]) o1, (float[]) o2); [EOL]     } [EOL]     if (componentType.equals(Double.TYPE)) { [EOL]         return Arrays.equals((double[]) o1, (double[]) o2); [EOL]     } [EOL]     if (componentType.equals(Boolean.TYPE)) { [EOL]         return Arrays.equals((boolean[]) o1, (boolean[]) o2); [EOL]     } [EOL]     return Arrays.equals((Object[]) o1, (Object[]) o2); [EOL] } 
 [LINE] if (componentType.isAnnotation()) { [LINE] private static boolean arrayMemberEquals(final Class<?> componentType, final Object o1, final Object o2) { [EOL]     if (componentType.isAnnotation()) { [EOL]         return annotationArrayMemberEquals((Annotation[]) o1, (Annotation[]) o2); [EOL]     } [EOL]     if (componentType.equals(Byte.TYPE)) { [EOL]         return Arrays.equals((byte[]) o1, (byte[]) o2); [EOL]     } [EOL]     if (componentType.equals(Short.TYPE)) { [EOL]         return Arrays.equals((short[]) o1, (short[]) o2); [EOL]     } [EOL]     if (componentType.equals(Integer.TYPE)) { [EOL]         return Arrays.equals((int[]) o1, (int[]) o2); [EOL]     } [EOL]     if (componentType.equals(Character.TYPE)) { [EOL]         return Arrays.equals((char[]) o1, (char[]) o2); [EOL]     } [EOL]     if (componentType.equals(Long.TYPE)) { [EOL]         return Arrays.equals((long[]) o1, (long[]) o2); [EOL]     } [EOL]     if (componentType.equals(Float.TYPE)) { [EOL]         return Arrays.equals((float[]) o1, (float[]) o2); [EOL]     } [EOL]     if (componentType.equals(Double.TYPE)) { [EOL]         return Arrays.equals((double[]) o1, (double[]) o2); [EOL]     } [EOL]     if (componentType.equals(Boolean.TYPE)) { [EOL]         return Arrays.equals((boolean[]) o1, (boolean[]) o2); [EOL]     } [EOL]     return Arrays.equals((Object[]) o1, (Object[]) o2); [EOL] } 
 [LINE] return annotationArrayMemberEquals((Annotation[]) o1, (Annotation[]) o2); [LINE] private static boolean arrayMemberEquals(final Class<?> componentType, final Object o1, final Object o2) { [EOL]     if (componentType.isAnnotation()) { [EOL]         return annotationArrayMemberEquals((Annotation[]) o1, (Annotation[]) o2); [EOL]     } [EOL]     if (componentType.equals(Byte.TYPE)) { [EOL]         return Arrays.equals((byte[]) o1, (byte[]) o2); [EOL]     } [EOL]     if (componentType.equals(Short.TYPE)) { [EOL]         return Arrays.equals((short[]) o1, (short[]) o2); [EOL]     } [EOL]     if (componentType.equals(Integer.TYPE)) { [EOL]         return Arrays.equals((int[]) o1, (int[]) o2); [EOL]     } [EOL]     if (componentType.equals(Character.TYPE)) { [EOL]         return Arrays.equals((char[]) o1, (char[]) o2); [EOL]     } [EOL]     if (componentType.equals(Long.TYPE)) { [EOL]         return Arrays.equals((long[]) o1, (long[]) o2); [EOL]     } [EOL]     if (componentType.equals(Float.TYPE)) { [EOL]         return Arrays.equals((float[]) o1, (float[]) o2); [EOL]     } [EOL]     if (componentType.equals(Double.TYPE)) { [EOL]         return Arrays.equals((double[]) o1, (double[]) o2); [EOL]     } [EOL]     if (componentType.equals(Boolean.TYPE)) { [EOL]         return Arrays.equals((boolean[]) o1, (boolean[]) o2); [EOL]     } [EOL]     return Arrays.equals((Object[]) o1, (Object[]) o2); [EOL] } 
 [LINE] if (componentType.equals(Byte.TYPE)) { [LINE] private static boolean arrayMemberEquals(final Class<?> componentType, final Object o1, final Object o2) { [EOL]     if (componentType.isAnnotation()) { [EOL]         return annotationArrayMemberEquals((Annotation[]) o1, (Annotation[]) o2); [EOL]     } [EOL]     if (componentType.equals(Byte.TYPE)) { [EOL]         return Arrays.equals((byte[]) o1, (byte[]) o2); [EOL]     } [EOL]     if (componentType.equals(Short.TYPE)) { [EOL]         return Arrays.equals((short[]) o1, (short[]) o2); [EOL]     } [EOL]     if (componentType.equals(Integer.TYPE)) { [EOL]         return Arrays.equals((int[]) o1, (int[]) o2); [EOL]     } [EOL]     if (componentType.equals(Character.TYPE)) { [EOL]         return Arrays.equals((char[]) o1, (char[]) o2); [EOL]     } [EOL]     if (componentType.equals(Long.TYPE)) { [EOL]         return Arrays.equals((long[]) o1, (long[]) o2); [EOL]     } [EOL]     if (componentType.equals(Float.TYPE)) { [EOL]         return Arrays.equals((float[]) o1, (float[]) o2); [EOL]     } [EOL]     if (componentType.equals(Double.TYPE)) { [EOL]         return Arrays.equals((double[]) o1, (double[]) o2); [EOL]     } [EOL]     if (componentType.equals(Boolean.TYPE)) { [EOL]         return Arrays.equals((boolean[]) o1, (boolean[]) o2); [EOL]     } [EOL]     return Arrays.equals((Object[]) o1, (Object[]) o2); [EOL] } 
 [LINE] return Arrays.equals((byte[]) o1, (byte[]) o2); [LINE] private static boolean arrayMemberEquals(final Class<?> componentType, final Object o1, final Object o2) { [EOL]     if (componentType.isAnnotation()) { [EOL]         return annotationArrayMemberEquals((Annotation[]) o1, (Annotation[]) o2); [EOL]     } [EOL]     if (componentType.equals(Byte.TYPE)) { [EOL]         return Arrays.equals((byte[]) o1, (byte[]) o2); [EOL]     } [EOL]     if (componentType.equals(Short.TYPE)) { [EOL]         return Arrays.equals((short[]) o1, (short[]) o2); [EOL]     } [EOL]     if (componentType.equals(Integer.TYPE)) { [EOL]         return Arrays.equals((int[]) o1, (int[]) o2); [EOL]     } [EOL]     if (componentType.equals(Character.TYPE)) { [EOL]         return Arrays.equals((char[]) o1, (char[]) o2); [EOL]     } [EOL]     if (componentType.equals(Long.TYPE)) { [EOL]         return Arrays.equals((long[]) o1, (long[]) o2); [EOL]     } [EOL]     if (componentType.equals(Float.TYPE)) { [EOL]         return Arrays.equals((float[]) o1, (float[]) o2); [EOL]     } [EOL]     if (componentType.equals(Double.TYPE)) { [EOL]         return Arrays.equals((double[]) o1, (double[]) o2); [EOL]     } [EOL]     if (componentType.equals(Boolean.TYPE)) { [EOL]         return Arrays.equals((boolean[]) o1, (boolean[]) o2); [EOL]     } [EOL]     return Arrays.equals((Object[]) o1, (Object[]) o2); [EOL] } 
 [LINE] if (componentType.equals(Short.TYPE)) { [LINE] private static boolean arrayMemberEquals(final Class<?> componentType, final Object o1, final Object o2) { [EOL]     if (componentType.isAnnotation()) { [EOL]         return annotationArrayMemberEquals((Annotation[]) o1, (Annotation[]) o2); [EOL]     } [EOL]     if (componentType.equals(Byte.TYPE)) { [EOL]         return Arrays.equals((byte[]) o1, (byte[]) o2); [EOL]     } [EOL]     if (componentType.equals(Short.TYPE)) { [EOL]         return Arrays.equals((short[]) o1, (short[]) o2); [EOL]     } [EOL]     if (componentType.equals(Integer.TYPE)) { [EOL]         return Arrays.equals((int[]) o1, (int[]) o2); [EOL]     } [EOL]     if (componentType.equals(Character.TYPE)) { [EOL]         return Arrays.equals((char[]) o1, (char[]) o2); [EOL]     } [EOL]     if (componentType.equals(Long.TYPE)) { [EOL]         return Arrays.equals((long[]) o1, (long[]) o2); [EOL]     } [EOL]     if (componentType.equals(Float.TYPE)) { [EOL]         return Arrays.equals((float[]) o1, (float[]) o2); [EOL]     } [EOL]     if (componentType.equals(Double.TYPE)) { [EOL]         return Arrays.equals((double[]) o1, (double[]) o2); [EOL]     } [EOL]     if (componentType.equals(Boolean.TYPE)) { [EOL]         return Arrays.equals((boolean[]) o1, (boolean[]) o2); [EOL]     } [EOL]     return Arrays.equals((Object[]) o1, (Object[]) o2); [EOL] } 
 [LINE] return Arrays.equals((short[]) o1, (short[]) o2); [LINE] private static boolean arrayMemberEquals(final Class<?> componentType, final Object o1, final Object o2) { [EOL]     if (componentType.isAnnotation()) { [EOL]         return annotationArrayMemberEquals((Annotation[]) o1, (Annotation[]) o2); [EOL]     } [EOL]     if (componentType.equals(Byte.TYPE)) { [EOL]         return Arrays.equals((byte[]) o1, (byte[]) o2); [EOL]     } [EOL]     if (componentType.equals(Short.TYPE)) { [EOL]         return Arrays.equals((short[]) o1, (short[]) o2); [EOL]     } [EOL]     if (componentType.equals(Integer.TYPE)) { [EOL]         return Arrays.equals((int[]) o1, (int[]) o2); [EOL]     } [EOL]     if (componentType.equals(Character.TYPE)) { [EOL]         return Arrays.equals((char[]) o1, (char[]) o2); [EOL]     } [EOL]     if (componentType.equals(Long.TYPE)) { [EOL]         return Arrays.equals((long[]) o1, (long[]) o2); [EOL]     } [EOL]     if (componentType.equals(Float.TYPE)) { [EOL]         return Arrays.equals((float[]) o1, (float[]) o2); [EOL]     } [EOL]     if (componentType.equals(Double.TYPE)) { [EOL]         return Arrays.equals((double[]) o1, (double[]) o2); [EOL]     } [EOL]     if (componentType.equals(Boolean.TYPE)) { [EOL]         return Arrays.equals((boolean[]) o1, (boolean[]) o2); [EOL]     } [EOL]     return Arrays.equals((Object[]) o1, (Object[]) o2); [EOL] } 
 [LINE] if (componentType.equals(Integer.TYPE)) { [LINE] private static boolean arrayMemberEquals(final Class<?> componentType, final Object o1, final Object o2) { [EOL]     if (componentType.isAnnotation()) { [EOL]         return annotationArrayMemberEquals((Annotation[]) o1, (Annotation[]) o2); [EOL]     } [EOL]     if (componentType.equals(Byte.TYPE)) { [EOL]         return Arrays.equals((byte[]) o1, (byte[]) o2); [EOL]     } [EOL]     if (componentType.equals(Short.TYPE)) { [EOL]         return Arrays.equals((short[]) o1, (short[]) o2); [EOL]     } [EOL]     if (componentType.equals(Integer.TYPE)) { [EOL]         return Arrays.equals((int[]) o1, (int[]) o2); [EOL]     } [EOL]     if (componentType.equals(Character.TYPE)) { [EOL]         return Arrays.equals((char[]) o1, (char[]) o2); [EOL]     } [EOL]     if (componentType.equals(Long.TYPE)) { [EOL]         return Arrays.equals((long[]) o1, (long[]) o2); [EOL]     } [EOL]     if (componentType.equals(Float.TYPE)) { [EOL]         return Arrays.equals((float[]) o1, (float[]) o2); [EOL]     } [EOL]     if (componentType.equals(Double.TYPE)) { [EOL]         return Arrays.equals((double[]) o1, (double[]) o2); [EOL]     } [EOL]     if (componentType.equals(Boolean.TYPE)) { [EOL]         return Arrays.equals((boolean[]) o1, (boolean[]) o2); [EOL]     } [EOL]     return Arrays.equals((Object[]) o1, (Object[]) o2); [EOL] } 
 [LINE] return Arrays.equals((int[]) o1, (int[]) o2); [LINE] private static boolean arrayMemberEquals(final Class<?> componentType, final Object o1, final Object o2) { [EOL]     if (componentType.isAnnotation()) { [EOL]         return annotationArrayMemberEquals((Annotation[]) o1, (Annotation[]) o2); [EOL]     } [EOL]     if (componentType.equals(Byte.TYPE)) { [EOL]         return Arrays.equals((byte[]) o1, (byte[]) o2); [EOL]     } [EOL]     if (componentType.equals(Short.TYPE)) { [EOL]         return Arrays.equals((short[]) o1, (short[]) o2); [EOL]     } [EOL]     if (componentType.equals(Integer.TYPE)) { [EOL]         return Arrays.equals((int[]) o1, (int[]) o2); [EOL]     } [EOL]     if (componentType.equals(Character.TYPE)) { [EOL]         return Arrays.equals((char[]) o1, (char[]) o2); [EOL]     } [EOL]     if (componentType.equals(Long.TYPE)) { [EOL]         return Arrays.equals((long[]) o1, (long[]) o2); [EOL]     } [EOL]     if (componentType.equals(Float.TYPE)) { [EOL]         return Arrays.equals((float[]) o1, (float[]) o2); [EOL]     } [EOL]     if (componentType.equals(Double.TYPE)) { [EOL]         return Arrays.equals((double[]) o1, (double[]) o2); [EOL]     } [EOL]     if (componentType.equals(Boolean.TYPE)) { [EOL]         return Arrays.equals((boolean[]) o1, (boolean[]) o2); [EOL]     } [EOL]     return Arrays.equals((Object[]) o1, (Object[]) o2); [EOL] } 
 [LINE] if (componentType.equals(Character.TYPE)) { [LINE] private static boolean arrayMemberEquals(final Class<?> componentType, final Object o1, final Object o2) { [EOL]     if (componentType.isAnnotation()) { [EOL]         return annotationArrayMemberEquals((Annotation[]) o1, (Annotation[]) o2); [EOL]     } [EOL]     if (componentType.equals(Byte.TYPE)) { [EOL]         return Arrays.equals((byte[]) o1, (byte[]) o2); [EOL]     } [EOL]     if (componentType.equals(Short.TYPE)) { [EOL]         return Arrays.equals((short[]) o1, (short[]) o2); [EOL]     } [EOL]     if (componentType.equals(Integer.TYPE)) { [EOL]         return Arrays.equals((int[]) o1, (int[]) o2); [EOL]     } [EOL]     if (componentType.equals(Character.TYPE)) { [EOL]         return Arrays.equals((char[]) o1, (char[]) o2); [EOL]     } [EOL]     if (componentType.equals(Long.TYPE)) { [EOL]         return Arrays.equals((long[]) o1, (long[]) o2); [EOL]     } [EOL]     if (componentType.equals(Float.TYPE)) { [EOL]         return Arrays.equals((float[]) o1, (float[]) o2); [EOL]     } [EOL]     if (componentType.equals(Double.TYPE)) { [EOL]         return Arrays.equals((double[]) o1, (double[]) o2); [EOL]     } [EOL]     if (componentType.equals(Boolean.TYPE)) { [EOL]         return Arrays.equals((boolean[]) o1, (boolean[]) o2); [EOL]     } [EOL]     return Arrays.equals((Object[]) o1, (Object[]) o2); [EOL] } 
 [LINE] return Arrays.equals((char[]) o1, (char[]) o2); [LINE] private static boolean arrayMemberEquals(final Class<?> componentType, final Object o1, final Object o2) { [EOL]     if (componentType.isAnnotation()) { [EOL]         return annotationArrayMemberEquals((Annotation[]) o1, (Annotation[]) o2); [EOL]     } [EOL]     if (componentType.equals(Byte.TYPE)) { [EOL]         return Arrays.equals((byte[]) o1, (byte[]) o2); [EOL]     } [EOL]     if (componentType.equals(Short.TYPE)) { [EOL]         return Arrays.equals((short[]) o1, (short[]) o2); [EOL]     } [EOL]     if (componentType.equals(Integer.TYPE)) { [EOL]         return Arrays.equals((int[]) o1, (int[]) o2); [EOL]     } [EOL]     if (componentType.equals(Character.TYPE)) { [EOL]         return Arrays.equals((char[]) o1, (char[]) o2); [EOL]     } [EOL]     if (componentType.equals(Long.TYPE)) { [EOL]         return Arrays.equals((long[]) o1, (long[]) o2); [EOL]     } [EOL]     if (componentType.equals(Float.TYPE)) { [EOL]         return Arrays.equals((float[]) o1, (float[]) o2); [EOL]     } [EOL]     if (componentType.equals(Double.TYPE)) { [EOL]         return Arrays.equals((double[]) o1, (double[]) o2); [EOL]     } [EOL]     if (componentType.equals(Boolean.TYPE)) { [EOL]         return Arrays.equals((boolean[]) o1, (boolean[]) o2); [EOL]     } [EOL]     return Arrays.equals((Object[]) o1, (Object[]) o2); [EOL] } 
 [LINE] if (componentType.equals(Long.TYPE)) { [LINE] private static boolean arrayMemberEquals(final Class<?> componentType, final Object o1, final Object o2) { [EOL]     if (componentType.isAnnotation()) { [EOL]         return annotationArrayMemberEquals((Annotation[]) o1, (Annotation[]) o2); [EOL]     } [EOL]     if (componentType.equals(Byte.TYPE)) { [EOL]         return Arrays.equals((byte[]) o1, (byte[]) o2); [EOL]     } [EOL]     if (componentType.equals(Short.TYPE)) { [EOL]         return Arrays.equals((short[]) o1, (short[]) o2); [EOL]     } [EOL]     if (componentType.equals(Integer.TYPE)) { [EOL]         return Arrays.equals((int[]) o1, (int[]) o2); [EOL]     } [EOL]     if (componentType.equals(Character.TYPE)) { [EOL]         return Arrays.equals((char[]) o1, (char[]) o2); [EOL]     } [EOL]     if (componentType.equals(Long.TYPE)) { [EOL]         return Arrays.equals((long[]) o1, (long[]) o2); [EOL]     } [EOL]     if (componentType.equals(Float.TYPE)) { [EOL]         return Arrays.equals((float[]) o1, (float[]) o2); [EOL]     } [EOL]     if (componentType.equals(Double.TYPE)) { [EOL]         return Arrays.equals((double[]) o1, (double[]) o2); [EOL]     } [EOL]     if (componentType.equals(Boolean.TYPE)) { [EOL]         return Arrays.equals((boolean[]) o1, (boolean[]) o2); [EOL]     } [EOL]     return Arrays.equals((Object[]) o1, (Object[]) o2); [EOL] } 
 [LINE] return Arrays.equals((long[]) o1, (long[]) o2); [LINE] private static boolean arrayMemberEquals(final Class<?> componentType, final Object o1, final Object o2) { [EOL]     if (componentType.isAnnotation()) { [EOL]         return annotationArrayMemberEquals((Annotation[]) o1, (Annotation[]) o2); [EOL]     } [EOL]     if (componentType.equals(Byte.TYPE)) { [EOL]         return Arrays.equals((byte[]) o1, (byte[]) o2); [EOL]     } [EOL]     if (componentType.equals(Short.TYPE)) { [EOL]         return Arrays.equals((short[]) o1, (short[]) o2); [EOL]     } [EOL]     if (componentType.equals(Integer.TYPE)) { [EOL]         return Arrays.equals((int[]) o1, (int[]) o2); [EOL]     } [EOL]     if (componentType.equals(Character.TYPE)) { [EOL]         return Arrays.equals((char[]) o1, (char[]) o2); [EOL]     } [EOL]     if (componentType.equals(Long.TYPE)) { [EOL]         return Arrays.equals((long[]) o1, (long[]) o2); [EOL]     } [EOL]     if (componentType.equals(Float.TYPE)) { [EOL]         return Arrays.equals((float[]) o1, (float[]) o2); [EOL]     } [EOL]     if (componentType.equals(Double.TYPE)) { [EOL]         return Arrays.equals((double[]) o1, (double[]) o2); [EOL]     } [EOL]     if (componentType.equals(Boolean.TYPE)) { [EOL]         return Arrays.equals((boolean[]) o1, (boolean[]) o2); [EOL]     } [EOL]     return Arrays.equals((Object[]) o1, (Object[]) o2); [EOL] } 
 [LINE] if (componentType.equals(Float.TYPE)) { [LINE] private static boolean arrayMemberEquals(final Class<?> componentType, final Object o1, final Object o2) { [EOL]     if (componentType.isAnnotation()) { [EOL]         return annotationArrayMemberEquals((Annotation[]) o1, (Annotation[]) o2); [EOL]     } [EOL]     if (componentType.equals(Byte.TYPE)) { [EOL]         return Arrays.equals((byte[]) o1, (byte[]) o2); [EOL]     } [EOL]     if (componentType.equals(Short.TYPE)) { [EOL]         return Arrays.equals((short[]) o1, (short[]) o2); [EOL]     } [EOL]     if (componentType.equals(Integer.TYPE)) { [EOL]         return Arrays.equals((int[]) o1, (int[]) o2); [EOL]     } [EOL]     if (componentType.equals(Character.TYPE)) { [EOL]         return Arrays.equals((char[]) o1, (char[]) o2); [EOL]     } [EOL]     if (componentType.equals(Long.TYPE)) { [EOL]         return Arrays.equals((long[]) o1, (long[]) o2); [EOL]     } [EOL]     if (componentType.equals(Float.TYPE)) { [EOL]         return Arrays.equals((float[]) o1, (float[]) o2); [EOL]     } [EOL]     if (componentType.equals(Double.TYPE)) { [EOL]         return Arrays.equals((double[]) o1, (double[]) o2); [EOL]     } [EOL]     if (componentType.equals(Boolean.TYPE)) { [EOL]         return Arrays.equals((boolean[]) o1, (boolean[]) o2); [EOL]     } [EOL]     return Arrays.equals((Object[]) o1, (Object[]) o2); [EOL] } 
 [LINE] return Arrays.equals((float[]) o1, (float[]) o2); [LINE] private static boolean arrayMemberEquals(final Class<?> componentType, final Object o1, final Object o2) { [EOL]     if (componentType.isAnnotation()) { [EOL]         return annotationArrayMemberEquals((Annotation[]) o1, (Annotation[]) o2); [EOL]     } [EOL]     if (componentType.equals(Byte.TYPE)) { [EOL]         return Arrays.equals((byte[]) o1, (byte[]) o2); [EOL]     } [EOL]     if (componentType.equals(Short.TYPE)) { [EOL]         return Arrays.equals((short[]) o1, (short[]) o2); [EOL]     } [EOL]     if (componentType.equals(Integer.TYPE)) { [EOL]         return Arrays.equals((int[]) o1, (int[]) o2); [EOL]     } [EOL]     if (componentType.equals(Character.TYPE)) { [EOL]         return Arrays.equals((char[]) o1, (char[]) o2); [EOL]     } [EOL]     if (componentType.equals(Long.TYPE)) { [EOL]         return Arrays.equals((long[]) o1, (long[]) o2); [EOL]     } [EOL]     if (componentType.equals(Float.TYPE)) { [EOL]         return Arrays.equals((float[]) o1, (float[]) o2); [EOL]     } [EOL]     if (componentType.equals(Double.TYPE)) { [EOL]         return Arrays.equals((double[]) o1, (double[]) o2); [EOL]     } [EOL]     if (componentType.equals(Boolean.TYPE)) { [EOL]         return Arrays.equals((boolean[]) o1, (boolean[]) o2); [EOL]     } [EOL]     return Arrays.equals((Object[]) o1, (Object[]) o2); [EOL] } 
 [LINE] if (componentType.equals(Double.TYPE)) { [LINE] private static boolean arrayMemberEquals(final Class<?> componentType, final Object o1, final Object o2) { [EOL]     if (componentType.isAnnotation()) { [EOL]         return annotationArrayMemberEquals((Annotation[]) o1, (Annotation[]) o2); [EOL]     } [EOL]     if (componentType.equals(Byte.TYPE)) { [EOL]         return Arrays.equals((byte[]) o1, (byte[]) o2); [EOL]     } [EOL]     if (componentType.equals(Short.TYPE)) { [EOL]         return Arrays.equals((short[]) o1, (short[]) o2); [EOL]     } [EOL]     if (componentType.equals(Integer.TYPE)) { [EOL]         return Arrays.equals((int[]) o1, (int[]) o2); [EOL]     } [EOL]     if (componentType.equals(Character.TYPE)) { [EOL]         return Arrays.equals((char[]) o1, (char[]) o2); [EOL]     } [EOL]     if (componentType.equals(Long.TYPE)) { [EOL]         return Arrays.equals((long[]) o1, (long[]) o2); [EOL]     } [EOL]     if (componentType.equals(Float.TYPE)) { [EOL]         return Arrays.equals((float[]) o1, (float[]) o2); [EOL]     } [EOL]     if (componentType.equals(Double.TYPE)) { [EOL]         return Arrays.equals((double[]) o1, (double[]) o2); [EOL]     } [EOL]     if (componentType.equals(Boolean.TYPE)) { [EOL]         return Arrays.equals((boolean[]) o1, (boolean[]) o2); [EOL]     } [EOL]     return Arrays.equals((Object[]) o1, (Object[]) o2); [EOL] } 
 [LINE] return Arrays.equals((double[]) o1, (double[]) o2); [LINE] private static boolean arrayMemberEquals(final Class<?> componentType, final Object o1, final Object o2) { [EOL]     if (componentType.isAnnotation()) { [EOL]         return annotationArrayMemberEquals((Annotation[]) o1, (Annotation[]) o2); [EOL]     } [EOL]     if (componentType.equals(Byte.TYPE)) { [EOL]         return Arrays.equals((byte[]) o1, (byte[]) o2); [EOL]     } [EOL]     if (componentType.equals(Short.TYPE)) { [EOL]         return Arrays.equals((short[]) o1, (short[]) o2); [EOL]     } [EOL]     if (componentType.equals(Integer.TYPE)) { [EOL]         return Arrays.equals((int[]) o1, (int[]) o2); [EOL]     } [EOL]     if (componentType.equals(Character.TYPE)) { [EOL]         return Arrays.equals((char[]) o1, (char[]) o2); [EOL]     } [EOL]     if (componentType.equals(Long.TYPE)) { [EOL]         return Arrays.equals((long[]) o1, (long[]) o2); [EOL]     } [EOL]     if (componentType.equals(Float.TYPE)) { [EOL]         return Arrays.equals((float[]) o1, (float[]) o2); [EOL]     } [EOL]     if (componentType.equals(Double.TYPE)) { [EOL]         return Arrays.equals((double[]) o1, (double[]) o2); [EOL]     } [EOL]     if (componentType.equals(Boolean.TYPE)) { [EOL]         return Arrays.equals((boolean[]) o1, (boolean[]) o2); [EOL]     } [EOL]     return Arrays.equals((Object[]) o1, (Object[]) o2); [EOL] } 
 [LINE] if (componentType.equals(Boolean.TYPE)) { [LINE] private static boolean arrayMemberEquals(final Class<?> componentType, final Object o1, final Object o2) { [EOL]     if (componentType.isAnnotation()) { [EOL]         return annotationArrayMemberEquals((Annotation[]) o1, (Annotation[]) o2); [EOL]     } [EOL]     if (componentType.equals(Byte.TYPE)) { [EOL]         return Arrays.equals((byte[]) o1, (byte[]) o2); [EOL]     } [EOL]     if (componentType.equals(Short.TYPE)) { [EOL]         return Arrays.equals((short[]) o1, (short[]) o2); [EOL]     } [EOL]     if (componentType.equals(Integer.TYPE)) { [EOL]         return Arrays.equals((int[]) o1, (int[]) o2); [EOL]     } [EOL]     if (componentType.equals(Character.TYPE)) { [EOL]         return Arrays.equals((char[]) o1, (char[]) o2); [EOL]     } [EOL]     if (componentType.equals(Long.TYPE)) { [EOL]         return Arrays.equals((long[]) o1, (long[]) o2); [EOL]     } [EOL]     if (componentType.equals(Float.TYPE)) { [EOL]         return Arrays.equals((float[]) o1, (float[]) o2); [EOL]     } [EOL]     if (componentType.equals(Double.TYPE)) { [EOL]         return Arrays.equals((double[]) o1, (double[]) o2); [EOL]     } [EOL]     if (componentType.equals(Boolean.TYPE)) { [EOL]         return Arrays.equals((boolean[]) o1, (boolean[]) o2); [EOL]     } [EOL]     return Arrays.equals((Object[]) o1, (Object[]) o2); [EOL] } 
 [LINE] return Arrays.equals((boolean[]) o1, (boolean[]) o2); [LINE] private static boolean arrayMemberEquals(final Class<?> componentType, final Object o1, final Object o2) { [EOL]     if (componentType.isAnnotation()) { [EOL]         return annotationArrayMemberEquals((Annotation[]) o1, (Annotation[]) o2); [EOL]     } [EOL]     if (componentType.equals(Byte.TYPE)) { [EOL]         return Arrays.equals((byte[]) o1, (byte[]) o2); [EOL]     } [EOL]     if (componentType.equals(Short.TYPE)) { [EOL]         return Arrays.equals((short[]) o1, (short[]) o2); [EOL]     } [EOL]     if (componentType.equals(Integer.TYPE)) { [EOL]         return Arrays.equals((int[]) o1, (int[]) o2); [EOL]     } [EOL]     if (componentType.equals(Character.TYPE)) { [EOL]         return Arrays.equals((char[]) o1, (char[]) o2); [EOL]     } [EOL]     if (componentType.equals(Long.TYPE)) { [EOL]         return Arrays.equals((long[]) o1, (long[]) o2); [EOL]     } [EOL]     if (componentType.equals(Float.TYPE)) { [EOL]         return Arrays.equals((float[]) o1, (float[]) o2); [EOL]     } [EOL]     if (componentType.equals(Double.TYPE)) { [EOL]         return Arrays.equals((double[]) o1, (double[]) o2); [EOL]     } [EOL]     if (componentType.equals(Boolean.TYPE)) { [EOL]         return Arrays.equals((boolean[]) o1, (boolean[]) o2); [EOL]     } [EOL]     return Arrays.equals((Object[]) o1, (Object[]) o2); [EOL] } 
 [LINE] return Arrays.equals((Object[]) o1, (Object[]) o2); [LINE] private static boolean arrayMemberEquals(final Class<?> componentType, final Object o1, final Object o2) { [EOL]     if (componentType.isAnnotation()) { [EOL]         return annotationArrayMemberEquals((Annotation[]) o1, (Annotation[]) o2); [EOL]     } [EOL]     if (componentType.equals(Byte.TYPE)) { [EOL]         return Arrays.equals((byte[]) o1, (byte[]) o2); [EOL]     } [EOL]     if (componentType.equals(Short.TYPE)) { [EOL]         return Arrays.equals((short[]) o1, (short[]) o2); [EOL]     } [EOL]     if (componentType.equals(Integer.TYPE)) { [EOL]         return Arrays.equals((int[]) o1, (int[]) o2); [EOL]     } [EOL]     if (componentType.equals(Character.TYPE)) { [EOL]         return Arrays.equals((char[]) o1, (char[]) o2); [EOL]     } [EOL]     if (componentType.equals(Long.TYPE)) { [EOL]         return Arrays.equals((long[]) o1, (long[]) o2); [EOL]     } [EOL]     if (componentType.equals(Float.TYPE)) { [EOL]         return Arrays.equals((float[]) o1, (float[]) o2); [EOL]     } [EOL]     if (componentType.equals(Double.TYPE)) { [EOL]         return Arrays.equals((double[]) o1, (double[]) o2); [EOL]     } [EOL]     if (componentType.equals(Boolean.TYPE)) { [EOL]         return Arrays.equals((boolean[]) o1, (boolean[]) o2); [EOL]     } [EOL]     return Arrays.equals((Object[]) o1, (Object[]) o2); [EOL] } 
 [LINE] private static boolean annotationArrayMemberEquals(final Annotation[] a1, final Annotation[] a2) { [LINE] private static boolean annotationArrayMemberEquals(final Annotation[] a1, final Annotation[] a2) { [EOL]     if (a1.length != a2.length) { [EOL]         return false; [EOL]     } [EOL]     for (int i = 0; i < a1.length; i++) { [EOL]         if (!equals(a1[i], a2[i])) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] if (a1.length != a2.length) { [LINE] private static boolean annotationArrayMemberEquals(final Annotation[] a1, final Annotation[] a2) { [EOL]     if (a1.length != a2.length) { [EOL]         return false; [EOL]     } [EOL]     for (int i = 0; i < a1.length; i++) { [EOL]         if (!equals(a1[i], a2[i])) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] return false; [LINE] private static boolean annotationArrayMemberEquals(final Annotation[] a1, final Annotation[] a2) { [EOL]     if (a1.length != a2.length) { [EOL]         return false; [EOL]     } [EOL]     for (int i = 0; i < a1.length; i++) { [EOL]         if (!equals(a1[i], a2[i])) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] for (int i = 0; i < a1.length; i++) { [LINE] private static boolean annotationArrayMemberEquals(final Annotation[] a1, final Annotation[] a2) { [EOL]     if (a1.length != a2.length) { [EOL]         return false; [EOL]     } [EOL]     for (int i = 0; i < a1.length; i++) { [EOL]         if (!equals(a1[i], a2[i])) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] if (!equals(a1[i], a2[i])) { [LINE] private static boolean annotationArrayMemberEquals(final Annotation[] a1, final Annotation[] a2) { [EOL]     if (a1.length != a2.length) { [EOL]         return false; [EOL]     } [EOL]     for (int i = 0; i < a1.length; i++) { [EOL]         if (!equals(a1[i], a2[i])) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] return true; [LINE] private static boolean annotationArrayMemberEquals(final Annotation[] a1, final Annotation[] a2) { [EOL]     if (a1.length != a2.length) { [EOL]         return false; [EOL]     } [EOL]     for (int i = 0; i < a1.length; i++) { [EOL]         if (!equals(a1[i], a2[i])) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] private static int arrayMemberHash(final Class<?> componentType, final Object o) { [LINE] private static int arrayMemberHash(final Class<?> componentType, final Object o) { [EOL]     if (componentType.equals(Byte.TYPE)) { [EOL]         return Arrays.hashCode((byte[]) o); [EOL]     } [EOL]     if (componentType.equals(Short.TYPE)) { [EOL]         return Arrays.hashCode((short[]) o); [EOL]     } [EOL]     if (componentType.equals(Integer.TYPE)) { [EOL]         return Arrays.hashCode((int[]) o); [EOL]     } [EOL]     if (componentType.equals(Character.TYPE)) { [EOL]         return Arrays.hashCode((char[]) o); [EOL]     } [EOL]     if (componentType.equals(Long.TYPE)) { [EOL]         return Arrays.hashCode((long[]) o); [EOL]     } [EOL]     if (componentType.equals(Float.TYPE)) { [EOL]         return Arrays.hashCode((float[]) o); [EOL]     } [EOL]     if (componentType.equals(Double.TYPE)) { [EOL]         return Arrays.hashCode((double[]) o); [EOL]     } [EOL]     if (componentType.equals(Boolean.TYPE)) { [EOL]         return Arrays.hashCode((boolean[]) o); [EOL]     } [EOL]     return Arrays.hashCode((Object[]) o); [EOL] } 
 [LINE] if (componentType.equals(Byte.TYPE)) { [LINE] private static int arrayMemberHash(final Class<?> componentType, final Object o) { [EOL]     if (componentType.equals(Byte.TYPE)) { [EOL]         return Arrays.hashCode((byte[]) o); [EOL]     } [EOL]     if (componentType.equals(Short.TYPE)) { [EOL]         return Arrays.hashCode((short[]) o); [EOL]     } [EOL]     if (componentType.equals(Integer.TYPE)) { [EOL]         return Arrays.hashCode((int[]) o); [EOL]     } [EOL]     if (componentType.equals(Character.TYPE)) { [EOL]         return Arrays.hashCode((char[]) o); [EOL]     } [EOL]     if (componentType.equals(Long.TYPE)) { [EOL]         return Arrays.hashCode((long[]) o); [EOL]     } [EOL]     if (componentType.equals(Float.TYPE)) { [EOL]         return Arrays.hashCode((float[]) o); [EOL]     } [EOL]     if (componentType.equals(Double.TYPE)) { [EOL]         return Arrays.hashCode((double[]) o); [EOL]     } [EOL]     if (componentType.equals(Boolean.TYPE)) { [EOL]         return Arrays.hashCode((boolean[]) o); [EOL]     } [EOL]     return Arrays.hashCode((Object[]) o); [EOL] } 
 [LINE] return Arrays.hashCode((byte[]) o); [LINE] private static int arrayMemberHash(final Class<?> componentType, final Object o) { [EOL]     if (componentType.equals(Byte.TYPE)) { [EOL]         return Arrays.hashCode((byte[]) o); [EOL]     } [EOL]     if (componentType.equals(Short.TYPE)) { [EOL]         return Arrays.hashCode((short[]) o); [EOL]     } [EOL]     if (componentType.equals(Integer.TYPE)) { [EOL]         return Arrays.hashCode((int[]) o); [EOL]     } [EOL]     if (componentType.equals(Character.TYPE)) { [EOL]         return Arrays.hashCode((char[]) o); [EOL]     } [EOL]     if (componentType.equals(Long.TYPE)) { [EOL]         return Arrays.hashCode((long[]) o); [EOL]     } [EOL]     if (componentType.equals(Float.TYPE)) { [EOL]         return Arrays.hashCode((float[]) o); [EOL]     } [EOL]     if (componentType.equals(Double.TYPE)) { [EOL]         return Arrays.hashCode((double[]) o); [EOL]     } [EOL]     if (componentType.equals(Boolean.TYPE)) { [EOL]         return Arrays.hashCode((boolean[]) o); [EOL]     } [EOL]     return Arrays.hashCode((Object[]) o); [EOL] } 
 [LINE] if (componentType.equals(Short.TYPE)) { [LINE] private static int arrayMemberHash(final Class<?> componentType, final Object o) { [EOL]     if (componentType.equals(Byte.TYPE)) { [EOL]         return Arrays.hashCode((byte[]) o); [EOL]     } [EOL]     if (componentType.equals(Short.TYPE)) { [EOL]         return Arrays.hashCode((short[]) o); [EOL]     } [EOL]     if (componentType.equals(Integer.TYPE)) { [EOL]         return Arrays.hashCode((int[]) o); [EOL]     } [EOL]     if (componentType.equals(Character.TYPE)) { [EOL]         return Arrays.hashCode((char[]) o); [EOL]     } [EOL]     if (componentType.equals(Long.TYPE)) { [EOL]         return Arrays.hashCode((long[]) o); [EOL]     } [EOL]     if (componentType.equals(Float.TYPE)) { [EOL]         return Arrays.hashCode((float[]) o); [EOL]     } [EOL]     if (componentType.equals(Double.TYPE)) { [EOL]         return Arrays.hashCode((double[]) o); [EOL]     } [EOL]     if (componentType.equals(Boolean.TYPE)) { [EOL]         return Arrays.hashCode((boolean[]) o); [EOL]     } [EOL]     return Arrays.hashCode((Object[]) o); [EOL] } 
 [LINE] return Arrays.hashCode((short[]) o); [LINE] private static int arrayMemberHash(final Class<?> componentType, final Object o) { [EOL]     if (componentType.equals(Byte.TYPE)) { [EOL]         return Arrays.hashCode((byte[]) o); [EOL]     } [EOL]     if (componentType.equals(Short.TYPE)) { [EOL]         return Arrays.hashCode((short[]) o); [EOL]     } [EOL]     if (componentType.equals(Integer.TYPE)) { [EOL]         return Arrays.hashCode((int[]) o); [EOL]     } [EOL]     if (componentType.equals(Character.TYPE)) { [EOL]         return Arrays.hashCode((char[]) o); [EOL]     } [EOL]     if (componentType.equals(Long.TYPE)) { [EOL]         return Arrays.hashCode((long[]) o); [EOL]     } [EOL]     if (componentType.equals(Float.TYPE)) { [EOL]         return Arrays.hashCode((float[]) o); [EOL]     } [EOL]     if (componentType.equals(Double.TYPE)) { [EOL]         return Arrays.hashCode((double[]) o); [EOL]     } [EOL]     if (componentType.equals(Boolean.TYPE)) { [EOL]         return Arrays.hashCode((boolean[]) o); [EOL]     } [EOL]     return Arrays.hashCode((Object[]) o); [EOL] } 
 [LINE] if (componentType.equals(Integer.TYPE)) { [LINE] private static int arrayMemberHash(final Class<?> componentType, final Object o) { [EOL]     if (componentType.equals(Byte.TYPE)) { [EOL]         return Arrays.hashCode((byte[]) o); [EOL]     } [EOL]     if (componentType.equals(Short.TYPE)) { [EOL]         return Arrays.hashCode((short[]) o); [EOL]     } [EOL]     if (componentType.equals(Integer.TYPE)) { [EOL]         return Arrays.hashCode((int[]) o); [EOL]     } [EOL]     if (componentType.equals(Character.TYPE)) { [EOL]         return Arrays.hashCode((char[]) o); [EOL]     } [EOL]     if (componentType.equals(Long.TYPE)) { [EOL]         return Arrays.hashCode((long[]) o); [EOL]     } [EOL]     if (componentType.equals(Float.TYPE)) { [EOL]         return Arrays.hashCode((float[]) o); [EOL]     } [EOL]     if (componentType.equals(Double.TYPE)) { [EOL]         return Arrays.hashCode((double[]) o); [EOL]     } [EOL]     if (componentType.equals(Boolean.TYPE)) { [EOL]         return Arrays.hashCode((boolean[]) o); [EOL]     } [EOL]     return Arrays.hashCode((Object[]) o); [EOL] } 
 [LINE] return Arrays.hashCode((int[]) o); [LINE] private static int arrayMemberHash(final Class<?> componentType, final Object o) { [EOL]     if (componentType.equals(Byte.TYPE)) { [EOL]         return Arrays.hashCode((byte[]) o); [EOL]     } [EOL]     if (componentType.equals(Short.TYPE)) { [EOL]         return Arrays.hashCode((short[]) o); [EOL]     } [EOL]     if (componentType.equals(Integer.TYPE)) { [EOL]         return Arrays.hashCode((int[]) o); [EOL]     } [EOL]     if (componentType.equals(Character.TYPE)) { [EOL]         return Arrays.hashCode((char[]) o); [EOL]     } [EOL]     if (componentType.equals(Long.TYPE)) { [EOL]         return Arrays.hashCode((long[]) o); [EOL]     } [EOL]     if (componentType.equals(Float.TYPE)) { [EOL]         return Arrays.hashCode((float[]) o); [EOL]     } [EOL]     if (componentType.equals(Double.TYPE)) { [EOL]         return Arrays.hashCode((double[]) o); [EOL]     } [EOL]     if (componentType.equals(Boolean.TYPE)) { [EOL]         return Arrays.hashCode((boolean[]) o); [EOL]     } [EOL]     return Arrays.hashCode((Object[]) o); [EOL] } 
 [LINE] if (componentType.equals(Character.TYPE)) { [LINE] private static int arrayMemberHash(final Class<?> componentType, final Object o) { [EOL]     if (componentType.equals(Byte.TYPE)) { [EOL]         return Arrays.hashCode((byte[]) o); [EOL]     } [EOL]     if (componentType.equals(Short.TYPE)) { [EOL]         return Arrays.hashCode((short[]) o); [EOL]     } [EOL]     if (componentType.equals(Integer.TYPE)) { [EOL]         return Arrays.hashCode((int[]) o); [EOL]     } [EOL]     if (componentType.equals(Character.TYPE)) { [EOL]         return Arrays.hashCode((char[]) o); [EOL]     } [EOL]     if (componentType.equals(Long.TYPE)) { [EOL]         return Arrays.hashCode((long[]) o); [EOL]     } [EOL]     if (componentType.equals(Float.TYPE)) { [EOL]         return Arrays.hashCode((float[]) o); [EOL]     } [EOL]     if (componentType.equals(Double.TYPE)) { [EOL]         return Arrays.hashCode((double[]) o); [EOL]     } [EOL]     if (componentType.equals(Boolean.TYPE)) { [EOL]         return Arrays.hashCode((boolean[]) o); [EOL]     } [EOL]     return Arrays.hashCode((Object[]) o); [EOL] } 
 [LINE] return Arrays.hashCode((char[]) o); [LINE] private static int arrayMemberHash(final Class<?> componentType, final Object o) { [EOL]     if (componentType.equals(Byte.TYPE)) { [EOL]         return Arrays.hashCode((byte[]) o); [EOL]     } [EOL]     if (componentType.equals(Short.TYPE)) { [EOL]         return Arrays.hashCode((short[]) o); [EOL]     } [EOL]     if (componentType.equals(Integer.TYPE)) { [EOL]         return Arrays.hashCode((int[]) o); [EOL]     } [EOL]     if (componentType.equals(Character.TYPE)) { [EOL]         return Arrays.hashCode((char[]) o); [EOL]     } [EOL]     if (componentType.equals(Long.TYPE)) { [EOL]         return Arrays.hashCode((long[]) o); [EOL]     } [EOL]     if (componentType.equals(Float.TYPE)) { [EOL]         return Arrays.hashCode((float[]) o); [EOL]     } [EOL]     if (componentType.equals(Double.TYPE)) { [EOL]         return Arrays.hashCode((double[]) o); [EOL]     } [EOL]     if (componentType.equals(Boolean.TYPE)) { [EOL]         return Arrays.hashCode((boolean[]) o); [EOL]     } [EOL]     return Arrays.hashCode((Object[]) o); [EOL] } 
 [LINE] if (componentType.equals(Long.TYPE)) { [LINE] private static int arrayMemberHash(final Class<?> componentType, final Object o) { [EOL]     if (componentType.equals(Byte.TYPE)) { [EOL]         return Arrays.hashCode((byte[]) o); [EOL]     } [EOL]     if (componentType.equals(Short.TYPE)) { [EOL]         return Arrays.hashCode((short[]) o); [EOL]     } [EOL]     if (componentType.equals(Integer.TYPE)) { [EOL]         return Arrays.hashCode((int[]) o); [EOL]     } [EOL]     if (componentType.equals(Character.TYPE)) { [EOL]         return Arrays.hashCode((char[]) o); [EOL]     } [EOL]     if (componentType.equals(Long.TYPE)) { [EOL]         return Arrays.hashCode((long[]) o); [EOL]     } [EOL]     if (componentType.equals(Float.TYPE)) { [EOL]         return Arrays.hashCode((float[]) o); [EOL]     } [EOL]     if (componentType.equals(Double.TYPE)) { [EOL]         return Arrays.hashCode((double[]) o); [EOL]     } [EOL]     if (componentType.equals(Boolean.TYPE)) { [EOL]         return Arrays.hashCode((boolean[]) o); [EOL]     } [EOL]     return Arrays.hashCode((Object[]) o); [EOL] } 
 [LINE] return Arrays.hashCode((long[]) o); [LINE] private static int arrayMemberHash(final Class<?> componentType, final Object o) { [EOL]     if (componentType.equals(Byte.TYPE)) { [EOL]         return Arrays.hashCode((byte[]) o); [EOL]     } [EOL]     if (componentType.equals(Short.TYPE)) { [EOL]         return Arrays.hashCode((short[]) o); [EOL]     } [EOL]     if (componentType.equals(Integer.TYPE)) { [EOL]         return Arrays.hashCode((int[]) o); [EOL]     } [EOL]     if (componentType.equals(Character.TYPE)) { [EOL]         return Arrays.hashCode((char[]) o); [EOL]     } [EOL]     if (componentType.equals(Long.TYPE)) { [EOL]         return Arrays.hashCode((long[]) o); [EOL]     } [EOL]     if (componentType.equals(Float.TYPE)) { [EOL]         return Arrays.hashCode((float[]) o); [EOL]     } [EOL]     if (componentType.equals(Double.TYPE)) { [EOL]         return Arrays.hashCode((double[]) o); [EOL]     } [EOL]     if (componentType.equals(Boolean.TYPE)) { [EOL]         return Arrays.hashCode((boolean[]) o); [EOL]     } [EOL]     return Arrays.hashCode((Object[]) o); [EOL] } 
 [LINE] if (componentType.equals(Float.TYPE)) { [LINE] private static int arrayMemberHash(final Class<?> componentType, final Object o) { [EOL]     if (componentType.equals(Byte.TYPE)) { [EOL]         return Arrays.hashCode((byte[]) o); [EOL]     } [EOL]     if (componentType.equals(Short.TYPE)) { [EOL]         return Arrays.hashCode((short[]) o); [EOL]     } [EOL]     if (componentType.equals(Integer.TYPE)) { [EOL]         return Arrays.hashCode((int[]) o); [EOL]     } [EOL]     if (componentType.equals(Character.TYPE)) { [EOL]         return Arrays.hashCode((char[]) o); [EOL]     } [EOL]     if (componentType.equals(Long.TYPE)) { [EOL]         return Arrays.hashCode((long[]) o); [EOL]     } [EOL]     if (componentType.equals(Float.TYPE)) { [EOL]         return Arrays.hashCode((float[]) o); [EOL]     } [EOL]     if (componentType.equals(Double.TYPE)) { [EOL]         return Arrays.hashCode((double[]) o); [EOL]     } [EOL]     if (componentType.equals(Boolean.TYPE)) { [EOL]         return Arrays.hashCode((boolean[]) o); [EOL]     } [EOL]     return Arrays.hashCode((Object[]) o); [EOL] } 
 [LINE] return Arrays.hashCode((float[]) o); [LINE] private static int arrayMemberHash(final Class<?> componentType, final Object o) { [EOL]     if (componentType.equals(Byte.TYPE)) { [EOL]         return Arrays.hashCode((byte[]) o); [EOL]     } [EOL]     if (componentType.equals(Short.TYPE)) { [EOL]         return Arrays.hashCode((short[]) o); [EOL]     } [EOL]     if (componentType.equals(Integer.TYPE)) { [EOL]         return Arrays.hashCode((int[]) o); [EOL]     } [EOL]     if (componentType.equals(Character.TYPE)) { [EOL]         return Arrays.hashCode((char[]) o); [EOL]     } [EOL]     if (componentType.equals(Long.TYPE)) { [EOL]         return Arrays.hashCode((long[]) o); [EOL]     } [EOL]     if (componentType.equals(Float.TYPE)) { [EOL]         return Arrays.hashCode((float[]) o); [EOL]     } [EOL]     if (componentType.equals(Double.TYPE)) { [EOL]         return Arrays.hashCode((double[]) o); [EOL]     } [EOL]     if (componentType.equals(Boolean.TYPE)) { [EOL]         return Arrays.hashCode((boolean[]) o); [EOL]     } [EOL]     return Arrays.hashCode((Object[]) o); [EOL] } 
 [LINE] if (componentType.equals(Double.TYPE)) { [LINE] private static int arrayMemberHash(final Class<?> componentType, final Object o) { [EOL]     if (componentType.equals(Byte.TYPE)) { [EOL]         return Arrays.hashCode((byte[]) o); [EOL]     } [EOL]     if (componentType.equals(Short.TYPE)) { [EOL]         return Arrays.hashCode((short[]) o); [EOL]     } [EOL]     if (componentType.equals(Integer.TYPE)) { [EOL]         return Arrays.hashCode((int[]) o); [EOL]     } [EOL]     if (componentType.equals(Character.TYPE)) { [EOL]         return Arrays.hashCode((char[]) o); [EOL]     } [EOL]     if (componentType.equals(Long.TYPE)) { [EOL]         return Arrays.hashCode((long[]) o); [EOL]     } [EOL]     if (componentType.equals(Float.TYPE)) { [EOL]         return Arrays.hashCode((float[]) o); [EOL]     } [EOL]     if (componentType.equals(Double.TYPE)) { [EOL]         return Arrays.hashCode((double[]) o); [EOL]     } [EOL]     if (componentType.equals(Boolean.TYPE)) { [EOL]         return Arrays.hashCode((boolean[]) o); [EOL]     } [EOL]     return Arrays.hashCode((Object[]) o); [EOL] } 
 [LINE] return Arrays.hashCode((double[]) o); [LINE] private static int arrayMemberHash(final Class<?> componentType, final Object o) { [EOL]     if (componentType.equals(Byte.TYPE)) { [EOL]         return Arrays.hashCode((byte[]) o); [EOL]     } [EOL]     if (componentType.equals(Short.TYPE)) { [EOL]         return Arrays.hashCode((short[]) o); [EOL]     } [EOL]     if (componentType.equals(Integer.TYPE)) { [EOL]         return Arrays.hashCode((int[]) o); [EOL]     } [EOL]     if (componentType.equals(Character.TYPE)) { [EOL]         return Arrays.hashCode((char[]) o); [EOL]     } [EOL]     if (componentType.equals(Long.TYPE)) { [EOL]         return Arrays.hashCode((long[]) o); [EOL]     } [EOL]     if (componentType.equals(Float.TYPE)) { [EOL]         return Arrays.hashCode((float[]) o); [EOL]     } [EOL]     if (componentType.equals(Double.TYPE)) { [EOL]         return Arrays.hashCode((double[]) o); [EOL]     } [EOL]     if (componentType.equals(Boolean.TYPE)) { [EOL]         return Arrays.hashCode((boolean[]) o); [EOL]     } [EOL]     return Arrays.hashCode((Object[]) o); [EOL] } 
 [LINE] if (componentType.equals(Boolean.TYPE)) { [LINE] private static int arrayMemberHash(final Class<?> componentType, final Object o) { [EOL]     if (componentType.equals(Byte.TYPE)) { [EOL]         return Arrays.hashCode((byte[]) o); [EOL]     } [EOL]     if (componentType.equals(Short.TYPE)) { [EOL]         return Arrays.hashCode((short[]) o); [EOL]     } [EOL]     if (componentType.equals(Integer.TYPE)) { [EOL]         return Arrays.hashCode((int[]) o); [EOL]     } [EOL]     if (componentType.equals(Character.TYPE)) { [EOL]         return Arrays.hashCode((char[]) o); [EOL]     } [EOL]     if (componentType.equals(Long.TYPE)) { [EOL]         return Arrays.hashCode((long[]) o); [EOL]     } [EOL]     if (componentType.equals(Float.TYPE)) { [EOL]         return Arrays.hashCode((float[]) o); [EOL]     } [EOL]     if (componentType.equals(Double.TYPE)) { [EOL]         return Arrays.hashCode((double[]) o); [EOL]     } [EOL]     if (componentType.equals(Boolean.TYPE)) { [EOL]         return Arrays.hashCode((boolean[]) o); [EOL]     } [EOL]     return Arrays.hashCode((Object[]) o); [EOL] } 
 [LINE] return Arrays.hashCode((boolean[]) o); [LINE] private static int arrayMemberHash(final Class<?> componentType, final Object o) { [EOL]     if (componentType.equals(Byte.TYPE)) { [EOL]         return Arrays.hashCode((byte[]) o); [EOL]     } [EOL]     if (componentType.equals(Short.TYPE)) { [EOL]         return Arrays.hashCode((short[]) o); [EOL]     } [EOL]     if (componentType.equals(Integer.TYPE)) { [EOL]         return Arrays.hashCode((int[]) o); [EOL]     } [EOL]     if (componentType.equals(Character.TYPE)) { [EOL]         return Arrays.hashCode((char[]) o); [EOL]     } [EOL]     if (componentType.equals(Long.TYPE)) { [EOL]         return Arrays.hashCode((long[]) o); [EOL]     } [EOL]     if (componentType.equals(Float.TYPE)) { [EOL]         return Arrays.hashCode((float[]) o); [EOL]     } [EOL]     if (componentType.equals(Double.TYPE)) { [EOL]         return Arrays.hashCode((double[]) o); [EOL]     } [EOL]     if (componentType.equals(Boolean.TYPE)) { [EOL]         return Arrays.hashCode((boolean[]) o); [EOL]     } [EOL]     return Arrays.hashCode((Object[]) o); [EOL] } 
 [LINE] return Arrays.hashCode((Object[]) o); [LINE] private static int arrayMemberHash(final Class<?> componentType, final Object o) { [EOL]     if (componentType.equals(Byte.TYPE)) { [EOL]         return Arrays.hashCode((byte[]) o); [EOL]     } [EOL]     if (componentType.equals(Short.TYPE)) { [EOL]         return Arrays.hashCode((short[]) o); [EOL]     } [EOL]     if (componentType.equals(Integer.TYPE)) { [EOL]         return Arrays.hashCode((int[]) o); [EOL]     } [EOL]     if (componentType.equals(Character.TYPE)) { [EOL]         return Arrays.hashCode((char[]) o); [EOL]     } [EOL]     if (componentType.equals(Long.TYPE)) { [EOL]         return Arrays.hashCode((long[]) o); [EOL]     } [EOL]     if (componentType.equals(Float.TYPE)) { [EOL]         return Arrays.hashCode((float[]) o); [EOL]     } [EOL]     if (componentType.equals(Double.TYPE)) { [EOL]         return Arrays.hashCode((double[]) o); [EOL]     } [EOL]     if (componentType.equals(Boolean.TYPE)) { [EOL]         return Arrays.hashCode((boolean[]) o); [EOL]     } [EOL]     return Arrays.hashCode((Object[]) o); [EOL] } 
 [LINE] throw new RuntimeException("Unable to add listener.", e.getCause()); [LINE] public static <L> void addEventListener(final Object eventSource, final Class<L> listenerType, final L listener) { [EOL]     try { [EOL]         MethodUtils.invokeMethod(eventSource, "add" + listenerType.getSimpleName(), listener); [EOL]     } catch (final NoSuchMethodException e) { [EOL]         throw new IllegalArgumentException("Class " + eventSource.getClass().getName() + " does not have a public add" + listenerType.getSimpleName() + " method which takes a parameter of type " + listenerType.getName() + "."); [EOL]     } catch (final IllegalAccessException e) { [EOL]         throw new IllegalArgumentException("Class " + eventSource.getClass().getName() + " does not have an accessible add" + listenerType.getSimpleName() + " method which takes a parameter of type " + listenerType.getName() + "."); [EOL]     } catch (final InvocationTargetException e) { [EOL]         throw new RuntimeException("Unable to add listener.", e.getCause()); [EOL]     } [EOL] } 
 [LINE] addEventListener(eventSource, listenerType, listener); [LINE] public static <L> void bindEventsToMethod(final Object target, final String methodName, final Object eventSource, final Class<L> listenerType, final String... eventTypes) { [EOL]     final L listener = listenerType.cast(Proxy.newProxyInstance(target.getClass().getClassLoader(), new Class[] { listenerType }, new EventBindingInvocationHandler(target, methodName, eventTypes))); [EOL]     addEventListener(eventSource, listenerType, listener); [EOL] } 
 [LINE] @Override [LINE] @Override [EOL] public Object invoke(final Object proxy, final Method method, final Object[] parameters) throws Throwable { [EOL]     if (eventTypes.isEmpty() || eventTypes.contains(method.getName())) { [EOL]         if (hasMatchingParametersMethod(method)) { [EOL]             return MethodUtils.invokeMethod(target, methodName, parameters); [EOL]         } else { [EOL]             return MethodUtils.invokeMethod(target, methodName); [EOL]         } [EOL]     } [EOL]     return null; [EOL] } 
 [LINE] if (eventTypes.isEmpty() || eventTypes.contains(method.getName())) { [LINE] @Override [EOL] public Object invoke(final Object proxy, final Method method, final Object[] parameters) throws Throwable { [EOL]     if (eventTypes.isEmpty() || eventTypes.contains(method.getName())) { [EOL]         if (hasMatchingParametersMethod(method)) { [EOL]             return MethodUtils.invokeMethod(target, methodName, parameters); [EOL]         } else { [EOL]             return MethodUtils.invokeMethod(target, methodName); [EOL]         } [EOL]     } [EOL]     return null; [EOL] } 
 [LINE] if (hasMatchingParametersMethod(method)) { [LINE] @Override [EOL] public Object invoke(final Object proxy, final Method method, final Object[] parameters) throws Throwable { [EOL]     if (eventTypes.isEmpty() || eventTypes.contains(method.getName())) { [EOL]         if (hasMatchingParametersMethod(method)) { [EOL]             return MethodUtils.invokeMethod(target, methodName, parameters); [EOL]         } else { [EOL]             return MethodUtils.invokeMethod(target, methodName); [EOL]         } [EOL]     } [EOL]     return null; [EOL] } 
 [LINE] return MethodUtils.invokeMethod(target, methodName, parameters); [LINE] @Override [EOL] public Object invoke(final Object proxy, final Method method, final Object[] parameters) throws Throwable { [EOL]     if (eventTypes.isEmpty() || eventTypes.contains(method.getName())) { [EOL]         if (hasMatchingParametersMethod(method)) { [EOL]             return MethodUtils.invokeMethod(target, methodName, parameters); [EOL]         } else { [EOL]             return MethodUtils.invokeMethod(target, methodName); [EOL]         } [EOL]     } [EOL]     return null; [EOL] } 
 [LINE] return MethodUtils.invokeMethod(target, methodName); [LINE] @Override [EOL] public Object invoke(final Object proxy, final Method method, final Object[] parameters) throws Throwable { [EOL]     if (eventTypes.isEmpty() || eventTypes.contains(method.getName())) { [EOL]         if (hasMatchingParametersMethod(method)) { [EOL]             return MethodUtils.invokeMethod(target, methodName, parameters); [EOL]         } else { [EOL]             return MethodUtils.invokeMethod(target, methodName); [EOL]         } [EOL]     } [EOL]     return null; [EOL] } 
 [LINE] return null; [LINE] @Override [EOL] public Object invoke(final Object proxy, final Method method, final Object[] parameters) throws Throwable { [EOL]     if (eventTypes.isEmpty() || eventTypes.contains(method.getName())) { [EOL]         if (hasMatchingParametersMethod(method)) { [EOL]             return MethodUtils.invokeMethod(target, methodName, parameters); [EOL]         } else { [EOL]             return MethodUtils.invokeMethod(target, methodName); [EOL]         } [EOL]     } [EOL]     return null; [EOL] } 
 [LINE] private boolean hasMatchingParametersMethod(final Method method) { [LINE] private boolean hasMatchingParametersMethod(final Method method) { [EOL]     return MethodUtils.getAccessibleMethod(target.getClass(), methodName, method.getParameterTypes()) != null; [EOL] } 
 [LINE] return MethodUtils.getAccessibleMethod(target.getClass(), methodName, method.getParameterTypes()) != null; [LINE] private boolean hasMatchingParametersMethod(final Method method) { [EOL]     return MethodUtils.getAccessibleMethod(target.getClass(), methodName, method.getParameterTypes()) != null; [EOL] } 
 [LINE] return null; [LINE] public static Map<Object, Object> toMap(final Object[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     final Map<Object, Object> map = new HashMap<Object, Object>((int) (array.length * 1.5)); [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Object object = array[i]; [EOL]         if (object instanceof Map.Entry<?, ?>) { [EOL]             final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) object; [EOL]             map.put(entry.getKey(), entry.getValue()); [EOL]         } else if (object instanceof Object[]) { [EOL]             final Object[] entry = (Object[]) object; [EOL]             if (entry.length < 2) { [EOL]                 throw new IllegalArgumentException("Array element " + i + ", '" + object + "', has a length less than 2"); [EOL]             } [EOL]             map.put(entry[0], entry[1]); [EOL]         } else { [EOL]             throw new IllegalArgumentException("Array element " + i + ", '" + object + "', is neither of type Map.Entry nor an Array"); [EOL]         } [EOL]     } [EOL]     return map; [EOL] } 
 [LINE] final Object object = array[i]; [LINE] public static Map<Object, Object> toMap(final Object[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     final Map<Object, Object> map = new HashMap<Object, Object>((int) (array.length * 1.5)); [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Object object = array[i]; [EOL]         if (object instanceof Map.Entry<?, ?>) { [EOL]             final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) object; [EOL]             map.put(entry.getKey(), entry.getValue()); [EOL]         } else if (object instanceof Object[]) { [EOL]             final Object[] entry = (Object[]) object; [EOL]             if (entry.length < 2) { [EOL]                 throw new IllegalArgumentException("Array element " + i + ", '" + object + "', has a length less than 2"); [EOL]             } [EOL]             map.put(entry[0], entry[1]); [EOL]         } else { [EOL]             throw new IllegalArgumentException("Array element " + i + ", '" + object + "', is neither of type Map.Entry nor an Array"); [EOL]         } [EOL]     } [EOL]     return map; [EOL] } 
 [LINE] if (object instanceof Map.Entry<?, ?>) { [LINE] public static Map<Object, Object> toMap(final Object[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     final Map<Object, Object> map = new HashMap<Object, Object>((int) (array.length * 1.5)); [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Object object = array[i]; [EOL]         if (object instanceof Map.Entry<?, ?>) { [EOL]             final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) object; [EOL]             map.put(entry.getKey(), entry.getValue()); [EOL]         } else if (object instanceof Object[]) { [EOL]             final Object[] entry = (Object[]) object; [EOL]             if (entry.length < 2) { [EOL]                 throw new IllegalArgumentException("Array element " + i + ", '" + object + "', has a length less than 2"); [EOL]             } [EOL]             map.put(entry[0], entry[1]); [EOL]         } else { [EOL]             throw new IllegalArgumentException("Array element " + i + ", '" + object + "', is neither of type Map.Entry nor an Array"); [EOL]         } [EOL]     } [EOL]     return map; [EOL] } 
 [LINE] final Map.Entry<?,?> entry = (Map.Entry<?,?>) object; [LINE] public static Map<Object, Object> toMap(final Object[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     final Map<Object, Object> map = new HashMap<Object, Object>((int) (array.length * 1.5)); [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Object object = array[i]; [EOL]         if (object instanceof Map.Entry<?, ?>) { [EOL]             final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) object; [EOL]             map.put(entry.getKey(), entry.getValue()); [EOL]         } else if (object instanceof Object[]) { [EOL]             final Object[] entry = (Object[]) object; [EOL]             if (entry.length < 2) { [EOL]                 throw new IllegalArgumentException("Array element " + i + ", '" + object + "', has a length less than 2"); [EOL]             } [EOL]             map.put(entry[0], entry[1]); [EOL]         } else { [EOL]             throw new IllegalArgumentException("Array element " + i + ", '" + object + "', is neither of type Map.Entry nor an Array"); [EOL]         } [EOL]     } [EOL]     return map; [EOL] } 
 [LINE] map.put(entry.getKey(), entry.getValue()); [LINE] public static Map<Object, Object> toMap(final Object[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     final Map<Object, Object> map = new HashMap<Object, Object>((int) (array.length * 1.5)); [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Object object = array[i]; [EOL]         if (object instanceof Map.Entry<?, ?>) { [EOL]             final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) object; [EOL]             map.put(entry.getKey(), entry.getValue()); [EOL]         } else if (object instanceof Object[]) { [EOL]             final Object[] entry = (Object[]) object; [EOL]             if (entry.length < 2) { [EOL]                 throw new IllegalArgumentException("Array element " + i + ", '" + object + "', has a length less than 2"); [EOL]             } [EOL]             map.put(entry[0], entry[1]); [EOL]         } else { [EOL]             throw new IllegalArgumentException("Array element " + i + ", '" + object + "', is neither of type Map.Entry nor an Array"); [EOL]         } [EOL]     } [EOL]     return map; [EOL] } 
 [LINE] } else if (object instanceof Object[]) { [LINE] public static Map<Object, Object> toMap(final Object[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     final Map<Object, Object> map = new HashMap<Object, Object>((int) (array.length * 1.5)); [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Object object = array[i]; [EOL]         if (object instanceof Map.Entry<?, ?>) { [EOL]             final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) object; [EOL]             map.put(entry.getKey(), entry.getValue()); [EOL]         } else if (object instanceof Object[]) { [EOL]             final Object[] entry = (Object[]) object; [EOL]             if (entry.length < 2) { [EOL]                 throw new IllegalArgumentException("Array element " + i + ", '" + object + "', has a length less than 2"); [EOL]             } [EOL]             map.put(entry[0], entry[1]); [EOL]         } else { [EOL]             throw new IllegalArgumentException("Array element " + i + ", '" + object + "', is neither of type Map.Entry nor an Array"); [EOL]         } [EOL]     } [EOL]     return map; [EOL] } 
 [LINE] final Object[] entry = (Object[]) object; [LINE] public static Map<Object, Object> toMap(final Object[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     final Map<Object, Object> map = new HashMap<Object, Object>((int) (array.length * 1.5)); [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Object object = array[i]; [EOL]         if (object instanceof Map.Entry<?, ?>) { [EOL]             final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) object; [EOL]             map.put(entry.getKey(), entry.getValue()); [EOL]         } else if (object instanceof Object[]) { [EOL]             final Object[] entry = (Object[]) object; [EOL]             if (entry.length < 2) { [EOL]                 throw new IllegalArgumentException("Array element " + i + ", '" + object + "', has a length less than 2"); [EOL]             } [EOL]             map.put(entry[0], entry[1]); [EOL]         } else { [EOL]             throw new IllegalArgumentException("Array element " + i + ", '" + object + "', is neither of type Map.Entry nor an Array"); [EOL]         } [EOL]     } [EOL]     return map; [EOL] } 
 [LINE] if (entry.length < 2) { [LINE] public static Map<Object, Object> toMap(final Object[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     final Map<Object, Object> map = new HashMap<Object, Object>((int) (array.length * 1.5)); [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Object object = array[i]; [EOL]         if (object instanceof Map.Entry<?, ?>) { [EOL]             final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) object; [EOL]             map.put(entry.getKey(), entry.getValue()); [EOL]         } else if (object instanceof Object[]) { [EOL]             final Object[] entry = (Object[]) object; [EOL]             if (entry.length < 2) { [EOL]                 throw new IllegalArgumentException("Array element " + i + ", '" + object + "', has a length less than 2"); [EOL]             } [EOL]             map.put(entry[0], entry[1]); [EOL]         } else { [EOL]             throw new IllegalArgumentException("Array element " + i + ", '" + object + "', is neither of type Map.Entry nor an Array"); [EOL]         } [EOL]     } [EOL]     return map; [EOL] } 
 [LINE] throw new IllegalArgumentException("Array element " + i + ", '" [LINE] public static Map<Object, Object> toMap(final Object[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     final Map<Object, Object> map = new HashMap<Object, Object>((int) (array.length * 1.5)); [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Object object = array[i]; [EOL]         if (object instanceof Map.Entry<?, ?>) { [EOL]             final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) object; [EOL]             map.put(entry.getKey(), entry.getValue()); [EOL]         } else if (object instanceof Object[]) { [EOL]             final Object[] entry = (Object[]) object; [EOL]             if (entry.length < 2) { [EOL]                 throw new IllegalArgumentException("Array element " + i + ", '" + object + "', has a length less than 2"); [EOL]             } [EOL]             map.put(entry[0], entry[1]); [EOL]         } else { [EOL]             throw new IllegalArgumentException("Array element " + i + ", '" + object + "', is neither of type Map.Entry nor an Array"); [EOL]         } [EOL]     } [EOL]     return map; [EOL] } 
 [LINE] map.put(entry[0], entry[1]); [LINE] public static Map<Object, Object> toMap(final Object[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     final Map<Object, Object> map = new HashMap<Object, Object>((int) (array.length * 1.5)); [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Object object = array[i]; [EOL]         if (object instanceof Map.Entry<?, ?>) { [EOL]             final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) object; [EOL]             map.put(entry.getKey(), entry.getValue()); [EOL]         } else if (object instanceof Object[]) { [EOL]             final Object[] entry = (Object[]) object; [EOL]             if (entry.length < 2) { [EOL]                 throw new IllegalArgumentException("Array element " + i + ", '" + object + "', has a length less than 2"); [EOL]             } [EOL]             map.put(entry[0], entry[1]); [EOL]         } else { [EOL]             throw new IllegalArgumentException("Array element " + i + ", '" + object + "', is neither of type Map.Entry nor an Array"); [EOL]         } [EOL]     } [EOL]     return map; [EOL] } 
 [LINE] throw new IllegalArgumentException("Array element " + i + ", '" [LINE] public static Map<Object, Object> toMap(final Object[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     final Map<Object, Object> map = new HashMap<Object, Object>((int) (array.length * 1.5)); [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Object object = array[i]; [EOL]         if (object instanceof Map.Entry<?, ?>) { [EOL]             final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) object; [EOL]             map.put(entry.getKey(), entry.getValue()); [EOL]         } else if (object instanceof Object[]) { [EOL]             final Object[] entry = (Object[]) object; [EOL]             if (entry.length < 2) { [EOL]                 throw new IllegalArgumentException("Array element " + i + ", '" + object + "', has a length less than 2"); [EOL]             } [EOL]             map.put(entry[0], entry[1]); [EOL]         } else { [EOL]             throw new IllegalArgumentException("Array element " + i + ", '" + object + "', is neither of type Map.Entry nor an Array"); [EOL]         } [EOL]     } [EOL]     return map; [EOL] } 
 [LINE] return null; [LINE] public static boolean[] clone(final boolean[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     return array.clone(); [EOL] } 
 [LINE] return array; [LINE] public static Object[] nullToEmpty(final Object[] array) { [EOL]     if (array == null || array.length == 0) { [EOL]         return EMPTY_OBJECT_ARRAY; [EOL]     } [EOL]     return array; [EOL] } 
 [LINE] return EMPTY_STRING_ARRAY; [LINE] public static String[] nullToEmpty(final String[] array) { [EOL]     if (array == null || array.length == 0) { [EOL]         return EMPTY_STRING_ARRAY; [EOL]     } [EOL]     return array; [EOL] } 
 [LINE] return EMPTY_INT_ARRAY; [LINE] public static int[] nullToEmpty(final int[] array) { [EOL]     if (array == null || array.length == 0) { [EOL]         return EMPTY_INT_ARRAY; [EOL]     } [EOL]     return array; [EOL] } 
 [LINE] return EMPTY_BYTE_ARRAY; [LINE] public static byte[] nullToEmpty(final byte[] array) { [EOL]     if (array == null || array.length == 0) { [EOL]         return EMPTY_BYTE_ARRAY; [EOL]     } [EOL]     return array; [EOL] } 
 [LINE] return EMPTY_INTEGER_OBJECT_ARRAY; [LINE] public static Integer[] nullToEmpty(final Integer[] array) { [EOL]     if (array == null || array.length == 0) { [EOL]         return EMPTY_INTEGER_OBJECT_ARRAY; [EOL]     } [EOL]     return array; [EOL] } 
 [LINE] return EMPTY_BYTE_OBJECT_ARRAY; [LINE] public static Byte[] nullToEmpty(final Byte[] array) { [EOL]     if (array == null || array.length == 0) { [EOL]         return EMPTY_BYTE_OBJECT_ARRAY; [EOL]     } [EOL]     return array; [EOL] } 
 [LINE] return EMPTY_DOUBLE_OBJECT_ARRAY; [LINE] public static Double[] nullToEmpty(final Double[] array) { [EOL]     if (array == null || array.length == 0) { [EOL]         return EMPTY_DOUBLE_OBJECT_ARRAY; [EOL]     } [EOL]     return array; [EOL] } 
 [LINE] endIndexExclusive = array.length; [LINE] public static <T> T[] subarray(final T[] array, int startIndexInclusive, int endIndexExclusive) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (startIndexInclusive < 0) { [EOL]         startIndexInclusive = 0; [EOL]     } [EOL]     if (endIndexExclusive > array.length) { [EOL]         endIndexExclusive = array.length; [EOL]     } [EOL]     final int newSize = endIndexExclusive - startIndexInclusive; [EOL]     final Class<?> type = array.getClass().getComponentType(); [EOL]     if (newSize <= 0) { [EOL]         @SuppressWarnings("unchecked") [EOL]         final T[] emptyArray = (T[]) Array.newInstance(type, 0); [EOL]         return emptyArray; [EOL]     } [EOL]     @SuppressWarnings("unchecked") [EOL]     final T[] subarray = (T[]) Array.newInstance(type, newSize); [EOL]     System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [EOL]     return subarray; [EOL] } 
 [LINE] @SuppressWarnings("unchecked") // OK, because array is of type T [LINE] public static <T> T[] subarray(final T[] array, int startIndexInclusive, int endIndexExclusive) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (startIndexInclusive < 0) { [EOL]         startIndexInclusive = 0; [EOL]     } [EOL]     if (endIndexExclusive > array.length) { [EOL]         endIndexExclusive = array.length; [EOL]     } [EOL]     final int newSize = endIndexExclusive - startIndexInclusive; [EOL]     final Class<?> type = array.getClass().getComponentType(); [EOL]     if (newSize <= 0) { [EOL]         @SuppressWarnings("unchecked") [EOL]         final T[] emptyArray = (T[]) Array.newInstance(type, 0); [EOL]         return emptyArray; [EOL]     } [EOL]     @SuppressWarnings("unchecked") [EOL]     final T[] subarray = (T[]) Array.newInstance(type, newSize); [EOL]     System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [EOL]     return subarray; [EOL] } 
 [LINE] System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [LINE] public static <T> T[] subarray(final T[] array, int startIndexInclusive, int endIndexExclusive) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (startIndexInclusive < 0) { [EOL]         startIndexInclusive = 0; [EOL]     } [EOL]     if (endIndexExclusive > array.length) { [EOL]         endIndexExclusive = array.length; [EOL]     } [EOL]     final int newSize = endIndexExclusive - startIndexInclusive; [EOL]     final Class<?> type = array.getClass().getComponentType(); [EOL]     if (newSize <= 0) { [EOL]         @SuppressWarnings("unchecked") [EOL]         final T[] emptyArray = (T[]) Array.newInstance(type, 0); [EOL]         return emptyArray; [EOL]     } [EOL]     @SuppressWarnings("unchecked") [EOL]     final T[] subarray = (T[]) Array.newInstance(type, newSize); [EOL]     System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [EOL]     return subarray; [EOL] } 
 [LINE] return subarray; [LINE] public static <T> T[] subarray(final T[] array, int startIndexInclusive, int endIndexExclusive) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (startIndexInclusive < 0) { [EOL]         startIndexInclusive = 0; [EOL]     } [EOL]     if (endIndexExclusive > array.length) { [EOL]         endIndexExclusive = array.length; [EOL]     } [EOL]     final int newSize = endIndexExclusive - startIndexInclusive; [EOL]     final Class<?> type = array.getClass().getComponentType(); [EOL]     if (newSize <= 0) { [EOL]         @SuppressWarnings("unchecked") [EOL]         final T[] emptyArray = (T[]) Array.newInstance(type, 0); [EOL]         return emptyArray; [EOL]     } [EOL]     @SuppressWarnings("unchecked") [EOL]     final T[] subarray = (T[]) Array.newInstance(type, newSize); [EOL]     System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [EOL]     return subarray; [EOL] } 
 [LINE] startIndexInclusive = 0; [LINE] public static long[] subarray(final long[] array, int startIndexInclusive, int endIndexExclusive) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (startIndexInclusive < 0) { [EOL]         startIndexInclusive = 0; [EOL]     } [EOL]     if (endIndexExclusive > array.length) { [EOL]         endIndexExclusive = array.length; [EOL]     } [EOL]     final int newSize = endIndexExclusive - startIndexInclusive; [EOL]     if (newSize <= 0) { [EOL]         return EMPTY_LONG_ARRAY; [EOL]     } [EOL]     final long[] subarray = new long[newSize]; [EOL]     System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [EOL]     return subarray; [EOL] } 
 [LINE] final long[] subarray = new long[newSize]; [LINE] public static long[] subarray(final long[] array, int startIndexInclusive, int endIndexExclusive) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (startIndexInclusive < 0) { [EOL]         startIndexInclusive = 0; [EOL]     } [EOL]     if (endIndexExclusive > array.length) { [EOL]         endIndexExclusive = array.length; [EOL]     } [EOL]     final int newSize = endIndexExclusive - startIndexInclusive; [EOL]     if (newSize <= 0) { [EOL]         return EMPTY_LONG_ARRAY; [EOL]     } [EOL]     final long[] subarray = new long[newSize]; [EOL]     System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [EOL]     return subarray; [EOL] } 
 [LINE] System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [LINE] public static long[] subarray(final long[] array, int startIndexInclusive, int endIndexExclusive) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (startIndexInclusive < 0) { [EOL]         startIndexInclusive = 0; [EOL]     } [EOL]     if (endIndexExclusive > array.length) { [EOL]         endIndexExclusive = array.length; [EOL]     } [EOL]     final int newSize = endIndexExclusive - startIndexInclusive; [EOL]     if (newSize <= 0) { [EOL]         return EMPTY_LONG_ARRAY; [EOL]     } [EOL]     final long[] subarray = new long[newSize]; [EOL]     System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [EOL]     return subarray; [EOL] } 
 [LINE] return subarray; [LINE] public static long[] subarray(final long[] array, int startIndexInclusive, int endIndexExclusive) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (startIndexInclusive < 0) { [EOL]         startIndexInclusive = 0; [EOL]     } [EOL]     if (endIndexExclusive > array.length) { [EOL]         endIndexExclusive = array.length; [EOL]     } [EOL]     final int newSize = endIndexExclusive - startIndexInclusive; [EOL]     if (newSize <= 0) { [EOL]         return EMPTY_LONG_ARRAY; [EOL]     } [EOL]     final long[] subarray = new long[newSize]; [EOL]     System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [EOL]     return subarray; [EOL] } 
 [LINE] final short[] subarray = new short[newSize]; [LINE] public static short[] subarray(final short[] array, int startIndexInclusive, int endIndexExclusive) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (startIndexInclusive < 0) { [EOL]         startIndexInclusive = 0; [EOL]     } [EOL]     if (endIndexExclusive > array.length) { [EOL]         endIndexExclusive = array.length; [EOL]     } [EOL]     final int newSize = endIndexExclusive - startIndexInclusive; [EOL]     if (newSize <= 0) { [EOL]         return EMPTY_SHORT_ARRAY; [EOL]     } [EOL]     final short[] subarray = new short[newSize]; [EOL]     System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [EOL]     return subarray; [EOL] } 
 [LINE] System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [LINE] public static short[] subarray(final short[] array, int startIndexInclusive, int endIndexExclusive) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (startIndexInclusive < 0) { [EOL]         startIndexInclusive = 0; [EOL]     } [EOL]     if (endIndexExclusive > array.length) { [EOL]         endIndexExclusive = array.length; [EOL]     } [EOL]     final int newSize = endIndexExclusive - startIndexInclusive; [EOL]     if (newSize <= 0) { [EOL]         return EMPTY_SHORT_ARRAY; [EOL]     } [EOL]     final short[] subarray = new short[newSize]; [EOL]     System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [EOL]     return subarray; [EOL] } 
 [LINE] return subarray; [LINE] public static short[] subarray(final short[] array, int startIndexInclusive, int endIndexExclusive) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (startIndexInclusive < 0) { [EOL]         startIndexInclusive = 0; [EOL]     } [EOL]     if (endIndexExclusive > array.length) { [EOL]         endIndexExclusive = array.length; [EOL]     } [EOL]     final int newSize = endIndexExclusive - startIndexInclusive; [EOL]     if (newSize <= 0) { [EOL]         return EMPTY_SHORT_ARRAY; [EOL]     } [EOL]     final short[] subarray = new short[newSize]; [EOL]     System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [EOL]     return subarray; [EOL] } 
 [LINE] return null; [LINE] public static char[] subarray(final char[] array, int startIndexInclusive, int endIndexExclusive) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (startIndexInclusive < 0) { [EOL]         startIndexInclusive = 0; [EOL]     } [EOL]     if (endIndexExclusive > array.length) { [EOL]         endIndexExclusive = array.length; [EOL]     } [EOL]     final int newSize = endIndexExclusive - startIndexInclusive; [EOL]     if (newSize <= 0) { [EOL]         return EMPTY_CHAR_ARRAY; [EOL]     } [EOL]     final char[] subarray = new char[newSize]; [EOL]     System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [EOL]     return subarray; [EOL] } 
 [LINE] endIndexExclusive = array.length; [LINE] public static char[] subarray(final char[] array, int startIndexInclusive, int endIndexExclusive) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (startIndexInclusive < 0) { [EOL]         startIndexInclusive = 0; [EOL]     } [EOL]     if (endIndexExclusive > array.length) { [EOL]         endIndexExclusive = array.length; [EOL]     } [EOL]     final int newSize = endIndexExclusive - startIndexInclusive; [EOL]     if (newSize <= 0) { [EOL]         return EMPTY_CHAR_ARRAY; [EOL]     } [EOL]     final char[] subarray = new char[newSize]; [EOL]     System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [EOL]     return subarray; [EOL] } 
 [LINE] final char[] subarray = new char[newSize]; [LINE] public static char[] subarray(final char[] array, int startIndexInclusive, int endIndexExclusive) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (startIndexInclusive < 0) { [EOL]         startIndexInclusive = 0; [EOL]     } [EOL]     if (endIndexExclusive > array.length) { [EOL]         endIndexExclusive = array.length; [EOL]     } [EOL]     final int newSize = endIndexExclusive - startIndexInclusive; [EOL]     if (newSize <= 0) { [EOL]         return EMPTY_CHAR_ARRAY; [EOL]     } [EOL]     final char[] subarray = new char[newSize]; [EOL]     System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [EOL]     return subarray; [EOL] } 
 [LINE] System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [LINE] public static char[] subarray(final char[] array, int startIndexInclusive, int endIndexExclusive) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (startIndexInclusive < 0) { [EOL]         startIndexInclusive = 0; [EOL]     } [EOL]     if (endIndexExclusive > array.length) { [EOL]         endIndexExclusive = array.length; [EOL]     } [EOL]     final int newSize = endIndexExclusive - startIndexInclusive; [EOL]     if (newSize <= 0) { [EOL]         return EMPTY_CHAR_ARRAY; [EOL]     } [EOL]     final char[] subarray = new char[newSize]; [EOL]     System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [EOL]     return subarray; [EOL] } 
 [LINE] return subarray; [LINE] public static char[] subarray(final char[] array, int startIndexInclusive, int endIndexExclusive) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (startIndexInclusive < 0) { [EOL]         startIndexInclusive = 0; [EOL]     } [EOL]     if (endIndexExclusive > array.length) { [EOL]         endIndexExclusive = array.length; [EOL]     } [EOL]     final int newSize = endIndexExclusive - startIndexInclusive; [EOL]     if (newSize <= 0) { [EOL]         return EMPTY_CHAR_ARRAY; [EOL]     } [EOL]     final char[] subarray = new char[newSize]; [EOL]     System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [EOL]     return subarray; [EOL] } 
 [LINE] endIndexExclusive = array.length; [LINE] public static byte[] subarray(final byte[] array, int startIndexInclusive, int endIndexExclusive) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (startIndexInclusive < 0) { [EOL]         startIndexInclusive = 0; [EOL]     } [EOL]     if (endIndexExclusive > array.length) { [EOL]         endIndexExclusive = array.length; [EOL]     } [EOL]     final int newSize = endIndexExclusive - startIndexInclusive; [EOL]     if (newSize <= 0) { [EOL]         return EMPTY_BYTE_ARRAY; [EOL]     } [EOL]     final byte[] subarray = new byte[newSize]; [EOL]     System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [EOL]     return subarray; [EOL] } 
 [LINE] final byte[] subarray = new byte[newSize]; [LINE] public static byte[] subarray(final byte[] array, int startIndexInclusive, int endIndexExclusive) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (startIndexInclusive < 0) { [EOL]         startIndexInclusive = 0; [EOL]     } [EOL]     if (endIndexExclusive > array.length) { [EOL]         endIndexExclusive = array.length; [EOL]     } [EOL]     final int newSize = endIndexExclusive - startIndexInclusive; [EOL]     if (newSize <= 0) { [EOL]         return EMPTY_BYTE_ARRAY; [EOL]     } [EOL]     final byte[] subarray = new byte[newSize]; [EOL]     System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [EOL]     return subarray; [EOL] } 
 [LINE] System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [LINE] public static byte[] subarray(final byte[] array, int startIndexInclusive, int endIndexExclusive) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (startIndexInclusive < 0) { [EOL]         startIndexInclusive = 0; [EOL]     } [EOL]     if (endIndexExclusive > array.length) { [EOL]         endIndexExclusive = array.length; [EOL]     } [EOL]     final int newSize = endIndexExclusive - startIndexInclusive; [EOL]     if (newSize <= 0) { [EOL]         return EMPTY_BYTE_ARRAY; [EOL]     } [EOL]     final byte[] subarray = new byte[newSize]; [EOL]     System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [EOL]     return subarray; [EOL] } 
 [LINE] return subarray; [LINE] public static byte[] subarray(final byte[] array, int startIndexInclusive, int endIndexExclusive) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (startIndexInclusive < 0) { [EOL]         startIndexInclusive = 0; [EOL]     } [EOL]     if (endIndexExclusive > array.length) { [EOL]         endIndexExclusive = array.length; [EOL]     } [EOL]     final int newSize = endIndexExclusive - startIndexInclusive; [EOL]     if (newSize <= 0) { [EOL]         return EMPTY_BYTE_ARRAY; [EOL]     } [EOL]     final byte[] subarray = new byte[newSize]; [EOL]     System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [EOL]     return subarray; [EOL] } 
 [LINE] endIndexExclusive = array.length; [LINE] public static float[] subarray(final float[] array, int startIndexInclusive, int endIndexExclusive) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (startIndexInclusive < 0) { [EOL]         startIndexInclusive = 0; [EOL]     } [EOL]     if (endIndexExclusive > array.length) { [EOL]         endIndexExclusive = array.length; [EOL]     } [EOL]     final int newSize = endIndexExclusive - startIndexInclusive; [EOL]     if (newSize <= 0) { [EOL]         return EMPTY_FLOAT_ARRAY; [EOL]     } [EOL]     final float[] subarray = new float[newSize]; [EOL]     System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [EOL]     return subarray; [EOL] } 
 [LINE] return null; [LINE] public static boolean[] subarray(final boolean[] array, int startIndexInclusive, int endIndexExclusive) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (startIndexInclusive < 0) { [EOL]         startIndexInclusive = 0; [EOL]     } [EOL]     if (endIndexExclusive > array.length) { [EOL]         endIndexExclusive = array.length; [EOL]     } [EOL]     final int newSize = endIndexExclusive - startIndexInclusive; [EOL]     if (newSize <= 0) { [EOL]         return EMPTY_BOOLEAN_ARRAY; [EOL]     } [EOL]     final boolean[] subarray = new boolean[newSize]; [EOL]     System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [EOL]     return subarray; [EOL] } 
 [LINE] endIndexExclusive = array.length; [LINE] public static boolean[] subarray(final boolean[] array, int startIndexInclusive, int endIndexExclusive) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (startIndexInclusive < 0) { [EOL]         startIndexInclusive = 0; [EOL]     } [EOL]     if (endIndexExclusive > array.length) { [EOL]         endIndexExclusive = array.length; [EOL]     } [EOL]     final int newSize = endIndexExclusive - startIndexInclusive; [EOL]     if (newSize <= 0) { [EOL]         return EMPTY_BOOLEAN_ARRAY; [EOL]     } [EOL]     final boolean[] subarray = new boolean[newSize]; [EOL]     System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [EOL]     return subarray; [EOL] } 
 [LINE] final boolean[] subarray = new boolean[newSize]; [LINE] public static boolean[] subarray(final boolean[] array, int startIndexInclusive, int endIndexExclusive) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (startIndexInclusive < 0) { [EOL]         startIndexInclusive = 0; [EOL]     } [EOL]     if (endIndexExclusive > array.length) { [EOL]         endIndexExclusive = array.length; [EOL]     } [EOL]     final int newSize = endIndexExclusive - startIndexInclusive; [EOL]     if (newSize <= 0) { [EOL]         return EMPTY_BOOLEAN_ARRAY; [EOL]     } [EOL]     final boolean[] subarray = new boolean[newSize]; [EOL]     System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [EOL]     return subarray; [EOL] } 
 [LINE] System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [LINE] public static boolean[] subarray(final boolean[] array, int startIndexInclusive, int endIndexExclusive) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (startIndexInclusive < 0) { [EOL]         startIndexInclusive = 0; [EOL]     } [EOL]     if (endIndexExclusive > array.length) { [EOL]         endIndexExclusive = array.length; [EOL]     } [EOL]     final int newSize = endIndexExclusive - startIndexInclusive; [EOL]     if (newSize <= 0) { [EOL]         return EMPTY_BOOLEAN_ARRAY; [EOL]     } [EOL]     final boolean[] subarray = new boolean[newSize]; [EOL]     System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [EOL]     return subarray; [EOL] } 
 [LINE] return subarray; [LINE] public static boolean[] subarray(final boolean[] array, int startIndexInclusive, int endIndexExclusive) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (startIndexInclusive < 0) { [EOL]         startIndexInclusive = 0; [EOL]     } [EOL]     if (endIndexExclusive > array.length) { [EOL]         endIndexExclusive = array.length; [EOL]     } [EOL]     final int newSize = endIndexExclusive - startIndexInclusive; [EOL]     if (newSize <= 0) { [EOL]         return EMPTY_BOOLEAN_ARRAY; [EOL]     } [EOL]     final boolean[] subarray = new boolean[newSize]; [EOL]     System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [EOL]     return subarray; [EOL] } 
 [LINE] return false; [LINE] public static boolean isSameLength(final int[] array1, final int[] array2) { [EOL]     if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] return false; [LINE] public static boolean isSameLength(final short[] array1, final short[] array2) { [EOL]     if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] return false; [LINE] public static boolean isSameLength(final byte[] array1, final byte[] array2) { [EOL]     if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] return false; [LINE] public static boolean isSameLength(final double[] array1, final double[] array2) { [EOL]     if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] return false; [LINE] public static boolean isSameLength(final float[] array1, final float[] array2) { [EOL]     if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] return false; [LINE] public static boolean isSameLength(final boolean[] array1, final boolean[] array2) { [EOL]     if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] return; [LINE] public static void reverse(final Object[] array) { [EOL]     if (array == null) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     int j = array.length - 1; [EOL]     Object tmp; [EOL]     while (j > i) { [EOL]         tmp = array[j]; [EOL]         array[j] = array[i]; [EOL]         array[i] = tmp; [EOL]         j--; [EOL]         i++; [EOL]     } [EOL] } 
 [LINE] return; [LINE] public static void reverse(final long[] array) { [EOL]     if (array == null) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     int j = array.length - 1; [EOL]     long tmp; [EOL]     while (j > i) { [EOL]         tmp = array[j]; [EOL]         array[j] = array[i]; [EOL]         array[i] = tmp; [EOL]         j--; [EOL]         i++; [EOL]     } [EOL] } 
 [LINE] return; [LINE] public static void reverse(final char[] array) { [EOL]     if (array == null) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     int j = array.length - 1; [EOL]     char tmp; [EOL]     while (j > i) { [EOL]         tmp = array[j]; [EOL]         array[j] = array[i]; [EOL]         array[i] = tmp; [EOL]         j--; [EOL]         i++; [EOL]     } [EOL] } 
 [LINE] return; [LINE] public static void reverse(final byte[] array) { [EOL]     if (array == null) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     int j = array.length - 1; [EOL]     byte tmp; [EOL]     while (j > i) { [EOL]         tmp = array[j]; [EOL]         array[j] = array[i]; [EOL]         array[i] = tmp; [EOL]         j--; [EOL]         i++; [EOL]     } [EOL] } 
 [LINE] return; [LINE] public static void reverse(final boolean[] array) { [EOL]     if (array == null) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     int j = array.length - 1; [EOL]     boolean tmp; [EOL]     while (j > i) { [EOL]         tmp = array[j]; [EOL]         array[j] = array[i]; [EOL]         array[i] = tmp; [EOL]         j--; [EOL]         i++; [EOL]     } [EOL] } 
 [LINE] return INDEX_NOT_FOUND; [LINE] public static int lastIndexOf(final Object[] array, final Object objectToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     if (objectToFind == null) { [EOL]         for (int i = startIndex; i >= 0; i--) { [EOL]             if (array[i] == null) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } else if (array.getClass().getComponentType().isInstance(objectToFind)) { [EOL]         for (int i = startIndex; i >= 0; i--) { [EOL]             if (objectToFind.equals(array[i])) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] } 
 [LINE] return INDEX_NOT_FOUND; [LINE] public static int lastIndexOf(final long[] array, final long valueToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] } 
 [LINE] return INDEX_NOT_FOUND; [LINE] public static int lastIndexOf(final long[] array, final long valueToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] } 
 [LINE] startIndex = 0; [LINE] public static int indexOf(final short[] array, final short valueToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] } 
 [LINE] return INDEX_NOT_FOUND; [LINE] public static int indexOf(final char[] array, final char valueToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] } 
 [LINE] return INDEX_NOT_FOUND; [LINE] public static int lastIndexOf(final char[] array, final char valueToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] } 
 [LINE] return INDEX_NOT_FOUND; [LINE] public static int indexOf(final byte[] array, final byte valueToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] } 
 [LINE] return i; [LINE] public static int lastIndexOf(final float[] array, final float valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] } 
 [LINE] return EMPTY_CHAR_ARRAY; [LINE] public static char[] toPrimitive(final Character[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_CHAR_ARRAY; [EOL]     } [EOL]     final char[] result = new char[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = array[i].charValue(); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] return EMPTY_CHAR_ARRAY; [LINE] public static char[] toPrimitive(final Character[] array, final char valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_CHAR_ARRAY; [EOL]     } [EOL]     final char[] result = new char[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Character b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.charValue()); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] return null; [LINE] public static Character[] toObject(final char[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_CHARACTER_OBJECT_ARRAY; [EOL]     } [EOL]     final Character[] result = new Character[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = Character.valueOf(array[i]); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] return null; [LINE] public static long[] toPrimitive(final Long[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_LONG_ARRAY; [EOL]     } [EOL]     final long[] result = new long[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = array[i].longValue(); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] return EMPTY_LONG_ARRAY; [LINE] public static long[] toPrimitive(final Long[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_LONG_ARRAY; [EOL]     } [EOL]     final long[] result = new long[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = array[i].longValue(); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] return null; [LINE] public static long[] toPrimitive(final Long[] array, final long valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_LONG_ARRAY; [EOL]     } [EOL]     final long[] result = new long[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Long b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.longValue()); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] return EMPTY_LONG_ARRAY; [LINE] public static long[] toPrimitive(final Long[] array, final long valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_LONG_ARRAY; [EOL]     } [EOL]     final long[] result = new long[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Long b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.longValue()); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] return null; [LINE] public static Long[] toObject(final long[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_LONG_OBJECT_ARRAY; [EOL]     } [EOL]     final Long[] result = new Long[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = Long.valueOf(array[i]); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] return EMPTY_INT_ARRAY; [LINE] public static int[] toPrimitive(final Integer[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_INT_ARRAY; [EOL]     } [EOL]     final int[] result = new int[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = array[i].intValue(); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] public static int[] toPrimitive(final Integer[] array, final int valueForNull) { [LINE] public static int[] toPrimitive(final Integer[] array, final int valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_INT_ARRAY; [EOL]     } [EOL]     final int[] result = new int[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Integer b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.intValue()); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] if (array == null) { [LINE] public static int[] toPrimitive(final Integer[] array, final int valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_INT_ARRAY; [EOL]     } [EOL]     final int[] result = new int[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Integer b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.intValue()); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] return null; [LINE] public static int[] toPrimitive(final Integer[] array, final int valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_INT_ARRAY; [EOL]     } [EOL]     final int[] result = new int[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Integer b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.intValue()); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] } else if (array.length == 0) { [LINE] public static int[] toPrimitive(final Integer[] array, final int valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_INT_ARRAY; [EOL]     } [EOL]     final int[] result = new int[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Integer b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.intValue()); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] return EMPTY_INT_ARRAY; [LINE] public static int[] toPrimitive(final Integer[] array, final int valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_INT_ARRAY; [EOL]     } [EOL]     final int[] result = new int[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Integer b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.intValue()); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] final int[] result = new int[array.length]; [LINE] public static int[] toPrimitive(final Integer[] array, final int valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_INT_ARRAY; [EOL]     } [EOL]     final int[] result = new int[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Integer b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.intValue()); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] for (int i = 0; i < array.length; i++) { [LINE] public static int[] toPrimitive(final Integer[] array, final int valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_INT_ARRAY; [EOL]     } [EOL]     final int[] result = new int[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Integer b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.intValue()); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] final Integer b = array[i]; [LINE] public static int[] toPrimitive(final Integer[] array, final int valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_INT_ARRAY; [EOL]     } [EOL]     final int[] result = new int[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Integer b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.intValue()); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] result[i] = (b == null ? valueForNull : b.intValue()); [LINE] public static int[] toPrimitive(final Integer[] array, final int valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_INT_ARRAY; [EOL]     } [EOL]     final int[] result = new int[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Integer b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.intValue()); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] return result; [LINE] public static int[] toPrimitive(final Integer[] array, final int valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_INT_ARRAY; [EOL]     } [EOL]     final int[] result = new int[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Integer b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.intValue()); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] return null; [LINE] public static Integer[] toObject(final int[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_INTEGER_OBJECT_ARRAY; [EOL]     } [EOL]     final Integer[] result = new Integer[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = Integer.valueOf(array[i]); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] return EMPTY_INTEGER_OBJECT_ARRAY; [LINE] public static Integer[] toObject(final int[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_INTEGER_OBJECT_ARRAY; [EOL]     } [EOL]     final Integer[] result = new Integer[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = Integer.valueOf(array[i]); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] return null; [LINE] public static short[] toPrimitive(final Short[] array, final short valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_SHORT_ARRAY; [EOL]     } [EOL]     final short[] result = new short[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Short b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.shortValue()); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] return EMPTY_SHORT_ARRAY; [LINE] public static short[] toPrimitive(final Short[] array, final short valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_SHORT_ARRAY; [EOL]     } [EOL]     final short[] result = new short[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Short b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.shortValue()); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] return EMPTY_BYTE_ARRAY; [LINE] public static byte[] toPrimitive(final Byte[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_BYTE_ARRAY; [EOL]     } [EOL]     final byte[] result = new byte[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = array[i].byteValue(); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] return null; [LINE] public static byte[] toPrimitive(final Byte[] array, final byte valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_BYTE_ARRAY; [EOL]     } [EOL]     final byte[] result = new byte[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Byte b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.byteValue()); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] return null; [LINE] public static Byte[] toObject(final byte[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_BYTE_OBJECT_ARRAY; [EOL]     } [EOL]     final Byte[] result = new Byte[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = Byte.valueOf(array[i]); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] return EMPTY_BYTE_OBJECT_ARRAY; [LINE] public static Byte[] toObject(final byte[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_BYTE_OBJECT_ARRAY; [EOL]     } [EOL]     final Byte[] result = new Byte[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = Byte.valueOf(array[i]); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] return EMPTY_DOUBLE_ARRAY; [LINE] public static double[] toPrimitive(final Double[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_DOUBLE_ARRAY; [EOL]     } [EOL]     final double[] result = new double[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = array[i].doubleValue(); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] return null; [LINE] public static double[] toPrimitive(final Double[] array, final double valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_DOUBLE_ARRAY; [EOL]     } [EOL]     final double[] result = new double[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Double b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.doubleValue()); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] return null; [LINE] public static Double[] toObject(final double[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_DOUBLE_OBJECT_ARRAY; [EOL]     } [EOL]     final Double[] result = new Double[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = Double.valueOf(array[i]); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] return EMPTY_DOUBLE_OBJECT_ARRAY; [LINE] public static Double[] toObject(final double[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_DOUBLE_OBJECT_ARRAY; [EOL]     } [EOL]     final Double[] result = new Double[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = Double.valueOf(array[i]); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] return null; [LINE] public static float[] toPrimitive(final Float[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_FLOAT_ARRAY; [EOL]     } [EOL]     final float[] result = new float[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = array[i].floatValue(); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] final float[] result = new float[array.length]; [LINE] public static float[] toPrimitive(final Float[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_FLOAT_ARRAY; [EOL]     } [EOL]     final float[] result = new float[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = array[i].floatValue(); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] for (int i = 0; i < array.length; i++) { [LINE] public static float[] toPrimitive(final Float[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_FLOAT_ARRAY; [EOL]     } [EOL]     final float[] result = new float[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = array[i].floatValue(); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] result[i] = array[i].floatValue(); [LINE] public static float[] toPrimitive(final Float[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_FLOAT_ARRAY; [EOL]     } [EOL]     final float[] result = new float[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = array[i].floatValue(); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] return result; [LINE] public static float[] toPrimitive(final Float[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_FLOAT_ARRAY; [EOL]     } [EOL]     final float[] result = new float[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = array[i].floatValue(); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] return null; [LINE] public static float[] toPrimitive(final Float[] array, final float valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_FLOAT_ARRAY; [EOL]     } [EOL]     final float[] result = new float[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Float b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.floatValue()); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] return EMPTY_FLOAT_ARRAY; [LINE] public static float[] toPrimitive(final Float[] array, final float valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_FLOAT_ARRAY; [EOL]     } [EOL]     final float[] result = new float[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Float b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.floatValue()); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] return null; [LINE] public static Float[] toObject(final float[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_FLOAT_OBJECT_ARRAY; [EOL]     } [EOL]     final Float[] result = new Float[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = Float.valueOf(array[i]); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] return EMPTY_FLOAT_OBJECT_ARRAY; [LINE] public static Float[] toObject(final float[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_FLOAT_OBJECT_ARRAY; [EOL]     } [EOL]     final Float[] result = new Float[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = Float.valueOf(array[i]); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] return null; [LINE] public static boolean[] toPrimitive(final Boolean[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_BOOLEAN_ARRAY; [EOL]     } [EOL]     final boolean[] result = new boolean[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = array[i].booleanValue(); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] return null; [LINE] public static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_BOOLEAN_ARRAY; [EOL]     } [EOL]     final boolean[] result = new boolean[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Boolean b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.booleanValue()); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] return EMPTY_BOOLEAN_ARRAY; [LINE] public static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_BOOLEAN_ARRAY; [EOL]     } [EOL]     final boolean[] result = new boolean[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Boolean b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.booleanValue()); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] return null; [LINE] public static Boolean[] toObject(final boolean[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_BOOLEAN_OBJECT_ARRAY; [EOL]     } [EOL]     final Boolean[] result = new Boolean[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = (array[i] ? Boolean.TRUE : Boolean.FALSE); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] return clone(array1); [LINE] public static <T> T[] addAll(final T[] array1, final T... array2) { [EOL]     if (array1 == null) { [EOL]         return clone(array2); [EOL]     } else if (array2 == null) { [EOL]         return clone(array1); [EOL]     } [EOL]     final Class<?> type1 = array1.getClass().getComponentType(); [EOL]     @SuppressWarnings("unchecked") [EOL]     final T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length); [EOL]     System.arraycopy(array1, 0, joinedArray, 0, array1.length); [EOL]     try { [EOL]         System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); [EOL]     } catch (final ArrayStoreException ase) { [EOL]         final Class<?> type2 = array2.getClass().getComponentType(); [EOL]         if (!type1.isAssignableFrom(type2)) { [EOL]             throw new IllegalArgumentException("Cannot store " + type2.getName() + " in an array of " + type1.getName(), ase); [EOL]         } [EOL]         throw ase; [EOL]     } [EOL]     return joinedArray; [EOL] } 
 [LINE] final Class<?> type2 = array2.getClass().getComponentType(); [LINE] public static <T> T[] addAll(final T[] array1, final T... array2) { [EOL]     if (array1 == null) { [EOL]         return clone(array2); [EOL]     } else if (array2 == null) { [EOL]         return clone(array1); [EOL]     } [EOL]     final Class<?> type1 = array1.getClass().getComponentType(); [EOL]     @SuppressWarnings("unchecked") [EOL]     final T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length); [EOL]     System.arraycopy(array1, 0, joinedArray, 0, array1.length); [EOL]     try { [EOL]         System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); [EOL]     } catch (final ArrayStoreException ase) { [EOL]         final Class<?> type2 = array2.getClass().getComponentType(); [EOL]         if (!type1.isAssignableFrom(type2)) { [EOL]             throw new IllegalArgumentException("Cannot store " + type2.getName() + " in an array of " + type1.getName(), ase); [EOL]         } [EOL]         throw ase; [EOL]     } [EOL]     return joinedArray; [EOL] } 
 [LINE] if (!type1.isAssignableFrom(type2)){ [LINE] public static <T> T[] addAll(final T[] array1, final T... array2) { [EOL]     if (array1 == null) { [EOL]         return clone(array2); [EOL]     } else if (array2 == null) { [EOL]         return clone(array1); [EOL]     } [EOL]     final Class<?> type1 = array1.getClass().getComponentType(); [EOL]     @SuppressWarnings("unchecked") [EOL]     final T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length); [EOL]     System.arraycopy(array1, 0, joinedArray, 0, array1.length); [EOL]     try { [EOL]         System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); [EOL]     } catch (final ArrayStoreException ase) { [EOL]         final Class<?> type2 = array2.getClass().getComponentType(); [EOL]         if (!type1.isAssignableFrom(type2)) { [EOL]             throw new IllegalArgumentException("Cannot store " + type2.getName() + " in an array of " + type1.getName(), ase); [EOL]         } [EOL]         throw ase; [EOL]     } [EOL]     return joinedArray; [EOL] } 
 [LINE] throw new IllegalArgumentException("Cannot store "+type2.getName()+" in an array of " [LINE] public static <T> T[] addAll(final T[] array1, final T... array2) { [EOL]     if (array1 == null) { [EOL]         return clone(array2); [EOL]     } else if (array2 == null) { [EOL]         return clone(array1); [EOL]     } [EOL]     final Class<?> type1 = array1.getClass().getComponentType(); [EOL]     @SuppressWarnings("unchecked") [EOL]     final T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length); [EOL]     System.arraycopy(array1, 0, joinedArray, 0, array1.length); [EOL]     try { [EOL]         System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); [EOL]     } catch (final ArrayStoreException ase) { [EOL]         final Class<?> type2 = array2.getClass().getComponentType(); [EOL]         if (!type1.isAssignableFrom(type2)) { [EOL]             throw new IllegalArgumentException("Cannot store " + type2.getName() + " in an array of " + type1.getName(), ase); [EOL]         } [EOL]         throw ase; [EOL]     } [EOL]     return joinedArray; [EOL] } 
 [LINE] return clone(array2); [LINE] public static boolean[] addAll(final boolean[] array1, final boolean... array2) { [EOL]     if (array1 == null) { [EOL]         return clone(array2); [EOL]     } else if (array2 == null) { [EOL]         return clone(array1); [EOL]     } [EOL]     final boolean[] joinedArray = new boolean[array1.length + array2.length]; [EOL]     System.arraycopy(array1, 0, joinedArray, 0, array1.length); [EOL]     System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); [EOL]     return joinedArray; [EOL] } 
 [LINE] return clone(array1); [LINE] public static boolean[] addAll(final boolean[] array1, final boolean... array2) { [EOL]     if (array1 == null) { [EOL]         return clone(array2); [EOL]     } else if (array2 == null) { [EOL]         return clone(array1); [EOL]     } [EOL]     final boolean[] joinedArray = new boolean[array1.length + array2.length]; [EOL]     System.arraycopy(array1, 0, joinedArray, 0, array1.length); [EOL]     System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); [EOL]     return joinedArray; [EOL] } 
 [LINE] return clone(array2); [LINE] public static char[] addAll(final char[] array1, final char... array2) { [EOL]     if (array1 == null) { [EOL]         return clone(array2); [EOL]     } else if (array2 == null) { [EOL]         return clone(array1); [EOL]     } [EOL]     final char[] joinedArray = new char[array1.length + array2.length]; [EOL]     System.arraycopy(array1, 0, joinedArray, 0, array1.length); [EOL]     System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); [EOL]     return joinedArray; [EOL] } 
 [LINE] return clone(array1); [LINE] public static char[] addAll(final char[] array1, final char... array2) { [EOL]     if (array1 == null) { [EOL]         return clone(array2); [EOL]     } else if (array2 == null) { [EOL]         return clone(array1); [EOL]     } [EOL]     final char[] joinedArray = new char[array1.length + array2.length]; [EOL]     System.arraycopy(array1, 0, joinedArray, 0, array1.length); [EOL]     System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); [EOL]     return joinedArray; [EOL] } 
 [LINE] return clone(array2); [LINE] public static byte[] addAll(final byte[] array1, final byte... array2) { [EOL]     if (array1 == null) { [EOL]         return clone(array2); [EOL]     } else if (array2 == null) { [EOL]         return clone(array1); [EOL]     } [EOL]     final byte[] joinedArray = new byte[array1.length + array2.length]; [EOL]     System.arraycopy(array1, 0, joinedArray, 0, array1.length); [EOL]     System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); [EOL]     return joinedArray; [EOL] } 
 [LINE] return clone(array1); [LINE] public static byte[] addAll(final byte[] array1, final byte... array2) { [EOL]     if (array1 == null) { [EOL]         return clone(array2); [EOL]     } else if (array2 == null) { [EOL]         return clone(array1); [EOL]     } [EOL]     final byte[] joinedArray = new byte[array1.length + array2.length]; [EOL]     System.arraycopy(array1, 0, joinedArray, 0, array1.length); [EOL]     System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); [EOL]     return joinedArray; [EOL] } 
 [LINE] return clone(array1); [LINE] public static short[] addAll(final short[] array1, final short... array2) { [EOL]     if (array1 == null) { [EOL]         return clone(array2); [EOL]     } else if (array2 == null) { [EOL]         return clone(array1); [EOL]     } [EOL]     final short[] joinedArray = new short[array1.length + array2.length]; [EOL]     System.arraycopy(array1, 0, joinedArray, 0, array1.length); [EOL]     System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); [EOL]     return joinedArray; [EOL] } 
 [LINE] return clone(array1); [LINE] public static int[] addAll(final int[] array1, final int... array2) { [EOL]     if (array1 == null) { [EOL]         return clone(array2); [EOL]     } else if (array2 == null) { [EOL]         return clone(array1); [EOL]     } [EOL]     final int[] joinedArray = new int[array1.length + array2.length]; [EOL]     System.arraycopy(array1, 0, joinedArray, 0, array1.length); [EOL]     System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); [EOL]     return joinedArray; [EOL] } 
 [LINE] return clone(array2); [LINE] public static long[] addAll(final long[] array1, final long... array2) { [EOL]     if (array1 == null) { [EOL]         return clone(array2); [EOL]     } else if (array2 == null) { [EOL]         return clone(array1); [EOL]     } [EOL]     final long[] joinedArray = new long[array1.length + array2.length]; [EOL]     System.arraycopy(array1, 0, joinedArray, 0, array1.length); [EOL]     System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); [EOL]     return joinedArray; [EOL] } 
 [LINE] return clone(array1); [LINE] public static long[] addAll(final long[] array1, final long... array2) { [EOL]     if (array1 == null) { [EOL]         return clone(array2); [EOL]     } else if (array2 == null) { [EOL]         return clone(array1); [EOL]     } [EOL]     final long[] joinedArray = new long[array1.length + array2.length]; [EOL]     System.arraycopy(array1, 0, joinedArray, 0, array1.length); [EOL]     System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); [EOL]     return joinedArray; [EOL] } 
 [LINE] return clone(array2); [LINE] public static float[] addAll(final float[] array1, final float... array2) { [EOL]     if (array1 == null) { [EOL]         return clone(array2); [EOL]     } else if (array2 == null) { [EOL]         return clone(array1); [EOL]     } [EOL]     final float[] joinedArray = new float[array1.length + array2.length]; [EOL]     System.arraycopy(array1, 0, joinedArray, 0, array1.length); [EOL]     System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); [EOL]     return joinedArray; [EOL] } 
 [LINE] return clone(array1); [LINE] public static float[] addAll(final float[] array1, final float... array2) { [EOL]     if (array1 == null) { [EOL]         return clone(array2); [EOL]     } else if (array2 == null) { [EOL]         return clone(array1); [EOL]     } [EOL]     final float[] joinedArray = new float[array1.length + array2.length]; [EOL]     System.arraycopy(array1, 0, joinedArray, 0, array1.length); [EOL]     System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); [EOL]     return joinedArray; [EOL] } 
 [LINE] return clone(array2); [LINE] public static double[] addAll(final double[] array1, final double... array2) { [EOL]     if (array1 == null) { [EOL]         return clone(array2); [EOL]     } else if (array2 == null) { [EOL]         return clone(array1); [EOL]     } [EOL]     final double[] joinedArray = new double[array1.length + array2.length]; [EOL]     System.arraycopy(array1, 0, joinedArray, 0, array1.length); [EOL]     System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); [EOL]     return joinedArray; [EOL] } 
 [LINE] return clone(array1); [LINE] public static double[] addAll(final double[] array1, final double... array2) { [EOL]     if (array1 == null) { [EOL]         return clone(array2); [EOL]     } else if (array2 == null) { [EOL]         return clone(array1); [EOL]     } [EOL]     final double[] joinedArray = new double[array1.length + array2.length]; [EOL]     System.arraycopy(array1, 0, joinedArray, 0, array1.length); [EOL]     System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); [EOL]     return joinedArray; [EOL] } 
 [LINE] throw new IllegalArgumentException("Arguments cannot both be null"); [LINE] public static <T> T[] add(final T[] array, final T element) { [EOL]     Class<?> type; [EOL]     if (array != null) { [EOL]         type = array.getClass(); [EOL]     } else if (element != null) { [EOL]         type = element.getClass(); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Arguments cannot both be null"); [EOL]     } [EOL]     @SuppressWarnings("unchecked") [EOL]     final T[] newArray = (T[]) copyArrayGrow1(array, type); [EOL]     newArray[newArray.length - 1] = element; [EOL]     return newArray; [EOL] } 
 [LINE] } else if (element != null) { [LINE] public static <T> T[] add(final T[] array, final int index, final T element) { [EOL]     Class<?> clss = null; [EOL]     if (array != null) { [EOL]         clss = array.getClass().getComponentType(); [EOL]     } else if (element != null) { [EOL]         clss = element.getClass(); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Array and element cannot both be null"); [EOL]     } [EOL]     @SuppressWarnings("unchecked") [EOL]     final T[] newArray = (T[]) add(array, index, element, clss); [EOL]     return newArray; [EOL] } 
 [LINE] clss = element.getClass(); [LINE] public static <T> T[] add(final T[] array, final int index, final T element) { [EOL]     Class<?> clss = null; [EOL]     if (array != null) { [EOL]         clss = array.getClass().getComponentType(); [EOL]     } else if (element != null) { [EOL]         clss = element.getClass(); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Array and element cannot both be null"); [EOL]     } [EOL]     @SuppressWarnings("unchecked") [EOL]     final T[] newArray = (T[]) add(array, index, element, clss); [EOL]     return newArray; [EOL] } 
 [LINE] throw new IllegalArgumentException("Array and element cannot both be null"); [LINE] public static <T> T[] add(final T[] array, final int index, final T element) { [EOL]     Class<?> clss = null; [EOL]     if (array != null) { [EOL]         clss = array.getClass().getComponentType(); [EOL]     } else if (element != null) { [EOL]         clss = element.getClass(); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Array and element cannot both be null"); [EOL]     } [EOL]     @SuppressWarnings("unchecked") [EOL]     final T[] newArray = (T[]) add(array, index, element, clss); [EOL]     return newArray; [EOL] } 
 [LINE] return newArray; [LINE] public static <T> T[] add(final T[] array, final int index, final T element) { [EOL]     Class<?> clss = null; [EOL]     if (array != null) { [EOL]         clss = array.getClass().getComponentType(); [EOL]     } else if (element != null) { [EOL]         clss = element.getClass(); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Array and element cannot both be null"); [EOL]     } [EOL]     @SuppressWarnings("unchecked") [EOL]     final T[] newArray = (T[]) add(array, index, element, clss); [EOL]     return newArray; [EOL] } 
 [LINE] return remove(array, index); [LINE] public static <T> T[] removeElement(final T[] array, final Object element) { [EOL]     final int index = indexOf(array, element); [EOL]     if (index == INDEX_NOT_FOUND) { [EOL]         return clone(array); [EOL]     } [EOL]     return remove(array, index); [EOL] } 
 [LINE] return clone(array); [LINE] public static int[] removeElement(final int[] array, final int element) { [EOL]     final int index = indexOf(array, element); [EOL]     if (index == INDEX_NOT_FOUND) { [EOL]         return clone(array); [EOL]     } [EOL]     return remove(array, index); [EOL] } 
 [LINE] public static <T> T[] removeElements(final T[] array, final T... values) { [LINE] public static <T> T[] removeElements(final T[] array, final T... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length); [EOL]     for (final T v : values) { [EOL]         final MutableInt count = occurrences.get(v); [EOL]         if (count == null) { [EOL]             occurrences.put(v, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) { [EOL]         final T v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v, found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     @SuppressWarnings("unchecked") [EOL]     final T[] result = (T[]) removeAll(array, toRemove); [EOL]     return result; [EOL] } 
 [LINE] if (isEmpty(array) || isEmpty(values)) { [LINE] public static <T> T[] removeElements(final T[] array, final T... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length); [EOL]     for (final T v : values) { [EOL]         final MutableInt count = occurrences.get(v); [EOL]         if (count == null) { [EOL]             occurrences.put(v, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) { [EOL]         final T v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v, found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     @SuppressWarnings("unchecked") [EOL]     final T[] result = (T[]) removeAll(array, toRemove); [EOL]     return result; [EOL] } 
 [LINE] return clone(array); [LINE] public static <T> T[] removeElements(final T[] array, final T... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length); [EOL]     for (final T v : values) { [EOL]         final MutableInt count = occurrences.get(v); [EOL]         if (count == null) { [EOL]             occurrences.put(v, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) { [EOL]         final T v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v, found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     @SuppressWarnings("unchecked") [EOL]     final T[] result = (T[]) removeAll(array, toRemove); [EOL]     return result; [EOL] } 
 [LINE] final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length); [LINE] public static <T> T[] removeElements(final T[] array, final T... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length); [EOL]     for (final T v : values) { [EOL]         final MutableInt count = occurrences.get(v); [EOL]         if (count == null) { [EOL]             occurrences.put(v, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) { [EOL]         final T v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v, found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     @SuppressWarnings("unchecked") [EOL]     final T[] result = (T[]) removeAll(array, toRemove); [EOL]     return result; [EOL] } 
 [LINE] for (final T v : values) { [LINE] public static <T> T[] removeElements(final T[] array, final T... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length); [EOL]     for (final T v : values) { [EOL]         final MutableInt count = occurrences.get(v); [EOL]         if (count == null) { [EOL]             occurrences.put(v, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) { [EOL]         final T v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v, found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     @SuppressWarnings("unchecked") [EOL]     final T[] result = (T[]) removeAll(array, toRemove); [EOL]     return result; [EOL] } 
 [LINE] final MutableInt count = occurrences.get(v); [LINE] public static <T> T[] removeElements(final T[] array, final T... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length); [EOL]     for (final T v : values) { [EOL]         final MutableInt count = occurrences.get(v); [EOL]         if (count == null) { [EOL]             occurrences.put(v, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) { [EOL]         final T v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v, found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     @SuppressWarnings("unchecked") [EOL]     final T[] result = (T[]) removeAll(array, toRemove); [EOL]     return result; [EOL] } 
 [LINE] if (count == null) { [LINE] public static <T> T[] removeElements(final T[] array, final T... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length); [EOL]     for (final T v : values) { [EOL]         final MutableInt count = occurrences.get(v); [EOL]         if (count == null) { [EOL]             occurrences.put(v, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) { [EOL]         final T v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v, found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     @SuppressWarnings("unchecked") [EOL]     final T[] result = (T[]) removeAll(array, toRemove); [EOL]     return result; [EOL] } 
 [LINE] occurrences.put(v, new MutableInt(1)); [LINE] public static <T> T[] removeElements(final T[] array, final T... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length); [EOL]     for (final T v : values) { [EOL]         final MutableInt count = occurrences.get(v); [EOL]         if (count == null) { [EOL]             occurrences.put(v, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) { [EOL]         final T v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v, found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     @SuppressWarnings("unchecked") [EOL]     final T[] result = (T[]) removeAll(array, toRemove); [EOL]     return result; [EOL] } 
 [LINE] count.increment(); [LINE] public static <T> T[] removeElements(final T[] array, final T... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length); [EOL]     for (final T v : values) { [EOL]         final MutableInt count = occurrences.get(v); [EOL]         if (count == null) { [EOL]             occurrences.put(v, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) { [EOL]         final T v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v, found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     @SuppressWarnings("unchecked") [EOL]     final T[] result = (T[]) removeAll(array, toRemove); [EOL]     return result; [EOL] } 
 [LINE] final BitSet toRemove = new BitSet(); [LINE] public static <T> T[] removeElements(final T[] array, final T... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length); [EOL]     for (final T v : values) { [EOL]         final MutableInt count = occurrences.get(v); [EOL]         if (count == null) { [EOL]             occurrences.put(v, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) { [EOL]         final T v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v, found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     @SuppressWarnings("unchecked") [EOL]     final T[] result = (T[]) removeAll(array, toRemove); [EOL]     return result; [EOL] } 
 [LINE] for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) { [LINE] public static <T> T[] removeElements(final T[] array, final T... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length); [EOL]     for (final T v : values) { [EOL]         final MutableInt count = occurrences.get(v); [EOL]         if (count == null) { [EOL]             occurrences.put(v, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) { [EOL]         final T v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v, found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     @SuppressWarnings("unchecked") [EOL]     final T[] result = (T[]) removeAll(array, toRemove); [EOL]     return result; [EOL] } 
 [LINE] final T v = e.getKey(); [LINE] public static <T> T[] removeElements(final T[] array, final T... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length); [EOL]     for (final T v : values) { [EOL]         final MutableInt count = occurrences.get(v); [EOL]         if (count == null) { [EOL]             occurrences.put(v, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) { [EOL]         final T v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v, found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     @SuppressWarnings("unchecked") [EOL]     final T[] result = (T[]) removeAll(array, toRemove); [EOL]     return result; [EOL] } 
 [LINE] int found = 0; [LINE] public static <T> T[] removeElements(final T[] array, final T... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length); [EOL]     for (final T v : values) { [EOL]         final MutableInt count = occurrences.get(v); [EOL]         if (count == null) { [EOL]             occurrences.put(v, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) { [EOL]         final T v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v, found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     @SuppressWarnings("unchecked") [EOL]     final T[] result = (T[]) removeAll(array, toRemove); [EOL]     return result; [EOL] } 
 [LINE] for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [LINE] public static <T> T[] removeElements(final T[] array, final T... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length); [EOL]     for (final T v : values) { [EOL]         final MutableInt count = occurrences.get(v); [EOL]         if (count == null) { [EOL]             occurrences.put(v, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) { [EOL]         final T v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v, found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     @SuppressWarnings("unchecked") [EOL]     final T[] result = (T[]) removeAll(array, toRemove); [EOL]     return result; [EOL] } 
 [LINE] found = indexOf(array, v, found); [LINE] public static <T> T[] removeElements(final T[] array, final T... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length); [EOL]     for (final T v : values) { [EOL]         final MutableInt count = occurrences.get(v); [EOL]         if (count == null) { [EOL]             occurrences.put(v, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) { [EOL]         final T v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v, found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     @SuppressWarnings("unchecked") [EOL]     final T[] result = (T[]) removeAll(array, toRemove); [EOL]     return result; [EOL] } 
 [LINE] if (found < 0) { [LINE] public static <T> T[] removeElements(final T[] array, final T... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length); [EOL]     for (final T v : values) { [EOL]         final MutableInt count = occurrences.get(v); [EOL]         if (count == null) { [EOL]             occurrences.put(v, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) { [EOL]         final T v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v, found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     @SuppressWarnings("unchecked") [EOL]     final T[] result = (T[]) removeAll(array, toRemove); [EOL]     return result; [EOL] } 
 [LINE] break; [LINE] public static <T> T[] removeElements(final T[] array, final T... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length); [EOL]     for (final T v : values) { [EOL]         final MutableInt count = occurrences.get(v); [EOL]         if (count == null) { [EOL]             occurrences.put(v, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) { [EOL]         final T v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v, found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     @SuppressWarnings("unchecked") [EOL]     final T[] result = (T[]) removeAll(array, toRemove); [EOL]     return result; [EOL] } 
 [LINE] toRemove.set(found++); [LINE] public static <T> T[] removeElements(final T[] array, final T... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length); [EOL]     for (final T v : values) { [EOL]         final MutableInt count = occurrences.get(v); [EOL]         if (count == null) { [EOL]             occurrences.put(v, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) { [EOL]         final T v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v, found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     @SuppressWarnings("unchecked") [EOL]     final T[] result = (T[]) removeAll(array, toRemove); [EOL]     return result; [EOL] } 
 [LINE] @SuppressWarnings("unchecked") // removeAll() always creates an array of the same type as its input [LINE] public static <T> T[] removeElements(final T[] array, final T... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length); [EOL]     for (final T v : values) { [EOL]         final MutableInt count = occurrences.get(v); [EOL]         if (count == null) { [EOL]             occurrences.put(v, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) { [EOL]         final T v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v, found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     @SuppressWarnings("unchecked") [EOL]     final T[] result = (T[]) removeAll(array, toRemove); [EOL]     return result; [EOL] } 
 [LINE] return result; [LINE] public static <T> T[] removeElements(final T[] array, final T... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length); [EOL]     for (final T v : values) { [EOL]         final MutableInt count = occurrences.get(v); [EOL]         if (count == null) { [EOL]             occurrences.put(v, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) { [EOL]         final T v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v, found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     @SuppressWarnings("unchecked") [EOL]     final T[] result = (T[]) removeAll(array, toRemove); [EOL]     return result; [EOL] } 
 [LINE] return clone(array); [LINE] public static byte[] removeElements(final byte[] array, final byte... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<Byte, MutableInt> occurrences = new HashMap<Byte, MutableInt>(values.length); [EOL]     for (final byte v : values) { [EOL]         final Byte boxed = Byte.valueOf(v); [EOL]         final MutableInt count = occurrences.get(boxed); [EOL]         if (count == null) { [EOL]             occurrences.put(boxed, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<Byte, MutableInt> e : occurrences.entrySet()) { [EOL]         final Byte v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v.byteValue(), found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     return (byte[]) removeAll(array, toRemove); [EOL] } 
 [LINE] break; [LINE] public static byte[] removeElements(final byte[] array, final byte... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<Byte, MutableInt> occurrences = new HashMap<Byte, MutableInt>(values.length); [EOL]     for (final byte v : values) { [EOL]         final Byte boxed = Byte.valueOf(v); [EOL]         final MutableInt count = occurrences.get(boxed); [EOL]         if (count == null) { [EOL]             occurrences.put(boxed, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<Byte, MutableInt> e : occurrences.entrySet()) { [EOL]         final Byte v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v.byteValue(), found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     return (byte[]) removeAll(array, toRemove); [EOL] } 
 [LINE] break; [LINE] public static short[] removeElements(final short[] array, final short... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<Short, MutableInt> occurrences = new HashMap<Short, MutableInt>(values.length); [EOL]     for (final short v : values) { [EOL]         final Short boxed = Short.valueOf(v); [EOL]         final MutableInt count = occurrences.get(boxed); [EOL]         if (count == null) { [EOL]             occurrences.put(boxed, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<Short, MutableInt> e : occurrences.entrySet()) { [EOL]         final Short v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v.shortValue(), found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     return (short[]) removeAll(array, toRemove); [EOL] } 
 [LINE] break; [LINE] public static int[] removeElements(final int[] array, final int... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<Integer, MutableInt> occurrences = new HashMap<Integer, MutableInt>(values.length); [EOL]     for (final int v : values) { [EOL]         final Integer boxed = Integer.valueOf(v); [EOL]         final MutableInt count = occurrences.get(boxed); [EOL]         if (count == null) { [EOL]             occurrences.put(boxed, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<Integer, MutableInt> e : occurrences.entrySet()) { [EOL]         final Integer v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v.intValue(), found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     return (int[]) removeAll(array, toRemove); [EOL] } 
 [LINE] break; [LINE] public static char[] removeElements(final char[] array, final char... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<Character, MutableInt> occurrences = new HashMap<Character, MutableInt>(values.length); [EOL]     for (final char v : values) { [EOL]         final Character boxed = Character.valueOf(v); [EOL]         final MutableInt count = occurrences.get(boxed); [EOL]         if (count == null) { [EOL]             occurrences.put(boxed, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<Character, MutableInt> e : occurrences.entrySet()) { [EOL]         final Character v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v.charValue(), found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     return (char[]) removeAll(array, toRemove); [EOL] } 
 [LINE] break; [LINE] public static long[] removeElements(final long[] array, final long... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<Long, MutableInt> occurrences = new HashMap<Long, MutableInt>(values.length); [EOL]     for (final long v : values) { [EOL]         final Long boxed = Long.valueOf(v); [EOL]         final MutableInt count = occurrences.get(boxed); [EOL]         if (count == null) { [EOL]             occurrences.put(boxed, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<Long, MutableInt> e : occurrences.entrySet()) { [EOL]         final Long v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v.longValue(), found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     return (long[]) removeAll(array, toRemove); [EOL] } 
 [LINE] break; [LINE] public static float[] removeElements(final float[] array, final float... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<Float, MutableInt> occurrences = new HashMap<Float, MutableInt>(values.length); [EOL]     for (final float v : values) { [EOL]         final Float boxed = Float.valueOf(v); [EOL]         final MutableInt count = occurrences.get(boxed); [EOL]         if (count == null) { [EOL]             occurrences.put(boxed, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<Float, MutableInt> e : occurrences.entrySet()) { [EOL]         final Float v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v.floatValue(), found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     return (float[]) removeAll(array, toRemove); [EOL] } 
 [LINE] break; [LINE] public static double[] removeElements(final double[] array, final double... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<Double, MutableInt> occurrences = new HashMap<Double, MutableInt>(values.length); [EOL]     for (final double v : values) { [EOL]         final Double boxed = Double.valueOf(v); [EOL]         final MutableInt count = occurrences.get(boxed); [EOL]         if (count == null) { [EOL]             occurrences.put(boxed, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<Double, MutableInt> e : occurrences.entrySet()) { [EOL]         final Double v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v.doubleValue(), found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     return (double[]) removeAll(array, toRemove); [EOL] } 
 [LINE] public static boolean[] removeAll(final boolean[] array, final int... indices) { [LINE] public static boolean[] removeAll(final boolean[] array, final int... indices) { [EOL]     return (boolean[]) removeAll((Object) array, clone(indices)); [EOL] } 
 [LINE] return (boolean[]) removeAll((Object) array, clone(indices)); [LINE] public static boolean[] removeAll(final boolean[] array, final int... indices) { [EOL]     return (boolean[]) removeAll((Object) array, clone(indices)); [EOL] } 
 [LINE] break; [LINE] public static boolean[] removeElements(final boolean[] array, final boolean... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<Boolean, MutableInt> occurrences = new HashMap<Boolean, MutableInt>(2); [EOL]     for (final boolean v : values) { [EOL]         final Boolean boxed = Boolean.valueOf(v); [EOL]         final MutableInt count = occurrences.get(boxed); [EOL]         if (count == null) { [EOL]             occurrences.put(boxed, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<Boolean, MutableInt> e : occurrences.entrySet()) { [EOL]         final Boolean v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v.booleanValue(), found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     return (boolean[]) removeAll(array, toRemove); [EOL] } 
 [LINE] System.arraycopy(array, 0, result, 0, end); [LINE] static Object removeAll(final Object array, final int... indices) { [EOL]     final int length = getLength(array); [EOL]     int diff = 0; [EOL]     if (isNotEmpty(indices)) { [EOL]         Arrays.sort(indices); [EOL]         int i = indices.length; [EOL]         int prevIndex = length; [EOL]         while (--i >= 0) { [EOL]             final int index = indices[i]; [EOL]             if (index < 0 || index >= length) { [EOL]                 throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]             } [EOL]             if (index >= prevIndex) { [EOL]                 continue; [EOL]             } [EOL]             diff++; [EOL]             prevIndex = index; [EOL]         } [EOL]     } [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), length - diff); [EOL]     if (diff < length) { [EOL]         int end = length; [EOL]         int dest = length - diff; [EOL]         for (int i = indices.length - 1; i >= 0; i--) { [EOL]             final int index = indices[i]; [EOL]             if (end - index > 1) { [EOL]                 final int cp = end - index - 1; [EOL]                 dest -= cp; [EOL]                 System.arraycopy(array, index + 1, result, dest, cp); [EOL]             } [EOL]             end = index; [EOL]         } [EOL]         if (end > 0) { [EOL]             System.arraycopy(array, 0, result, 0, end); [EOL]         } [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] System.arraycopy(array, srcIndex, result, destIndex, count); [LINE] static Object removeAll(final Object array, final BitSet indices) { [EOL]     final int srcLength = ArrayUtils.getLength(array); [EOL]     final int removals = indices.cardinality(); [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), srcLength - removals); [EOL]     int srcIndex = 0; [EOL]     int destIndex = 0; [EOL]     int count; [EOL]     int set; [EOL]     while ((set = indices.nextSetBit(srcIndex)) != -1) { [EOL]         count = set - srcIndex; [EOL]         if (count > 0) { [EOL]             System.arraycopy(array, srcIndex, result, destIndex, count); [EOL]             destIndex += count; [EOL]         } [EOL]         srcIndex = indices.nextClearBit(set); [EOL]     } [EOL]     count = srcLength - srcIndex; [EOL]     if (count > 0) { [EOL]         System.arraycopy(array, srcIndex, result, destIndex, count); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] destIndex += count; [LINE] static Object removeAll(final Object array, final BitSet indices) { [EOL]     final int srcLength = ArrayUtils.getLength(array); [EOL]     final int removals = indices.cardinality(); [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), srcLength - removals); [EOL]     int srcIndex = 0; [EOL]     int destIndex = 0; [EOL]     int count; [EOL]     int set; [EOL]     while ((set = indices.nextSetBit(srcIndex)) != -1) { [EOL]         count = set - srcIndex; [EOL]         if (count > 0) { [EOL]             System.arraycopy(array, srcIndex, result, destIndex, count); [EOL]             destIndex += count; [EOL]         } [EOL]         srcIndex = indices.nextClearBit(set); [EOL]     } [EOL]     count = srcLength - srcIndex; [EOL]     if (count > 0) { [EOL]         System.arraycopy(array, srcIndex, result, destIndex, count); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] System.arraycopy(array, srcIndex, result, destIndex, count); [LINE] static Object removeAll(final Object array, final BitSet indices) { [EOL]     final int srcLength = ArrayUtils.getLength(array); [EOL]     final int removals = indices.cardinality(); [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), srcLength - removals); [EOL]     int srcIndex = 0; [EOL]     int destIndex = 0; [EOL]     int count; [EOL]     int set; [EOL]     while ((set = indices.nextSetBit(srcIndex)) != -1) { [EOL]         count = set - srcIndex; [EOL]         if (count > 0) { [EOL]             System.arraycopy(array, srcIndex, result, destIndex, count); [EOL]             destIndex += count; [EOL]         } [EOL]         srcIndex = indices.nextClearBit(set); [EOL]     } [EOL]     count = srcLength - srcIndex; [EOL]     if (count > 0) { [EOL]         System.arraycopy(array, srcIndex, result, destIndex, count); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] throw new IllegalArgumentException("Invalid locale format: " + str); [LINE] public static Locale toLocale(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (str.contains("#")) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len < 2) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch0 = str.charAt(0); [EOL]     if (ch0 == '_') { [EOL]         if (len < 3) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         final char ch1 = str.charAt(1); [EOL]         final char ch2 = str.charAt(2); [EOL]         if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (len == 3) { [EOL]             return new Locale("", str.substring(1, 3)); [EOL]         } [EOL]         if (len < 5) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (str.charAt(3) != '_') { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         return new Locale("", str.substring(1, 3), str.substring(4)); [EOL]     } [EOL]     final char ch1 = str.charAt(1); [EOL]     if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 2) { [EOL]         return new Locale(str); [EOL]     } [EOL]     if (len < 5) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(2) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch3 = str.charAt(3); [EOL]     if (ch3 == '_') { [EOL]         return new Locale(str.substring(0, 2), "", str.substring(4)); [EOL]     } [EOL]     final char ch4 = str.charAt(4); [EOL]     if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 5) { [EOL]         return new Locale(str.substring(0, 2), str.substring(3, 5)); [EOL]     } [EOL]     if (len < 7) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(5) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6)); [EOL] } 
 [LINE] if (len == 3) { [LINE] public static Locale toLocale(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (str.contains("#")) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len < 2) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch0 = str.charAt(0); [EOL]     if (ch0 == '_') { [EOL]         if (len < 3) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         final char ch1 = str.charAt(1); [EOL]         final char ch2 = str.charAt(2); [EOL]         if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (len == 3) { [EOL]             return new Locale("", str.substring(1, 3)); [EOL]         } [EOL]         if (len < 5) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (str.charAt(3) != '_') { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         return new Locale("", str.substring(1, 3), str.substring(4)); [EOL]     } [EOL]     final char ch1 = str.charAt(1); [EOL]     if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 2) { [EOL]         return new Locale(str); [EOL]     } [EOL]     if (len < 5) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(2) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch3 = str.charAt(3); [EOL]     if (ch3 == '_') { [EOL]         return new Locale(str.substring(0, 2), "", str.substring(4)); [EOL]     } [EOL]     final char ch4 = str.charAt(4); [EOL]     if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 5) { [EOL]         return new Locale(str.substring(0, 2), str.substring(3, 5)); [EOL]     } [EOL]     if (len < 7) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(5) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6)); [EOL] } 
 [LINE] return new Locale("", str.substring(1, 3)); [LINE] public static Locale toLocale(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (str.contains("#")) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len < 2) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch0 = str.charAt(0); [EOL]     if (ch0 == '_') { [EOL]         if (len < 3) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         final char ch1 = str.charAt(1); [EOL]         final char ch2 = str.charAt(2); [EOL]         if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (len == 3) { [EOL]             return new Locale("", str.substring(1, 3)); [EOL]         } [EOL]         if (len < 5) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (str.charAt(3) != '_') { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         return new Locale("", str.substring(1, 3), str.substring(4)); [EOL]     } [EOL]     final char ch1 = str.charAt(1); [EOL]     if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 2) { [EOL]         return new Locale(str); [EOL]     } [EOL]     if (len < 5) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(2) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch3 = str.charAt(3); [EOL]     if (ch3 == '_') { [EOL]         return new Locale(str.substring(0, 2), "", str.substring(4)); [EOL]     } [EOL]     final char ch4 = str.charAt(4); [EOL]     if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 5) { [EOL]         return new Locale(str.substring(0, 2), str.substring(3, 5)); [EOL]     } [EOL]     if (len < 7) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(5) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6)); [EOL] } 
 [LINE] if (len < 5) { [LINE] public static Locale toLocale(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (str.contains("#")) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len < 2) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch0 = str.charAt(0); [EOL]     if (ch0 == '_') { [EOL]         if (len < 3) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         final char ch1 = str.charAt(1); [EOL]         final char ch2 = str.charAt(2); [EOL]         if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (len == 3) { [EOL]             return new Locale("", str.substring(1, 3)); [EOL]         } [EOL]         if (len < 5) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (str.charAt(3) != '_') { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         return new Locale("", str.substring(1, 3), str.substring(4)); [EOL]     } [EOL]     final char ch1 = str.charAt(1); [EOL]     if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 2) { [EOL]         return new Locale(str); [EOL]     } [EOL]     if (len < 5) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(2) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch3 = str.charAt(3); [EOL]     if (ch3 == '_') { [EOL]         return new Locale(str.substring(0, 2), "", str.substring(4)); [EOL]     } [EOL]     final char ch4 = str.charAt(4); [EOL]     if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 5) { [EOL]         return new Locale(str.substring(0, 2), str.substring(3, 5)); [EOL]     } [EOL]     if (len < 7) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(5) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6)); [EOL] } 
 [LINE] throw new IllegalArgumentException("Invalid locale format: " + str); [LINE] public static Locale toLocale(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (str.contains("#")) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len < 2) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch0 = str.charAt(0); [EOL]     if (ch0 == '_') { [EOL]         if (len < 3) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         final char ch1 = str.charAt(1); [EOL]         final char ch2 = str.charAt(2); [EOL]         if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (len == 3) { [EOL]             return new Locale("", str.substring(1, 3)); [EOL]         } [EOL]         if (len < 5) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (str.charAt(3) != '_') { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         return new Locale("", str.substring(1, 3), str.substring(4)); [EOL]     } [EOL]     final char ch1 = str.charAt(1); [EOL]     if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 2) { [EOL]         return new Locale(str); [EOL]     } [EOL]     if (len < 5) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(2) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch3 = str.charAt(3); [EOL]     if (ch3 == '_') { [EOL]         return new Locale(str.substring(0, 2), "", str.substring(4)); [EOL]     } [EOL]     final char ch4 = str.charAt(4); [EOL]     if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 5) { [EOL]         return new Locale(str.substring(0, 2), str.substring(3, 5)); [EOL]     } [EOL]     if (len < 7) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(5) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6)); [EOL] } 
 [LINE] if (str.charAt(3) != '_') { [LINE] public static Locale toLocale(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (str.contains("#")) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len < 2) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch0 = str.charAt(0); [EOL]     if (ch0 == '_') { [EOL]         if (len < 3) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         final char ch1 = str.charAt(1); [EOL]         final char ch2 = str.charAt(2); [EOL]         if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (len == 3) { [EOL]             return new Locale("", str.substring(1, 3)); [EOL]         } [EOL]         if (len < 5) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (str.charAt(3) != '_') { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         return new Locale("", str.substring(1, 3), str.substring(4)); [EOL]     } [EOL]     final char ch1 = str.charAt(1); [EOL]     if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 2) { [EOL]         return new Locale(str); [EOL]     } [EOL]     if (len < 5) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(2) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch3 = str.charAt(3); [EOL]     if (ch3 == '_') { [EOL]         return new Locale(str.substring(0, 2), "", str.substring(4)); [EOL]     } [EOL]     final char ch4 = str.charAt(4); [EOL]     if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 5) { [EOL]         return new Locale(str.substring(0, 2), str.substring(3, 5)); [EOL]     } [EOL]     if (len < 7) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(5) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6)); [EOL] } 
 [LINE] throw new IllegalArgumentException("Invalid locale format: " + str); [LINE] public static Locale toLocale(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (str.contains("#")) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len < 2) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch0 = str.charAt(0); [EOL]     if (ch0 == '_') { [EOL]         if (len < 3) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         final char ch1 = str.charAt(1); [EOL]         final char ch2 = str.charAt(2); [EOL]         if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (len == 3) { [EOL]             return new Locale("", str.substring(1, 3)); [EOL]         } [EOL]         if (len < 5) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (str.charAt(3) != '_') { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         return new Locale("", str.substring(1, 3), str.substring(4)); [EOL]     } [EOL]     final char ch1 = str.charAt(1); [EOL]     if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 2) { [EOL]         return new Locale(str); [EOL]     } [EOL]     if (len < 5) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(2) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch3 = str.charAt(3); [EOL]     if (ch3 == '_') { [EOL]         return new Locale(str.substring(0, 2), "", str.substring(4)); [EOL]     } [EOL]     final char ch4 = str.charAt(4); [EOL]     if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 5) { [EOL]         return new Locale(str.substring(0, 2), str.substring(3, 5)); [EOL]     } [EOL]     if (len < 7) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(5) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6)); [EOL] } 
 [LINE] return new Locale("", str.substring(1, 3), str.substring(4)); [LINE] public static Locale toLocale(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (str.contains("#")) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len < 2) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch0 = str.charAt(0); [EOL]     if (ch0 == '_') { [EOL]         if (len < 3) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         final char ch1 = str.charAt(1); [EOL]         final char ch2 = str.charAt(2); [EOL]         if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (len == 3) { [EOL]             return new Locale("", str.substring(1, 3)); [EOL]         } [EOL]         if (len < 5) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (str.charAt(3) != '_') { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         return new Locale("", str.substring(1, 3), str.substring(4)); [EOL]     } [EOL]     final char ch1 = str.charAt(1); [EOL]     if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 2) { [EOL]         return new Locale(str); [EOL]     } [EOL]     if (len < 5) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(2) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch3 = str.charAt(3); [EOL]     if (ch3 == '_') { [EOL]         return new Locale(str.substring(0, 2), "", str.substring(4)); [EOL]     } [EOL]     final char ch4 = str.charAt(4); [EOL]     if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 5) { [EOL]         return new Locale(str.substring(0, 2), str.substring(3, 5)); [EOL]     } [EOL]     if (len < 7) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(5) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6)); [EOL] } 
 [LINE] final char ch3 = str.charAt(3); [LINE] public static Locale toLocale(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (str.contains("#")) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len < 2) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch0 = str.charAt(0); [EOL]     if (ch0 == '_') { [EOL]         if (len < 3) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         final char ch1 = str.charAt(1); [EOL]         final char ch2 = str.charAt(2); [EOL]         if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (len == 3) { [EOL]             return new Locale("", str.substring(1, 3)); [EOL]         } [EOL]         if (len < 5) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (str.charAt(3) != '_') { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         return new Locale("", str.substring(1, 3), str.substring(4)); [EOL]     } [EOL]     final char ch1 = str.charAt(1); [EOL]     if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 2) { [EOL]         return new Locale(str); [EOL]     } [EOL]     if (len < 5) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(2) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch3 = str.charAt(3); [EOL]     if (ch3 == '_') { [EOL]         return new Locale(str.substring(0, 2), "", str.substring(4)); [EOL]     } [EOL]     final char ch4 = str.charAt(4); [EOL]     if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 5) { [EOL]         return new Locale(str.substring(0, 2), str.substring(3, 5)); [EOL]     } [EOL]     if (len < 7) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(5) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6)); [EOL] } 
 [LINE] if (ch3 == '_') { [LINE] public static Locale toLocale(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (str.contains("#")) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len < 2) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch0 = str.charAt(0); [EOL]     if (ch0 == '_') { [EOL]         if (len < 3) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         final char ch1 = str.charAt(1); [EOL]         final char ch2 = str.charAt(2); [EOL]         if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (len == 3) { [EOL]             return new Locale("", str.substring(1, 3)); [EOL]         } [EOL]         if (len < 5) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (str.charAt(3) != '_') { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         return new Locale("", str.substring(1, 3), str.substring(4)); [EOL]     } [EOL]     final char ch1 = str.charAt(1); [EOL]     if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 2) { [EOL]         return new Locale(str); [EOL]     } [EOL]     if (len < 5) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(2) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch3 = str.charAt(3); [EOL]     if (ch3 == '_') { [EOL]         return new Locale(str.substring(0, 2), "", str.substring(4)); [EOL]     } [EOL]     final char ch4 = str.charAt(4); [EOL]     if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 5) { [EOL]         return new Locale(str.substring(0, 2), str.substring(3, 5)); [EOL]     } [EOL]     if (len < 7) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(5) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6)); [EOL] } 
 [LINE] return new Locale(str.substring(0, 2), "", str.substring(4)); [LINE] public static Locale toLocale(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (str.contains("#")) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len < 2) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch0 = str.charAt(0); [EOL]     if (ch0 == '_') { [EOL]         if (len < 3) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         final char ch1 = str.charAt(1); [EOL]         final char ch2 = str.charAt(2); [EOL]         if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (len == 3) { [EOL]             return new Locale("", str.substring(1, 3)); [EOL]         } [EOL]         if (len < 5) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (str.charAt(3) != '_') { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         return new Locale("", str.substring(1, 3), str.substring(4)); [EOL]     } [EOL]     final char ch1 = str.charAt(1); [EOL]     if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 2) { [EOL]         return new Locale(str); [EOL]     } [EOL]     if (len < 5) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(2) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch3 = str.charAt(3); [EOL]     if (ch3 == '_') { [EOL]         return new Locale(str.substring(0, 2), "", str.substring(4)); [EOL]     } [EOL]     final char ch4 = str.charAt(4); [EOL]     if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 5) { [EOL]         return new Locale(str.substring(0, 2), str.substring(3, 5)); [EOL]     } [EOL]     if (len < 7) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(5) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6)); [EOL] } 
 [LINE] final char ch4 = str.charAt(4); [LINE] public static Locale toLocale(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (str.contains("#")) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len < 2) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch0 = str.charAt(0); [EOL]     if (ch0 == '_') { [EOL]         if (len < 3) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         final char ch1 = str.charAt(1); [EOL]         final char ch2 = str.charAt(2); [EOL]         if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (len == 3) { [EOL]             return new Locale("", str.substring(1, 3)); [EOL]         } [EOL]         if (len < 5) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (str.charAt(3) != '_') { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         return new Locale("", str.substring(1, 3), str.substring(4)); [EOL]     } [EOL]     final char ch1 = str.charAt(1); [EOL]     if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 2) { [EOL]         return new Locale(str); [EOL]     } [EOL]     if (len < 5) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(2) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch3 = str.charAt(3); [EOL]     if (ch3 == '_') { [EOL]         return new Locale(str.substring(0, 2), "", str.substring(4)); [EOL]     } [EOL]     final char ch4 = str.charAt(4); [EOL]     if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 5) { [EOL]         return new Locale(str.substring(0, 2), str.substring(3, 5)); [EOL]     } [EOL]     if (len < 7) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(5) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6)); [EOL] } 
 [LINE] if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) { [LINE] public static Locale toLocale(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (str.contains("#")) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len < 2) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch0 = str.charAt(0); [EOL]     if (ch0 == '_') { [EOL]         if (len < 3) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         final char ch1 = str.charAt(1); [EOL]         final char ch2 = str.charAt(2); [EOL]         if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (len == 3) { [EOL]             return new Locale("", str.substring(1, 3)); [EOL]         } [EOL]         if (len < 5) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (str.charAt(3) != '_') { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         return new Locale("", str.substring(1, 3), str.substring(4)); [EOL]     } [EOL]     final char ch1 = str.charAt(1); [EOL]     if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 2) { [EOL]         return new Locale(str); [EOL]     } [EOL]     if (len < 5) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(2) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch3 = str.charAt(3); [EOL]     if (ch3 == '_') { [EOL]         return new Locale(str.substring(0, 2), "", str.substring(4)); [EOL]     } [EOL]     final char ch4 = str.charAt(4); [EOL]     if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 5) { [EOL]         return new Locale(str.substring(0, 2), str.substring(3, 5)); [EOL]     } [EOL]     if (len < 7) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(5) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6)); [EOL] } 
 [LINE] throw new IllegalArgumentException("Invalid locale format: " + str); [LINE] public static Locale toLocale(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (str.contains("#")) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len < 2) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch0 = str.charAt(0); [EOL]     if (ch0 == '_') { [EOL]         if (len < 3) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         final char ch1 = str.charAt(1); [EOL]         final char ch2 = str.charAt(2); [EOL]         if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (len == 3) { [EOL]             return new Locale("", str.substring(1, 3)); [EOL]         } [EOL]         if (len < 5) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (str.charAt(3) != '_') { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         return new Locale("", str.substring(1, 3), str.substring(4)); [EOL]     } [EOL]     final char ch1 = str.charAt(1); [EOL]     if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 2) { [EOL]         return new Locale(str); [EOL]     } [EOL]     if (len < 5) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(2) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch3 = str.charAt(3); [EOL]     if (ch3 == '_') { [EOL]         return new Locale(str.substring(0, 2), "", str.substring(4)); [EOL]     } [EOL]     final char ch4 = str.charAt(4); [EOL]     if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 5) { [EOL]         return new Locale(str.substring(0, 2), str.substring(3, 5)); [EOL]     } [EOL]     if (len < 7) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(5) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6)); [EOL] } 
 [LINE] if (len == 5) { [LINE] public static Locale toLocale(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (str.contains("#")) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len < 2) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch0 = str.charAt(0); [EOL]     if (ch0 == '_') { [EOL]         if (len < 3) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         final char ch1 = str.charAt(1); [EOL]         final char ch2 = str.charAt(2); [EOL]         if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (len == 3) { [EOL]             return new Locale("", str.substring(1, 3)); [EOL]         } [EOL]         if (len < 5) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (str.charAt(3) != '_') { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         return new Locale("", str.substring(1, 3), str.substring(4)); [EOL]     } [EOL]     final char ch1 = str.charAt(1); [EOL]     if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 2) { [EOL]         return new Locale(str); [EOL]     } [EOL]     if (len < 5) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(2) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch3 = str.charAt(3); [EOL]     if (ch3 == '_') { [EOL]         return new Locale(str.substring(0, 2), "", str.substring(4)); [EOL]     } [EOL]     final char ch4 = str.charAt(4); [EOL]     if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 5) { [EOL]         return new Locale(str.substring(0, 2), str.substring(3, 5)); [EOL]     } [EOL]     if (len < 7) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(5) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6)); [EOL] } 
 [LINE] return new Locale(str.substring(0, 2), str.substring(3, 5)); [LINE] public static Locale toLocale(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (str.contains("#")) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len < 2) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch0 = str.charAt(0); [EOL]     if (ch0 == '_') { [EOL]         if (len < 3) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         final char ch1 = str.charAt(1); [EOL]         final char ch2 = str.charAt(2); [EOL]         if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (len == 3) { [EOL]             return new Locale("", str.substring(1, 3)); [EOL]         } [EOL]         if (len < 5) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (str.charAt(3) != '_') { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         return new Locale("", str.substring(1, 3), str.substring(4)); [EOL]     } [EOL]     final char ch1 = str.charAt(1); [EOL]     if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 2) { [EOL]         return new Locale(str); [EOL]     } [EOL]     if (len < 5) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(2) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch3 = str.charAt(3); [EOL]     if (ch3 == '_') { [EOL]         return new Locale(str.substring(0, 2), "", str.substring(4)); [EOL]     } [EOL]     final char ch4 = str.charAt(4); [EOL]     if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 5) { [EOL]         return new Locale(str.substring(0, 2), str.substring(3, 5)); [EOL]     } [EOL]     if (len < 7) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(5) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6)); [EOL] } 
 [LINE] if (len < 7) { [LINE] public static Locale toLocale(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (str.contains("#")) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len < 2) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch0 = str.charAt(0); [EOL]     if (ch0 == '_') { [EOL]         if (len < 3) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         final char ch1 = str.charAt(1); [EOL]         final char ch2 = str.charAt(2); [EOL]         if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (len == 3) { [EOL]             return new Locale("", str.substring(1, 3)); [EOL]         } [EOL]         if (len < 5) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (str.charAt(3) != '_') { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         return new Locale("", str.substring(1, 3), str.substring(4)); [EOL]     } [EOL]     final char ch1 = str.charAt(1); [EOL]     if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 2) { [EOL]         return new Locale(str); [EOL]     } [EOL]     if (len < 5) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(2) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch3 = str.charAt(3); [EOL]     if (ch3 == '_') { [EOL]         return new Locale(str.substring(0, 2), "", str.substring(4)); [EOL]     } [EOL]     final char ch4 = str.charAt(4); [EOL]     if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 5) { [EOL]         return new Locale(str.substring(0, 2), str.substring(3, 5)); [EOL]     } [EOL]     if (len < 7) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(5) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6)); [EOL] } 
 [LINE] throw new IllegalArgumentException("Invalid locale format: " + str); [LINE] public static Locale toLocale(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (str.contains("#")) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len < 2) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch0 = str.charAt(0); [EOL]     if (ch0 == '_') { [EOL]         if (len < 3) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         final char ch1 = str.charAt(1); [EOL]         final char ch2 = str.charAt(2); [EOL]         if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (len == 3) { [EOL]             return new Locale("", str.substring(1, 3)); [EOL]         } [EOL]         if (len < 5) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (str.charAt(3) != '_') { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         return new Locale("", str.substring(1, 3), str.substring(4)); [EOL]     } [EOL]     final char ch1 = str.charAt(1); [EOL]     if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 2) { [EOL]         return new Locale(str); [EOL]     } [EOL]     if (len < 5) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(2) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch3 = str.charAt(3); [EOL]     if (ch3 == '_') { [EOL]         return new Locale(str.substring(0, 2), "", str.substring(4)); [EOL]     } [EOL]     final char ch4 = str.charAt(4); [EOL]     if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 5) { [EOL]         return new Locale(str.substring(0, 2), str.substring(3, 5)); [EOL]     } [EOL]     if (len < 7) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(5) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6)); [EOL] } 
 [LINE] if (str.charAt(5) != '_') { [LINE] public static Locale toLocale(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (str.contains("#")) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len < 2) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch0 = str.charAt(0); [EOL]     if (ch0 == '_') { [EOL]         if (len < 3) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         final char ch1 = str.charAt(1); [EOL]         final char ch2 = str.charAt(2); [EOL]         if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (len == 3) { [EOL]             return new Locale("", str.substring(1, 3)); [EOL]         } [EOL]         if (len < 5) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (str.charAt(3) != '_') { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         return new Locale("", str.substring(1, 3), str.substring(4)); [EOL]     } [EOL]     final char ch1 = str.charAt(1); [EOL]     if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 2) { [EOL]         return new Locale(str); [EOL]     } [EOL]     if (len < 5) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(2) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch3 = str.charAt(3); [EOL]     if (ch3 == '_') { [EOL]         return new Locale(str.substring(0, 2), "", str.substring(4)); [EOL]     } [EOL]     final char ch4 = str.charAt(4); [EOL]     if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 5) { [EOL]         return new Locale(str.substring(0, 2), str.substring(3, 5)); [EOL]     } [EOL]     if (len < 7) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(5) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6)); [EOL] } 
 [LINE] throw new IllegalArgumentException("Invalid locale format: " + str); [LINE] public static Locale toLocale(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (str.contains("#")) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len < 2) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch0 = str.charAt(0); [EOL]     if (ch0 == '_') { [EOL]         if (len < 3) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         final char ch1 = str.charAt(1); [EOL]         final char ch2 = str.charAt(2); [EOL]         if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (len == 3) { [EOL]             return new Locale("", str.substring(1, 3)); [EOL]         } [EOL]         if (len < 5) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (str.charAt(3) != '_') { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         return new Locale("", str.substring(1, 3), str.substring(4)); [EOL]     } [EOL]     final char ch1 = str.charAt(1); [EOL]     if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 2) { [EOL]         return new Locale(str); [EOL]     } [EOL]     if (len < 5) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(2) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch3 = str.charAt(3); [EOL]     if (ch3 == '_') { [EOL]         return new Locale(str.substring(0, 2), "", str.substring(4)); [EOL]     } [EOL]     final char ch4 = str.charAt(4); [EOL]     if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 5) { [EOL]         return new Locale(str.substring(0, 2), str.substring(3, 5)); [EOL]     } [EOL]     if (len < 7) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(5) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6)); [EOL] } 
 [LINE] return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6)); [LINE] public static Locale toLocale(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (str.contains("#")) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len < 2) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch0 = str.charAt(0); [EOL]     if (ch0 == '_') { [EOL]         if (len < 3) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         final char ch1 = str.charAt(1); [EOL]         final char ch2 = str.charAt(2); [EOL]         if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (len == 3) { [EOL]             return new Locale("", str.substring(1, 3)); [EOL]         } [EOL]         if (len < 5) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (str.charAt(3) != '_') { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         return new Locale("", str.substring(1, 3), str.substring(4)); [EOL]     } [EOL]     final char ch1 = str.charAt(1); [EOL]     if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 2) { [EOL]         return new Locale(str); [EOL]     } [EOL]     if (len < 5) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(2) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch3 = str.charAt(3); [EOL]     if (ch3 == '_') { [EOL]         return new Locale(str.substring(0, 2), "", str.substring(4)); [EOL]     } [EOL]     final char ch4 = str.charAt(4); [EOL]     if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 5) { [EOL]         return new Locale(str.substring(0, 2), str.substring(3, 5)); [EOL]     } [EOL]     if (len < 7) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(5) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6)); [EOL] } 
 [LINE] countries.add(locale); [LINE] public static List<Locale> countriesByLanguage(final String languageCode) { [EOL]     if (languageCode == null) { [EOL]         return Collections.emptyList(); [EOL]     } [EOL]     List<Locale> countries = cCountriesByLanguage.get(languageCode); [EOL]     if (countries == null) { [EOL]         countries = new ArrayList<Locale>(); [EOL]         final List<Locale> locales = availableLocaleList(); [EOL]         for (int i = 0; i < locales.size(); i++) { [EOL]             final Locale locale = locales.get(i); [EOL]             if (languageCode.equals(locale.getLanguage()) && locale.getCountry().length() != 0 && locale.getVariant().isEmpty()) { [EOL]                 countries.add(locale); [EOL]             } [EOL]         } [EOL]         countries = Collections.unmodifiableList(countries); [EOL]         cCountriesByLanguage.putIfAbsent(languageCode, countries); [EOL]         countries = cCountriesByLanguage.get(languageCode); [EOL]     } [EOL]     return countries; [EOL] } 
 [LINE] return method.invoke(object, args); [LINE] public static Object invokeExactMethod(final Object object, final String methodName, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException { [EOL]     if (args == null) { [EOL]         args = ArrayUtils.EMPTY_OBJECT_ARRAY; [EOL]     } [EOL]     if (parameterTypes == null) { [EOL]         parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY; [EOL]     } [EOL]     final Method method = getAccessibleMethod(object.getClass(), methodName, parameterTypes); [EOL]     if (method == null) { [EOL]         throw new NoSuchMethodException("No such accessible method: " + methodName + "() on object: " + object.getClass().getName()); [EOL]     } [EOL]     return method.invoke(object, args); [EOL] } 
 [LINE] final String methodName = method.getName(); [LINE] public static Method getAccessibleMethod(Method method) { [EOL]     if (!MemberUtils.isAccessible(method)) { [EOL]         return null; [EOL]     } [EOL]     final Class<?> cls = method.getDeclaringClass(); [EOL]     if (Modifier.isPublic(cls.getModifiers())) { [EOL]         return method; [EOL]     } [EOL]     final String methodName = method.getName(); [EOL]     final Class<?>[] parameterTypes = method.getParameterTypes(); [EOL]     method = getAccessibleMethodFromInterfaceNest(cls, methodName, parameterTypes); [EOL]     if (method == null) { [EOL]         method = getAccessibleMethodFromSuperclass(cls, methodName, parameterTypes); [EOL]     } [EOL]     return method; [EOL] } 
 [LINE] final Class<?>[] parameterTypes = method.getParameterTypes(); [LINE] public static Method getAccessibleMethod(Method method) { [EOL]     if (!MemberUtils.isAccessible(method)) { [EOL]         return null; [EOL]     } [EOL]     final Class<?> cls = method.getDeclaringClass(); [EOL]     if (Modifier.isPublic(cls.getModifiers())) { [EOL]         return method; [EOL]     } [EOL]     final String methodName = method.getName(); [EOL]     final Class<?>[] parameterTypes = method.getParameterTypes(); [EOL]     method = getAccessibleMethodFromInterfaceNest(cls, methodName, parameterTypes); [EOL]     if (method == null) { [EOL]         method = getAccessibleMethodFromSuperclass(cls, methodName, parameterTypes); [EOL]     } [EOL]     return method; [EOL] } 
 [LINE] method = getAccessibleMethodFromInterfaceNest(cls, methodName, [LINE] public static Method getAccessibleMethod(Method method) { [EOL]     if (!MemberUtils.isAccessible(method)) { [EOL]         return null; [EOL]     } [EOL]     final Class<?> cls = method.getDeclaringClass(); [EOL]     if (Modifier.isPublic(cls.getModifiers())) { [EOL]         return method; [EOL]     } [EOL]     final String methodName = method.getName(); [EOL]     final Class<?>[] parameterTypes = method.getParameterTypes(); [EOL]     method = getAccessibleMethodFromInterfaceNest(cls, methodName, parameterTypes); [EOL]     if (method == null) { [EOL]         method = getAccessibleMethodFromSuperclass(cls, methodName, parameterTypes); [EOL]     } [EOL]     return method; [EOL] } 
 [LINE] if (method == null) { [LINE] public static Method getAccessibleMethod(Method method) { [EOL]     if (!MemberUtils.isAccessible(method)) { [EOL]         return null; [EOL]     } [EOL]     final Class<?> cls = method.getDeclaringClass(); [EOL]     if (Modifier.isPublic(cls.getModifiers())) { [EOL]         return method; [EOL]     } [EOL]     final String methodName = method.getName(); [EOL]     final Class<?>[] parameterTypes = method.getParameterTypes(); [EOL]     method = getAccessibleMethodFromInterfaceNest(cls, methodName, parameterTypes); [EOL]     if (method == null) { [EOL]         method = getAccessibleMethodFromSuperclass(cls, methodName, parameterTypes); [EOL]     } [EOL]     return method; [EOL] } 
 [LINE] method = getAccessibleMethodFromSuperclass(cls, methodName, [LINE] public static Method getAccessibleMethod(Method method) { [EOL]     if (!MemberUtils.isAccessible(method)) { [EOL]         return null; [EOL]     } [EOL]     final Class<?> cls = method.getDeclaringClass(); [EOL]     if (Modifier.isPublic(cls.getModifiers())) { [EOL]         return method; [EOL]     } [EOL]     final String methodName = method.getName(); [EOL]     final Class<?>[] parameterTypes = method.getParameterTypes(); [EOL]     method = getAccessibleMethodFromInterfaceNest(cls, methodName, parameterTypes); [EOL]     if (method == null) { [EOL]         method = getAccessibleMethodFromSuperclass(cls, methodName, parameterTypes); [EOL]     } [EOL]     return method; [EOL] } 
 [LINE] return method; [LINE] public static Method getAccessibleMethod(Method method) { [EOL]     if (!MemberUtils.isAccessible(method)) { [EOL]         return null; [EOL]     } [EOL]     final Class<?> cls = method.getDeclaringClass(); [EOL]     if (Modifier.isPublic(cls.getModifiers())) { [EOL]         return method; [EOL]     } [EOL]     final String methodName = method.getName(); [EOL]     final Class<?>[] parameterTypes = method.getParameterTypes(); [EOL]     method = getAccessibleMethodFromInterfaceNest(cls, methodName, parameterTypes); [EOL]     if (method == null) { [EOL]         method = getAccessibleMethodFromSuperclass(cls, methodName, parameterTypes); [EOL]     } [EOL]     return method; [EOL] } 
 [LINE] private static Method getAccessibleMethodFromSuperclass(final Class<?> cls, [LINE] private static Method getAccessibleMethodFromSuperclass(final Class<?> cls, final String methodName, final Class<?>... parameterTypes) { [EOL]     Class<?> parentClass = cls.getSuperclass(); [EOL]     while (parentClass != null) { [EOL]         if (Modifier.isPublic(parentClass.getModifiers())) { [EOL]             try { [EOL]                 return parentClass.getMethod(methodName, parameterTypes); [EOL]             } catch (final NoSuchMethodException e) { [EOL]                 return null; [EOL]             } [EOL]         } [EOL]         parentClass = parentClass.getSuperclass(); [EOL]     } [EOL]     return null; [EOL] } 
 [LINE] Class<?> parentClass = cls.getSuperclass(); [LINE] private static Method getAccessibleMethodFromSuperclass(final Class<?> cls, final String methodName, final Class<?>... parameterTypes) { [EOL]     Class<?> parentClass = cls.getSuperclass(); [EOL]     while (parentClass != null) { [EOL]         if (Modifier.isPublic(parentClass.getModifiers())) { [EOL]             try { [EOL]                 return parentClass.getMethod(methodName, parameterTypes); [EOL]             } catch (final NoSuchMethodException e) { [EOL]                 return null; [EOL]             } [EOL]         } [EOL]         parentClass = parentClass.getSuperclass(); [EOL]     } [EOL]     return null; [EOL] } 
 [LINE] while (parentClass != null) { [LINE] private static Method getAccessibleMethodFromSuperclass(final Class<?> cls, final String methodName, final Class<?>... parameterTypes) { [EOL]     Class<?> parentClass = cls.getSuperclass(); [EOL]     while (parentClass != null) { [EOL]         if (Modifier.isPublic(parentClass.getModifiers())) { [EOL]             try { [EOL]                 return parentClass.getMethod(methodName, parameterTypes); [EOL]             } catch (final NoSuchMethodException e) { [EOL]                 return null; [EOL]             } [EOL]         } [EOL]         parentClass = parentClass.getSuperclass(); [EOL]     } [EOL]     return null; [EOL] } 
 [LINE] if (Modifier.isPublic(parentClass.getModifiers())) { [LINE] private static Method getAccessibleMethodFromSuperclass(final Class<?> cls, final String methodName, final Class<?>... parameterTypes) { [EOL]     Class<?> parentClass = cls.getSuperclass(); [EOL]     while (parentClass != null) { [EOL]         if (Modifier.isPublic(parentClass.getModifiers())) { [EOL]             try { [EOL]                 return parentClass.getMethod(methodName, parameterTypes); [EOL]             } catch (final NoSuchMethodException e) { [EOL]                 return null; [EOL]             } [EOL]         } [EOL]         parentClass = parentClass.getSuperclass(); [EOL]     } [EOL]     return null; [EOL] } 
 [LINE] try { [LINE] private static Method getAccessibleMethodFromSuperclass(final Class<?> cls, final String methodName, final Class<?>... parameterTypes) { [EOL]     Class<?> parentClass = cls.getSuperclass(); [EOL]     while (parentClass != null) { [EOL]         if (Modifier.isPublic(parentClass.getModifiers())) { [EOL]             try { [EOL]                 return parentClass.getMethod(methodName, parameterTypes); [EOL]             } catch (final NoSuchMethodException e) { [EOL]                 return null; [EOL]             } [EOL]         } [EOL]         parentClass = parentClass.getSuperclass(); [EOL]     } [EOL]     return null; [EOL] } 
 [LINE] return parentClass.getMethod(methodName, parameterTypes); [LINE] private static Method getAccessibleMethodFromSuperclass(final Class<?> cls, final String methodName, final Class<?>... parameterTypes) { [EOL]     Class<?> parentClass = cls.getSuperclass(); [EOL]     while (parentClass != null) { [EOL]         if (Modifier.isPublic(parentClass.getModifiers())) { [EOL]             try { [EOL]                 return parentClass.getMethod(methodName, parameterTypes); [EOL]             } catch (final NoSuchMethodException e) { [EOL]                 return null; [EOL]             } [EOL]         } [EOL]         parentClass = parentClass.getSuperclass(); [EOL]     } [EOL]     return null; [EOL] } 
 [LINE] return null; [LINE] private static Method getAccessibleMethodFromSuperclass(final Class<?> cls, final String methodName, final Class<?>... parameterTypes) { [EOL]     Class<?> parentClass = cls.getSuperclass(); [EOL]     while (parentClass != null) { [EOL]         if (Modifier.isPublic(parentClass.getModifiers())) { [EOL]             try { [EOL]                 return parentClass.getMethod(methodName, parameterTypes); [EOL]             } catch (final NoSuchMethodException e) { [EOL]                 return null; [EOL]             } [EOL]         } [EOL]         parentClass = parentClass.getSuperclass(); [EOL]     } [EOL]     return null; [EOL] } 
 [LINE] private static Method getAccessibleMethodFromInterfaceNest(Class<?> cls, [LINE] private static Method getAccessibleMethodFromInterfaceNest(Class<?> cls, final String methodName, final Class<?>... parameterTypes) { [EOL]     Method method = null; [EOL]     for (; cls != null; cls = cls.getSuperclass()) { [EOL]         final Class<?>[] interfaces = cls.getInterfaces(); [EOL]         for (int i = 0; i < interfaces.length; i++) { [EOL]             if (!Modifier.isPublic(interfaces[i].getModifiers())) { [EOL]                 continue; [EOL]             } [EOL]             try { [EOL]                 method = interfaces[i].getDeclaredMethod(methodName, parameterTypes); [EOL]             } catch (final NoSuchMethodException e) { [EOL]             } [EOL]             if (method != null) { [EOL]                 break; [EOL]             } [EOL]             method = getAccessibleMethodFromInterfaceNest(interfaces[i], methodName, parameterTypes); [EOL]             if (method != null) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     return method; [EOL] } 
 [LINE] Method method = null; [LINE] private static Method getAccessibleMethodFromInterfaceNest(Class<?> cls, final String methodName, final Class<?>... parameterTypes) { [EOL]     Method method = null; [EOL]     for (; cls != null; cls = cls.getSuperclass()) { [EOL]         final Class<?>[] interfaces = cls.getInterfaces(); [EOL]         for (int i = 0; i < interfaces.length; i++) { [EOL]             if (!Modifier.isPublic(interfaces[i].getModifiers())) { [EOL]                 continue; [EOL]             } [EOL]             try { [EOL]                 method = interfaces[i].getDeclaredMethod(methodName, parameterTypes); [EOL]             } catch (final NoSuchMethodException e) { [EOL]             } [EOL]             if (method != null) { [EOL]                 break; [EOL]             } [EOL]             method = getAccessibleMethodFromInterfaceNest(interfaces[i], methodName, parameterTypes); [EOL]             if (method != null) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     return method; [EOL] } 
 [LINE] for (; cls != null; cls = cls.getSuperclass()) { [LINE] private static Method getAccessibleMethodFromInterfaceNest(Class<?> cls, final String methodName, final Class<?>... parameterTypes) { [EOL]     Method method = null; [EOL]     for (; cls != null; cls = cls.getSuperclass()) { [EOL]         final Class<?>[] interfaces = cls.getInterfaces(); [EOL]         for (int i = 0; i < interfaces.length; i++) { [EOL]             if (!Modifier.isPublic(interfaces[i].getModifiers())) { [EOL]                 continue; [EOL]             } [EOL]             try { [EOL]                 method = interfaces[i].getDeclaredMethod(methodName, parameterTypes); [EOL]             } catch (final NoSuchMethodException e) { [EOL]             } [EOL]             if (method != null) { [EOL]                 break; [EOL]             } [EOL]             method = getAccessibleMethodFromInterfaceNest(interfaces[i], methodName, parameterTypes); [EOL]             if (method != null) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     return method; [EOL] } 
 [LINE] final Class<?>[] interfaces = cls.getInterfaces(); [LINE] private static Method getAccessibleMethodFromInterfaceNest(Class<?> cls, final String methodName, final Class<?>... parameterTypes) { [EOL]     Method method = null; [EOL]     for (; cls != null; cls = cls.getSuperclass()) { [EOL]         final Class<?>[] interfaces = cls.getInterfaces(); [EOL]         for (int i = 0; i < interfaces.length; i++) { [EOL]             if (!Modifier.isPublic(interfaces[i].getModifiers())) { [EOL]                 continue; [EOL]             } [EOL]             try { [EOL]                 method = interfaces[i].getDeclaredMethod(methodName, parameterTypes); [EOL]             } catch (final NoSuchMethodException e) { [EOL]             } [EOL]             if (method != null) { [EOL]                 break; [EOL]             } [EOL]             method = getAccessibleMethodFromInterfaceNest(interfaces[i], methodName, parameterTypes); [EOL]             if (method != null) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     return method; [EOL] } 
 [LINE] for (int i = 0; i < interfaces.length; i++) { [LINE] private static Method getAccessibleMethodFromInterfaceNest(Class<?> cls, final String methodName, final Class<?>... parameterTypes) { [EOL]     Method method = null; [EOL]     for (; cls != null; cls = cls.getSuperclass()) { [EOL]         final Class<?>[] interfaces = cls.getInterfaces(); [EOL]         for (int i = 0; i < interfaces.length; i++) { [EOL]             if (!Modifier.isPublic(interfaces[i].getModifiers())) { [EOL]                 continue; [EOL]             } [EOL]             try { [EOL]                 method = interfaces[i].getDeclaredMethod(methodName, parameterTypes); [EOL]             } catch (final NoSuchMethodException e) { [EOL]             } [EOL]             if (method != null) { [EOL]                 break; [EOL]             } [EOL]             method = getAccessibleMethodFromInterfaceNest(interfaces[i], methodName, parameterTypes); [EOL]             if (method != null) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     return method; [EOL] } 
 [LINE] if (!Modifier.isPublic(interfaces[i].getModifiers())) { [LINE] private static Method getAccessibleMethodFromInterfaceNest(Class<?> cls, final String methodName, final Class<?>... parameterTypes) { [EOL]     Method method = null; [EOL]     for (; cls != null; cls = cls.getSuperclass()) { [EOL]         final Class<?>[] interfaces = cls.getInterfaces(); [EOL]         for (int i = 0; i < interfaces.length; i++) { [EOL]             if (!Modifier.isPublic(interfaces[i].getModifiers())) { [EOL]                 continue; [EOL]             } [EOL]             try { [EOL]                 method = interfaces[i].getDeclaredMethod(methodName, parameterTypes); [EOL]             } catch (final NoSuchMethodException e) { [EOL]             } [EOL]             if (method != null) { [EOL]                 break; [EOL]             } [EOL]             method = getAccessibleMethodFromInterfaceNest(interfaces[i], methodName, parameterTypes); [EOL]             if (method != null) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     return method; [EOL] } 
 [LINE] continue; [LINE] private static Method getAccessibleMethodFromInterfaceNest(Class<?> cls, final String methodName, final Class<?>... parameterTypes) { [EOL]     Method method = null; [EOL]     for (; cls != null; cls = cls.getSuperclass()) { [EOL]         final Class<?>[] interfaces = cls.getInterfaces(); [EOL]         for (int i = 0; i < interfaces.length; i++) { [EOL]             if (!Modifier.isPublic(interfaces[i].getModifiers())) { [EOL]                 continue; [EOL]             } [EOL]             try { [EOL]                 method = interfaces[i].getDeclaredMethod(methodName, parameterTypes); [EOL]             } catch (final NoSuchMethodException e) { [EOL]             } [EOL]             if (method != null) { [EOL]                 break; [EOL]             } [EOL]             method = getAccessibleMethodFromInterfaceNest(interfaces[i], methodName, parameterTypes); [EOL]             if (method != null) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     return method; [EOL] } 
 [LINE] try { [LINE] private static Method getAccessibleMethodFromInterfaceNest(Class<?> cls, final String methodName, final Class<?>... parameterTypes) { [EOL]     Method method = null; [EOL]     for (; cls != null; cls = cls.getSuperclass()) { [EOL]         final Class<?>[] interfaces = cls.getInterfaces(); [EOL]         for (int i = 0; i < interfaces.length; i++) { [EOL]             if (!Modifier.isPublic(interfaces[i].getModifiers())) { [EOL]                 continue; [EOL]             } [EOL]             try { [EOL]                 method = interfaces[i].getDeclaredMethod(methodName, parameterTypes); [EOL]             } catch (final NoSuchMethodException e) { [EOL]             } [EOL]             if (method != null) { [EOL]                 break; [EOL]             } [EOL]             method = getAccessibleMethodFromInterfaceNest(interfaces[i], methodName, parameterTypes); [EOL]             if (method != null) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     return method; [EOL] } 
 [LINE] method = interfaces[i].getDeclaredMethod(methodName, [LINE] private static Method getAccessibleMethodFromInterfaceNest(Class<?> cls, final String methodName, final Class<?>... parameterTypes) { [EOL]     Method method = null; [EOL]     for (; cls != null; cls = cls.getSuperclass()) { [EOL]         final Class<?>[] interfaces = cls.getInterfaces(); [EOL]         for (int i = 0; i < interfaces.length; i++) { [EOL]             if (!Modifier.isPublic(interfaces[i].getModifiers())) { [EOL]                 continue; [EOL]             } [EOL]             try { [EOL]                 method = interfaces[i].getDeclaredMethod(methodName, parameterTypes); [EOL]             } catch (final NoSuchMethodException e) { [EOL]             } [EOL]             if (method != null) { [EOL]                 break; [EOL]             } [EOL]             method = getAccessibleMethodFromInterfaceNest(interfaces[i], methodName, parameterTypes); [EOL]             if (method != null) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     return method; [EOL] } 
 [LINE] if (method != null) { [LINE] private static Method getAccessibleMethodFromInterfaceNest(Class<?> cls, final String methodName, final Class<?>... parameterTypes) { [EOL]     Method method = null; [EOL]     for (; cls != null; cls = cls.getSuperclass()) { [EOL]         final Class<?>[] interfaces = cls.getInterfaces(); [EOL]         for (int i = 0; i < interfaces.length; i++) { [EOL]             if (!Modifier.isPublic(interfaces[i].getModifiers())) { [EOL]                 continue; [EOL]             } [EOL]             try { [EOL]                 method = interfaces[i].getDeclaredMethod(methodName, parameterTypes); [EOL]             } catch (final NoSuchMethodException e) { [EOL]             } [EOL]             if (method != null) { [EOL]                 break; [EOL]             } [EOL]             method = getAccessibleMethodFromInterfaceNest(interfaces[i], methodName, parameterTypes); [EOL]             if (method != null) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     return method; [EOL] } 
 [LINE] break; [LINE] private static Method getAccessibleMethodFromInterfaceNest(Class<?> cls, final String methodName, final Class<?>... parameterTypes) { [EOL]     Method method = null; [EOL]     for (; cls != null; cls = cls.getSuperclass()) { [EOL]         final Class<?>[] interfaces = cls.getInterfaces(); [EOL]         for (int i = 0; i < interfaces.length; i++) { [EOL]             if (!Modifier.isPublic(interfaces[i].getModifiers())) { [EOL]                 continue; [EOL]             } [EOL]             try { [EOL]                 method = interfaces[i].getDeclaredMethod(methodName, parameterTypes); [EOL]             } catch (final NoSuchMethodException e) { [EOL]             } [EOL]             if (method != null) { [EOL]                 break; [EOL]             } [EOL]             method = getAccessibleMethodFromInterfaceNest(interfaces[i], methodName, parameterTypes); [EOL]             if (method != null) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     return method; [EOL] } 
 [LINE] return method; [LINE] private static Method getAccessibleMethodFromInterfaceNest(Class<?> cls, final String methodName, final Class<?>... parameterTypes) { [EOL]     Method method = null; [EOL]     for (; cls != null; cls = cls.getSuperclass()) { [EOL]         final Class<?>[] interfaces = cls.getInterfaces(); [EOL]         for (int i = 0; i < interfaces.length; i++) { [EOL]             if (!Modifier.isPublic(interfaces[i].getModifiers())) { [EOL]                 continue; [EOL]             } [EOL]             try { [EOL]                 method = interfaces[i].getDeclaredMethod(methodName, parameterTypes); [EOL]             } catch (final NoSuchMethodException e) { [EOL]             } [EOL]             if (method != null) { [EOL]                 break; [EOL]             } [EOL]             method = getAccessibleMethodFromInterfaceNest(interfaces[i], methodName, parameterTypes); [EOL]             if (method != null) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     return method; [EOL] } 
 [LINE] final Method accessibleMethod = getAccessibleMethod(method); [LINE] public static Method getMatchingAccessibleMethod(final Class<?> cls, final String methodName, final Class<?>... parameterTypes) { [EOL]     try { [EOL]         final Method method = cls.getMethod(methodName, parameterTypes); [EOL]         MemberUtils.setAccessibleWorkaround(method); [EOL]         return method; [EOL]     } catch (final NoSuchMethodException e) { [EOL]     } [EOL]     Method bestMatch = null; [EOL]     final Method[] methods = cls.getMethods(); [EOL]     for (final Method method : methods) { [EOL]         if (method.getName().equals(methodName) && ClassUtils.isAssignable(parameterTypes, method.getParameterTypes(), true)) { [EOL]             final Method accessibleMethod = getAccessibleMethod(method); [EOL]             if (accessibleMethod != null && (bestMatch == null || MemberUtils.compareParameterTypes(accessibleMethod.getParameterTypes(), bestMatch.getParameterTypes(), parameterTypes) < 0)) { [EOL]                 bestMatch = accessibleMethod; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (bestMatch != null) { [EOL]         MemberUtils.setAccessibleWorkaround(bestMatch); [EOL]     } [EOL]     return bestMatch; [EOL] } 
 [LINE] if (accessibleMethod != null && (bestMatch == null || MemberUtils.compareParameterTypes( [LINE] public static Method getMatchingAccessibleMethod(final Class<?> cls, final String methodName, final Class<?>... parameterTypes) { [EOL]     try { [EOL]         final Method method = cls.getMethod(methodName, parameterTypes); [EOL]         MemberUtils.setAccessibleWorkaround(method); [EOL]         return method; [EOL]     } catch (final NoSuchMethodException e) { [EOL]     } [EOL]     Method bestMatch = null; [EOL]     final Method[] methods = cls.getMethods(); [EOL]     for (final Method method : methods) { [EOL]         if (method.getName().equals(methodName) && ClassUtils.isAssignable(parameterTypes, method.getParameterTypes(), true)) { [EOL]             final Method accessibleMethod = getAccessibleMethod(method); [EOL]             if (accessibleMethod != null && (bestMatch == null || MemberUtils.compareParameterTypes(accessibleMethod.getParameterTypes(), bestMatch.getParameterTypes(), parameterTypes) < 0)) { [EOL]                 bestMatch = accessibleMethod; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (bestMatch != null) { [EOL]         MemberUtils.setAccessibleWorkaround(bestMatch); [EOL]     } [EOL]     return bestMatch; [EOL] } 
 [LINE] bestMatch = accessibleMethod; [LINE] public static Method getMatchingAccessibleMethod(final Class<?> cls, final String methodName, final Class<?>... parameterTypes) { [EOL]     try { [EOL]         final Method method = cls.getMethod(methodName, parameterTypes); [EOL]         MemberUtils.setAccessibleWorkaround(method); [EOL]         return method; [EOL]     } catch (final NoSuchMethodException e) { [EOL]     } [EOL]     Method bestMatch = null; [EOL]     final Method[] methods = cls.getMethods(); [EOL]     for (final Method method : methods) { [EOL]         if (method.getName().equals(methodName) && ClassUtils.isAssignable(parameterTypes, method.getParameterTypes(), true)) { [EOL]             final Method accessibleMethod = getAccessibleMethod(method); [EOL]             if (accessibleMethod != null && (bestMatch == null || MemberUtils.compareParameterTypes(accessibleMethod.getParameterTypes(), bestMatch.getParameterTypes(), parameterTypes) < 0)) { [EOL]                 bestMatch = accessibleMethod; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (bestMatch != null) { [EOL]         MemberUtils.setAccessibleWorkaround(bestMatch); [EOL]     } [EOL]     return bestMatch; [EOL] } 
 [LINE] MemberUtils.setAccessibleWorkaround(bestMatch); [LINE] public static Method getMatchingAccessibleMethod(final Class<?> cls, final String methodName, final Class<?>... parameterTypes) { [EOL]     try { [EOL]         final Method method = cls.getMethod(methodName, parameterTypes); [EOL]         MemberUtils.setAccessibleWorkaround(method); [EOL]         return method; [EOL]     } catch (final NoSuchMethodException e) { [EOL]     } [EOL]     Method bestMatch = null; [EOL]     final Method[] methods = cls.getMethods(); [EOL]     for (final Method method : methods) { [EOL]         if (method.getName().equals(methodName) && ClassUtils.isAssignable(parameterTypes, method.getParameterTypes(), true)) { [EOL]             final Method accessibleMethod = getAccessibleMethod(method); [EOL]             if (accessibleMethod != null && (bestMatch == null || MemberUtils.compareParameterTypes(accessibleMethod.getParameterTypes(), bestMatch.getParameterTypes(), parameterTypes) < 0)) { [EOL]                 bestMatch = accessibleMethod; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (bestMatch != null) { [EOL]         MemberUtils.setAccessibleWorkaround(bestMatch); [EOL]     } [EOL]     return bestMatch; [EOL] } 
 [LINE] private BasicThreadFactory(final Builder builder) { [LINE] private BasicThreadFactory(final Builder builder) { [EOL]     if (builder.wrappedFactory == null) { [EOL]         wrappedFactory = Executors.defaultThreadFactory(); [EOL]     } else { [EOL]         wrappedFactory = builder.wrappedFactory; [EOL]     } [EOL]     namingPattern = builder.namingPattern; [EOL]     priority = builder.priority; [EOL]     daemonFlag = builder.daemonFlag; [EOL]     uncaughtExceptionHandler = builder.exceptionHandler; [EOL]     threadCounter = new AtomicLong(); [EOL] } 
 [LINE] if (builder.wrappedFactory == null) { [LINE] private BasicThreadFactory(final Builder builder) { [EOL]     if (builder.wrappedFactory == null) { [EOL]         wrappedFactory = Executors.defaultThreadFactory(); [EOL]     } else { [EOL]         wrappedFactory = builder.wrappedFactory; [EOL]     } [EOL]     namingPattern = builder.namingPattern; [EOL]     priority = builder.priority; [EOL]     daemonFlag = builder.daemonFlag; [EOL]     uncaughtExceptionHandler = builder.exceptionHandler; [EOL]     threadCounter = new AtomicLong(); [EOL] } 
 [LINE] wrappedFactory = Executors.defaultThreadFactory(); [LINE] private BasicThreadFactory(final Builder builder) { [EOL]     if (builder.wrappedFactory == null) { [EOL]         wrappedFactory = Executors.defaultThreadFactory(); [EOL]     } else { [EOL]         wrappedFactory = builder.wrappedFactory; [EOL]     } [EOL]     namingPattern = builder.namingPattern; [EOL]     priority = builder.priority; [EOL]     daemonFlag = builder.daemonFlag; [EOL]     uncaughtExceptionHandler = builder.exceptionHandler; [EOL]     threadCounter = new AtomicLong(); [EOL] } 
 [LINE] wrappedFactory = builder.wrappedFactory; [LINE] private BasicThreadFactory(final Builder builder) { [EOL]     if (builder.wrappedFactory == null) { [EOL]         wrappedFactory = Executors.defaultThreadFactory(); [EOL]     } else { [EOL]         wrappedFactory = builder.wrappedFactory; [EOL]     } [EOL]     namingPattern = builder.namingPattern; [EOL]     priority = builder.priority; [EOL]     daemonFlag = builder.daemonFlag; [EOL]     uncaughtExceptionHandler = builder.exceptionHandler; [EOL]     threadCounter = new AtomicLong(); [EOL] } 
 [LINE] namingPattern = builder.namingPattern; [LINE] private BasicThreadFactory(final Builder builder) { [EOL]     if (builder.wrappedFactory == null) { [EOL]         wrappedFactory = Executors.defaultThreadFactory(); [EOL]     } else { [EOL]         wrappedFactory = builder.wrappedFactory; [EOL]     } [EOL]     namingPattern = builder.namingPattern; [EOL]     priority = builder.priority; [EOL]     daemonFlag = builder.daemonFlag; [EOL]     uncaughtExceptionHandler = builder.exceptionHandler; [EOL]     threadCounter = new AtomicLong(); [EOL] } 
 [LINE] priority = builder.priority; [LINE] private BasicThreadFactory(final Builder builder) { [EOL]     if (builder.wrappedFactory == null) { [EOL]         wrappedFactory = Executors.defaultThreadFactory(); [EOL]     } else { [EOL]         wrappedFactory = builder.wrappedFactory; [EOL]     } [EOL]     namingPattern = builder.namingPattern; [EOL]     priority = builder.priority; [EOL]     daemonFlag = builder.daemonFlag; [EOL]     uncaughtExceptionHandler = builder.exceptionHandler; [EOL]     threadCounter = new AtomicLong(); [EOL] } 
 [LINE] daemonFlag = builder.daemonFlag; [LINE] private BasicThreadFactory(final Builder builder) { [EOL]     if (builder.wrappedFactory == null) { [EOL]         wrappedFactory = Executors.defaultThreadFactory(); [EOL]     } else { [EOL]         wrappedFactory = builder.wrappedFactory; [EOL]     } [EOL]     namingPattern = builder.namingPattern; [EOL]     priority = builder.priority; [EOL]     daemonFlag = builder.daemonFlag; [EOL]     uncaughtExceptionHandler = builder.exceptionHandler; [EOL]     threadCounter = new AtomicLong(); [EOL] } 
 [LINE] uncaughtExceptionHandler = builder.exceptionHandler; [LINE] private BasicThreadFactory(final Builder builder) { [EOL]     if (builder.wrappedFactory == null) { [EOL]         wrappedFactory = Executors.defaultThreadFactory(); [EOL]     } else { [EOL]         wrappedFactory = builder.wrappedFactory; [EOL]     } [EOL]     namingPattern = builder.namingPattern; [EOL]     priority = builder.priority; [EOL]     daemonFlag = builder.daemonFlag; [EOL]     uncaughtExceptionHandler = builder.exceptionHandler; [EOL]     threadCounter = new AtomicLong(); [EOL] } 
 [LINE] threadCounter = new AtomicLong(); [LINE] private BasicThreadFactory(final Builder builder) { [EOL]     if (builder.wrappedFactory == null) { [EOL]         wrappedFactory = Executors.defaultThreadFactory(); [EOL]     } else { [EOL]         wrappedFactory = builder.wrappedFactory; [EOL]     } [EOL]     namingPattern = builder.namingPattern; [EOL]     priority = builder.priority; [EOL]     daemonFlag = builder.daemonFlag; [EOL]     uncaughtExceptionHandler = builder.exceptionHandler; [EOL]     threadCounter = new AtomicLong(); [EOL] } 
 [LINE] public final ThreadFactory getWrappedFactory() { [LINE] public final ThreadFactory getWrappedFactory() { [EOL]     return wrappedFactory; [EOL] } 
 [LINE] return wrappedFactory; [LINE] public final ThreadFactory getWrappedFactory() { [EOL]     return wrappedFactory; [EOL] } 
 [LINE] public final String getNamingPattern() { [LINE] public final String getNamingPattern() { [EOL]     return namingPattern; [EOL] } 
 [LINE] return namingPattern; [LINE] public final String getNamingPattern() { [EOL]     return namingPattern; [EOL] } 
 [LINE] public final Boolean getDaemonFlag() { [LINE] public final Boolean getDaemonFlag() { [EOL]     return daemonFlag; [EOL] } 
 [LINE] return daemonFlag; [LINE] public final Boolean getDaemonFlag() { [EOL]     return daemonFlag; [EOL] } 
 [LINE] public final Integer getPriority() { [LINE] public final Integer getPriority() { [EOL]     return priority; [EOL] } 
 [LINE] return priority; [LINE] public final Integer getPriority() { [EOL]     return priority; [EOL] } 
 [LINE] public final Thread.UncaughtExceptionHandler getUncaughtExceptionHandler() { [LINE] public final Thread.UncaughtExceptionHandler getUncaughtExceptionHandler() { [EOL]     return uncaughtExceptionHandler; [EOL] } 
 [LINE] return uncaughtExceptionHandler; [LINE] public final Thread.UncaughtExceptionHandler getUncaughtExceptionHandler() { [EOL]     return uncaughtExceptionHandler; [EOL] } 
 [LINE] public long getThreadCount() { [LINE] public long getThreadCount() { [EOL]     return threadCounter.get(); [EOL] } 
 [LINE] return threadCounter.get(); [LINE] public long getThreadCount() { [EOL]     return threadCounter.get(); [EOL] } 
 [LINE] @Override [LINE] @Override [EOL] public Thread newThread(final Runnable r) { [EOL]     final Thread t = getWrappedFactory().newThread(r); [EOL]     initializeThread(t); [EOL]     return t; [EOL] } 
 [LINE] final Thread t = getWrappedFactory().newThread(r); [LINE] @Override [EOL] public Thread newThread(final Runnable r) { [EOL]     final Thread t = getWrappedFactory().newThread(r); [EOL]     initializeThread(t); [EOL]     return t; [EOL] } 
 [LINE] initializeThread(t); [LINE] @Override [EOL] public Thread newThread(final Runnable r) { [EOL]     final Thread t = getWrappedFactory().newThread(r); [EOL]     initializeThread(t); [EOL]     return t; [EOL] } 
 [LINE] return t; [LINE] @Override [EOL] public Thread newThread(final Runnable r) { [EOL]     final Thread t = getWrappedFactory().newThread(r); [EOL]     initializeThread(t); [EOL]     return t; [EOL] } 
 [LINE] private void initializeThread(final Thread t) { [LINE] private void initializeThread(final Thread t) { [EOL]     if (getNamingPattern() != null) { [EOL]         final Long count = Long.valueOf(threadCounter.incrementAndGet()); [EOL]         t.setName(String.format(getNamingPattern(), count)); [EOL]     } [EOL]     if (getUncaughtExceptionHandler() != null) { [EOL]         t.setUncaughtExceptionHandler(getUncaughtExceptionHandler()); [EOL]     } [EOL]     if (getPriority() != null) { [EOL]         t.setPriority(getPriority().intValue()); [EOL]     } [EOL]     if (getDaemonFlag() != null) { [EOL]         t.setDaemon(getDaemonFlag().booleanValue()); [EOL]     } [EOL] } 
 [LINE] if (getNamingPattern() != null) { [LINE] private void initializeThread(final Thread t) { [EOL]     if (getNamingPattern() != null) { [EOL]         final Long count = Long.valueOf(threadCounter.incrementAndGet()); [EOL]         t.setName(String.format(getNamingPattern(), count)); [EOL]     } [EOL]     if (getUncaughtExceptionHandler() != null) { [EOL]         t.setUncaughtExceptionHandler(getUncaughtExceptionHandler()); [EOL]     } [EOL]     if (getPriority() != null) { [EOL]         t.setPriority(getPriority().intValue()); [EOL]     } [EOL]     if (getDaemonFlag() != null) { [EOL]         t.setDaemon(getDaemonFlag().booleanValue()); [EOL]     } [EOL] } 
 [LINE] final Long count = Long.valueOf(threadCounter.incrementAndGet()); [LINE] private void initializeThread(final Thread t) { [EOL]     if (getNamingPattern() != null) { [EOL]         final Long count = Long.valueOf(threadCounter.incrementAndGet()); [EOL]         t.setName(String.format(getNamingPattern(), count)); [EOL]     } [EOL]     if (getUncaughtExceptionHandler() != null) { [EOL]         t.setUncaughtExceptionHandler(getUncaughtExceptionHandler()); [EOL]     } [EOL]     if (getPriority() != null) { [EOL]         t.setPriority(getPriority().intValue()); [EOL]     } [EOL]     if (getDaemonFlag() != null) { [EOL]         t.setDaemon(getDaemonFlag().booleanValue()); [EOL]     } [EOL] } 
 [LINE] t.setName(String.format(getNamingPattern(), count)); [LINE] private void initializeThread(final Thread t) { [EOL]     if (getNamingPattern() != null) { [EOL]         final Long count = Long.valueOf(threadCounter.incrementAndGet()); [EOL]         t.setName(String.format(getNamingPattern(), count)); [EOL]     } [EOL]     if (getUncaughtExceptionHandler() != null) { [EOL]         t.setUncaughtExceptionHandler(getUncaughtExceptionHandler()); [EOL]     } [EOL]     if (getPriority() != null) { [EOL]         t.setPriority(getPriority().intValue()); [EOL]     } [EOL]     if (getDaemonFlag() != null) { [EOL]         t.setDaemon(getDaemonFlag().booleanValue()); [EOL]     } [EOL] } 
 [LINE] if (getUncaughtExceptionHandler() != null) { [LINE] private void initializeThread(final Thread t) { [EOL]     if (getNamingPattern() != null) { [EOL]         final Long count = Long.valueOf(threadCounter.incrementAndGet()); [EOL]         t.setName(String.format(getNamingPattern(), count)); [EOL]     } [EOL]     if (getUncaughtExceptionHandler() != null) { [EOL]         t.setUncaughtExceptionHandler(getUncaughtExceptionHandler()); [EOL]     } [EOL]     if (getPriority() != null) { [EOL]         t.setPriority(getPriority().intValue()); [EOL]     } [EOL]     if (getDaemonFlag() != null) { [EOL]         t.setDaemon(getDaemonFlag().booleanValue()); [EOL]     } [EOL] } 
 [LINE] t.setUncaughtExceptionHandler(getUncaughtExceptionHandler()); [LINE] private void initializeThread(final Thread t) { [EOL]     if (getNamingPattern() != null) { [EOL]         final Long count = Long.valueOf(threadCounter.incrementAndGet()); [EOL]         t.setName(String.format(getNamingPattern(), count)); [EOL]     } [EOL]     if (getUncaughtExceptionHandler() != null) { [EOL]         t.setUncaughtExceptionHandler(getUncaughtExceptionHandler()); [EOL]     } [EOL]     if (getPriority() != null) { [EOL]         t.setPriority(getPriority().intValue()); [EOL]     } [EOL]     if (getDaemonFlag() != null) { [EOL]         t.setDaemon(getDaemonFlag().booleanValue()); [EOL]     } [EOL] } 
 [LINE] if (getPriority() != null) { [LINE] private void initializeThread(final Thread t) { [EOL]     if (getNamingPattern() != null) { [EOL]         final Long count = Long.valueOf(threadCounter.incrementAndGet()); [EOL]         t.setName(String.format(getNamingPattern(), count)); [EOL]     } [EOL]     if (getUncaughtExceptionHandler() != null) { [EOL]         t.setUncaughtExceptionHandler(getUncaughtExceptionHandler()); [EOL]     } [EOL]     if (getPriority() != null) { [EOL]         t.setPriority(getPriority().intValue()); [EOL]     } [EOL]     if (getDaemonFlag() != null) { [EOL]         t.setDaemon(getDaemonFlag().booleanValue()); [EOL]     } [EOL] } 
 [LINE] t.setPriority(getPriority().intValue()); [LINE] private void initializeThread(final Thread t) { [EOL]     if (getNamingPattern() != null) { [EOL]         final Long count = Long.valueOf(threadCounter.incrementAndGet()); [EOL]         t.setName(String.format(getNamingPattern(), count)); [EOL]     } [EOL]     if (getUncaughtExceptionHandler() != null) { [EOL]         t.setUncaughtExceptionHandler(getUncaughtExceptionHandler()); [EOL]     } [EOL]     if (getPriority() != null) { [EOL]         t.setPriority(getPriority().intValue()); [EOL]     } [EOL]     if (getDaemonFlag() != null) { [EOL]         t.setDaemon(getDaemonFlag().booleanValue()); [EOL]     } [EOL] } 
 [LINE] if (getDaemonFlag() != null) { [LINE] private void initializeThread(final Thread t) { [EOL]     if (getNamingPattern() != null) { [EOL]         final Long count = Long.valueOf(threadCounter.incrementAndGet()); [EOL]         t.setName(String.format(getNamingPattern(), count)); [EOL]     } [EOL]     if (getUncaughtExceptionHandler() != null) { [EOL]         t.setUncaughtExceptionHandler(getUncaughtExceptionHandler()); [EOL]     } [EOL]     if (getPriority() != null) { [EOL]         t.setPriority(getPriority().intValue()); [EOL]     } [EOL]     if (getDaemonFlag() != null) { [EOL]         t.setDaemon(getDaemonFlag().booleanValue()); [EOL]     } [EOL] } 
 [LINE] t.setDaemon(getDaemonFlag().booleanValue()); [LINE] private void initializeThread(final Thread t) { [EOL]     if (getNamingPattern() != null) { [EOL]         final Long count = Long.valueOf(threadCounter.incrementAndGet()); [EOL]         t.setName(String.format(getNamingPattern(), count)); [EOL]     } [EOL]     if (getUncaughtExceptionHandler() != null) { [EOL]         t.setUncaughtExceptionHandler(getUncaughtExceptionHandler()); [EOL]     } [EOL]     if (getPriority() != null) { [EOL]         t.setPriority(getPriority().intValue()); [EOL]     } [EOL]     if (getDaemonFlag() != null) { [EOL]         t.setDaemon(getDaemonFlag().booleanValue()); [EOL]     } [EOL] } 
 [LINE] public Builder wrappedFactory(final ThreadFactory factory) { [LINE] public Builder wrappedFactory(final ThreadFactory factory) { [EOL]     if (factory == null) { [EOL]         throw new NullPointerException("Wrapped ThreadFactory must not be null!"); [EOL]     } [EOL]     wrappedFactory = factory; [EOL]     return this; [EOL] } 
 [LINE] if (factory == null) { [LINE] public Builder wrappedFactory(final ThreadFactory factory) { [EOL]     if (factory == null) { [EOL]         throw new NullPointerException("Wrapped ThreadFactory must not be null!"); [EOL]     } [EOL]     wrappedFactory = factory; [EOL]     return this; [EOL] } 
 [LINE] throw new NullPointerException( [LINE] public Builder wrappedFactory(final ThreadFactory factory) { [EOL]     if (factory == null) { [EOL]         throw new NullPointerException("Wrapped ThreadFactory must not be null!"); [EOL]     } [EOL]     wrappedFactory = factory; [EOL]     return this; [EOL] } 
 [LINE] wrappedFactory = factory; [LINE] public Builder wrappedFactory(final ThreadFactory factory) { [EOL]     if (factory == null) { [EOL]         throw new NullPointerException("Wrapped ThreadFactory must not be null!"); [EOL]     } [EOL]     wrappedFactory = factory; [EOL]     return this; [EOL] } 
 [LINE] return this; [LINE] public Builder wrappedFactory(final ThreadFactory factory) { [EOL]     if (factory == null) { [EOL]         throw new NullPointerException("Wrapped ThreadFactory must not be null!"); [EOL]     } [EOL]     wrappedFactory = factory; [EOL]     return this; [EOL] } 
 [LINE] public Builder namingPattern(final String pattern) { [LINE] public Builder namingPattern(final String pattern) { [EOL]     if (pattern == null) { [EOL]         throw new NullPointerException("Naming pattern must not be null!"); [EOL]     } [EOL]     namingPattern = pattern; [EOL]     return this; [EOL] } 
 [LINE] if (pattern == null) { [LINE] public Builder namingPattern(final String pattern) { [EOL]     if (pattern == null) { [EOL]         throw new NullPointerException("Naming pattern must not be null!"); [EOL]     } [EOL]     namingPattern = pattern; [EOL]     return this; [EOL] } 
 [LINE] throw new NullPointerException( [LINE] public Builder namingPattern(final String pattern) { [EOL]     if (pattern == null) { [EOL]         throw new NullPointerException("Naming pattern must not be null!"); [EOL]     } [EOL]     namingPattern = pattern; [EOL]     return this; [EOL] } 
 [LINE] namingPattern = pattern; [LINE] public Builder namingPattern(final String pattern) { [EOL]     if (pattern == null) { [EOL]         throw new NullPointerException("Naming pattern must not be null!"); [EOL]     } [EOL]     namingPattern = pattern; [EOL]     return this; [EOL] } 
 [LINE] return this; [LINE] public Builder namingPattern(final String pattern) { [EOL]     if (pattern == null) { [EOL]         throw new NullPointerException("Naming pattern must not be null!"); [EOL]     } [EOL]     namingPattern = pattern; [EOL]     return this; [EOL] } 
 [LINE] public Builder daemon(final boolean f) { [LINE] public Builder daemon(final boolean f) { [EOL]     daemonFlag = Boolean.valueOf(f); [EOL]     return this; [EOL] } 
 [LINE] daemonFlag = Boolean.valueOf(f); [LINE] public Builder daemon(final boolean f) { [EOL]     daemonFlag = Boolean.valueOf(f); [EOL]     return this; [EOL] } 
 [LINE] return this; [LINE] public Builder daemon(final boolean f) { [EOL]     daemonFlag = Boolean.valueOf(f); [EOL]     return this; [EOL] } 
 [LINE] public Builder priority(final int prio) { [LINE] public Builder priority(final int prio) { [EOL]     priority = Integer.valueOf(prio); [EOL]     return this; [EOL] } 
 [LINE] priority = Integer.valueOf(prio); [LINE] public Builder priority(final int prio) { [EOL]     priority = Integer.valueOf(prio); [EOL]     return this; [EOL] } 
 [LINE] return this; [LINE] public Builder priority(final int prio) { [EOL]     priority = Integer.valueOf(prio); [EOL]     return this; [EOL] } 
 [LINE] public Builder uncaughtExceptionHandler( [LINE] public Builder uncaughtExceptionHandler(final Thread.UncaughtExceptionHandler handler) { [EOL]     if (handler == null) { [EOL]         throw new NullPointerException("Uncaught exception handler must not be null!"); [EOL]     } [EOL]     exceptionHandler = handler; [EOL]     return this; [EOL] } 
 [LINE] if (handler == null) { [LINE] public Builder uncaughtExceptionHandler(final Thread.UncaughtExceptionHandler handler) { [EOL]     if (handler == null) { [EOL]         throw new NullPointerException("Uncaught exception handler must not be null!"); [EOL]     } [EOL]     exceptionHandler = handler; [EOL]     return this; [EOL] } 
 [LINE] throw new NullPointerException( [LINE] public Builder uncaughtExceptionHandler(final Thread.UncaughtExceptionHandler handler) { [EOL]     if (handler == null) { [EOL]         throw new NullPointerException("Uncaught exception handler must not be null!"); [EOL]     } [EOL]     exceptionHandler = handler; [EOL]     return this; [EOL] } 
 [LINE] exceptionHandler = handler; [LINE] public Builder uncaughtExceptionHandler(final Thread.UncaughtExceptionHandler handler) { [EOL]     if (handler == null) { [EOL]         throw new NullPointerException("Uncaught exception handler must not be null!"); [EOL]     } [EOL]     exceptionHandler = handler; [EOL]     return this; [EOL] } 
 [LINE] return this; [LINE] public Builder uncaughtExceptionHandler(final Thread.UncaughtExceptionHandler handler) { [EOL]     if (handler == null) { [EOL]         throw new NullPointerException("Uncaught exception handler must not be null!"); [EOL]     } [EOL]     exceptionHandler = handler; [EOL]     return this; [EOL] } 
 [LINE] public void reset() { [LINE] public void reset() { [EOL]     wrappedFactory = null; [EOL]     exceptionHandler = null; [EOL]     namingPattern = null; [EOL]     priority = null; [EOL]     daemonFlag = null; [EOL] } 
 [LINE] wrappedFactory = null; [LINE] public void reset() { [EOL]     wrappedFactory = null; [EOL]     exceptionHandler = null; [EOL]     namingPattern = null; [EOL]     priority = null; [EOL]     daemonFlag = null; [EOL] } 
 [LINE] exceptionHandler = null; [LINE] public void reset() { [EOL]     wrappedFactory = null; [EOL]     exceptionHandler = null; [EOL]     namingPattern = null; [EOL]     priority = null; [EOL]     daemonFlag = null; [EOL] } 
 [LINE] namingPattern = null; [LINE] public void reset() { [EOL]     wrappedFactory = null; [EOL]     exceptionHandler = null; [EOL]     namingPattern = null; [EOL]     priority = null; [EOL]     daemonFlag = null; [EOL] } 
 [LINE] priority = null; [LINE] public void reset() { [EOL]     wrappedFactory = null; [EOL]     exceptionHandler = null; [EOL]     namingPattern = null; [EOL]     priority = null; [EOL]     daemonFlag = null; [EOL] } 
 [LINE] daemonFlag = null; [LINE] public void reset() { [EOL]     wrappedFactory = null; [EOL]     exceptionHandler = null; [EOL]     namingPattern = null; [EOL]     priority = null; [EOL]     daemonFlag = null; [EOL] } 
 [LINE] @Override [LINE] @Override [EOL] public BasicThreadFactory build() { [EOL]     final BasicThreadFactory factory = new BasicThreadFactory(this); [EOL]     reset(); [EOL]     return factory; [EOL] } 
 [LINE] final BasicThreadFactory factory = new BasicThreadFactory(this); [LINE] @Override [EOL] public BasicThreadFactory build() { [EOL]     final BasicThreadFactory factory = new BasicThreadFactory(this); [EOL]     reset(); [EOL]     return factory; [EOL] } 
 [LINE] reset(); [LINE] @Override [EOL] public BasicThreadFactory build() { [EOL]     final BasicThreadFactory factory = new BasicThreadFactory(this); [EOL]     reset(); [EOL]     return factory; [EOL] } 
 [LINE] return factory; [LINE] @Override [EOL] public BasicThreadFactory build() { [EOL]     final BasicThreadFactory factory = new BasicThreadFactory(this); [EOL]     reset(); [EOL]     return factory; [EOL] } 
