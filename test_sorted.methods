lang3/concurrent/LazyInitializer.java
 [LINE] T result = object; [LINE] @Override [EOL] public T get() throws ConcurrentException { [EOL]     T result = object; [EOL]     if (result == null) { [EOL]         synchronized (this) { [EOL]             result = object; [EOL]             if (result == null) { [EOL]                 object = result = initialize(); [EOL]             } [EOL]         } [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] result = object; [LINE] @Override [EOL] public T get() throws ConcurrentException { [EOL]     T result = object; [EOL]     if (result == null) { [EOL]         synchronized (this) { [EOL]             result = object; [EOL]             if (result == null) { [EOL]                 object = result = initialize(); [EOL]             } [EOL]         } [EOL]     } [EOL]     return result; [EOL] } 
lang3/text/translate/LookupTranslator.java
 [LINE] if (index + longest > input.length()) { [LINE] @Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     int max = longest; [EOL]     if (index + longest > input.length()) { [EOL]         max = input.length() - index; [EOL]     } [EOL]     for (int i = max; i >= shortest; i--) { [EOL]         final CharSequence subSeq = input.subSequence(index, index + i); [EOL]         final CharSequence result = lookupMap.get(subSeq.toString()); [EOL]         if (result != null) { [EOL]             out.write(result.toString()); [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return 0; [EOL] } 
 [LINE] for (int i = max; i >= shortest; i--) { [LINE] @Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     int max = longest; [EOL]     if (index + longest > input.length()) { [EOL]         max = input.length() - index; [EOL]     } [EOL]     for (int i = max; i >= shortest; i--) { [EOL]         final CharSequence subSeq = input.subSequence(index, index + i); [EOL]         final CharSequence result = lookupMap.get(subSeq.toString()); [EOL]         if (result != null) { [EOL]             out.write(result.toString()); [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return 0; [EOL] } 
 [LINE] final CharSequence result = lookupMap.get(subSeq.toString()); [LINE] @Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     int max = longest; [EOL]     if (index + longest > input.length()) { [EOL]         max = input.length() - index; [EOL]     } [EOL]     for (int i = max; i >= shortest; i--) { [EOL]         final CharSequence subSeq = input.subSequence(index, index + i); [EOL]         final CharSequence result = lookupMap.get(subSeq.toString()); [EOL]         if (result != null) { [EOL]             out.write(result.toString()); [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return 0; [EOL] } 
 [LINE] out.write(result.toString()); [LINE] @Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     int max = longest; [EOL]     if (index + longest > input.length()) { [EOL]         max = input.length() - index; [EOL]     } [EOL]     for (int i = max; i >= shortest; i--) { [EOL]         final CharSequence subSeq = input.subSequence(index, index + i); [EOL]         final CharSequence result = lookupMap.get(subSeq.toString()); [EOL]         if (result != null) { [EOL]             out.write(result.toString()); [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return 0; [EOL] } 
lang3/Validate.java
 [LINE] if (expression == false) { [LINE] public static void isTrue(final boolean expression, final String message, final long value) { [EOL]     if (expression == false) { [EOL]         throw new IllegalArgumentException(String.format(message, Long.valueOf(value))); [EOL]     } [EOL] } 
 [LINE] if (expression == false) { [LINE] public static void isTrue(final boolean expression, final String message, final double value) { [EOL]     if (expression == false) { [EOL]         throw new IllegalArgumentException(String.format(message, Double.valueOf(value))); [EOL]     } [EOL] } 
 [LINE] if (expression == false) { [LINE] public static void isTrue(final boolean expression) { [EOL]     if (expression == false) { [EOL]         throw new IllegalArgumentException(DEFAULT_IS_TRUE_EX_MESSAGE); [EOL]     } [EOL] } 
 [LINE] if (array == null) { [LINE] public static <T> T[] notEmpty(final T[] array, final String message, final Object... values) { [EOL]     if (array == null) { [EOL]         throw new NullPointerException(String.format(message, values)); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException(String.format(message, values)); [EOL]     } [EOL]     return array; [EOL] } 
 [LINE] throw new NullPointerException(String.format(message, values)); [LINE] public static <T> T[] notEmpty(final T[] array, final String message, final Object... values) { [EOL]     if (array == null) { [EOL]         throw new NullPointerException(String.format(message, values)); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException(String.format(message, values)); [EOL]     } [EOL]     return array; [EOL] } 
 [LINE] if (array.length == 0) { [LINE] public static <T> T[] notEmpty(final T[] array, final String message, final Object... values) { [EOL]     if (array == null) { [EOL]         throw new NullPointerException(String.format(message, values)); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException(String.format(message, values)); [EOL]     } [EOL]     return array; [EOL] } 
 [LINE] return array; [LINE] public static <T> T[] notEmpty(final T[] array, final String message, final Object... values) { [EOL]     if (array == null) { [EOL]         throw new NullPointerException(String.format(message, values)); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException(String.format(message, values)); [EOL]     } [EOL]     return array; [EOL] } 
 [LINE] throw new NullPointerException(String.format(message, values)); [LINE] public static <T extends Collection<?>> T notEmpty(final T collection, final String message, final Object... values) { [EOL]     if (collection == null) { [EOL]         throw new NullPointerException(String.format(message, values)); [EOL]     } [EOL]     if (collection.isEmpty()) { [EOL]         throw new IllegalArgumentException(String.format(message, values)); [EOL]     } [EOL]     return collection; [EOL] } 
 [LINE] if (collection.isEmpty()) { [LINE] public static <T extends Collection<?>> T notEmpty(final T collection, final String message, final Object... values) { [EOL]     if (collection == null) { [EOL]         throw new NullPointerException(String.format(message, values)); [EOL]     } [EOL]     if (collection.isEmpty()) { [EOL]         throw new IllegalArgumentException(String.format(message, values)); [EOL]     } [EOL]     return collection; [EOL] } 
 [LINE] return collection; [LINE] public static <T extends Collection<?>> T notEmpty(final T collection, final String message, final Object... values) { [EOL]     if (collection == null) { [EOL]         throw new NullPointerException(String.format(message, values)); [EOL]     } [EOL]     if (collection.isEmpty()) { [EOL]         throw new IllegalArgumentException(String.format(message, values)); [EOL]     } [EOL]     return collection; [EOL] } 
 [LINE] return notEmpty(map, DEFAULT_NOT_EMPTY_MAP_EX_MESSAGE); [LINE] public static <T extends Map<?, ?>> T notEmpty(final T map) { [EOL]     return notEmpty(map, DEFAULT_NOT_EMPTY_MAP_EX_MESSAGE); [EOL] } 
 [LINE] if (chars == null) { [LINE] public static <T extends CharSequence> T notEmpty(final T chars, final String message, final Object... values) { [EOL]     if (chars == null) { [EOL]         throw new NullPointerException(String.format(message, values)); [EOL]     } [EOL]     if (chars.length() == 0) { [EOL]         throw new IllegalArgumentException(String.format(message, values)); [EOL]     } [EOL]     return chars; [EOL] } 
 [LINE] throw new IllegalArgumentException(String.format(message, values)); [LINE] public static <T extends CharSequence> T notEmpty(final T chars, final String message, final Object... values) { [EOL]     if (chars == null) { [EOL]         throw new NullPointerException(String.format(message, values)); [EOL]     } [EOL]     if (chars.length() == 0) { [EOL]         throw new IllegalArgumentException(String.format(message, values)); [EOL]     } [EOL]     return chars; [EOL] } 
 [LINE] return notBlank(chars, DEFAULT_NOT_BLANK_EX_MESSAGE); [LINE] public static <T extends CharSequence> T notBlank(final T chars) { [EOL]     return notBlank(chars, DEFAULT_NOT_BLANK_EX_MESSAGE); [EOL] } 
 [LINE] Validate.notNull(array); [LINE] public static <T> T[] noNullElements(final T[] array, final String message, final Object... values) { [EOL]     Validate.notNull(array); [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         if (array[i] == null) { [EOL]             final Object[] values2 = ArrayUtils.add(values, Integer.valueOf(i)); [EOL]             throw new IllegalArgumentException(String.format(message, values2)); [EOL]         } [EOL]     } [EOL]     return array; [EOL] } 
 [LINE] throw new IndexOutOfBoundsException(String.format(message, values)); [LINE] public static <T> T[] validIndex(final T[] array, final int index, final String message, final Object... values) { [EOL]     Validate.notNull(array); [EOL]     if (index < 0 || index >= array.length) { [EOL]         throw new IndexOutOfBoundsException(String.format(message, values)); [EOL]     } [EOL]     return array; [EOL] } 
 [LINE] if (index < 0 || index >= collection.size()) { [LINE] public static <T extends Collection<?>> T validIndex(final T collection, final int index, final String message, final Object... values) { [EOL]     Validate.notNull(collection); [EOL]     if (index < 0 || index >= collection.size()) { [EOL]         throw new IndexOutOfBoundsException(String.format(message, values)); [EOL]     } [EOL]     return collection; [EOL] } 
 [LINE] return validIndex(chars, index, DEFAULT_VALID_INDEX_CHAR_SEQUENCE_EX_MESSAGE, Integer.valueOf(index)); [LINE] public static <T extends CharSequence> T validIndex(final T chars, final int index) { [EOL]     return validIndex(chars, index, DEFAULT_VALID_INDEX_CHAR_SEQUENCE_EX_MESSAGE, Integer.valueOf(index)); [EOL] } 
 [LINE] throw new IllegalArgumentException(String.format(message, values)); [LINE] public static void matchesPattern(final CharSequence input, final String pattern, final String message, final Object... values) { [EOL]     if (Pattern.matches(pattern, input) == false) { [EOL]         throw new IllegalArgumentException(String.format(message, values)); [EOL]     } [EOL] } 
 [LINE] if (value.compareTo(start) < 0 || value.compareTo(end) > 0) { [LINE] public static <T> void inclusiveBetween(final T start, final T end, final Comparable<T> value) { [EOL]     if (value.compareTo(start) < 0 || value.compareTo(end) > 0) { [EOL]         throw new IllegalArgumentException(String.format(DEFAULT_INCLUSIVE_BETWEEN_EX_MESSAGE, value, start, end)); [EOL]     } [EOL] } 
 [LINE] if (value.compareTo(start) < 0 || value.compareTo(end) > 0) { [LINE] public static <T> void inclusiveBetween(final T start, final T end, final Comparable<T> value, final String message, final Object... values) { [EOL]     if (value.compareTo(start) < 0 || value.compareTo(end) > 0) { [EOL]         throw new IllegalArgumentException(String.format(message, values)); [EOL]     } [EOL] } 
 [LINE] throw new IllegalArgumentException(String.format(message, values)); [LINE] public static <T> void inclusiveBetween(final T start, final T end, final Comparable<T> value, final String message, final Object... values) { [EOL]     if (value.compareTo(start) < 0 || value.compareTo(end) > 0) { [EOL]         throw new IllegalArgumentException(String.format(message, values)); [EOL]     } [EOL] } 
 [LINE] if (value.compareTo(start) <= 0 || value.compareTo(end) >= 0) { [LINE] public static <T> void exclusiveBetween(final T start, final T end, final Comparable<T> value, final String message, final Object... values) { [EOL]     if (value.compareTo(start) <= 0 || value.compareTo(end) >= 0) { [EOL]         throw new IllegalArgumentException(String.format(message, values)); [EOL]     } [EOL] } 
 [LINE] if (type.isInstance(obj) == false) { [LINE] public static void isInstanceOf(final Class<?> type, final Object obj) { [EOL]     if (type.isInstance(obj) == false) { [EOL]         throw new IllegalArgumentException(String.format(DEFAULT_IS_INSTANCE_OF_EX_MESSAGE, type.getName(), obj == null ? "null" : obj.getClass().getName())); [EOL]     } [EOL] } 
 [LINE] if (type.isInstance(obj) == false) { [LINE] public static void isInstanceOf(final Class<?> type, final Object obj, final String message, final Object... values) { [EOL]     if (type.isInstance(obj) == false) { [EOL]         throw new IllegalArgumentException(String.format(message, values)); [EOL]     } [EOL] } 
 [LINE] throw new IllegalArgumentException(String.format(DEFAULT_IS_ASSIGNABLE_EX_MESSAGE, type == null ? "null" : type.getName(), [LINE] public static void isAssignableFrom(final Class<?> superType, final Class<?> type) { [EOL]     if (superType.isAssignableFrom(type) == false) { [EOL]         throw new IllegalArgumentException(String.format(DEFAULT_IS_ASSIGNABLE_EX_MESSAGE, type == null ? "null" : type.getName(), superType.getName())); [EOL]     } [EOL] } 
 [LINE] if (superType.isAssignableFrom(type) == false) { [LINE] public static void isAssignableFrom(final Class<?> superType, final Class<?> type, final String message, final Object... values) { [EOL]     if (superType.isAssignableFrom(type) == false) { [EOL]         throw new IllegalArgumentException(String.format(message, values)); [EOL]     } [EOL] } 
 [LINE] throw new IllegalArgumentException(String.format(message, values)); [LINE] public static void isAssignableFrom(final Class<?> superType, final Class<?> type, final String message, final Object... values) { [EOL]     if (superType.isAssignableFrom(type) == false) { [EOL]         throw new IllegalArgumentException(String.format(message, values)); [EOL]     } [EOL] } 
lang3/time/FastDateFormat.java
 [LINE] return cache.getInstance(pattern, null, null); [LINE] public static FastDateFormat getInstance(final String pattern) { [EOL]     return cache.getInstance(pattern, null, null); [EOL] } 
 [LINE] return cache.getTimeInstance(style, null, null); [LINE] public static FastDateFormat getTimeInstance(final int style) { [EOL]     return cache.getTimeInstance(style, null, null); [EOL] } 
 [LINE] return printer.format(millis); [LINE] @Override [EOL] public String format(final long millis) { [EOL]     return printer.format(millis); [EOL] } 
 [LINE] @Override [LINE] @Override [EOL] public String format(final long millis) { [EOL]     return printer.format(millis); [EOL] } 
 [LINE] return printer.format(calendar); [LINE] @Override [EOL] public String format(final Calendar calendar) { [EOL]     return printer.format(calendar); [EOL] } 
 [LINE] @Override [LINE] @Override [EOL] public TimeZone getTimeZone() { [EOL]     return printer.getTimeZone(); [EOL] } 
 [LINE] final FastDateFormat other = (FastDateFormat) obj; [LINE] @Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj instanceof FastDateFormat == false) { [EOL]         return false; [EOL]     } [EOL]     final FastDateFormat other = (FastDateFormat) obj; [EOL]     return printer.equals(other.printer); [EOL] } 
lang3/tuple/Pair.java
 [LINE] @Override [LINE] @Override [EOL] public final L getKey() { [EOL]     return getLeft(); [EOL] } 
 [LINE] @Override [LINE] @Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof Map.Entry<?, ?>) { [EOL]         final Map.Entry<?, ?> other = (Map.Entry<?, ?>) obj; [EOL]         return ObjectUtils.equals(getKey(), other.getKey()) && ObjectUtils.equals(getValue(), other.getValue()); [EOL]     } [EOL]     return false; [EOL] } 
 [LINE] return (getKey() == null ? 0 : getKey().hashCode()) ^ [LINE] @Override [EOL] public int hashCode() { [EOL]     return (getKey() == null ? 0 : getKey().hashCode()) ^ (getValue() == null ? 0 : getValue().hashCode()); [EOL] } 
lang3/exception/ContextedException.java
 [LINE] @Override [LINE] @Override [EOL] public List<Object> getContextValues(final String label) { [EOL]     return this.exceptionContext.getContextValues(label); [EOL] } 
 [LINE] return this.exceptionContext.getContextEntries(); [LINE] @Override [EOL] public List<Pair<String, Object>> getContextEntries() { [EOL]     return this.exceptionContext.getContextEntries(); [EOL] } 
 [LINE] return exceptionContext.getContextLabels(); [LINE] @Override [EOL] public Set<String> getContextLabels() { [EOL]     return exceptionContext.getContextLabels(); [EOL] } 
lang3/builder/EqualsBuilder.java
 [LINE] registry = getRegistry(); [LINE] static void unregister(final Object lhs, final Object rhs) { [EOL]     Set<Pair<IDKey, IDKey>> registry = getRegistry(); [EOL]     if (registry != null) { [EOL]         final Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs); [EOL]         registry.remove(pair); [EOL]         synchronized (EqualsBuilder.class) { [EOL]             registry = getRegistry(); [EOL]             if (registry != null && registry.isEmpty()) { [EOL]                 REGISTRY.remove(); [EOL]             } [EOL]         } [EOL]     } [EOL] } 
 [LINE] if (registry != null && registry.isEmpty()) { [LINE] static void unregister(final Object lhs, final Object rhs) { [EOL]     Set<Pair<IDKey, IDKey>> registry = getRegistry(); [EOL]     if (registry != null) { [EOL]         final Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs); [EOL]         registry.remove(pair); [EOL]         synchronized (EqualsBuilder.class) { [EOL]             registry = getRegistry(); [EOL]             if (registry != null && registry.isEmpty()) { [EOL]                 REGISTRY.remove(); [EOL]             } [EOL]         } [EOL]     } [EOL] } 
 [LINE] REGISTRY.remove(); [LINE] static void unregister(final Object lhs, final Object rhs) { [EOL]     Set<Pair<IDKey, IDKey>> registry = getRegistry(); [EOL]     if (registry != null) { [EOL]         final Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs); [EOL]         registry.remove(pair); [EOL]         synchronized (EqualsBuilder.class) { [EOL]             registry = getRegistry(); [EOL]             if (registry != null && registry.isEmpty()) { [EOL]                 REGISTRY.remove(); [EOL]             } [EOL]         } [EOL]     } [EOL] } 
 [LINE] if (lhs == null || rhs == null) { [LINE] public static boolean reflectionEquals(final Object lhs, final Object rhs, final boolean testTransients, final Class<?> reflectUpToClass, final String... excludeFields) { [EOL]     if (lhs == rhs) { [EOL]         return true; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         return false; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     final Class<?> rhsClass = rhs.getClass(); [EOL]     Class<?> testClass; [EOL]     if (lhsClass.isInstance(rhs)) { [EOL]         testClass = lhsClass; [EOL]         if (!rhsClass.isInstance(lhs)) { [EOL]             testClass = rhsClass; [EOL]         } [EOL]     } else if (rhsClass.isInstance(lhs)) { [EOL]         testClass = rhsClass; [EOL]         if (!lhsClass.isInstance(rhs)) { [EOL]             testClass = lhsClass; [EOL]         } [EOL]     } else { [EOL]         return false; [EOL]     } [EOL]     final EqualsBuilder equalsBuilder = new EqualsBuilder(); [EOL]     try { [EOL]         reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields); [EOL]         while (testClass.getSuperclass() != null && testClass != reflectUpToClass) { [EOL]             testClass = testClass.getSuperclass(); [EOL]             reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields); [EOL]         } [EOL]     } catch (final IllegalArgumentException e) { [EOL]         return false; [EOL]     } [EOL]     return equalsBuilder.isEquals(); [EOL] } 
 [LINE] Class<?> testClass; [LINE] public static boolean reflectionEquals(final Object lhs, final Object rhs, final boolean testTransients, final Class<?> reflectUpToClass, final String... excludeFields) { [EOL]     if (lhs == rhs) { [EOL]         return true; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         return false; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     final Class<?> rhsClass = rhs.getClass(); [EOL]     Class<?> testClass; [EOL]     if (lhsClass.isInstance(rhs)) { [EOL]         testClass = lhsClass; [EOL]         if (!rhsClass.isInstance(lhs)) { [EOL]             testClass = rhsClass; [EOL]         } [EOL]     } else if (rhsClass.isInstance(lhs)) { [EOL]         testClass = rhsClass; [EOL]         if (!lhsClass.isInstance(rhs)) { [EOL]             testClass = lhsClass; [EOL]         } [EOL]     } else { [EOL]         return false; [EOL]     } [EOL]     final EqualsBuilder equalsBuilder = new EqualsBuilder(); [EOL]     try { [EOL]         reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields); [EOL]         while (testClass.getSuperclass() != null && testClass != reflectUpToClass) { [EOL]             testClass = testClass.getSuperclass(); [EOL]             reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields); [EOL]         } [EOL]     } catch (final IllegalArgumentException e) { [EOL]         return false; [EOL]     } [EOL]     return equalsBuilder.isEquals(); [EOL] } 
 [LINE] if (lhsClass.isInstance(rhs)) { [LINE] public static boolean reflectionEquals(final Object lhs, final Object rhs, final boolean testTransients, final Class<?> reflectUpToClass, final String... excludeFields) { [EOL]     if (lhs == rhs) { [EOL]         return true; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         return false; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     final Class<?> rhsClass = rhs.getClass(); [EOL]     Class<?> testClass; [EOL]     if (lhsClass.isInstance(rhs)) { [EOL]         testClass = lhsClass; [EOL]         if (!rhsClass.isInstance(lhs)) { [EOL]             testClass = rhsClass; [EOL]         } [EOL]     } else if (rhsClass.isInstance(lhs)) { [EOL]         testClass = rhsClass; [EOL]         if (!lhsClass.isInstance(rhs)) { [EOL]             testClass = lhsClass; [EOL]         } [EOL]     } else { [EOL]         return false; [EOL]     } [EOL]     final EqualsBuilder equalsBuilder = new EqualsBuilder(); [EOL]     try { [EOL]         reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields); [EOL]         while (testClass.getSuperclass() != null && testClass != reflectUpToClass) { [EOL]             testClass = testClass.getSuperclass(); [EOL]             reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields); [EOL]         } [EOL]     } catch (final IllegalArgumentException e) { [EOL]         return false; [EOL]     } [EOL]     return equalsBuilder.isEquals(); [EOL] } 
 [LINE] reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields); [LINE] public static boolean reflectionEquals(final Object lhs, final Object rhs, final boolean testTransients, final Class<?> reflectUpToClass, final String... excludeFields) { [EOL]     if (lhs == rhs) { [EOL]         return true; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         return false; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     final Class<?> rhsClass = rhs.getClass(); [EOL]     Class<?> testClass; [EOL]     if (lhsClass.isInstance(rhs)) { [EOL]         testClass = lhsClass; [EOL]         if (!rhsClass.isInstance(lhs)) { [EOL]             testClass = rhsClass; [EOL]         } [EOL]     } else if (rhsClass.isInstance(lhs)) { [EOL]         testClass = rhsClass; [EOL]         if (!lhsClass.isInstance(rhs)) { [EOL]             testClass = lhsClass; [EOL]         } [EOL]     } else { [EOL]         return false; [EOL]     } [EOL]     final EqualsBuilder equalsBuilder = new EqualsBuilder(); [EOL]     try { [EOL]         reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields); [EOL]         while (testClass.getSuperclass() != null && testClass != reflectUpToClass) { [EOL]             testClass = testClass.getSuperclass(); [EOL]             reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields); [EOL]         } [EOL]     } catch (final IllegalArgumentException e) { [EOL]         return false; [EOL]     } [EOL]     return equalsBuilder.isEquals(); [EOL] } 
 [LINE] if (isRegistered(lhs, rhs)) { [LINE] private static void reflectionAppend(final Object lhs, final Object rhs, final Class<?> clazz, final EqualsBuilder builder, final boolean useTransients, final String[] excludeFields) { [EOL]     if (isRegistered(lhs, rhs)) { [EOL]         return; [EOL]     } [EOL]     try { [EOL]         register(lhs, rhs); [EOL]         final Field[] fields = clazz.getDeclaredFields(); [EOL]         AccessibleObject.setAccessible(fields, true); [EOL]         for (int i = 0; i < fields.length && builder.isEquals; i++) { [EOL]             final Field f = fields[i]; [EOL]             if (!ArrayUtils.contains(excludeFields, f.getName()) && (f.getName().indexOf('$') == -1) && (useTransients || !Modifier.isTransient(f.getModifiers())) && (!Modifier.isStatic(f.getModifiers()))) { [EOL]                 try { [EOL]                     builder.append(f.get(lhs), f.get(rhs)); [EOL]                 } catch (final IllegalAccessException e) { [EOL]                     throw new InternalError("Unexpected IllegalAccessException"); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } finally { [EOL]         unregister(lhs, rhs); [EOL]     } [EOL] } 
 [LINE] try { [LINE] private static void reflectionAppend(final Object lhs, final Object rhs, final Class<?> clazz, final EqualsBuilder builder, final boolean useTransients, final String[] excludeFields) { [EOL]     if (isRegistered(lhs, rhs)) { [EOL]         return; [EOL]     } [EOL]     try { [EOL]         register(lhs, rhs); [EOL]         final Field[] fields = clazz.getDeclaredFields(); [EOL]         AccessibleObject.setAccessible(fields, true); [EOL]         for (int i = 0; i < fields.length && builder.isEquals; i++) { [EOL]             final Field f = fields[i]; [EOL]             if (!ArrayUtils.contains(excludeFields, f.getName()) && (f.getName().indexOf('$') == -1) && (useTransients || !Modifier.isTransient(f.getModifiers())) && (!Modifier.isStatic(f.getModifiers()))) { [EOL]                 try { [EOL]                     builder.append(f.get(lhs), f.get(rhs)); [EOL]                 } catch (final IllegalAccessException e) { [EOL]                     throw new InternalError("Unexpected IllegalAccessException"); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } finally { [EOL]         unregister(lhs, rhs); [EOL]     } [EOL] } 
 [LINE] for (int i = 0; i < fields.length && builder.isEquals; i++) { [LINE] private static void reflectionAppend(final Object lhs, final Object rhs, final Class<?> clazz, final EqualsBuilder builder, final boolean useTransients, final String[] excludeFields) { [EOL]     if (isRegistered(lhs, rhs)) { [EOL]         return; [EOL]     } [EOL]     try { [EOL]         register(lhs, rhs); [EOL]         final Field[] fields = clazz.getDeclaredFields(); [EOL]         AccessibleObject.setAccessible(fields, true); [EOL]         for (int i = 0; i < fields.length && builder.isEquals; i++) { [EOL]             final Field f = fields[i]; [EOL]             if (!ArrayUtils.contains(excludeFields, f.getName()) && (f.getName().indexOf('$') == -1) && (useTransients || !Modifier.isTransient(f.getModifiers())) && (!Modifier.isStatic(f.getModifiers()))) { [EOL]                 try { [EOL]                     builder.append(f.get(lhs), f.get(rhs)); [EOL]                 } catch (final IllegalAccessException e) { [EOL]                     throw new InternalError("Unexpected IllegalAccessException"); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } finally { [EOL]         unregister(lhs, rhs); [EOL]     } [EOL] } 
 [LINE] if (isEquals == false) { [LINE] public EqualsBuilder appendSuper(final boolean superEquals) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     isEquals = superEquals; [EOL]     return this; [EOL] } 
 [LINE] isEquals = superEquals; [LINE] public EqualsBuilder appendSuper(final boolean superEquals) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     isEquals = superEquals; [EOL]     return this; [EOL] } 
 [LINE] this.setEquals(false); [LINE] public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] isEquals = lhs.equals(rhs); [LINE] public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] append((long[]) lhs, (long[]) rhs); [LINE] public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] } else if (lhs instanceof byte[]) { [LINE] public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] return this; [LINE] public EqualsBuilder append(final long lhs, final long rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     isEquals = (lhs == rhs); [EOL]     return this; [EOL] } 
 [LINE] isEquals = (lhs == rhs); [LINE] public EqualsBuilder append(final short lhs, final short rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     isEquals = (lhs == rhs); [EOL]     return this; [EOL] } 
 [LINE] return this; [LINE] public EqualsBuilder append(final short lhs, final short rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     isEquals = (lhs == rhs); [EOL]     return this; [EOL] } 
 [LINE] isEquals = (lhs == rhs); [LINE] public EqualsBuilder append(final boolean lhs, final boolean rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     isEquals = (lhs == rhs); [EOL]     return this; [EOL] } 
 [LINE] return this; [LINE] public EqualsBuilder append(final Object[] lhs, final Object[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] return this; [LINE] public EqualsBuilder append(final Object[] lhs, final Object[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] if (isEquals == false) { [LINE] public EqualsBuilder append(final long[] lhs, final long[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] return this; [LINE] public EqualsBuilder append(final long[] lhs, final long[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] if (lhs == null || rhs == null) { [LINE] public EqualsBuilder append(final long[] lhs, final long[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] return this; [LINE] public EqualsBuilder append(final long[] lhs, final long[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] for (int i = 0; i < lhs.length && isEquals; ++i) { [LINE] public EqualsBuilder append(final long[] lhs, final long[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] return this; [LINE] public EqualsBuilder append(final int[] lhs, final int[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] this.setEquals(false); [LINE] public EqualsBuilder append(final int[] lhs, final int[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] for (int i = 0; i < lhs.length && isEquals; ++i) { [LINE] public EqualsBuilder append(final int[] lhs, final int[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] append(lhs[i], rhs[i]); [LINE] public EqualsBuilder append(final int[] lhs, final int[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] if (isEquals == false) { [LINE] public EqualsBuilder append(final char[] lhs, final char[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] if (lhs == null || rhs == null) { [LINE] public EqualsBuilder append(final char[] lhs, final char[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] for (int i = 0; i < lhs.length && isEquals; ++i) { [LINE] public EqualsBuilder append(final char[] lhs, final char[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] this.setEquals(false); [LINE] public EqualsBuilder append(final byte[] lhs, final byte[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] if (lhs == rhs) { [LINE] public EqualsBuilder append(final double[] lhs, final double[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] return this; [LINE] public EqualsBuilder append(final float[] lhs, final float[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] if (lhs == null || rhs == null) { [LINE] public EqualsBuilder append(final float[] lhs, final float[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] return this; [LINE] public EqualsBuilder append(final float[] lhs, final float[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] return this; [LINE] public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] append(lhs[i], rhs[i]); [LINE] public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
lang3/mutable/MutableLong.java
 [LINE] return Long.valueOf(this.value); [LINE] @Override [EOL] public Long getValue() { [EOL]     return Long.valueOf(this.value); [EOL] } 
 [LINE] value++; [LINE] public void increment() { [EOL]     value++; [EOL] } 
 [LINE] value--; [LINE] public void decrement() { [EOL]     value--; [EOL] } 
 [LINE] this.value -= operand; [LINE] public void subtract(final long operand) { [EOL]     this.value -= operand; [EOL] } 
 [LINE] @Override [LINE] public void subtract(final Number operand) { [EOL]     this.value -= operand.longValue(); [EOL] } 
 [LINE] return (int) value; [LINE] @Override [EOL] public int intValue() { [EOL]     return (int) value; [EOL] } 
 [LINE] @Override [LINE] @Override [EOL] public int intValue() { [EOL]     return (int) value; [EOL] } 
 [LINE] return value; [LINE] @Override [EOL] public float floatValue() { [EOL]     return value; [EOL] } 
 [LINE] @Override [LINE] @Override [EOL] public float floatValue() { [EOL]     return value; [EOL] } 
 [LINE] return value; [LINE] @Override [EOL] public double doubleValue() { [EOL]     return value; [EOL] } 
 [LINE] return value < anotherVal ? -1 : (value == anotherVal ? 0 : 1); [LINE] @Override [EOL] public int compareTo(final MutableLong other) { [EOL]     final long anotherVal = other.value; [EOL]     return value < anotherVal ? -1 : (value == anotherVal ? 0 : 1); [EOL] } 
 [LINE] return String.valueOf(value); [LINE] @Override [EOL] public String toString() { [EOL]     return String.valueOf(value); [EOL] } 
lang3/text/translate/AggregateTranslator.java
lang3/RandomStringUtils.java
 [LINE] return random(count, 0, 0, letters, numbers); [LINE] public static String random(final int count, final boolean letters, final boolean numbers) { [EOL]     return random(count, 0, 0, letters, numbers); [EOL] } 
 [LINE] throw new IllegalArgumentException("The chars array must not be empty"); [LINE] public static String random(int count, int start, int end, final boolean letters, final boolean numbers, final char[] chars, final Random random) { [EOL]     if (count == 0) { [EOL]         return ""; [EOL]     } else if (count < 0) { [EOL]         throw new IllegalArgumentException("Requested random string length " + count + " is less than 0."); [EOL]     } [EOL]     if (chars != null && chars.length == 0) { [EOL]         throw new IllegalArgumentException("The chars array must not be empty"); [EOL]     } [EOL]     if (start == 0 && end == 0) { [EOL]         if (chars != null) { [EOL]             end = chars.length; [EOL]         } else { [EOL]             if (!letters && !numbers) { [EOL]                 end = Integer.MAX_VALUE; [EOL]             } else { [EOL]                 end = 'z' + 1; [EOL]                 start = ' '; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (end <= start) { [EOL]             throw new IllegalArgumentException("Parameter end (" + end + ") must be greater than start (" + start + ")"); [EOL]         } [EOL]     } [EOL]     final char[] buffer = new char[count]; [EOL]     final int gap = end - start; [EOL]     while (count-- != 0) { [EOL]         char ch; [EOL]         if (chars == null) { [EOL]             ch = (char) (random.nextInt(gap) + start); [EOL]         } else { [EOL]             ch = chars[random.nextInt(gap) + start]; [EOL]         } [EOL]         if (letters && Character.isLetter(ch) || numbers && Character.isDigit(ch) || !letters && !numbers) { [EOL]             if (ch >= 56320 && ch <= 57343) { [EOL]                 if (count == 0) { [EOL]                     count++; [EOL]                 } else { [EOL]                     buffer[count] = ch; [EOL]                     count--; [EOL]                     buffer[count] = (char) (55296 + random.nextInt(128)); [EOL]                 } [EOL]             } else if (ch >= 55296 && ch <= 56191) { [EOL]                 if (count == 0) { [EOL]                     count++; [EOL]                 } else { [EOL]                     buffer[count] = (char) (56320 + random.nextInt(128)); [EOL]                     count--; [EOL]                     buffer[count] = ch; [EOL]                 } [EOL]             } else if (ch >= 56192 && ch <= 56319) { [EOL]                 count++; [EOL]             } else { [EOL]                 buffer[count] = ch; [EOL]             } [EOL]         } else { [EOL]             count++; [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] } 
 [LINE] if (chars != null) { [LINE] public static String random(int count, int start, int end, final boolean letters, final boolean numbers, final char[] chars, final Random random) { [EOL]     if (count == 0) { [EOL]         return ""; [EOL]     } else if (count < 0) { [EOL]         throw new IllegalArgumentException("Requested random string length " + count + " is less than 0."); [EOL]     } [EOL]     if (chars != null && chars.length == 0) { [EOL]         throw new IllegalArgumentException("The chars array must not be empty"); [EOL]     } [EOL]     if (start == 0 && end == 0) { [EOL]         if (chars != null) { [EOL]             end = chars.length; [EOL]         } else { [EOL]             if (!letters && !numbers) { [EOL]                 end = Integer.MAX_VALUE; [EOL]             } else { [EOL]                 end = 'z' + 1; [EOL]                 start = ' '; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (end <= start) { [EOL]             throw new IllegalArgumentException("Parameter end (" + end + ") must be greater than start (" + start + ")"); [EOL]         } [EOL]     } [EOL]     final char[] buffer = new char[count]; [EOL]     final int gap = end - start; [EOL]     while (count-- != 0) { [EOL]         char ch; [EOL]         if (chars == null) { [EOL]             ch = (char) (random.nextInt(gap) + start); [EOL]         } else { [EOL]             ch = chars[random.nextInt(gap) + start]; [EOL]         } [EOL]         if (letters && Character.isLetter(ch) || numbers && Character.isDigit(ch) || !letters && !numbers) { [EOL]             if (ch >= 56320 && ch <= 57343) { [EOL]                 if (count == 0) { [EOL]                     count++; [EOL]                 } else { [EOL]                     buffer[count] = ch; [EOL]                     count--; [EOL]                     buffer[count] = (char) (55296 + random.nextInt(128)); [EOL]                 } [EOL]             } else if (ch >= 55296 && ch <= 56191) { [EOL]                 if (count == 0) { [EOL]                     count++; [EOL]                 } else { [EOL]                     buffer[count] = (char) (56320 + random.nextInt(128)); [EOL]                     count--; [EOL]                     buffer[count] = ch; [EOL]                 } [EOL]             } else if (ch >= 56192 && ch <= 56319) { [EOL]                 count++; [EOL]             } else { [EOL]                 buffer[count] = ch; [EOL]             } [EOL]         } else { [EOL]             count++; [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] } 
 [LINE] end = 'z' + 1; [LINE] public static String random(int count, int start, int end, final boolean letters, final boolean numbers, final char[] chars, final Random random) { [EOL]     if (count == 0) { [EOL]         return ""; [EOL]     } else if (count < 0) { [EOL]         throw new IllegalArgumentException("Requested random string length " + count + " is less than 0."); [EOL]     } [EOL]     if (chars != null && chars.length == 0) { [EOL]         throw new IllegalArgumentException("The chars array must not be empty"); [EOL]     } [EOL]     if (start == 0 && end == 0) { [EOL]         if (chars != null) { [EOL]             end = chars.length; [EOL]         } else { [EOL]             if (!letters && !numbers) { [EOL]                 end = Integer.MAX_VALUE; [EOL]             } else { [EOL]                 end = 'z' + 1; [EOL]                 start = ' '; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (end <= start) { [EOL]             throw new IllegalArgumentException("Parameter end (" + end + ") must be greater than start (" + start + ")"); [EOL]         } [EOL]     } [EOL]     final char[] buffer = new char[count]; [EOL]     final int gap = end - start; [EOL]     while (count-- != 0) { [EOL]         char ch; [EOL]         if (chars == null) { [EOL]             ch = (char) (random.nextInt(gap) + start); [EOL]         } else { [EOL]             ch = chars[random.nextInt(gap) + start]; [EOL]         } [EOL]         if (letters && Character.isLetter(ch) || numbers && Character.isDigit(ch) || !letters && !numbers) { [EOL]             if (ch >= 56320 && ch <= 57343) { [EOL]                 if (count == 0) { [EOL]                     count++; [EOL]                 } else { [EOL]                     buffer[count] = ch; [EOL]                     count--; [EOL]                     buffer[count] = (char) (55296 + random.nextInt(128)); [EOL]                 } [EOL]             } else if (ch >= 55296 && ch <= 56191) { [EOL]                 if (count == 0) { [EOL]                     count++; [EOL]                 } else { [EOL]                     buffer[count] = (char) (56320 + random.nextInt(128)); [EOL]                     count--; [EOL]                     buffer[count] = ch; [EOL]                 } [EOL]             } else if (ch >= 56192 && ch <= 56319) { [EOL]                 count++; [EOL]             } else { [EOL]                 buffer[count] = ch; [EOL]             } [EOL]         } else { [EOL]             count++; [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] } 
 [LINE] final char[] buffer = new char[count]; [LINE] public static String random(int count, int start, int end, final boolean letters, final boolean numbers, final char[] chars, final Random random) { [EOL]     if (count == 0) { [EOL]         return ""; [EOL]     } else if (count < 0) { [EOL]         throw new IllegalArgumentException("Requested random string length " + count + " is less than 0."); [EOL]     } [EOL]     if (chars != null && chars.length == 0) { [EOL]         throw new IllegalArgumentException("The chars array must not be empty"); [EOL]     } [EOL]     if (start == 0 && end == 0) { [EOL]         if (chars != null) { [EOL]             end = chars.length; [EOL]         } else { [EOL]             if (!letters && !numbers) { [EOL]                 end = Integer.MAX_VALUE; [EOL]             } else { [EOL]                 end = 'z' + 1; [EOL]                 start = ' '; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (end <= start) { [EOL]             throw new IllegalArgumentException("Parameter end (" + end + ") must be greater than start (" + start + ")"); [EOL]         } [EOL]     } [EOL]     final char[] buffer = new char[count]; [EOL]     final int gap = end - start; [EOL]     while (count-- != 0) { [EOL]         char ch; [EOL]         if (chars == null) { [EOL]             ch = (char) (random.nextInt(gap) + start); [EOL]         } else { [EOL]             ch = chars[random.nextInt(gap) + start]; [EOL]         } [EOL]         if (letters && Character.isLetter(ch) || numbers && Character.isDigit(ch) || !letters && !numbers) { [EOL]             if (ch >= 56320 && ch <= 57343) { [EOL]                 if (count == 0) { [EOL]                     count++; [EOL]                 } else { [EOL]                     buffer[count] = ch; [EOL]                     count--; [EOL]                     buffer[count] = (char) (55296 + random.nextInt(128)); [EOL]                 } [EOL]             } else if (ch >= 55296 && ch <= 56191) { [EOL]                 if (count == 0) { [EOL]                     count++; [EOL]                 } else { [EOL]                     buffer[count] = (char) (56320 + random.nextInt(128)); [EOL]                     count--; [EOL]                     buffer[count] = ch; [EOL]                 } [EOL]             } else if (ch >= 56192 && ch <= 56319) { [EOL]                 count++; [EOL]             } else { [EOL]                 buffer[count] = ch; [EOL]             } [EOL]         } else { [EOL]             count++; [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] } 
 [LINE] if (chars == null) { [LINE] public static String random(int count, int start, int end, final boolean letters, final boolean numbers, final char[] chars, final Random random) { [EOL]     if (count == 0) { [EOL]         return ""; [EOL]     } else if (count < 0) { [EOL]         throw new IllegalArgumentException("Requested random string length " + count + " is less than 0."); [EOL]     } [EOL]     if (chars != null && chars.length == 0) { [EOL]         throw new IllegalArgumentException("The chars array must not be empty"); [EOL]     } [EOL]     if (start == 0 && end == 0) { [EOL]         if (chars != null) { [EOL]             end = chars.length; [EOL]         } else { [EOL]             if (!letters && !numbers) { [EOL]                 end = Integer.MAX_VALUE; [EOL]             } else { [EOL]                 end = 'z' + 1; [EOL]                 start = ' '; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (end <= start) { [EOL]             throw new IllegalArgumentException("Parameter end (" + end + ") must be greater than start (" + start + ")"); [EOL]         } [EOL]     } [EOL]     final char[] buffer = new char[count]; [EOL]     final int gap = end - start; [EOL]     while (count-- != 0) { [EOL]         char ch; [EOL]         if (chars == null) { [EOL]             ch = (char) (random.nextInt(gap) + start); [EOL]         } else { [EOL]             ch = chars[random.nextInt(gap) + start]; [EOL]         } [EOL]         if (letters && Character.isLetter(ch) || numbers && Character.isDigit(ch) || !letters && !numbers) { [EOL]             if (ch >= 56320 && ch <= 57343) { [EOL]                 if (count == 0) { [EOL]                     count++; [EOL]                 } else { [EOL]                     buffer[count] = ch; [EOL]                     count--; [EOL]                     buffer[count] = (char) (55296 + random.nextInt(128)); [EOL]                 } [EOL]             } else if (ch >= 55296 && ch <= 56191) { [EOL]                 if (count == 0) { [EOL]                     count++; [EOL]                 } else { [EOL]                     buffer[count] = (char) (56320 + random.nextInt(128)); [EOL]                     count--; [EOL]                     buffer[count] = ch; [EOL]                 } [EOL]             } else if (ch >= 56192 && ch <= 56319) { [EOL]                 count++; [EOL]             } else { [EOL]                 buffer[count] = ch; [EOL]             } [EOL]         } else { [EOL]             count++; [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] } 
 [LINE] ch = (char) (random.nextInt(gap) + start); [LINE] public static String random(int count, int start, int end, final boolean letters, final boolean numbers, final char[] chars, final Random random) { [EOL]     if (count == 0) { [EOL]         return ""; [EOL]     } else if (count < 0) { [EOL]         throw new IllegalArgumentException("Requested random string length " + count + " is less than 0."); [EOL]     } [EOL]     if (chars != null && chars.length == 0) { [EOL]         throw new IllegalArgumentException("The chars array must not be empty"); [EOL]     } [EOL]     if (start == 0 && end == 0) { [EOL]         if (chars != null) { [EOL]             end = chars.length; [EOL]         } else { [EOL]             if (!letters && !numbers) { [EOL]                 end = Integer.MAX_VALUE; [EOL]             } else { [EOL]                 end = 'z' + 1; [EOL]                 start = ' '; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (end <= start) { [EOL]             throw new IllegalArgumentException("Parameter end (" + end + ") must be greater than start (" + start + ")"); [EOL]         } [EOL]     } [EOL]     final char[] buffer = new char[count]; [EOL]     final int gap = end - start; [EOL]     while (count-- != 0) { [EOL]         char ch; [EOL]         if (chars == null) { [EOL]             ch = (char) (random.nextInt(gap) + start); [EOL]         } else { [EOL]             ch = chars[random.nextInt(gap) + start]; [EOL]         } [EOL]         if (letters && Character.isLetter(ch) || numbers && Character.isDigit(ch) || !letters && !numbers) { [EOL]             if (ch >= 56320 && ch <= 57343) { [EOL]                 if (count == 0) { [EOL]                     count++; [EOL]                 } else { [EOL]                     buffer[count] = ch; [EOL]                     count--; [EOL]                     buffer[count] = (char) (55296 + random.nextInt(128)); [EOL]                 } [EOL]             } else if (ch >= 55296 && ch <= 56191) { [EOL]                 if (count == 0) { [EOL]                     count++; [EOL]                 } else { [EOL]                     buffer[count] = (char) (56320 + random.nextInt(128)); [EOL]                     count--; [EOL]                     buffer[count] = ch; [EOL]                 } [EOL]             } else if (ch >= 56192 && ch <= 56319) { [EOL]                 count++; [EOL]             } else { [EOL]                 buffer[count] = ch; [EOL]             } [EOL]         } else { [EOL]             count++; [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] } 
 [LINE] buffer[count] = ch; [LINE] public static String random(int count, int start, int end, final boolean letters, final boolean numbers, final char[] chars, final Random random) { [EOL]     if (count == 0) { [EOL]         return ""; [EOL]     } else if (count < 0) { [EOL]         throw new IllegalArgumentException("Requested random string length " + count + " is less than 0."); [EOL]     } [EOL]     if (chars != null && chars.length == 0) { [EOL]         throw new IllegalArgumentException("The chars array must not be empty"); [EOL]     } [EOL]     if (start == 0 && end == 0) { [EOL]         if (chars != null) { [EOL]             end = chars.length; [EOL]         } else { [EOL]             if (!letters && !numbers) { [EOL]                 end = Integer.MAX_VALUE; [EOL]             } else { [EOL]                 end = 'z' + 1; [EOL]                 start = ' '; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (end <= start) { [EOL]             throw new IllegalArgumentException("Parameter end (" + end + ") must be greater than start (" + start + ")"); [EOL]         } [EOL]     } [EOL]     final char[] buffer = new char[count]; [EOL]     final int gap = end - start; [EOL]     while (count-- != 0) { [EOL]         char ch; [EOL]         if (chars == null) { [EOL]             ch = (char) (random.nextInt(gap) + start); [EOL]         } else { [EOL]             ch = chars[random.nextInt(gap) + start]; [EOL]         } [EOL]         if (letters && Character.isLetter(ch) || numbers && Character.isDigit(ch) || !letters && !numbers) { [EOL]             if (ch >= 56320 && ch <= 57343) { [EOL]                 if (count == 0) { [EOL]                     count++; [EOL]                 } else { [EOL]                     buffer[count] = ch; [EOL]                     count--; [EOL]                     buffer[count] = (char) (55296 + random.nextInt(128)); [EOL]                 } [EOL]             } else if (ch >= 55296 && ch <= 56191) { [EOL]                 if (count == 0) { [EOL]                     count++; [EOL]                 } else { [EOL]                     buffer[count] = (char) (56320 + random.nextInt(128)); [EOL]                     count--; [EOL]                     buffer[count] = ch; [EOL]                 } [EOL]             } else if (ch >= 56192 && ch <= 56319) { [EOL]                 count++; [EOL]             } else { [EOL]                 buffer[count] = ch; [EOL]             } [EOL]         } else { [EOL]             count++; [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] } 
 [LINE] count++; [LINE] public static String random(int count, int start, int end, final boolean letters, final boolean numbers, final char[] chars, final Random random) { [EOL]     if (count == 0) { [EOL]         return ""; [EOL]     } else if (count < 0) { [EOL]         throw new IllegalArgumentException("Requested random string length " + count + " is less than 0."); [EOL]     } [EOL]     if (chars != null && chars.length == 0) { [EOL]         throw new IllegalArgumentException("The chars array must not be empty"); [EOL]     } [EOL]     if (start == 0 && end == 0) { [EOL]         if (chars != null) { [EOL]             end = chars.length; [EOL]         } else { [EOL]             if (!letters && !numbers) { [EOL]                 end = Integer.MAX_VALUE; [EOL]             } else { [EOL]                 end = 'z' + 1; [EOL]                 start = ' '; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (end <= start) { [EOL]             throw new IllegalArgumentException("Parameter end (" + end + ") must be greater than start (" + start + ")"); [EOL]         } [EOL]     } [EOL]     final char[] buffer = new char[count]; [EOL]     final int gap = end - start; [EOL]     while (count-- != 0) { [EOL]         char ch; [EOL]         if (chars == null) { [EOL]             ch = (char) (random.nextInt(gap) + start); [EOL]         } else { [EOL]             ch = chars[random.nextInt(gap) + start]; [EOL]         } [EOL]         if (letters && Character.isLetter(ch) || numbers && Character.isDigit(ch) || !letters && !numbers) { [EOL]             if (ch >= 56320 && ch <= 57343) { [EOL]                 if (count == 0) { [EOL]                     count++; [EOL]                 } else { [EOL]                     buffer[count] = ch; [EOL]                     count--; [EOL]                     buffer[count] = (char) (55296 + random.nextInt(128)); [EOL]                 } [EOL]             } else if (ch >= 55296 && ch <= 56191) { [EOL]                 if (count == 0) { [EOL]                     count++; [EOL]                 } else { [EOL]                     buffer[count] = (char) (56320 + random.nextInt(128)); [EOL]                     count--; [EOL]                     buffer[count] = ch; [EOL]                 } [EOL]             } else if (ch >= 56192 && ch <= 56319) { [EOL]                 count++; [EOL]             } else { [EOL]                 buffer[count] = ch; [EOL]             } [EOL]         } else { [EOL]             count++; [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] } 
 [LINE] return new String(buffer); [LINE] public static String random(int count, int start, int end, final boolean letters, final boolean numbers, final char[] chars, final Random random) { [EOL]     if (count == 0) { [EOL]         return ""; [EOL]     } else if (count < 0) { [EOL]         throw new IllegalArgumentException("Requested random string length " + count + " is less than 0."); [EOL]     } [EOL]     if (chars != null && chars.length == 0) { [EOL]         throw new IllegalArgumentException("The chars array must not be empty"); [EOL]     } [EOL]     if (start == 0 && end == 0) { [EOL]         if (chars != null) { [EOL]             end = chars.length; [EOL]         } else { [EOL]             if (!letters && !numbers) { [EOL]                 end = Integer.MAX_VALUE; [EOL]             } else { [EOL]                 end = 'z' + 1; [EOL]                 start = ' '; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (end <= start) { [EOL]             throw new IllegalArgumentException("Parameter end (" + end + ") must be greater than start (" + start + ")"); [EOL]         } [EOL]     } [EOL]     final char[] buffer = new char[count]; [EOL]     final int gap = end - start; [EOL]     while (count-- != 0) { [EOL]         char ch; [EOL]         if (chars == null) { [EOL]             ch = (char) (random.nextInt(gap) + start); [EOL]         } else { [EOL]             ch = chars[random.nextInt(gap) + start]; [EOL]         } [EOL]         if (letters && Character.isLetter(ch) || numbers && Character.isDigit(ch) || !letters && !numbers) { [EOL]             if (ch >= 56320 && ch <= 57343) { [EOL]                 if (count == 0) { [EOL]                     count++; [EOL]                 } else { [EOL]                     buffer[count] = ch; [EOL]                     count--; [EOL]                     buffer[count] = (char) (55296 + random.nextInt(128)); [EOL]                 } [EOL]             } else if (ch >= 55296 && ch <= 56191) { [EOL]                 if (count == 0) { [EOL]                     count++; [EOL]                 } else { [EOL]                     buffer[count] = (char) (56320 + random.nextInt(128)); [EOL]                     count--; [EOL]                     buffer[count] = ch; [EOL]                 } [EOL]             } else if (ch >= 56192 && ch <= 56319) { [EOL]                 count++; [EOL]             } else { [EOL]                 buffer[count] = ch; [EOL]             } [EOL]         } else { [EOL]             count++; [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] } 
lang3/time/StopWatch.java
 [LINE] if (this.runningState != STATE_UNSTARTED) { [LINE] public void start() { [EOL]     if (this.runningState == STATE_STOPPED) { [EOL]         throw new IllegalStateException("Stopwatch must be reset before being restarted. "); [EOL]     } [EOL]     if (this.runningState != STATE_UNSTARTED) { [EOL]         throw new IllegalStateException("Stopwatch already started. "); [EOL]     } [EOL]     this.startTime = System.nanoTime(); [EOL]     this.startTimeMillis = System.currentTimeMillis(); [EOL]     this.runningState = STATE_RUNNING; [EOL] } 
 [LINE] this.runningState = STATE_RUNNING; [LINE] public void start() { [EOL]     if (this.runningState == STATE_STOPPED) { [EOL]         throw new IllegalStateException("Stopwatch must be reset before being restarted. "); [EOL]     } [EOL]     if (this.runningState != STATE_UNSTARTED) { [EOL]         throw new IllegalStateException("Stopwatch already started. "); [EOL]     } [EOL]     this.startTime = System.nanoTime(); [EOL]     this.startTimeMillis = System.currentTimeMillis(); [EOL]     this.runningState = STATE_RUNNING; [EOL] } 
 [LINE] throw new IllegalStateException("Stopwatch is not running. "); [LINE] public void split() { [EOL]     if (this.runningState != STATE_RUNNING) { [EOL]         throw new IllegalStateException("Stopwatch is not running. "); [EOL]     } [EOL]     this.stopTime = System.nanoTime(); [EOL]     this.splitState = STATE_SPLIT; [EOL] } 
 [LINE] throw new IllegalStateException("Stopwatch has not been split. "); [LINE] public void unsplit() { [EOL]     if (this.splitState != STATE_SPLIT) { [EOL]         throw new IllegalStateException("Stopwatch has not been split. "); [EOL]     } [EOL]     this.splitState = STATE_UNSPLIT; [EOL] } 
 [LINE] this.runningState = STATE_RUNNING; [LINE] public void resume() { [EOL]     if (this.runningState != STATE_SUSPENDED) { [EOL]         throw new IllegalStateException("Stopwatch must be suspended to resume. "); [EOL]     } [EOL]     this.startTime += System.nanoTime() - this.stopTime; [EOL]     this.runningState = STATE_RUNNING; [EOL] } 
 [LINE] if (this.runningState == STATE_STOPPED || this.runningState == STATE_SUSPENDED) { [LINE] public long getNanoTime() { [EOL]     if (this.runningState == STATE_STOPPED || this.runningState == STATE_SUSPENDED) { [EOL]         return this.stopTime - this.startTime; [EOL]     } else if (this.runningState == STATE_UNSTARTED) { [EOL]         return 0; [EOL]     } else if (this.runningState == STATE_RUNNING) { [EOL]         return System.nanoTime() - this.startTime; [EOL]     } [EOL]     throw new RuntimeException("Illegal running state has occurred."); [EOL] } 
 [LINE] } else if (this.runningState == STATE_UNSTARTED) { [LINE] public long getNanoTime() { [EOL]     if (this.runningState == STATE_STOPPED || this.runningState == STATE_SUSPENDED) { [EOL]         return this.stopTime - this.startTime; [EOL]     } else if (this.runningState == STATE_UNSTARTED) { [EOL]         return 0; [EOL]     } else if (this.runningState == STATE_RUNNING) { [EOL]         return System.nanoTime() - this.startTime; [EOL]     } [EOL]     throw new RuntimeException("Illegal running state has occurred."); [EOL] } 
 [LINE] if (this.splitState != STATE_SPLIT) { [LINE] public long getSplitNanoTime() { [EOL]     if (this.splitState != STATE_SPLIT) { [EOL]         throw new IllegalStateException("Stopwatch must be split to get the split time. "); [EOL]     } [EOL]     return this.stopTime - this.startTime; [EOL] } 
lang3/builder/ToStringStyle.java
 [LINE] REGISTRY.set(new WeakHashMap<Object, Object>()); [LINE] static void register(final Object value) { [EOL]     if (value != null) { [EOL]         final Map<Object, Object> m = getRegistry(); [EOL]         if (m == null) { [EOL]             REGISTRY.set(new WeakHashMap<Object, Object>()); [EOL]         } [EOL]         getRegistry().put(value, null); [EOL]     } [EOL] } 
 [LINE] getRegistry().put(value, null); [LINE] static void register(final Object value) { [EOL]     if (value != null) { [EOL]         final Map<Object, Object> m = getRegistry(); [EOL]         if (m == null) { [EOL]             REGISTRY.set(new WeakHashMap<Object, Object>()); [EOL]         } [EOL]         getRegistry().put(value, null); [EOL]     } [EOL] } 
 [LINE] if (m.isEmpty()) { [LINE] static void unregister(final Object value) { [EOL]     if (value != null) { [EOL]         final Map<Object, Object> m = getRegistry(); [EOL]         if (m != null) { [EOL]             m.remove(value); [EOL]             if (m.isEmpty()) { [EOL]                 REGISTRY.remove(); [EOL]             } [EOL]         } [EOL]     } [EOL] } 
 [LINE] appendToString(buffer, superToString); [LINE] public void appendSuper(final StringBuffer buffer, final String superToString) { [EOL]     appendToString(buffer, superToString); [EOL] } 
 [LINE] final int pos2 = toString.lastIndexOf(contentEnd); [LINE] public void appendToString(final StringBuffer buffer, final String toString) { [EOL]     if (toString != null) { [EOL]         final int pos1 = toString.indexOf(contentStart) + contentStart.length(); [EOL]         final int pos2 = toString.lastIndexOf(contentEnd); [EOL]         if (pos1 != pos2 && pos1 >= 0 && pos2 >= 0) { [EOL]             final String data = toString.substring(pos1, pos2); [EOL]             if (fieldSeparatorAtStart) { [EOL]                 removeLastFieldSeparator(buffer); [EOL]             } [EOL]             buffer.append(data); [EOL]             appendFieldSeparator(buffer); [EOL]         } [EOL]     } [EOL] } 
 [LINE] if (object != null) { [LINE] public void appendStart(final StringBuffer buffer, final Object object) { [EOL]     if (object != null) { [EOL]         appendClassName(buffer, object); [EOL]         appendIdentityHashCode(buffer, object); [EOL]         appendContentStart(buffer); [EOL]         if (fieldSeparatorAtStart) { [EOL]             appendFieldSeparator(buffer); [EOL]         } [EOL]     } [EOL] } 
 [LINE] if (fieldSeparatorAtStart) { [LINE] public void appendStart(final StringBuffer buffer, final Object object) { [EOL]     if (object != null) { [EOL]         appendClassName(buffer, object); [EOL]         appendIdentityHashCode(buffer, object); [EOL]         appendContentStart(buffer); [EOL]         if (fieldSeparatorAtStart) { [EOL]             appendFieldSeparator(buffer); [EOL]         } [EOL]     } [EOL] } 
 [LINE] boolean match = true; [LINE] protected void removeLastFieldSeparator(final StringBuffer buffer) { [EOL]     final int len = buffer.length(); [EOL]     final int sepLen = fieldSeparator.length(); [EOL]     if (len > 0 && sepLen > 0 && len >= sepLen) { [EOL]         boolean match = true; [EOL]         for (int i = 0; i < sepLen; i++) { [EOL]             if (buffer.charAt(len - 1 - i) != fieldSeparator.charAt(sepLen - 1 - i)) { [EOL]                 match = false; [EOL]                 break; [EOL]             } [EOL]         } [EOL]         if (match) { [EOL]             buffer.setLength(len - sepLen); [EOL]         } [EOL]     } [EOL] } 
 [LINE] break; [LINE] protected void removeLastFieldSeparator(final StringBuffer buffer) { [EOL]     final int len = buffer.length(); [EOL]     final int sepLen = fieldSeparator.length(); [EOL]     if (len > 0 && sepLen > 0 && len >= sepLen) { [EOL]         boolean match = true; [EOL]         for (int i = 0; i < sepLen; i++) { [EOL]             if (buffer.charAt(len - 1 - i) != fieldSeparator.charAt(sepLen - 1 - i)) { [EOL]                 match = false; [EOL]                 break; [EOL]             } [EOL]         } [EOL]         if (match) { [EOL]             buffer.setLength(len - sepLen); [EOL]         } [EOL]     } [EOL] } 
 [LINE] if (match) { [LINE] protected void removeLastFieldSeparator(final StringBuffer buffer) { [EOL]     final int len = buffer.length(); [EOL]     final int sepLen = fieldSeparator.length(); [EOL]     if (len > 0 && sepLen > 0 && len >= sepLen) { [EOL]         boolean match = true; [EOL]         for (int i = 0; i < sepLen; i++) { [EOL]             if (buffer.charAt(len - 1 - i) != fieldSeparator.charAt(sepLen - 1 - i)) { [EOL]                 match = false; [EOL]                 break; [EOL]             } [EOL]         } [EOL]         if (match) { [EOL]             buffer.setLength(len - sepLen); [EOL]         } [EOL]     } [EOL] } 
 [LINE] return; [LINE] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail) { [EOL]     if (isRegistered(value) && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) { [EOL]         appendCyclicObject(buffer, fieldName, value); [EOL]         return; [EOL]     } [EOL]     register(value); [EOL]     try { [EOL]         if (value instanceof Collection<?>) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Collection<?>) value); [EOL]             } else { [EOL]                 appendSummarySize(buffer, fieldName, ((Collection<?>) value).size()); [EOL]             } [EOL]         } else if (value instanceof Map<?, ?>) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Map<?, ?>) value); [EOL]             } else { [EOL]                 appendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size()); [EOL]             } [EOL]         } else if (value instanceof long[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (long[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (long[]) value); [EOL]             } [EOL]         } else if (value instanceof int[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (int[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (int[]) value); [EOL]             } [EOL]         } else if (value instanceof short[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (short[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (short[]) value); [EOL]             } [EOL]         } else if (value instanceof byte[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (byte[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (byte[]) value); [EOL]             } [EOL]         } else if (value instanceof char[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (char[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (char[]) value); [EOL]             } [EOL]         } else if (value instanceof double[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (double[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (double[]) value); [EOL]             } [EOL]         } else if (value instanceof float[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (float[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (float[]) value); [EOL]             } [EOL]         } else if (value instanceof boolean[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (boolean[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (boolean[]) value); [EOL]             } [EOL]         } else if (value.getClass().isArray()) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Object[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (Object[]) value); [EOL]             } [EOL]         } else { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, value); [EOL]             } [EOL]         } [EOL]     } finally { [EOL]         unregister(value); [EOL]     } [EOL] } 
 [LINE] if (detail) { [LINE] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail) { [EOL]     if (isRegistered(value) && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) { [EOL]         appendCyclicObject(buffer, fieldName, value); [EOL]         return; [EOL]     } [EOL]     register(value); [EOL]     try { [EOL]         if (value instanceof Collection<?>) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Collection<?>) value); [EOL]             } else { [EOL]                 appendSummarySize(buffer, fieldName, ((Collection<?>) value).size()); [EOL]             } [EOL]         } else if (value instanceof Map<?, ?>) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Map<?, ?>) value); [EOL]             } else { [EOL]                 appendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size()); [EOL]             } [EOL]         } else if (value instanceof long[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (long[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (long[]) value); [EOL]             } [EOL]         } else if (value instanceof int[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (int[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (int[]) value); [EOL]             } [EOL]         } else if (value instanceof short[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (short[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (short[]) value); [EOL]             } [EOL]         } else if (value instanceof byte[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (byte[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (byte[]) value); [EOL]             } [EOL]         } else if (value instanceof char[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (char[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (char[]) value); [EOL]             } [EOL]         } else if (value instanceof double[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (double[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (double[]) value); [EOL]             } [EOL]         } else if (value instanceof float[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (float[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (float[]) value); [EOL]             } [EOL]         } else if (value instanceof boolean[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (boolean[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (boolean[]) value); [EOL]             } [EOL]         } else if (value.getClass().isArray()) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Object[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (Object[]) value); [EOL]             } [EOL]         } else { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, value); [EOL]             } [EOL]         } [EOL]     } finally { [EOL]         unregister(value); [EOL]     } [EOL] } 
 [LINE] appendDetail(buffer, fieldName, (Collection<?>) value); [LINE] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail) { [EOL]     if (isRegistered(value) && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) { [EOL]         appendCyclicObject(buffer, fieldName, value); [EOL]         return; [EOL]     } [EOL]     register(value); [EOL]     try { [EOL]         if (value instanceof Collection<?>) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Collection<?>) value); [EOL]             } else { [EOL]                 appendSummarySize(buffer, fieldName, ((Collection<?>) value).size()); [EOL]             } [EOL]         } else if (value instanceof Map<?, ?>) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Map<?, ?>) value); [EOL]             } else { [EOL]                 appendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size()); [EOL]             } [EOL]         } else if (value instanceof long[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (long[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (long[]) value); [EOL]             } [EOL]         } else if (value instanceof int[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (int[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (int[]) value); [EOL]             } [EOL]         } else if (value instanceof short[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (short[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (short[]) value); [EOL]             } [EOL]         } else if (value instanceof byte[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (byte[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (byte[]) value); [EOL]             } [EOL]         } else if (value instanceof char[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (char[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (char[]) value); [EOL]             } [EOL]         } else if (value instanceof double[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (double[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (double[]) value); [EOL]             } [EOL]         } else if (value instanceof float[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (float[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (float[]) value); [EOL]             } [EOL]         } else if (value instanceof boolean[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (boolean[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (boolean[]) value); [EOL]             } [EOL]         } else if (value.getClass().isArray()) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Object[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (Object[]) value); [EOL]             } [EOL]         } else { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, value); [EOL]             } [EOL]         } [EOL]     } finally { [EOL]         unregister(value); [EOL]     } [EOL] } 
 [LINE] if (detail) { [LINE] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail) { [EOL]     if (isRegistered(value) && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) { [EOL]         appendCyclicObject(buffer, fieldName, value); [EOL]         return; [EOL]     } [EOL]     register(value); [EOL]     try { [EOL]         if (value instanceof Collection<?>) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Collection<?>) value); [EOL]             } else { [EOL]                 appendSummarySize(buffer, fieldName, ((Collection<?>) value).size()); [EOL]             } [EOL]         } else if (value instanceof Map<?, ?>) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Map<?, ?>) value); [EOL]             } else { [EOL]                 appendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size()); [EOL]             } [EOL]         } else if (value instanceof long[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (long[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (long[]) value); [EOL]             } [EOL]         } else if (value instanceof int[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (int[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (int[]) value); [EOL]             } [EOL]         } else if (value instanceof short[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (short[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (short[]) value); [EOL]             } [EOL]         } else if (value instanceof byte[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (byte[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (byte[]) value); [EOL]             } [EOL]         } else if (value instanceof char[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (char[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (char[]) value); [EOL]             } [EOL]         } else if (value instanceof double[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (double[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (double[]) value); [EOL]             } [EOL]         } else if (value instanceof float[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (float[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (float[]) value); [EOL]             } [EOL]         } else if (value instanceof boolean[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (boolean[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (boolean[]) value); [EOL]             } [EOL]         } else if (value.getClass().isArray()) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Object[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (Object[]) value); [EOL]             } [EOL]         } else { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, value); [EOL]             } [EOL]         } [EOL]     } finally { [EOL]         unregister(value); [EOL]     } [EOL] } 
 [LINE] appendDetail(buffer, fieldName, (Map<?, ?>) value); [LINE] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail) { [EOL]     if (isRegistered(value) && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) { [EOL]         appendCyclicObject(buffer, fieldName, value); [EOL]         return; [EOL]     } [EOL]     register(value); [EOL]     try { [EOL]         if (value instanceof Collection<?>) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Collection<?>) value); [EOL]             } else { [EOL]                 appendSummarySize(buffer, fieldName, ((Collection<?>) value).size()); [EOL]             } [EOL]         } else if (value instanceof Map<?, ?>) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Map<?, ?>) value); [EOL]             } else { [EOL]                 appendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size()); [EOL]             } [EOL]         } else if (value instanceof long[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (long[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (long[]) value); [EOL]             } [EOL]         } else if (value instanceof int[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (int[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (int[]) value); [EOL]             } [EOL]         } else if (value instanceof short[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (short[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (short[]) value); [EOL]             } [EOL]         } else if (value instanceof byte[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (byte[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (byte[]) value); [EOL]             } [EOL]         } else if (value instanceof char[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (char[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (char[]) value); [EOL]             } [EOL]         } else if (value instanceof double[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (double[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (double[]) value); [EOL]             } [EOL]         } else if (value instanceof float[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (float[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (float[]) value); [EOL]             } [EOL]         } else if (value instanceof boolean[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (boolean[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (boolean[]) value); [EOL]             } [EOL]         } else if (value.getClass().isArray()) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Object[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (Object[]) value); [EOL]             } [EOL]         } else { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, value); [EOL]             } [EOL]         } [EOL]     } finally { [EOL]         unregister(value); [EOL]     } [EOL] } 
 [LINE] appendDetail(buffer, fieldName, (long[]) value); [LINE] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail) { [EOL]     if (isRegistered(value) && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) { [EOL]         appendCyclicObject(buffer, fieldName, value); [EOL]         return; [EOL]     } [EOL]     register(value); [EOL]     try { [EOL]         if (value instanceof Collection<?>) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Collection<?>) value); [EOL]             } else { [EOL]                 appendSummarySize(buffer, fieldName, ((Collection<?>) value).size()); [EOL]             } [EOL]         } else if (value instanceof Map<?, ?>) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Map<?, ?>) value); [EOL]             } else { [EOL]                 appendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size()); [EOL]             } [EOL]         } else if (value instanceof long[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (long[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (long[]) value); [EOL]             } [EOL]         } else if (value instanceof int[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (int[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (int[]) value); [EOL]             } [EOL]         } else if (value instanceof short[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (short[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (short[]) value); [EOL]             } [EOL]         } else if (value instanceof byte[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (byte[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (byte[]) value); [EOL]             } [EOL]         } else if (value instanceof char[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (char[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (char[]) value); [EOL]             } [EOL]         } else if (value instanceof double[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (double[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (double[]) value); [EOL]             } [EOL]         } else if (value instanceof float[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (float[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (float[]) value); [EOL]             } [EOL]         } else if (value instanceof boolean[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (boolean[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (boolean[]) value); [EOL]             } [EOL]         } else if (value.getClass().isArray()) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Object[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (Object[]) value); [EOL]             } [EOL]         } else { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, value); [EOL]             } [EOL]         } [EOL]     } finally { [EOL]         unregister(value); [EOL]     } [EOL] } 
 [LINE] } else if (value instanceof int[]) { [LINE] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail) { [EOL]     if (isRegistered(value) && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) { [EOL]         appendCyclicObject(buffer, fieldName, value); [EOL]         return; [EOL]     } [EOL]     register(value); [EOL]     try { [EOL]         if (value instanceof Collection<?>) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Collection<?>) value); [EOL]             } else { [EOL]                 appendSummarySize(buffer, fieldName, ((Collection<?>) value).size()); [EOL]             } [EOL]         } else if (value instanceof Map<?, ?>) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Map<?, ?>) value); [EOL]             } else { [EOL]                 appendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size()); [EOL]             } [EOL]         } else if (value instanceof long[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (long[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (long[]) value); [EOL]             } [EOL]         } else if (value instanceof int[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (int[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (int[]) value); [EOL]             } [EOL]         } else if (value instanceof short[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (short[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (short[]) value); [EOL]             } [EOL]         } else if (value instanceof byte[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (byte[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (byte[]) value); [EOL]             } [EOL]         } else if (value instanceof char[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (char[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (char[]) value); [EOL]             } [EOL]         } else if (value instanceof double[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (double[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (double[]) value); [EOL]             } [EOL]         } else if (value instanceof float[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (float[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (float[]) value); [EOL]             } [EOL]         } else if (value instanceof boolean[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (boolean[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (boolean[]) value); [EOL]             } [EOL]         } else if (value.getClass().isArray()) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Object[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (Object[]) value); [EOL]             } [EOL]         } else { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, value); [EOL]             } [EOL]         } [EOL]     } finally { [EOL]         unregister(value); [EOL]     } [EOL] } 
 [LINE] } else if (value instanceof short[]) { [LINE] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail) { [EOL]     if (isRegistered(value) && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) { [EOL]         appendCyclicObject(buffer, fieldName, value); [EOL]         return; [EOL]     } [EOL]     register(value); [EOL]     try { [EOL]         if (value instanceof Collection<?>) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Collection<?>) value); [EOL]             } else { [EOL]                 appendSummarySize(buffer, fieldName, ((Collection<?>) value).size()); [EOL]             } [EOL]         } else if (value instanceof Map<?, ?>) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Map<?, ?>) value); [EOL]             } else { [EOL]                 appendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size()); [EOL]             } [EOL]         } else if (value instanceof long[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (long[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (long[]) value); [EOL]             } [EOL]         } else if (value instanceof int[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (int[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (int[]) value); [EOL]             } [EOL]         } else if (value instanceof short[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (short[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (short[]) value); [EOL]             } [EOL]         } else if (value instanceof byte[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (byte[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (byte[]) value); [EOL]             } [EOL]         } else if (value instanceof char[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (char[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (char[]) value); [EOL]             } [EOL]         } else if (value instanceof double[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (double[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (double[]) value); [EOL]             } [EOL]         } else if (value instanceof float[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (float[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (float[]) value); [EOL]             } [EOL]         } else if (value instanceof boolean[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (boolean[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (boolean[]) value); [EOL]             } [EOL]         } else if (value.getClass().isArray()) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Object[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (Object[]) value); [EOL]             } [EOL]         } else { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, value); [EOL]             } [EOL]         } [EOL]     } finally { [EOL]         unregister(value); [EOL]     } [EOL] } 
 [LINE] } else if (value instanceof double[]) { [LINE] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail) { [EOL]     if (isRegistered(value) && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) { [EOL]         appendCyclicObject(buffer, fieldName, value); [EOL]         return; [EOL]     } [EOL]     register(value); [EOL]     try { [EOL]         if (value instanceof Collection<?>) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Collection<?>) value); [EOL]             } else { [EOL]                 appendSummarySize(buffer, fieldName, ((Collection<?>) value).size()); [EOL]             } [EOL]         } else if (value instanceof Map<?, ?>) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Map<?, ?>) value); [EOL]             } else { [EOL]                 appendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size()); [EOL]             } [EOL]         } else if (value instanceof long[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (long[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (long[]) value); [EOL]             } [EOL]         } else if (value instanceof int[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (int[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (int[]) value); [EOL]             } [EOL]         } else if (value instanceof short[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (short[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (short[]) value); [EOL]             } [EOL]         } else if (value instanceof byte[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (byte[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (byte[]) value); [EOL]             } [EOL]         } else if (value instanceof char[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (char[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (char[]) value); [EOL]             } [EOL]         } else if (value instanceof double[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (double[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (double[]) value); [EOL]             } [EOL]         } else if (value instanceof float[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (float[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (float[]) value); [EOL]             } [EOL]         } else if (value instanceof boolean[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (boolean[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (boolean[]) value); [EOL]             } [EOL]         } else if (value.getClass().isArray()) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Object[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (Object[]) value); [EOL]             } [EOL]         } else { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, value); [EOL]             } [EOL]         } [EOL]     } finally { [EOL]         unregister(value); [EOL]     } [EOL] } 
 [LINE] appendDetail(buffer, fieldName, (double[]) value); [LINE] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail) { [EOL]     if (isRegistered(value) && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) { [EOL]         appendCyclicObject(buffer, fieldName, value); [EOL]         return; [EOL]     } [EOL]     register(value); [EOL]     try { [EOL]         if (value instanceof Collection<?>) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Collection<?>) value); [EOL]             } else { [EOL]                 appendSummarySize(buffer, fieldName, ((Collection<?>) value).size()); [EOL]             } [EOL]         } else if (value instanceof Map<?, ?>) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Map<?, ?>) value); [EOL]             } else { [EOL]                 appendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size()); [EOL]             } [EOL]         } else if (value instanceof long[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (long[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (long[]) value); [EOL]             } [EOL]         } else if (value instanceof int[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (int[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (int[]) value); [EOL]             } [EOL]         } else if (value instanceof short[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (short[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (short[]) value); [EOL]             } [EOL]         } else if (value instanceof byte[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (byte[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (byte[]) value); [EOL]             } [EOL]         } else if (value instanceof char[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (char[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (char[]) value); [EOL]             } [EOL]         } else if (value instanceof double[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (double[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (double[]) value); [EOL]             } [EOL]         } else if (value instanceof float[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (float[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (float[]) value); [EOL]             } [EOL]         } else if (value instanceof boolean[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (boolean[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (boolean[]) value); [EOL]             } [EOL]         } else if (value.getClass().isArray()) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Object[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (Object[]) value); [EOL]             } [EOL]         } else { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, value); [EOL]             } [EOL]         } [EOL]     } finally { [EOL]         unregister(value); [EOL]     } [EOL] } 
 [LINE] appendDetail(buffer, fieldName, (boolean[]) value); [LINE] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail) { [EOL]     if (isRegistered(value) && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) { [EOL]         appendCyclicObject(buffer, fieldName, value); [EOL]         return; [EOL]     } [EOL]     register(value); [EOL]     try { [EOL]         if (value instanceof Collection<?>) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Collection<?>) value); [EOL]             } else { [EOL]                 appendSummarySize(buffer, fieldName, ((Collection<?>) value).size()); [EOL]             } [EOL]         } else if (value instanceof Map<?, ?>) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Map<?, ?>) value); [EOL]             } else { [EOL]                 appendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size()); [EOL]             } [EOL]         } else if (value instanceof long[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (long[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (long[]) value); [EOL]             } [EOL]         } else if (value instanceof int[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (int[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (int[]) value); [EOL]             } [EOL]         } else if (value instanceof short[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (short[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (short[]) value); [EOL]             } [EOL]         } else if (value instanceof byte[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (byte[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (byte[]) value); [EOL]             } [EOL]         } else if (value instanceof char[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (char[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (char[]) value); [EOL]             } [EOL]         } else if (value instanceof double[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (double[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (double[]) value); [EOL]             } [EOL]         } else if (value instanceof float[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (float[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (float[]) value); [EOL]             } [EOL]         } else if (value instanceof boolean[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (boolean[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (boolean[]) value); [EOL]             } [EOL]         } else if (value.getClass().isArray()) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Object[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (Object[]) value); [EOL]             } [EOL]         } else { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, value); [EOL]             } [EOL]         } [EOL]     } finally { [EOL]         unregister(value); [EOL]     } [EOL] } 
 [LINE] appendDetail(buffer, fieldName, value); [LINE] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail) { [EOL]     if (isRegistered(value) && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) { [EOL]         appendCyclicObject(buffer, fieldName, value); [EOL]         return; [EOL]     } [EOL]     register(value); [EOL]     try { [EOL]         if (value instanceof Collection<?>) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Collection<?>) value); [EOL]             } else { [EOL]                 appendSummarySize(buffer, fieldName, ((Collection<?>) value).size()); [EOL]             } [EOL]         } else if (value instanceof Map<?, ?>) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Map<?, ?>) value); [EOL]             } else { [EOL]                 appendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size()); [EOL]             } [EOL]         } else if (value instanceof long[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (long[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (long[]) value); [EOL]             } [EOL]         } else if (value instanceof int[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (int[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (int[]) value); [EOL]             } [EOL]         } else if (value instanceof short[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (short[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (short[]) value); [EOL]             } [EOL]         } else if (value instanceof byte[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (byte[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (byte[]) value); [EOL]             } [EOL]         } else if (value instanceof char[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (char[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (char[]) value); [EOL]             } [EOL]         } else if (value instanceof double[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (double[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (double[]) value); [EOL]             } [EOL]         } else if (value instanceof float[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (float[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (float[]) value); [EOL]             } [EOL]         } else if (value instanceof boolean[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (boolean[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (boolean[]) value); [EOL]             } [EOL]         } else if (value.getClass().isArray()) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Object[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (Object[]) value); [EOL]             } [EOL]         } else { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, value); [EOL]             } [EOL]         } [EOL]     } finally { [EOL]         unregister(value); [EOL]     } [EOL] } 
 [LINE] appendSummary(buffer, fieldName, value); [LINE] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail) { [EOL]     if (isRegistered(value) && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) { [EOL]         appendCyclicObject(buffer, fieldName, value); [EOL]         return; [EOL]     } [EOL]     register(value); [EOL]     try { [EOL]         if (value instanceof Collection<?>) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Collection<?>) value); [EOL]             } else { [EOL]                 appendSummarySize(buffer, fieldName, ((Collection<?>) value).size()); [EOL]             } [EOL]         } else if (value instanceof Map<?, ?>) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Map<?, ?>) value); [EOL]             } else { [EOL]                 appendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size()); [EOL]             } [EOL]         } else if (value instanceof long[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (long[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (long[]) value); [EOL]             } [EOL]         } else if (value instanceof int[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (int[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (int[]) value); [EOL]             } [EOL]         } else if (value instanceof short[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (short[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (short[]) value); [EOL]             } [EOL]         } else if (value instanceof byte[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (byte[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (byte[]) value); [EOL]             } [EOL]         } else if (value instanceof char[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (char[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (char[]) value); [EOL]             } [EOL]         } else if (value instanceof double[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (double[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (double[]) value); [EOL]             } [EOL]         } else if (value instanceof float[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (float[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (float[]) value); [EOL]             } [EOL]         } else if (value instanceof boolean[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (boolean[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (boolean[]) value); [EOL]             } [EOL]         } else if (value.getClass().isArray()) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Object[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (Object[]) value); [EOL]             } [EOL]         } else { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, value); [EOL]             } [EOL]         } [EOL]     } finally { [EOL]         unregister(value); [EOL]     } [EOL] } 
 [LINE] ObjectUtils.identityToString(buffer, value); [LINE] protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value) { [EOL]     ObjectUtils.identityToString(buffer, value); [EOL] } 
 [LINE] buffer.append(map); [LINE] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map) { [EOL]     buffer.append(map); [EOL] } 
 [LINE] buffer.append(summaryObjectStartText); [LINE] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value) { [EOL]     buffer.append(summaryObjectStartText); [EOL]     buffer.append(getShortClassName(value.getClass())); [EOL]     buffer.append(summaryObjectEndText); [EOL] } 
 [LINE] buffer.append(getShortClassName(value.getClass())); [LINE] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value) { [EOL]     buffer.append(summaryObjectStartText); [EOL]     buffer.append(getShortClassName(value.getClass())); [EOL]     buffer.append(summaryObjectEndText); [EOL] } 
 [LINE] appendFieldEnd(buffer, fieldName); [LINE] public void append(final StringBuffer buffer, final String fieldName, final short value) { [EOL]     appendFieldStart(buffer, fieldName); [EOL]     appendDetail(buffer, fieldName, value); [EOL]     appendFieldEnd(buffer, fieldName); [EOL] } 
 [LINE] appendFieldStart(buffer, fieldName); [LINE] public void append(final StringBuffer buffer, final String fieldName, final double value) { [EOL]     appendFieldStart(buffer, fieldName); [EOL]     appendDetail(buffer, fieldName, value); [EOL]     appendFieldEnd(buffer, fieldName); [EOL] } 
 [LINE] appendFieldEnd(buffer, fieldName); [LINE] public void append(final StringBuffer buffer, final String fieldName, final float value) { [EOL]     appendFieldStart(buffer, fieldName); [EOL]     appendDetail(buffer, fieldName, value); [EOL]     appendFieldEnd(buffer, fieldName); [EOL] } 
 [LINE] appendFieldStart(buffer, fieldName); [LINE] public void append(final StringBuffer buffer, final String fieldName, final boolean value) { [EOL]     appendFieldStart(buffer, fieldName); [EOL]     appendDetail(buffer, fieldName, value); [EOL]     appendFieldEnd(buffer, fieldName); [EOL] } 
 [LINE] if (i > 0) { [LINE] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array) { [EOL]     buffer.append(arrayStart); [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Object item = array[i]; [EOL]         if (i > 0) { [EOL]             buffer.append(arraySeparator); [EOL]         } [EOL]         if (item == null) { [EOL]             appendNullText(buffer, fieldName); [EOL]         } else { [EOL]             appendInternal(buffer, fieldName, item, arrayContentDetail); [EOL]         } [EOL]     } [EOL]     buffer.append(arrayEnd); [EOL] } 
 [LINE] buffer.append(arrayEnd); [LINE] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array) { [EOL]     buffer.append(arrayStart); [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Object item = array[i]; [EOL]         if (i > 0) { [EOL]             buffer.append(arraySeparator); [EOL]         } [EOL]         if (item == null) { [EOL]             appendNullText(buffer, fieldName); [EOL]         } else { [EOL]             appendInternal(buffer, fieldName, item, arrayContentDetail); [EOL]         } [EOL]     } [EOL]     buffer.append(arrayEnd); [EOL] } 
 [LINE] for (int i = 0; i < length; i++) { [LINE] protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array) { [EOL]     buffer.append(arrayStart); [EOL]     final int length = Array.getLength(array); [EOL]     for (int i = 0; i < length; i++) { [EOL]         final Object item = Array.get(array, i); [EOL]         if (i > 0) { [EOL]             buffer.append(arraySeparator); [EOL]         } [EOL]         if (item == null) { [EOL]             appendNullText(buffer, fieldName); [EOL]         } else { [EOL]             appendInternal(buffer, fieldName, item, arrayContentDetail); [EOL]         } [EOL]     } [EOL]     buffer.append(arrayEnd); [EOL] } 
 [LINE] appendInternal(buffer, fieldName, item, arrayContentDetail); [LINE] protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array) { [EOL]     buffer.append(arrayStart); [EOL]     final int length = Array.getLength(array); [EOL]     for (int i = 0; i < length; i++) { [EOL]         final Object item = Array.get(array, i); [EOL]         if (i > 0) { [EOL]             buffer.append(arraySeparator); [EOL]         } [EOL]         if (item == null) { [EOL]             appendNullText(buffer, fieldName); [EOL]         } else { [EOL]             appendInternal(buffer, fieldName, item, arrayContentDetail); [EOL]         } [EOL]     } [EOL]     buffer.append(arrayEnd); [EOL] } 
 [LINE] buffer.append(arrayEnd); [LINE] protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array) { [EOL]     buffer.append(arrayStart); [EOL]     final int length = Array.getLength(array); [EOL]     for (int i = 0; i < length; i++) { [EOL]         final Object item = Array.get(array, i); [EOL]         if (i > 0) { [EOL]             buffer.append(arraySeparator); [EOL]         } [EOL]         if (item == null) { [EOL]             appendNullText(buffer, fieldName); [EOL]         } else { [EOL]             appendInternal(buffer, fieldName, item, arrayContentDetail); [EOL]         } [EOL]     } [EOL]     buffer.append(arrayEnd); [EOL] } 
 [LINE] buffer.append(arrayEnd); [LINE] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array) { [EOL]     buffer.append(arrayStart); [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         if (i > 0) { [EOL]             buffer.append(arraySeparator); [EOL]         } [EOL]         appendDetail(buffer, fieldName, array[i]); [EOL]     } [EOL]     buffer.append(arrayEnd); [EOL] } 
 [LINE] } else if (isFullDetail(fullDetail)) { [LINE] public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail) { [EOL]     appendFieldStart(buffer, fieldName); [EOL]     if (array == null) { [EOL]         appendNullText(buffer, fieldName); [EOL]     } else if (isFullDetail(fullDetail)) { [EOL]         appendDetail(buffer, fieldName, array); [EOL]     } else { [EOL]         appendSummary(buffer, fieldName, array); [EOL]     } [EOL]     appendFieldEnd(buffer, fieldName); [EOL] } 
 [LINE] if (i > 0) { [LINE] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array) { [EOL]     buffer.append(arrayStart); [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         if (i > 0) { [EOL]             buffer.append(arraySeparator); [EOL]         } [EOL]         appendDetail(buffer, fieldName, array[i]); [EOL]     } [EOL]     buffer.append(arrayEnd); [EOL] } 
 [LINE] buffer.append(arrayEnd); [LINE] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array) { [EOL]     buffer.append(arrayStart); [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         if (i > 0) { [EOL]             buffer.append(arraySeparator); [EOL]         } [EOL]         appendDetail(buffer, fieldName, array[i]); [EOL]     } [EOL]     buffer.append(arrayEnd); [EOL] } 
 [LINE] if (array == null) { [LINE] public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail) { [EOL]     appendFieldStart(buffer, fieldName); [EOL]     if (array == null) { [EOL]         appendNullText(buffer, fieldName); [EOL]     } else if (isFullDetail(fullDetail)) { [EOL]         appendDetail(buffer, fieldName, array); [EOL]     } else { [EOL]         appendSummary(buffer, fieldName, array); [EOL]     } [EOL]     appendFieldEnd(buffer, fieldName); [EOL] } 
 [LINE] appendNullText(buffer, fieldName); [LINE] public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail) { [EOL]     appendFieldStart(buffer, fieldName); [EOL]     if (array == null) { [EOL]         appendNullText(buffer, fieldName); [EOL]     } else if (isFullDetail(fullDetail)) { [EOL]         appendDetail(buffer, fieldName, array); [EOL]     } else { [EOL]         appendSummary(buffer, fieldName, array); [EOL]     } [EOL]     appendFieldEnd(buffer, fieldName); [EOL] } 
 [LINE] } else if (isFullDetail(fullDetail)) { [LINE] public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail) { [EOL]     appendFieldStart(buffer, fieldName); [EOL]     if (array == null) { [EOL]         appendNullText(buffer, fieldName); [EOL]     } else if (isFullDetail(fullDetail)) { [EOL]         appendDetail(buffer, fieldName, array); [EOL]     } else { [EOL]         appendSummary(buffer, fieldName, array); [EOL]     } [EOL]     appendFieldEnd(buffer, fieldName); [EOL] } 
 [LINE] appendDetail(buffer, fieldName, array); [LINE] public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail) { [EOL]     appendFieldStart(buffer, fieldName); [EOL]     if (array == null) { [EOL]         appendNullText(buffer, fieldName); [EOL]     } else if (isFullDetail(fullDetail)) { [EOL]         appendDetail(buffer, fieldName, array); [EOL]     } else { [EOL]         appendSummary(buffer, fieldName, array); [EOL]     } [EOL]     appendFieldEnd(buffer, fieldName); [EOL] } 
 [LINE] buffer.append(arrayStart); [LINE] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array) { [EOL]     buffer.append(arrayStart); [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         if (i > 0) { [EOL]             buffer.append(arraySeparator); [EOL]         } [EOL]         appendDetail(buffer, fieldName, array[i]); [EOL]     } [EOL]     buffer.append(arrayEnd); [EOL] } 
 [LINE] buffer.append(arraySeparator); [LINE] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array) { [EOL]     buffer.append(arrayStart); [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         if (i > 0) { [EOL]             buffer.append(arraySeparator); [EOL]         } [EOL]         appendDetail(buffer, fieldName, array[i]); [EOL]     } [EOL]     buffer.append(arrayEnd); [EOL] } 
 [LINE] } else if (isFullDetail(fullDetail)) { [LINE] public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail) { [EOL]     appendFieldStart(buffer, fieldName); [EOL]     if (array == null) { [EOL]         appendNullText(buffer, fieldName); [EOL]     } else if (isFullDetail(fullDetail)) { [EOL]         appendDetail(buffer, fieldName, array); [EOL]     } else { [EOL]         appendSummary(buffer, fieldName, array); [EOL]     } [EOL]     appendFieldEnd(buffer, fieldName); [EOL] } 
 [LINE] buffer.append(arraySeparator); [LINE] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array) { [EOL]     buffer.append(arrayStart); [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         if (i > 0) { [EOL]             buffer.append(arraySeparator); [EOL]         } [EOL]         appendDetail(buffer, fieldName, array[i]); [EOL]     } [EOL]     buffer.append(arrayEnd); [EOL] } 
 [LINE] appendFieldStart(buffer, fieldName); [LINE] public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail) { [EOL]     appendFieldStart(buffer, fieldName); [EOL]     if (array == null) { [EOL]         appendNullText(buffer, fieldName); [EOL]     } else if (isFullDetail(fullDetail)) { [EOL]         appendDetail(buffer, fieldName, array); [EOL]     } else { [EOL]         appendSummary(buffer, fieldName, array); [EOL]     } [EOL]     appendFieldEnd(buffer, fieldName); [EOL] } 
 [LINE] } else if (isFullDetail(fullDetail)) { [LINE] public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail) { [EOL]     appendFieldStart(buffer, fieldName); [EOL]     if (array == null) { [EOL]         appendNullText(buffer, fieldName); [EOL]     } else if (isFullDetail(fullDetail)) { [EOL]         appendDetail(buffer, fieldName, array); [EOL]     } else { [EOL]         appendSummary(buffer, fieldName, array); [EOL]     } [EOL]     appendFieldEnd(buffer, fieldName); [EOL] } 
 [LINE] appendFieldEnd(buffer, fieldName); [LINE] public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail) { [EOL]     appendFieldStart(buffer, fieldName); [EOL]     if (array == null) { [EOL]         appendNullText(buffer, fieldName); [EOL]     } else if (isFullDetail(fullDetail)) { [EOL]         appendDetail(buffer, fieldName, array); [EOL]     } else { [EOL]         appendSummary(buffer, fieldName, array); [EOL]     } [EOL]     appendFieldEnd(buffer, fieldName); [EOL] } 
 [LINE] buffer.append(arraySeparator); [LINE] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array) { [EOL]     buffer.append(arrayStart); [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         if (i > 0) { [EOL]             buffer.append(arraySeparator); [EOL]         } [EOL]         appendDetail(buffer, fieldName, array[i]); [EOL]     } [EOL]     buffer.append(arrayEnd); [EOL] } 
 [LINE] appendDetail(buffer, fieldName, array[i]); [LINE] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array) { [EOL]     buffer.append(arrayStart); [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         if (i > 0) { [EOL]             buffer.append(arraySeparator); [EOL]         } [EOL]         appendDetail(buffer, fieldName, array[i]); [EOL]     } [EOL]     buffer.append(arrayEnd); [EOL] } 
 [LINE] appendFieldStart(buffer, fieldName); [LINE] public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail) { [EOL]     appendFieldStart(buffer, fieldName); [EOL]     if (array == null) { [EOL]         appendNullText(buffer, fieldName); [EOL]     } else if (isFullDetail(fullDetail)) { [EOL]         appendDetail(buffer, fieldName, array); [EOL]     } else { [EOL]         appendSummary(buffer, fieldName, array); [EOL]     } [EOL]     appendFieldEnd(buffer, fieldName); [EOL] } 
 [LINE] appendNullText(buffer, fieldName); [LINE] public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail) { [EOL]     appendFieldStart(buffer, fieldName); [EOL]     if (array == null) { [EOL]         appendNullText(buffer, fieldName); [EOL]     } else if (isFullDetail(fullDetail)) { [EOL]         appendDetail(buffer, fieldName, array); [EOL]     } else { [EOL]         appendSummary(buffer, fieldName, array); [EOL]     } [EOL]     appendFieldEnd(buffer, fieldName); [EOL] } 
 [LINE] buffer.append(arraySeparator); [LINE] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array) { [EOL]     buffer.append(arrayStart); [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         if (i > 0) { [EOL]             buffer.append(arraySeparator); [EOL]         } [EOL]         appendDetail(buffer, fieldName, array[i]); [EOL]     } [EOL]     buffer.append(arrayEnd); [EOL] } 
 [LINE] if (array == null) { [LINE] public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail) { [EOL]     appendFieldStart(buffer, fieldName); [EOL]     if (array == null) { [EOL]         appendNullText(buffer, fieldName); [EOL]     } else if (isFullDetail(fullDetail)) { [EOL]         appendDetail(buffer, fieldName, array); [EOL]     } else { [EOL]         appendSummary(buffer, fieldName, array); [EOL]     } [EOL]     appendFieldEnd(buffer, fieldName); [EOL] } 
 [LINE] appendDetail(buffer, fieldName, array); [LINE] public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail) { [EOL]     appendFieldStart(buffer, fieldName); [EOL]     if (array == null) { [EOL]         appendNullText(buffer, fieldName); [EOL]     } else if (isFullDetail(fullDetail)) { [EOL]         appendDetail(buffer, fieldName, array); [EOL]     } else { [EOL]         appendSummary(buffer, fieldName, array); [EOL]     } [EOL]     appendFieldEnd(buffer, fieldName); [EOL] } 
 [LINE] buffer.append(arrayStart); [LINE] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array) { [EOL]     buffer.append(arrayStart); [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         if (i > 0) { [EOL]             buffer.append(arraySeparator); [EOL]         } [EOL]         appendDetail(buffer, fieldName, array[i]); [EOL]     } [EOL]     buffer.append(arrayEnd); [EOL] } 
 [LINE] for (int i = 0; i < array.length; i++) { [LINE] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array) { [EOL]     buffer.append(arrayStart); [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         if (i > 0) { [EOL]             buffer.append(arraySeparator); [EOL]         } [EOL]         appendDetail(buffer, fieldName, array[i]); [EOL]     } [EOL]     buffer.append(arrayEnd); [EOL] } 
 [LINE] if (i > 0) { [LINE] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array) { [EOL]     buffer.append(arrayStart); [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         if (i > 0) { [EOL]             buffer.append(arraySeparator); [EOL]         } [EOL]         appendDetail(buffer, fieldName, array[i]); [EOL]     } [EOL]     buffer.append(arrayEnd); [EOL] } 
 [LINE] buffer.append(arraySeparator); [LINE] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array) { [EOL]     buffer.append(arrayStart); [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         if (i > 0) { [EOL]             buffer.append(arraySeparator); [EOL]         } [EOL]         appendDetail(buffer, fieldName, array[i]); [EOL]     } [EOL]     buffer.append(arrayEnd); [EOL] } 
 [LINE] appendFieldEnd(buffer, fieldName); [LINE] public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) { [EOL]     appendFieldStart(buffer, fieldName); [EOL]     if (array == null) { [EOL]         appendNullText(buffer, fieldName); [EOL]     } else if (isFullDetail(fullDetail)) { [EOL]         appendDetail(buffer, fieldName, array); [EOL]     } else { [EOL]         appendSummary(buffer, fieldName, array); [EOL]     } [EOL]     appendFieldEnd(buffer, fieldName); [EOL] } 
 [LINE] register(object); [LINE] protected void appendClassName(final StringBuffer buffer, final Object object) { [EOL]     if (useClassName && object != null) { [EOL]         register(object); [EOL]         if (useShortClassName) { [EOL]             buffer.append(getShortClassName(object.getClass())); [EOL]         } else { [EOL]             buffer.append(object.getClass().getName()); [EOL]         } [EOL]     } [EOL] } 
 [LINE] buffer.append(contentStart); [LINE] protected void appendContentStart(final StringBuffer buffer) { [EOL]     buffer.append(contentStart); [EOL] } 
 [LINE] buffer.append(fieldName); [LINE] protected void appendFieldStart(final StringBuffer buffer, final String fieldName) { [EOL]     if (useFieldNames && fieldName != null) { [EOL]         buffer.append(fieldName); [EOL]         buffer.append(fieldNameValueSeparator); [EOL]     } [EOL] } 
 [LINE] buffer.append(fieldNameValueSeparator); [LINE] protected void appendFieldStart(final StringBuffer buffer, final String fieldName) { [EOL]     if (useFieldNames && fieldName != null) { [EOL]         buffer.append(fieldName); [EOL]         buffer.append(fieldNameValueSeparator); [EOL]     } [EOL] } 
 [LINE] buffer.append(sizeEndText); [LINE] protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size) { [EOL]     buffer.append(sizeStartText); [EOL]     buffer.append(size); [EOL]     buffer.append(sizeEndText); [EOL] } 
 [LINE] this.defaultFullDetail = defaultFullDetail; [LINE] protected void setDefaultFullDetail(final boolean defaultFullDetail) { [EOL]     this.defaultFullDetail = defaultFullDetail; [EOL] } 
 [LINE] this.arrayContentDetail = arrayContentDetail; [LINE] protected void setArrayContentDetail(final boolean arrayContentDetail) { [EOL]     this.arrayContentDetail = arrayContentDetail; [EOL] } 
 [LINE] return arrayStart; [LINE] protected String getArrayStart() { [EOL]     return arrayStart; [EOL] } 
 [LINE] if (contentEnd == null) { [LINE] protected void setContentEnd(String contentEnd) { [EOL]     if (contentEnd == null) { [EOL]         contentEnd = ""; [EOL]     } [EOL]     this.contentEnd = contentEnd; [EOL] } 
 [LINE] fieldNameValueSeparator = ""; [LINE] protected void setFieldNameValueSeparator(String fieldNameValueSeparator) { [EOL]     if (fieldNameValueSeparator == null) { [EOL]         fieldNameValueSeparator = ""; [EOL]     } [EOL]     this.fieldNameValueSeparator = fieldNameValueSeparator; [EOL] } 
 [LINE] fieldSeparator = ""; [LINE] protected void setFieldSeparator(String fieldSeparator) { [EOL]     if (fieldSeparator == null) { [EOL]         fieldSeparator = ""; [EOL]     } [EOL]     this.fieldSeparator = fieldSeparator; [EOL] } 
 [LINE] if (nullText == null) { [LINE] protected void setNullText(String nullText) { [EOL]     if (nullText == null) { [EOL]         nullText = ""; [EOL]     } [EOL]     this.nullText = nullText; [EOL] } 
 [LINE] return summaryObjectStartText; [LINE] protected String getSummaryObjectStartText() { [EOL]     return summaryObjectStartText; [EOL] } 
 [LINE] return summaryObjectEndText; [LINE] protected String getSummaryObjectEndText() { [EOL]     return summaryObjectEndText; [EOL] } 
 [LINE] summaryObjectEndText = ""; [LINE] protected void setSummaryObjectEndText(String summaryObjectEndText) { [EOL]     if (summaryObjectEndText == null) { [EOL]         summaryObjectEndText = ""; [EOL]     } [EOL]     this.summaryObjectEndText = summaryObjectEndText; [EOL] } 
lang3/reflect/TypeUtils.java
 [LINE] return isAssignable(type, (GenericArrayType) toType, typeVarAssigns); [LINE] private static boolean isAssignable(final Type type, final Type toType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (toType == null || toType instanceof Class<?>) { [EOL]         return isAssignable(type, (Class<?>) toType); [EOL]     } [EOL]     if (toType instanceof ParameterizedType) { [EOL]         return isAssignable(type, (ParameterizedType) toType, typeVarAssigns); [EOL]     } [EOL]     if (toType instanceof GenericArrayType) { [EOL]         return isAssignable(type, (GenericArrayType) toType, typeVarAssigns); [EOL]     } [EOL]     if (toType instanceof WildcardType) { [EOL]         return isAssignable(type, (WildcardType) toType, typeVarAssigns); [EOL]     } [EOL]     if (toType instanceof TypeVariable<?>) { [EOL]         return isAssignable(type, (TypeVariable<?>) toType, typeVarAssigns); [EOL]     } [EOL]     throw new IllegalStateException("found an unhandled type: " + toType); [EOL] } 
 [LINE] if (toClass == null) { [LINE] private static boolean isAssignable(final Type type, final Class<?> toClass) { [EOL]     if (type == null) { [EOL]         return toClass == null || !toClass.isPrimitive(); [EOL]     } [EOL]     if (toClass == null) { [EOL]         return false; [EOL]     } [EOL]     if (toClass.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     if (type instanceof Class<?>) { [EOL]         return ClassUtils.isAssignable((Class<?>) type, toClass); [EOL]     } [EOL]     if (type instanceof ParameterizedType) { [EOL]         return isAssignable(getRawType((ParameterizedType) type), toClass); [EOL]     } [EOL]     if (type instanceof TypeVariable<?>) { [EOL]         for (final Type bound : ((TypeVariable<?>) type).getBounds()) { [EOL]             if (isAssignable(bound, toClass)) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (type instanceof GenericArrayType) { [EOL]         return toClass.equals(Object.class) || toClass.isArray() && isAssignable(((GenericArrayType) type).getGenericComponentType(), toClass.getComponentType()); [EOL]     } [EOL]     if (type instanceof WildcardType) { [EOL]         return false; [EOL]     } [EOL]     throw new IllegalStateException("found an unhandled type: " + type); [EOL] } 
 [LINE] return false; [LINE] private static boolean isAssignable(final Type type, final Class<?> toClass) { [EOL]     if (type == null) { [EOL]         return toClass == null || !toClass.isPrimitive(); [EOL]     } [EOL]     if (toClass == null) { [EOL]         return false; [EOL]     } [EOL]     if (toClass.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     if (type instanceof Class<?>) { [EOL]         return ClassUtils.isAssignable((Class<?>) type, toClass); [EOL]     } [EOL]     if (type instanceof ParameterizedType) { [EOL]         return isAssignable(getRawType((ParameterizedType) type), toClass); [EOL]     } [EOL]     if (type instanceof TypeVariable<?>) { [EOL]         for (final Type bound : ((TypeVariable<?>) type).getBounds()) { [EOL]             if (isAssignable(bound, toClass)) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (type instanceof GenericArrayType) { [EOL]         return toClass.equals(Object.class) || toClass.isArray() && isAssignable(((GenericArrayType) type).getGenericComponentType(), toClass.getComponentType()); [EOL]     } [EOL]     if (type instanceof WildcardType) { [EOL]         return false; [EOL]     } [EOL]     throw new IllegalStateException("found an unhandled type: " + type); [EOL] } 
 [LINE] if (type instanceof TypeVariable<?>) { [LINE] private static boolean isAssignable(final Type type, final Class<?> toClass) { [EOL]     if (type == null) { [EOL]         return toClass == null || !toClass.isPrimitive(); [EOL]     } [EOL]     if (toClass == null) { [EOL]         return false; [EOL]     } [EOL]     if (toClass.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     if (type instanceof Class<?>) { [EOL]         return ClassUtils.isAssignable((Class<?>) type, toClass); [EOL]     } [EOL]     if (type instanceof ParameterizedType) { [EOL]         return isAssignable(getRawType((ParameterizedType) type), toClass); [EOL]     } [EOL]     if (type instanceof TypeVariable<?>) { [EOL]         for (final Type bound : ((TypeVariable<?>) type).getBounds()) { [EOL]             if (isAssignable(bound, toClass)) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (type instanceof GenericArrayType) { [EOL]         return toClass.equals(Object.class) || toClass.isArray() && isAssignable(((GenericArrayType) type).getGenericComponentType(), toClass.getComponentType()); [EOL]     } [EOL]     if (type instanceof WildcardType) { [EOL]         return false; [EOL]     } [EOL]     throw new IllegalStateException("found an unhandled type: " + type); [EOL] } 
 [LINE] if (toParameterizedType == null) { [LINE] private static boolean isAssignable(final Type type, final ParameterizedType toParameterizedType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toParameterizedType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toParameterizedType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Class<?> toClass = getRawType(toParameterizedType); [EOL]     final Map<TypeVariable<?>, Type> fromTypeVarAssigns = getTypeArguments(type, toClass, null); [EOL]     if (fromTypeVarAssigns == null) { [EOL]         return false; [EOL]     } [EOL]     if (fromTypeVarAssigns.isEmpty()) { [EOL]         return true; [EOL]     } [EOL]     final Map<TypeVariable<?>, Type> toTypeVarAssigns = getTypeArguments(toParameterizedType, toClass, typeVarAssigns); [EOL]     for (final TypeVariable<?> var : toTypeVarAssigns.keySet()) { [EOL]         final Type toTypeArg = unrollVariableAssignments(var, toTypeVarAssigns); [EOL]         final Type fromTypeArg = unrollVariableAssignments(var, fromTypeVarAssigns); [EOL]         if (fromTypeArg != null && !toTypeArg.equals(fromTypeArg) && !(toTypeArg instanceof WildcardType && isAssignable(fromTypeArg, toTypeArg, typeVarAssigns))) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] if (type == null) { [LINE] private static boolean isAssignable(final Type type, final GenericArrayType toGenericArrayType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toGenericArrayType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toGenericArrayType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Type toComponentType = toGenericArrayType.getGenericComponentType(); [EOL]     if (type instanceof Class<?>) { [EOL]         final Class<?> cls = (Class<?>) type; [EOL]         return cls.isArray() && isAssignable(cls.getComponentType(), toComponentType, typeVarAssigns); [EOL]     } [EOL]     if (type instanceof GenericArrayType) { [EOL]         return isAssignable(((GenericArrayType) type).getGenericComponentType(), toComponentType, typeVarAssigns); [EOL]     } [EOL]     if (type instanceof WildcardType) { [EOL]         for (final Type bound : getImplicitUpperBounds((WildcardType) type)) { [EOL]             if (isAssignable(bound, toGenericArrayType)) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (type instanceof TypeVariable<?>) { [EOL]         for (final Type bound : getImplicitBounds((TypeVariable<?>) type)) { [EOL]             if (isAssignable(bound, toGenericArrayType)) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (type instanceof ParameterizedType) { [EOL]         return false; [EOL]     } [EOL]     throw new IllegalStateException("found an unhandled type: " + type); [EOL] } 
 [LINE] if (toGenericArrayType.equals(type)) { [LINE] private static boolean isAssignable(final Type type, final GenericArrayType toGenericArrayType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toGenericArrayType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toGenericArrayType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Type toComponentType = toGenericArrayType.getGenericComponentType(); [EOL]     if (type instanceof Class<?>) { [EOL]         final Class<?> cls = (Class<?>) type; [EOL]         return cls.isArray() && isAssignable(cls.getComponentType(), toComponentType, typeVarAssigns); [EOL]     } [EOL]     if (type instanceof GenericArrayType) { [EOL]         return isAssignable(((GenericArrayType) type).getGenericComponentType(), toComponentType, typeVarAssigns); [EOL]     } [EOL]     if (type instanceof WildcardType) { [EOL]         for (final Type bound : getImplicitUpperBounds((WildcardType) type)) { [EOL]             if (isAssignable(bound, toGenericArrayType)) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (type instanceof TypeVariable<?>) { [EOL]         for (final Type bound : getImplicitBounds((TypeVariable<?>) type)) { [EOL]             if (isAssignable(bound, toGenericArrayType)) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (type instanceof ParameterizedType) { [EOL]         return false; [EOL]     } [EOL]     throw new IllegalStateException("found an unhandled type: " + type); [EOL] } 
 [LINE] if (type instanceof GenericArrayType) { [LINE] private static boolean isAssignable(final Type type, final GenericArrayType toGenericArrayType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toGenericArrayType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toGenericArrayType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Type toComponentType = toGenericArrayType.getGenericComponentType(); [EOL]     if (type instanceof Class<?>) { [EOL]         final Class<?> cls = (Class<?>) type; [EOL]         return cls.isArray() && isAssignable(cls.getComponentType(), toComponentType, typeVarAssigns); [EOL]     } [EOL]     if (type instanceof GenericArrayType) { [EOL]         return isAssignable(((GenericArrayType) type).getGenericComponentType(), toComponentType, typeVarAssigns); [EOL]     } [EOL]     if (type instanceof WildcardType) { [EOL]         for (final Type bound : getImplicitUpperBounds((WildcardType) type)) { [EOL]             if (isAssignable(bound, toGenericArrayType)) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (type instanceof TypeVariable<?>) { [EOL]         for (final Type bound : getImplicitBounds((TypeVariable<?>) type)) { [EOL]             if (isAssignable(bound, toGenericArrayType)) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (type instanceof ParameterizedType) { [EOL]         return false; [EOL]     } [EOL]     throw new IllegalStateException("found an unhandled type: " + type); [EOL] } 
 [LINE] if (type instanceof WildcardType) { [LINE] private static boolean isAssignable(final Type type, final WildcardType toWildcardType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toWildcardType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toWildcardType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Type[] toUpperBounds = getImplicitUpperBounds(toWildcardType); [EOL]     final Type[] toLowerBounds = getImplicitLowerBounds(toWildcardType); [EOL]     if (type instanceof WildcardType) { [EOL]         final WildcardType wildcardType = (WildcardType) type; [EOL]         final Type[] upperBounds = getImplicitUpperBounds(wildcardType); [EOL]         final Type[] lowerBounds = getImplicitLowerBounds(wildcardType); [EOL]         for (Type toBound : toUpperBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : upperBounds) { [EOL]                 if (!isAssignable(bound, toBound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         for (Type toBound : toLowerBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : lowerBounds) { [EOL]                 if (!isAssignable(toBound, bound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     for (final Type toBound : toUpperBounds) { [EOL]         if (!isAssignable(type, substituteTypeVariables(toBound, typeVarAssigns), typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     for (final Type toBound : toLowerBounds) { [EOL]         if (!isAssignable(substituteTypeVariables(toBound, typeVarAssigns), type, typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] for (final Type bound : upperBounds) { [LINE] private static boolean isAssignable(final Type type, final WildcardType toWildcardType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toWildcardType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toWildcardType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Type[] toUpperBounds = getImplicitUpperBounds(toWildcardType); [EOL]     final Type[] toLowerBounds = getImplicitLowerBounds(toWildcardType); [EOL]     if (type instanceof WildcardType) { [EOL]         final WildcardType wildcardType = (WildcardType) type; [EOL]         final Type[] upperBounds = getImplicitUpperBounds(wildcardType); [EOL]         final Type[] lowerBounds = getImplicitLowerBounds(wildcardType); [EOL]         for (Type toBound : toUpperBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : upperBounds) { [EOL]                 if (!isAssignable(bound, toBound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         for (Type toBound : toLowerBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : lowerBounds) { [EOL]                 if (!isAssignable(toBound, bound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     for (final Type toBound : toUpperBounds) { [EOL]         if (!isAssignable(type, substituteTypeVariables(toBound, typeVarAssigns), typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     for (final Type toBound : toLowerBounds) { [EOL]         if (!isAssignable(substituteTypeVariables(toBound, typeVarAssigns), type, typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] return false; [LINE] private static boolean isAssignable(final Type type, final WildcardType toWildcardType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toWildcardType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toWildcardType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Type[] toUpperBounds = getImplicitUpperBounds(toWildcardType); [EOL]     final Type[] toLowerBounds = getImplicitLowerBounds(toWildcardType); [EOL]     if (type instanceof WildcardType) { [EOL]         final WildcardType wildcardType = (WildcardType) type; [EOL]         final Type[] upperBounds = getImplicitUpperBounds(wildcardType); [EOL]         final Type[] lowerBounds = getImplicitLowerBounds(wildcardType); [EOL]         for (Type toBound : toUpperBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : upperBounds) { [EOL]                 if (!isAssignable(bound, toBound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         for (Type toBound : toLowerBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : lowerBounds) { [EOL]                 if (!isAssignable(toBound, bound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     for (final Type toBound : toUpperBounds) { [EOL]         if (!isAssignable(type, substituteTypeVariables(toBound, typeVarAssigns), typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     for (final Type toBound : toLowerBounds) { [EOL]         if (!isAssignable(substituteTypeVariables(toBound, typeVarAssigns), type, typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] for (final Type bound : lowerBounds) { [LINE] private static boolean isAssignable(final Type type, final WildcardType toWildcardType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toWildcardType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toWildcardType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Type[] toUpperBounds = getImplicitUpperBounds(toWildcardType); [EOL]     final Type[] toLowerBounds = getImplicitLowerBounds(toWildcardType); [EOL]     if (type instanceof WildcardType) { [EOL]         final WildcardType wildcardType = (WildcardType) type; [EOL]         final Type[] upperBounds = getImplicitUpperBounds(wildcardType); [EOL]         final Type[] lowerBounds = getImplicitLowerBounds(wildcardType); [EOL]         for (Type toBound : toUpperBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : upperBounds) { [EOL]                 if (!isAssignable(bound, toBound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         for (Type toBound : toLowerBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : lowerBounds) { [EOL]                 if (!isAssignable(toBound, bound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     for (final Type toBound : toUpperBounds) { [EOL]         if (!isAssignable(type, substituteTypeVariables(toBound, typeVarAssigns), typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     for (final Type toBound : toLowerBounds) { [EOL]         if (!isAssignable(substituteTypeVariables(toBound, typeVarAssigns), type, typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] if (!isAssignable(substituteTypeVariables(toBound, typeVarAssigns), type, [LINE] private static boolean isAssignable(final Type type, final WildcardType toWildcardType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toWildcardType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toWildcardType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Type[] toUpperBounds = getImplicitUpperBounds(toWildcardType); [EOL]     final Type[] toLowerBounds = getImplicitLowerBounds(toWildcardType); [EOL]     if (type instanceof WildcardType) { [EOL]         final WildcardType wildcardType = (WildcardType) type; [EOL]         final Type[] upperBounds = getImplicitUpperBounds(wildcardType); [EOL]         final Type[] lowerBounds = getImplicitLowerBounds(wildcardType); [EOL]         for (Type toBound : toUpperBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : upperBounds) { [EOL]                 if (!isAssignable(bound, toBound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         for (Type toBound : toLowerBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : lowerBounds) { [EOL]                 if (!isAssignable(toBound, bound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     for (final Type toBound : toUpperBounds) { [EOL]         if (!isAssignable(type, substituteTypeVariables(toBound, typeVarAssigns), typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     for (final Type toBound : toLowerBounds) { [EOL]         if (!isAssignable(substituteTypeVariables(toBound, typeVarAssigns), type, typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] if (!isAssignable(cls, toClass)) { [LINE] private static Map<TypeVariable<?>, Type> getTypeArguments(final ParameterizedType parameterizedType, final Class<?> toClass, final Map<TypeVariable<?>, Type> subtypeVarAssigns) { [EOL]     final Class<?> cls = getRawType(parameterizedType); [EOL]     if (!isAssignable(cls, toClass)) { [EOL]         return null; [EOL]     } [EOL]     final Type ownerType = parameterizedType.getOwnerType(); [EOL]     Map<TypeVariable<?>, Type> typeVarAssigns; [EOL]     if (ownerType instanceof ParameterizedType) { [EOL]         final ParameterizedType parameterizedOwnerType = (ParameterizedType) ownerType; [EOL]         typeVarAssigns = getTypeArguments(parameterizedOwnerType, getRawType(parameterizedOwnerType), subtypeVarAssigns); [EOL]     } else { [EOL]         typeVarAssigns = subtypeVarAssigns == null ? new HashMap<TypeVariable<?>, Type>() : new HashMap<TypeVariable<?>, Type>(subtypeVarAssigns); [EOL]     } [EOL]     final Type[] typeArgs = parameterizedType.getActualTypeArguments(); [EOL]     final TypeVariable<?>[] typeParams = cls.getTypeParameters(); [EOL]     for (int i = 0; i < typeParams.length; i++) { [EOL]         final Type typeArg = typeArgs[i]; [EOL]         typeVarAssigns.put(typeParams[i], typeVarAssigns.containsKey(typeArg) ? typeVarAssigns.get(typeArg) : typeArg); [EOL]     } [EOL]     if (toClass.equals(cls)) { [EOL]         return typeVarAssigns; [EOL]     } [EOL]     return getTypeArguments(getClosestParentType(cls, toClass), toClass, typeVarAssigns); [EOL] } 
 [LINE] typeVarAssigns = subtypeVarAssigns == null ? new HashMap<TypeVariable<?>, Type>() [LINE] private static Map<TypeVariable<?>, Type> getTypeArguments(final ParameterizedType parameterizedType, final Class<?> toClass, final Map<TypeVariable<?>, Type> subtypeVarAssigns) { [EOL]     final Class<?> cls = getRawType(parameterizedType); [EOL]     if (!isAssignable(cls, toClass)) { [EOL]         return null; [EOL]     } [EOL]     final Type ownerType = parameterizedType.getOwnerType(); [EOL]     Map<TypeVariable<?>, Type> typeVarAssigns; [EOL]     if (ownerType instanceof ParameterizedType) { [EOL]         final ParameterizedType parameterizedOwnerType = (ParameterizedType) ownerType; [EOL]         typeVarAssigns = getTypeArguments(parameterizedOwnerType, getRawType(parameterizedOwnerType), subtypeVarAssigns); [EOL]     } else { [EOL]         typeVarAssigns = subtypeVarAssigns == null ? new HashMap<TypeVariable<?>, Type>() : new HashMap<TypeVariable<?>, Type>(subtypeVarAssigns); [EOL]     } [EOL]     final Type[] typeArgs = parameterizedType.getActualTypeArguments(); [EOL]     final TypeVariable<?>[] typeParams = cls.getTypeParameters(); [EOL]     for (int i = 0; i < typeParams.length; i++) { [EOL]         final Type typeArg = typeArgs[i]; [EOL]         typeVarAssigns.put(typeParams[i], typeVarAssigns.containsKey(typeArg) ? typeVarAssigns.get(typeArg) : typeArg); [EOL]     } [EOL]     if (toClass.equals(cls)) { [EOL]         return typeVarAssigns; [EOL]     } [EOL]     return getTypeArguments(getClosestParentType(cls, toClass), toClass, typeVarAssigns); [EOL] } 
 [LINE] final TypeVariable<?>[] typeParams = cls.getTypeParameters(); [LINE] private static Map<TypeVariable<?>, Type> getTypeArguments(final ParameterizedType parameterizedType, final Class<?> toClass, final Map<TypeVariable<?>, Type> subtypeVarAssigns) { [EOL]     final Class<?> cls = getRawType(parameterizedType); [EOL]     if (!isAssignable(cls, toClass)) { [EOL]         return null; [EOL]     } [EOL]     final Type ownerType = parameterizedType.getOwnerType(); [EOL]     Map<TypeVariable<?>, Type> typeVarAssigns; [EOL]     if (ownerType instanceof ParameterizedType) { [EOL]         final ParameterizedType parameterizedOwnerType = (ParameterizedType) ownerType; [EOL]         typeVarAssigns = getTypeArguments(parameterizedOwnerType, getRawType(parameterizedOwnerType), subtypeVarAssigns); [EOL]     } else { [EOL]         typeVarAssigns = subtypeVarAssigns == null ? new HashMap<TypeVariable<?>, Type>() : new HashMap<TypeVariable<?>, Type>(subtypeVarAssigns); [EOL]     } [EOL]     final Type[] typeArgs = parameterizedType.getActualTypeArguments(); [EOL]     final TypeVariable<?>[] typeParams = cls.getTypeParameters(); [EOL]     for (int i = 0; i < typeParams.length; i++) { [EOL]         final Type typeArg = typeArgs[i]; [EOL]         typeVarAssigns.put(typeParams[i], typeVarAssigns.containsKey(typeArg) ? typeVarAssigns.get(typeArg) : typeArg); [EOL]     } [EOL]     if (toClass.equals(cls)) { [EOL]         return typeVarAssigns; [EOL]     } [EOL]     return getTypeArguments(getClosestParentType(cls, toClass), toClass, typeVarAssigns); [EOL] } 
 [LINE] if (toClass.equals(cls)) { [LINE] private static Map<TypeVariable<?>, Type> getTypeArguments(final ParameterizedType parameterizedType, final Class<?> toClass, final Map<TypeVariable<?>, Type> subtypeVarAssigns) { [EOL]     final Class<?> cls = getRawType(parameterizedType); [EOL]     if (!isAssignable(cls, toClass)) { [EOL]         return null; [EOL]     } [EOL]     final Type ownerType = parameterizedType.getOwnerType(); [EOL]     Map<TypeVariable<?>, Type> typeVarAssigns; [EOL]     if (ownerType instanceof ParameterizedType) { [EOL]         final ParameterizedType parameterizedOwnerType = (ParameterizedType) ownerType; [EOL]         typeVarAssigns = getTypeArguments(parameterizedOwnerType, getRawType(parameterizedOwnerType), subtypeVarAssigns); [EOL]     } else { [EOL]         typeVarAssigns = subtypeVarAssigns == null ? new HashMap<TypeVariable<?>, Type>() : new HashMap<TypeVariable<?>, Type>(subtypeVarAssigns); [EOL]     } [EOL]     final Type[] typeArgs = parameterizedType.getActualTypeArguments(); [EOL]     final TypeVariable<?>[] typeParams = cls.getTypeParameters(); [EOL]     for (int i = 0; i < typeParams.length; i++) { [EOL]         final Type typeArg = typeArgs[i]; [EOL]         typeVarAssigns.put(typeParams[i], typeVarAssigns.containsKey(typeArg) ? typeVarAssigns.get(typeArg) : typeArg); [EOL]     } [EOL]     if (toClass.equals(cls)) { [EOL]         return typeVarAssigns; [EOL]     } [EOL]     return getTypeArguments(getClosestParentType(cls, toClass), toClass, typeVarAssigns); [EOL] } 
 [LINE] return typeVarAssigns; [LINE] private static Map<TypeVariable<?>, Type> getTypeArguments(final ParameterizedType parameterizedType, final Class<?> toClass, final Map<TypeVariable<?>, Type> subtypeVarAssigns) { [EOL]     final Class<?> cls = getRawType(parameterizedType); [EOL]     if (!isAssignable(cls, toClass)) { [EOL]         return null; [EOL]     } [EOL]     final Type ownerType = parameterizedType.getOwnerType(); [EOL]     Map<TypeVariable<?>, Type> typeVarAssigns; [EOL]     if (ownerType instanceof ParameterizedType) { [EOL]         final ParameterizedType parameterizedOwnerType = (ParameterizedType) ownerType; [EOL]         typeVarAssigns = getTypeArguments(parameterizedOwnerType, getRawType(parameterizedOwnerType), subtypeVarAssigns); [EOL]     } else { [EOL]         typeVarAssigns = subtypeVarAssigns == null ? new HashMap<TypeVariable<?>, Type>() : new HashMap<TypeVariable<?>, Type>(subtypeVarAssigns); [EOL]     } [EOL]     final Type[] typeArgs = parameterizedType.getActualTypeArguments(); [EOL]     final TypeVariable<?>[] typeParams = cls.getTypeParameters(); [EOL]     for (int i = 0; i < typeParams.length; i++) { [EOL]         final Type typeArg = typeArgs[i]; [EOL]         typeVarAssigns.put(typeParams[i], typeVarAssigns.containsKey(typeArg) ? typeVarAssigns.get(typeArg) : typeArg); [EOL]     } [EOL]     if (toClass.equals(cls)) { [EOL]         return typeVarAssigns; [EOL]     } [EOL]     return getTypeArguments(getClosestParentType(cls, toClass), toClass, typeVarAssigns); [EOL] } 
 [LINE] if (!isAssignable(cls, toClass)) { [LINE] private static Map<TypeVariable<?>, Type> getTypeArguments(Class<?> cls, final Class<?> toClass, final Map<TypeVariable<?>, Type> subtypeVarAssigns) { [EOL]     if (!isAssignable(cls, toClass)) { [EOL]         return null; [EOL]     } [EOL]     if (cls.isPrimitive()) { [EOL]         if (toClass.isPrimitive()) { [EOL]             return new HashMap<TypeVariable<?>, Type>(); [EOL]         } [EOL]         cls = ClassUtils.primitiveToWrapper(cls); [EOL]     } [EOL]     final HashMap<TypeVariable<?>, Type> typeVarAssigns = subtypeVarAssigns == null ? new HashMap<TypeVariable<?>, Type>() : new HashMap<TypeVariable<?>, Type>(subtypeVarAssigns); [EOL]     if (toClass.equals(cls)) { [EOL]         return typeVarAssigns; [EOL]     } [EOL]     return getTypeArguments(getClosestParentType(cls, toClass), toClass, typeVarAssigns); [EOL] } 
 [LINE] cls = ClassUtils.primitiveToWrapper(cls); [LINE] private static Map<TypeVariable<?>, Type> getTypeArguments(Class<?> cls, final Class<?> toClass, final Map<TypeVariable<?>, Type> subtypeVarAssigns) { [EOL]     if (!isAssignable(cls, toClass)) { [EOL]         return null; [EOL]     } [EOL]     if (cls.isPrimitive()) { [EOL]         if (toClass.isPrimitive()) { [EOL]             return new HashMap<TypeVariable<?>, Type>(); [EOL]         } [EOL]         cls = ClassUtils.primitiveToWrapper(cls); [EOL]     } [EOL]     final HashMap<TypeVariable<?>, Type> typeVarAssigns = subtypeVarAssigns == null ? new HashMap<TypeVariable<?>, Type>() : new HashMap<TypeVariable<?>, Type>(subtypeVarAssigns); [EOL]     if (toClass.equals(cls)) { [EOL]         return typeVarAssigns; [EOL]     } [EOL]     return getTypeArguments(getClosestParentType(cls, toClass), toClass, typeVarAssigns); [EOL] } 
 [LINE] final HashMap<TypeVariable<?>, Type> typeVarAssigns = subtypeVarAssigns == null ? new HashMap<TypeVariable<?>, Type>() [LINE] private static Map<TypeVariable<?>, Type> getTypeArguments(Class<?> cls, final Class<?> toClass, final Map<TypeVariable<?>, Type> subtypeVarAssigns) { [EOL]     if (!isAssignable(cls, toClass)) { [EOL]         return null; [EOL]     } [EOL]     if (cls.isPrimitive()) { [EOL]         if (toClass.isPrimitive()) { [EOL]             return new HashMap<TypeVariable<?>, Type>(); [EOL]         } [EOL]         cls = ClassUtils.primitiveToWrapper(cls); [EOL]     } [EOL]     final HashMap<TypeVariable<?>, Type> typeVarAssigns = subtypeVarAssigns == null ? new HashMap<TypeVariable<?>, Type>() : new HashMap<TypeVariable<?>, Type>(subtypeVarAssigns); [EOL]     if (toClass.equals(cls)) { [EOL]         return typeVarAssigns; [EOL]     } [EOL]     return getTypeArguments(getClosestParentType(cls, toClass), toClass, typeVarAssigns); [EOL] } 
 [LINE] if (typeVarList.contains(typeArg) [LINE] private static <T> void mapTypeVariablesToArguments(final Class<T> cls, final ParameterizedType parameterizedType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     final Type ownerType = parameterizedType.getOwnerType(); [EOL]     if (ownerType instanceof ParameterizedType) { [EOL]         mapTypeVariablesToArguments(cls, (ParameterizedType) ownerType, typeVarAssigns); [EOL]     } [EOL]     final Type[] typeArgs = parameterizedType.getActualTypeArguments(); [EOL]     final TypeVariable<?>[] typeVars = getRawType(parameterizedType).getTypeParameters(); [EOL]     final List<TypeVariable<Class<T>>> typeVarList = Arrays.asList(cls.getTypeParameters()); [EOL]     for (int i = 0; i < typeArgs.length; i++) { [EOL]         final TypeVariable<?> typeVar = typeVars[i]; [EOL]         final Type typeArg = typeArgs[i]; [EOL]         if (typeVarList.contains(typeArg) && typeVarAssigns.containsKey(typeVar)) { [EOL]             typeVarAssigns.put((TypeVariable<?>) typeArg, typeVarAssigns.get(typeVar)); [EOL]         } [EOL]     } [EOL] } 
 [LINE] midClass = getRawType((ParameterizedType) midType); [LINE] private static Type getClosestParentType(final Class<?> cls, final Class<?> superClass) { [EOL]     if (superClass.isInterface()) { [EOL]         final Type[] interfaceTypes = cls.getGenericInterfaces(); [EOL]         Type genericInterface = null; [EOL]         for (final Type midType : interfaceTypes) { [EOL]             Class<?> midClass = null; [EOL]             if (midType instanceof ParameterizedType) { [EOL]                 midClass = getRawType((ParameterizedType) midType); [EOL]             } else if (midType instanceof Class<?>) { [EOL]                 midClass = (Class<?>) midType; [EOL]             } else { [EOL]                 throw new IllegalStateException("Unexpected generic" + " interface type found: " + midType); [EOL]             } [EOL]             if (isAssignable(midClass, superClass) && isAssignable(genericInterface, (Type) midClass)) { [EOL]                 genericInterface = midType; [EOL]             } [EOL]         } [EOL]         if (genericInterface != null) { [EOL]             return genericInterface; [EOL]         } [EOL]     } [EOL]     return cls.getGenericSuperclass(); [EOL] } 
 [LINE] return cls.getGenericSuperclass(); [LINE] private static Type getClosestParentType(final Class<?> cls, final Class<?> superClass) { [EOL]     if (superClass.isInterface()) { [EOL]         final Type[] interfaceTypes = cls.getGenericInterfaces(); [EOL]         Type genericInterface = null; [EOL]         for (final Type midType : interfaceTypes) { [EOL]             Class<?> midClass = null; [EOL]             if (midType instanceof ParameterizedType) { [EOL]                 midClass = getRawType((ParameterizedType) midType); [EOL]             } else if (midType instanceof Class<?>) { [EOL]                 midClass = (Class<?>) midType; [EOL]             } else { [EOL]                 throw new IllegalStateException("Unexpected generic" + " interface type found: " + midType); [EOL]             } [EOL]             if (isAssignable(midClass, superClass) && isAssignable(genericInterface, (Type) midClass)) { [EOL]                 genericInterface = midType; [EOL]             } [EOL]         } [EOL]         if (genericInterface != null) { [EOL]             return genericInterface; [EOL]         } [EOL]     } [EOL]     return cls.getGenericSuperclass(); [EOL] } 
 [LINE] if (type == null) { [LINE] public static boolean isInstance(final Object value, final Type type) { [EOL]     if (type == null) { [EOL]         return false; [EOL]     } [EOL]     return value == null ? !(type instanceof Class<?>) || !((Class<?>) type).isPrimitive() : isAssignable(value.getClass(), type, null); [EOL] } 
 [LINE] if (type1 != type2 && isAssignable(type2, type1, null)) { [LINE] public static Type[] normalizeUpperBounds(final Type[] bounds) { [EOL]     if (bounds.length < 2) { [EOL]         return bounds; [EOL]     } [EOL]     final Set<Type> types = new HashSet<Type>(bounds.length); [EOL]     for (final Type type1 : bounds) { [EOL]         boolean subtypeFound = false; [EOL]         for (final Type type2 : bounds) { [EOL]             if (type1 != type2 && isAssignable(type2, type1, null)) { [EOL]                 subtypeFound = true; [EOL]                 break; [EOL]             } [EOL]         } [EOL]         if (!subtypeFound) { [EOL]             types.add(type1); [EOL]         } [EOL]     } [EOL]     return types.toArray(new Type[types.size()]); [EOL] } 
 [LINE] types.add(type1); [LINE] public static Type[] normalizeUpperBounds(final Type[] bounds) { [EOL]     if (bounds.length < 2) { [EOL]         return bounds; [EOL]     } [EOL]     final Set<Type> types = new HashSet<Type>(bounds.length); [EOL]     for (final Type type1 : bounds) { [EOL]         boolean subtypeFound = false; [EOL]         for (final Type type2 : bounds) { [EOL]             if (type1 != type2 && isAssignable(type2, type1, null)) { [EOL]                 subtypeFound = true; [EOL]                 break; [EOL]             } [EOL]         } [EOL]         if (!subtypeFound) { [EOL]             types.add(type1); [EOL]         } [EOL]     } [EOL]     return types.toArray(new Type[types.size()]); [EOL] } 
 [LINE] final Type[] bounds = wildcardType.getUpperBounds(); [LINE] public static Type[] getImplicitUpperBounds(final WildcardType wildcardType) { [EOL]     final Type[] bounds = wildcardType.getUpperBounds(); [EOL]     return bounds.length == 0 ? new Type[] { Object.class } : normalizeUpperBounds(bounds); [EOL] } 
 [LINE] if (assigningType == null) { [LINE] public static Class<?> getRawType(final Type type, final Type assigningType) { [EOL]     if (type instanceof Class<?>) { [EOL]         return (Class<?>) type; [EOL]     } [EOL]     if (type instanceof ParameterizedType) { [EOL]         return getRawType((ParameterizedType) type); [EOL]     } [EOL]     if (type instanceof TypeVariable<?>) { [EOL]         if (assigningType == null) { [EOL]             return null; [EOL]         } [EOL]         final Object genericDeclaration = ((TypeVariable<?>) type).getGenericDeclaration(); [EOL]         if (!(genericDeclaration instanceof Class<?>)) { [EOL]             return null; [EOL]         } [EOL]         final Map<TypeVariable<?>, Type> typeVarAssigns = getTypeArguments(assigningType, (Class<?>) genericDeclaration); [EOL]         if (typeVarAssigns == null) { [EOL]             return null; [EOL]         } [EOL]         final Type typeArgument = typeVarAssigns.get(type); [EOL]         if (typeArgument == null) { [EOL]             return null; [EOL]         } [EOL]         return getRawType(typeArgument, assigningType); [EOL]     } [EOL]     if (type instanceof GenericArrayType) { [EOL]         final Class<?> rawComponentType = getRawType(((GenericArrayType) type).getGenericComponentType(), assigningType); [EOL]         return Array.newInstance(rawComponentType, 0).getClass(); [EOL]     } [EOL]     if (type instanceof WildcardType) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("unknown type: " + type); [EOL] } 
 [LINE] if (typeVarAssigns == null) { [LINE] public static Class<?> getRawType(final Type type, final Type assigningType) { [EOL]     if (type instanceof Class<?>) { [EOL]         return (Class<?>) type; [EOL]     } [EOL]     if (type instanceof ParameterizedType) { [EOL]         return getRawType((ParameterizedType) type); [EOL]     } [EOL]     if (type instanceof TypeVariable<?>) { [EOL]         if (assigningType == null) { [EOL]             return null; [EOL]         } [EOL]         final Object genericDeclaration = ((TypeVariable<?>) type).getGenericDeclaration(); [EOL]         if (!(genericDeclaration instanceof Class<?>)) { [EOL]             return null; [EOL]         } [EOL]         final Map<TypeVariable<?>, Type> typeVarAssigns = getTypeArguments(assigningType, (Class<?>) genericDeclaration); [EOL]         if (typeVarAssigns == null) { [EOL]             return null; [EOL]         } [EOL]         final Type typeArgument = typeVarAssigns.get(type); [EOL]         if (typeArgument == null) { [EOL]             return null; [EOL]         } [EOL]         return getRawType(typeArgument, assigningType); [EOL]     } [EOL]     if (type instanceof GenericArrayType) { [EOL]         final Class<?> rawComponentType = getRawType(((GenericArrayType) type).getGenericComponentType(), assigningType); [EOL]         return Array.newInstance(rawComponentType, 0).getClass(); [EOL]     } [EOL]     if (type instanceof WildcardType) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("unknown type: " + type); [EOL] } 
 [LINE] final Class<?> rawComponentType = getRawType(((GenericArrayType) type) [LINE] public static Class<?> getRawType(final Type type, final Type assigningType) { [EOL]     if (type instanceof Class<?>) { [EOL]         return (Class<?>) type; [EOL]     } [EOL]     if (type instanceof ParameterizedType) { [EOL]         return getRawType((ParameterizedType) type); [EOL]     } [EOL]     if (type instanceof TypeVariable<?>) { [EOL]         if (assigningType == null) { [EOL]             return null; [EOL]         } [EOL]         final Object genericDeclaration = ((TypeVariable<?>) type).getGenericDeclaration(); [EOL]         if (!(genericDeclaration instanceof Class<?>)) { [EOL]             return null; [EOL]         } [EOL]         final Map<TypeVariable<?>, Type> typeVarAssigns = getTypeArguments(assigningType, (Class<?>) genericDeclaration); [EOL]         if (typeVarAssigns == null) { [EOL]             return null; [EOL]         } [EOL]         final Type typeArgument = typeVarAssigns.get(type); [EOL]         if (typeArgument == null) { [EOL]             return null; [EOL]         } [EOL]         return getRawType(typeArgument, assigningType); [EOL]     } [EOL]     if (type instanceof GenericArrayType) { [EOL]         final Class<?> rawComponentType = getRawType(((GenericArrayType) type).getGenericComponentType(), assigningType); [EOL]         return Array.newInstance(rawComponentType, 0).getClass(); [EOL]     } [EOL]     if (type instanceof WildcardType) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("unknown type: " + type); [EOL] } 
 [LINE] return type instanceof GenericArrayType || type instanceof Class<?> && ((Class<?>) type).isArray(); [LINE] public static boolean isArrayType(final Type type) { [EOL]     return type instanceof GenericArrayType || type instanceof Class<?> && ((Class<?>) type).isArray(); [EOL] } 
 [LINE] return null; [LINE] public static Type getArrayComponentType(final Type type) { [EOL]     if (type instanceof Class<?>) { [EOL]         final Class<?> clazz = (Class<?>) type; [EOL]         return clazz.isArray() ? clazz.getComponentType() : null; [EOL]     } [EOL]     if (type instanceof GenericArrayType) { [EOL]         return ((GenericArrayType) type).getGenericComponentType(); [EOL]     } [EOL]     return null; [EOL] } 
lang3/time/DateFormatUtils.java
 [LINE] return format(new Date(millis), pattern, UTC_TIME_ZONE, locale); [LINE] public static String formatUTC(final long millis, final String pattern, final Locale locale) { [EOL]     return format(new Date(millis), pattern, UTC_TIME_ZONE, locale); [EOL] } 
 [LINE] return format(date, pattern, UTC_TIME_ZONE, locale); [LINE] public static String formatUTC(final Date date, final String pattern, final Locale locale) { [EOL]     return format(date, pattern, UTC_TIME_ZONE, locale); [EOL] } 
 [LINE] return format(new Date(millis), pattern, null, null); [LINE] public static String format(final long millis, final String pattern) { [EOL]     return format(new Date(millis), pattern, null, null); [EOL] } 
 [LINE] final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale); [LINE] public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) { [EOL]     final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale); [EOL]     return df.format(calendar); [EOL] } 
lang3/mutable/MutableObject.java
 [LINE] @Override [LINE] @Override [EOL] public T getValue() { [EOL]     return this.value; [EOL] } 
 [LINE] if (this == obj) { [LINE] @Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == null) { [EOL]         return false; [EOL]     } [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (this.getClass() == obj.getClass()) { [EOL]         final MutableObject<?> that = (MutableObject<?>) obj; [EOL]         return this.value.equals(that.value); [EOL]     } else { [EOL]         return false; [EOL]     } [EOL] } 
 [LINE] if (this.getClass() == obj.getClass()) { [LINE] @Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == null) { [EOL]         return false; [EOL]     } [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (this.getClass() == obj.getClass()) { [EOL]         final MutableObject<?> that = (MutableObject<?>) obj; [EOL]         return this.value.equals(that.value); [EOL]     } else { [EOL]         return false; [EOL]     } [EOL] } 
 [LINE] @Override [LINE] @Override [EOL] public int hashCode() { [EOL]     return value == null ? 0 : value.hashCode(); [EOL] } 
lang3/text/translate/NumericEntityUnescaper.java
 [LINE] final int seqEnd = input.length(); [LINE] @Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     final int seqEnd = input.length(); [EOL]     if (input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') { [EOL]         int start = index + 2; [EOL]         boolean isHex = false; [EOL]         final char firstChar = input.charAt(start); [EOL]         if (firstChar == 'x' || firstChar == 'X') { [EOL]             start++; [EOL]             isHex = true; [EOL]             if (start == seqEnd) { [EOL]                 return 0; [EOL]             } [EOL]         } [EOL]         int end = start; [EOL]         while (end < seqEnd && (input.charAt(end) >= '0' && input.charAt(end) <= '9' || input.charAt(end) >= 'a' && input.charAt(end) <= 'f' || input.charAt(end) >= 'A' && input.charAt(end) <= 'F')) { [EOL]             end++; [EOL]         } [EOL]         final boolean semiNext = end != seqEnd && input.charAt(end) == ';'; [EOL]         if (!semiNext) { [EOL]             if (isSet(OPTION.semiColonRequired)) { [EOL]                 return 0; [EOL]             } else if (isSet(OPTION.errorIfNoSemiColon)) { [EOL]                 throw new IllegalArgumentException("Semi-colon required at end of numeric entity"); [EOL]             } [EOL]         } [EOL]         int entityValue; [EOL]         try { [EOL]             if (isHex) { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16); [EOL]             } else { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10); [EOL]             } [EOL]         } catch (final NumberFormatException nfe) { [EOL]             return 0; [EOL]         } [EOL]         if (entityValue > 0xFFFF) { [EOL]             final char[] chrs = Character.toChars(entityValue); [EOL]             out.write(chrs[0]); [EOL]             out.write(chrs[1]); [EOL]         } else { [EOL]             out.write(entityValue); [EOL]         } [EOL]         return 2 + end - start + (isHex ? 1 : 0) + (semiNext ? 1 : 0); [EOL]     } [EOL]     return 0; [EOL] } 
 [LINE] final char firstChar = input.charAt(start); [LINE] @Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     final int seqEnd = input.length(); [EOL]     if (input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') { [EOL]         int start = index + 2; [EOL]         boolean isHex = false; [EOL]         final char firstChar = input.charAt(start); [EOL]         if (firstChar == 'x' || firstChar == 'X') { [EOL]             start++; [EOL]             isHex = true; [EOL]             if (start == seqEnd) { [EOL]                 return 0; [EOL]             } [EOL]         } [EOL]         int end = start; [EOL]         while (end < seqEnd && (input.charAt(end) >= '0' && input.charAt(end) <= '9' || input.charAt(end) >= 'a' && input.charAt(end) <= 'f' || input.charAt(end) >= 'A' && input.charAt(end) <= 'F')) { [EOL]             end++; [EOL]         } [EOL]         final boolean semiNext = end != seqEnd && input.charAt(end) == ';'; [EOL]         if (!semiNext) { [EOL]             if (isSet(OPTION.semiColonRequired)) { [EOL]                 return 0; [EOL]             } else if (isSet(OPTION.errorIfNoSemiColon)) { [EOL]                 throw new IllegalArgumentException("Semi-colon required at end of numeric entity"); [EOL]             } [EOL]         } [EOL]         int entityValue; [EOL]         try { [EOL]             if (isHex) { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16); [EOL]             } else { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10); [EOL]             } [EOL]         } catch (final NumberFormatException nfe) { [EOL]             return 0; [EOL]         } [EOL]         if (entityValue > 0xFFFF) { [EOL]             final char[] chrs = Character.toChars(entityValue); [EOL]             out.write(chrs[0]); [EOL]             out.write(chrs[1]); [EOL]         } else { [EOL]             out.write(entityValue); [EOL]         } [EOL]         return 2 + end - start + (isHex ? 1 : 0) + (semiNext ? 1 : 0); [EOL]     } [EOL]     return 0; [EOL] } 
 [LINE] return 0; [LINE] @Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     final int seqEnd = input.length(); [EOL]     if (input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') { [EOL]         int start = index + 2; [EOL]         boolean isHex = false; [EOL]         final char firstChar = input.charAt(start); [EOL]         if (firstChar == 'x' || firstChar == 'X') { [EOL]             start++; [EOL]             isHex = true; [EOL]             if (start == seqEnd) { [EOL]                 return 0; [EOL]             } [EOL]         } [EOL]         int end = start; [EOL]         while (end < seqEnd && (input.charAt(end) >= '0' && input.charAt(end) <= '9' || input.charAt(end) >= 'a' && input.charAt(end) <= 'f' || input.charAt(end) >= 'A' && input.charAt(end) <= 'F')) { [EOL]             end++; [EOL]         } [EOL]         final boolean semiNext = end != seqEnd && input.charAt(end) == ';'; [EOL]         if (!semiNext) { [EOL]             if (isSet(OPTION.semiColonRequired)) { [EOL]                 return 0; [EOL]             } else if (isSet(OPTION.errorIfNoSemiColon)) { [EOL]                 throw new IllegalArgumentException("Semi-colon required at end of numeric entity"); [EOL]             } [EOL]         } [EOL]         int entityValue; [EOL]         try { [EOL]             if (isHex) { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16); [EOL]             } else { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10); [EOL]             } [EOL]         } catch (final NumberFormatException nfe) { [EOL]             return 0; [EOL]         } [EOL]         if (entityValue > 0xFFFF) { [EOL]             final char[] chrs = Character.toChars(entityValue); [EOL]             out.write(chrs[0]); [EOL]             out.write(chrs[1]); [EOL]         } else { [EOL]             out.write(entityValue); [EOL]         } [EOL]         return 2 + end - start + (isHex ? 1 : 0) + (semiNext ? 1 : 0); [EOL]     } [EOL]     return 0; [EOL] } 
 [LINE] end++; [LINE] @Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     final int seqEnd = input.length(); [EOL]     if (input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') { [EOL]         int start = index + 2; [EOL]         boolean isHex = false; [EOL]         final char firstChar = input.charAt(start); [EOL]         if (firstChar == 'x' || firstChar == 'X') { [EOL]             start++; [EOL]             isHex = true; [EOL]             if (start == seqEnd) { [EOL]                 return 0; [EOL]             } [EOL]         } [EOL]         int end = start; [EOL]         while (end < seqEnd && (input.charAt(end) >= '0' && input.charAt(end) <= '9' || input.charAt(end) >= 'a' && input.charAt(end) <= 'f' || input.charAt(end) >= 'A' && input.charAt(end) <= 'F')) { [EOL]             end++; [EOL]         } [EOL]         final boolean semiNext = end != seqEnd && input.charAt(end) == ';'; [EOL]         if (!semiNext) { [EOL]             if (isSet(OPTION.semiColonRequired)) { [EOL]                 return 0; [EOL]             } else if (isSet(OPTION.errorIfNoSemiColon)) { [EOL]                 throw new IllegalArgumentException("Semi-colon required at end of numeric entity"); [EOL]             } [EOL]         } [EOL]         int entityValue; [EOL]         try { [EOL]             if (isHex) { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16); [EOL]             } else { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10); [EOL]             } [EOL]         } catch (final NumberFormatException nfe) { [EOL]             return 0; [EOL]         } [EOL]         if (entityValue > 0xFFFF) { [EOL]             final char[] chrs = Character.toChars(entityValue); [EOL]             out.write(chrs[0]); [EOL]             out.write(chrs[1]); [EOL]         } else { [EOL]             out.write(entityValue); [EOL]         } [EOL]         return 2 + end - start + (isHex ? 1 : 0) + (semiNext ? 1 : 0); [EOL]     } [EOL]     return 0; [EOL] } 
 [LINE] return 0; [LINE] @Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     final int seqEnd = input.length(); [EOL]     if (input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') { [EOL]         int start = index + 2; [EOL]         boolean isHex = false; [EOL]         final char firstChar = input.charAt(start); [EOL]         if (firstChar == 'x' || firstChar == 'X') { [EOL]             start++; [EOL]             isHex = true; [EOL]             if (start == seqEnd) { [EOL]                 return 0; [EOL]             } [EOL]         } [EOL]         int end = start; [EOL]         while (end < seqEnd && (input.charAt(end) >= '0' && input.charAt(end) <= '9' || input.charAt(end) >= 'a' && input.charAt(end) <= 'f' || input.charAt(end) >= 'A' && input.charAt(end) <= 'F')) { [EOL]             end++; [EOL]         } [EOL]         final boolean semiNext = end != seqEnd && input.charAt(end) == ';'; [EOL]         if (!semiNext) { [EOL]             if (isSet(OPTION.semiColonRequired)) { [EOL]                 return 0; [EOL]             } else if (isSet(OPTION.errorIfNoSemiColon)) { [EOL]                 throw new IllegalArgumentException("Semi-colon required at end of numeric entity"); [EOL]             } [EOL]         } [EOL]         int entityValue; [EOL]         try { [EOL]             if (isHex) { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16); [EOL]             } else { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10); [EOL]             } [EOL]         } catch (final NumberFormatException nfe) { [EOL]             return 0; [EOL]         } [EOL]         if (entityValue > 0xFFFF) { [EOL]             final char[] chrs = Character.toChars(entityValue); [EOL]             out.write(chrs[0]); [EOL]             out.write(chrs[1]); [EOL]         } else { [EOL]             out.write(entityValue); [EOL]         } [EOL]         return 2 + end - start + (isHex ? 1 : 0) + (semiNext ? 1 : 0); [EOL]     } [EOL]     return 0; [EOL] } 
 [LINE] out.write(entityValue); [LINE] @Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     final int seqEnd = input.length(); [EOL]     if (input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') { [EOL]         int start = index + 2; [EOL]         boolean isHex = false; [EOL]         final char firstChar = input.charAt(start); [EOL]         if (firstChar == 'x' || firstChar == 'X') { [EOL]             start++; [EOL]             isHex = true; [EOL]             if (start == seqEnd) { [EOL]                 return 0; [EOL]             } [EOL]         } [EOL]         int end = start; [EOL]         while (end < seqEnd && (input.charAt(end) >= '0' && input.charAt(end) <= '9' || input.charAt(end) >= 'a' && input.charAt(end) <= 'f' || input.charAt(end) >= 'A' && input.charAt(end) <= 'F')) { [EOL]             end++; [EOL]         } [EOL]         final boolean semiNext = end != seqEnd && input.charAt(end) == ';'; [EOL]         if (!semiNext) { [EOL]             if (isSet(OPTION.semiColonRequired)) { [EOL]                 return 0; [EOL]             } else if (isSet(OPTION.errorIfNoSemiColon)) { [EOL]                 throw new IllegalArgumentException("Semi-colon required at end of numeric entity"); [EOL]             } [EOL]         } [EOL]         int entityValue; [EOL]         try { [EOL]             if (isHex) { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16); [EOL]             } else { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10); [EOL]             } [EOL]         } catch (final NumberFormatException nfe) { [EOL]             return 0; [EOL]         } [EOL]         if (entityValue > 0xFFFF) { [EOL]             final char[] chrs = Character.toChars(entityValue); [EOL]             out.write(chrs[0]); [EOL]             out.write(chrs[1]); [EOL]         } else { [EOL]             out.write(entityValue); [EOL]         } [EOL]         return 2 + end - start + (isHex ? 1 : 0) + (semiNext ? 1 : 0); [EOL]     } [EOL]     return 0; [EOL] } 
lang3/mutable/MutableByte.java
 [LINE] this.value = value; [LINE] public void setValue(final byte value) { [EOL]     this.value = value; [EOL] } 
 [LINE] @Override [LINE] public void setValue(final byte value) { [EOL]     this.value = value; [EOL] } 
 [LINE] return value; [LINE] @Override [EOL] public int intValue() { [EOL]     return value; [EOL] } 
 [LINE] return value; [LINE] @Override [EOL] public float floatValue() { [EOL]     return value; [EOL] } 
 [LINE] @Override [LINE] @Override [EOL] public float floatValue() { [EOL]     return value; [EOL] } 
 [LINE] return String.valueOf(value); [LINE] @Override [EOL] public String toString() { [EOL]     return String.valueOf(value); [EOL] } 
lang3/mutable/MutableBoolean.java
 [LINE] return Boolean.valueOf(this.value); [LINE] @Override [EOL] public Boolean getValue() { [EOL]     return Boolean.valueOf(this.value); [EOL] } 
 [LINE] @Override [LINE] public void setValue(final boolean value) { [EOL]     this.value = value; [EOL] } 
 [LINE] this.value = value.booleanValue(); [LINE] @Override [EOL] public void setValue(final Boolean value) { [EOL]     this.value = value.booleanValue(); [EOL] } 
 [LINE] return value == false; [LINE] public boolean isFalse() { [EOL]     return value == false; [EOL] } 
 [LINE] return Boolean.valueOf(booleanValue()); [LINE] public Boolean toBoolean() { [EOL]     return Boolean.valueOf(booleanValue()); [EOL] } 
 [LINE] return false; [LINE] @Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj instanceof MutableBoolean) { [EOL]         return value == ((MutableBoolean) obj).booleanValue(); [EOL]     } [EOL]     return false; [EOL] } 
 [LINE] return value ? Boolean.TRUE.hashCode() : Boolean.FALSE.hashCode(); [LINE] @Override [EOL] public int hashCode() { [EOL]     return value ? Boolean.TRUE.hashCode() : Boolean.FALSE.hashCode(); [EOL] } 
 [LINE] @Override [LINE] @Override [EOL] public int hashCode() { [EOL]     return value ? Boolean.TRUE.hashCode() : Boolean.FALSE.hashCode(); [EOL] } 
lang3/concurrent/AtomicSafeInitializer.java
 [LINE] while ((result = reference.get()) == null) { [LINE] @Override [EOL] public final T get() throws ConcurrentException { [EOL]     T result; [EOL]     while ((result = reference.get()) == null) { [EOL]         if (factory.compareAndSet(null, this)) { [EOL]             reference.set(initialize()); [EOL]         } [EOL]     } [EOL]     return result; [EOL] } 
lang3/JavaVersion.java
 [LINE] return JAVA_1_3; [LINE] static JavaVersion get(final String nom) { [EOL]     if ("0.9".equals(nom)) { [EOL]         return JAVA_0_9; [EOL]     } else if ("1.1".equals(nom)) { [EOL]         return JAVA_1_1; [EOL]     } else if ("1.2".equals(nom)) { [EOL]         return JAVA_1_2; [EOL]     } else if ("1.3".equals(nom)) { [EOL]         return JAVA_1_3; [EOL]     } else if ("1.4".equals(nom)) { [EOL]         return JAVA_1_4; [EOL]     } else if ("1.5".equals(nom)) { [EOL]         return JAVA_1_5; [EOL]     } else if ("1.6".equals(nom)) { [EOL]         return JAVA_1_6; [EOL]     } else if ("1.7".equals(nom)) { [EOL]         return JAVA_1_7; [EOL]     } else if ("1.8".equals(nom)) { [EOL]         return JAVA_1_8; [EOL]     } else { [EOL]         return null; [EOL]     } [EOL] } 
 [LINE] } else if ("1.6".equals(nom)) { [LINE] static JavaVersion get(final String nom) { [EOL]     if ("0.9".equals(nom)) { [EOL]         return JAVA_0_9; [EOL]     } else if ("1.1".equals(nom)) { [EOL]         return JAVA_1_1; [EOL]     } else if ("1.2".equals(nom)) { [EOL]         return JAVA_1_2; [EOL]     } else if ("1.3".equals(nom)) { [EOL]         return JAVA_1_3; [EOL]     } else if ("1.4".equals(nom)) { [EOL]         return JAVA_1_4; [EOL]     } else if ("1.5".equals(nom)) { [EOL]         return JAVA_1_5; [EOL]     } else if ("1.6".equals(nom)) { [EOL]         return JAVA_1_6; [EOL]     } else if ("1.7".equals(nom)) { [EOL]         return JAVA_1_7; [EOL]     } else if ("1.8".equals(nom)) { [EOL]         return JAVA_1_8; [EOL]     } else { [EOL]         return null; [EOL]     } [EOL] } 
 [LINE] return JAVA_1_7; [LINE] static JavaVersion get(final String nom) { [EOL]     if ("0.9".equals(nom)) { [EOL]         return JAVA_0_9; [EOL]     } else if ("1.1".equals(nom)) { [EOL]         return JAVA_1_1; [EOL]     } else if ("1.2".equals(nom)) { [EOL]         return JAVA_1_2; [EOL]     } else if ("1.3".equals(nom)) { [EOL]         return JAVA_1_3; [EOL]     } else if ("1.4".equals(nom)) { [EOL]         return JAVA_1_4; [EOL]     } else if ("1.5".equals(nom)) { [EOL]         return JAVA_1_5; [EOL]     } else if ("1.6".equals(nom)) { [EOL]         return JAVA_1_6; [EOL]     } else if ("1.7".equals(nom)) { [EOL]         return JAVA_1_7; [EOL]     } else if ("1.8".equals(nom)) { [EOL]         return JAVA_1_8; [EOL]     } else { [EOL]         return null; [EOL]     } [EOL] } 
lang3/tuple/ImmutablePair.java
 [LINE] return new ImmutablePair<L, R>(left, right); [LINE] public static <L, R> ImmutablePair<L, R> of(final L left, final R right) { [EOL]     return new ImmutablePair<L, R>(left, right); [EOL] } 
 [LINE] return right; [LINE] @Override [EOL] public R getRight() { [EOL]     return right; [EOL] } 
lang3/mutable/MutableDouble.java
 [LINE] @Override [LINE] public void setValue(final double value) { [EOL]     this.value = value; [EOL] } 
 [LINE] this.value = value.doubleValue(); [LINE] @Override [EOL] public void setValue(final Number value) { [EOL]     this.value = value.doubleValue(); [EOL] } 
 [LINE] return Double.isInfinite(value); [LINE] public boolean isInfinite() { [EOL]     return Double.isInfinite(value); [EOL] } 
 [LINE] @Override [LINE] @Override [EOL] public float floatValue() { [EOL]     return (float) value; [EOL] } 
 [LINE] return (int) (bits ^ bits >>> 32); [LINE] @Override [EOL] public int hashCode() { [EOL]     final long bits = Double.doubleToLongBits(value); [EOL]     return (int) (bits ^ bits >>> 32); [EOL] } 
 [LINE] return Double.compare(value, anotherVal); [LINE] @Override [EOL] public int compareTo(final MutableDouble other) { [EOL]     final double anotherVal = other.value; [EOL]     return Double.compare(value, anotherVal); [EOL] } 
lang3/StringEscapeUtils.java
 [LINE] out.write(input.toString()); [LINE] @Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     if (index != 0) { [EOL]         throw new IllegalStateException("CsvEscaper should never reach the [1] index"); [EOL]     } [EOL]     if (StringUtils.containsNone(input.toString(), CSV_SEARCH_CHARS)) { [EOL]         out.write(input.toString()); [EOL]     } else { [EOL]         out.write(CSV_QUOTE); [EOL]         out.write(StringUtils.replace(input.toString(), CSV_QUOTE_STR, CSV_QUOTE_STR + CSV_QUOTE_STR)); [EOL]         out.write(CSV_QUOTE); [EOL]     } [EOL]     return input.length(); [EOL] } 
 [LINE] return UNESCAPE_XML.translate(input); [LINE] public static final String unescapeXml(final String input) { [EOL]     return UNESCAPE_XML.translate(input); [EOL] } 
 [LINE] return UNESCAPE_CSV.translate(input); [LINE] public static final String unescapeCsv(final String input) { [EOL]     return UNESCAPE_CSV.translate(input); [EOL] } 
lang3/Range.java
 [LINE] return between(fromInclusive, toInclusive, null); [LINE] public static <T extends Comparable<T>> Range<T> between(final T fromInclusive, final T toInclusive) { [EOL]     return between(fromInclusive, toInclusive, null); [EOL] } 
 [LINE] return maximum; [LINE] public T getMaximum() { [EOL]     return maximum; [EOL] } 
 [LINE] return comparator; [LINE] public Comparator<T> getComparator() { [EOL]     return comparator; [EOL] } 
 [LINE] return comparator.compare(element, minimum) < 0; [LINE] public boolean isAfter(final T element) { [EOL]     if (element == null) { [EOL]         return false; [EOL]     } [EOL]     return comparator.compare(element, minimum) < 0; [EOL] } 
 [LINE] return false; [LINE] public boolean isStartedBy(final T element) { [EOL]     if (element == null) { [EOL]         return false; [EOL]     } [EOL]     return comparator.compare(element, minimum) == 0; [EOL] } 
 [LINE] return 0; [LINE] public int elementCompareTo(final T element) { [EOL]     if (element == null) { [EOL]         throw new NullPointerException("Element is null"); [EOL]     } [EOL]     if (isAfter(element)) { [EOL]         return -1; [EOL]     } else if (isBefore(element)) { [EOL]         return 1; [EOL]     } else { [EOL]         return 0; [EOL]     } [EOL] } 
 [LINE] return false; [LINE] public boolean isOverlappedBy(final Range<T> otherRange) { [EOL]     if (otherRange == null) { [EOL]         return false; [EOL]     } [EOL]     return otherRange.contains(minimum) || otherRange.contains(maximum) || contains(otherRange.minimum); [EOL] } 
 [LINE] if (otherRange == null) { [LINE] public boolean isBeforeRange(final Range<T> otherRange) { [EOL]     if (otherRange == null) { [EOL]         return false; [EOL]     } [EOL]     return isBefore(otherRange.minimum); [EOL] } 
 [LINE] final T max = getComparator().compare(maximum, other.maximum) < 0 ? maximum : other.maximum; [LINE] public Range<T> intersectionWith(final Range<T> other) { [EOL]     if (!this.isOverlappedBy(other)) { [EOL]         throw new IllegalArgumentException(String.format("Cannot calculate intersection with non-overlapping range %s", other)); [EOL]     } [EOL]     if (this.equals(other)) { [EOL]         return this; [EOL]     } [EOL]     final T min = getComparator().compare(minimum, other.minimum) < 0 ? other.minimum : minimum; [EOL]     final T max = getComparator().compare(maximum, other.maximum) < 0 ? maximum : other.maximum; [EOL]     return between(min, max, getComparator()); [EOL] } 
 [LINE] if (obj == this) { [LINE] @Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } else if (obj == null || obj.getClass() != getClass()) { [EOL]         return false; [EOL]     } else { [EOL]         @SuppressWarnings("unchecked") [EOL]         final Range<T> range = (Range<T>) obj; [EOL]         return minimum.equals(range.minimum) && maximum.equals(range.maximum); [EOL]     } [EOL] } 
 [LINE] return true; [LINE] @Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } else if (obj == null || obj.getClass() != getClass()) { [EOL]         return false; [EOL]     } else { [EOL]         @SuppressWarnings("unchecked") [EOL]         final Range<T> range = (Range<T>) obj; [EOL]         return minimum.equals(range.minimum) && maximum.equals(range.maximum); [EOL]     } [EOL] } 
 [LINE] return result; [LINE] @Override [EOL] public int hashCode() { [EOL]     int result = hashCode; [EOL]     if (hashCode == 0) { [EOL]         result = 17; [EOL]         result = 37 * result + getClass().hashCode(); [EOL]         result = 37 * result + minimum.hashCode(); [EOL]         result = 37 * result + maximum.hashCode(); [EOL]         hashCode = result; [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] if (result == null) { [LINE] @Override [EOL] public String toString() { [EOL]     String result = toString; [EOL]     if (result == null) { [EOL]         final StringBuilder buf = new StringBuilder(32); [EOL]         buf.append('['); [EOL]         buf.append(minimum); [EOL]         buf.append(".."); [EOL]         buf.append(maximum); [EOL]         buf.append(']'); [EOL]         result = buf.toString(); [EOL]         toString = result; [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] final StringBuilder buf = new StringBuilder(32); [LINE] @Override [EOL] public String toString() { [EOL]     String result = toString; [EOL]     if (result == null) { [EOL]         final StringBuilder buf = new StringBuilder(32); [EOL]         buf.append('['); [EOL]         buf.append(minimum); [EOL]         buf.append(".."); [EOL]         buf.append(maximum); [EOL]         buf.append(']'); [EOL]         result = buf.toString(); [EOL]         toString = result; [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] buf.append('['); [LINE] @Override [EOL] public String toString() { [EOL]     String result = toString; [EOL]     if (result == null) { [EOL]         final StringBuilder buf = new StringBuilder(32); [EOL]         buf.append('['); [EOL]         buf.append(minimum); [EOL]         buf.append(".."); [EOL]         buf.append(maximum); [EOL]         buf.append(']'); [EOL]         result = buf.toString(); [EOL]         toString = result; [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] buf.append(maximum); [LINE] @Override [EOL] public String toString() { [EOL]     String result = toString; [EOL]     if (result == null) { [EOL]         final StringBuilder buf = new StringBuilder(32); [EOL]         buf.append('['); [EOL]         buf.append(minimum); [EOL]         buf.append(".."); [EOL]         buf.append(maximum); [EOL]         buf.append(']'); [EOL]         result = buf.toString(); [EOL]         toString = result; [EOL]     } [EOL]     return result; [EOL] } 
lang3/mutable/MutableShort.java
 [LINE] @Override [LINE] public void setValue(final short value) { [EOL]     this.value = value; [EOL] } 
 [LINE] return value; [LINE] @Override [EOL] public int intValue() { [EOL]     return value; [EOL] } 
 [LINE] @Override [LINE] @Override [EOL] public float floatValue() { [EOL]     return value; [EOL] } 
 [LINE] return Short.valueOf(shortValue()); [LINE] public Short toShort() { [EOL]     return Short.valueOf(shortValue()); [EOL] } 
 [LINE] return value == ((MutableShort) obj).shortValue(); [LINE] @Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj instanceof MutableShort) { [EOL]         return value == ((MutableShort) obj).shortValue(); [EOL]     } [EOL]     return false; [EOL] } 
 [LINE] return value < anotherVal ? -1 : (value == anotherVal ? 0 : 1); [LINE] @Override [EOL] public int compareTo(final MutableShort other) { [EOL]     final short anotherVal = other.value; [EOL]     return value < anotherVal ? -1 : (value == anotherVal ? 0 : 1); [EOL] } 
lang3/text/StrBuilder.java
 [LINE] return this; [LINE] public StrBuilder setNewLineText(final String newLine) { [EOL]     this.newLine = newLine; [EOL]     return this; [EOL] } 
 [LINE] if (length < size) { [LINE] public StrBuilder setLength(final int length) { [EOL]     if (length < 0) { [EOL]         throw new StringIndexOutOfBoundsException(length); [EOL]     } [EOL]     if (length < size) { [EOL]         size = length; [EOL]     } else if (length > size) { [EOL]         ensureCapacity(length); [EOL]         final int oldEnd = size; [EOL]         final int newEnd = length; [EOL]         size = length; [EOL]         for (int i = oldEnd; i < newEnd; i++) { [EOL]             buffer[i] = '\0'; [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] ensureCapacity(length); [LINE] public StrBuilder setLength(final int length) { [EOL]     if (length < 0) { [EOL]         throw new StringIndexOutOfBoundsException(length); [EOL]     } [EOL]     if (length < size) { [EOL]         size = length; [EOL]     } else if (length > size) { [EOL]         ensureCapacity(length); [EOL]         final int oldEnd = size; [EOL]         final int newEnd = length; [EOL]         size = length; [EOL]         for (int i = oldEnd; i < newEnd; i++) { [EOL]             buffer[i] = '\0'; [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] final int oldEnd = size; [LINE] public StrBuilder setLength(final int length) { [EOL]     if (length < 0) { [EOL]         throw new StringIndexOutOfBoundsException(length); [EOL]     } [EOL]     if (length < size) { [EOL]         size = length; [EOL]     } else if (length > size) { [EOL]         ensureCapacity(length); [EOL]         final int oldEnd = size; [EOL]         final int newEnd = length; [EOL]         size = length; [EOL]         for (int i = oldEnd; i < newEnd; i++) { [EOL]             buffer[i] = '\0'; [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] return buffer.length; [LINE] public int capacity() { [EOL]     return buffer.length; [EOL] } 
 [LINE] System.arraycopy(old, 0, buffer, 0, size); [LINE] public StrBuilder ensureCapacity(final int capacity) { [EOL]     if (capacity > buffer.length) { [EOL]         final char[] old = buffer; [EOL]         buffer = new char[capacity * 2]; [EOL]         System.arraycopy(old, 0, buffer, 0, size); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] size = 0; [LINE] public StrBuilder clear() { [EOL]     size = 0; [EOL]     return this; [EOL] } 
 [LINE] return this; [LINE] public StrBuilder clear() { [EOL]     size = 0; [EOL]     return this; [EOL] } 
 [LINE] buffer[index] = ch; [LINE] public StrBuilder setCharAt(final int index, final char ch) { [EOL]     if (index < 0 || index >= length()) { [EOL]         throw new StringIndexOutOfBoundsException(index); [EOL]     } [EOL]     buffer[index] = ch; [EOL]     return this; [EOL] } 
 [LINE] if (index < 0 || index >= size) { [LINE] public StrBuilder deleteCharAt(final int index) { [EOL]     if (index < 0 || index >= size) { [EOL]         throw new StringIndexOutOfBoundsException(index); [EOL]     } [EOL]     deleteImpl(index, index + 1, 1); [EOL]     return this; [EOL] } 
 [LINE] if (size == 0) { [LINE] public char[] toCharArray() { [EOL]     if (size == 0) { [EOL]         return ArrayUtils.EMPTY_CHAR_ARRAY; [EOL]     } [EOL]     final char[] chars = new char[size]; [EOL]     System.arraycopy(buffer, 0, chars, 0, size); [EOL]     return chars; [EOL] } 
 [LINE] return ArrayUtils.EMPTY_CHAR_ARRAY; [LINE] public char[] toCharArray(final int startIndex, int endIndex) { [EOL]     endIndex = validateRange(startIndex, endIndex); [EOL]     final int len = endIndex - startIndex; [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_CHAR_ARRAY; [EOL]     } [EOL]     final char[] chars = new char[len]; [EOL]     System.arraycopy(buffer, startIndex, chars, 0, len); [EOL]     return chars; [EOL] } 
 [LINE] System.arraycopy(buffer, startIndex, chars, 0, len); [LINE] public char[] toCharArray(final int startIndex, int endIndex) { [EOL]     endIndex = validateRange(startIndex, endIndex); [EOL]     final int len = endIndex - startIndex; [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_CHAR_ARRAY; [EOL]     } [EOL]     final char[] chars = new char[len]; [EOL]     System.arraycopy(buffer, startIndex, chars, 0, len); [EOL]     return chars; [EOL] } 
 [LINE] final int len = length(); [LINE] public char[] getChars(char[] destination) { [EOL]     final int len = length(); [EOL]     if (destination == null || destination.length < len) { [EOL]         destination = new char[len]; [EOL]     } [EOL]     System.arraycopy(buffer, 0, destination, 0, len); [EOL]     return destination; [EOL] } 
 [LINE] destination = new char[len]; [LINE] public char[] getChars(char[] destination) { [EOL]     final int len = length(); [EOL]     if (destination == null || destination.length < len) { [EOL]         destination = new char[len]; [EOL]     } [EOL]     System.arraycopy(buffer, 0, destination, 0, len); [EOL]     return destination; [EOL] } 
 [LINE] throw new StringIndexOutOfBoundsException("end < start"); [LINE] public void getChars(final int startIndex, final int endIndex, final char[] destination, final int destinationIndex) { [EOL]     if (startIndex < 0) { [EOL]         throw new StringIndexOutOfBoundsException(startIndex); [EOL]     } [EOL]     if (endIndex < 0 || endIndex > length()) { [EOL]         throw new StringIndexOutOfBoundsException(endIndex); [EOL]     } [EOL]     if (startIndex > endIndex) { [EOL]         throw new StringIndexOutOfBoundsException("end < start"); [EOL]     } [EOL]     System.arraycopy(buffer, startIndex, destination, destinationIndex, endIndex - startIndex); [EOL] } 
 [LINE] return this; [LINE] public StrBuilder appendNewLine() { [EOL]     if (newLine == null) { [EOL]         append(SystemUtils.LINE_SEPARATOR); [EOL]         return this; [EOL]     } [EOL]     return append(newLine); [EOL] } 
 [LINE] return append(nullText); [LINE] public StrBuilder appendNull() { [EOL]     if (nullText == null) { [EOL]         return this; [EOL]     } [EOL]     return append(nullText); [EOL] } 
 [LINE] return append(seq.toString()); [LINE] @Override [EOL] public StrBuilder append(final CharSequence seq) { [EOL]     if (seq == null) { [EOL]         return appendNull(); [EOL]     } [EOL]     return append(seq.toString()); [EOL] } 
 [LINE] return append(seq.toString(), startIndex, length); [LINE] @Override [EOL] public StrBuilder append(final CharSequence seq, final int startIndex, final int length) { [EOL]     if (seq == null) { [EOL]         return appendNull(); [EOL]     } [EOL]     return append(seq.toString(), startIndex, length); [EOL] } 
 [LINE] final int len = length(); [LINE] public StrBuilder append(final String str) { [EOL]     if (str == null) { [EOL]         return appendNull(); [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     if (strLen > 0) { [EOL]         final int len = length(); [EOL]         ensureCapacity(len + strLen); [EOL]         str.getChars(0, strLen, buffer, len); [EOL]         size += strLen; [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] return appendNull(); [LINE] public StrBuilder append(final String str, final int startIndex, final int length) { [EOL]     if (str == null) { [EOL]         return appendNull(); [EOL]     } [EOL]     if (startIndex < 0 || startIndex > str.length()) { [EOL]         throw new StringIndexOutOfBoundsException("startIndex must be valid"); [EOL]     } [EOL]     if (length < 0 || (startIndex + length) > str.length()) { [EOL]         throw new StringIndexOutOfBoundsException("length must be valid"); [EOL]     } [EOL]     if (length > 0) { [EOL]         final int len = length(); [EOL]         ensureCapacity(len + length); [EOL]         str.getChars(startIndex, startIndex + length, buffer, len); [EOL]         size += length; [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] if (startIndex < 0 || startIndex > str.length()) { [LINE] public StrBuilder append(final String str, final int startIndex, final int length) { [EOL]     if (str == null) { [EOL]         return appendNull(); [EOL]     } [EOL]     if (startIndex < 0 || startIndex > str.length()) { [EOL]         throw new StringIndexOutOfBoundsException("startIndex must be valid"); [EOL]     } [EOL]     if (length < 0 || (startIndex + length) > str.length()) { [EOL]         throw new StringIndexOutOfBoundsException("length must be valid"); [EOL]     } [EOL]     if (length > 0) { [EOL]         final int len = length(); [EOL]         ensureCapacity(len + length); [EOL]         str.getChars(startIndex, startIndex + length, buffer, len); [EOL]         size += length; [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] throw new StringIndexOutOfBoundsException("length must be valid"); [LINE] public StrBuilder append(final String str, final int startIndex, final int length) { [EOL]     if (str == null) { [EOL]         return appendNull(); [EOL]     } [EOL]     if (startIndex < 0 || startIndex > str.length()) { [EOL]         throw new StringIndexOutOfBoundsException("startIndex must be valid"); [EOL]     } [EOL]     if (length < 0 || (startIndex + length) > str.length()) { [EOL]         throw new StringIndexOutOfBoundsException("length must be valid"); [EOL]     } [EOL]     if (length > 0) { [EOL]         final int len = length(); [EOL]         ensureCapacity(len + length); [EOL]         str.getChars(startIndex, startIndex + length, buffer, len); [EOL]         size += length; [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] final int len = length(); [LINE] public StrBuilder append(final String str, final int startIndex, final int length) { [EOL]     if (str == null) { [EOL]         return appendNull(); [EOL]     } [EOL]     if (startIndex < 0 || startIndex > str.length()) { [EOL]         throw new StringIndexOutOfBoundsException("startIndex must be valid"); [EOL]     } [EOL]     if (length < 0 || (startIndex + length) > str.length()) { [EOL]         throw new StringIndexOutOfBoundsException("length must be valid"); [EOL]     } [EOL]     if (length > 0) { [EOL]         final int len = length(); [EOL]         ensureCapacity(len + length); [EOL]         str.getChars(startIndex, startIndex + length, buffer, len); [EOL]         size += length; [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] final int len = length(); [LINE] public StrBuilder append(final StringBuffer str) { [EOL]     if (str == null) { [EOL]         return appendNull(); [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     if (strLen > 0) { [EOL]         final int len = length(); [EOL]         ensureCapacity(len + strLen); [EOL]         str.getChars(0, strLen, buffer, len); [EOL]         size += strLen; [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] str.getChars(0, strLen, buffer, len); [LINE] public StrBuilder append(final StringBuffer str) { [EOL]     if (str == null) { [EOL]         return appendNull(); [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     if (strLen > 0) { [EOL]         final int len = length(); [EOL]         ensureCapacity(len + strLen); [EOL]         str.getChars(0, strLen, buffer, len); [EOL]         size += strLen; [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] return this; [LINE] public StrBuilder append(final StringBuffer str) { [EOL]     if (str == null) { [EOL]         return appendNull(); [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     if (strLen > 0) { [EOL]         final int len = length(); [EOL]         ensureCapacity(len + strLen); [EOL]         str.getChars(0, strLen, buffer, len); [EOL]         size += strLen; [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] if (length < 0 || (startIndex + length) > str.length()) { [LINE] public StrBuilder append(final StringBuffer str, final int startIndex, final int length) { [EOL]     if (str == null) { [EOL]         return appendNull(); [EOL]     } [EOL]     if (startIndex < 0 || startIndex > str.length()) { [EOL]         throw new StringIndexOutOfBoundsException("startIndex must be valid"); [EOL]     } [EOL]     if (length < 0 || (startIndex + length) > str.length()) { [EOL]         throw new StringIndexOutOfBoundsException("length must be valid"); [EOL]     } [EOL]     if (length > 0) { [EOL]         final int len = length(); [EOL]         ensureCapacity(len + length); [EOL]         str.getChars(startIndex, startIndex + length, buffer, len); [EOL]         size += length; [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] if (length > 0) { [LINE] public StrBuilder append(final StringBuffer str, final int startIndex, final int length) { [EOL]     if (str == null) { [EOL]         return appendNull(); [EOL]     } [EOL]     if (startIndex < 0 || startIndex > str.length()) { [EOL]         throw new StringIndexOutOfBoundsException("startIndex must be valid"); [EOL]     } [EOL]     if (length < 0 || (startIndex + length) > str.length()) { [EOL]         throw new StringIndexOutOfBoundsException("length must be valid"); [EOL]     } [EOL]     if (length > 0) { [EOL]         final int len = length(); [EOL]         ensureCapacity(len + length); [EOL]         str.getChars(startIndex, startIndex + length, buffer, len); [EOL]         size += length; [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] str.getChars(startIndex, startIndex + length, buffer, len); [LINE] public StrBuilder append(final StringBuffer str, final int startIndex, final int length) { [EOL]     if (str == null) { [EOL]         return appendNull(); [EOL]     } [EOL]     if (startIndex < 0 || startIndex > str.length()) { [EOL]         throw new StringIndexOutOfBoundsException("startIndex must be valid"); [EOL]     } [EOL]     if (length < 0 || (startIndex + length) > str.length()) { [EOL]         throw new StringIndexOutOfBoundsException("length must be valid"); [EOL]     } [EOL]     if (length > 0) { [EOL]         final int len = length(); [EOL]         ensureCapacity(len + length); [EOL]         str.getChars(startIndex, startIndex + length, buffer, len); [EOL]         size += length; [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] size += length; [LINE] public StrBuilder append(final StringBuffer str, final int startIndex, final int length) { [EOL]     if (str == null) { [EOL]         return appendNull(); [EOL]     } [EOL]     if (startIndex < 0 || startIndex > str.length()) { [EOL]         throw new StringIndexOutOfBoundsException("startIndex must be valid"); [EOL]     } [EOL]     if (length < 0 || (startIndex + length) > str.length()) { [EOL]         throw new StringIndexOutOfBoundsException("length must be valid"); [EOL]     } [EOL]     if (length > 0) { [EOL]         final int len = length(); [EOL]         ensureCapacity(len + length); [EOL]         str.getChars(startIndex, startIndex + length, buffer, len); [EOL]         size += length; [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] final int len = length(); [LINE] public StrBuilder append(final StringBuilder str) { [EOL]     if (str == null) { [EOL]         return appendNull(); [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     if (strLen > 0) { [EOL]         final int len = length(); [EOL]         ensureCapacity(len + strLen); [EOL]         str.getChars(0, strLen, buffer, len); [EOL]         size += strLen; [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] if (length < 0 || (startIndex + length) > str.length()) { [LINE] public StrBuilder append(final StringBuilder str, final int startIndex, final int length) { [EOL]     if (str == null) { [EOL]         return appendNull(); [EOL]     } [EOL]     if (startIndex < 0 || startIndex > str.length()) { [EOL]         throw new StringIndexOutOfBoundsException("startIndex must be valid"); [EOL]     } [EOL]     if (length < 0 || (startIndex + length) > str.length()) { [EOL]         throw new StringIndexOutOfBoundsException("length must be valid"); [EOL]     } [EOL]     if (length > 0) { [EOL]         final int len = length(); [EOL]         ensureCapacity(len + length); [EOL]         str.getChars(startIndex, startIndex + length, buffer, len); [EOL]         size += length; [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] if (length > 0) { [LINE] public StrBuilder append(final StringBuilder str, final int startIndex, final int length) { [EOL]     if (str == null) { [EOL]         return appendNull(); [EOL]     } [EOL]     if (startIndex < 0 || startIndex > str.length()) { [EOL]         throw new StringIndexOutOfBoundsException("startIndex must be valid"); [EOL]     } [EOL]     if (length < 0 || (startIndex + length) > str.length()) { [EOL]         throw new StringIndexOutOfBoundsException("length must be valid"); [EOL]     } [EOL]     if (length > 0) { [EOL]         final int len = length(); [EOL]         ensureCapacity(len + length); [EOL]         str.getChars(startIndex, startIndex + length, buffer, len); [EOL]         size += length; [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] ensureCapacity(len + strLen); [LINE] public StrBuilder append(final StrBuilder str) { [EOL]     if (str == null) { [EOL]         return appendNull(); [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     if (strLen > 0) { [EOL]         final int len = length(); [EOL]         ensureCapacity(len + strLen); [EOL]         System.arraycopy(str.buffer, 0, buffer, len, strLen); [EOL]         size += strLen; [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] return this; [LINE] public StrBuilder append(final StrBuilder str) { [EOL]     if (str == null) { [EOL]         return appendNull(); [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     if (strLen > 0) { [EOL]         final int len = length(); [EOL]         ensureCapacity(len + strLen); [EOL]         System.arraycopy(str.buffer, 0, buffer, len, strLen); [EOL]         size += strLen; [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] if (str == null) { [LINE] public StrBuilder append(final StrBuilder str, final int startIndex, final int length) { [EOL]     if (str == null) { [EOL]         return appendNull(); [EOL]     } [EOL]     if (startIndex < 0 || startIndex > str.length()) { [EOL]         throw new StringIndexOutOfBoundsException("startIndex must be valid"); [EOL]     } [EOL]     if (length < 0 || (startIndex + length) > str.length()) { [EOL]         throw new StringIndexOutOfBoundsException("length must be valid"); [EOL]     } [EOL]     if (length > 0) { [EOL]         final int len = length(); [EOL]         ensureCapacity(len + length); [EOL]         str.getChars(startIndex, startIndex + length, buffer, len); [EOL]         size += length; [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] throw new StringIndexOutOfBoundsException("startIndex must be valid"); [LINE] public StrBuilder append(final StrBuilder str, final int startIndex, final int length) { [EOL]     if (str == null) { [EOL]         return appendNull(); [EOL]     } [EOL]     if (startIndex < 0 || startIndex > str.length()) { [EOL]         throw new StringIndexOutOfBoundsException("startIndex must be valid"); [EOL]     } [EOL]     if (length < 0 || (startIndex + length) > str.length()) { [EOL]         throw new StringIndexOutOfBoundsException("length must be valid"); [EOL]     } [EOL]     if (length > 0) { [EOL]         final int len = length(); [EOL]         ensureCapacity(len + length); [EOL]         str.getChars(startIndex, startIndex + length, buffer, len); [EOL]         size += length; [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] final int strLen = chars.length; [LINE] public StrBuilder append(final char[] chars) { [EOL]     if (chars == null) { [EOL]         return appendNull(); [EOL]     } [EOL]     final int strLen = chars.length; [EOL]     if (strLen > 0) { [EOL]         final int len = length(); [EOL]         ensureCapacity(len + strLen); [EOL]         System.arraycopy(chars, 0, buffer, len, strLen); [EOL]         size += strLen; [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] ensureCapacity(len + strLen); [LINE] public StrBuilder append(final char[] chars) { [EOL]     if (chars == null) { [EOL]         return appendNull(); [EOL]     } [EOL]     final int strLen = chars.length; [EOL]     if (strLen > 0) { [EOL]         final int len = length(); [EOL]         ensureCapacity(len + strLen); [EOL]         System.arraycopy(chars, 0, buffer, len, strLen); [EOL]         size += strLen; [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] if (startIndex < 0 || startIndex > chars.length) { [LINE] public StrBuilder append(final char[] chars, final int startIndex, final int length) { [EOL]     if (chars == null) { [EOL]         return appendNull(); [EOL]     } [EOL]     if (startIndex < 0 || startIndex > chars.length) { [EOL]         throw new StringIndexOutOfBoundsException("Invalid startIndex: " + length); [EOL]     } [EOL]     if (length < 0 || (startIndex + length) > chars.length) { [EOL]         throw new StringIndexOutOfBoundsException("Invalid length: " + length); [EOL]     } [EOL]     if (length > 0) { [EOL]         final int len = length(); [EOL]         ensureCapacity(len + length); [EOL]         System.arraycopy(chars, startIndex, buffer, len, length); [EOL]         size += length; [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] System.arraycopy(chars, startIndex, buffer, len, length); [LINE] public StrBuilder append(final char[] chars, final int startIndex, final int length) { [EOL]     if (chars == null) { [EOL]         return appendNull(); [EOL]     } [EOL]     if (startIndex < 0 || startIndex > chars.length) { [EOL]         throw new StringIndexOutOfBoundsException("Invalid startIndex: " + length); [EOL]     } [EOL]     if (length < 0 || (startIndex + length) > chars.length) { [EOL]         throw new StringIndexOutOfBoundsException("Invalid length: " + length); [EOL]     } [EOL]     if (length > 0) { [EOL]         final int len = length(); [EOL]         ensureCapacity(len + length); [EOL]         System.arraycopy(chars, startIndex, buffer, len, length); [EOL]         size += length; [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] size += length; [LINE] public StrBuilder append(final char[] chars, final int startIndex, final int length) { [EOL]     if (chars == null) { [EOL]         return appendNull(); [EOL]     } [EOL]     if (startIndex < 0 || startIndex > chars.length) { [EOL]         throw new StringIndexOutOfBoundsException("Invalid startIndex: " + length); [EOL]     } [EOL]     if (length < 0 || (startIndex + length) > chars.length) { [EOL]         throw new StringIndexOutOfBoundsException("Invalid length: " + length); [EOL]     } [EOL]     if (length > 0) { [EOL]         final int len = length(); [EOL]         ensureCapacity(len + length); [EOL]         System.arraycopy(chars, startIndex, buffer, len, length); [EOL]         size += length; [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] buffer[size++] = 'u'; [LINE] public StrBuilder append(final boolean value) { [EOL]     if (value) { [EOL]         ensureCapacity(size + 4); [EOL]         buffer[size++] = 't'; [EOL]         buffer[size++] = 'r'; [EOL]         buffer[size++] = 'u'; [EOL]         buffer[size++] = 'e'; [EOL]     } else { [EOL]         ensureCapacity(size + 5); [EOL]         buffer[size++] = 'f'; [EOL]         buffer[size++] = 'a'; [EOL]         buffer[size++] = 'l'; [EOL]         buffer[size++] = 's'; [EOL]         buffer[size++] = 'e'; [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] buffer[size++] = 'e'; [LINE] public StrBuilder append(final boolean value) { [EOL]     if (value) { [EOL]         ensureCapacity(size + 4); [EOL]         buffer[size++] = 't'; [EOL]         buffer[size++] = 'r'; [EOL]         buffer[size++] = 'u'; [EOL]         buffer[size++] = 'e'; [EOL]     } else { [EOL]         ensureCapacity(size + 5); [EOL]         buffer[size++] = 'f'; [EOL]         buffer[size++] = 'a'; [EOL]         buffer[size++] = 'l'; [EOL]         buffer[size++] = 's'; [EOL]         buffer[size++] = 'e'; [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] return this; [LINE] public StrBuilder append(final boolean value) { [EOL]     if (value) { [EOL]         ensureCapacity(size + 4); [EOL]         buffer[size++] = 't'; [EOL]         buffer[size++] = 'r'; [EOL]         buffer[size++] = 'u'; [EOL]         buffer[size++] = 'e'; [EOL]     } else { [EOL]         ensureCapacity(size + 5); [EOL]         buffer[size++] = 'f'; [EOL]         buffer[size++] = 'a'; [EOL]         buffer[size++] = 'l'; [EOL]         buffer[size++] = 's'; [EOL]         buffer[size++] = 'e'; [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] buffer[size++] = ch; [LINE] @Override [EOL] public StrBuilder append(final char ch) { [EOL]     final int len = length(); [EOL]     ensureCapacity(len + 1); [EOL]     buffer[size++] = ch; [EOL]     return this; [EOL] } 
 [LINE] return append(obj).appendNewLine(); [LINE] public StrBuilder appendln(final Object obj) { [EOL]     return append(obj).appendNewLine(); [EOL] } 
 [LINE] return append(str).appendNewLine(); [LINE] public StrBuilder appendln(final String str) { [EOL]     return append(str).appendNewLine(); [EOL] } 
 [LINE] return append(str, startIndex, length).appendNewLine(); [LINE] public StrBuilder appendln(final StringBuffer str, final int startIndex, final int length) { [EOL]     return append(str, startIndex, length).appendNewLine(); [EOL] } 
 [LINE] return append(str).appendNewLine(); [LINE] public StrBuilder appendln(final StrBuilder str) { [EOL]     return append(str).appendNewLine(); [EOL] } 
 [LINE] return append(chars).appendNewLine(); [LINE] public StrBuilder appendln(final char[] chars) { [EOL]     return append(chars).appendNewLine(); [EOL] } 
 [LINE] if (it != null) { [LINE] public StrBuilder appendAll(final Iterator<?> it) { [EOL]     if (it != null) { [EOL]         while (it.hasNext()) { [EOL]             append(it.next()); [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] append(it.next()); [LINE] public StrBuilder appendAll(final Iterator<?> it) { [EOL]     if (it != null) { [EOL]         while (it.hasNext()) { [EOL]             append(it.next()); [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] if (array != null && array.length > 0) { [LINE] public StrBuilder appendWithSeparators(final Object[] array, String separator) { [EOL]     if (array != null && array.length > 0) { [EOL]         separator = ObjectUtils.toString(separator); [EOL]         append(array[0]); [EOL]         for (int i = 1; i < array.length; i++) { [EOL]             append(separator); [EOL]             append(array[i]); [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] append(array[0]); [LINE] public StrBuilder appendWithSeparators(final Object[] array, String separator) { [EOL]     if (array != null && array.length > 0) { [EOL]         separator = ObjectUtils.toString(separator); [EOL]         append(array[0]); [EOL]         for (int i = 1; i < array.length; i++) { [EOL]             append(separator); [EOL]             append(array[i]); [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] for (int i = 1; i < array.length; i++) { [LINE] public StrBuilder appendWithSeparators(final Object[] array, String separator) { [EOL]     if (array != null && array.length > 0) { [EOL]         separator = ObjectUtils.toString(separator); [EOL]         append(array[0]); [EOL]         for (int i = 1; i < array.length; i++) { [EOL]             append(separator); [EOL]             append(array[i]); [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] final Iterator<?> it = iterable.iterator(); [LINE] public StrBuilder appendWithSeparators(final Iterable<?> iterable, String separator) { [EOL]     if (iterable != null) { [EOL]         separator = ObjectUtils.toString(separator); [EOL]         final Iterator<?> it = iterable.iterator(); [EOL]         while (it.hasNext()) { [EOL]             append(it.next()); [EOL]             if (it.hasNext()) { [EOL]                 append(separator); [EOL]             } [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] append(it.next()); [LINE] public StrBuilder appendWithSeparators(final Iterable<?> iterable, String separator) { [EOL]     if (iterable != null) { [EOL]         separator = ObjectUtils.toString(separator); [EOL]         final Iterator<?> it = iterable.iterator(); [EOL]         while (it.hasNext()) { [EOL]             append(it.next()); [EOL]             if (it.hasNext()) { [EOL]                 append(separator); [EOL]             } [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] append(it.next()); [LINE] public StrBuilder appendWithSeparators(final Iterator<?> it, String separator) { [EOL]     if (it != null) { [EOL]         separator = ObjectUtils.toString(separator); [EOL]         while (it.hasNext()) { [EOL]             append(it.next()); [EOL]             if (it.hasNext()) { [EOL]                 append(separator); [EOL]             } [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] if (it.hasNext()) { [LINE] public StrBuilder appendWithSeparators(final Iterator<?> it, String separator) { [EOL]     if (it != null) { [EOL]         separator = ObjectUtils.toString(separator); [EOL]         while (it.hasNext()) { [EOL]             append(it.next()); [EOL]             if (it.hasNext()) { [EOL]                 append(separator); [EOL]             } [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] append(separator); [LINE] public StrBuilder appendWithSeparators(final Iterator<?> it, String separator) { [EOL]     if (it != null) { [EOL]         separator = ObjectUtils.toString(separator); [EOL]         while (it.hasNext()) { [EOL]             append(it.next()); [EOL]             if (it.hasNext()) { [EOL]                 append(separator); [EOL]             } [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] return this; [LINE] public StrBuilder appendWithSeparators(final Iterator<?> it, String separator) { [EOL]     if (it != null) { [EOL]         separator = ObjectUtils.toString(separator); [EOL]         while (it.hasNext()) { [EOL]             append(it.next()); [EOL]             if (it.hasNext()) { [EOL]                 append(separator); [EOL]             } [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] return this; [LINE] public StrBuilder appendSeparator(final String standard, final String defaultIfEmpty) { [EOL]     final String str = isEmpty() ? defaultIfEmpty : standard; [EOL]     if (str != null) { [EOL]         append(str); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] return this; [LINE] public StrBuilder appendSeparator(final char separator) { [EOL]     if (size() > 0) { [EOL]         append(separator); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] if (separator != null && loopIndex > 0) { [LINE] public StrBuilder appendSeparator(final String separator, final int loopIndex) { [EOL]     if (separator != null && loopIndex > 0) { [EOL]         append(separator); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] if (width > 0) { [LINE] public StrBuilder appendFixedWidthPadLeft(final Object obj, final int width, final char padChar) { [EOL]     if (width > 0) { [EOL]         ensureCapacity(size + width); [EOL]         String str = (obj == null ? getNullText() : obj.toString()); [EOL]         if (str == null) { [EOL]             str = ""; [EOL]         } [EOL]         final int strLen = str.length(); [EOL]         if (strLen >= width) { [EOL]             str.getChars(strLen - width, strLen, buffer, size); [EOL]         } else { [EOL]             final int padLen = width - strLen; [EOL]             for (int i = 0; i < padLen; i++) { [EOL]                 buffer[size + i] = padChar; [EOL]             } [EOL]             str.getChars(0, strLen, buffer, size + padLen); [EOL]         } [EOL]         size += width; [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] final int padLen = width - strLen; [LINE] public StrBuilder appendFixedWidthPadLeft(final Object obj, final int width, final char padChar) { [EOL]     if (width > 0) { [EOL]         ensureCapacity(size + width); [EOL]         String str = (obj == null ? getNullText() : obj.toString()); [EOL]         if (str == null) { [EOL]             str = ""; [EOL]         } [EOL]         final int strLen = str.length(); [EOL]         if (strLen >= width) { [EOL]             str.getChars(strLen - width, strLen, buffer, size); [EOL]         } else { [EOL]             final int padLen = width - strLen; [EOL]             for (int i = 0; i < padLen; i++) { [EOL]                 buffer[size + i] = padChar; [EOL]             } [EOL]             str.getChars(0, strLen, buffer, size + padLen); [EOL]         } [EOL]         size += width; [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] return this; [LINE] public StrBuilder appendFixedWidthPadLeft(final Object obj, final int width, final char padChar) { [EOL]     if (width > 0) { [EOL]         ensureCapacity(size + width); [EOL]         String str = (obj == null ? getNullText() : obj.toString()); [EOL]         if (str == null) { [EOL]             str = ""; [EOL]         } [EOL]         final int strLen = str.length(); [EOL]         if (strLen >= width) { [EOL]             str.getChars(strLen - width, strLen, buffer, size); [EOL]         } else { [EOL]             final int padLen = width - strLen; [EOL]             for (int i = 0; i < padLen; i++) { [EOL]                 buffer[size + i] = padChar; [EOL]             } [EOL]             str.getChars(0, strLen, buffer, size + padLen); [EOL]         } [EOL]         size += width; [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] final int strLen = str.length(); [LINE] public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar) { [EOL]     if (width > 0) { [EOL]         ensureCapacity(size + width); [EOL]         String str = (obj == null ? getNullText() : obj.toString()); [EOL]         if (str == null) { [EOL]             str = ""; [EOL]         } [EOL]         final int strLen = str.length(); [EOL]         if (strLen >= width) { [EOL]             str.getChars(0, width, buffer, size); [EOL]         } else { [EOL]             final int padLen = width - strLen; [EOL]             str.getChars(0, strLen, buffer, size); [EOL]             for (int i = 0; i < padLen; i++) { [EOL]                 buffer[size + strLen + i] = padChar; [EOL]             } [EOL]         } [EOL]         size += width; [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] final int padLen = width - strLen; [LINE] public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar) { [EOL]     if (width > 0) { [EOL]         ensureCapacity(size + width); [EOL]         String str = (obj == null ? getNullText() : obj.toString()); [EOL]         if (str == null) { [EOL]             str = ""; [EOL]         } [EOL]         final int strLen = str.length(); [EOL]         if (strLen >= width) { [EOL]             str.getChars(0, width, buffer, size); [EOL]         } else { [EOL]             final int padLen = width - strLen; [EOL]             str.getChars(0, strLen, buffer, size); [EOL]             for (int i = 0; i < padLen; i++) { [EOL]                 buffer[size + strLen + i] = padChar; [EOL]             } [EOL]         } [EOL]         size += width; [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] return this; [LINE] public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar) { [EOL]     if (width > 0) { [EOL]         ensureCapacity(size + width); [EOL]         String str = (obj == null ? getNullText() : obj.toString()); [EOL]         if (str == null) { [EOL]             str = ""; [EOL]         } [EOL]         final int strLen = str.length(); [EOL]         if (strLen >= width) { [EOL]             str.getChars(0, width, buffer, size); [EOL]         } else { [EOL]             final int padLen = width - strLen; [EOL]             str.getChars(0, strLen, buffer, size); [EOL]             for (int i = 0; i < padLen; i++) { [EOL]                 buffer[size + strLen + i] = padChar; [EOL]             } [EOL]         } [EOL]         size += width; [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] return appendFixedWidthPadRight(String.valueOf(value), width, padChar); [LINE] public StrBuilder appendFixedWidthPadRight(final int value, final int width, final char padChar) { [EOL]     return appendFixedWidthPadRight(String.valueOf(value), width, padChar); [EOL] } 
 [LINE] if (obj == null) { [LINE] public StrBuilder insert(final int index, final Object obj) { [EOL]     if (obj == null) { [EOL]         return insert(index, nullText); [EOL]     } [EOL]     return insert(index, obj.toString()); [EOL] } 
 [LINE] System.arraycopy(buffer, index, buffer, index + strLen, size - index); [LINE] public StrBuilder insert(final int index, String str) { [EOL]     validateIndex(index); [EOL]     if (str == null) { [EOL]         str = nullText; [EOL]     } [EOL]     if (str != null) { [EOL]         final int strLen = str.length(); [EOL]         if (strLen > 0) { [EOL]             final int newSize = size + strLen; [EOL]             ensureCapacity(newSize); [EOL]             System.arraycopy(buffer, index, buffer, index + strLen, size - index); [EOL]             size = newSize; [EOL]             str.getChars(0, strLen, buffer, index); [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] size = newSize; [LINE] public StrBuilder insert(final int index, String str) { [EOL]     validateIndex(index); [EOL]     if (str == null) { [EOL]         str = nullText; [EOL]     } [EOL]     if (str != null) { [EOL]         final int strLen = str.length(); [EOL]         if (strLen > 0) { [EOL]             final int newSize = size + strLen; [EOL]             ensureCapacity(newSize); [EOL]             System.arraycopy(buffer, index, buffer, index + strLen, size - index); [EOL]             size = newSize; [EOL]             str.getChars(0, strLen, buffer, index); [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] if (chars == null) { [LINE] public StrBuilder insert(final int index, final char[] chars) { [EOL]     validateIndex(index); [EOL]     if (chars == null) { [EOL]         return insert(index, nullText); [EOL]     } [EOL]     final int len = chars.length; [EOL]     if (len > 0) { [EOL]         ensureCapacity(size + len); [EOL]         System.arraycopy(buffer, index, buffer, index + len, size - index); [EOL]         System.arraycopy(chars, 0, buffer, index, len); [EOL]         size += len; [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] if (len > 0) { [LINE] public StrBuilder insert(final int index, final char[] chars) { [EOL]     validateIndex(index); [EOL]     if (chars == null) { [EOL]         return insert(index, nullText); [EOL]     } [EOL]     final int len = chars.length; [EOL]     if (len > 0) { [EOL]         ensureCapacity(size + len); [EOL]         System.arraycopy(buffer, index, buffer, index + len, size - index); [EOL]         System.arraycopy(chars, 0, buffer, index, len); [EOL]         size += len; [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] return insert(index, nullText); [LINE] public StrBuilder insert(final int index, final char[] chars, final int offset, final int length) { [EOL]     validateIndex(index); [EOL]     if (chars == null) { [EOL]         return insert(index, nullText); [EOL]     } [EOL]     if (offset < 0 || offset > chars.length) { [EOL]         throw new StringIndexOutOfBoundsException("Invalid offset: " + offset); [EOL]     } [EOL]     if (length < 0 || offset + length > chars.length) { [EOL]         throw new StringIndexOutOfBoundsException("Invalid length: " + length); [EOL]     } [EOL]     if (length > 0) { [EOL]         ensureCapacity(size + length); [EOL]         System.arraycopy(buffer, index, buffer, index + length, size - index); [EOL]         System.arraycopy(chars, offset, buffer, index, length); [EOL]         size += length; [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] System.arraycopy(buffer, index, buffer, index + 4, size - index); [LINE] public StrBuilder insert(int index, final boolean value) { [EOL]     validateIndex(index); [EOL]     if (value) { [EOL]         ensureCapacity(size + 4); [EOL]         System.arraycopy(buffer, index, buffer, index + 4, size - index); [EOL]         buffer[index++] = 't'; [EOL]         buffer[index++] = 'r'; [EOL]         buffer[index++] = 'u'; [EOL]         buffer[index] = 'e'; [EOL]         size += 4; [EOL]     } else { [EOL]         ensureCapacity(size + 5); [EOL]         System.arraycopy(buffer, index, buffer, index + 5, size - index); [EOL]         buffer[index++] = 'f'; [EOL]         buffer[index++] = 'a'; [EOL]         buffer[index++] = 'l'; [EOL]         buffer[index++] = 's'; [EOL]         buffer[index] = 'e'; [EOL]         size += 5; [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] size += 4; [LINE] public StrBuilder insert(int index, final boolean value) { [EOL]     validateIndex(index); [EOL]     if (value) { [EOL]         ensureCapacity(size + 4); [EOL]         System.arraycopy(buffer, index, buffer, index + 4, size - index); [EOL]         buffer[index++] = 't'; [EOL]         buffer[index++] = 'r'; [EOL]         buffer[index++] = 'u'; [EOL]         buffer[index] = 'e'; [EOL]         size += 4; [EOL]     } else { [EOL]         ensureCapacity(size + 5); [EOL]         System.arraycopy(buffer, index, buffer, index + 5, size - index); [EOL]         buffer[index++] = 'f'; [EOL]         buffer[index++] = 'a'; [EOL]         buffer[index++] = 'l'; [EOL]         buffer[index++] = 's'; [EOL]         buffer[index] = 'e'; [EOL]         size += 5; [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] size += 5; [LINE] public StrBuilder insert(int index, final boolean value) { [EOL]     validateIndex(index); [EOL]     if (value) { [EOL]         ensureCapacity(size + 4); [EOL]         System.arraycopy(buffer, index, buffer, index + 4, size - index); [EOL]         buffer[index++] = 't'; [EOL]         buffer[index++] = 'r'; [EOL]         buffer[index++] = 'u'; [EOL]         buffer[index] = 'e'; [EOL]         size += 4; [EOL]     } else { [EOL]         ensureCapacity(size + 5); [EOL]         System.arraycopy(buffer, index, buffer, index + 5, size - index); [EOL]         buffer[index++] = 'f'; [EOL]         buffer[index++] = 'a'; [EOL]         buffer[index++] = 'l'; [EOL]         buffer[index++] = 's'; [EOL]         buffer[index] = 'e'; [EOL]         size += 5; [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] System.arraycopy(buffer, index, buffer, index + 1, size - index); [LINE] public StrBuilder insert(final int index, final char value) { [EOL]     validateIndex(index); [EOL]     ensureCapacity(size + 1); [EOL]     System.arraycopy(buffer, index, buffer, index + 1, size - index); [EOL]     buffer[index] = value; [EOL]     size++; [EOL]     return this; [EOL] } 
 [LINE] buffer[index] = value; [LINE] public StrBuilder insert(final int index, final char value) { [EOL]     validateIndex(index); [EOL]     ensureCapacity(size + 1); [EOL]     System.arraycopy(buffer, index, buffer, index + 1, size - index); [EOL]     buffer[index] = value; [EOL]     size++; [EOL]     return this; [EOL] } 
 [LINE] size++; [LINE] public StrBuilder insert(final int index, final char value) { [EOL]     validateIndex(index); [EOL]     ensureCapacity(size + 1); [EOL]     System.arraycopy(buffer, index, buffer, index + 1, size - index); [EOL]     buffer[index] = value; [EOL]     size++; [EOL]     return this; [EOL] } 
 [LINE] return insert(index, String.valueOf(value)); [LINE] public StrBuilder insert(final int index, final double value) { [EOL]     return insert(index, String.valueOf(value)); [EOL] } 
 [LINE] endIndex = validateRange(startIndex, endIndex); [LINE] public StrBuilder delete(final int startIndex, int endIndex) { [EOL]     endIndex = validateRange(startIndex, endIndex); [EOL]     final int len = endIndex - startIndex; [EOL]     if (len > 0) { [EOL]         deleteImpl(startIndex, endIndex, len); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] final int len = endIndex - startIndex; [LINE] public StrBuilder delete(final int startIndex, int endIndex) { [EOL]     endIndex = validateRange(startIndex, endIndex); [EOL]     final int len = endIndex - startIndex; [EOL]     if (len > 0) { [EOL]         deleteImpl(startIndex, endIndex, len); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] for (int i = 0; i < size; i++) { [LINE] public StrBuilder deleteAll(final char ch) { [EOL]     for (int i = 0; i < size; i++) { [EOL]         if (buffer[i] == ch) { [EOL]             final int start = i; [EOL]             while (++i < size) { [EOL]                 if (buffer[i] != ch) { [EOL]                     break; [EOL]                 } [EOL]             } [EOL]             final int len = i - start; [EOL]             deleteImpl(start, i, len); [EOL]             i -= len; [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] if (buffer[i] == ch) { [LINE] public StrBuilder deleteAll(final char ch) { [EOL]     for (int i = 0; i < size; i++) { [EOL]         if (buffer[i] == ch) { [EOL]             final int start = i; [EOL]             while (++i < size) { [EOL]                 if (buffer[i] != ch) { [EOL]                     break; [EOL]                 } [EOL]             } [EOL]             final int len = i - start; [EOL]             deleteImpl(start, i, len); [EOL]             i -= len; [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] final int start = i; [LINE] public StrBuilder deleteAll(final char ch) { [EOL]     for (int i = 0; i < size; i++) { [EOL]         if (buffer[i] == ch) { [EOL]             final int start = i; [EOL]             while (++i < size) { [EOL]                 if (buffer[i] != ch) { [EOL]                     break; [EOL]                 } [EOL]             } [EOL]             final int len = i - start; [EOL]             deleteImpl(start, i, len); [EOL]             i -= len; [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] break; [LINE] public StrBuilder deleteFirst(final char ch) { [EOL]     for (int i = 0; i < size; i++) { [EOL]         if (buffer[i] == ch) { [EOL]             deleteImpl(i, i + 1, 1); [EOL]             break; [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] final int len = (str == null ? 0 : str.length()); [LINE] public StrBuilder deleteAll(final String str) { [EOL]     final int len = (str == null ? 0 : str.length()); [EOL]     if (len > 0) { [EOL]         int index = indexOf(str, 0); [EOL]         while (index >= 0) { [EOL]             deleteImpl(index, index + len, len); [EOL]             index = indexOf(str, index); [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] index = indexOf(str, index); [LINE] public StrBuilder deleteAll(final String str) { [EOL]     final int len = (str == null ? 0 : str.length()); [EOL]     if (len > 0) { [EOL]         int index = indexOf(str, 0); [EOL]         while (index >= 0) { [EOL]             deleteImpl(index, index + len, len); [EOL]             index = indexOf(str, index); [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] if (len > 0) { [LINE] public StrBuilder deleteFirst(final String str) { [EOL]     final int len = (str == null ? 0 : str.length()); [EOL]     if (len > 0) { [EOL]         final int index = indexOf(str, 0); [EOL]         if (index >= 0) { [EOL]             deleteImpl(index, index + len, len); [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] if (index >= 0) { [LINE] public StrBuilder deleteFirst(final String str) { [EOL]     final int len = (str == null ? 0 : str.length()); [EOL]     if (len > 0) { [EOL]         final int index = indexOf(str, 0); [EOL]         if (index >= 0) { [EOL]             deleteImpl(index, index + len, len); [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] final int newSize = size - removeLen + insertLen; [LINE] private void replaceImpl(final int startIndex, final int endIndex, final int removeLen, final String insertStr, final int insertLen) { [EOL]     final int newSize = size - removeLen + insertLen; [EOL]     if (insertLen != removeLen) { [EOL]         ensureCapacity(newSize); [EOL]         System.arraycopy(buffer, endIndex, buffer, startIndex + insertLen, size - endIndex); [EOL]         size = newSize; [EOL]     } [EOL]     if (insertLen > 0) { [EOL]         insertStr.getChars(0, insertLen, buffer, startIndex); [EOL]     } [EOL] } 
 [LINE] if (insertLen > 0) { [LINE] private void replaceImpl(final int startIndex, final int endIndex, final int removeLen, final String insertStr, final int insertLen) { [EOL]     final int newSize = size - removeLen + insertLen; [EOL]     if (insertLen != removeLen) { [EOL]         ensureCapacity(newSize); [EOL]         System.arraycopy(buffer, endIndex, buffer, startIndex + insertLen, size - endIndex); [EOL]         size = newSize; [EOL]     } [EOL]     if (insertLen > 0) { [EOL]         insertStr.getChars(0, insertLen, buffer, startIndex); [EOL]     } [EOL] } 
 [LINE] final int insertLen = (replaceStr == null ? 0 : replaceStr.length()); [LINE] public StrBuilder replace(final int startIndex, int endIndex, final String replaceStr) { [EOL]     endIndex = validateRange(startIndex, endIndex); [EOL]     final int insertLen = (replaceStr == null ? 0 : replaceStr.length()); [EOL]     replaceImpl(startIndex, endIndex, endIndex - startIndex, replaceStr, insertLen); [EOL]     return this; [EOL] } 
 [LINE] return this; [LINE] public StrBuilder replace(final int startIndex, int endIndex, final String replaceStr) { [EOL]     endIndex = validateRange(startIndex, endIndex); [EOL]     final int insertLen = (replaceStr == null ? 0 : replaceStr.length()); [EOL]     replaceImpl(startIndex, endIndex, endIndex - startIndex, replaceStr, insertLen); [EOL]     return this; [EOL] } 
 [LINE] return this; [LINE] public StrBuilder replaceAll(final char search, final char replace) { [EOL]     if (search != replace) { [EOL]         for (int i = 0; i < size; i++) { [EOL]             if (buffer[i] == search) { [EOL]                 buffer[i] = replace; [EOL]             } [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] if (search != replace) { [LINE] public StrBuilder replaceFirst(final char search, final char replace) { [EOL]     if (search != replace) { [EOL]         for (int i = 0; i < size; i++) { [EOL]             if (buffer[i] == search) { [EOL]                 buffer[i] = replace; [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] if (buffer[i] == search) { [LINE] public StrBuilder replaceFirst(final char search, final char replace) { [EOL]     if (search != replace) { [EOL]         for (int i = 0; i < size; i++) { [EOL]             if (buffer[i] == search) { [EOL]                 buffer[i] = replace; [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] break; [LINE] public StrBuilder replaceFirst(final char search, final char replace) { [EOL]     if (search != replace) { [EOL]         for (int i = 0; i < size; i++) { [EOL]             if (buffer[i] == search) { [EOL]                 buffer[i] = replace; [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] index = indexOf(searchStr, index + replaceLen); [LINE] public StrBuilder replaceAll(final String searchStr, final String replaceStr) { [EOL]     final int searchLen = (searchStr == null ? 0 : searchStr.length()); [EOL]     if (searchLen > 0) { [EOL]         final int replaceLen = (replaceStr == null ? 0 : replaceStr.length()); [EOL]         int index = indexOf(searchStr, 0); [EOL]         while (index >= 0) { [EOL]             replaceImpl(index, index + searchLen, searchLen, replaceStr, replaceLen); [EOL]             index = indexOf(searchStr, index + replaceLen); [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] final int searchLen = (searchStr == null ? 0 : searchStr.length()); [LINE] public StrBuilder replaceFirst(final String searchStr, final String replaceStr) { [EOL]     final int searchLen = (searchStr == null ? 0 : searchStr.length()); [EOL]     if (searchLen > 0) { [EOL]         final int index = indexOf(searchStr, 0); [EOL]         if (index >= 0) { [EOL]             final int replaceLen = (replaceStr == null ? 0 : replaceStr.length()); [EOL]             replaceImpl(index, index + searchLen, searchLen, replaceStr, replaceLen); [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] final int index = indexOf(searchStr, 0); [LINE] public StrBuilder replaceFirst(final String searchStr, final String replaceStr) { [EOL]     final int searchLen = (searchStr == null ? 0 : searchStr.length()); [EOL]     if (searchLen > 0) { [EOL]         final int index = indexOf(searchStr, 0); [EOL]         if (index >= 0) { [EOL]             final int replaceLen = (replaceStr == null ? 0 : replaceStr.length()); [EOL]             replaceImpl(index, index + searchLen, searchLen, replaceStr, replaceLen); [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] if (matcher == null || size == 0) { [LINE] private StrBuilder replaceImpl(final StrMatcher matcher, final String replaceStr, final int from, int to, int replaceCount) { [EOL]     if (matcher == null || size == 0) { [EOL]         return this; [EOL]     } [EOL]     final int replaceLen = (replaceStr == null ? 0 : replaceStr.length()); [EOL]     final char[] buf = buffer; [EOL]     for (int i = from; i < to && replaceCount != 0; i++) { [EOL]         final int removeLen = matcher.isMatch(buf, i, from, to); [EOL]         if (removeLen > 0) { [EOL]             replaceImpl(i, i + removeLen, removeLen, replaceStr, replaceLen); [EOL]             to = to - removeLen + replaceLen; [EOL]             i = i + replaceLen - 1; [EOL]             if (replaceCount > 0) { [EOL]                 replaceCount--; [EOL]             } [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] to = to - removeLen + replaceLen; [LINE] private StrBuilder replaceImpl(final StrMatcher matcher, final String replaceStr, final int from, int to, int replaceCount) { [EOL]     if (matcher == null || size == 0) { [EOL]         return this; [EOL]     } [EOL]     final int replaceLen = (replaceStr == null ? 0 : replaceStr.length()); [EOL]     final char[] buf = buffer; [EOL]     for (int i = from; i < to && replaceCount != 0; i++) { [EOL]         final int removeLen = matcher.isMatch(buf, i, from, to); [EOL]         if (removeLen > 0) { [EOL]             replaceImpl(i, i + removeLen, removeLen, replaceStr, replaceLen); [EOL]             to = to - removeLen + replaceLen; [EOL]             i = i + replaceLen - 1; [EOL]             if (replaceCount > 0) { [EOL]                 replaceCount--; [EOL]             } [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] final char[] buf = buffer; [LINE] public StrBuilder reverse() { [EOL]     if (size == 0) { [EOL]         return this; [EOL]     } [EOL]     final int half = size / 2; [EOL]     final char[] buf = buffer; [EOL]     for (int leftIdx = 0, rightIdx = size - 1; leftIdx < half; leftIdx++, rightIdx--) { [EOL]         final char swap = buf[leftIdx]; [EOL]         buf[leftIdx] = buf[rightIdx]; [EOL]         buf[rightIdx] = swap; [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] buf[leftIdx] = buf[rightIdx]; [LINE] public StrBuilder reverse() { [EOL]     if (size == 0) { [EOL]         return this; [EOL]     } [EOL]     final int half = size / 2; [EOL]     final char[] buf = buffer; [EOL]     for (int leftIdx = 0, rightIdx = size - 1; leftIdx < half; leftIdx++, rightIdx--) { [EOL]         final char swap = buf[leftIdx]; [EOL]         buf[leftIdx] = buf[rightIdx]; [EOL]         buf[rightIdx] = swap; [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] return this; [LINE] public StrBuilder trim() { [EOL]     if (size == 0) { [EOL]         return this; [EOL]     } [EOL]     int len = size; [EOL]     final char[] buf = buffer; [EOL]     int pos = 0; [EOL]     while (pos < len && buf[pos] <= ' ') { [EOL]         pos++; [EOL]     } [EOL]     while (pos < len && buf[len - 1] <= ' ') { [EOL]         len--; [EOL]     } [EOL]     if (len < size) { [EOL]         delete(len, size); [EOL]     } [EOL]     if (pos > 0) { [EOL]         delete(0, pos); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] return true; [LINE] public boolean startsWith(final String str) { [EOL]     if (str == null) { [EOL]         return false; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return true; [EOL]     } [EOL]     if (len > size) { [EOL]         return false; [EOL]     } [EOL]     for (int i = 0; i < len; i++) { [EOL]         if (buffer[i] != str.charAt(i)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] return false; [LINE] public boolean endsWith(final String str) { [EOL]     if (str == null) { [EOL]         return false; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return true; [EOL]     } [EOL]     if (len > size) { [EOL]         return false; [EOL]     } [EOL]     int pos = size - len; [EOL]     for (int i = 0; i < len; i++, pos++) { [EOL]         if (buffer[pos] != str.charAt(i)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] if (endIndex > size) { [LINE] @Override [EOL] public CharSequence subSequence(final int startIndex, final int endIndex) { [EOL]     if (startIndex < 0) { [EOL]         throw new StringIndexOutOfBoundsException(startIndex); [EOL]     } [EOL]     if (endIndex > size) { [EOL]         throw new StringIndexOutOfBoundsException(endIndex); [EOL]     } [EOL]     if (startIndex > endIndex) { [EOL]         throw new StringIndexOutOfBoundsException(endIndex - startIndex); [EOL]     } [EOL]     return substring(startIndex, endIndex); [EOL] } 
 [LINE] throw new StringIndexOutOfBoundsException(endIndex - startIndex); [LINE] @Override [EOL] public CharSequence subSequence(final int startIndex, final int endIndex) { [EOL]     if (startIndex < 0) { [EOL]         throw new StringIndexOutOfBoundsException(startIndex); [EOL]     } [EOL]     if (endIndex > size) { [EOL]         throw new StringIndexOutOfBoundsException(endIndex); [EOL]     } [EOL]     if (startIndex > endIndex) { [EOL]         throw new StringIndexOutOfBoundsException(endIndex - startIndex); [EOL]     } [EOL]     return substring(startIndex, endIndex); [EOL] } 
 [LINE] return new String(buffer, 0, size); [LINE] public String leftString(final int length) { [EOL]     if (length <= 0) { [EOL]         return ""; [EOL]     } else if (length >= size) { [EOL]         return new String(buffer, 0, size); [EOL]     } else { [EOL]         return new String(buffer, 0, length); [EOL]     } [EOL] } 
 [LINE] return ""; [LINE] public String rightString(final int length) { [EOL]     if (length <= 0) { [EOL]         return ""; [EOL]     } else if (length >= size) { [EOL]         return new String(buffer, 0, size); [EOL]     } else { [EOL]         return new String(buffer, size - length, length); [EOL]     } [EOL] } 
 [LINE] if (length <= 0 || index >= size) { [LINE] public String midString(int index, final int length) { [EOL]     if (index < 0) { [EOL]         index = 0; [EOL]     } [EOL]     if (length <= 0 || index >= size) { [EOL]         return ""; [EOL]     } [EOL]     if (size <= index + length) { [EOL]         return new String(buffer, index, size - index); [EOL]     } [EOL]     return new String(buffer, index, length); [EOL] } 
 [LINE] return new String(buffer, index, length); [LINE] public String midString(int index, final int length) { [EOL]     if (index < 0) { [EOL]         index = 0; [EOL]     } [EOL]     if (length <= 0 || index >= size) { [EOL]         return ""; [EOL]     } [EOL]     if (size <= index + length) { [EOL]         return new String(buffer, index, size - index); [EOL]     } [EOL]     return new String(buffer, index, length); [EOL] } 
 [LINE] if (thisBuf[i] == ch) { [LINE] public int indexOf(final char ch, int startIndex) { [EOL]     startIndex = (startIndex < 0 ? 0 : startIndex); [EOL]     if (startIndex >= size) { [EOL]         return -1; [EOL]     } [EOL]     final char[] thisBuf = buffer; [EOL]     for (int i = startIndex; i < size; i++) { [EOL]         if (thisBuf[i] == ch) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return -1; [EOL] } 
 [LINE] startIndex = (startIndex < 0 ? 0 : startIndex); [LINE] public int indexOf(final String str, int startIndex) { [EOL]     startIndex = (startIndex < 0 ? 0 : startIndex); [EOL]     if (str == null || startIndex >= size) { [EOL]         return -1; [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     if (strLen == 1) { [EOL]         return indexOf(str.charAt(0), startIndex); [EOL]     } [EOL]     if (strLen == 0) { [EOL]         return startIndex; [EOL]     } [EOL]     if (strLen > size) { [EOL]         return -1; [EOL]     } [EOL]     final char[] thisBuf = buffer; [EOL]     final int len = size - strLen + 1; [EOL]     outer: for (int i = startIndex; i < len; i++) { [EOL]         for (int j = 0; j < strLen; j++) { [EOL]             if (str.charAt(j) != thisBuf[i + j]) { [EOL]                 continue outer; [EOL]             } [EOL]         } [EOL]         return i; [EOL]     } [EOL]     return -1; [EOL] } 
 [LINE] return -1; [LINE] public int indexOf(final String str, int startIndex) { [EOL]     startIndex = (startIndex < 0 ? 0 : startIndex); [EOL]     if (str == null || startIndex >= size) { [EOL]         return -1; [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     if (strLen == 1) { [EOL]         return indexOf(str.charAt(0), startIndex); [EOL]     } [EOL]     if (strLen == 0) { [EOL]         return startIndex; [EOL]     } [EOL]     if (strLen > size) { [EOL]         return -1; [EOL]     } [EOL]     final char[] thisBuf = buffer; [EOL]     final int len = size - strLen + 1; [EOL]     outer: for (int i = startIndex; i < len; i++) { [EOL]         for (int j = 0; j < strLen; j++) { [EOL]             if (str.charAt(j) != thisBuf[i + j]) { [EOL]                 continue outer; [EOL]             } [EOL]         } [EOL]         return i; [EOL]     } [EOL]     return -1; [EOL] } 
 [LINE] final int strLen = str.length(); [LINE] public int indexOf(final String str, int startIndex) { [EOL]     startIndex = (startIndex < 0 ? 0 : startIndex); [EOL]     if (str == null || startIndex >= size) { [EOL]         return -1; [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     if (strLen == 1) { [EOL]         return indexOf(str.charAt(0), startIndex); [EOL]     } [EOL]     if (strLen == 0) { [EOL]         return startIndex; [EOL]     } [EOL]     if (strLen > size) { [EOL]         return -1; [EOL]     } [EOL]     final char[] thisBuf = buffer; [EOL]     final int len = size - strLen + 1; [EOL]     outer: for (int i = startIndex; i < len; i++) { [EOL]         for (int j = 0; j < strLen; j++) { [EOL]             if (str.charAt(j) != thisBuf[i + j]) { [EOL]                 continue outer; [EOL]             } [EOL]         } [EOL]         return i; [EOL]     } [EOL]     return -1; [EOL] } 
 [LINE] return -1; [LINE] public int indexOf(final String str, int startIndex) { [EOL]     startIndex = (startIndex < 0 ? 0 : startIndex); [EOL]     if (str == null || startIndex >= size) { [EOL]         return -1; [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     if (strLen == 1) { [EOL]         return indexOf(str.charAt(0), startIndex); [EOL]     } [EOL]     if (strLen == 0) { [EOL]         return startIndex; [EOL]     } [EOL]     if (strLen > size) { [EOL]         return -1; [EOL]     } [EOL]     final char[] thisBuf = buffer; [EOL]     final int len = size - strLen + 1; [EOL]     outer: for (int i = startIndex; i < len; i++) { [EOL]         for (int j = 0; j < strLen; j++) { [EOL]             if (str.charAt(j) != thisBuf[i + j]) { [EOL]                 continue outer; [EOL]             } [EOL]         } [EOL]         return i; [EOL]     } [EOL]     return -1; [EOL] } 
 [LINE] return -1; [LINE] public int indexOf(final StrMatcher matcher, int startIndex) { [EOL]     startIndex = (startIndex < 0 ? 0 : startIndex); [EOL]     if (matcher == null || startIndex >= size) { [EOL]         return -1; [EOL]     } [EOL]     final int len = size; [EOL]     final char[] buf = buffer; [EOL]     for (int i = startIndex; i < len; i++) { [EOL]         if (matcher.isMatch(buf, i, startIndex, len) > 0) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return -1; [EOL] } 
 [LINE] return i; [LINE] public int lastIndexOf(final char ch, int startIndex) { [EOL]     startIndex = (startIndex >= size ? size - 1 : startIndex); [EOL]     if (startIndex < 0) { [EOL]         return -1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (buffer[i] == ch) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return -1; [EOL] } 
 [LINE] startIndex = (startIndex >= size ? size - 1 : startIndex); [LINE] public int lastIndexOf(final String str, int startIndex) { [EOL]     startIndex = (startIndex >= size ? size - 1 : startIndex); [EOL]     if (str == null || startIndex < 0) { [EOL]         return -1; [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     if (strLen > 0 && strLen <= size) { [EOL]         if (strLen == 1) { [EOL]             return lastIndexOf(str.charAt(0), startIndex); [EOL]         } [EOL]         outer: for (int i = startIndex - strLen + 1; i >= 0; i--) { [EOL]             for (int j = 0; j < strLen; j++) { [EOL]                 if (str.charAt(j) != buffer[i + j]) { [EOL]                     continue outer; [EOL]                 } [EOL]             } [EOL]             return i; [EOL]         } [EOL]     } else if (strLen == 0) { [EOL]         return startIndex; [EOL]     } [EOL]     return -1; [EOL] } 
 [LINE] return lastIndexOf(str.charAt(0), startIndex); [LINE] public int lastIndexOf(final String str, int startIndex) { [EOL]     startIndex = (startIndex >= size ? size - 1 : startIndex); [EOL]     if (str == null || startIndex < 0) { [EOL]         return -1; [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     if (strLen > 0 && strLen <= size) { [EOL]         if (strLen == 1) { [EOL]             return lastIndexOf(str.charAt(0), startIndex); [EOL]         } [EOL]         outer: for (int i = startIndex - strLen + 1; i >= 0; i--) { [EOL]             for (int j = 0; j < strLen; j++) { [EOL]                 if (str.charAt(j) != buffer[i + j]) { [EOL]                     continue outer; [EOL]                 } [EOL]             } [EOL]             return i; [EOL]         } [EOL]     } else if (strLen == 0) { [EOL]         return startIndex; [EOL]     } [EOL]     return -1; [EOL] } 
 [LINE] for (int i = startIndex - strLen + 1; i >= 0; i--) { [LINE] public int lastIndexOf(final String str, int startIndex) { [EOL]     startIndex = (startIndex >= size ? size - 1 : startIndex); [EOL]     if (str == null || startIndex < 0) { [EOL]         return -1; [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     if (strLen > 0 && strLen <= size) { [EOL]         if (strLen == 1) { [EOL]             return lastIndexOf(str.charAt(0), startIndex); [EOL]         } [EOL]         outer: for (int i = startIndex - strLen + 1; i >= 0; i--) { [EOL]             for (int j = 0; j < strLen; j++) { [EOL]                 if (str.charAt(j) != buffer[i + j]) { [EOL]                     continue outer; [EOL]                 } [EOL]             } [EOL]             return i; [EOL]         } [EOL]     } else if (strLen == 0) { [EOL]         return startIndex; [EOL]     } [EOL]     return -1; [EOL] } 
 [LINE] return i; [LINE] public int lastIndexOf(final StrMatcher matcher, int startIndex) { [EOL]     startIndex = (startIndex >= size ? size - 1 : startIndex); [EOL]     if (matcher == null || startIndex < 0) { [EOL]         return -1; [EOL]     } [EOL]     final char[] buf = buffer; [EOL]     final int endIndex = startIndex + 1; [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (matcher.isMatch(buf, i, 0, endIndex) > 0) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return -1; [EOL] } 
 [LINE] return true; [LINE] public boolean equals(final StrBuilder other) { [EOL]     if (this == other) { [EOL]         return true; [EOL]     } [EOL]     if (this.size != other.size) { [EOL]         return false; [EOL]     } [EOL]     final char[] thisBuf = this.buffer; [EOL]     final char[] otherBuf = other.buffer; [EOL]     for (int i = size - 1; i >= 0; i--) { [EOL]         if (thisBuf[i] != otherBuf[i]) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] int hash = 0; [LINE] @Override [EOL] public int hashCode() { [EOL]     final char[] buf = buffer; [EOL]     int hash = 0; [EOL]     for (int i = size - 1; i >= 0; i--) { [EOL]         hash = 31 * hash + buf[i]; [EOL]     } [EOL]     return hash; [EOL] } 
 [LINE] @Override [LINE] @Override [EOL] public int hashCode() { [EOL]     final char[] buf = buffer; [EOL]     int hash = 0; [EOL]     for (int i = size - 1; i >= 0; i--) { [EOL]         hash = 31 * hash + buf[i]; [EOL]     } [EOL]     return hash; [EOL] } 
 [LINE] return new String(buffer, 0, size); [LINE] @Override [EOL] public String toString() { [EOL]     return new String(buffer, 0, size); [EOL] } 
 [LINE] return toString(); [LINE] @Override [EOL] public String build() { [EOL]     return toString(); [EOL] } 
 [LINE] if (startIndex < 0) { [LINE] protected int validateRange(final int startIndex, int endIndex) { [EOL]     if (startIndex < 0) { [EOL]         throw new StringIndexOutOfBoundsException(startIndex); [EOL]     } [EOL]     if (endIndex > size) { [EOL]         endIndex = size; [EOL]     } [EOL]     if (startIndex > endIndex) { [EOL]         throw new StringIndexOutOfBoundsException("end < start"); [EOL]     } [EOL]     return endIndex; [EOL] } 
 [LINE] if (index < 0 || index > size) { [LINE] protected void validateIndex(final int index) { [EOL]     if (index < 0 || index > size) { [EOL]         throw new StringIndexOutOfBoundsException(index); [EOL]     } [EOL] } 
 [LINE] return super.tokenize(StrBuilder.this.buffer, 0, StrBuilder.this.size()); [LINE] @Override [EOL] protected List<String> tokenize(final char[] chars, final int offset, final int count) { [EOL]     if (chars == null) { [EOL]         return super.tokenize(StrBuilder.this.buffer, 0, StrBuilder.this.size()); [EOL]     } [EOL]     return super.tokenize(chars, offset, count); [EOL] } 
 [LINE] @Override [LINE] @Override [EOL] public void close() { [EOL] } 
 [LINE] if (ready() == false) { [LINE] @Override [EOL] public int read() { [EOL]     if (ready() == false) { [EOL]         return -1; [EOL]     } [EOL]     return StrBuilder.this.charAt(pos++); [EOL] } 
 [LINE] return -1; [LINE] @Override [EOL] public int read(final char[] b, final int off, int len) { [EOL]     if (off < 0 || len < 0 || off > b.length || (off + len) > b.length || (off + len) < 0) { [EOL]         throw new IndexOutOfBoundsException(); [EOL]     } [EOL]     if (len == 0) { [EOL]         return 0; [EOL]     } [EOL]     if (pos >= StrBuilder.this.size()) { [EOL]         return -1; [EOL]     } [EOL]     if (pos + len > size()) { [EOL]         len = StrBuilder.this.size() - pos; [EOL]     } [EOL]     StrBuilder.this.getChars(pos, pos + len, b, off); [EOL]     pos += len; [EOL]     return len; [EOL] } 
 [LINE] return 0; [LINE] @Override [EOL] public long skip(long n) { [EOL]     if (pos + n > StrBuilder.this.size()) { [EOL]         n = StrBuilder.this.size() - pos; [EOL]     } [EOL]     if (n < 0) { [EOL]         return 0; [EOL]     } [EOL]     pos += n; [EOL]     return n; [EOL] } 
 [LINE] @Override [LINE] @Override [EOL] public void write(final char[] cbuf) { [EOL]     StrBuilder.this.append(cbuf); [EOL] } 
 [LINE] StrBuilder.this.append(str); [LINE] @Override [EOL] public void write(final String str) { [EOL]     StrBuilder.this.append(str); [EOL] } 
lang3/exception/ContextedRuntimeException.java
 [LINE] @Override [LINE] @Override [EOL] public ContextedRuntimeException setContextValue(final String label, final Object value) { [EOL]     exceptionContext.setContextValue(label, value); [EOL]     return this; [EOL] } 
lang3/mutable/MutableFloat.java
 [LINE] @Override [LINE] public void setValue(final float value) { [EOL]     this.value = value; [EOL] } 
 [LINE] this.value -= operand.floatValue(); [LINE] public void subtract(final Number operand) { [EOL]     this.value -= operand.floatValue(); [EOL] } 
 [LINE] @Override [LINE] public void subtract(final Number operand) { [EOL]     this.value -= operand.floatValue(); [EOL] } 
 [LINE] final float anotherVal = other.value; [LINE] @Override [EOL] public int compareTo(final MutableFloat other) { [EOL]     final float anotherVal = other.value; [EOL]     return Float.compare(value, anotherVal); [EOL] } 
 [LINE] @Override [LINE] @Override [EOL] public int compareTo(final MutableFloat other) { [EOL]     final float anotherVal = other.value; [EOL]     return Float.compare(value, anotherVal); [EOL] } 
lang3/text/StrSubstitutor.java
 [LINE] return new StrSubstitutor(valueMap, prefix, suffix).replace(source); [LINE] public static <V> String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix) { [EOL]     return new StrSubstitutor(valueMap, prefix, suffix).replace(source); [EOL] } 
 [LINE] if (valueProperties == null) { [LINE] public static String replace(final Object source, final Properties valueProperties) { [EOL]     if (valueProperties == null) { [EOL]         return source.toString(); [EOL]     } [EOL]     final Map<String, String> valueMap = new HashMap<String, String>(); [EOL]     final Enumeration<?> propNames = valueProperties.propertyNames(); [EOL]     while (propNames.hasMoreElements()) { [EOL]         final String propName = (String) propNames.nextElement(); [EOL]         final String propValue = valueProperties.getProperty(propName); [EOL]         valueMap.put(propName, propValue); [EOL]     } [EOL]     return StrSubstitutor.replace(source, valueMap); [EOL] } 
 [LINE] final Enumeration<?> propNames = valueProperties.propertyNames(); [LINE] public static String replace(final Object source, final Properties valueProperties) { [EOL]     if (valueProperties == null) { [EOL]         return source.toString(); [EOL]     } [EOL]     final Map<String, String> valueMap = new HashMap<String, String>(); [EOL]     final Enumeration<?> propNames = valueProperties.propertyNames(); [EOL]     while (propNames.hasMoreElements()) { [EOL]         final String propName = (String) propNames.nextElement(); [EOL]         final String propValue = valueProperties.getProperty(propName); [EOL]         valueMap.put(propName, propValue); [EOL]     } [EOL]     return StrSubstitutor.replace(source, valueMap); [EOL] } 
 [LINE] return source.substring(offset, offset + length); [LINE] public String replace(final String source, final int offset, final int length) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(length).append(source, offset, length); [EOL]     if (substitute(buf, 0, length) == false) { [EOL]         return source.substring(offset, offset + length); [EOL]     } [EOL]     return buf.toString(); [EOL] } 
 [LINE] if (source == null) { [LINE] public String replace(final char[] source) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(source.length).append(source); [EOL]     substitute(buf, 0, source.length); [EOL]     return buf.toString(); [EOL] } 
 [LINE] final StrBuilder buf = new StrBuilder(source.length).append(source); [LINE] public String replace(final char[] source) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(source.length).append(source); [EOL]     substitute(buf, 0, source.length); [EOL]     return buf.toString(); [EOL] } 
 [LINE] substitute(buf, 0, source.length); [LINE] public String replace(final char[] source) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(source.length).append(source); [EOL]     substitute(buf, 0, source.length); [EOL]     return buf.toString(); [EOL] } 
 [LINE] if (source == null) { [LINE] public String replace(final char[] source, final int offset, final int length) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(length).append(source, offset, length); [EOL]     substitute(buf, 0, length); [EOL]     return buf.toString(); [EOL] } 
 [LINE] if (source == null) { [LINE] public String replace(final StringBuffer source) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(source.length()).append(source); [EOL]     substitute(buf, 0, buf.length()); [EOL]     return buf.toString(); [EOL] } 
 [LINE] substitute(buf, 0, length); [LINE] public String replace(final StringBuffer source, final int offset, final int length) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(length).append(source, offset, length); [EOL]     substitute(buf, 0, length); [EOL]     return buf.toString(); [EOL] } 
 [LINE] if (source == null) { [LINE] public String replace(CharSequence source) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     return replace(source, 0, source.length()); [EOL] } 
 [LINE] return replace(source, 0, source.length()); [LINE] public String replace(CharSequence source) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     return replace(source, 0, source.length()); [EOL] } 
 [LINE] if (source == null) { [LINE] public String replace(final StrBuilder source, final int offset, final int length) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(length).append(source, offset, length); [EOL]     substitute(buf, 0, length); [EOL]     return buf.toString(); [EOL] } 
 [LINE] if (source == null) { [LINE] public String replace(final Object source) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder().append(source); [EOL]     substitute(buf, 0, buf.length()); [EOL]     return buf.toString(); [EOL] } 
 [LINE] return false; [LINE] public boolean replaceIn(final StringBuffer source) { [EOL]     if (source == null) { [EOL]         return false; [EOL]     } [EOL]     return replaceIn(source, 0, source.length()); [EOL] } 
 [LINE] if (source == null) { [LINE] public boolean replaceIn(final StringBuffer source, final int offset, final int length) { [EOL]     if (source == null) { [EOL]         return false; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(length).append(source, offset, length); [EOL]     if (substitute(buf, 0, length) == false) { [EOL]         return false; [EOL]     } [EOL]     source.replace(offset, offset + length, buf.toString()); [EOL]     return true; [EOL] } 
 [LINE] if (source == null) { [LINE] public boolean replaceIn(StringBuilder source, int offset, int length) { [EOL]     if (source == null) { [EOL]         return false; [EOL]     } [EOL]     StrBuilder buf = new StrBuilder(length).append(source, offset, length); [EOL]     if (substitute(buf, 0, length) == false) { [EOL]         return false; [EOL]     } [EOL]     source.replace(offset, offset + length, buf.toString()); [EOL]     return true; [EOL] } 
 [LINE] return substitute(buf, offset, length, null) > 0; [LINE] protected boolean substitute(final StrBuilder buf, final int offset, final int length) { [EOL]     return substitute(buf, offset, length, null) > 0; [EOL] } 
 [LINE] boolean altered = false; [LINE] private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables) { [EOL]     final StrMatcher prefixMatcher = getVariablePrefixMatcher(); [EOL]     final StrMatcher suffixMatcher = getVariableSuffixMatcher(); [EOL]     final char escape = getEscapeChar(); [EOL]     final boolean top = priorVariables == null; [EOL]     boolean altered = false; [EOL]     int lengthChange = 0; [EOL]     char[] chars = buf.buffer; [EOL]     int bufEnd = offset + length; [EOL]     int pos = offset; [EOL]     while (pos < bufEnd) { [EOL]         final int startMatchLen = prefixMatcher.isMatch(chars, pos, offset, bufEnd); [EOL]         if (startMatchLen == 0) { [EOL]             pos++; [EOL]         } else { [EOL]             if (pos > offset && chars[pos - 1] == escape) { [EOL]                 buf.deleteCharAt(pos - 1); [EOL]                 chars = buf.buffer; [EOL]                 lengthChange--; [EOL]                 altered = true; [EOL]                 bufEnd--; [EOL]             } else { [EOL]                 final int startPos = pos; [EOL]                 pos += startMatchLen; [EOL]                 int endMatchLen = 0; [EOL]                 int nestedVarCount = 0; [EOL]                 while (pos < bufEnd) { [EOL]                     if (isEnableSubstitutionInVariables() && (endMatchLen = prefixMatcher.isMatch(chars, pos, offset, bufEnd)) != 0) { [EOL]                         nestedVarCount++; [EOL]                         pos += endMatchLen; [EOL]                         continue; [EOL]                     } [EOL]                     endMatchLen = suffixMatcher.isMatch(chars, pos, offset, bufEnd); [EOL]                     if (endMatchLen == 0) { [EOL]                         pos++; [EOL]                     } else { [EOL]                         if (nestedVarCount == 0) { [EOL]                             String varName = new String(chars, startPos + startMatchLen, pos - startPos - startMatchLen); [EOL]                             if (isEnableSubstitutionInVariables()) { [EOL]                                 final StrBuilder bufName = new StrBuilder(varName); [EOL]                                 substitute(bufName, 0, bufName.length()); [EOL]                                 varName = bufName.toString(); [EOL]                             } [EOL]                             pos += endMatchLen; [EOL]                             final int endPos = pos; [EOL]                             if (priorVariables == null) { [EOL]                                 priorVariables = new ArrayList<String>(); [EOL]                                 priorVariables.add(new String(chars, offset, length)); [EOL]                             } [EOL]                             checkCyclicSubstitution(varName, priorVariables); [EOL]                             priorVariables.add(varName); [EOL]                             final String varValue = resolveVariable(varName, buf, startPos, endPos); [EOL]                             if (varValue != null) { [EOL]                                 final int varLen = varValue.length(); [EOL]                                 buf.replace(startPos, endPos, varValue); [EOL]                                 altered = true; [EOL]                                 int change = substitute(buf, startPos, varLen, priorVariables); [EOL]                                 change = change + varLen - (endPos - startPos); [EOL]                                 pos += change; [EOL]                                 bufEnd += change; [EOL]                                 lengthChange += change; [EOL]                                 chars = buf.buffer; [EOL]                             } [EOL]                             priorVariables.remove(priorVariables.size() - 1); [EOL]                             break; [EOL]                         } else { [EOL]                             nestedVarCount--; [EOL]                             pos += endMatchLen; [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (top) { [EOL]         return altered ? 1 : 0; [EOL]     } [EOL]     return lengthChange; [EOL] } 
 [LINE] while (pos < bufEnd) { [LINE] private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables) { [EOL]     final StrMatcher prefixMatcher = getVariablePrefixMatcher(); [EOL]     final StrMatcher suffixMatcher = getVariableSuffixMatcher(); [EOL]     final char escape = getEscapeChar(); [EOL]     final boolean top = priorVariables == null; [EOL]     boolean altered = false; [EOL]     int lengthChange = 0; [EOL]     char[] chars = buf.buffer; [EOL]     int bufEnd = offset + length; [EOL]     int pos = offset; [EOL]     while (pos < bufEnd) { [EOL]         final int startMatchLen = prefixMatcher.isMatch(chars, pos, offset, bufEnd); [EOL]         if (startMatchLen == 0) { [EOL]             pos++; [EOL]         } else { [EOL]             if (pos > offset && chars[pos - 1] == escape) { [EOL]                 buf.deleteCharAt(pos - 1); [EOL]                 chars = buf.buffer; [EOL]                 lengthChange--; [EOL]                 altered = true; [EOL]                 bufEnd--; [EOL]             } else { [EOL]                 final int startPos = pos; [EOL]                 pos += startMatchLen; [EOL]                 int endMatchLen = 0; [EOL]                 int nestedVarCount = 0; [EOL]                 while (pos < bufEnd) { [EOL]                     if (isEnableSubstitutionInVariables() && (endMatchLen = prefixMatcher.isMatch(chars, pos, offset, bufEnd)) != 0) { [EOL]                         nestedVarCount++; [EOL]                         pos += endMatchLen; [EOL]                         continue; [EOL]                     } [EOL]                     endMatchLen = suffixMatcher.isMatch(chars, pos, offset, bufEnd); [EOL]                     if (endMatchLen == 0) { [EOL]                         pos++; [EOL]                     } else { [EOL]                         if (nestedVarCount == 0) { [EOL]                             String varName = new String(chars, startPos + startMatchLen, pos - startPos - startMatchLen); [EOL]                             if (isEnableSubstitutionInVariables()) { [EOL]                                 final StrBuilder bufName = new StrBuilder(varName); [EOL]                                 substitute(bufName, 0, bufName.length()); [EOL]                                 varName = bufName.toString(); [EOL]                             } [EOL]                             pos += endMatchLen; [EOL]                             final int endPos = pos; [EOL]                             if (priorVariables == null) { [EOL]                                 priorVariables = new ArrayList<String>(); [EOL]                                 priorVariables.add(new String(chars, offset, length)); [EOL]                             } [EOL]                             checkCyclicSubstitution(varName, priorVariables); [EOL]                             priorVariables.add(varName); [EOL]                             final String varValue = resolveVariable(varName, buf, startPos, endPos); [EOL]                             if (varValue != null) { [EOL]                                 final int varLen = varValue.length(); [EOL]                                 buf.replace(startPos, endPos, varValue); [EOL]                                 altered = true; [EOL]                                 int change = substitute(buf, startPos, varLen, priorVariables); [EOL]                                 change = change + varLen - (endPos - startPos); [EOL]                                 pos += change; [EOL]                                 bufEnd += change; [EOL]                                 lengthChange += change; [EOL]                                 chars = buf.buffer; [EOL]                             } [EOL]                             priorVariables.remove(priorVariables.size() - 1); [EOL]                             break; [EOL]                         } else { [EOL]                             nestedVarCount--; [EOL]                             pos += endMatchLen; [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (top) { [EOL]         return altered ? 1 : 0; [EOL]     } [EOL]     return lengthChange; [EOL] } 
 [LINE] buf.deleteCharAt(pos - 1); [LINE] private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables) { [EOL]     final StrMatcher prefixMatcher = getVariablePrefixMatcher(); [EOL]     final StrMatcher suffixMatcher = getVariableSuffixMatcher(); [EOL]     final char escape = getEscapeChar(); [EOL]     final boolean top = priorVariables == null; [EOL]     boolean altered = false; [EOL]     int lengthChange = 0; [EOL]     char[] chars = buf.buffer; [EOL]     int bufEnd = offset + length; [EOL]     int pos = offset; [EOL]     while (pos < bufEnd) { [EOL]         final int startMatchLen = prefixMatcher.isMatch(chars, pos, offset, bufEnd); [EOL]         if (startMatchLen == 0) { [EOL]             pos++; [EOL]         } else { [EOL]             if (pos > offset && chars[pos - 1] == escape) { [EOL]                 buf.deleteCharAt(pos - 1); [EOL]                 chars = buf.buffer; [EOL]                 lengthChange--; [EOL]                 altered = true; [EOL]                 bufEnd--; [EOL]             } else { [EOL]                 final int startPos = pos; [EOL]                 pos += startMatchLen; [EOL]                 int endMatchLen = 0; [EOL]                 int nestedVarCount = 0; [EOL]                 while (pos < bufEnd) { [EOL]                     if (isEnableSubstitutionInVariables() && (endMatchLen = prefixMatcher.isMatch(chars, pos, offset, bufEnd)) != 0) { [EOL]                         nestedVarCount++; [EOL]                         pos += endMatchLen; [EOL]                         continue; [EOL]                     } [EOL]                     endMatchLen = suffixMatcher.isMatch(chars, pos, offset, bufEnd); [EOL]                     if (endMatchLen == 0) { [EOL]                         pos++; [EOL]                     } else { [EOL]                         if (nestedVarCount == 0) { [EOL]                             String varName = new String(chars, startPos + startMatchLen, pos - startPos - startMatchLen); [EOL]                             if (isEnableSubstitutionInVariables()) { [EOL]                                 final StrBuilder bufName = new StrBuilder(varName); [EOL]                                 substitute(bufName, 0, bufName.length()); [EOL]                                 varName = bufName.toString(); [EOL]                             } [EOL]                             pos += endMatchLen; [EOL]                             final int endPos = pos; [EOL]                             if (priorVariables == null) { [EOL]                                 priorVariables = new ArrayList<String>(); [EOL]                                 priorVariables.add(new String(chars, offset, length)); [EOL]                             } [EOL]                             checkCyclicSubstitution(varName, priorVariables); [EOL]                             priorVariables.add(varName); [EOL]                             final String varValue = resolveVariable(varName, buf, startPos, endPos); [EOL]                             if (varValue != null) { [EOL]                                 final int varLen = varValue.length(); [EOL]                                 buf.replace(startPos, endPos, varValue); [EOL]                                 altered = true; [EOL]                                 int change = substitute(buf, startPos, varLen, priorVariables); [EOL]                                 change = change + varLen - (endPos - startPos); [EOL]                                 pos += change; [EOL]                                 bufEnd += change; [EOL]                                 lengthChange += change; [EOL]                                 chars = buf.buffer; [EOL]                             } [EOL]                             priorVariables.remove(priorVariables.size() - 1); [EOL]                             break; [EOL]                         } else { [EOL]                             nestedVarCount--; [EOL]                             pos += endMatchLen; [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (top) { [EOL]         return altered ? 1 : 0; [EOL]     } [EOL]     return lengthChange; [EOL] } 
 [LINE] altered = true; [LINE] private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables) { [EOL]     final StrMatcher prefixMatcher = getVariablePrefixMatcher(); [EOL]     final StrMatcher suffixMatcher = getVariableSuffixMatcher(); [EOL]     final char escape = getEscapeChar(); [EOL]     final boolean top = priorVariables == null; [EOL]     boolean altered = false; [EOL]     int lengthChange = 0; [EOL]     char[] chars = buf.buffer; [EOL]     int bufEnd = offset + length; [EOL]     int pos = offset; [EOL]     while (pos < bufEnd) { [EOL]         final int startMatchLen = prefixMatcher.isMatch(chars, pos, offset, bufEnd); [EOL]         if (startMatchLen == 0) { [EOL]             pos++; [EOL]         } else { [EOL]             if (pos > offset && chars[pos - 1] == escape) { [EOL]                 buf.deleteCharAt(pos - 1); [EOL]                 chars = buf.buffer; [EOL]                 lengthChange--; [EOL]                 altered = true; [EOL]                 bufEnd--; [EOL]             } else { [EOL]                 final int startPos = pos; [EOL]                 pos += startMatchLen; [EOL]                 int endMatchLen = 0; [EOL]                 int nestedVarCount = 0; [EOL]                 while (pos < bufEnd) { [EOL]                     if (isEnableSubstitutionInVariables() && (endMatchLen = prefixMatcher.isMatch(chars, pos, offset, bufEnd)) != 0) { [EOL]                         nestedVarCount++; [EOL]                         pos += endMatchLen; [EOL]                         continue; [EOL]                     } [EOL]                     endMatchLen = suffixMatcher.isMatch(chars, pos, offset, bufEnd); [EOL]                     if (endMatchLen == 0) { [EOL]                         pos++; [EOL]                     } else { [EOL]                         if (nestedVarCount == 0) { [EOL]                             String varName = new String(chars, startPos + startMatchLen, pos - startPos - startMatchLen); [EOL]                             if (isEnableSubstitutionInVariables()) { [EOL]                                 final StrBuilder bufName = new StrBuilder(varName); [EOL]                                 substitute(bufName, 0, bufName.length()); [EOL]                                 varName = bufName.toString(); [EOL]                             } [EOL]                             pos += endMatchLen; [EOL]                             final int endPos = pos; [EOL]                             if (priorVariables == null) { [EOL]                                 priorVariables = new ArrayList<String>(); [EOL]                                 priorVariables.add(new String(chars, offset, length)); [EOL]                             } [EOL]                             checkCyclicSubstitution(varName, priorVariables); [EOL]                             priorVariables.add(varName); [EOL]                             final String varValue = resolveVariable(varName, buf, startPos, endPos); [EOL]                             if (varValue != null) { [EOL]                                 final int varLen = varValue.length(); [EOL]                                 buf.replace(startPos, endPos, varValue); [EOL]                                 altered = true; [EOL]                                 int change = substitute(buf, startPos, varLen, priorVariables); [EOL]                                 change = change + varLen - (endPos - startPos); [EOL]                                 pos += change; [EOL]                                 bufEnd += change; [EOL]                                 lengthChange += change; [EOL]                                 chars = buf.buffer; [EOL]                             } [EOL]                             priorVariables.remove(priorVariables.size() - 1); [EOL]                             break; [EOL]                         } else { [EOL]                             nestedVarCount--; [EOL]                             pos += endMatchLen; [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (top) { [EOL]         return altered ? 1 : 0; [EOL]     } [EOL]     return lengthChange; [EOL] } 
 [LINE] bufEnd--; [LINE] private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables) { [EOL]     final StrMatcher prefixMatcher = getVariablePrefixMatcher(); [EOL]     final StrMatcher suffixMatcher = getVariableSuffixMatcher(); [EOL]     final char escape = getEscapeChar(); [EOL]     final boolean top = priorVariables == null; [EOL]     boolean altered = false; [EOL]     int lengthChange = 0; [EOL]     char[] chars = buf.buffer; [EOL]     int bufEnd = offset + length; [EOL]     int pos = offset; [EOL]     while (pos < bufEnd) { [EOL]         final int startMatchLen = prefixMatcher.isMatch(chars, pos, offset, bufEnd); [EOL]         if (startMatchLen == 0) { [EOL]             pos++; [EOL]         } else { [EOL]             if (pos > offset && chars[pos - 1] == escape) { [EOL]                 buf.deleteCharAt(pos - 1); [EOL]                 chars = buf.buffer; [EOL]                 lengthChange--; [EOL]                 altered = true; [EOL]                 bufEnd--; [EOL]             } else { [EOL]                 final int startPos = pos; [EOL]                 pos += startMatchLen; [EOL]                 int endMatchLen = 0; [EOL]                 int nestedVarCount = 0; [EOL]                 while (pos < bufEnd) { [EOL]                     if (isEnableSubstitutionInVariables() && (endMatchLen = prefixMatcher.isMatch(chars, pos, offset, bufEnd)) != 0) { [EOL]                         nestedVarCount++; [EOL]                         pos += endMatchLen; [EOL]                         continue; [EOL]                     } [EOL]                     endMatchLen = suffixMatcher.isMatch(chars, pos, offset, bufEnd); [EOL]                     if (endMatchLen == 0) { [EOL]                         pos++; [EOL]                     } else { [EOL]                         if (nestedVarCount == 0) { [EOL]                             String varName = new String(chars, startPos + startMatchLen, pos - startPos - startMatchLen); [EOL]                             if (isEnableSubstitutionInVariables()) { [EOL]                                 final StrBuilder bufName = new StrBuilder(varName); [EOL]                                 substitute(bufName, 0, bufName.length()); [EOL]                                 varName = bufName.toString(); [EOL]                             } [EOL]                             pos += endMatchLen; [EOL]                             final int endPos = pos; [EOL]                             if (priorVariables == null) { [EOL]                                 priorVariables = new ArrayList<String>(); [EOL]                                 priorVariables.add(new String(chars, offset, length)); [EOL]                             } [EOL]                             checkCyclicSubstitution(varName, priorVariables); [EOL]                             priorVariables.add(varName); [EOL]                             final String varValue = resolveVariable(varName, buf, startPos, endPos); [EOL]                             if (varValue != null) { [EOL]                                 final int varLen = varValue.length(); [EOL]                                 buf.replace(startPos, endPos, varValue); [EOL]                                 altered = true; [EOL]                                 int change = substitute(buf, startPos, varLen, priorVariables); [EOL]                                 change = change + varLen - (endPos - startPos); [EOL]                                 pos += change; [EOL]                                 bufEnd += change; [EOL]                                 lengthChange += change; [EOL]                                 chars = buf.buffer; [EOL]                             } [EOL]                             priorVariables.remove(priorVariables.size() - 1); [EOL]                             break; [EOL]                         } else { [EOL]                             nestedVarCount--; [EOL]                             pos += endMatchLen; [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (top) { [EOL]         return altered ? 1 : 0; [EOL]     } [EOL]     return lengthChange; [EOL] } 
 [LINE] int endMatchLen = 0; [LINE] private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables) { [EOL]     final StrMatcher prefixMatcher = getVariablePrefixMatcher(); [EOL]     final StrMatcher suffixMatcher = getVariableSuffixMatcher(); [EOL]     final char escape = getEscapeChar(); [EOL]     final boolean top = priorVariables == null; [EOL]     boolean altered = false; [EOL]     int lengthChange = 0; [EOL]     char[] chars = buf.buffer; [EOL]     int bufEnd = offset + length; [EOL]     int pos = offset; [EOL]     while (pos < bufEnd) { [EOL]         final int startMatchLen = prefixMatcher.isMatch(chars, pos, offset, bufEnd); [EOL]         if (startMatchLen == 0) { [EOL]             pos++; [EOL]         } else { [EOL]             if (pos > offset && chars[pos - 1] == escape) { [EOL]                 buf.deleteCharAt(pos - 1); [EOL]                 chars = buf.buffer; [EOL]                 lengthChange--; [EOL]                 altered = true; [EOL]                 bufEnd--; [EOL]             } else { [EOL]                 final int startPos = pos; [EOL]                 pos += startMatchLen; [EOL]                 int endMatchLen = 0; [EOL]                 int nestedVarCount = 0; [EOL]                 while (pos < bufEnd) { [EOL]                     if (isEnableSubstitutionInVariables() && (endMatchLen = prefixMatcher.isMatch(chars, pos, offset, bufEnd)) != 0) { [EOL]                         nestedVarCount++; [EOL]                         pos += endMatchLen; [EOL]                         continue; [EOL]                     } [EOL]                     endMatchLen = suffixMatcher.isMatch(chars, pos, offset, bufEnd); [EOL]                     if (endMatchLen == 0) { [EOL]                         pos++; [EOL]                     } else { [EOL]                         if (nestedVarCount == 0) { [EOL]                             String varName = new String(chars, startPos + startMatchLen, pos - startPos - startMatchLen); [EOL]                             if (isEnableSubstitutionInVariables()) { [EOL]                                 final StrBuilder bufName = new StrBuilder(varName); [EOL]                                 substitute(bufName, 0, bufName.length()); [EOL]                                 varName = bufName.toString(); [EOL]                             } [EOL]                             pos += endMatchLen; [EOL]                             final int endPos = pos; [EOL]                             if (priorVariables == null) { [EOL]                                 priorVariables = new ArrayList<String>(); [EOL]                                 priorVariables.add(new String(chars, offset, length)); [EOL]                             } [EOL]                             checkCyclicSubstitution(varName, priorVariables); [EOL]                             priorVariables.add(varName); [EOL]                             final String varValue = resolveVariable(varName, buf, startPos, endPos); [EOL]                             if (varValue != null) { [EOL]                                 final int varLen = varValue.length(); [EOL]                                 buf.replace(startPos, endPos, varValue); [EOL]                                 altered = true; [EOL]                                 int change = substitute(buf, startPos, varLen, priorVariables); [EOL]                                 change = change + varLen - (endPos - startPos); [EOL]                                 pos += change; [EOL]                                 bufEnd += change; [EOL]                                 lengthChange += change; [EOL]                                 chars = buf.buffer; [EOL]                             } [EOL]                             priorVariables.remove(priorVariables.size() - 1); [EOL]                             break; [EOL]                         } else { [EOL]                             nestedVarCount--; [EOL]                             pos += endMatchLen; [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (top) { [EOL]         return altered ? 1 : 0; [EOL]     } [EOL]     return lengthChange; [EOL] } 
 [LINE] int nestedVarCount = 0; [LINE] private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables) { [EOL]     final StrMatcher prefixMatcher = getVariablePrefixMatcher(); [EOL]     final StrMatcher suffixMatcher = getVariableSuffixMatcher(); [EOL]     final char escape = getEscapeChar(); [EOL]     final boolean top = priorVariables == null; [EOL]     boolean altered = false; [EOL]     int lengthChange = 0; [EOL]     char[] chars = buf.buffer; [EOL]     int bufEnd = offset + length; [EOL]     int pos = offset; [EOL]     while (pos < bufEnd) { [EOL]         final int startMatchLen = prefixMatcher.isMatch(chars, pos, offset, bufEnd); [EOL]         if (startMatchLen == 0) { [EOL]             pos++; [EOL]         } else { [EOL]             if (pos > offset && chars[pos - 1] == escape) { [EOL]                 buf.deleteCharAt(pos - 1); [EOL]                 chars = buf.buffer; [EOL]                 lengthChange--; [EOL]                 altered = true; [EOL]                 bufEnd--; [EOL]             } else { [EOL]                 final int startPos = pos; [EOL]                 pos += startMatchLen; [EOL]                 int endMatchLen = 0; [EOL]                 int nestedVarCount = 0; [EOL]                 while (pos < bufEnd) { [EOL]                     if (isEnableSubstitutionInVariables() && (endMatchLen = prefixMatcher.isMatch(chars, pos, offset, bufEnd)) != 0) { [EOL]                         nestedVarCount++; [EOL]                         pos += endMatchLen; [EOL]                         continue; [EOL]                     } [EOL]                     endMatchLen = suffixMatcher.isMatch(chars, pos, offset, bufEnd); [EOL]                     if (endMatchLen == 0) { [EOL]                         pos++; [EOL]                     } else { [EOL]                         if (nestedVarCount == 0) { [EOL]                             String varName = new String(chars, startPos + startMatchLen, pos - startPos - startMatchLen); [EOL]                             if (isEnableSubstitutionInVariables()) { [EOL]                                 final StrBuilder bufName = new StrBuilder(varName); [EOL]                                 substitute(bufName, 0, bufName.length()); [EOL]                                 varName = bufName.toString(); [EOL]                             } [EOL]                             pos += endMatchLen; [EOL]                             final int endPos = pos; [EOL]                             if (priorVariables == null) { [EOL]                                 priorVariables = new ArrayList<String>(); [EOL]                                 priorVariables.add(new String(chars, offset, length)); [EOL]                             } [EOL]                             checkCyclicSubstitution(varName, priorVariables); [EOL]                             priorVariables.add(varName); [EOL]                             final String varValue = resolveVariable(varName, buf, startPos, endPos); [EOL]                             if (varValue != null) { [EOL]                                 final int varLen = varValue.length(); [EOL]                                 buf.replace(startPos, endPos, varValue); [EOL]                                 altered = true; [EOL]                                 int change = substitute(buf, startPos, varLen, priorVariables); [EOL]                                 change = change + varLen - (endPos - startPos); [EOL]                                 pos += change; [EOL]                                 bufEnd += change; [EOL]                                 lengthChange += change; [EOL]                                 chars = buf.buffer; [EOL]                             } [EOL]                             priorVariables.remove(priorVariables.size() - 1); [EOL]                             break; [EOL]                         } else { [EOL]                             nestedVarCount--; [EOL]                             pos += endMatchLen; [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (top) { [EOL]         return altered ? 1 : 0; [EOL]     } [EOL]     return lengthChange; [EOL] } 
 [LINE] if (endMatchLen == 0) { [LINE] private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables) { [EOL]     final StrMatcher prefixMatcher = getVariablePrefixMatcher(); [EOL]     final StrMatcher suffixMatcher = getVariableSuffixMatcher(); [EOL]     final char escape = getEscapeChar(); [EOL]     final boolean top = priorVariables == null; [EOL]     boolean altered = false; [EOL]     int lengthChange = 0; [EOL]     char[] chars = buf.buffer; [EOL]     int bufEnd = offset + length; [EOL]     int pos = offset; [EOL]     while (pos < bufEnd) { [EOL]         final int startMatchLen = prefixMatcher.isMatch(chars, pos, offset, bufEnd); [EOL]         if (startMatchLen == 0) { [EOL]             pos++; [EOL]         } else { [EOL]             if (pos > offset && chars[pos - 1] == escape) { [EOL]                 buf.deleteCharAt(pos - 1); [EOL]                 chars = buf.buffer; [EOL]                 lengthChange--; [EOL]                 altered = true; [EOL]                 bufEnd--; [EOL]             } else { [EOL]                 final int startPos = pos; [EOL]                 pos += startMatchLen; [EOL]                 int endMatchLen = 0; [EOL]                 int nestedVarCount = 0; [EOL]                 while (pos < bufEnd) { [EOL]                     if (isEnableSubstitutionInVariables() && (endMatchLen = prefixMatcher.isMatch(chars, pos, offset, bufEnd)) != 0) { [EOL]                         nestedVarCount++; [EOL]                         pos += endMatchLen; [EOL]                         continue; [EOL]                     } [EOL]                     endMatchLen = suffixMatcher.isMatch(chars, pos, offset, bufEnd); [EOL]                     if (endMatchLen == 0) { [EOL]                         pos++; [EOL]                     } else { [EOL]                         if (nestedVarCount == 0) { [EOL]                             String varName = new String(chars, startPos + startMatchLen, pos - startPos - startMatchLen); [EOL]                             if (isEnableSubstitutionInVariables()) { [EOL]                                 final StrBuilder bufName = new StrBuilder(varName); [EOL]                                 substitute(bufName, 0, bufName.length()); [EOL]                                 varName = bufName.toString(); [EOL]                             } [EOL]                             pos += endMatchLen; [EOL]                             final int endPos = pos; [EOL]                             if (priorVariables == null) { [EOL]                                 priorVariables = new ArrayList<String>(); [EOL]                                 priorVariables.add(new String(chars, offset, length)); [EOL]                             } [EOL]                             checkCyclicSubstitution(varName, priorVariables); [EOL]                             priorVariables.add(varName); [EOL]                             final String varValue = resolveVariable(varName, buf, startPos, endPos); [EOL]                             if (varValue != null) { [EOL]                                 final int varLen = varValue.length(); [EOL]                                 buf.replace(startPos, endPos, varValue); [EOL]                                 altered = true; [EOL]                                 int change = substitute(buf, startPos, varLen, priorVariables); [EOL]                                 change = change + varLen - (endPos - startPos); [EOL]                                 pos += change; [EOL]                                 bufEnd += change; [EOL]                                 lengthChange += change; [EOL]                                 chars = buf.buffer; [EOL]                             } [EOL]                             priorVariables.remove(priorVariables.size() - 1); [EOL]                             break; [EOL]                         } else { [EOL]                             nestedVarCount--; [EOL]                             pos += endMatchLen; [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (top) { [EOL]         return altered ? 1 : 0; [EOL]     } [EOL]     return lengthChange; [EOL] } 
 [LINE] substitute(bufName, 0, bufName.length()); [LINE] private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables) { [EOL]     final StrMatcher prefixMatcher = getVariablePrefixMatcher(); [EOL]     final StrMatcher suffixMatcher = getVariableSuffixMatcher(); [EOL]     final char escape = getEscapeChar(); [EOL]     final boolean top = priorVariables == null; [EOL]     boolean altered = false; [EOL]     int lengthChange = 0; [EOL]     char[] chars = buf.buffer; [EOL]     int bufEnd = offset + length; [EOL]     int pos = offset; [EOL]     while (pos < bufEnd) { [EOL]         final int startMatchLen = prefixMatcher.isMatch(chars, pos, offset, bufEnd); [EOL]         if (startMatchLen == 0) { [EOL]             pos++; [EOL]         } else { [EOL]             if (pos > offset && chars[pos - 1] == escape) { [EOL]                 buf.deleteCharAt(pos - 1); [EOL]                 chars = buf.buffer; [EOL]                 lengthChange--; [EOL]                 altered = true; [EOL]                 bufEnd--; [EOL]             } else { [EOL]                 final int startPos = pos; [EOL]                 pos += startMatchLen; [EOL]                 int endMatchLen = 0; [EOL]                 int nestedVarCount = 0; [EOL]                 while (pos < bufEnd) { [EOL]                     if (isEnableSubstitutionInVariables() && (endMatchLen = prefixMatcher.isMatch(chars, pos, offset, bufEnd)) != 0) { [EOL]                         nestedVarCount++; [EOL]                         pos += endMatchLen; [EOL]                         continue; [EOL]                     } [EOL]                     endMatchLen = suffixMatcher.isMatch(chars, pos, offset, bufEnd); [EOL]                     if (endMatchLen == 0) { [EOL]                         pos++; [EOL]                     } else { [EOL]                         if (nestedVarCount == 0) { [EOL]                             String varName = new String(chars, startPos + startMatchLen, pos - startPos - startMatchLen); [EOL]                             if (isEnableSubstitutionInVariables()) { [EOL]                                 final StrBuilder bufName = new StrBuilder(varName); [EOL]                                 substitute(bufName, 0, bufName.length()); [EOL]                                 varName = bufName.toString(); [EOL]                             } [EOL]                             pos += endMatchLen; [EOL]                             final int endPos = pos; [EOL]                             if (priorVariables == null) { [EOL]                                 priorVariables = new ArrayList<String>(); [EOL]                                 priorVariables.add(new String(chars, offset, length)); [EOL]                             } [EOL]                             checkCyclicSubstitution(varName, priorVariables); [EOL]                             priorVariables.add(varName); [EOL]                             final String varValue = resolveVariable(varName, buf, startPos, endPos); [EOL]                             if (varValue != null) { [EOL]                                 final int varLen = varValue.length(); [EOL]                                 buf.replace(startPos, endPos, varValue); [EOL]                                 altered = true; [EOL]                                 int change = substitute(buf, startPos, varLen, priorVariables); [EOL]                                 change = change + varLen - (endPos - startPos); [EOL]                                 pos += change; [EOL]                                 bufEnd += change; [EOL]                                 lengthChange += change; [EOL]                                 chars = buf.buffer; [EOL]                             } [EOL]                             priorVariables.remove(priorVariables.size() - 1); [EOL]                             break; [EOL]                         } else { [EOL]                             nestedVarCount--; [EOL]                             pos += endMatchLen; [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (top) { [EOL]         return altered ? 1 : 0; [EOL]     } [EOL]     return lengthChange; [EOL] } 
 [LINE] if (priorVariables == null) { [LINE] private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables) { [EOL]     final StrMatcher prefixMatcher = getVariablePrefixMatcher(); [EOL]     final StrMatcher suffixMatcher = getVariableSuffixMatcher(); [EOL]     final char escape = getEscapeChar(); [EOL]     final boolean top = priorVariables == null; [EOL]     boolean altered = false; [EOL]     int lengthChange = 0; [EOL]     char[] chars = buf.buffer; [EOL]     int bufEnd = offset + length; [EOL]     int pos = offset; [EOL]     while (pos < bufEnd) { [EOL]         final int startMatchLen = prefixMatcher.isMatch(chars, pos, offset, bufEnd); [EOL]         if (startMatchLen == 0) { [EOL]             pos++; [EOL]         } else { [EOL]             if (pos > offset && chars[pos - 1] == escape) { [EOL]                 buf.deleteCharAt(pos - 1); [EOL]                 chars = buf.buffer; [EOL]                 lengthChange--; [EOL]                 altered = true; [EOL]                 bufEnd--; [EOL]             } else { [EOL]                 final int startPos = pos; [EOL]                 pos += startMatchLen; [EOL]                 int endMatchLen = 0; [EOL]                 int nestedVarCount = 0; [EOL]                 while (pos < bufEnd) { [EOL]                     if (isEnableSubstitutionInVariables() && (endMatchLen = prefixMatcher.isMatch(chars, pos, offset, bufEnd)) != 0) { [EOL]                         nestedVarCount++; [EOL]                         pos += endMatchLen; [EOL]                         continue; [EOL]                     } [EOL]                     endMatchLen = suffixMatcher.isMatch(chars, pos, offset, bufEnd); [EOL]                     if (endMatchLen == 0) { [EOL]                         pos++; [EOL]                     } else { [EOL]                         if (nestedVarCount == 0) { [EOL]                             String varName = new String(chars, startPos + startMatchLen, pos - startPos - startMatchLen); [EOL]                             if (isEnableSubstitutionInVariables()) { [EOL]                                 final StrBuilder bufName = new StrBuilder(varName); [EOL]                                 substitute(bufName, 0, bufName.length()); [EOL]                                 varName = bufName.toString(); [EOL]                             } [EOL]                             pos += endMatchLen; [EOL]                             final int endPos = pos; [EOL]                             if (priorVariables == null) { [EOL]                                 priorVariables = new ArrayList<String>(); [EOL]                                 priorVariables.add(new String(chars, offset, length)); [EOL]                             } [EOL]                             checkCyclicSubstitution(varName, priorVariables); [EOL]                             priorVariables.add(varName); [EOL]                             final String varValue = resolveVariable(varName, buf, startPos, endPos); [EOL]                             if (varValue != null) { [EOL]                                 final int varLen = varValue.length(); [EOL]                                 buf.replace(startPos, endPos, varValue); [EOL]                                 altered = true; [EOL]                                 int change = substitute(buf, startPos, varLen, priorVariables); [EOL]                                 change = change + varLen - (endPos - startPos); [EOL]                                 pos += change; [EOL]                                 bufEnd += change; [EOL]                                 lengthChange += change; [EOL]                                 chars = buf.buffer; [EOL]                             } [EOL]                             priorVariables.remove(priorVariables.size() - 1); [EOL]                             break; [EOL]                         } else { [EOL]                             nestedVarCount--; [EOL]                             pos += endMatchLen; [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (top) { [EOL]         return altered ? 1 : 0; [EOL]     } [EOL]     return lengthChange; [EOL] } 
 [LINE] priorVariables.add(new String(chars, [LINE] private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables) { [EOL]     final StrMatcher prefixMatcher = getVariablePrefixMatcher(); [EOL]     final StrMatcher suffixMatcher = getVariableSuffixMatcher(); [EOL]     final char escape = getEscapeChar(); [EOL]     final boolean top = priorVariables == null; [EOL]     boolean altered = false; [EOL]     int lengthChange = 0; [EOL]     char[] chars = buf.buffer; [EOL]     int bufEnd = offset + length; [EOL]     int pos = offset; [EOL]     while (pos < bufEnd) { [EOL]         final int startMatchLen = prefixMatcher.isMatch(chars, pos, offset, bufEnd); [EOL]         if (startMatchLen == 0) { [EOL]             pos++; [EOL]         } else { [EOL]             if (pos > offset && chars[pos - 1] == escape) { [EOL]                 buf.deleteCharAt(pos - 1); [EOL]                 chars = buf.buffer; [EOL]                 lengthChange--; [EOL]                 altered = true; [EOL]                 bufEnd--; [EOL]             } else { [EOL]                 final int startPos = pos; [EOL]                 pos += startMatchLen; [EOL]                 int endMatchLen = 0; [EOL]                 int nestedVarCount = 0; [EOL]                 while (pos < bufEnd) { [EOL]                     if (isEnableSubstitutionInVariables() && (endMatchLen = prefixMatcher.isMatch(chars, pos, offset, bufEnd)) != 0) { [EOL]                         nestedVarCount++; [EOL]                         pos += endMatchLen; [EOL]                         continue; [EOL]                     } [EOL]                     endMatchLen = suffixMatcher.isMatch(chars, pos, offset, bufEnd); [EOL]                     if (endMatchLen == 0) { [EOL]                         pos++; [EOL]                     } else { [EOL]                         if (nestedVarCount == 0) { [EOL]                             String varName = new String(chars, startPos + startMatchLen, pos - startPos - startMatchLen); [EOL]                             if (isEnableSubstitutionInVariables()) { [EOL]                                 final StrBuilder bufName = new StrBuilder(varName); [EOL]                                 substitute(bufName, 0, bufName.length()); [EOL]                                 varName = bufName.toString(); [EOL]                             } [EOL]                             pos += endMatchLen; [EOL]                             final int endPos = pos; [EOL]                             if (priorVariables == null) { [EOL]                                 priorVariables = new ArrayList<String>(); [EOL]                                 priorVariables.add(new String(chars, offset, length)); [EOL]                             } [EOL]                             checkCyclicSubstitution(varName, priorVariables); [EOL]                             priorVariables.add(varName); [EOL]                             final String varValue = resolveVariable(varName, buf, startPos, endPos); [EOL]                             if (varValue != null) { [EOL]                                 final int varLen = varValue.length(); [EOL]                                 buf.replace(startPos, endPos, varValue); [EOL]                                 altered = true; [EOL]                                 int change = substitute(buf, startPos, varLen, priorVariables); [EOL]                                 change = change + varLen - (endPos - startPos); [EOL]                                 pos += change; [EOL]                                 bufEnd += change; [EOL]                                 lengthChange += change; [EOL]                                 chars = buf.buffer; [EOL]                             } [EOL]                             priorVariables.remove(priorVariables.size() - 1); [EOL]                             break; [EOL]                         } else { [EOL]                             nestedVarCount--; [EOL]                             pos += endMatchLen; [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (top) { [EOL]         return altered ? 1 : 0; [EOL]     } [EOL]     return lengthChange; [EOL] } 
 [LINE] checkCyclicSubstitution(varName, priorVariables); [LINE] private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables) { [EOL]     final StrMatcher prefixMatcher = getVariablePrefixMatcher(); [EOL]     final StrMatcher suffixMatcher = getVariableSuffixMatcher(); [EOL]     final char escape = getEscapeChar(); [EOL]     final boolean top = priorVariables == null; [EOL]     boolean altered = false; [EOL]     int lengthChange = 0; [EOL]     char[] chars = buf.buffer; [EOL]     int bufEnd = offset + length; [EOL]     int pos = offset; [EOL]     while (pos < bufEnd) { [EOL]         final int startMatchLen = prefixMatcher.isMatch(chars, pos, offset, bufEnd); [EOL]         if (startMatchLen == 0) { [EOL]             pos++; [EOL]         } else { [EOL]             if (pos > offset && chars[pos - 1] == escape) { [EOL]                 buf.deleteCharAt(pos - 1); [EOL]                 chars = buf.buffer; [EOL]                 lengthChange--; [EOL]                 altered = true; [EOL]                 bufEnd--; [EOL]             } else { [EOL]                 final int startPos = pos; [EOL]                 pos += startMatchLen; [EOL]                 int endMatchLen = 0; [EOL]                 int nestedVarCount = 0; [EOL]                 while (pos < bufEnd) { [EOL]                     if (isEnableSubstitutionInVariables() && (endMatchLen = prefixMatcher.isMatch(chars, pos, offset, bufEnd)) != 0) { [EOL]                         nestedVarCount++; [EOL]                         pos += endMatchLen; [EOL]                         continue; [EOL]                     } [EOL]                     endMatchLen = suffixMatcher.isMatch(chars, pos, offset, bufEnd); [EOL]                     if (endMatchLen == 0) { [EOL]                         pos++; [EOL]                     } else { [EOL]                         if (nestedVarCount == 0) { [EOL]                             String varName = new String(chars, startPos + startMatchLen, pos - startPos - startMatchLen); [EOL]                             if (isEnableSubstitutionInVariables()) { [EOL]                                 final StrBuilder bufName = new StrBuilder(varName); [EOL]                                 substitute(bufName, 0, bufName.length()); [EOL]                                 varName = bufName.toString(); [EOL]                             } [EOL]                             pos += endMatchLen; [EOL]                             final int endPos = pos; [EOL]                             if (priorVariables == null) { [EOL]                                 priorVariables = new ArrayList<String>(); [EOL]                                 priorVariables.add(new String(chars, offset, length)); [EOL]                             } [EOL]                             checkCyclicSubstitution(varName, priorVariables); [EOL]                             priorVariables.add(varName); [EOL]                             final String varValue = resolveVariable(varName, buf, startPos, endPos); [EOL]                             if (varValue != null) { [EOL]                                 final int varLen = varValue.length(); [EOL]                                 buf.replace(startPos, endPos, varValue); [EOL]                                 altered = true; [EOL]                                 int change = substitute(buf, startPos, varLen, priorVariables); [EOL]                                 change = change + varLen - (endPos - startPos); [EOL]                                 pos += change; [EOL]                                 bufEnd += change; [EOL]                                 lengthChange += change; [EOL]                                 chars = buf.buffer; [EOL]                             } [EOL]                             priorVariables.remove(priorVariables.size() - 1); [EOL]                             break; [EOL]                         } else { [EOL]                             nestedVarCount--; [EOL]                             pos += endMatchLen; [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (top) { [EOL]         return altered ? 1 : 0; [EOL]     } [EOL]     return lengthChange; [EOL] } 
 [LINE] final String varValue = resolveVariable(varName, buf, [LINE] private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables) { [EOL]     final StrMatcher prefixMatcher = getVariablePrefixMatcher(); [EOL]     final StrMatcher suffixMatcher = getVariableSuffixMatcher(); [EOL]     final char escape = getEscapeChar(); [EOL]     final boolean top = priorVariables == null; [EOL]     boolean altered = false; [EOL]     int lengthChange = 0; [EOL]     char[] chars = buf.buffer; [EOL]     int bufEnd = offset + length; [EOL]     int pos = offset; [EOL]     while (pos < bufEnd) { [EOL]         final int startMatchLen = prefixMatcher.isMatch(chars, pos, offset, bufEnd); [EOL]         if (startMatchLen == 0) { [EOL]             pos++; [EOL]         } else { [EOL]             if (pos > offset && chars[pos - 1] == escape) { [EOL]                 buf.deleteCharAt(pos - 1); [EOL]                 chars = buf.buffer; [EOL]                 lengthChange--; [EOL]                 altered = true; [EOL]                 bufEnd--; [EOL]             } else { [EOL]                 final int startPos = pos; [EOL]                 pos += startMatchLen; [EOL]                 int endMatchLen = 0; [EOL]                 int nestedVarCount = 0; [EOL]                 while (pos < bufEnd) { [EOL]                     if (isEnableSubstitutionInVariables() && (endMatchLen = prefixMatcher.isMatch(chars, pos, offset, bufEnd)) != 0) { [EOL]                         nestedVarCount++; [EOL]                         pos += endMatchLen; [EOL]                         continue; [EOL]                     } [EOL]                     endMatchLen = suffixMatcher.isMatch(chars, pos, offset, bufEnd); [EOL]                     if (endMatchLen == 0) { [EOL]                         pos++; [EOL]                     } else { [EOL]                         if (nestedVarCount == 0) { [EOL]                             String varName = new String(chars, startPos + startMatchLen, pos - startPos - startMatchLen); [EOL]                             if (isEnableSubstitutionInVariables()) { [EOL]                                 final StrBuilder bufName = new StrBuilder(varName); [EOL]                                 substitute(bufName, 0, bufName.length()); [EOL]                                 varName = bufName.toString(); [EOL]                             } [EOL]                             pos += endMatchLen; [EOL]                             final int endPos = pos; [EOL]                             if (priorVariables == null) { [EOL]                                 priorVariables = new ArrayList<String>(); [EOL]                                 priorVariables.add(new String(chars, offset, length)); [EOL]                             } [EOL]                             checkCyclicSubstitution(varName, priorVariables); [EOL]                             priorVariables.add(varName); [EOL]                             final String varValue = resolveVariable(varName, buf, startPos, endPos); [EOL]                             if (varValue != null) { [EOL]                                 final int varLen = varValue.length(); [EOL]                                 buf.replace(startPos, endPos, varValue); [EOL]                                 altered = true; [EOL]                                 int change = substitute(buf, startPos, varLen, priorVariables); [EOL]                                 change = change + varLen - (endPos - startPos); [EOL]                                 pos += change; [EOL]                                 bufEnd += change; [EOL]                                 lengthChange += change; [EOL]                                 chars = buf.buffer; [EOL]                             } [EOL]                             priorVariables.remove(priorVariables.size() - 1); [EOL]                             break; [EOL]                         } else { [EOL]                             nestedVarCount--; [EOL]                             pos += endMatchLen; [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (top) { [EOL]         return altered ? 1 : 0; [EOL]     } [EOL]     return lengthChange; [EOL] } 
 [LINE] change = change [LINE] private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables) { [EOL]     final StrMatcher prefixMatcher = getVariablePrefixMatcher(); [EOL]     final StrMatcher suffixMatcher = getVariableSuffixMatcher(); [EOL]     final char escape = getEscapeChar(); [EOL]     final boolean top = priorVariables == null; [EOL]     boolean altered = false; [EOL]     int lengthChange = 0; [EOL]     char[] chars = buf.buffer; [EOL]     int bufEnd = offset + length; [EOL]     int pos = offset; [EOL]     while (pos < bufEnd) { [EOL]         final int startMatchLen = prefixMatcher.isMatch(chars, pos, offset, bufEnd); [EOL]         if (startMatchLen == 0) { [EOL]             pos++; [EOL]         } else { [EOL]             if (pos > offset && chars[pos - 1] == escape) { [EOL]                 buf.deleteCharAt(pos - 1); [EOL]                 chars = buf.buffer; [EOL]                 lengthChange--; [EOL]                 altered = true; [EOL]                 bufEnd--; [EOL]             } else { [EOL]                 final int startPos = pos; [EOL]                 pos += startMatchLen; [EOL]                 int endMatchLen = 0; [EOL]                 int nestedVarCount = 0; [EOL]                 while (pos < bufEnd) { [EOL]                     if (isEnableSubstitutionInVariables() && (endMatchLen = prefixMatcher.isMatch(chars, pos, offset, bufEnd)) != 0) { [EOL]                         nestedVarCount++; [EOL]                         pos += endMatchLen; [EOL]                         continue; [EOL]                     } [EOL]                     endMatchLen = suffixMatcher.isMatch(chars, pos, offset, bufEnd); [EOL]                     if (endMatchLen == 0) { [EOL]                         pos++; [EOL]                     } else { [EOL]                         if (nestedVarCount == 0) { [EOL]                             String varName = new String(chars, startPos + startMatchLen, pos - startPos - startMatchLen); [EOL]                             if (isEnableSubstitutionInVariables()) { [EOL]                                 final StrBuilder bufName = new StrBuilder(varName); [EOL]                                 substitute(bufName, 0, bufName.length()); [EOL]                                 varName = bufName.toString(); [EOL]                             } [EOL]                             pos += endMatchLen; [EOL]                             final int endPos = pos; [EOL]                             if (priorVariables == null) { [EOL]                                 priorVariables = new ArrayList<String>(); [EOL]                                 priorVariables.add(new String(chars, offset, length)); [EOL]                             } [EOL]                             checkCyclicSubstitution(varName, priorVariables); [EOL]                             priorVariables.add(varName); [EOL]                             final String varValue = resolveVariable(varName, buf, startPos, endPos); [EOL]                             if (varValue != null) { [EOL]                                 final int varLen = varValue.length(); [EOL]                                 buf.replace(startPos, endPos, varValue); [EOL]                                 altered = true; [EOL]                                 int change = substitute(buf, startPos, varLen, priorVariables); [EOL]                                 change = change + varLen - (endPos - startPos); [EOL]                                 pos += change; [EOL]                                 bufEnd += change; [EOL]                                 lengthChange += change; [EOL]                                 chars = buf.buffer; [EOL]                             } [EOL]                             priorVariables.remove(priorVariables.size() - 1); [EOL]                             break; [EOL]                         } else { [EOL]                             nestedVarCount--; [EOL]                             pos += endMatchLen; [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (top) { [EOL]         return altered ? 1 : 0; [EOL]     } [EOL]     return lengthChange; [EOL] } 
 [LINE] return lengthChange; [LINE] private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables) { [EOL]     final StrMatcher prefixMatcher = getVariablePrefixMatcher(); [EOL]     final StrMatcher suffixMatcher = getVariableSuffixMatcher(); [EOL]     final char escape = getEscapeChar(); [EOL]     final boolean top = priorVariables == null; [EOL]     boolean altered = false; [EOL]     int lengthChange = 0; [EOL]     char[] chars = buf.buffer; [EOL]     int bufEnd = offset + length; [EOL]     int pos = offset; [EOL]     while (pos < bufEnd) { [EOL]         final int startMatchLen = prefixMatcher.isMatch(chars, pos, offset, bufEnd); [EOL]         if (startMatchLen == 0) { [EOL]             pos++; [EOL]         } else { [EOL]             if (pos > offset && chars[pos - 1] == escape) { [EOL]                 buf.deleteCharAt(pos - 1); [EOL]                 chars = buf.buffer; [EOL]                 lengthChange--; [EOL]                 altered = true; [EOL]                 bufEnd--; [EOL]             } else { [EOL]                 final int startPos = pos; [EOL]                 pos += startMatchLen; [EOL]                 int endMatchLen = 0; [EOL]                 int nestedVarCount = 0; [EOL]                 while (pos < bufEnd) { [EOL]                     if (isEnableSubstitutionInVariables() && (endMatchLen = prefixMatcher.isMatch(chars, pos, offset, bufEnd)) != 0) { [EOL]                         nestedVarCount++; [EOL]                         pos += endMatchLen; [EOL]                         continue; [EOL]                     } [EOL]                     endMatchLen = suffixMatcher.isMatch(chars, pos, offset, bufEnd); [EOL]                     if (endMatchLen == 0) { [EOL]                         pos++; [EOL]                     } else { [EOL]                         if (nestedVarCount == 0) { [EOL]                             String varName = new String(chars, startPos + startMatchLen, pos - startPos - startMatchLen); [EOL]                             if (isEnableSubstitutionInVariables()) { [EOL]                                 final StrBuilder bufName = new StrBuilder(varName); [EOL]                                 substitute(bufName, 0, bufName.length()); [EOL]                                 varName = bufName.toString(); [EOL]                             } [EOL]                             pos += endMatchLen; [EOL]                             final int endPos = pos; [EOL]                             if (priorVariables == null) { [EOL]                                 priorVariables = new ArrayList<String>(); [EOL]                                 priorVariables.add(new String(chars, offset, length)); [EOL]                             } [EOL]                             checkCyclicSubstitution(varName, priorVariables); [EOL]                             priorVariables.add(varName); [EOL]                             final String varValue = resolveVariable(varName, buf, startPos, endPos); [EOL]                             if (varValue != null) { [EOL]                                 final int varLen = varValue.length(); [EOL]                                 buf.replace(startPos, endPos, varValue); [EOL]                                 altered = true; [EOL]                                 int change = substitute(buf, startPos, varLen, priorVariables); [EOL]                                 change = change + varLen - (endPos - startPos); [EOL]                                 pos += change; [EOL]                                 bufEnd += change; [EOL]                                 lengthChange += change; [EOL]                                 chars = buf.buffer; [EOL]                             } [EOL]                             priorVariables.remove(priorVariables.size() - 1); [EOL]                             break; [EOL]                         } else { [EOL]                             nestedVarCount--; [EOL]                             pos += endMatchLen; [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (top) { [EOL]         return altered ? 1 : 0; [EOL]     } [EOL]     return lengthChange; [EOL] } 
 [LINE] final StrBuilder buf = new StrBuilder(256); [LINE] private void checkCyclicSubstitution(final String varName, final List<String> priorVariables) { [EOL]     if (priorVariables.contains(varName) == false) { [EOL]         return; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(256); [EOL]     buf.append("Infinite loop in property interpolation of "); [EOL]     buf.append(priorVariables.remove(0)); [EOL]     buf.append(": "); [EOL]     buf.appendWithSeparators(priorVariables, "->"); [EOL]     throw new IllegalStateException(buf.toString()); [EOL] } 
 [LINE] buf.append(priorVariables.remove(0)); [LINE] private void checkCyclicSubstitution(final String varName, final List<String> priorVariables) { [EOL]     if (priorVariables.contains(varName) == false) { [EOL]         return; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(256); [EOL]     buf.append("Infinite loop in property interpolation of "); [EOL]     buf.append(priorVariables.remove(0)); [EOL]     buf.append(": "); [EOL]     buf.appendWithSeparators(priorVariables, "->"); [EOL]     throw new IllegalStateException(buf.toString()); [EOL] } 
 [LINE] if (prefixMatcher == null) { [LINE] public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher) { [EOL]     if (prefixMatcher == null) { [EOL]         throw new IllegalArgumentException("Variable prefix matcher must not be null!"); [EOL]     } [EOL]     this.prefixMatcher = prefixMatcher; [EOL]     return this; [EOL] } 
 [LINE] throw new IllegalArgumentException("Variable prefix matcher must not be null!"); [LINE] public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher) { [EOL]     if (prefixMatcher == null) { [EOL]         throw new IllegalArgumentException("Variable prefix matcher must not be null!"); [EOL]     } [EOL]     this.prefixMatcher = prefixMatcher; [EOL]     return this; [EOL] } 
 [LINE] if (prefix == null) { [LINE] public StrSubstitutor setVariablePrefix(final String prefix) { [EOL]     if (prefix == null) { [EOL]         throw new IllegalArgumentException("Variable prefix must not be null!"); [EOL]     } [EOL]     return setVariablePrefixMatcher(StrMatcher.stringMatcher(prefix)); [EOL] } 
 [LINE] throw new IllegalArgumentException("Variable suffix must not be null!"); [LINE] public StrSubstitutor setVariableSuffix(final String suffix) { [EOL]     if (suffix == null) { [EOL]         throw new IllegalArgumentException("Variable suffix must not be null!"); [EOL]     } [EOL]     return setVariableSuffixMatcher(StrMatcher.stringMatcher(suffix)); [EOL] } 
 [LINE] return setVariableSuffixMatcher(StrMatcher.stringMatcher(suffix)); [LINE] public StrSubstitutor setVariableSuffix(final String suffix) { [EOL]     if (suffix == null) { [EOL]         throw new IllegalArgumentException("Variable suffix must not be null!"); [EOL]     } [EOL]     return setVariableSuffixMatcher(StrMatcher.stringMatcher(suffix)); [EOL] } 
 [LINE] return this.variableResolver; [LINE] public StrLookup<?> getVariableResolver() { [EOL]     return this.variableResolver; [EOL] } 
 [LINE] this.variableResolver = variableResolver; [LINE] public void setVariableResolver(final StrLookup<?> variableResolver) { [EOL]     this.variableResolver = variableResolver; [EOL] } 
lang3/builder/CompareToBuilder.java
 [LINE] if (lhs == rhs) { [LINE] public static int reflectionCompare(final Object lhs, final Object rhs, final boolean compareTransients, final Class<?> reflectUpToClass, final String... excludeFields) { [EOL]     if (lhs == rhs) { [EOL]         return 0; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         throw new NullPointerException(); [EOL]     } [EOL]     Class<?> lhsClazz = lhs.getClass(); [EOL]     if (!lhsClazz.isInstance(rhs)) { [EOL]         throw new ClassCastException(); [EOL]     } [EOL]     final CompareToBuilder compareToBuilder = new CompareToBuilder(); [EOL]     reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields); [EOL]     while (lhsClazz.getSuperclass() != null && lhsClazz != reflectUpToClass) { [EOL]         lhsClazz = lhsClazz.getSuperclass(); [EOL]         reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields); [EOL]     } [EOL]     return compareToBuilder.toComparison(); [EOL] } 
 [LINE] throw new ClassCastException(); [LINE] public static int reflectionCompare(final Object lhs, final Object rhs, final boolean compareTransients, final Class<?> reflectUpToClass, final String... excludeFields) { [EOL]     if (lhs == rhs) { [EOL]         return 0; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         throw new NullPointerException(); [EOL]     } [EOL]     Class<?> lhsClazz = lhs.getClass(); [EOL]     if (!lhsClazz.isInstance(rhs)) { [EOL]         throw new ClassCastException(); [EOL]     } [EOL]     final CompareToBuilder compareToBuilder = new CompareToBuilder(); [EOL]     reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields); [EOL]     while (lhsClazz.getSuperclass() != null && lhsClazz != reflectUpToClass) { [EOL]         lhsClazz = lhsClazz.getSuperclass(); [EOL]         reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields); [EOL]     } [EOL]     return compareToBuilder.toComparison(); [EOL] } 
 [LINE] while (lhsClazz.getSuperclass() != null && lhsClazz != reflectUpToClass) { [LINE] public static int reflectionCompare(final Object lhs, final Object rhs, final boolean compareTransients, final Class<?> reflectUpToClass, final String... excludeFields) { [EOL]     if (lhs == rhs) { [EOL]         return 0; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         throw new NullPointerException(); [EOL]     } [EOL]     Class<?> lhsClazz = lhs.getClass(); [EOL]     if (!lhsClazz.isInstance(rhs)) { [EOL]         throw new ClassCastException(); [EOL]     } [EOL]     final CompareToBuilder compareToBuilder = new CompareToBuilder(); [EOL]     reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields); [EOL]     while (lhsClazz.getSuperclass() != null && lhsClazz != reflectUpToClass) { [EOL]         lhsClazz = lhsClazz.getSuperclass(); [EOL]         reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields); [EOL]     } [EOL]     return compareToBuilder.toComparison(); [EOL] } 
 [LINE] try { [LINE] private static void reflectionAppend(final Object lhs, final Object rhs, final Class<?> clazz, final CompareToBuilder builder, final boolean useTransients, final String[] excludeFields) { [EOL]     final Field[] fields = clazz.getDeclaredFields(); [EOL]     AccessibleObject.setAccessible(fields, true); [EOL]     for (int i = 0; i < fields.length && builder.comparison == 0; i++) { [EOL]         final Field f = fields[i]; [EOL]         if (!ArrayUtils.contains(excludeFields, f.getName()) && (f.getName().indexOf('$') == -1) && (useTransients || !Modifier.isTransient(f.getModifiers())) && (!Modifier.isStatic(f.getModifiers()))) { [EOL]             try { [EOL]                 builder.append(f.get(lhs), f.get(rhs)); [EOL]             } catch (final IllegalAccessException e) { [EOL]                 throw new InternalError("Unexpected IllegalAccessException"); [EOL]             } [EOL]         } [EOL]     } [EOL] } 
 [LINE] return this; [LINE] public CompareToBuilder append(final Object lhs, final Object rhs, final Comparator<?> comparator) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.getClass().isArray()) { [EOL]         if (lhs instanceof long[]) { [EOL]             append((long[]) lhs, (long[]) rhs); [EOL]         } else if (lhs instanceof int[]) { [EOL]             append((int[]) lhs, (int[]) rhs); [EOL]         } else if (lhs instanceof short[]) { [EOL]             append((short[]) lhs, (short[]) rhs); [EOL]         } else if (lhs instanceof char[]) { [EOL]             append((char[]) lhs, (char[]) rhs); [EOL]         } else if (lhs instanceof byte[]) { [EOL]             append((byte[]) lhs, (byte[]) rhs); [EOL]         } else if (lhs instanceof double[]) { [EOL]             append((double[]) lhs, (double[]) rhs); [EOL]         } else if (lhs instanceof float[]) { [EOL]             append((float[]) lhs, (float[]) rhs); [EOL]         } else if (lhs instanceof boolean[]) { [EOL]             append((boolean[]) lhs, (boolean[]) rhs); [EOL]         } else { [EOL]             append((Object[]) lhs, (Object[]) rhs, comparator); [EOL]         } [EOL]     } else { [EOL]         if (comparator == null) { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparable<Object> comparable = (Comparable<Object>) lhs; [EOL]             comparison = comparable.compareTo(rhs); [EOL]         } else { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparator<Object> comparator2 = (Comparator<Object>) comparator; [EOL]             comparison = comparator2.compare(lhs, rhs); [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] if (lhs.getClass().isArray()) { [LINE] public CompareToBuilder append(final Object lhs, final Object rhs, final Comparator<?> comparator) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.getClass().isArray()) { [EOL]         if (lhs instanceof long[]) { [EOL]             append((long[]) lhs, (long[]) rhs); [EOL]         } else if (lhs instanceof int[]) { [EOL]             append((int[]) lhs, (int[]) rhs); [EOL]         } else if (lhs instanceof short[]) { [EOL]             append((short[]) lhs, (short[]) rhs); [EOL]         } else if (lhs instanceof char[]) { [EOL]             append((char[]) lhs, (char[]) rhs); [EOL]         } else if (lhs instanceof byte[]) { [EOL]             append((byte[]) lhs, (byte[]) rhs); [EOL]         } else if (lhs instanceof double[]) { [EOL]             append((double[]) lhs, (double[]) rhs); [EOL]         } else if (lhs instanceof float[]) { [EOL]             append((float[]) lhs, (float[]) rhs); [EOL]         } else if (lhs instanceof boolean[]) { [EOL]             append((boolean[]) lhs, (boolean[]) rhs); [EOL]         } else { [EOL]             append((Object[]) lhs, (Object[]) rhs, comparator); [EOL]         } [EOL]     } else { [EOL]         if (comparator == null) { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparable<Object> comparable = (Comparable<Object>) lhs; [EOL]             comparison = comparable.compareTo(rhs); [EOL]         } else { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparator<Object> comparator2 = (Comparator<Object>) comparator; [EOL]             comparison = comparator2.compare(lhs, rhs); [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] append((int[]) lhs, (int[]) rhs); [LINE] public CompareToBuilder append(final Object lhs, final Object rhs, final Comparator<?> comparator) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.getClass().isArray()) { [EOL]         if (lhs instanceof long[]) { [EOL]             append((long[]) lhs, (long[]) rhs); [EOL]         } else if (lhs instanceof int[]) { [EOL]             append((int[]) lhs, (int[]) rhs); [EOL]         } else if (lhs instanceof short[]) { [EOL]             append((short[]) lhs, (short[]) rhs); [EOL]         } else if (lhs instanceof char[]) { [EOL]             append((char[]) lhs, (char[]) rhs); [EOL]         } else if (lhs instanceof byte[]) { [EOL]             append((byte[]) lhs, (byte[]) rhs); [EOL]         } else if (lhs instanceof double[]) { [EOL]             append((double[]) lhs, (double[]) rhs); [EOL]         } else if (lhs instanceof float[]) { [EOL]             append((float[]) lhs, (float[]) rhs); [EOL]         } else if (lhs instanceof boolean[]) { [EOL]             append((boolean[]) lhs, (boolean[]) rhs); [EOL]         } else { [EOL]             append((Object[]) lhs, (Object[]) rhs, comparator); [EOL]         } [EOL]     } else { [EOL]         if (comparator == null) { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparable<Object> comparable = (Comparable<Object>) lhs; [EOL]             comparison = comparable.compareTo(rhs); [EOL]         } else { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparator<Object> comparator2 = (Comparator<Object>) comparator; [EOL]             comparison = comparator2.compare(lhs, rhs); [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] append((float[]) lhs, (float[]) rhs); [LINE] public CompareToBuilder append(final Object lhs, final Object rhs, final Comparator<?> comparator) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.getClass().isArray()) { [EOL]         if (lhs instanceof long[]) { [EOL]             append((long[]) lhs, (long[]) rhs); [EOL]         } else if (lhs instanceof int[]) { [EOL]             append((int[]) lhs, (int[]) rhs); [EOL]         } else if (lhs instanceof short[]) { [EOL]             append((short[]) lhs, (short[]) rhs); [EOL]         } else if (lhs instanceof char[]) { [EOL]             append((char[]) lhs, (char[]) rhs); [EOL]         } else if (lhs instanceof byte[]) { [EOL]             append((byte[]) lhs, (byte[]) rhs); [EOL]         } else if (lhs instanceof double[]) { [EOL]             append((double[]) lhs, (double[]) rhs); [EOL]         } else if (lhs instanceof float[]) { [EOL]             append((float[]) lhs, (float[]) rhs); [EOL]         } else if (lhs instanceof boolean[]) { [EOL]             append((boolean[]) lhs, (boolean[]) rhs); [EOL]         } else { [EOL]             append((Object[]) lhs, (Object[]) rhs, comparator); [EOL]         } [EOL]     } else { [EOL]         if (comparator == null) { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparable<Object> comparable = (Comparable<Object>) lhs; [EOL]             comparison = comparable.compareTo(rhs); [EOL]         } else { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparator<Object> comparator2 = (Comparator<Object>) comparator; [EOL]             comparison = comparator2.compare(lhs, rhs); [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] append((boolean[]) lhs, (boolean[]) rhs); [LINE] public CompareToBuilder append(final Object lhs, final Object rhs, final Comparator<?> comparator) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.getClass().isArray()) { [EOL]         if (lhs instanceof long[]) { [EOL]             append((long[]) lhs, (long[]) rhs); [EOL]         } else if (lhs instanceof int[]) { [EOL]             append((int[]) lhs, (int[]) rhs); [EOL]         } else if (lhs instanceof short[]) { [EOL]             append((short[]) lhs, (short[]) rhs); [EOL]         } else if (lhs instanceof char[]) { [EOL]             append((char[]) lhs, (char[]) rhs); [EOL]         } else if (lhs instanceof byte[]) { [EOL]             append((byte[]) lhs, (byte[]) rhs); [EOL]         } else if (lhs instanceof double[]) { [EOL]             append((double[]) lhs, (double[]) rhs); [EOL]         } else if (lhs instanceof float[]) { [EOL]             append((float[]) lhs, (float[]) rhs); [EOL]         } else if (lhs instanceof boolean[]) { [EOL]             append((boolean[]) lhs, (boolean[]) rhs); [EOL]         } else { [EOL]             append((Object[]) lhs, (Object[]) rhs, comparator); [EOL]         } [EOL]     } else { [EOL]         if (comparator == null) { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparable<Object> comparable = (Comparable<Object>) lhs; [EOL]             comparison = comparable.compareTo(rhs); [EOL]         } else { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparator<Object> comparator2 = (Comparator<Object>) comparator; [EOL]             comparison = comparator2.compare(lhs, rhs); [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] comparison = ((lhs < rhs) ? -1 : ((lhs > rhs) ? 1 : 0)); [LINE] public CompareToBuilder append(final short lhs, final short rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     comparison = ((lhs < rhs) ? -1 : ((lhs > rhs) ? 1 : 0)); [EOL]     return this; [EOL] } 
 [LINE] if (comparison != 0) { [LINE] public CompareToBuilder append(final char lhs, final char rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     comparison = ((lhs < rhs) ? -1 : ((lhs > rhs) ? 1 : 0)); [EOL]     return this; [EOL] } 
 [LINE] return this; [LINE] public CompareToBuilder append(final char lhs, final char rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     comparison = ((lhs < rhs) ? -1 : ((lhs > rhs) ? 1 : 0)); [EOL]     return this; [EOL] } 
 [LINE] if (lhs == rhs) { [LINE] public CompareToBuilder append(final boolean lhs, final boolean rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == false) { [EOL]         comparison = -1; [EOL]     } else { [EOL]         comparison = +1; [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] return this; [LINE] public CompareToBuilder append(final boolean lhs, final boolean rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == false) { [EOL]         comparison = -1; [EOL]     } else { [EOL]         comparison = +1; [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] comparison = +1; [LINE] public CompareToBuilder append(final boolean lhs, final boolean rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == false) { [EOL]         comparison = -1; [EOL]     } else { [EOL]         comparison = +1; [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] return this; [LINE] public CompareToBuilder append(final Object[] lhs, final Object[] rhs, final Comparator<?> comparator) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i], comparator); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] for (int i = 0; i < lhs.length && comparison == 0; i++) { [LINE] public CompareToBuilder append(final Object[] lhs, final Object[] rhs, final Comparator<?> comparator) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i], comparator); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] return this; [LINE] public CompareToBuilder append(final long[] lhs, final long[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] comparison = (lhs.length < rhs.length) ? -1 : +1; [LINE] public CompareToBuilder append(final long[] lhs, final long[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] append(lhs[i], rhs[i]); [LINE] public CompareToBuilder append(final long[] lhs, final long[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] return this; [LINE] public CompareToBuilder append(final int[] lhs, final int[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] comparison = +1; [LINE] public CompareToBuilder append(final short[] lhs, final short[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] append(lhs[i], rhs[i]); [LINE] public CompareToBuilder append(final short[] lhs, final short[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] if (comparison != 0) { [LINE] public CompareToBuilder append(final char[] lhs, final char[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] if (lhs == rhs) { [LINE] public CompareToBuilder append(final char[] lhs, final char[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] if (lhs.length != rhs.length) { [LINE] public CompareToBuilder append(final char[] lhs, final char[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] if (comparison != 0) { [LINE] public CompareToBuilder append(final byte[] lhs, final byte[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] if (lhs == rhs) { [LINE] public CompareToBuilder append(final byte[] lhs, final byte[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] return this; [LINE] public CompareToBuilder append(final byte[] lhs, final byte[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] return this; [LINE] public CompareToBuilder append(final byte[] lhs, final byte[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] append(lhs[i], rhs[i]); [LINE] public CompareToBuilder append(final byte[] lhs, final byte[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] if (comparison != 0) { [LINE] public CompareToBuilder append(final double[] lhs, final double[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] if (lhs == rhs) { [LINE] public CompareToBuilder append(final double[] lhs, final double[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] return this; [LINE] public CompareToBuilder append(final double[] lhs, final double[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] comparison = +1; [LINE] public CompareToBuilder append(final double[] lhs, final double[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] append(lhs[i], rhs[i]); [LINE] public CompareToBuilder append(final double[] lhs, final double[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] comparison = (lhs.length < rhs.length) ? -1 : +1; [LINE] public CompareToBuilder append(final float[] lhs, final float[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] return this; [LINE] public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] return this; [LINE] public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] comparison = +1; [LINE] public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] return this; [LINE] public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] return Integer.valueOf(toComparison()); [LINE] @Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] } 
lang3/concurrent/MultiBackgroundInitializer.java
 [LINE] throw new IllegalArgumentException( [LINE] public void addInitializer(final String name, final BackgroundInitializer<?> init) { [EOL]     if (name == null) { [EOL]         throw new IllegalArgumentException("Name of child initializer must not be null!"); [EOL]     } [EOL]     if (init == null) { [EOL]         throw new IllegalArgumentException("Child initializer must not be null!"); [EOL]     } [EOL]     synchronized (this) { [EOL]         if (isStarted()) { [EOL]             throw new IllegalStateException("addInitializer() must not be called after start()!"); [EOL]         } [EOL]         childInitializers.put(name, init); [EOL]     } [EOL] } 
 [LINE] if (init == null) { [LINE] public void addInitializer(final String name, final BackgroundInitializer<?> init) { [EOL]     if (name == null) { [EOL]         throw new IllegalArgumentException("Name of child initializer must not be null!"); [EOL]     } [EOL]     if (init == null) { [EOL]         throw new IllegalArgumentException("Child initializer must not be null!"); [EOL]     } [EOL]     synchronized (this) { [EOL]         if (isStarted()) { [EOL]             throw new IllegalStateException("addInitializer() must not be called after start()!"); [EOL]         } [EOL]         childInitializers.put(name, init); [EOL]     } [EOL] } 
 [LINE] final Map<String, ConcurrentException> excepts = new HashMap<String, ConcurrentException>(); [LINE] @Override [EOL] protected MultiBackgroundInitializerResults initialize() throws Exception { [EOL]     Map<String, BackgroundInitializer<?>> inits; [EOL]     synchronized (this) { [EOL]         inits = new HashMap<String, BackgroundInitializer<?>>(childInitializers); [EOL]     } [EOL]     final ExecutorService exec = getActiveExecutor(); [EOL]     for (final BackgroundInitializer<?> bi : inits.values()) { [EOL]         if (bi.getExternalExecutor() == null) { [EOL]             bi.setExternalExecutor(exec); [EOL]         } [EOL]         bi.start(); [EOL]     } [EOL]     final Map<String, Object> results = new HashMap<String, Object>(); [EOL]     final Map<String, ConcurrentException> excepts = new HashMap<String, ConcurrentException>(); [EOL]     for (final Map.Entry<String, BackgroundInitializer<?>> e : inits.entrySet()) { [EOL]         try { [EOL]             results.put(e.getKey(), e.getValue().get()); [EOL]         } catch (final ConcurrentException cex) { [EOL]             excepts.put(e.getKey(), cex); [EOL]         } [EOL]     } [EOL]     return new MultiBackgroundInitializerResults(inits, results, excepts); [EOL] } 
lang3/text/translate/UnicodeEscaper.java
 [LINE] return outsideOf(0, codepoint); [LINE] public static UnicodeEscaper above(final int codepoint) { [EOL]     return outsideOf(0, codepoint); [EOL] } 
 [LINE] } else if (codepoint > 0xff) { [LINE] @Override [EOL] public boolean translate(final int codepoint, final Writer out) throws IOException { [EOL]     if (between) { [EOL]         if (codepoint < below || codepoint > above) { [EOL]             return false; [EOL]         } [EOL]     } else { [EOL]         if (codepoint >= below && codepoint <= above) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     if (codepoint > 0xffff) { [EOL]         out.write(toUtf16Escape(codepoint)); [EOL]     } else if (codepoint > 0xfff) { [EOL]         out.write("\\u" + hex(codepoint)); [EOL]     } else if (codepoint > 0xff) { [EOL]         out.write("\\u0" + hex(codepoint)); [EOL]     } else if (codepoint > 0xf) { [EOL]         out.write("\\u00" + hex(codepoint)); [EOL]     } else { [EOL]         out.write("\\u000" + hex(codepoint)); [EOL]     } [EOL]     return true; [EOL] } 
lang3/math/IEEE754rUtils.java
 [LINE] if (array == null) { [LINE] public static double min(final double[] array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } else if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array cannot be empty."); [EOL]     } [EOL]     double min = array[0]; [EOL]     for (int i = 1; i < array.length; i++) { [EOL]         min = min(array[i], min); [EOL]     } [EOL]     return min; [EOL] } 
 [LINE] } else if (array.length == 0) { [LINE] public static float min(final float[] array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } else if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array cannot be empty."); [EOL]     } [EOL]     float min = array[0]; [EOL]     for (int i = 1; i < array.length; i++) { [EOL]         min = min(array[i], min); [EOL]     } [EOL]     return min; [EOL] } 
 [LINE] return b; [LINE] public static double min(final double a, final double b) { [EOL]     if (Double.isNaN(a)) { [EOL]         return b; [EOL]     } else if (Double.isNaN(b)) { [EOL]         return a; [EOL]     } else { [EOL]         return Math.min(a, b); [EOL]     } [EOL] } 
 [LINE] return Math.min(a, b); [LINE] public static double min(final double a, final double b) { [EOL]     if (Double.isNaN(a)) { [EOL]         return b; [EOL]     } else if (Double.isNaN(b)) { [EOL]         return a; [EOL]     } else { [EOL]         return Math.min(a, b); [EOL]     } [EOL] } 
 [LINE] return a; [LINE] public static float min(final float a, final float b) { [EOL]     if (Float.isNaN(a)) { [EOL]         return b; [EOL]     } else if (Float.isNaN(b)) { [EOL]         return a; [EOL]     } else { [EOL]         return Math.min(a, b); [EOL]     } [EOL] } 
 [LINE] return Math.min(a, b); [LINE] public static float min(final float a, final float b) { [EOL]     if (Float.isNaN(a)) { [EOL]         return b; [EOL]     } else if (Float.isNaN(b)) { [EOL]         return a; [EOL]     } else { [EOL]         return Math.min(a, b); [EOL]     } [EOL] } 
 [LINE] for (int j = 1; j < array.length; j++) { [LINE] public static double max(final double[] array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } else if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array cannot be empty."); [EOL]     } [EOL]     double max = array[0]; [EOL]     for (int j = 1; j < array.length; j++) { [EOL]         max = max(array[j], max); [EOL]     } [EOL]     return max; [EOL] } 
 [LINE] float max = array[0]; [LINE] public static float max(final float[] array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } else if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array cannot be empty."); [EOL]     } [EOL]     float max = array[0]; [EOL]     for (int j = 1; j < array.length; j++) { [EOL]         max = max(array[j], max); [EOL]     } [EOL]     return max; [EOL] } 
 [LINE] return Math.max(a, b); [LINE] public static float max(final float a, final float b) { [EOL]     if (Float.isNaN(a)) { [EOL]         return b; [EOL]     } else if (Float.isNaN(b)) { [EOL]         return a; [EOL]     } else { [EOL]         return Math.max(a, b); [EOL]     } [EOL] } 
lang3/builder/ToStringBuilder.java
 [LINE] style.append(buffer, null, value); [LINE] public ToStringBuilder append(final boolean value) { [EOL]     style.append(buffer, null, value); [EOL]     return this; [EOL] } 
 [LINE] style.append(buffer, null, array, null); [LINE] public ToStringBuilder append(final boolean[] array) { [EOL]     style.append(buffer, null, array, null); [EOL]     return this; [EOL] } 
 [LINE] style.append(buffer, null, value); [LINE] public ToStringBuilder append(final float value) { [EOL]     style.append(buffer, null, value); [EOL]     return this; [EOL] } 
 [LINE] return this; [LINE] public ToStringBuilder append(final long value) { [EOL]     style.append(buffer, null, value); [EOL]     return this; [EOL] } 
 [LINE] style.append(buffer, null, array, null); [LINE] public ToStringBuilder append(final Object[] array) { [EOL]     style.append(buffer, null, array, null); [EOL]     return this; [EOL] } 
 [LINE] style.append(buffer, null, value); [LINE] public ToStringBuilder append(final short value) { [EOL]     style.append(buffer, null, value); [EOL]     return this; [EOL] } 
 [LINE] style.append(buffer, null, array, null); [LINE] public ToStringBuilder append(final short[] array) { [EOL]     style.append(buffer, null, array, null); [EOL]     return this; [EOL] } 
 [LINE] style.append(buffer, fieldName, value); [LINE] public ToStringBuilder append(final String fieldName, final boolean value) { [EOL]     style.append(buffer, fieldName, value); [EOL]     return this; [EOL] } 
 [LINE] return this; [LINE] public ToStringBuilder append(final String fieldName, final boolean value) { [EOL]     style.append(buffer, fieldName, value); [EOL]     return this; [EOL] } 
 [LINE] style.append(buffer, fieldName, value); [LINE] public ToStringBuilder append(final String fieldName, final char value) { [EOL]     style.append(buffer, fieldName, value); [EOL]     return this; [EOL] } 
 [LINE] return this; [LINE] public ToStringBuilder append(final String fieldName, final double value) { [EOL]     style.append(buffer, fieldName, value); [EOL]     return this; [EOL] } 
 [LINE] style.append(buffer, fieldName, value); [LINE] public ToStringBuilder append(final String fieldName, final float value) { [EOL]     style.append(buffer, fieldName, value); [EOL]     return this; [EOL] } 
 [LINE] return this; [LINE] public ToStringBuilder append(final String fieldName, final long value) { [EOL]     style.append(buffer, fieldName, value); [EOL]     return this; [EOL] } 
 [LINE] style.append(buffer, fieldName, obj, null); [LINE] public ToStringBuilder append(final String fieldName, final Object obj) { [EOL]     style.append(buffer, fieldName, obj, null); [EOL]     return this; [EOL] } 
 [LINE] style.appendEnd(this.getStringBuffer(), this.getObject()); [LINE] @Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         this.getStringBuffer().append(this.getStyle().getNullText()); [EOL]     } else { [EOL]         style.appendEnd(this.getStringBuffer(), this.getObject()); [EOL]     } [EOL]     return this.getStringBuffer().toString(); [EOL] } 
lang3/text/ExtendedMessageFormat.java
 [LINE] return; [LINE] @Override [EOL] public final void applyPattern(final String pattern) { [EOL]     if (registry == null) { [EOL]         super.applyPattern(pattern); [EOL]         toPattern = super.toPattern(); [EOL]         return; [EOL]     } [EOL]     final ArrayList<Format> foundFormats = new ArrayList<Format>(); [EOL]     final ArrayList<String> foundDescriptions = new ArrayList<String>(); [EOL]     final StringBuilder stripCustom = new StringBuilder(pattern.length()); [EOL]     final ParsePosition pos = new ParsePosition(0); [EOL]     final char[] c = pattern.toCharArray(); [EOL]     int fmtCount = 0; [EOL]     while (pos.getIndex() < pattern.length()) { [EOL]         switch(c[pos.getIndex()]) { [EOL]             case QUOTE: [EOL]                 appendQuotedString(pattern, pos, stripCustom, true); [EOL]                 break; [EOL]             case START_FE: [EOL]                 fmtCount++; [EOL]                 seekNonWs(pattern, pos); [EOL]                 final int start = pos.getIndex(); [EOL]                 final int index = readArgumentIndex(pattern, next(pos)); [EOL]                 stripCustom.append(START_FE).append(index); [EOL]                 seekNonWs(pattern, pos); [EOL]                 Format format = null; [EOL]                 String formatDescription = null; [EOL]                 if (c[pos.getIndex()] == START_FMT) { [EOL]                     formatDescription = parseFormatDescription(pattern, next(pos)); [EOL]                     format = getFormat(formatDescription); [EOL]                     if (format == null) { [EOL]                         stripCustom.append(START_FMT).append(formatDescription); [EOL]                     } [EOL]                 } [EOL]                 foundFormats.add(format); [EOL]                 foundDescriptions.add(format == null ? null : formatDescription); [EOL]                 Validate.isTrue(foundFormats.size() == fmtCount); [EOL]                 Validate.isTrue(foundDescriptions.size() == fmtCount); [EOL]                 if (c[pos.getIndex()] != END_FE) { [EOL]                     throw new IllegalArgumentException("Unreadable format element at position " + start); [EOL]                 } [EOL]             default: [EOL]                 stripCustom.append(c[pos.getIndex()]); [EOL]                 next(pos); [EOL]         } [EOL]     } [EOL]     super.applyPattern(stripCustom.toString()); [EOL]     toPattern = insertFormats(super.toPattern(), foundDescriptions); [EOL]     if (containsElements(foundFormats)) { [EOL]         final Format[] origFormats = getFormats(); [EOL]         int i = 0; [EOL]         for (final Iterator<Format> it = foundFormats.iterator(); it.hasNext(); i++) { [EOL]             final Format f = it.next(); [EOL]             if (f != null) { [EOL]                 origFormats[i] = f; [EOL]             } [EOL]         } [EOL]         super.setFormats(origFormats); [EOL]     } [EOL] } 
 [LINE] case QUOTE: [LINE] @Override [EOL] public final void applyPattern(final String pattern) { [EOL]     if (registry == null) { [EOL]         super.applyPattern(pattern); [EOL]         toPattern = super.toPattern(); [EOL]         return; [EOL]     } [EOL]     final ArrayList<Format> foundFormats = new ArrayList<Format>(); [EOL]     final ArrayList<String> foundDescriptions = new ArrayList<String>(); [EOL]     final StringBuilder stripCustom = new StringBuilder(pattern.length()); [EOL]     final ParsePosition pos = new ParsePosition(0); [EOL]     final char[] c = pattern.toCharArray(); [EOL]     int fmtCount = 0; [EOL]     while (pos.getIndex() < pattern.length()) { [EOL]         switch(c[pos.getIndex()]) { [EOL]             case QUOTE: [EOL]                 appendQuotedString(pattern, pos, stripCustom, true); [EOL]                 break; [EOL]             case START_FE: [EOL]                 fmtCount++; [EOL]                 seekNonWs(pattern, pos); [EOL]                 final int start = pos.getIndex(); [EOL]                 final int index = readArgumentIndex(pattern, next(pos)); [EOL]                 stripCustom.append(START_FE).append(index); [EOL]                 seekNonWs(pattern, pos); [EOL]                 Format format = null; [EOL]                 String formatDescription = null; [EOL]                 if (c[pos.getIndex()] == START_FMT) { [EOL]                     formatDescription = parseFormatDescription(pattern, next(pos)); [EOL]                     format = getFormat(formatDescription); [EOL]                     if (format == null) { [EOL]                         stripCustom.append(START_FMT).append(formatDescription); [EOL]                     } [EOL]                 } [EOL]                 foundFormats.add(format); [EOL]                 foundDescriptions.add(format == null ? null : formatDescription); [EOL]                 Validate.isTrue(foundFormats.size() == fmtCount); [EOL]                 Validate.isTrue(foundDescriptions.size() == fmtCount); [EOL]                 if (c[pos.getIndex()] != END_FE) { [EOL]                     throw new IllegalArgumentException("Unreadable format element at position " + start); [EOL]                 } [EOL]             default: [EOL]                 stripCustom.append(c[pos.getIndex()]); [EOL]                 next(pos); [EOL]         } [EOL]     } [EOL]     super.applyPattern(stripCustom.toString()); [EOL]     toPattern = insertFormats(super.toPattern(), foundDescriptions); [EOL]     if (containsElements(foundFormats)) { [EOL]         final Format[] origFormats = getFormats(); [EOL]         int i = 0; [EOL]         for (final Iterator<Format> it = foundFormats.iterator(); it.hasNext(); i++) { [EOL]             final Format f = it.next(); [EOL]             if (f != null) { [EOL]                 origFormats[i] = f; [EOL]             } [EOL]         } [EOL]         super.setFormats(origFormats); [EOL]     } [EOL] } 
 [LINE] seekNonWs(pattern, pos); [LINE] @Override [EOL] public final void applyPattern(final String pattern) { [EOL]     if (registry == null) { [EOL]         super.applyPattern(pattern); [EOL]         toPattern = super.toPattern(); [EOL]         return; [EOL]     } [EOL]     final ArrayList<Format> foundFormats = new ArrayList<Format>(); [EOL]     final ArrayList<String> foundDescriptions = new ArrayList<String>(); [EOL]     final StringBuilder stripCustom = new StringBuilder(pattern.length()); [EOL]     final ParsePosition pos = new ParsePosition(0); [EOL]     final char[] c = pattern.toCharArray(); [EOL]     int fmtCount = 0; [EOL]     while (pos.getIndex() < pattern.length()) { [EOL]         switch(c[pos.getIndex()]) { [EOL]             case QUOTE: [EOL]                 appendQuotedString(pattern, pos, stripCustom, true); [EOL]                 break; [EOL]             case START_FE: [EOL]                 fmtCount++; [EOL]                 seekNonWs(pattern, pos); [EOL]                 final int start = pos.getIndex(); [EOL]                 final int index = readArgumentIndex(pattern, next(pos)); [EOL]                 stripCustom.append(START_FE).append(index); [EOL]                 seekNonWs(pattern, pos); [EOL]                 Format format = null; [EOL]                 String formatDescription = null; [EOL]                 if (c[pos.getIndex()] == START_FMT) { [EOL]                     formatDescription = parseFormatDescription(pattern, next(pos)); [EOL]                     format = getFormat(formatDescription); [EOL]                     if (format == null) { [EOL]                         stripCustom.append(START_FMT).append(formatDescription); [EOL]                     } [EOL]                 } [EOL]                 foundFormats.add(format); [EOL]                 foundDescriptions.add(format == null ? null : formatDescription); [EOL]                 Validate.isTrue(foundFormats.size() == fmtCount); [EOL]                 Validate.isTrue(foundDescriptions.size() == fmtCount); [EOL]                 if (c[pos.getIndex()] != END_FE) { [EOL]                     throw new IllegalArgumentException("Unreadable format element at position " + start); [EOL]                 } [EOL]             default: [EOL]                 stripCustom.append(c[pos.getIndex()]); [EOL]                 next(pos); [EOL]         } [EOL]     } [EOL]     super.applyPattern(stripCustom.toString()); [EOL]     toPattern = insertFormats(super.toPattern(), foundDescriptions); [EOL]     if (containsElements(foundFormats)) { [EOL]         final Format[] origFormats = getFormats(); [EOL]         int i = 0; [EOL]         for (final Iterator<Format> it = foundFormats.iterator(); it.hasNext(); i++) { [EOL]             final Format f = it.next(); [EOL]             if (f != null) { [EOL]                 origFormats[i] = f; [EOL]             } [EOL]         } [EOL]         super.setFormats(origFormats); [EOL]     } [EOL] } 
 [LINE] Format format = null; [LINE] @Override [EOL] public final void applyPattern(final String pattern) { [EOL]     if (registry == null) { [EOL]         super.applyPattern(pattern); [EOL]         toPattern = super.toPattern(); [EOL]         return; [EOL]     } [EOL]     final ArrayList<Format> foundFormats = new ArrayList<Format>(); [EOL]     final ArrayList<String> foundDescriptions = new ArrayList<String>(); [EOL]     final StringBuilder stripCustom = new StringBuilder(pattern.length()); [EOL]     final ParsePosition pos = new ParsePosition(0); [EOL]     final char[] c = pattern.toCharArray(); [EOL]     int fmtCount = 0; [EOL]     while (pos.getIndex() < pattern.length()) { [EOL]         switch(c[pos.getIndex()]) { [EOL]             case QUOTE: [EOL]                 appendQuotedString(pattern, pos, stripCustom, true); [EOL]                 break; [EOL]             case START_FE: [EOL]                 fmtCount++; [EOL]                 seekNonWs(pattern, pos); [EOL]                 final int start = pos.getIndex(); [EOL]                 final int index = readArgumentIndex(pattern, next(pos)); [EOL]                 stripCustom.append(START_FE).append(index); [EOL]                 seekNonWs(pattern, pos); [EOL]                 Format format = null; [EOL]                 String formatDescription = null; [EOL]                 if (c[pos.getIndex()] == START_FMT) { [EOL]                     formatDescription = parseFormatDescription(pattern, next(pos)); [EOL]                     format = getFormat(formatDescription); [EOL]                     if (format == null) { [EOL]                         stripCustom.append(START_FMT).append(formatDescription); [EOL]                     } [EOL]                 } [EOL]                 foundFormats.add(format); [EOL]                 foundDescriptions.add(format == null ? null : formatDescription); [EOL]                 Validate.isTrue(foundFormats.size() == fmtCount); [EOL]                 Validate.isTrue(foundDescriptions.size() == fmtCount); [EOL]                 if (c[pos.getIndex()] != END_FE) { [EOL]                     throw new IllegalArgumentException("Unreadable format element at position " + start); [EOL]                 } [EOL]             default: [EOL]                 stripCustom.append(c[pos.getIndex()]); [EOL]                 next(pos); [EOL]         } [EOL]     } [EOL]     super.applyPattern(stripCustom.toString()); [EOL]     toPattern = insertFormats(super.toPattern(), foundDescriptions); [EOL]     if (containsElements(foundFormats)) { [EOL]         final Format[] origFormats = getFormats(); [EOL]         int i = 0; [EOL]         for (final Iterator<Format> it = foundFormats.iterator(); it.hasNext(); i++) { [EOL]             final Format f = it.next(); [EOL]             if (f != null) { [EOL]                 origFormats[i] = f; [EOL]             } [EOL]         } [EOL]         super.setFormats(origFormats); [EOL]     } [EOL] } 
 [LINE] foundDescriptions.add(format == null ? null : formatDescription); [LINE] @Override [EOL] public final void applyPattern(final String pattern) { [EOL]     if (registry == null) { [EOL]         super.applyPattern(pattern); [EOL]         toPattern = super.toPattern(); [EOL]         return; [EOL]     } [EOL]     final ArrayList<Format> foundFormats = new ArrayList<Format>(); [EOL]     final ArrayList<String> foundDescriptions = new ArrayList<String>(); [EOL]     final StringBuilder stripCustom = new StringBuilder(pattern.length()); [EOL]     final ParsePosition pos = new ParsePosition(0); [EOL]     final char[] c = pattern.toCharArray(); [EOL]     int fmtCount = 0; [EOL]     while (pos.getIndex() < pattern.length()) { [EOL]         switch(c[pos.getIndex()]) { [EOL]             case QUOTE: [EOL]                 appendQuotedString(pattern, pos, stripCustom, true); [EOL]                 break; [EOL]             case START_FE: [EOL]                 fmtCount++; [EOL]                 seekNonWs(pattern, pos); [EOL]                 final int start = pos.getIndex(); [EOL]                 final int index = readArgumentIndex(pattern, next(pos)); [EOL]                 stripCustom.append(START_FE).append(index); [EOL]                 seekNonWs(pattern, pos); [EOL]                 Format format = null; [EOL]                 String formatDescription = null; [EOL]                 if (c[pos.getIndex()] == START_FMT) { [EOL]                     formatDescription = parseFormatDescription(pattern, next(pos)); [EOL]                     format = getFormat(formatDescription); [EOL]                     if (format == null) { [EOL]                         stripCustom.append(START_FMT).append(formatDescription); [EOL]                     } [EOL]                 } [EOL]                 foundFormats.add(format); [EOL]                 foundDescriptions.add(format == null ? null : formatDescription); [EOL]                 Validate.isTrue(foundFormats.size() == fmtCount); [EOL]                 Validate.isTrue(foundDescriptions.size() == fmtCount); [EOL]                 if (c[pos.getIndex()] != END_FE) { [EOL]                     throw new IllegalArgumentException("Unreadable format element at position " + start); [EOL]                 } [EOL]             default: [EOL]                 stripCustom.append(c[pos.getIndex()]); [EOL]                 next(pos); [EOL]         } [EOL]     } [EOL]     super.applyPattern(stripCustom.toString()); [EOL]     toPattern = insertFormats(super.toPattern(), foundDescriptions); [EOL]     if (containsElements(foundFormats)) { [EOL]         final Format[] origFormats = getFormats(); [EOL]         int i = 0; [EOL]         for (final Iterator<Format> it = foundFormats.iterator(); it.hasNext(); i++) { [EOL]             final Format f = it.next(); [EOL]             if (f != null) { [EOL]                 origFormats[i] = f; [EOL]             } [EOL]         } [EOL]         super.setFormats(origFormats); [EOL]     } [EOL] } 
 [LINE] if (c[pos.getIndex()] != END_FE) { [LINE] @Override [EOL] public final void applyPattern(final String pattern) { [EOL]     if (registry == null) { [EOL]         super.applyPattern(pattern); [EOL]         toPattern = super.toPattern(); [EOL]         return; [EOL]     } [EOL]     final ArrayList<Format> foundFormats = new ArrayList<Format>(); [EOL]     final ArrayList<String> foundDescriptions = new ArrayList<String>(); [EOL]     final StringBuilder stripCustom = new StringBuilder(pattern.length()); [EOL]     final ParsePosition pos = new ParsePosition(0); [EOL]     final char[] c = pattern.toCharArray(); [EOL]     int fmtCount = 0; [EOL]     while (pos.getIndex() < pattern.length()) { [EOL]         switch(c[pos.getIndex()]) { [EOL]             case QUOTE: [EOL]                 appendQuotedString(pattern, pos, stripCustom, true); [EOL]                 break; [EOL]             case START_FE: [EOL]                 fmtCount++; [EOL]                 seekNonWs(pattern, pos); [EOL]                 final int start = pos.getIndex(); [EOL]                 final int index = readArgumentIndex(pattern, next(pos)); [EOL]                 stripCustom.append(START_FE).append(index); [EOL]                 seekNonWs(pattern, pos); [EOL]                 Format format = null; [EOL]                 String formatDescription = null; [EOL]                 if (c[pos.getIndex()] == START_FMT) { [EOL]                     formatDescription = parseFormatDescription(pattern, next(pos)); [EOL]                     format = getFormat(formatDescription); [EOL]                     if (format == null) { [EOL]                         stripCustom.append(START_FMT).append(formatDescription); [EOL]                     } [EOL]                 } [EOL]                 foundFormats.add(format); [EOL]                 foundDescriptions.add(format == null ? null : formatDescription); [EOL]                 Validate.isTrue(foundFormats.size() == fmtCount); [EOL]                 Validate.isTrue(foundDescriptions.size() == fmtCount); [EOL]                 if (c[pos.getIndex()] != END_FE) { [EOL]                     throw new IllegalArgumentException("Unreadable format element at position " + start); [EOL]                 } [EOL]             default: [EOL]                 stripCustom.append(c[pos.getIndex()]); [EOL]                 next(pos); [EOL]         } [EOL]     } [EOL]     super.applyPattern(stripCustom.toString()); [EOL]     toPattern = insertFormats(super.toPattern(), foundDescriptions); [EOL]     if (containsElements(foundFormats)) { [EOL]         final Format[] origFormats = getFormats(); [EOL]         int i = 0; [EOL]         for (final Iterator<Format> it = foundFormats.iterator(); it.hasNext(); i++) { [EOL]             final Format f = it.next(); [EOL]             if (f != null) { [EOL]                 origFormats[i] = f; [EOL]             } [EOL]         } [EOL]         super.setFormats(origFormats); [EOL]     } [EOL] } 
 [LINE] default: [LINE] @Override [EOL] public final void applyPattern(final String pattern) { [EOL]     if (registry == null) { [EOL]         super.applyPattern(pattern); [EOL]         toPattern = super.toPattern(); [EOL]         return; [EOL]     } [EOL]     final ArrayList<Format> foundFormats = new ArrayList<Format>(); [EOL]     final ArrayList<String> foundDescriptions = new ArrayList<String>(); [EOL]     final StringBuilder stripCustom = new StringBuilder(pattern.length()); [EOL]     final ParsePosition pos = new ParsePosition(0); [EOL]     final char[] c = pattern.toCharArray(); [EOL]     int fmtCount = 0; [EOL]     while (pos.getIndex() < pattern.length()) { [EOL]         switch(c[pos.getIndex()]) { [EOL]             case QUOTE: [EOL]                 appendQuotedString(pattern, pos, stripCustom, true); [EOL]                 break; [EOL]             case START_FE: [EOL]                 fmtCount++; [EOL]                 seekNonWs(pattern, pos); [EOL]                 final int start = pos.getIndex(); [EOL]                 final int index = readArgumentIndex(pattern, next(pos)); [EOL]                 stripCustom.append(START_FE).append(index); [EOL]                 seekNonWs(pattern, pos); [EOL]                 Format format = null; [EOL]                 String formatDescription = null; [EOL]                 if (c[pos.getIndex()] == START_FMT) { [EOL]                     formatDescription = parseFormatDescription(pattern, next(pos)); [EOL]                     format = getFormat(formatDescription); [EOL]                     if (format == null) { [EOL]                         stripCustom.append(START_FMT).append(formatDescription); [EOL]                     } [EOL]                 } [EOL]                 foundFormats.add(format); [EOL]                 foundDescriptions.add(format == null ? null : formatDescription); [EOL]                 Validate.isTrue(foundFormats.size() == fmtCount); [EOL]                 Validate.isTrue(foundDescriptions.size() == fmtCount); [EOL]                 if (c[pos.getIndex()] != END_FE) { [EOL]                     throw new IllegalArgumentException("Unreadable format element at position " + start); [EOL]                 } [EOL]             default: [EOL]                 stripCustom.append(c[pos.getIndex()]); [EOL]                 next(pos); [EOL]         } [EOL]     } [EOL]     super.applyPattern(stripCustom.toString()); [EOL]     toPattern = insertFormats(super.toPattern(), foundDescriptions); [EOL]     if (containsElements(foundFormats)) { [EOL]         final Format[] origFormats = getFormats(); [EOL]         int i = 0; [EOL]         for (final Iterator<Format> it = foundFormats.iterator(); it.hasNext(); i++) { [EOL]             final Format f = it.next(); [EOL]             if (f != null) { [EOL]                 origFormats[i] = f; [EOL]             } [EOL]         } [EOL]         super.setFormats(origFormats); [EOL]     } [EOL] } 
 [LINE] stripCustom.append(c[pos.getIndex()]); [LINE] @Override [EOL] public final void applyPattern(final String pattern) { [EOL]     if (registry == null) { [EOL]         super.applyPattern(pattern); [EOL]         toPattern = super.toPattern(); [EOL]         return; [EOL]     } [EOL]     final ArrayList<Format> foundFormats = new ArrayList<Format>(); [EOL]     final ArrayList<String> foundDescriptions = new ArrayList<String>(); [EOL]     final StringBuilder stripCustom = new StringBuilder(pattern.length()); [EOL]     final ParsePosition pos = new ParsePosition(0); [EOL]     final char[] c = pattern.toCharArray(); [EOL]     int fmtCount = 0; [EOL]     while (pos.getIndex() < pattern.length()) { [EOL]         switch(c[pos.getIndex()]) { [EOL]             case QUOTE: [EOL]                 appendQuotedString(pattern, pos, stripCustom, true); [EOL]                 break; [EOL]             case START_FE: [EOL]                 fmtCount++; [EOL]                 seekNonWs(pattern, pos); [EOL]                 final int start = pos.getIndex(); [EOL]                 final int index = readArgumentIndex(pattern, next(pos)); [EOL]                 stripCustom.append(START_FE).append(index); [EOL]                 seekNonWs(pattern, pos); [EOL]                 Format format = null; [EOL]                 String formatDescription = null; [EOL]                 if (c[pos.getIndex()] == START_FMT) { [EOL]                     formatDescription = parseFormatDescription(pattern, next(pos)); [EOL]                     format = getFormat(formatDescription); [EOL]                     if (format == null) { [EOL]                         stripCustom.append(START_FMT).append(formatDescription); [EOL]                     } [EOL]                 } [EOL]                 foundFormats.add(format); [EOL]                 foundDescriptions.add(format == null ? null : formatDescription); [EOL]                 Validate.isTrue(foundFormats.size() == fmtCount); [EOL]                 Validate.isTrue(foundDescriptions.size() == fmtCount); [EOL]                 if (c[pos.getIndex()] != END_FE) { [EOL]                     throw new IllegalArgumentException("Unreadable format element at position " + start); [EOL]                 } [EOL]             default: [EOL]                 stripCustom.append(c[pos.getIndex()]); [EOL]                 next(pos); [EOL]         } [EOL]     } [EOL]     super.applyPattern(stripCustom.toString()); [EOL]     toPattern = insertFormats(super.toPattern(), foundDescriptions); [EOL]     if (containsElements(foundFormats)) { [EOL]         final Format[] origFormats = getFormats(); [EOL]         int i = 0; [EOL]         for (final Iterator<Format> it = foundFormats.iterator(); it.hasNext(); i++) { [EOL]             final Format f = it.next(); [EOL]             if (f != null) { [EOL]                 origFormats[i] = f; [EOL]             } [EOL]         } [EOL]         super.setFormats(origFormats); [EOL]     } [EOL] } 
 [LINE] toPattern = insertFormats(super.toPattern(), foundDescriptions); [LINE] @Override [EOL] public final void applyPattern(final String pattern) { [EOL]     if (registry == null) { [EOL]         super.applyPattern(pattern); [EOL]         toPattern = super.toPattern(); [EOL]         return; [EOL]     } [EOL]     final ArrayList<Format> foundFormats = new ArrayList<Format>(); [EOL]     final ArrayList<String> foundDescriptions = new ArrayList<String>(); [EOL]     final StringBuilder stripCustom = new StringBuilder(pattern.length()); [EOL]     final ParsePosition pos = new ParsePosition(0); [EOL]     final char[] c = pattern.toCharArray(); [EOL]     int fmtCount = 0; [EOL]     while (pos.getIndex() < pattern.length()) { [EOL]         switch(c[pos.getIndex()]) { [EOL]             case QUOTE: [EOL]                 appendQuotedString(pattern, pos, stripCustom, true); [EOL]                 break; [EOL]             case START_FE: [EOL]                 fmtCount++; [EOL]                 seekNonWs(pattern, pos); [EOL]                 final int start = pos.getIndex(); [EOL]                 final int index = readArgumentIndex(pattern, next(pos)); [EOL]                 stripCustom.append(START_FE).append(index); [EOL]                 seekNonWs(pattern, pos); [EOL]                 Format format = null; [EOL]                 String formatDescription = null; [EOL]                 if (c[pos.getIndex()] == START_FMT) { [EOL]                     formatDescription = parseFormatDescription(pattern, next(pos)); [EOL]                     format = getFormat(formatDescription); [EOL]                     if (format == null) { [EOL]                         stripCustom.append(START_FMT).append(formatDescription); [EOL]                     } [EOL]                 } [EOL]                 foundFormats.add(format); [EOL]                 foundDescriptions.add(format == null ? null : formatDescription); [EOL]                 Validate.isTrue(foundFormats.size() == fmtCount); [EOL]                 Validate.isTrue(foundDescriptions.size() == fmtCount); [EOL]                 if (c[pos.getIndex()] != END_FE) { [EOL]                     throw new IllegalArgumentException("Unreadable format element at position " + start); [EOL]                 } [EOL]             default: [EOL]                 stripCustom.append(c[pos.getIndex()]); [EOL]                 next(pos); [EOL]         } [EOL]     } [EOL]     super.applyPattern(stripCustom.toString()); [EOL]     toPattern = insertFormats(super.toPattern(), foundDescriptions); [EOL]     if (containsElements(foundFormats)) { [EOL]         final Format[] origFormats = getFormats(); [EOL]         int i = 0; [EOL]         for (final Iterator<Format> it = foundFormats.iterator(); it.hasNext(); i++) { [EOL]             final Format f = it.next(); [EOL]             if (f != null) { [EOL]                 origFormats[i] = f; [EOL]             } [EOL]         } [EOL]         super.setFormats(origFormats); [EOL]     } [EOL] } 
 [LINE] final Format[] origFormats = getFormats(); [LINE] @Override [EOL] public final void applyPattern(final String pattern) { [EOL]     if (registry == null) { [EOL]         super.applyPattern(pattern); [EOL]         toPattern = super.toPattern(); [EOL]         return; [EOL]     } [EOL]     final ArrayList<Format> foundFormats = new ArrayList<Format>(); [EOL]     final ArrayList<String> foundDescriptions = new ArrayList<String>(); [EOL]     final StringBuilder stripCustom = new StringBuilder(pattern.length()); [EOL]     final ParsePosition pos = new ParsePosition(0); [EOL]     final char[] c = pattern.toCharArray(); [EOL]     int fmtCount = 0; [EOL]     while (pos.getIndex() < pattern.length()) { [EOL]         switch(c[pos.getIndex()]) { [EOL]             case QUOTE: [EOL]                 appendQuotedString(pattern, pos, stripCustom, true); [EOL]                 break; [EOL]             case START_FE: [EOL]                 fmtCount++; [EOL]                 seekNonWs(pattern, pos); [EOL]                 final int start = pos.getIndex(); [EOL]                 final int index = readArgumentIndex(pattern, next(pos)); [EOL]                 stripCustom.append(START_FE).append(index); [EOL]                 seekNonWs(pattern, pos); [EOL]                 Format format = null; [EOL]                 String formatDescription = null; [EOL]                 if (c[pos.getIndex()] == START_FMT) { [EOL]                     formatDescription = parseFormatDescription(pattern, next(pos)); [EOL]                     format = getFormat(formatDescription); [EOL]                     if (format == null) { [EOL]                         stripCustom.append(START_FMT).append(formatDescription); [EOL]                     } [EOL]                 } [EOL]                 foundFormats.add(format); [EOL]                 foundDescriptions.add(format == null ? null : formatDescription); [EOL]                 Validate.isTrue(foundFormats.size() == fmtCount); [EOL]                 Validate.isTrue(foundDescriptions.size() == fmtCount); [EOL]                 if (c[pos.getIndex()] != END_FE) { [EOL]                     throw new IllegalArgumentException("Unreadable format element at position " + start); [EOL]                 } [EOL]             default: [EOL]                 stripCustom.append(c[pos.getIndex()]); [EOL]                 next(pos); [EOL]         } [EOL]     } [EOL]     super.applyPattern(stripCustom.toString()); [EOL]     toPattern = insertFormats(super.toPattern(), foundDescriptions); [EOL]     if (containsElements(foundFormats)) { [EOL]         final Format[] origFormats = getFormats(); [EOL]         int i = 0; [EOL]         for (final Iterator<Format> it = foundFormats.iterator(); it.hasNext(); i++) { [EOL]             final Format f = it.next(); [EOL]             if (f != null) { [EOL]                 origFormats[i] = f; [EOL]             } [EOL]         } [EOL]         super.setFormats(origFormats); [EOL]     } [EOL] } 
 [LINE] super.setFormats(origFormats); [LINE] @Override [EOL] public final void applyPattern(final String pattern) { [EOL]     if (registry == null) { [EOL]         super.applyPattern(pattern); [EOL]         toPattern = super.toPattern(); [EOL]         return; [EOL]     } [EOL]     final ArrayList<Format> foundFormats = new ArrayList<Format>(); [EOL]     final ArrayList<String> foundDescriptions = new ArrayList<String>(); [EOL]     final StringBuilder stripCustom = new StringBuilder(pattern.length()); [EOL]     final ParsePosition pos = new ParsePosition(0); [EOL]     final char[] c = pattern.toCharArray(); [EOL]     int fmtCount = 0; [EOL]     while (pos.getIndex() < pattern.length()) { [EOL]         switch(c[pos.getIndex()]) { [EOL]             case QUOTE: [EOL]                 appendQuotedString(pattern, pos, stripCustom, true); [EOL]                 break; [EOL]             case START_FE: [EOL]                 fmtCount++; [EOL]                 seekNonWs(pattern, pos); [EOL]                 final int start = pos.getIndex(); [EOL]                 final int index = readArgumentIndex(pattern, next(pos)); [EOL]                 stripCustom.append(START_FE).append(index); [EOL]                 seekNonWs(pattern, pos); [EOL]                 Format format = null; [EOL]                 String formatDescription = null; [EOL]                 if (c[pos.getIndex()] == START_FMT) { [EOL]                     formatDescription = parseFormatDescription(pattern, next(pos)); [EOL]                     format = getFormat(formatDescription); [EOL]                     if (format == null) { [EOL]                         stripCustom.append(START_FMT).append(formatDescription); [EOL]                     } [EOL]                 } [EOL]                 foundFormats.add(format); [EOL]                 foundDescriptions.add(format == null ? null : formatDescription); [EOL]                 Validate.isTrue(foundFormats.size() == fmtCount); [EOL]                 Validate.isTrue(foundDescriptions.size() == fmtCount); [EOL]                 if (c[pos.getIndex()] != END_FE) { [EOL]                     throw new IllegalArgumentException("Unreadable format element at position " + start); [EOL]                 } [EOL]             default: [EOL]                 stripCustom.append(c[pos.getIndex()]); [EOL]                 next(pos); [EOL]         } [EOL]     } [EOL]     super.applyPattern(stripCustom.toString()); [EOL]     toPattern = insertFormats(super.toPattern(), foundDescriptions); [EOL]     if (containsElements(foundFormats)) { [EOL]         final Format[] origFormats = getFormats(); [EOL]         int i = 0; [EOL]         for (final Iterator<Format> it = foundFormats.iterator(); it.hasNext(); i++) { [EOL]             final Format f = it.next(); [EOL]             if (f != null) { [EOL]                 origFormats[i] = f; [EOL]             } [EOL]         } [EOL]         super.setFormats(origFormats); [EOL]     } [EOL] } 
 [LINE] return true; [LINE] @Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } [EOL]     if (obj == null) { [EOL]         return false; [EOL]     } [EOL]     if (!super.equals(obj)) { [EOL]         return false; [EOL]     } [EOL]     if (ObjectUtils.notEqual(getClass(), obj.getClass())) { [EOL]         return false; [EOL]     } [EOL]     final ExtendedMessageFormat rhs = (ExtendedMessageFormat) obj; [EOL]     if (ObjectUtils.notEqual(toPattern, rhs.toPattern)) { [EOL]         return false; [EOL]     } [EOL]     if (ObjectUtils.notEqual(registry, rhs.registry)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] if (!super.equals(obj)) { [LINE] @Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } [EOL]     if (obj == null) { [EOL]         return false; [EOL]     } [EOL]     if (!super.equals(obj)) { [EOL]         return false; [EOL]     } [EOL]     if (ObjectUtils.notEqual(getClass(), obj.getClass())) { [EOL]         return false; [EOL]     } [EOL]     final ExtendedMessageFormat rhs = (ExtendedMessageFormat) obj; [EOL]     if (ObjectUtils.notEqual(toPattern, rhs.toPattern)) { [EOL]         return false; [EOL]     } [EOL]     if (ObjectUtils.notEqual(registry, rhs.registry)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] @Override [LINE] @Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } [EOL]     if (obj == null) { [EOL]         return false; [EOL]     } [EOL]     if (!super.equals(obj)) { [EOL]         return false; [EOL]     } [EOL]     if (ObjectUtils.notEqual(getClass(), obj.getClass())) { [EOL]         return false; [EOL]     } [EOL]     final ExtendedMessageFormat rhs = (ExtendedMessageFormat) obj; [EOL]     if (ObjectUtils.notEqual(toPattern, rhs.toPattern)) { [EOL]         return false; [EOL]     } [EOL]     if (ObjectUtils.notEqual(registry, rhs.registry)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] seekNonWs(pattern, pos); [LINE] private int readArgumentIndex(final String pattern, final ParsePosition pos) { [EOL]     final int start = pos.getIndex(); [EOL]     seekNonWs(pattern, pos); [EOL]     final StringBuilder result = new StringBuilder(); [EOL]     boolean error = false; [EOL]     for (; !error && pos.getIndex() < pattern.length(); next(pos)) { [EOL]         char c = pattern.charAt(pos.getIndex()); [EOL]         if (Character.isWhitespace(c)) { [EOL]             seekNonWs(pattern, pos); [EOL]             c = pattern.charAt(pos.getIndex()); [EOL]             if (c != START_FMT && c != END_FE) { [EOL]                 error = true; [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         if ((c == START_FMT || c == END_FE) && result.length() > 0) { [EOL]             try { [EOL]                 return Integer.parseInt(result.toString()); [EOL]             } catch (final NumberFormatException e) { [EOL]             } [EOL]         } [EOL]         error = !Character.isDigit(c); [EOL]         result.append(c); [EOL]     } [EOL]     if (error) { [EOL]         throw new IllegalArgumentException("Invalid format argument index at position " + start + ": " + pattern.substring(start, pos.getIndex())); [EOL]     } [EOL]     throw new IllegalArgumentException("Unterminated format element at position " + start); [EOL] } 
 [LINE] final int text = pos.getIndex(); [LINE] private String parseFormatDescription(final String pattern, final ParsePosition pos) { [EOL]     final int start = pos.getIndex(); [EOL]     seekNonWs(pattern, pos); [EOL]     final int text = pos.getIndex(); [EOL]     int depth = 1; [EOL]     for (; pos.getIndex() < pattern.length(); next(pos)) { [EOL]         switch(pattern.charAt(pos.getIndex())) { [EOL]             case START_FE: [EOL]                 depth++; [EOL]                 break; [EOL]             case END_FE: [EOL]                 depth--; [EOL]                 if (depth == 0) { [EOL]                     return pattern.substring(text, pos.getIndex()); [EOL]                 } [EOL]                 break; [EOL]             case QUOTE: [EOL]                 getQuotedString(pattern, pos, false); [EOL]                 break; [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("Unterminated format element at position " + start); [EOL] } 
 [LINE] final ParsePosition pos = new ParsePosition(0); [LINE] private String insertFormats(final String pattern, final ArrayList<String> customPatterns) { [EOL]     if (!containsElements(customPatterns)) { [EOL]         return pattern; [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(pattern.length() * 2); [EOL]     final ParsePosition pos = new ParsePosition(0); [EOL]     int fe = -1; [EOL]     int depth = 0; [EOL]     while (pos.getIndex() < pattern.length()) { [EOL]         final char c = pattern.charAt(pos.getIndex()); [EOL]         switch(c) { [EOL]             case QUOTE: [EOL]                 appendQuotedString(pattern, pos, sb, false); [EOL]                 break; [EOL]             case START_FE: [EOL]                 depth++; [EOL]                 if (depth == 1) { [EOL]                     fe++; [EOL]                     sb.append(START_FE).append(readArgumentIndex(pattern, next(pos))); [EOL]                     final String customPattern = customPatterns.get(fe); [EOL]                     if (customPattern != null) { [EOL]                         sb.append(START_FMT).append(customPattern); [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             case END_FE: [EOL]                 depth--; [EOL]             default: [EOL]                 sb.append(c); [EOL]                 next(pos); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] } 
 [LINE] final char c = pattern.charAt(pos.getIndex()); [LINE] private String insertFormats(final String pattern, final ArrayList<String> customPatterns) { [EOL]     if (!containsElements(customPatterns)) { [EOL]         return pattern; [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(pattern.length() * 2); [EOL]     final ParsePosition pos = new ParsePosition(0); [EOL]     int fe = -1; [EOL]     int depth = 0; [EOL]     while (pos.getIndex() < pattern.length()) { [EOL]         final char c = pattern.charAt(pos.getIndex()); [EOL]         switch(c) { [EOL]             case QUOTE: [EOL]                 appendQuotedString(pattern, pos, sb, false); [EOL]                 break; [EOL]             case START_FE: [EOL]                 depth++; [EOL]                 if (depth == 1) { [EOL]                     fe++; [EOL]                     sb.append(START_FE).append(readArgumentIndex(pattern, next(pos))); [EOL]                     final String customPattern = customPatterns.get(fe); [EOL]                     if (customPattern != null) { [EOL]                         sb.append(START_FMT).append(customPattern); [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             case END_FE: [EOL]                 depth--; [EOL]             default: [EOL]                 sb.append(c); [EOL]                 next(pos); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] } 
 [LINE] depth++; [LINE] private String insertFormats(final String pattern, final ArrayList<String> customPatterns) { [EOL]     if (!containsElements(customPatterns)) { [EOL]         return pattern; [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(pattern.length() * 2); [EOL]     final ParsePosition pos = new ParsePosition(0); [EOL]     int fe = -1; [EOL]     int depth = 0; [EOL]     while (pos.getIndex() < pattern.length()) { [EOL]         final char c = pattern.charAt(pos.getIndex()); [EOL]         switch(c) { [EOL]             case QUOTE: [EOL]                 appendQuotedString(pattern, pos, sb, false); [EOL]                 break; [EOL]             case START_FE: [EOL]                 depth++; [EOL]                 if (depth == 1) { [EOL]                     fe++; [EOL]                     sb.append(START_FE).append(readArgumentIndex(pattern, next(pos))); [EOL]                     final String customPattern = customPatterns.get(fe); [EOL]                     if (customPattern != null) { [EOL]                         sb.append(START_FMT).append(customPattern); [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             case END_FE: [EOL]                 depth--; [EOL]             default: [EOL]                 sb.append(c); [EOL]                 next(pos); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] } 
 [LINE] final char[] buffer = pattern.toCharArray(); [LINE] private void seekNonWs(final String pattern, final ParsePosition pos) { [EOL]     int len = 0; [EOL]     final char[] buffer = pattern.toCharArray(); [EOL]     do { [EOL]         len = StrMatcher.splitMatcher().isMatch(buffer, pos.getIndex()); [EOL]         pos.setIndex(pos.getIndex() + len); [EOL]     } while (len > 0 && pos.getIndex() < pattern.length()); [EOL] } 
 [LINE] final int start = pos.getIndex(); [LINE] private StringBuilder appendQuotedString(final String pattern, final ParsePosition pos, final StringBuilder appendTo, final boolean escapingOn) { [EOL]     final int start = pos.getIndex(); [EOL]     final char[] c = pattern.toCharArray(); [EOL]     if (escapingOn && c[start] == QUOTE) { [EOL]         next(pos); [EOL]         return appendTo == null ? null : appendTo.append(QUOTE); [EOL]     } [EOL]     int lastHold = start; [EOL]     for (int i = pos.getIndex(); i < pattern.length(); i++) { [EOL]         if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) { [EOL]             appendTo.append(c, lastHold, pos.getIndex() - lastHold).append(QUOTE); [EOL]             pos.setIndex(i + ESCAPED_QUOTE.length()); [EOL]             lastHold = pos.getIndex(); [EOL]             continue; [EOL]         } [EOL]         switch(c[pos.getIndex()]) { [EOL]             case QUOTE: [EOL]                 next(pos); [EOL]                 return appendTo == null ? null : appendTo.append(c, lastHold, pos.getIndex() - lastHold); [EOL]             default: [EOL]                 next(pos); [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("Unterminated quoted string at position " + start); [EOL] } 
 [LINE] if (escapingOn && c[start] == QUOTE) { [LINE] private StringBuilder appendQuotedString(final String pattern, final ParsePosition pos, final StringBuilder appendTo, final boolean escapingOn) { [EOL]     final int start = pos.getIndex(); [EOL]     final char[] c = pattern.toCharArray(); [EOL]     if (escapingOn && c[start] == QUOTE) { [EOL]         next(pos); [EOL]         return appendTo == null ? null : appendTo.append(QUOTE); [EOL]     } [EOL]     int lastHold = start; [EOL]     for (int i = pos.getIndex(); i < pattern.length(); i++) { [EOL]         if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) { [EOL]             appendTo.append(c, lastHold, pos.getIndex() - lastHold).append(QUOTE); [EOL]             pos.setIndex(i + ESCAPED_QUOTE.length()); [EOL]             lastHold = pos.getIndex(); [EOL]             continue; [EOL]         } [EOL]         switch(c[pos.getIndex()]) { [EOL]             case QUOTE: [EOL]                 next(pos); [EOL]                 return appendTo == null ? null : appendTo.append(c, lastHold, pos.getIndex() - lastHold); [EOL]             default: [EOL]                 next(pos); [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("Unterminated quoted string at position " + start); [EOL] } 
 [LINE] next(pos); [LINE] private StringBuilder appendQuotedString(final String pattern, final ParsePosition pos, final StringBuilder appendTo, final boolean escapingOn) { [EOL]     final int start = pos.getIndex(); [EOL]     final char[] c = pattern.toCharArray(); [EOL]     if (escapingOn && c[start] == QUOTE) { [EOL]         next(pos); [EOL]         return appendTo == null ? null : appendTo.append(QUOTE); [EOL]     } [EOL]     int lastHold = start; [EOL]     for (int i = pos.getIndex(); i < pattern.length(); i++) { [EOL]         if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) { [EOL]             appendTo.append(c, lastHold, pos.getIndex() - lastHold).append(QUOTE); [EOL]             pos.setIndex(i + ESCAPED_QUOTE.length()); [EOL]             lastHold = pos.getIndex(); [EOL]             continue; [EOL]         } [EOL]         switch(c[pos.getIndex()]) { [EOL]             case QUOTE: [EOL]                 next(pos); [EOL]                 return appendTo == null ? null : appendTo.append(c, lastHold, pos.getIndex() - lastHold); [EOL]             default: [EOL]                 next(pos); [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("Unterminated quoted string at position " + start); [EOL] } 
 [LINE] if (name != null) { [LINE] private boolean containsElements(final Collection<?> coll) { [EOL]     if (coll == null || coll.isEmpty()) { [EOL]         return false; [EOL]     } [EOL]     for (final Object name : coll) { [EOL]         if (name != null) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } 
lang3/ClassUtils.java
 [LINE] return valueIfNull; [LINE] public static String getShortClassName(final Object object, final String valueIfNull) { [EOL]     if (object == null) { [EOL]         return valueIfNull; [EOL]     } [EOL]     return getShortClassName(object.getClass()); [EOL] } 
 [LINE] return getShortClassName(cls.getName()); [LINE] public static String getShortClassName(final Class<?> cls) { [EOL]     if (cls == null) { [EOL]         return StringUtils.EMPTY; [EOL]     } [EOL]     return getShortClassName(cls.getName()); [EOL] } 
 [LINE] return StringUtils.EMPTY; [LINE] public static String getShortClassName(String className) { [EOL]     if (StringUtils.isEmpty(className)) { [EOL]         return StringUtils.EMPTY; [EOL]     } [EOL]     final StringBuilder arrayPrefix = new StringBuilder(); [EOL]     if (className.startsWith("[")) { [EOL]         while (className.charAt(0) == '[') { [EOL]             className = className.substring(1); [EOL]             arrayPrefix.append("[]"); [EOL]         } [EOL]         if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') { [EOL]             className = className.substring(1, className.length() - 1); [EOL]         } [EOL]         if (reverseAbbreviationMap.containsKey(className)) { [EOL]             className = reverseAbbreviationMap.get(className); [EOL]         } [EOL]     } [EOL]     final int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); [EOL]     final int innerIdx = className.indexOf(INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1); [EOL]     String out = className.substring(lastDotIdx + 1); [EOL]     if (innerIdx != -1) { [EOL]         out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); [EOL]     } [EOL]     return out + arrayPrefix; [EOL] } 
 [LINE] className = className.substring(1); [LINE] public static String getShortClassName(String className) { [EOL]     if (StringUtils.isEmpty(className)) { [EOL]         return StringUtils.EMPTY; [EOL]     } [EOL]     final StringBuilder arrayPrefix = new StringBuilder(); [EOL]     if (className.startsWith("[")) { [EOL]         while (className.charAt(0) == '[') { [EOL]             className = className.substring(1); [EOL]             arrayPrefix.append("[]"); [EOL]         } [EOL]         if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') { [EOL]             className = className.substring(1, className.length() - 1); [EOL]         } [EOL]         if (reverseAbbreviationMap.containsKey(className)) { [EOL]             className = reverseAbbreviationMap.get(className); [EOL]         } [EOL]     } [EOL]     final int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); [EOL]     final int innerIdx = className.indexOf(INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1); [EOL]     String out = className.substring(lastDotIdx + 1); [EOL]     if (innerIdx != -1) { [EOL]         out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); [EOL]     } [EOL]     return out + arrayPrefix; [EOL] } 
 [LINE] if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') { [LINE] public static String getShortClassName(String className) { [EOL]     if (StringUtils.isEmpty(className)) { [EOL]         return StringUtils.EMPTY; [EOL]     } [EOL]     final StringBuilder arrayPrefix = new StringBuilder(); [EOL]     if (className.startsWith("[")) { [EOL]         while (className.charAt(0) == '[') { [EOL]             className = className.substring(1); [EOL]             arrayPrefix.append("[]"); [EOL]         } [EOL]         if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') { [EOL]             className = className.substring(1, className.length() - 1); [EOL]         } [EOL]         if (reverseAbbreviationMap.containsKey(className)) { [EOL]             className = reverseAbbreviationMap.get(className); [EOL]         } [EOL]     } [EOL]     final int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); [EOL]     final int innerIdx = className.indexOf(INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1); [EOL]     String out = className.substring(lastDotIdx + 1); [EOL]     if (innerIdx != -1) { [EOL]         out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); [EOL]     } [EOL]     return out + arrayPrefix; [EOL] } 
 [LINE] INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1); [LINE] public static String getShortClassName(String className) { [EOL]     if (StringUtils.isEmpty(className)) { [EOL]         return StringUtils.EMPTY; [EOL]     } [EOL]     final StringBuilder arrayPrefix = new StringBuilder(); [EOL]     if (className.startsWith("[")) { [EOL]         while (className.charAt(0) == '[') { [EOL]             className = className.substring(1); [EOL]             arrayPrefix.append("[]"); [EOL]         } [EOL]         if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') { [EOL]             className = className.substring(1, className.length() - 1); [EOL]         } [EOL]         if (reverseAbbreviationMap.containsKey(className)) { [EOL]             className = reverseAbbreviationMap.get(className); [EOL]         } [EOL]     } [EOL]     final int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); [EOL]     final int innerIdx = className.indexOf(INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1); [EOL]     String out = className.substring(lastDotIdx + 1); [EOL]     if (innerIdx != -1) { [EOL]         out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); [EOL]     } [EOL]     return out + arrayPrefix; [EOL] } 
 [LINE] if (innerIdx != -1) { [LINE] public static String getShortClassName(String className) { [EOL]     if (StringUtils.isEmpty(className)) { [EOL]         return StringUtils.EMPTY; [EOL]     } [EOL]     final StringBuilder arrayPrefix = new StringBuilder(); [EOL]     if (className.startsWith("[")) { [EOL]         while (className.charAt(0) == '[') { [EOL]             className = className.substring(1); [EOL]             arrayPrefix.append("[]"); [EOL]         } [EOL]         if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') { [EOL]             className = className.substring(1, className.length() - 1); [EOL]         } [EOL]         if (reverseAbbreviationMap.containsKey(className)) { [EOL]             className = reverseAbbreviationMap.get(className); [EOL]         } [EOL]     } [EOL]     final int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); [EOL]     final int innerIdx = className.indexOf(INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1); [EOL]     String out = className.substring(lastDotIdx + 1); [EOL]     if (innerIdx != -1) { [EOL]         out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); [EOL]     } [EOL]     return out + arrayPrefix; [EOL] } 
 [LINE] out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); [LINE] public static String getShortClassName(String className) { [EOL]     if (StringUtils.isEmpty(className)) { [EOL]         return StringUtils.EMPTY; [EOL]     } [EOL]     final StringBuilder arrayPrefix = new StringBuilder(); [EOL]     if (className.startsWith("[")) { [EOL]         while (className.charAt(0) == '[') { [EOL]             className = className.substring(1); [EOL]             arrayPrefix.append("[]"); [EOL]         } [EOL]         if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') { [EOL]             className = className.substring(1, className.length() - 1); [EOL]         } [EOL]         if (reverseAbbreviationMap.containsKey(className)) { [EOL]             className = reverseAbbreviationMap.get(className); [EOL]         } [EOL]     } [EOL]     final int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); [EOL]     final int innerIdx = className.indexOf(INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1); [EOL]     String out = className.substring(lastDotIdx + 1); [EOL]     if (innerIdx != -1) { [EOL]         out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); [EOL]     } [EOL]     return out + arrayPrefix; [EOL] } 
 [LINE] return out + arrayPrefix; [LINE] public static String getShortClassName(String className) { [EOL]     if (StringUtils.isEmpty(className)) { [EOL]         return StringUtils.EMPTY; [EOL]     } [EOL]     final StringBuilder arrayPrefix = new StringBuilder(); [EOL]     if (className.startsWith("[")) { [EOL]         while (className.charAt(0) == '[') { [EOL]             className = className.substring(1); [EOL]             arrayPrefix.append("[]"); [EOL]         } [EOL]         if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') { [EOL]             className = className.substring(1, className.length() - 1); [EOL]         } [EOL]         if (reverseAbbreviationMap.containsKey(className)) { [EOL]             className = reverseAbbreviationMap.get(className); [EOL]         } [EOL]     } [EOL]     final int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); [EOL]     final int innerIdx = className.indexOf(INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1); [EOL]     String out = className.substring(lastDotIdx + 1); [EOL]     if (innerIdx != -1) { [EOL]         out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); [EOL]     } [EOL]     return out + arrayPrefix; [EOL] } 
 [LINE] return valueIfNull; [LINE] public static String getPackageName(final Object object, final String valueIfNull) { [EOL]     if (object == null) { [EOL]         return valueIfNull; [EOL]     } [EOL]     return getPackageName(object.getClass()); [EOL] } 
 [LINE] return StringUtils.EMPTY; [LINE] public static String getPackageName(String className) { [EOL]     if (StringUtils.isEmpty(className)) { [EOL]         return StringUtils.EMPTY; [EOL]     } [EOL]     while (className.charAt(0) == '[') { [EOL]         className = className.substring(1); [EOL]     } [EOL]     if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') { [EOL]         className = className.substring(1); [EOL]     } [EOL]     final int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); [EOL]     if (i == -1) { [EOL]         return StringUtils.EMPTY; [EOL]     } [EOL]     return className.substring(0, i); [EOL] } 
 [LINE] if (i == -1) { [LINE] public static String getPackageName(String className) { [EOL]     if (StringUtils.isEmpty(className)) { [EOL]         return StringUtils.EMPTY; [EOL]     } [EOL]     while (className.charAt(0) == '[') { [EOL]         className = className.substring(1); [EOL]     } [EOL]     if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') { [EOL]         className = className.substring(1); [EOL]     } [EOL]     final int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); [EOL]     if (i == -1) { [EOL]         return StringUtils.EMPTY; [EOL]     } [EOL]     return className.substring(0, i); [EOL] } 
 [LINE] return null; [LINE] public static List<Class<?>> getAllSuperclasses(final Class<?> cls) { [EOL]     if (cls == null) { [EOL]         return null; [EOL]     } [EOL]     final List<Class<?>> classes = new ArrayList<Class<?>>(); [EOL]     Class<?> superclass = cls.getSuperclass(); [EOL]     while (superclass != null) { [EOL]         classes.add(superclass); [EOL]         superclass = superclass.getSuperclass(); [EOL]     } [EOL]     return classes; [EOL] } 
 [LINE] while (superclass != null) { [LINE] public static List<Class<?>> getAllSuperclasses(final Class<?> cls) { [EOL]     if (cls == null) { [EOL]         return null; [EOL]     } [EOL]     final List<Class<?>> classes = new ArrayList<Class<?>>(); [EOL]     Class<?> superclass = cls.getSuperclass(); [EOL]     while (superclass != null) { [EOL]         classes.add(superclass); [EOL]         superclass = superclass.getSuperclass(); [EOL]     } [EOL]     return classes; [EOL] } 
 [LINE] while (cls != null) { [LINE] private static void getAllInterfaces(Class<?> cls, final HashSet<Class<?>> interfacesFound) { [EOL]     while (cls != null) { [EOL]         final Class<?>[] interfaces = cls.getInterfaces(); [EOL]         for (final Class<?> i : interfaces) { [EOL]             if (interfacesFound.add(i)) { [EOL]                 getAllInterfaces(i, interfacesFound); [EOL]             } [EOL]         } [EOL]         cls = cls.getSuperclass(); [EOL]     } [EOL] } 
 [LINE] cls = cls.getSuperclass(); [LINE] private static void getAllInterfaces(Class<?> cls, final HashSet<Class<?>> interfacesFound) { [EOL]     while (cls != null) { [EOL]         final Class<?>[] interfaces = cls.getInterfaces(); [EOL]         for (final Class<?> i : interfaces) { [EOL]             if (interfacesFound.add(i)) { [EOL]                 getAllInterfaces(i, interfacesFound); [EOL]             } [EOL]         } [EOL]         cls = cls.getSuperclass(); [EOL]     } [EOL] } 
 [LINE] final List<Class<?>> classes = new ArrayList<Class<?>>(classNames.size()); [LINE] public static List<Class<?>> convertClassNamesToClasses(final List<String> classNames) { [EOL]     if (classNames == null) { [EOL]         return null; [EOL]     } [EOL]     final List<Class<?>> classes = new ArrayList<Class<?>>(classNames.size()); [EOL]     for (final String className : classNames) { [EOL]         try { [EOL]             classes.add(Class.forName(className)); [EOL]         } catch (final Exception ex) { [EOL]             classes.add(null); [EOL]         } [EOL]     } [EOL]     return classes; [EOL] } 
 [LINE] try { [LINE] public static List<Class<?>> convertClassNamesToClasses(final List<String> classNames) { [EOL]     if (classNames == null) { [EOL]         return null; [EOL]     } [EOL]     final List<Class<?>> classes = new ArrayList<Class<?>>(classNames.size()); [EOL]     for (final String className : classNames) { [EOL]         try { [EOL]             classes.add(Class.forName(className)); [EOL]         } catch (final Exception ex) { [EOL]             classes.add(null); [EOL]         } [EOL]     } [EOL]     return classes; [EOL] } 
 [LINE] return classNames; [LINE] public static List<String> convertClassesToClassNames(final List<Class<?>> classes) { [EOL]     if (classes == null) { [EOL]         return null; [EOL]     } [EOL]     final List<String> classNames = new ArrayList<String>(classes.size()); [EOL]     for (final Class<?> cls : classes) { [EOL]         if (cls == null) { [EOL]             classNames.add(null); [EOL]         } else { [EOL]             classNames.add(cls.getName()); [EOL]         } [EOL]     } [EOL]     return classNames; [EOL] } 
 [LINE] classArray = ArrayUtils.EMPTY_CLASS_ARRAY; [LINE] public static boolean isAssignable(Class<?>[] classArray, Class<?>[] toClassArray, final boolean autoboxing) { [EOL]     if (ArrayUtils.isSameLength(classArray, toClassArray) == false) { [EOL]         return false; [EOL]     } [EOL]     if (classArray == null) { [EOL]         classArray = ArrayUtils.EMPTY_CLASS_ARRAY; [EOL]     } [EOL]     if (toClassArray == null) { [EOL]         toClassArray = ArrayUtils.EMPTY_CLASS_ARRAY; [EOL]     } [EOL]     for (int i = 0; i < classArray.length; i++) { [EOL]         if (isAssignable(classArray[i], toClassArray[i], autoboxing) == false) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] if (type == null) { [LINE] public static boolean isPrimitiveOrWrapper(final Class<?> type) { [EOL]     if (type == null) { [EOL]         return false; [EOL]     } [EOL]     return type.isPrimitive() || isPrimitiveWrapper(type); [EOL] } 
 [LINE] return false; [LINE] public static boolean isPrimitiveOrWrapper(final Class<?> type) { [EOL]     if (type == null) { [EOL]         return false; [EOL]     } [EOL]     return type.isPrimitive() || isPrimitiveWrapper(type); [EOL] } 
 [LINE] if (toClass == null) { [LINE] public static boolean isAssignable(Class<?> cls, final Class<?> toClass, final boolean autoboxing) { [EOL]     if (toClass == null) { [EOL]         return false; [EOL]     } [EOL]     if (cls == null) { [EOL]         return !toClass.isPrimitive(); [EOL]     } [EOL]     if (autoboxing) { [EOL]         if (cls.isPrimitive() && !toClass.isPrimitive()) { [EOL]             cls = primitiveToWrapper(cls); [EOL]             if (cls == null) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         if (toClass.isPrimitive() && !cls.isPrimitive()) { [EOL]             cls = wrapperToPrimitive(cls); [EOL]             if (cls == null) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (cls.equals(toClass)) { [EOL]         return true; [EOL]     } [EOL]     if (cls.isPrimitive()) { [EOL]         if (toClass.isPrimitive() == false) { [EOL]             return false; [EOL]         } [EOL]         if (Integer.TYPE.equals(cls)) { [EOL]             return Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Long.TYPE.equals(cls)) { [EOL]             return Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Boolean.TYPE.equals(cls)) { [EOL]             return false; [EOL]         } [EOL]         if (Double.TYPE.equals(cls)) { [EOL]             return false; [EOL]         } [EOL]         if (Float.TYPE.equals(cls)) { [EOL]             return Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Character.TYPE.equals(cls)) { [EOL]             return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Short.TYPE.equals(cls)) { [EOL]             return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Byte.TYPE.equals(cls)) { [EOL]             return Short.TYPE.equals(toClass) || Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return toClass.isAssignableFrom(cls); [EOL] } 
 [LINE] if (cls == null) { [LINE] public static boolean isAssignable(Class<?> cls, final Class<?> toClass, final boolean autoboxing) { [EOL]     if (toClass == null) { [EOL]         return false; [EOL]     } [EOL]     if (cls == null) { [EOL]         return !toClass.isPrimitive(); [EOL]     } [EOL]     if (autoboxing) { [EOL]         if (cls.isPrimitive() && !toClass.isPrimitive()) { [EOL]             cls = primitiveToWrapper(cls); [EOL]             if (cls == null) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         if (toClass.isPrimitive() && !cls.isPrimitive()) { [EOL]             cls = wrapperToPrimitive(cls); [EOL]             if (cls == null) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (cls.equals(toClass)) { [EOL]         return true; [EOL]     } [EOL]     if (cls.isPrimitive()) { [EOL]         if (toClass.isPrimitive() == false) { [EOL]             return false; [EOL]         } [EOL]         if (Integer.TYPE.equals(cls)) { [EOL]             return Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Long.TYPE.equals(cls)) { [EOL]             return Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Boolean.TYPE.equals(cls)) { [EOL]             return false; [EOL]         } [EOL]         if (Double.TYPE.equals(cls)) { [EOL]             return false; [EOL]         } [EOL]         if (Float.TYPE.equals(cls)) { [EOL]             return Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Character.TYPE.equals(cls)) { [EOL]             return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Short.TYPE.equals(cls)) { [EOL]             return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Byte.TYPE.equals(cls)) { [EOL]             return Short.TYPE.equals(toClass) || Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return toClass.isAssignableFrom(cls); [EOL] } 
 [LINE] return !toClass.isPrimitive(); [LINE] public static boolean isAssignable(Class<?> cls, final Class<?> toClass, final boolean autoboxing) { [EOL]     if (toClass == null) { [EOL]         return false; [EOL]     } [EOL]     if (cls == null) { [EOL]         return !toClass.isPrimitive(); [EOL]     } [EOL]     if (autoboxing) { [EOL]         if (cls.isPrimitive() && !toClass.isPrimitive()) { [EOL]             cls = primitiveToWrapper(cls); [EOL]             if (cls == null) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         if (toClass.isPrimitive() && !cls.isPrimitive()) { [EOL]             cls = wrapperToPrimitive(cls); [EOL]             if (cls == null) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (cls.equals(toClass)) { [EOL]         return true; [EOL]     } [EOL]     if (cls.isPrimitive()) { [EOL]         if (toClass.isPrimitive() == false) { [EOL]             return false; [EOL]         } [EOL]         if (Integer.TYPE.equals(cls)) { [EOL]             return Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Long.TYPE.equals(cls)) { [EOL]             return Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Boolean.TYPE.equals(cls)) { [EOL]             return false; [EOL]         } [EOL]         if (Double.TYPE.equals(cls)) { [EOL]             return false; [EOL]         } [EOL]         if (Float.TYPE.equals(cls)) { [EOL]             return Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Character.TYPE.equals(cls)) { [EOL]             return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Short.TYPE.equals(cls)) { [EOL]             return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Byte.TYPE.equals(cls)) { [EOL]             return Short.TYPE.equals(toClass) || Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return toClass.isAssignableFrom(cls); [EOL] } 
 [LINE] return Short.TYPE.equals(toClass) [LINE] public static boolean isAssignable(Class<?> cls, final Class<?> toClass, final boolean autoboxing) { [EOL]     if (toClass == null) { [EOL]         return false; [EOL]     } [EOL]     if (cls == null) { [EOL]         return !toClass.isPrimitive(); [EOL]     } [EOL]     if (autoboxing) { [EOL]         if (cls.isPrimitive() && !toClass.isPrimitive()) { [EOL]             cls = primitiveToWrapper(cls); [EOL]             if (cls == null) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         if (toClass.isPrimitive() && !cls.isPrimitive()) { [EOL]             cls = wrapperToPrimitive(cls); [EOL]             if (cls == null) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (cls.equals(toClass)) { [EOL]         return true; [EOL]     } [EOL]     if (cls.isPrimitive()) { [EOL]         if (toClass.isPrimitive() == false) { [EOL]             return false; [EOL]         } [EOL]         if (Integer.TYPE.equals(cls)) { [EOL]             return Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Long.TYPE.equals(cls)) { [EOL]             return Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Boolean.TYPE.equals(cls)) { [EOL]             return false; [EOL]         } [EOL]         if (Double.TYPE.equals(cls)) { [EOL]             return false; [EOL]         } [EOL]         if (Float.TYPE.equals(cls)) { [EOL]             return Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Character.TYPE.equals(cls)) { [EOL]             return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Short.TYPE.equals(cls)) { [EOL]             return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Byte.TYPE.equals(cls)) { [EOL]             return Short.TYPE.equals(toClass) || Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return toClass.isAssignableFrom(cls); [EOL] } 
 [LINE] if (classes == null) { [LINE] public static Class<?>[] primitivesToWrappers(final Class<?>... classes) { [EOL]     if (classes == null) { [EOL]         return null; [EOL]     } [EOL]     if (classes.length == 0) { [EOL]         return classes; [EOL]     } [EOL]     final Class<?>[] convertedClasses = new Class[classes.length]; [EOL]     for (int i = 0; i < classes.length; i++) { [EOL]         convertedClasses[i] = primitiveToWrapper(classes[i]); [EOL]     } [EOL]     return convertedClasses; [EOL] } 
 [LINE] final Class<?>[] convertedClasses = new Class[classes.length]; [LINE] public static Class<?>[] primitivesToWrappers(final Class<?>... classes) { [EOL]     if (classes == null) { [EOL]         return null; [EOL]     } [EOL]     if (classes.length == 0) { [EOL]         return classes; [EOL]     } [EOL]     final Class<?>[] convertedClasses = new Class[classes.length]; [EOL]     for (int i = 0; i < classes.length; i++) { [EOL]         convertedClasses[i] = primitiveToWrapper(classes[i]); [EOL]     } [EOL]     return convertedClasses; [EOL] } 
 [LINE] if (classes == null) { [LINE] public static Class<?>[] wrappersToPrimitives(final Class<?>... classes) { [EOL]     if (classes == null) { [EOL]         return null; [EOL]     } [EOL]     if (classes.length == 0) { [EOL]         return classes; [EOL]     } [EOL]     final Class<?>[] convertedClasses = new Class[classes.length]; [EOL]     for (int i = 0; i < classes.length; i++) { [EOL]         convertedClasses[i] = wrapperToPrimitive(classes[i]); [EOL]     } [EOL]     return convertedClasses; [EOL] } 
 [LINE] return null; [LINE] public static Class<?>[] wrappersToPrimitives(final Class<?>... classes) { [EOL]     if (classes == null) { [EOL]         return null; [EOL]     } [EOL]     if (classes.length == 0) { [EOL]         return classes; [EOL]     } [EOL]     final Class<?>[] convertedClasses = new Class[classes.length]; [EOL]     for (int i = 0; i < classes.length; i++) { [EOL]         convertedClasses[i] = wrapperToPrimitive(classes[i]); [EOL]     } [EOL]     return convertedClasses; [EOL] } 
 [LINE] return cls != null && cls.getEnclosingClass() != null; [LINE] public static boolean isInnerClass(final Class<?> cls) { [EOL]     return cls != null && cls.getEnclosingClass() != null; [EOL] } 
 [LINE] try { [LINE] public static Class<?> getClass(final ClassLoader classLoader, final String className, final boolean initialize) throws ClassNotFoundException { [EOL]     try { [EOL]         Class<?> clazz; [EOL]         if (abbreviationMap.containsKey(className)) { [EOL]             final String clsName = "[" + abbreviationMap.get(className); [EOL]             clazz = Class.forName(clsName, initialize, classLoader).getComponentType(); [EOL]         } else { [EOL]             clazz = Class.forName(toCanonicalName(className), initialize, classLoader); [EOL]         } [EOL]         return clazz; [EOL]     } catch (final ClassNotFoundException ex) { [EOL]         final int lastDotIndex = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); [EOL]         if (lastDotIndex != -1) { [EOL]             try { [EOL]                 return getClass(classLoader, className.substring(0, lastDotIndex) + INNER_CLASS_SEPARATOR_CHAR + className.substring(lastDotIndex + 1), initialize); [EOL]             } catch (final ClassNotFoundException ex2) { [EOL]             } [EOL]         } [EOL]         throw ex; [EOL]     } [EOL] } 
 [LINE] Class<?> clazz; [LINE] public static Class<?> getClass(final ClassLoader classLoader, final String className, final boolean initialize) throws ClassNotFoundException { [EOL]     try { [EOL]         Class<?> clazz; [EOL]         if (abbreviationMap.containsKey(className)) { [EOL]             final String clsName = "[" + abbreviationMap.get(className); [EOL]             clazz = Class.forName(clsName, initialize, classLoader).getComponentType(); [EOL]         } else { [EOL]             clazz = Class.forName(toCanonicalName(className), initialize, classLoader); [EOL]         } [EOL]         return clazz; [EOL]     } catch (final ClassNotFoundException ex) { [EOL]         final int lastDotIndex = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); [EOL]         if (lastDotIndex != -1) { [EOL]             try { [EOL]                 return getClass(classLoader, className.substring(0, lastDotIndex) + INNER_CLASS_SEPARATOR_CHAR + className.substring(lastDotIndex + 1), initialize); [EOL]             } catch (final ClassNotFoundException ex2) { [EOL]             } [EOL]         } [EOL]         throw ex; [EOL]     } [EOL] } 
 [LINE] if (abbreviationMap.containsKey(className)) { [LINE] public static Class<?> getClass(final ClassLoader classLoader, final String className, final boolean initialize) throws ClassNotFoundException { [EOL]     try { [EOL]         Class<?> clazz; [EOL]         if (abbreviationMap.containsKey(className)) { [EOL]             final String clsName = "[" + abbreviationMap.get(className); [EOL]             clazz = Class.forName(clsName, initialize, classLoader).getComponentType(); [EOL]         } else { [EOL]             clazz = Class.forName(toCanonicalName(className), initialize, classLoader); [EOL]         } [EOL]         return clazz; [EOL]     } catch (final ClassNotFoundException ex) { [EOL]         final int lastDotIndex = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); [EOL]         if (lastDotIndex != -1) { [EOL]             try { [EOL]                 return getClass(classLoader, className.substring(0, lastDotIndex) + INNER_CLASS_SEPARATOR_CHAR + className.substring(lastDotIndex + 1), initialize); [EOL]             } catch (final ClassNotFoundException ex2) { [EOL]             } [EOL]         } [EOL]         throw ex; [EOL]     } [EOL] } 
 [LINE] final String clsName = "[" + abbreviationMap.get(className); [LINE] public static Class<?> getClass(final ClassLoader classLoader, final String className, final boolean initialize) throws ClassNotFoundException { [EOL]     try { [EOL]         Class<?> clazz; [EOL]         if (abbreviationMap.containsKey(className)) { [EOL]             final String clsName = "[" + abbreviationMap.get(className); [EOL]             clazz = Class.forName(clsName, initialize, classLoader).getComponentType(); [EOL]         } else { [EOL]             clazz = Class.forName(toCanonicalName(className), initialize, classLoader); [EOL]         } [EOL]         return clazz; [EOL]     } catch (final ClassNotFoundException ex) { [EOL]         final int lastDotIndex = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); [EOL]         if (lastDotIndex != -1) { [EOL]             try { [EOL]                 return getClass(classLoader, className.substring(0, lastDotIndex) + INNER_CLASS_SEPARATOR_CHAR + className.substring(lastDotIndex + 1), initialize); [EOL]             } catch (final ClassNotFoundException ex2) { [EOL]             } [EOL]         } [EOL]         throw ex; [EOL]     } [EOL] } 
 [LINE] clazz = Class.forName(clsName, initialize, classLoader).getComponentType(); [LINE] public static Class<?> getClass(final ClassLoader classLoader, final String className, final boolean initialize) throws ClassNotFoundException { [EOL]     try { [EOL]         Class<?> clazz; [EOL]         if (abbreviationMap.containsKey(className)) { [EOL]             final String clsName = "[" + abbreviationMap.get(className); [EOL]             clazz = Class.forName(clsName, initialize, classLoader).getComponentType(); [EOL]         } else { [EOL]             clazz = Class.forName(toCanonicalName(className), initialize, classLoader); [EOL]         } [EOL]         return clazz; [EOL]     } catch (final ClassNotFoundException ex) { [EOL]         final int lastDotIndex = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); [EOL]         if (lastDotIndex != -1) { [EOL]             try { [EOL]                 return getClass(classLoader, className.substring(0, lastDotIndex) + INNER_CLASS_SEPARATOR_CHAR + className.substring(lastDotIndex + 1), initialize); [EOL]             } catch (final ClassNotFoundException ex2) { [EOL]             } [EOL]         } [EOL]         throw ex; [EOL]     } [EOL] } 
 [LINE] return clazz; [LINE] public static Class<?> getClass(final ClassLoader classLoader, final String className, final boolean initialize) throws ClassNotFoundException { [EOL]     try { [EOL]         Class<?> clazz; [EOL]         if (abbreviationMap.containsKey(className)) { [EOL]             final String clsName = "[" + abbreviationMap.get(className); [EOL]             clazz = Class.forName(clsName, initialize, classLoader).getComponentType(); [EOL]         } else { [EOL]             clazz = Class.forName(toCanonicalName(className), initialize, classLoader); [EOL]         } [EOL]         return clazz; [EOL]     } catch (final ClassNotFoundException ex) { [EOL]         final int lastDotIndex = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); [EOL]         if (lastDotIndex != -1) { [EOL]             try { [EOL]                 return getClass(classLoader, className.substring(0, lastDotIndex) + INNER_CLASS_SEPARATOR_CHAR + className.substring(lastDotIndex + 1), initialize); [EOL]             } catch (final ClassNotFoundException ex2) { [EOL]             } [EOL]         } [EOL]         throw ex; [EOL]     } [EOL] } 
 [LINE] if (Modifier.isPublic(declaredMethod.getDeclaringClass().getModifiers())) { [LINE] public static Method getPublicMethod(final Class<?> cls, final String methodName, final Class<?>... parameterTypes) throws SecurityException, NoSuchMethodException { [EOL]     final Method declaredMethod = cls.getMethod(methodName, parameterTypes); [EOL]     if (Modifier.isPublic(declaredMethod.getDeclaringClass().getModifiers())) { [EOL]         return declaredMethod; [EOL]     } [EOL]     final List<Class<?>> candidateClasses = new ArrayList<Class<?>>(); [EOL]     candidateClasses.addAll(getAllInterfaces(cls)); [EOL]     candidateClasses.addAll(getAllSuperclasses(cls)); [EOL]     for (final Class<?> candidateClass : candidateClasses) { [EOL]         if (!Modifier.isPublic(candidateClass.getModifiers())) { [EOL]             continue; [EOL]         } [EOL]         Method candidateMethod; [EOL]         try { [EOL]             candidateMethod = candidateClass.getMethod(methodName, parameterTypes); [EOL]         } catch (final NoSuchMethodException ex) { [EOL]             continue; [EOL]         } [EOL]         if (Modifier.isPublic(candidateMethod.getDeclaringClass().getModifiers())) { [EOL]             return candidateMethod; [EOL]         } [EOL]     } [EOL]     throw new NoSuchMethodException("Can't find a public method for " + methodName + " " + ArrayUtils.toString(parameterTypes)); [EOL] } 
 [LINE] return declaredMethod; [LINE] public static Method getPublicMethod(final Class<?> cls, final String methodName, final Class<?>... parameterTypes) throws SecurityException, NoSuchMethodException { [EOL]     final Method declaredMethod = cls.getMethod(methodName, parameterTypes); [EOL]     if (Modifier.isPublic(declaredMethod.getDeclaringClass().getModifiers())) { [EOL]         return declaredMethod; [EOL]     } [EOL]     final List<Class<?>> candidateClasses = new ArrayList<Class<?>>(); [EOL]     candidateClasses.addAll(getAllInterfaces(cls)); [EOL]     candidateClasses.addAll(getAllSuperclasses(cls)); [EOL]     for (final Class<?> candidateClass : candidateClasses) { [EOL]         if (!Modifier.isPublic(candidateClass.getModifiers())) { [EOL]             continue; [EOL]         } [EOL]         Method candidateMethod; [EOL]         try { [EOL]             candidateMethod = candidateClass.getMethod(methodName, parameterTypes); [EOL]         } catch (final NoSuchMethodException ex) { [EOL]             continue; [EOL]         } [EOL]         if (Modifier.isPublic(candidateMethod.getDeclaringClass().getModifiers())) { [EOL]             return candidateMethod; [EOL]         } [EOL]     } [EOL]     throw new NoSuchMethodException("Can't find a public method for " + methodName + " " + ArrayUtils.toString(parameterTypes)); [EOL] } 
 [LINE] final List<Class<?>> candidateClasses = new ArrayList<Class<?>>(); [LINE] public static Method getPublicMethod(final Class<?> cls, final String methodName, final Class<?>... parameterTypes) throws SecurityException, NoSuchMethodException { [EOL]     final Method declaredMethod = cls.getMethod(methodName, parameterTypes); [EOL]     if (Modifier.isPublic(declaredMethod.getDeclaringClass().getModifiers())) { [EOL]         return declaredMethod; [EOL]     } [EOL]     final List<Class<?>> candidateClasses = new ArrayList<Class<?>>(); [EOL]     candidateClasses.addAll(getAllInterfaces(cls)); [EOL]     candidateClasses.addAll(getAllSuperclasses(cls)); [EOL]     for (final Class<?> candidateClass : candidateClasses) { [EOL]         if (!Modifier.isPublic(candidateClass.getModifiers())) { [EOL]             continue; [EOL]         } [EOL]         Method candidateMethod; [EOL]         try { [EOL]             candidateMethod = candidateClass.getMethod(methodName, parameterTypes); [EOL]         } catch (final NoSuchMethodException ex) { [EOL]             continue; [EOL]         } [EOL]         if (Modifier.isPublic(candidateMethod.getDeclaringClass().getModifiers())) { [EOL]             return candidateMethod; [EOL]         } [EOL]     } [EOL]     throw new NoSuchMethodException("Can't find a public method for " + methodName + " " + ArrayUtils.toString(parameterTypes)); [EOL] } 
 [LINE] for (final Class<?> candidateClass : candidateClasses) { [LINE] public static Method getPublicMethod(final Class<?> cls, final String methodName, final Class<?>... parameterTypes) throws SecurityException, NoSuchMethodException { [EOL]     final Method declaredMethod = cls.getMethod(methodName, parameterTypes); [EOL]     if (Modifier.isPublic(declaredMethod.getDeclaringClass().getModifiers())) { [EOL]         return declaredMethod; [EOL]     } [EOL]     final List<Class<?>> candidateClasses = new ArrayList<Class<?>>(); [EOL]     candidateClasses.addAll(getAllInterfaces(cls)); [EOL]     candidateClasses.addAll(getAllSuperclasses(cls)); [EOL]     for (final Class<?> candidateClass : candidateClasses) { [EOL]         if (!Modifier.isPublic(candidateClass.getModifiers())) { [EOL]             continue; [EOL]         } [EOL]         Method candidateMethod; [EOL]         try { [EOL]             candidateMethod = candidateClass.getMethod(methodName, parameterTypes); [EOL]         } catch (final NoSuchMethodException ex) { [EOL]             continue; [EOL]         } [EOL]         if (Modifier.isPublic(candidateMethod.getDeclaringClass().getModifiers())) { [EOL]             return candidateMethod; [EOL]         } [EOL]     } [EOL]     throw new NoSuchMethodException("Can't find a public method for " + methodName + " " + ArrayUtils.toString(parameterTypes)); [EOL] } 
 [LINE] if (!Modifier.isPublic(candidateClass.getModifiers())) { [LINE] public static Method getPublicMethod(final Class<?> cls, final String methodName, final Class<?>... parameterTypes) throws SecurityException, NoSuchMethodException { [EOL]     final Method declaredMethod = cls.getMethod(methodName, parameterTypes); [EOL]     if (Modifier.isPublic(declaredMethod.getDeclaringClass().getModifiers())) { [EOL]         return declaredMethod; [EOL]     } [EOL]     final List<Class<?>> candidateClasses = new ArrayList<Class<?>>(); [EOL]     candidateClasses.addAll(getAllInterfaces(cls)); [EOL]     candidateClasses.addAll(getAllSuperclasses(cls)); [EOL]     for (final Class<?> candidateClass : candidateClasses) { [EOL]         if (!Modifier.isPublic(candidateClass.getModifiers())) { [EOL]             continue; [EOL]         } [EOL]         Method candidateMethod; [EOL]         try { [EOL]             candidateMethod = candidateClass.getMethod(methodName, parameterTypes); [EOL]         } catch (final NoSuchMethodException ex) { [EOL]             continue; [EOL]         } [EOL]         if (Modifier.isPublic(candidateMethod.getDeclaringClass().getModifiers())) { [EOL]             return candidateMethod; [EOL]         } [EOL]     } [EOL]     throw new NoSuchMethodException("Can't find a public method for " + methodName + " " + ArrayUtils.toString(parameterTypes)); [EOL] } 
 [LINE] return candidateMethod; [LINE] public static Method getPublicMethod(final Class<?> cls, final String methodName, final Class<?>... parameterTypes) throws SecurityException, NoSuchMethodException { [EOL]     final Method declaredMethod = cls.getMethod(methodName, parameterTypes); [EOL]     if (Modifier.isPublic(declaredMethod.getDeclaringClass().getModifiers())) { [EOL]         return declaredMethod; [EOL]     } [EOL]     final List<Class<?>> candidateClasses = new ArrayList<Class<?>>(); [EOL]     candidateClasses.addAll(getAllInterfaces(cls)); [EOL]     candidateClasses.addAll(getAllSuperclasses(cls)); [EOL]     for (final Class<?> candidateClass : candidateClasses) { [EOL]         if (!Modifier.isPublic(candidateClass.getModifiers())) { [EOL]             continue; [EOL]         } [EOL]         Method candidateMethod; [EOL]         try { [EOL]             candidateMethod = candidateClass.getMethod(methodName, parameterTypes); [EOL]         } catch (final NoSuchMethodException ex) { [EOL]             continue; [EOL]         } [EOL]         if (Modifier.isPublic(candidateMethod.getDeclaringClass().getModifiers())) { [EOL]             return candidateMethod; [EOL]         } [EOL]     } [EOL]     throw new NoSuchMethodException("Can't find a public method for " + methodName + " " + ArrayUtils.toString(parameterTypes)); [EOL] } 
 [LINE] className = StringUtils.deleteWhitespace(className); [LINE] private static String toCanonicalName(String className) { [EOL]     className = StringUtils.deleteWhitespace(className); [EOL]     if (className == null) { [EOL]         throw new NullPointerException("className must not be null."); [EOL]     } else if (className.endsWith("[]")) { [EOL]         final StringBuilder classNameBuffer = new StringBuilder(); [EOL]         while (className.endsWith("[]")) { [EOL]             className = className.substring(0, className.length() - 2); [EOL]             classNameBuffer.append("["); [EOL]         } [EOL]         final String abbreviation = abbreviationMap.get(className); [EOL]         if (abbreviation != null) { [EOL]             classNameBuffer.append(abbreviation); [EOL]         } else { [EOL]             classNameBuffer.append("L").append(className).append(";"); [EOL]         } [EOL]         className = classNameBuffer.toString(); [EOL]     } [EOL]     return className; [EOL] } 
 [LINE] } else if (className.endsWith("[]")) { [LINE] private static String toCanonicalName(String className) { [EOL]     className = StringUtils.deleteWhitespace(className); [EOL]     if (className == null) { [EOL]         throw new NullPointerException("className must not be null."); [EOL]     } else if (className.endsWith("[]")) { [EOL]         final StringBuilder classNameBuffer = new StringBuilder(); [EOL]         while (className.endsWith("[]")) { [EOL]             className = className.substring(0, className.length() - 2); [EOL]             classNameBuffer.append("["); [EOL]         } [EOL]         final String abbreviation = abbreviationMap.get(className); [EOL]         if (abbreviation != null) { [EOL]             classNameBuffer.append(abbreviation); [EOL]         } else { [EOL]             classNameBuffer.append("L").append(className).append(";"); [EOL]         } [EOL]         className = classNameBuffer.toString(); [EOL]     } [EOL]     return className; [EOL] } 
 [LINE] className = className.substring(0, className.length() - 2); [LINE] private static String toCanonicalName(String className) { [EOL]     className = StringUtils.deleteWhitespace(className); [EOL]     if (className == null) { [EOL]         throw new NullPointerException("className must not be null."); [EOL]     } else if (className.endsWith("[]")) { [EOL]         final StringBuilder classNameBuffer = new StringBuilder(); [EOL]         while (className.endsWith("[]")) { [EOL]             className = className.substring(0, className.length() - 2); [EOL]             classNameBuffer.append("["); [EOL]         } [EOL]         final String abbreviation = abbreviationMap.get(className); [EOL]         if (abbreviation != null) { [EOL]             classNameBuffer.append(abbreviation); [EOL]         } else { [EOL]             classNameBuffer.append("L").append(className).append(";"); [EOL]         } [EOL]         className = classNameBuffer.toString(); [EOL]     } [EOL]     return className; [EOL] } 
 [LINE] classNameBuffer.append("L").append(className).append(";"); [LINE] private static String toCanonicalName(String className) { [EOL]     className = StringUtils.deleteWhitespace(className); [EOL]     if (className == null) { [EOL]         throw new NullPointerException("className must not be null."); [EOL]     } else if (className.endsWith("[]")) { [EOL]         final StringBuilder classNameBuffer = new StringBuilder(); [EOL]         while (className.endsWith("[]")) { [EOL]             className = className.substring(0, className.length() - 2); [EOL]             classNameBuffer.append("["); [EOL]         } [EOL]         final String abbreviation = abbreviationMap.get(className); [EOL]         if (abbreviation != null) { [EOL]             classNameBuffer.append(abbreviation); [EOL]         } else { [EOL]             classNameBuffer.append("L").append(className).append(";"); [EOL]         } [EOL]         className = classNameBuffer.toString(); [EOL]     } [EOL]     return className; [EOL] } 
 [LINE] return className; [LINE] private static String toCanonicalName(String className) { [EOL]     className = StringUtils.deleteWhitespace(className); [EOL]     if (className == null) { [EOL]         throw new NullPointerException("className must not be null."); [EOL]     } else if (className.endsWith("[]")) { [EOL]         final StringBuilder classNameBuffer = new StringBuilder(); [EOL]         while (className.endsWith("[]")) { [EOL]             className = className.substring(0, className.length() - 2); [EOL]             classNameBuffer.append("["); [EOL]         } [EOL]         final String abbreviation = abbreviationMap.get(className); [EOL]         if (abbreviation != null) { [EOL]             classNameBuffer.append(abbreviation); [EOL]         } else { [EOL]             classNameBuffer.append("L").append(className).append(";"); [EOL]         } [EOL]         className = classNameBuffer.toString(); [EOL]     } [EOL]     return className; [EOL] } 
 [LINE] if (array == null) { [LINE] public static Class<?>[] toClass(final Object... array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return ArrayUtils.EMPTY_CLASS_ARRAY; [EOL]     } [EOL]     final Class<?>[] classes = new Class[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         classes[i] = array[i] == null ? null : array[i].getClass(); [EOL]     } [EOL]     return classes; [EOL] } 
 [LINE] classes[i] = array[i] == null ? null : array[i].getClass(); [LINE] public static Class<?>[] toClass(final Object... array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return ArrayUtils.EMPTY_CLASS_ARRAY; [EOL]     } [EOL]     final Class<?>[] classes = new Class[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         classes[i] = array[i] == null ? null : array[i].getClass(); [EOL]     } [EOL]     return classes; [EOL] } 
 [LINE] return classes; [LINE] public static Class<?>[] toClass(final Object... array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return ArrayUtils.EMPTY_CLASS_ARRAY; [EOL]     } [EOL]     final Class<?>[] classes = new Class[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         classes[i] = array[i] == null ? null : array[i].getClass(); [EOL]     } [EOL]     return classes; [EOL] } 
 [LINE] return ClassUtils.getPackageName(getCanonicalName(canonicalName)); [LINE] public static String getPackageCanonicalName(final String canonicalName) { [EOL]     return ClassUtils.getPackageName(getCanonicalName(canonicalName)); [EOL] } 
 [LINE] className = StringUtils.deleteWhitespace(className); [LINE] private static String getCanonicalName(String className) { [EOL]     className = StringUtils.deleteWhitespace(className); [EOL]     if (className == null) { [EOL]         return null; [EOL]     } else { [EOL]         int dim = 0; [EOL]         while (className.startsWith("[")) { [EOL]             dim++; [EOL]             className = className.substring(1); [EOL]         } [EOL]         if (dim < 1) { [EOL]             return className; [EOL]         } else { [EOL]             if (className.startsWith("L")) { [EOL]                 className = className.substring(1, className.endsWith(";") ? className.length() - 1 : className.length()); [EOL]             } else { [EOL]                 if (className.length() > 0) { [EOL]                     className = reverseAbbreviationMap.get(className.substring(0, 1)); [EOL]                 } [EOL]             } [EOL]             final StringBuilder canonicalClassNameBuffer = new StringBuilder(className); [EOL]             for (int i = 0; i < dim; i++) { [EOL]                 canonicalClassNameBuffer.append("[]"); [EOL]             } [EOL]             return canonicalClassNameBuffer.toString(); [EOL]         } [EOL]     } [EOL] } 
 [LINE] if (className == null) { [LINE] private static String getCanonicalName(String className) { [EOL]     className = StringUtils.deleteWhitespace(className); [EOL]     if (className == null) { [EOL]         return null; [EOL]     } else { [EOL]         int dim = 0; [EOL]         while (className.startsWith("[")) { [EOL]             dim++; [EOL]             className = className.substring(1); [EOL]         } [EOL]         if (dim < 1) { [EOL]             return className; [EOL]         } else { [EOL]             if (className.startsWith("L")) { [EOL]                 className = className.substring(1, className.endsWith(";") ? className.length() - 1 : className.length()); [EOL]             } else { [EOL]                 if (className.length() > 0) { [EOL]                     className = reverseAbbreviationMap.get(className.substring(0, 1)); [EOL]                 } [EOL]             } [EOL]             final StringBuilder canonicalClassNameBuffer = new StringBuilder(className); [EOL]             for (int i = 0; i < dim; i++) { [EOL]                 canonicalClassNameBuffer.append("[]"); [EOL]             } [EOL]             return canonicalClassNameBuffer.toString(); [EOL]         } [EOL]     } [EOL] } 
 [LINE] dim++; [LINE] private static String getCanonicalName(String className) { [EOL]     className = StringUtils.deleteWhitespace(className); [EOL]     if (className == null) { [EOL]         return null; [EOL]     } else { [EOL]         int dim = 0; [EOL]         while (className.startsWith("[")) { [EOL]             dim++; [EOL]             className = className.substring(1); [EOL]         } [EOL]         if (dim < 1) { [EOL]             return className; [EOL]         } else { [EOL]             if (className.startsWith("L")) { [EOL]                 className = className.substring(1, className.endsWith(";") ? className.length() - 1 : className.length()); [EOL]             } else { [EOL]                 if (className.length() > 0) { [EOL]                     className = reverseAbbreviationMap.get(className.substring(0, 1)); [EOL]                 } [EOL]             } [EOL]             final StringBuilder canonicalClassNameBuffer = new StringBuilder(className); [EOL]             for (int i = 0; i < dim; i++) { [EOL]                 canonicalClassNameBuffer.append("[]"); [EOL]             } [EOL]             return canonicalClassNameBuffer.toString(); [EOL]         } [EOL]     } [EOL] } 
 [LINE] className = reverseAbbreviationMap.get(className.substring(0, 1)); [LINE] private static String getCanonicalName(String className) { [EOL]     className = StringUtils.deleteWhitespace(className); [EOL]     if (className == null) { [EOL]         return null; [EOL]     } else { [EOL]         int dim = 0; [EOL]         while (className.startsWith("[")) { [EOL]             dim++; [EOL]             className = className.substring(1); [EOL]         } [EOL]         if (dim < 1) { [EOL]             return className; [EOL]         } else { [EOL]             if (className.startsWith("L")) { [EOL]                 className = className.substring(1, className.endsWith(";") ? className.length() - 1 : className.length()); [EOL]             } else { [EOL]                 if (className.length() > 0) { [EOL]                     className = reverseAbbreviationMap.get(className.substring(0, 1)); [EOL]                 } [EOL]             } [EOL]             final StringBuilder canonicalClassNameBuffer = new StringBuilder(className); [EOL]             for (int i = 0; i < dim; i++) { [EOL]                 canonicalClassNameBuffer.append("[]"); [EOL]             } [EOL]             return canonicalClassNameBuffer.toString(); [EOL]         } [EOL]     } [EOL] } 
 [LINE] return canonicalClassNameBuffer.toString(); [LINE] private static String getCanonicalName(String className) { [EOL]     className = StringUtils.deleteWhitespace(className); [EOL]     if (className == null) { [EOL]         return null; [EOL]     } else { [EOL]         int dim = 0; [EOL]         while (className.startsWith("[")) { [EOL]             dim++; [EOL]             className = className.substring(1); [EOL]         } [EOL]         if (dim < 1) { [EOL]             return className; [EOL]         } else { [EOL]             if (className.startsWith("L")) { [EOL]                 className = className.substring(1, className.endsWith(";") ? className.length() - 1 : className.length()); [EOL]             } else { [EOL]                 if (className.length() > 0) { [EOL]                     className = reverseAbbreviationMap.get(className.substring(0, 1)); [EOL]                 } [EOL]             } [EOL]             final StringBuilder canonicalClassNameBuffer = new StringBuilder(className); [EOL]             for (int i = 0; i < dim; i++) { [EOL]                 canonicalClassNameBuffer.append("[]"); [EOL]             } [EOL]             return canonicalClassNameBuffer.toString(); [EOL]         } [EOL]     } [EOL] } 
lang3/CharSequenceUtils.java
 [LINE] for (int i = start; i < sz; i++) { [LINE] static int indexOf(final CharSequence cs, final int searchChar, int start) { [EOL]     if (cs instanceof String) { [EOL]         return ((String) cs).indexOf(searchChar, start); [EOL]     } else { [EOL]         final int sz = cs.length(); [EOL]         if (start < 0) { [EOL]             start = 0; [EOL]         } [EOL]         for (int i = start; i < sz; i++) { [EOL]             if (cs.charAt(i) == searchChar) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]         return -1; [EOL]     } [EOL] } 
 [LINE] if (cs.charAt(i) == searchChar) { [LINE] static int indexOf(final CharSequence cs, final int searchChar, int start) { [EOL]     if (cs instanceof String) { [EOL]         return ((String) cs).indexOf(searchChar, start); [EOL]     } else { [EOL]         final int sz = cs.length(); [EOL]         if (start < 0) { [EOL]             start = 0; [EOL]         } [EOL]         for (int i = start; i < sz; i++) { [EOL]             if (cs.charAt(i) == searchChar) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]         return -1; [EOL]     } [EOL] } 
 [LINE] return ((String) cs).lastIndexOf(searchChar, start); [LINE] static int lastIndexOf(final CharSequence cs, final int searchChar, int start) { [EOL]     if (cs instanceof String) { [EOL]         return ((String) cs).lastIndexOf(searchChar, start); [EOL]     } else { [EOL]         final int sz = cs.length(); [EOL]         if (start < 0) { [EOL]             return -1; [EOL]         } [EOL]         if (start >= sz) { [EOL]             start = sz - 1; [EOL]         } [EOL]         for (int i = start; i >= 0; --i) { [EOL]             if (cs.charAt(i) == searchChar) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]         return -1; [EOL]     } [EOL] } 
 [LINE] if (start < 0) { [LINE] static int lastIndexOf(final CharSequence cs, final int searchChar, int start) { [EOL]     if (cs instanceof String) { [EOL]         return ((String) cs).lastIndexOf(searchChar, start); [EOL]     } else { [EOL]         final int sz = cs.length(); [EOL]         if (start < 0) { [EOL]             return -1; [EOL]         } [EOL]         if (start >= sz) { [EOL]             start = sz - 1; [EOL]         } [EOL]         for (int i = start; i >= 0; --i) { [EOL]             if (cs.charAt(i) == searchChar) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]         return -1; [EOL]     } [EOL] } 
 [LINE] if (cs.charAt(i) == searchChar) { [LINE] static int lastIndexOf(final CharSequence cs, final int searchChar, int start) { [EOL]     if (cs instanceof String) { [EOL]         return ((String) cs).lastIndexOf(searchChar, start); [EOL]     } else { [EOL]         final int sz = cs.length(); [EOL]         if (start < 0) { [EOL]             return -1; [EOL]         } [EOL]         if (start >= sz) { [EOL]             start = sz - 1; [EOL]         } [EOL]         for (int i = start; i >= 0; --i) { [EOL]             if (cs.charAt(i) == searchChar) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]         return -1; [EOL]     } [EOL] } 
 [LINE] if (cs instanceof String) { [LINE] static char[] toCharArray(final CharSequence cs) { [EOL]     if (cs instanceof String) { [EOL]         return ((String) cs).toCharArray(); [EOL]     } else { [EOL]         final int sz = cs.length(); [EOL]         final char[] array = new char[cs.length()]; [EOL]         for (int i = 0; i < sz; i++) { [EOL]             array[i] = cs.charAt(i); [EOL]         } [EOL]         return array; [EOL]     } [EOL] } 
 [LINE] continue; [LINE] static boolean regionMatches(final CharSequence cs, final boolean ignoreCase, final int thisStart, final CharSequence substring, final int start, final int length) { [EOL]     if (cs instanceof String && substring instanceof String) { [EOL]         return ((String) cs).regionMatches(ignoreCase, thisStart, (String) substring, start, length); [EOL]     } else { [EOL]         int index1 = thisStart; [EOL]         int index2 = start; [EOL]         int tmpLen = length; [EOL]         while (tmpLen-- > 0) { [EOL]             char c1 = cs.charAt(index1++); [EOL]             char c2 = substring.charAt(index2++); [EOL]             if (c1 == c2) { [EOL]                 continue; [EOL]             } [EOL]             if (!ignoreCase) { [EOL]                 return false; [EOL]             } [EOL]             if (Character.toUpperCase(c1) != Character.toUpperCase(c2) && Character.toLowerCase(c1) != Character.toLowerCase(c2)) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL] } 
 [LINE] return false; [LINE] static boolean regionMatches(final CharSequence cs, final boolean ignoreCase, final int thisStart, final CharSequence substring, final int start, final int length) { [EOL]     if (cs instanceof String && substring instanceof String) { [EOL]         return ((String) cs).regionMatches(ignoreCase, thisStart, (String) substring, start, length); [EOL]     } else { [EOL]         int index1 = thisStart; [EOL]         int index2 = start; [EOL]         int tmpLen = length; [EOL]         while (tmpLen-- > 0) { [EOL]             char c1 = cs.charAt(index1++); [EOL]             char c2 = substring.charAt(index2++); [EOL]             if (c1 == c2) { [EOL]                 continue; [EOL]             } [EOL]             if (!ignoreCase) { [EOL]                 return false; [EOL]             } [EOL]             if (Character.toUpperCase(c1) != Character.toUpperCase(c2) && Character.toLowerCase(c1) != Character.toLowerCase(c2)) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL] } 
lang3/BooleanUtils.java
 [LINE] return bool.booleanValue() ? Boolean.FALSE : Boolean.TRUE; [LINE] public static Boolean negate(final Boolean bool) { [EOL]     if (bool == null) { [EOL]         return null; [EOL]     } [EOL]     return bool.booleanValue() ? Boolean.FALSE : Boolean.TRUE; [EOL] } 
 [LINE] return Boolean.TRUE.equals(bool); [LINE] public static boolean isTrue(final Boolean bool) { [EOL]     return Boolean.TRUE.equals(bool); [EOL] } 
 [LINE] if (value == trueValue) { [LINE] public static boolean toBoolean(final int value, final int trueValue, final int falseValue) { [EOL]     if (value == trueValue) { [EOL]         return true; [EOL]     } [EOL]     if (value == falseValue) { [EOL]         return false; [EOL]     } [EOL]     throw new IllegalArgumentException("The Integer did not match either specified value"); [EOL] } 
 [LINE] return true; [LINE] public static boolean toBoolean(final int value, final int trueValue, final int falseValue) { [EOL]     if (value == trueValue) { [EOL]         return true; [EOL]     } [EOL]     if (value == falseValue) { [EOL]         return false; [EOL]     } [EOL]     throw new IllegalArgumentException("The Integer did not match either specified value"); [EOL] } 
 [LINE] if (trueValue == null) { [LINE] public static boolean toBoolean(final Integer value, final Integer trueValue, final Integer falseValue) { [EOL]     if (value == null) { [EOL]         if (trueValue == null) { [EOL]             return true; [EOL]         } [EOL]         if (falseValue == null) { [EOL]             return false; [EOL]         } [EOL]     } else if (value.equals(trueValue)) { [EOL]         return true; [EOL]     } else if (value.equals(falseValue)) { [EOL]         return false; [EOL]     } [EOL]     throw new IllegalArgumentException("The Integer did not match either specified value"); [EOL] } 
 [LINE] return false; [LINE] public static boolean toBoolean(final Integer value, final Integer trueValue, final Integer falseValue) { [EOL]     if (value == null) { [EOL]         if (trueValue == null) { [EOL]             return true; [EOL]         } [EOL]         if (falseValue == null) { [EOL]             return false; [EOL]         } [EOL]     } else if (value.equals(trueValue)) { [EOL]         return true; [EOL]     } else if (value.equals(falseValue)) { [EOL]         return false; [EOL]     } [EOL]     throw new IllegalArgumentException("The Integer did not match either specified value"); [EOL] } 
 [LINE] if (value == trueValue) { [LINE] public static Boolean toBooleanObject(final int value, final int trueValue, final int falseValue, final int nullValue) { [EOL]     if (value == trueValue) { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     if (value == falseValue) { [EOL]         return Boolean.FALSE; [EOL]     } [EOL]     if (value == nullValue) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("The Integer did not match any specified value"); [EOL] } 
 [LINE] if (nullValue == null) { [LINE] public static Boolean toBooleanObject(final Integer value, final Integer trueValue, final Integer falseValue, final Integer nullValue) { [EOL]     if (value == null) { [EOL]         if (trueValue == null) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if (falseValue == null) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (nullValue == null) { [EOL]             return null; [EOL]         } [EOL]     } else if (value.equals(trueValue)) { [EOL]         return Boolean.TRUE; [EOL]     } else if (value.equals(falseValue)) { [EOL]         return Boolean.FALSE; [EOL]     } else if (value.equals(nullValue)) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("The Integer did not match any specified value"); [EOL] } 
 [LINE] return bool ? 1 : 0; [LINE] public static int toInteger(final boolean bool) { [EOL]     return bool ? 1 : 0; [EOL] } 
 [LINE] return null; [LINE] public static Integer toIntegerObject(final Boolean bool) { [EOL]     if (bool == null) { [EOL]         return null; [EOL]     } [EOL]     return bool.booleanValue() ? NumberUtils.INTEGER_ONE : NumberUtils.INTEGER_ZERO; [EOL] } 
 [LINE] if (bool == null) { [LINE] public static int toInteger(final Boolean bool, final int trueValue, final int falseValue, final int nullValue) { [EOL]     if (bool == null) { [EOL]         return nullValue; [EOL]     } [EOL]     return bool.booleanValue() ? trueValue : falseValue; [EOL] } 
 [LINE] return null; [LINE] public static Boolean toBooleanObject(final String str) { [EOL]     if (str == "true") { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     switch(str.length()) { [EOL]         case 1: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 if (ch0 == 'y' || ch0 == 'Y' || ch0 == 't' || ch0 == 'T') { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if (ch0 == 'n' || ch0 == 'N' || ch0 == 'f' || ch0 == 'F') { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 2: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 if ((ch0 == 'o' || ch0 == 'O') && (ch1 == 'n' || ch1 == 'N')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if ((ch0 == 'n' || ch0 == 'N') && (ch1 == 'o' || ch1 == 'O')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 3: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 if ((ch0 == 'y' || ch0 == 'Y') && (ch1 == 'e' || ch1 == 'E') && (ch2 == 's' || ch2 == 'S')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if ((ch0 == 'o' || ch0 == 'O') && (ch1 == 'f' || ch1 == 'F') && (ch2 == 'f' || ch2 == 'F')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 4: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 final char ch3 = str.charAt(3); [EOL]                 if ((ch0 == 't' || ch0 == 'T') && (ch1 == 'r' || ch1 == 'R') && (ch2 == 'u' || ch2 == 'U') && (ch3 == 'e' || ch3 == 'E')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 5: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 final char ch3 = str.charAt(3); [EOL]                 final char ch4 = str.charAt(4); [EOL]                 if ((ch0 == 'f' || ch0 == 'F') && (ch1 == 'a' || ch1 == 'A') && (ch2 == 'l' || ch2 == 'L') && (ch3 == 's' || ch3 == 'S') && (ch4 == 'e' || ch4 == 'E')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]     } [EOL]     return null; [EOL] } 
 [LINE] return Boolean.FALSE; [LINE] public static Boolean toBooleanObject(final String str) { [EOL]     if (str == "true") { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     switch(str.length()) { [EOL]         case 1: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 if (ch0 == 'y' || ch0 == 'Y' || ch0 == 't' || ch0 == 'T') { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if (ch0 == 'n' || ch0 == 'N' || ch0 == 'f' || ch0 == 'F') { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 2: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 if ((ch0 == 'o' || ch0 == 'O') && (ch1 == 'n' || ch1 == 'N')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if ((ch0 == 'n' || ch0 == 'N') && (ch1 == 'o' || ch1 == 'O')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 3: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 if ((ch0 == 'y' || ch0 == 'Y') && (ch1 == 'e' || ch1 == 'E') && (ch2 == 's' || ch2 == 'S')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if ((ch0 == 'o' || ch0 == 'O') && (ch1 == 'f' || ch1 == 'F') && (ch2 == 'f' || ch2 == 'F')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 4: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 final char ch3 = str.charAt(3); [EOL]                 if ((ch0 == 't' || ch0 == 'T') && (ch1 == 'r' || ch1 == 'R') && (ch2 == 'u' || ch2 == 'U') && (ch3 == 'e' || ch3 == 'E')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 5: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 final char ch3 = str.charAt(3); [EOL]                 final char ch4 = str.charAt(4); [EOL]                 if ((ch0 == 'f' || ch0 == 'F') && (ch1 == 'a' || ch1 == 'A') && (ch2 == 'l' || ch2 == 'L') && (ch3 == 's' || ch3 == 'S') && (ch4 == 'e' || ch4 == 'E')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]     } [EOL]     return null; [EOL] } 
 [LINE] break; [LINE] public static Boolean toBooleanObject(final String str) { [EOL]     if (str == "true") { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     switch(str.length()) { [EOL]         case 1: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 if (ch0 == 'y' || ch0 == 'Y' || ch0 == 't' || ch0 == 'T') { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if (ch0 == 'n' || ch0 == 'N' || ch0 == 'f' || ch0 == 'F') { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 2: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 if ((ch0 == 'o' || ch0 == 'O') && (ch1 == 'n' || ch1 == 'N')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if ((ch0 == 'n' || ch0 == 'N') && (ch1 == 'o' || ch1 == 'O')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 3: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 if ((ch0 == 'y' || ch0 == 'Y') && (ch1 == 'e' || ch1 == 'E') && (ch2 == 's' || ch2 == 'S')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if ((ch0 == 'o' || ch0 == 'O') && (ch1 == 'f' || ch1 == 'F') && (ch2 == 'f' || ch2 == 'F')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 4: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 final char ch3 = str.charAt(3); [EOL]                 if ((ch0 == 't' || ch0 == 'T') && (ch1 == 'r' || ch1 == 'R') && (ch2 == 'u' || ch2 == 'U') && (ch3 == 'e' || ch3 == 'E')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 5: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 final char ch3 = str.charAt(3); [EOL]                 final char ch4 = str.charAt(4); [EOL]                 if ((ch0 == 'f' || ch0 == 'F') && (ch1 == 'a' || ch1 == 'A') && (ch2 == 'l' || ch2 == 'L') && (ch3 == 's' || ch3 == 'S') && (ch4 == 'e' || ch4 == 'E')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]     } [EOL]     return null; [EOL] } 
 [LINE] final char ch1 = str.charAt(1); [LINE] public static Boolean toBooleanObject(final String str) { [EOL]     if (str == "true") { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     switch(str.length()) { [EOL]         case 1: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 if (ch0 == 'y' || ch0 == 'Y' || ch0 == 't' || ch0 == 'T') { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if (ch0 == 'n' || ch0 == 'N' || ch0 == 'f' || ch0 == 'F') { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 2: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 if ((ch0 == 'o' || ch0 == 'O') && (ch1 == 'n' || ch1 == 'N')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if ((ch0 == 'n' || ch0 == 'N') && (ch1 == 'o' || ch1 == 'O')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 3: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 if ((ch0 == 'y' || ch0 == 'Y') && (ch1 == 'e' || ch1 == 'E') && (ch2 == 's' || ch2 == 'S')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if ((ch0 == 'o' || ch0 == 'O') && (ch1 == 'f' || ch1 == 'F') && (ch2 == 'f' || ch2 == 'F')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 4: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 final char ch3 = str.charAt(3); [EOL]                 if ((ch0 == 't' || ch0 == 'T') && (ch1 == 'r' || ch1 == 'R') && (ch2 == 'u' || ch2 == 'U') && (ch3 == 'e' || ch3 == 'E')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 5: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 final char ch3 = str.charAt(3); [EOL]                 final char ch4 = str.charAt(4); [EOL]                 if ((ch0 == 'f' || ch0 == 'F') && (ch1 == 'a' || ch1 == 'A') && (ch2 == 'l' || ch2 == 'L') && (ch3 == 's' || ch3 == 'S') && (ch4 == 'e' || ch4 == 'E')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]     } [EOL]     return null; [EOL] } 
 [LINE] if ((ch0 == 'o' || ch0 == 'O') && [LINE] public static Boolean toBooleanObject(final String str) { [EOL]     if (str == "true") { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     switch(str.length()) { [EOL]         case 1: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 if (ch0 == 'y' || ch0 == 'Y' || ch0 == 't' || ch0 == 'T') { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if (ch0 == 'n' || ch0 == 'N' || ch0 == 'f' || ch0 == 'F') { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 2: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 if ((ch0 == 'o' || ch0 == 'O') && (ch1 == 'n' || ch1 == 'N')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if ((ch0 == 'n' || ch0 == 'N') && (ch1 == 'o' || ch1 == 'O')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 3: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 if ((ch0 == 'y' || ch0 == 'Y') && (ch1 == 'e' || ch1 == 'E') && (ch2 == 's' || ch2 == 'S')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if ((ch0 == 'o' || ch0 == 'O') && (ch1 == 'f' || ch1 == 'F') && (ch2 == 'f' || ch2 == 'F')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 4: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 final char ch3 = str.charAt(3); [EOL]                 if ((ch0 == 't' || ch0 == 'T') && (ch1 == 'r' || ch1 == 'R') && (ch2 == 'u' || ch2 == 'U') && (ch3 == 'e' || ch3 == 'E')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 5: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 final char ch3 = str.charAt(3); [EOL]                 final char ch4 = str.charAt(4); [EOL]                 if ((ch0 == 'f' || ch0 == 'F') && (ch1 == 'a' || ch1 == 'A') && (ch2 == 'l' || ch2 == 'L') && (ch3 == 's' || ch3 == 'S') && (ch4 == 'e' || ch4 == 'E')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]     } [EOL]     return null; [EOL] } 
 [LINE] return Boolean.FALSE; [LINE] public static Boolean toBooleanObject(final String str) { [EOL]     if (str == "true") { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     switch(str.length()) { [EOL]         case 1: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 if (ch0 == 'y' || ch0 == 'Y' || ch0 == 't' || ch0 == 'T') { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if (ch0 == 'n' || ch0 == 'N' || ch0 == 'f' || ch0 == 'F') { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 2: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 if ((ch0 == 'o' || ch0 == 'O') && (ch1 == 'n' || ch1 == 'N')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if ((ch0 == 'n' || ch0 == 'N') && (ch1 == 'o' || ch1 == 'O')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 3: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 if ((ch0 == 'y' || ch0 == 'Y') && (ch1 == 'e' || ch1 == 'E') && (ch2 == 's' || ch2 == 'S')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if ((ch0 == 'o' || ch0 == 'O') && (ch1 == 'f' || ch1 == 'F') && (ch2 == 'f' || ch2 == 'F')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 4: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 final char ch3 = str.charAt(3); [EOL]                 if ((ch0 == 't' || ch0 == 'T') && (ch1 == 'r' || ch1 == 'R') && (ch2 == 'u' || ch2 == 'U') && (ch3 == 'e' || ch3 == 'E')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 5: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 final char ch3 = str.charAt(3); [EOL]                 final char ch4 = str.charAt(4); [EOL]                 if ((ch0 == 'f' || ch0 == 'F') && (ch1 == 'a' || ch1 == 'A') && (ch2 == 'l' || ch2 == 'L') && (ch3 == 's' || ch3 == 'S') && (ch4 == 'e' || ch4 == 'E')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]     } [EOL]     return null; [EOL] } 
 [LINE] if ((ch0 == 'f' || ch0 == 'F') && [LINE] public static Boolean toBooleanObject(final String str) { [EOL]     if (str == "true") { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     switch(str.length()) { [EOL]         case 1: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 if (ch0 == 'y' || ch0 == 'Y' || ch0 == 't' || ch0 == 'T') { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if (ch0 == 'n' || ch0 == 'N' || ch0 == 'f' || ch0 == 'F') { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 2: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 if ((ch0 == 'o' || ch0 == 'O') && (ch1 == 'n' || ch1 == 'N')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if ((ch0 == 'n' || ch0 == 'N') && (ch1 == 'o' || ch1 == 'O')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 3: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 if ((ch0 == 'y' || ch0 == 'Y') && (ch1 == 'e' || ch1 == 'E') && (ch2 == 's' || ch2 == 'S')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if ((ch0 == 'o' || ch0 == 'O') && (ch1 == 'f' || ch1 == 'F') && (ch2 == 'f' || ch2 == 'F')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 4: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 final char ch3 = str.charAt(3); [EOL]                 if ((ch0 == 't' || ch0 == 'T') && (ch1 == 'r' || ch1 == 'R') && (ch2 == 'u' || ch2 == 'U') && (ch3 == 'e' || ch3 == 'E')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 5: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 final char ch3 = str.charAt(3); [EOL]                 final char ch4 = str.charAt(4); [EOL]                 if ((ch0 == 'f' || ch0 == 'F') && (ch1 == 'a' || ch1 == 'A') && (ch2 == 'l' || ch2 == 'L') && (ch3 == 's' || ch3 == 'S') && (ch4 == 'e' || ch4 == 'E')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]     } [EOL]     return null; [EOL] } 
 [LINE] return Boolean.FALSE; [LINE] public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) { [EOL]     if (str == null) { [EOL]         if (trueString == null) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if (falseString == null) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (nullString == null) { [EOL]             return null; [EOL]         } [EOL]     } else if (str.equals(trueString)) { [EOL]         return Boolean.TRUE; [EOL]     } else if (str.equals(falseString)) { [EOL]         return Boolean.FALSE; [EOL]     } else if (str.equals(nullString)) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match any specified value"); [EOL] } 
 [LINE] } else if (str.equals(nullString)) { [LINE] public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) { [EOL]     if (str == null) { [EOL]         if (trueString == null) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if (falseString == null) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (nullString == null) { [EOL]             return null; [EOL]         } [EOL]     } else if (str.equals(trueString)) { [EOL]         return Boolean.TRUE; [EOL]     } else if (str.equals(falseString)) { [EOL]         return Boolean.FALSE; [EOL]     } else if (str.equals(nullString)) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match any specified value"); [EOL] } 
 [LINE] } else if (str == falseString) { [LINE] public static boolean toBoolean(final String str, final String trueString, final String falseString) { [EOL]     if (str == trueString) { [EOL]         return true; [EOL]     } else if (str == falseString) { [EOL]         return false; [EOL]     } else if (str != null) { [EOL]         if (str.equals(trueString)) { [EOL]             return true; [EOL]         } else if (str.equals(falseString)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match either specified value"); [EOL] } 
 [LINE] return false; [LINE] public static boolean toBoolean(final String str, final String trueString, final String falseString) { [EOL]     if (str == trueString) { [EOL]         return true; [EOL]     } else if (str == falseString) { [EOL]         return false; [EOL]     } else if (str != null) { [EOL]         if (str.equals(trueString)) { [EOL]             return true; [EOL]         } else if (str.equals(falseString)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match either specified value"); [EOL] } 
 [LINE] return nullString; [LINE] public static String toString(final Boolean bool, final String trueString, final String falseString, final String nullString) { [EOL]     if (bool == null) { [EOL]         return nullString; [EOL]     } [EOL]     return bool.booleanValue() ? trueString : falseString; [EOL] } 
 [LINE] return toString(bool, "true", "false"); [LINE] public static String toStringTrueFalse(final boolean bool) { [EOL]     return toString(bool, "true", "false"); [EOL] } 
 [LINE] if (array == null) { [LINE] public static boolean and(final boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     for (final boolean element : array) { [EOL]         if (!element) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] throw new IllegalArgumentException("Array is empty"); [LINE] public static boolean and(final boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     for (final boolean element : array) { [EOL]         if (!element) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] if (array.length == 0) { [LINE] public static Boolean and(final Boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     try { [EOL]         final boolean[] primitive = ArrayUtils.toPrimitive(array); [EOL]         return and(primitive) ? Boolean.TRUE : Boolean.FALSE; [EOL]     } catch (final NullPointerException ex) { [EOL]         throw new IllegalArgumentException("The array must not contain any null elements"); [EOL]     } [EOL] } 
 [LINE] if (element) { [LINE] public static boolean or(final boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     for (final boolean element : array) { [EOL]         if (element) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } 
 [LINE] if (array.length == 0) { [LINE] public static Boolean or(final Boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     try { [EOL]         final boolean[] primitive = ArrayUtils.toPrimitive(array); [EOL]         return or(primitive) ? Boolean.TRUE : Boolean.FALSE; [EOL]     } catch (final NullPointerException ex) { [EOL]         throw new IllegalArgumentException("The array must not contain any null elements"); [EOL]     } [EOL] } 
 [LINE] return or(primitive) ? Boolean.TRUE : Boolean.FALSE; [LINE] public static Boolean or(final Boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     try { [EOL]         final boolean[] primitive = ArrayUtils.toPrimitive(array); [EOL]         return or(primitive) ? Boolean.TRUE : Boolean.FALSE; [EOL]     } catch (final NullPointerException ex) { [EOL]         throw new IllegalArgumentException("The array must not contain any null elements"); [EOL]     } [EOL] } 
 [LINE] int trueCount = 0; [LINE] public static boolean xor(final boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     int trueCount = 0; [EOL]     for (final boolean element : array) { [EOL]         if (element) { [EOL]             if (trueCount < 1) { [EOL]                 trueCount++; [EOL]             } else { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     return trueCount == 1; [EOL] } 
 [LINE] if (element) { [LINE] public static boolean xor(final boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     int trueCount = 0; [EOL]     for (final boolean element : array) { [EOL]         if (element) { [EOL]             if (trueCount < 1) { [EOL]                 trueCount++; [EOL]             } else { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     return trueCount == 1; [EOL] } 
 [LINE] if (array.length == 0) { [LINE] public static Boolean xor(final Boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     try { [EOL]         final boolean[] primitive = ArrayUtils.toPrimitive(array); [EOL]         return xor(primitive) ? Boolean.TRUE : Boolean.FALSE; [EOL]     } catch (final NullPointerException ex) { [EOL]         throw new IllegalArgumentException("The array must not contain any null elements"); [EOL]     } [EOL] } 
 [LINE] throw new IllegalArgumentException("Array is empty"); [LINE] public static Boolean xor(final Boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     try { [EOL]         final boolean[] primitive = ArrayUtils.toPrimitive(array); [EOL]         return xor(primitive) ? Boolean.TRUE : Boolean.FALSE; [EOL]     } catch (final NullPointerException ex) { [EOL]         throw new IllegalArgumentException("The array must not contain any null elements"); [EOL]     } [EOL] } 
lang3/concurrent/ConcurrentRuntimeException.java
lang3/BitField.java
 [LINE] return (holder & _mask) == _mask; [LINE] public boolean isAllSet(final int holder) { [EOL]     return (holder & _mask) == _mask; [EOL] } 
 [LINE] return holder & ~_mask; [LINE] public int clear(final int holder) { [EOL]     return holder & ~_mask; [EOL] } 
 [LINE] return (byte) set(holder); [LINE] public byte setByte(final byte holder) { [EOL]     return (byte) set(holder); [EOL] } 
 [LINE] return flag ? set(holder) : clear(holder); [LINE] public int setBoolean(final int holder, final boolean flag) { [EOL]     return flag ? set(holder) : clear(holder); [EOL] } 
lang3/mutable/MutableInt.java
 [LINE] this.value += operand.intValue(); [LINE] public void add(final Number operand) { [EOL]     this.value += operand.intValue(); [EOL] } 
lang3/event/EventListenerSupport.java
 [LINE] listeners.add(listener); [LINE] public void addListener(final L listener) { [EOL]     Validate.notNull(listener, "Listener object cannot be null."); [EOL]     listeners.add(listener); [EOL] } 
 [LINE] testObjectOutputStream.writeObject(listener); [LINE] private void writeObject(final ObjectOutputStream objectOutputStream) throws IOException { [EOL]     final ArrayList<L> serializableListeners = new ArrayList<L>(); [EOL]     ObjectOutputStream testObjectOutputStream = new ObjectOutputStream(new ByteArrayOutputStream()); [EOL]     for (final L listener : listeners) { [EOL]         try { [EOL]             testObjectOutputStream.writeObject(listener); [EOL]             serializableListeners.add(listener); [EOL]         } catch (final IOException exception) { [EOL]             testObjectOutputStream = new ObjectOutputStream(new ByteArrayOutputStream()); [EOL]         } [EOL]     } [EOL]     objectOutputStream.writeObject(serializableListeners.toArray(prototypeArray)); [EOL] } 
 [LINE] testObjectOutputStream = new ObjectOutputStream(new ByteArrayOutputStream()); [LINE] private void writeObject(final ObjectOutputStream objectOutputStream) throws IOException { [EOL]     final ArrayList<L> serializableListeners = new ArrayList<L>(); [EOL]     ObjectOutputStream testObjectOutputStream = new ObjectOutputStream(new ByteArrayOutputStream()); [EOL]     for (final L listener : listeners) { [EOL]         try { [EOL]             testObjectOutputStream.writeObject(listener); [EOL]             serializableListeners.add(listener); [EOL]         } catch (final IOException exception) { [EOL]             testObjectOutputStream = new ObjectOutputStream(new ByteArrayOutputStream()); [EOL]         } [EOL]     } [EOL]     objectOutputStream.writeObject(serializableListeners.toArray(prototypeArray)); [EOL] } 
 [LINE] objectOutputStream.writeObject(serializableListeners.toArray(prototypeArray)); [LINE] private void writeObject(final ObjectOutputStream objectOutputStream) throws IOException { [EOL]     final ArrayList<L> serializableListeners = new ArrayList<L>(); [EOL]     ObjectOutputStream testObjectOutputStream = new ObjectOutputStream(new ByteArrayOutputStream()); [EOL]     for (final L listener : listeners) { [EOL]         try { [EOL]             testObjectOutputStream.writeObject(listener); [EOL]             serializableListeners.add(listener); [EOL]         } catch (final IOException exception) { [EOL]             testObjectOutputStream = new ObjectOutputStream(new ByteArrayOutputStream()); [EOL]         } [EOL]     } [EOL]     objectOutputStream.writeObject(serializableListeners.toArray(prototypeArray)); [EOL] } 
 [LINE] proxy = listenerInterface.cast(Proxy.newProxyInstance(classLoader, [LINE] private void createProxy(final Class<L> listenerInterface, final ClassLoader classLoader) { [EOL]     proxy = listenerInterface.cast(Proxy.newProxyInstance(classLoader, new Class[] { listenerInterface }, createInvocationHandler())); [EOL] } 
lang3/math/NumberUtils.java
 [LINE] return toInt(str, 0); [LINE] public static int toInt(final String str) { [EOL]     return toInt(str, 0); [EOL] } 
 [LINE] return defaultValue; [LINE] public static int toInt(final String str, final int defaultValue) { [EOL]     if (str == null) { [EOL]         return defaultValue; [EOL]     } [EOL]     try { [EOL]         return Integer.parseInt(str); [EOL]     } catch (final NumberFormatException nfe) { [EOL]         return defaultValue; [EOL]     } [EOL] } 
 [LINE] return toLong(str, 0L); [LINE] public static long toLong(final String str) { [EOL]     return toLong(str, 0L); [EOL] } 
 [LINE] return defaultValue; [LINE] public static long toLong(final String str, final long defaultValue) { [EOL]     if (str == null) { [EOL]         return defaultValue; [EOL]     } [EOL]     try { [EOL]         return Long.parseLong(str); [EOL]     } catch (final NumberFormatException nfe) { [EOL]         return defaultValue; [EOL]     } [EOL] } 
 [LINE] if (str == null) { [LINE] public static double toDouble(final String str, final double defaultValue) { [EOL]     if (str == null) { [EOL]         return defaultValue; [EOL]     } [EOL]     try { [EOL]         return Double.parseDouble(str); [EOL]     } catch (final NumberFormatException nfe) { [EOL]         return defaultValue; [EOL]     } [EOL] } 
 [LINE] return defaultValue; [LINE] public static double toDouble(final String str, final double defaultValue) { [EOL]     if (str == null) { [EOL]         return defaultValue; [EOL]     } [EOL]     try { [EOL]         return Double.parseDouble(str); [EOL]     } catch (final NumberFormatException nfe) { [EOL]         return defaultValue; [EOL]     } [EOL] } 
 [LINE] try { [LINE] public static double toDouble(final String str, final double defaultValue) { [EOL]     if (str == null) { [EOL]         return defaultValue; [EOL]     } [EOL]     try { [EOL]         return Double.parseDouble(str); [EOL]     } catch (final NumberFormatException nfe) { [EOL]         return defaultValue; [EOL]     } [EOL] } 
 [LINE] return Double.parseDouble(str); [LINE] public static double toDouble(final String str, final double defaultValue) { [EOL]     if (str == null) { [EOL]         return defaultValue; [EOL]     } [EOL]     try { [EOL]         return Double.parseDouble(str); [EOL]     } catch (final NumberFormatException nfe) { [EOL]         return defaultValue; [EOL]     } [EOL] } 
 [LINE] return createLong(str); [LINE] public static Number createNumber(final String str) throws NumberFormatException { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (StringUtils.isBlank(str)) { [EOL]         throw new NumberFormatException("A blank string is not a valid number"); [EOL]     } [EOL]     final String[] hex_prefixes = { "0x", "0X", "-0x", "-0X", "#", "-#" }; [EOL]     int pfxLen = 0; [EOL]     for (final String pfx : hex_prefixes) { [EOL]         if (str.startsWith(pfx)) { [EOL]             pfxLen += pfx.length(); [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (pfxLen > 0) { [EOL]         char firstSigDigit = 0; [EOL]         for (int i = pfxLen; i < str.length(); i++) { [EOL]             firstSigDigit = str.charAt(i); [EOL]             if (firstSigDigit == '0') { [EOL]                 pfxLen++; [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         final int hexDigits = str.length() - pfxLen; [EOL]         if (hexDigits > 16 || (hexDigits == 16 && firstSigDigit > '7')) { [EOL]             return createBigInteger(str); [EOL]         } [EOL]         if (hexDigits > 8 || (hexDigits == 8 && firstSigDigit > '7')) { [EOL]             return createLong(str); [EOL]         } [EOL]         return createInteger(str); [EOL]     } [EOL]     final char lastChar = str.charAt(str.length() - 1); [EOL]     String mant; [EOL]     String dec; [EOL]     String exp; [EOL]     final int decPos = str.indexOf('.'); [EOL]     final int expPos = str.indexOf('e') + str.indexOf('E') + 1; [EOL]     int numDecimals = 0; [EOL]     if (decPos > -1) { [EOL]         if (expPos > -1) { [EOL]             if (expPos < decPos || expPos > str.length()) { [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             } [EOL]             dec = str.substring(decPos + 1, expPos); [EOL]         } else { [EOL]             dec = str.substring(decPos + 1); [EOL]         } [EOL]         mant = str.substring(0, decPos); [EOL]         numDecimals = dec.length(); [EOL]     } else { [EOL]         if (expPos > -1) { [EOL]             if (expPos > str.length()) { [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             } [EOL]             mant = str.substring(0, expPos); [EOL]         } else { [EOL]             mant = str; [EOL]         } [EOL]         dec = null; [EOL]     } [EOL]     if (!Character.isDigit(lastChar) && lastChar != '.') { [EOL]         if (expPos > -1 && expPos < str.length() - 1) { [EOL]             exp = str.substring(expPos + 1, str.length() - 1); [EOL]         } else { [EOL]             exp = null; [EOL]         } [EOL]         final String numeric = str.substring(0, str.length() - 1); [EOL]         final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL]         switch(lastChar) { [EOL]             case 'l': [EOL]             case 'L': [EOL]                 if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { [EOL]                     try { [EOL]                         return createLong(numeric); [EOL]                     } catch (final NumberFormatException nfe) { [EOL]                     } [EOL]                     return createBigInteger(numeric); [EOL]                 } [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             case 'f': [EOL]             case 'F': [EOL]                 try { [EOL]                     final Float f = NumberUtils.createFloat(numeric); [EOL]                     if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL]                         return f; [EOL]                     } [EOL]                 } catch (final NumberFormatException nfe) { [EOL]                 } [EOL]             case 'd': [EOL]             case 'D': [EOL]                 try { [EOL]                     final Double d = NumberUtils.createDouble(numeric); [EOL]                     if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { [EOL]                         return d; [EOL]                     } [EOL]                 } catch (final NumberFormatException nfe) { [EOL]                 } [EOL]                 try { [EOL]                     return createBigDecimal(numeric); [EOL]                 } catch (final NumberFormatException e) { [EOL]                 } [EOL]             default: [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]         } [EOL]     } [EOL]     if (expPos > -1 && expPos < str.length() - 1) { [EOL]         exp = str.substring(expPos + 1, str.length()); [EOL]     } else { [EOL]         exp = null; [EOL]     } [EOL]     if (dec == null && exp == null) { [EOL]         try { [EOL]             return createInteger(str); [EOL]         } catch (final NumberFormatException nfe) { [EOL]         } [EOL]         try { [EOL]             return createLong(str); [EOL]         } catch (final NumberFormatException nfe) { [EOL]         } [EOL]         return createBigInteger(str); [EOL]     } [EOL]     final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL]     try { [EOL]         if (numDecimals <= 7) { [EOL]             final Float f = createFloat(str); [EOL]             if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL]                 return f; [EOL]             } [EOL]         } [EOL]     } catch (final NumberFormatException nfe) { [EOL]     } [EOL]     try { [EOL]         if (numDecimals <= 16) { [EOL]             final Double d = createDouble(str); [EOL]             if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { [EOL]                 return d; [EOL]             } [EOL]         } [EOL]     } catch (final NumberFormatException nfe) { [EOL]     } [EOL]     return createBigDecimal(str); [EOL] } 
 [LINE] String exp; [LINE] public static Number createNumber(final String str) throws NumberFormatException { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (StringUtils.isBlank(str)) { [EOL]         throw new NumberFormatException("A blank string is not a valid number"); [EOL]     } [EOL]     final String[] hex_prefixes = { "0x", "0X", "-0x", "-0X", "#", "-#" }; [EOL]     int pfxLen = 0; [EOL]     for (final String pfx : hex_prefixes) { [EOL]         if (str.startsWith(pfx)) { [EOL]             pfxLen += pfx.length(); [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (pfxLen > 0) { [EOL]         char firstSigDigit = 0; [EOL]         for (int i = pfxLen; i < str.length(); i++) { [EOL]             firstSigDigit = str.charAt(i); [EOL]             if (firstSigDigit == '0') { [EOL]                 pfxLen++; [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         final int hexDigits = str.length() - pfxLen; [EOL]         if (hexDigits > 16 || (hexDigits == 16 && firstSigDigit > '7')) { [EOL]             return createBigInteger(str); [EOL]         } [EOL]         if (hexDigits > 8 || (hexDigits == 8 && firstSigDigit > '7')) { [EOL]             return createLong(str); [EOL]         } [EOL]         return createInteger(str); [EOL]     } [EOL]     final char lastChar = str.charAt(str.length() - 1); [EOL]     String mant; [EOL]     String dec; [EOL]     String exp; [EOL]     final int decPos = str.indexOf('.'); [EOL]     final int expPos = str.indexOf('e') + str.indexOf('E') + 1; [EOL]     int numDecimals = 0; [EOL]     if (decPos > -1) { [EOL]         if (expPos > -1) { [EOL]             if (expPos < decPos || expPos > str.length()) { [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             } [EOL]             dec = str.substring(decPos + 1, expPos); [EOL]         } else { [EOL]             dec = str.substring(decPos + 1); [EOL]         } [EOL]         mant = str.substring(0, decPos); [EOL]         numDecimals = dec.length(); [EOL]     } else { [EOL]         if (expPos > -1) { [EOL]             if (expPos > str.length()) { [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             } [EOL]             mant = str.substring(0, expPos); [EOL]         } else { [EOL]             mant = str; [EOL]         } [EOL]         dec = null; [EOL]     } [EOL]     if (!Character.isDigit(lastChar) && lastChar != '.') { [EOL]         if (expPos > -1 && expPos < str.length() - 1) { [EOL]             exp = str.substring(expPos + 1, str.length() - 1); [EOL]         } else { [EOL]             exp = null; [EOL]         } [EOL]         final String numeric = str.substring(0, str.length() - 1); [EOL]         final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL]         switch(lastChar) { [EOL]             case 'l': [EOL]             case 'L': [EOL]                 if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { [EOL]                     try { [EOL]                         return createLong(numeric); [EOL]                     } catch (final NumberFormatException nfe) { [EOL]                     } [EOL]                     return createBigInteger(numeric); [EOL]                 } [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             case 'f': [EOL]             case 'F': [EOL]                 try { [EOL]                     final Float f = NumberUtils.createFloat(numeric); [EOL]                     if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL]                         return f; [EOL]                     } [EOL]                 } catch (final NumberFormatException nfe) { [EOL]                 } [EOL]             case 'd': [EOL]             case 'D': [EOL]                 try { [EOL]                     final Double d = NumberUtils.createDouble(numeric); [EOL]                     if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { [EOL]                         return d; [EOL]                     } [EOL]                 } catch (final NumberFormatException nfe) { [EOL]                 } [EOL]                 try { [EOL]                     return createBigDecimal(numeric); [EOL]                 } catch (final NumberFormatException e) { [EOL]                 } [EOL]             default: [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]         } [EOL]     } [EOL]     if (expPos > -1 && expPos < str.length() - 1) { [EOL]         exp = str.substring(expPos + 1, str.length()); [EOL]     } else { [EOL]         exp = null; [EOL]     } [EOL]     if (dec == null && exp == null) { [EOL]         try { [EOL]             return createInteger(str); [EOL]         } catch (final NumberFormatException nfe) { [EOL]         } [EOL]         try { [EOL]             return createLong(str); [EOL]         } catch (final NumberFormatException nfe) { [EOL]         } [EOL]         return createBigInteger(str); [EOL]     } [EOL]     final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL]     try { [EOL]         if (numDecimals <= 7) { [EOL]             final Float f = createFloat(str); [EOL]             if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL]                 return f; [EOL]             } [EOL]         } [EOL]     } catch (final NumberFormatException nfe) { [EOL]     } [EOL]     try { [EOL]         if (numDecimals <= 16) { [EOL]             final Double d = createDouble(str); [EOL]             if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { [EOL]                 return d; [EOL]             } [EOL]         } [EOL]     } catch (final NumberFormatException nfe) { [EOL]     } [EOL]     return createBigDecimal(str); [EOL] } 
 [LINE] throw new NumberFormatException(str + " is not a valid number."); [LINE] public static Number createNumber(final String str) throws NumberFormatException { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (StringUtils.isBlank(str)) { [EOL]         throw new NumberFormatException("A blank string is not a valid number"); [EOL]     } [EOL]     final String[] hex_prefixes = { "0x", "0X", "-0x", "-0X", "#", "-#" }; [EOL]     int pfxLen = 0; [EOL]     for (final String pfx : hex_prefixes) { [EOL]         if (str.startsWith(pfx)) { [EOL]             pfxLen += pfx.length(); [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (pfxLen > 0) { [EOL]         char firstSigDigit = 0; [EOL]         for (int i = pfxLen; i < str.length(); i++) { [EOL]             firstSigDigit = str.charAt(i); [EOL]             if (firstSigDigit == '0') { [EOL]                 pfxLen++; [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         final int hexDigits = str.length() - pfxLen; [EOL]         if (hexDigits > 16 || (hexDigits == 16 && firstSigDigit > '7')) { [EOL]             return createBigInteger(str); [EOL]         } [EOL]         if (hexDigits > 8 || (hexDigits == 8 && firstSigDigit > '7')) { [EOL]             return createLong(str); [EOL]         } [EOL]         return createInteger(str); [EOL]     } [EOL]     final char lastChar = str.charAt(str.length() - 1); [EOL]     String mant; [EOL]     String dec; [EOL]     String exp; [EOL]     final int decPos = str.indexOf('.'); [EOL]     final int expPos = str.indexOf('e') + str.indexOf('E') + 1; [EOL]     int numDecimals = 0; [EOL]     if (decPos > -1) { [EOL]         if (expPos > -1) { [EOL]             if (expPos < decPos || expPos > str.length()) { [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             } [EOL]             dec = str.substring(decPos + 1, expPos); [EOL]         } else { [EOL]             dec = str.substring(decPos + 1); [EOL]         } [EOL]         mant = str.substring(0, decPos); [EOL]         numDecimals = dec.length(); [EOL]     } else { [EOL]         if (expPos > -1) { [EOL]             if (expPos > str.length()) { [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             } [EOL]             mant = str.substring(0, expPos); [EOL]         } else { [EOL]             mant = str; [EOL]         } [EOL]         dec = null; [EOL]     } [EOL]     if (!Character.isDigit(lastChar) && lastChar != '.') { [EOL]         if (expPos > -1 && expPos < str.length() - 1) { [EOL]             exp = str.substring(expPos + 1, str.length() - 1); [EOL]         } else { [EOL]             exp = null; [EOL]         } [EOL]         final String numeric = str.substring(0, str.length() - 1); [EOL]         final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL]         switch(lastChar) { [EOL]             case 'l': [EOL]             case 'L': [EOL]                 if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { [EOL]                     try { [EOL]                         return createLong(numeric); [EOL]                     } catch (final NumberFormatException nfe) { [EOL]                     } [EOL]                     return createBigInteger(numeric); [EOL]                 } [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             case 'f': [EOL]             case 'F': [EOL]                 try { [EOL]                     final Float f = NumberUtils.createFloat(numeric); [EOL]                     if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL]                         return f; [EOL]                     } [EOL]                 } catch (final NumberFormatException nfe) { [EOL]                 } [EOL]             case 'd': [EOL]             case 'D': [EOL]                 try { [EOL]                     final Double d = NumberUtils.createDouble(numeric); [EOL]                     if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { [EOL]                         return d; [EOL]                     } [EOL]                 } catch (final NumberFormatException nfe) { [EOL]                 } [EOL]                 try { [EOL]                     return createBigDecimal(numeric); [EOL]                 } catch (final NumberFormatException e) { [EOL]                 } [EOL]             default: [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]         } [EOL]     } [EOL]     if (expPos > -1 && expPos < str.length() - 1) { [EOL]         exp = str.substring(expPos + 1, str.length()); [EOL]     } else { [EOL]         exp = null; [EOL]     } [EOL]     if (dec == null && exp == null) { [EOL]         try { [EOL]             return createInteger(str); [EOL]         } catch (final NumberFormatException nfe) { [EOL]         } [EOL]         try { [EOL]             return createLong(str); [EOL]         } catch (final NumberFormatException nfe) { [EOL]         } [EOL]         return createBigInteger(str); [EOL]     } [EOL]     final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL]     try { [EOL]         if (numDecimals <= 7) { [EOL]             final Float f = createFloat(str); [EOL]             if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL]                 return f; [EOL]             } [EOL]         } [EOL]     } catch (final NumberFormatException nfe) { [EOL]     } [EOL]     try { [EOL]         if (numDecimals <= 16) { [EOL]             final Double d = createDouble(str); [EOL]             if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { [EOL]                 return d; [EOL]             } [EOL]         } [EOL]     } catch (final NumberFormatException nfe) { [EOL]     } [EOL]     return createBigDecimal(str); [EOL] } 
 [LINE] if (!Character.isDigit(lastChar) && lastChar != '.') { [LINE] public static Number createNumber(final String str) throws NumberFormatException { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (StringUtils.isBlank(str)) { [EOL]         throw new NumberFormatException("A blank string is not a valid number"); [EOL]     } [EOL]     final String[] hex_prefixes = { "0x", "0X", "-0x", "-0X", "#", "-#" }; [EOL]     int pfxLen = 0; [EOL]     for (final String pfx : hex_prefixes) { [EOL]         if (str.startsWith(pfx)) { [EOL]             pfxLen += pfx.length(); [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (pfxLen > 0) { [EOL]         char firstSigDigit = 0; [EOL]         for (int i = pfxLen; i < str.length(); i++) { [EOL]             firstSigDigit = str.charAt(i); [EOL]             if (firstSigDigit == '0') { [EOL]                 pfxLen++; [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         final int hexDigits = str.length() - pfxLen; [EOL]         if (hexDigits > 16 || (hexDigits == 16 && firstSigDigit > '7')) { [EOL]             return createBigInteger(str); [EOL]         } [EOL]         if (hexDigits > 8 || (hexDigits == 8 && firstSigDigit > '7')) { [EOL]             return createLong(str); [EOL]         } [EOL]         return createInteger(str); [EOL]     } [EOL]     final char lastChar = str.charAt(str.length() - 1); [EOL]     String mant; [EOL]     String dec; [EOL]     String exp; [EOL]     final int decPos = str.indexOf('.'); [EOL]     final int expPos = str.indexOf('e') + str.indexOf('E') + 1; [EOL]     int numDecimals = 0; [EOL]     if (decPos > -1) { [EOL]         if (expPos > -1) { [EOL]             if (expPos < decPos || expPos > str.length()) { [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             } [EOL]             dec = str.substring(decPos + 1, expPos); [EOL]         } else { [EOL]             dec = str.substring(decPos + 1); [EOL]         } [EOL]         mant = str.substring(0, decPos); [EOL]         numDecimals = dec.length(); [EOL]     } else { [EOL]         if (expPos > -1) { [EOL]             if (expPos > str.length()) { [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             } [EOL]             mant = str.substring(0, expPos); [EOL]         } else { [EOL]             mant = str; [EOL]         } [EOL]         dec = null; [EOL]     } [EOL]     if (!Character.isDigit(lastChar) && lastChar != '.') { [EOL]         if (expPos > -1 && expPos < str.length() - 1) { [EOL]             exp = str.substring(expPos + 1, str.length() - 1); [EOL]         } else { [EOL]             exp = null; [EOL]         } [EOL]         final String numeric = str.substring(0, str.length() - 1); [EOL]         final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL]         switch(lastChar) { [EOL]             case 'l': [EOL]             case 'L': [EOL]                 if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { [EOL]                     try { [EOL]                         return createLong(numeric); [EOL]                     } catch (final NumberFormatException nfe) { [EOL]                     } [EOL]                     return createBigInteger(numeric); [EOL]                 } [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             case 'f': [EOL]             case 'F': [EOL]                 try { [EOL]                     final Float f = NumberUtils.createFloat(numeric); [EOL]                     if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL]                         return f; [EOL]                     } [EOL]                 } catch (final NumberFormatException nfe) { [EOL]                 } [EOL]             case 'd': [EOL]             case 'D': [EOL]                 try { [EOL]                     final Double d = NumberUtils.createDouble(numeric); [EOL]                     if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { [EOL]                         return d; [EOL]                     } [EOL]                 } catch (final NumberFormatException nfe) { [EOL]                 } [EOL]                 try { [EOL]                     return createBigDecimal(numeric); [EOL]                 } catch (final NumberFormatException e) { [EOL]                 } [EOL]             default: [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]         } [EOL]     } [EOL]     if (expPos > -1 && expPos < str.length() - 1) { [EOL]         exp = str.substring(expPos + 1, str.length()); [EOL]     } else { [EOL]         exp = null; [EOL]     } [EOL]     if (dec == null && exp == null) { [EOL]         try { [EOL]             return createInteger(str); [EOL]         } catch (final NumberFormatException nfe) { [EOL]         } [EOL]         try { [EOL]             return createLong(str); [EOL]         } catch (final NumberFormatException nfe) { [EOL]         } [EOL]         return createBigInteger(str); [EOL]     } [EOL]     final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL]     try { [EOL]         if (numDecimals <= 7) { [EOL]             final Float f = createFloat(str); [EOL]             if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL]                 return f; [EOL]             } [EOL]         } [EOL]     } catch (final NumberFormatException nfe) { [EOL]     } [EOL]     try { [EOL]         if (numDecimals <= 16) { [EOL]             final Double d = createDouble(str); [EOL]             if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { [EOL]                 return d; [EOL]             } [EOL]         } [EOL]     } catch (final NumberFormatException nfe) { [EOL]     } [EOL]     return createBigDecimal(str); [EOL] } 
 [LINE] final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [LINE] public static Number createNumber(final String str) throws NumberFormatException { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (StringUtils.isBlank(str)) { [EOL]         throw new NumberFormatException("A blank string is not a valid number"); [EOL]     } [EOL]     final String[] hex_prefixes = { "0x", "0X", "-0x", "-0X", "#", "-#" }; [EOL]     int pfxLen = 0; [EOL]     for (final String pfx : hex_prefixes) { [EOL]         if (str.startsWith(pfx)) { [EOL]             pfxLen += pfx.length(); [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (pfxLen > 0) { [EOL]         char firstSigDigit = 0; [EOL]         for (int i = pfxLen; i < str.length(); i++) { [EOL]             firstSigDigit = str.charAt(i); [EOL]             if (firstSigDigit == '0') { [EOL]                 pfxLen++; [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         final int hexDigits = str.length() - pfxLen; [EOL]         if (hexDigits > 16 || (hexDigits == 16 && firstSigDigit > '7')) { [EOL]             return createBigInteger(str); [EOL]         } [EOL]         if (hexDigits > 8 || (hexDigits == 8 && firstSigDigit > '7')) { [EOL]             return createLong(str); [EOL]         } [EOL]         return createInteger(str); [EOL]     } [EOL]     final char lastChar = str.charAt(str.length() - 1); [EOL]     String mant; [EOL]     String dec; [EOL]     String exp; [EOL]     final int decPos = str.indexOf('.'); [EOL]     final int expPos = str.indexOf('e') + str.indexOf('E') + 1; [EOL]     int numDecimals = 0; [EOL]     if (decPos > -1) { [EOL]         if (expPos > -1) { [EOL]             if (expPos < decPos || expPos > str.length()) { [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             } [EOL]             dec = str.substring(decPos + 1, expPos); [EOL]         } else { [EOL]             dec = str.substring(decPos + 1); [EOL]         } [EOL]         mant = str.substring(0, decPos); [EOL]         numDecimals = dec.length(); [EOL]     } else { [EOL]         if (expPos > -1) { [EOL]             if (expPos > str.length()) { [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             } [EOL]             mant = str.substring(0, expPos); [EOL]         } else { [EOL]             mant = str; [EOL]         } [EOL]         dec = null; [EOL]     } [EOL]     if (!Character.isDigit(lastChar) && lastChar != '.') { [EOL]         if (expPos > -1 && expPos < str.length() - 1) { [EOL]             exp = str.substring(expPos + 1, str.length() - 1); [EOL]         } else { [EOL]             exp = null; [EOL]         } [EOL]         final String numeric = str.substring(0, str.length() - 1); [EOL]         final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL]         switch(lastChar) { [EOL]             case 'l': [EOL]             case 'L': [EOL]                 if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { [EOL]                     try { [EOL]                         return createLong(numeric); [EOL]                     } catch (final NumberFormatException nfe) { [EOL]                     } [EOL]                     return createBigInteger(numeric); [EOL]                 } [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             case 'f': [EOL]             case 'F': [EOL]                 try { [EOL]                     final Float f = NumberUtils.createFloat(numeric); [EOL]                     if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL]                         return f; [EOL]                     } [EOL]                 } catch (final NumberFormatException nfe) { [EOL]                 } [EOL]             case 'd': [EOL]             case 'D': [EOL]                 try { [EOL]                     final Double d = NumberUtils.createDouble(numeric); [EOL]                     if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { [EOL]                         return d; [EOL]                     } [EOL]                 } catch (final NumberFormatException nfe) { [EOL]                 } [EOL]                 try { [EOL]                     return createBigDecimal(numeric); [EOL]                 } catch (final NumberFormatException e) { [EOL]                 } [EOL]             default: [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]         } [EOL]     } [EOL]     if (expPos > -1 && expPos < str.length() - 1) { [EOL]         exp = str.substring(expPos + 1, str.length()); [EOL]     } else { [EOL]         exp = null; [EOL]     } [EOL]     if (dec == null && exp == null) { [EOL]         try { [EOL]             return createInteger(str); [EOL]         } catch (final NumberFormatException nfe) { [EOL]         } [EOL]         try { [EOL]             return createLong(str); [EOL]         } catch (final NumberFormatException nfe) { [EOL]         } [EOL]         return createBigInteger(str); [EOL]     } [EOL]     final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL]     try { [EOL]         if (numDecimals <= 7) { [EOL]             final Float f = createFloat(str); [EOL]             if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL]                 return f; [EOL]             } [EOL]         } [EOL]     } catch (final NumberFormatException nfe) { [EOL]     } [EOL]     try { [EOL]         if (numDecimals <= 16) { [EOL]             final Double d = createDouble(str); [EOL]             if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { [EOL]                 return d; [EOL]             } [EOL]         } [EOL]     } catch (final NumberFormatException nfe) { [EOL]     } [EOL]     return createBigDecimal(str); [EOL] } 
 [LINE] try { [LINE] public static Number createNumber(final String str) throws NumberFormatException { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (StringUtils.isBlank(str)) { [EOL]         throw new NumberFormatException("A blank string is not a valid number"); [EOL]     } [EOL]     final String[] hex_prefixes = { "0x", "0X", "-0x", "-0X", "#", "-#" }; [EOL]     int pfxLen = 0; [EOL]     for (final String pfx : hex_prefixes) { [EOL]         if (str.startsWith(pfx)) { [EOL]             pfxLen += pfx.length(); [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (pfxLen > 0) { [EOL]         char firstSigDigit = 0; [EOL]         for (int i = pfxLen; i < str.length(); i++) { [EOL]             firstSigDigit = str.charAt(i); [EOL]             if (firstSigDigit == '0') { [EOL]                 pfxLen++; [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         final int hexDigits = str.length() - pfxLen; [EOL]         if (hexDigits > 16 || (hexDigits == 16 && firstSigDigit > '7')) { [EOL]             return createBigInteger(str); [EOL]         } [EOL]         if (hexDigits > 8 || (hexDigits == 8 && firstSigDigit > '7')) { [EOL]             return createLong(str); [EOL]         } [EOL]         return createInteger(str); [EOL]     } [EOL]     final char lastChar = str.charAt(str.length() - 1); [EOL]     String mant; [EOL]     String dec; [EOL]     String exp; [EOL]     final int decPos = str.indexOf('.'); [EOL]     final int expPos = str.indexOf('e') + str.indexOf('E') + 1; [EOL]     int numDecimals = 0; [EOL]     if (decPos > -1) { [EOL]         if (expPos > -1) { [EOL]             if (expPos < decPos || expPos > str.length()) { [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             } [EOL]             dec = str.substring(decPos + 1, expPos); [EOL]         } else { [EOL]             dec = str.substring(decPos + 1); [EOL]         } [EOL]         mant = str.substring(0, decPos); [EOL]         numDecimals = dec.length(); [EOL]     } else { [EOL]         if (expPos > -1) { [EOL]             if (expPos > str.length()) { [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             } [EOL]             mant = str.substring(0, expPos); [EOL]         } else { [EOL]             mant = str; [EOL]         } [EOL]         dec = null; [EOL]     } [EOL]     if (!Character.isDigit(lastChar) && lastChar != '.') { [EOL]         if (expPos > -1 && expPos < str.length() - 1) { [EOL]             exp = str.substring(expPos + 1, str.length() - 1); [EOL]         } else { [EOL]             exp = null; [EOL]         } [EOL]         final String numeric = str.substring(0, str.length() - 1); [EOL]         final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL]         switch(lastChar) { [EOL]             case 'l': [EOL]             case 'L': [EOL]                 if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { [EOL]                     try { [EOL]                         return createLong(numeric); [EOL]                     } catch (final NumberFormatException nfe) { [EOL]                     } [EOL]                     return createBigInteger(numeric); [EOL]                 } [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             case 'f': [EOL]             case 'F': [EOL]                 try { [EOL]                     final Float f = NumberUtils.createFloat(numeric); [EOL]                     if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL]                         return f; [EOL]                     } [EOL]                 } catch (final NumberFormatException nfe) { [EOL]                 } [EOL]             case 'd': [EOL]             case 'D': [EOL]                 try { [EOL]                     final Double d = NumberUtils.createDouble(numeric); [EOL]                     if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { [EOL]                         return d; [EOL]                     } [EOL]                 } catch (final NumberFormatException nfe) { [EOL]                 } [EOL]                 try { [EOL]                     return createBigDecimal(numeric); [EOL]                 } catch (final NumberFormatException e) { [EOL]                 } [EOL]             default: [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]         } [EOL]     } [EOL]     if (expPos > -1 && expPos < str.length() - 1) { [EOL]         exp = str.substring(expPos + 1, str.length()); [EOL]     } else { [EOL]         exp = null; [EOL]     } [EOL]     if (dec == null && exp == null) { [EOL]         try { [EOL]             return createInteger(str); [EOL]         } catch (final NumberFormatException nfe) { [EOL]         } [EOL]         try { [EOL]             return createLong(str); [EOL]         } catch (final NumberFormatException nfe) { [EOL]         } [EOL]         return createBigInteger(str); [EOL]     } [EOL]     final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL]     try { [EOL]         if (numDecimals <= 7) { [EOL]             final Float f = createFloat(str); [EOL]             if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL]                 return f; [EOL]             } [EOL]         } [EOL]     } catch (final NumberFormatException nfe) { [EOL]     } [EOL]     try { [EOL]         if (numDecimals <= 16) { [EOL]             final Double d = createDouble(str); [EOL]             if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { [EOL]                 return d; [EOL]             } [EOL]         } [EOL]     } catch (final NumberFormatException nfe) { [EOL]     } [EOL]     return createBigDecimal(str); [EOL] } 
 [LINE] return createBigInteger(numeric); [LINE] public static Number createNumber(final String str) throws NumberFormatException { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (StringUtils.isBlank(str)) { [EOL]         throw new NumberFormatException("A blank string is not a valid number"); [EOL]     } [EOL]     final String[] hex_prefixes = { "0x", "0X", "-0x", "-0X", "#", "-#" }; [EOL]     int pfxLen = 0; [EOL]     for (final String pfx : hex_prefixes) { [EOL]         if (str.startsWith(pfx)) { [EOL]             pfxLen += pfx.length(); [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (pfxLen > 0) { [EOL]         char firstSigDigit = 0; [EOL]         for (int i = pfxLen; i < str.length(); i++) { [EOL]             firstSigDigit = str.charAt(i); [EOL]             if (firstSigDigit == '0') { [EOL]                 pfxLen++; [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         final int hexDigits = str.length() - pfxLen; [EOL]         if (hexDigits > 16 || (hexDigits == 16 && firstSigDigit > '7')) { [EOL]             return createBigInteger(str); [EOL]         } [EOL]         if (hexDigits > 8 || (hexDigits == 8 && firstSigDigit > '7')) { [EOL]             return createLong(str); [EOL]         } [EOL]         return createInteger(str); [EOL]     } [EOL]     final char lastChar = str.charAt(str.length() - 1); [EOL]     String mant; [EOL]     String dec; [EOL]     String exp; [EOL]     final int decPos = str.indexOf('.'); [EOL]     final int expPos = str.indexOf('e') + str.indexOf('E') + 1; [EOL]     int numDecimals = 0; [EOL]     if (decPos > -1) { [EOL]         if (expPos > -1) { [EOL]             if (expPos < decPos || expPos > str.length()) { [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             } [EOL]             dec = str.substring(decPos + 1, expPos); [EOL]         } else { [EOL]             dec = str.substring(decPos + 1); [EOL]         } [EOL]         mant = str.substring(0, decPos); [EOL]         numDecimals = dec.length(); [EOL]     } else { [EOL]         if (expPos > -1) { [EOL]             if (expPos > str.length()) { [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             } [EOL]             mant = str.substring(0, expPos); [EOL]         } else { [EOL]             mant = str; [EOL]         } [EOL]         dec = null; [EOL]     } [EOL]     if (!Character.isDigit(lastChar) && lastChar != '.') { [EOL]         if (expPos > -1 && expPos < str.length() - 1) { [EOL]             exp = str.substring(expPos + 1, str.length() - 1); [EOL]         } else { [EOL]             exp = null; [EOL]         } [EOL]         final String numeric = str.substring(0, str.length() - 1); [EOL]         final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL]         switch(lastChar) { [EOL]             case 'l': [EOL]             case 'L': [EOL]                 if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { [EOL]                     try { [EOL]                         return createLong(numeric); [EOL]                     } catch (final NumberFormatException nfe) { [EOL]                     } [EOL]                     return createBigInteger(numeric); [EOL]                 } [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             case 'f': [EOL]             case 'F': [EOL]                 try { [EOL]                     final Float f = NumberUtils.createFloat(numeric); [EOL]                     if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL]                         return f; [EOL]                     } [EOL]                 } catch (final NumberFormatException nfe) { [EOL]                 } [EOL]             case 'd': [EOL]             case 'D': [EOL]                 try { [EOL]                     final Double d = NumberUtils.createDouble(numeric); [EOL]                     if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { [EOL]                         return d; [EOL]                     } [EOL]                 } catch (final NumberFormatException nfe) { [EOL]                 } [EOL]                 try { [EOL]                     return createBigDecimal(numeric); [EOL]                 } catch (final NumberFormatException e) { [EOL]                 } [EOL]             default: [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]         } [EOL]     } [EOL]     if (expPos > -1 && expPos < str.length() - 1) { [EOL]         exp = str.substring(expPos + 1, str.length()); [EOL]     } else { [EOL]         exp = null; [EOL]     } [EOL]     if (dec == null && exp == null) { [EOL]         try { [EOL]             return createInteger(str); [EOL]         } catch (final NumberFormatException nfe) { [EOL]         } [EOL]         try { [EOL]             return createLong(str); [EOL]         } catch (final NumberFormatException nfe) { [EOL]         } [EOL]         return createBigInteger(str); [EOL]     } [EOL]     final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL]     try { [EOL]         if (numDecimals <= 7) { [EOL]             final Float f = createFloat(str); [EOL]             if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL]                 return f; [EOL]             } [EOL]         } [EOL]     } catch (final NumberFormatException nfe) { [EOL]     } [EOL]     try { [EOL]         if (numDecimals <= 16) { [EOL]             final Double d = createDouble(str); [EOL]             if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { [EOL]                 return d; [EOL]             } [EOL]         } [EOL]     } catch (final NumberFormatException nfe) { [EOL]     } [EOL]     return createBigDecimal(str); [EOL] } 
 [LINE] try { [LINE] public static Number createNumber(final String str) throws NumberFormatException { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (StringUtils.isBlank(str)) { [EOL]         throw new NumberFormatException("A blank string is not a valid number"); [EOL]     } [EOL]     final String[] hex_prefixes = { "0x", "0X", "-0x", "-0X", "#", "-#" }; [EOL]     int pfxLen = 0; [EOL]     for (final String pfx : hex_prefixes) { [EOL]         if (str.startsWith(pfx)) { [EOL]             pfxLen += pfx.length(); [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (pfxLen > 0) { [EOL]         char firstSigDigit = 0; [EOL]         for (int i = pfxLen; i < str.length(); i++) { [EOL]             firstSigDigit = str.charAt(i); [EOL]             if (firstSigDigit == '0') { [EOL]                 pfxLen++; [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         final int hexDigits = str.length() - pfxLen; [EOL]         if (hexDigits > 16 || (hexDigits == 16 && firstSigDigit > '7')) { [EOL]             return createBigInteger(str); [EOL]         } [EOL]         if (hexDigits > 8 || (hexDigits == 8 && firstSigDigit > '7')) { [EOL]             return createLong(str); [EOL]         } [EOL]         return createInteger(str); [EOL]     } [EOL]     final char lastChar = str.charAt(str.length() - 1); [EOL]     String mant; [EOL]     String dec; [EOL]     String exp; [EOL]     final int decPos = str.indexOf('.'); [EOL]     final int expPos = str.indexOf('e') + str.indexOf('E') + 1; [EOL]     int numDecimals = 0; [EOL]     if (decPos > -1) { [EOL]         if (expPos > -1) { [EOL]             if (expPos < decPos || expPos > str.length()) { [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             } [EOL]             dec = str.substring(decPos + 1, expPos); [EOL]         } else { [EOL]             dec = str.substring(decPos + 1); [EOL]         } [EOL]         mant = str.substring(0, decPos); [EOL]         numDecimals = dec.length(); [EOL]     } else { [EOL]         if (expPos > -1) { [EOL]             if (expPos > str.length()) { [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             } [EOL]             mant = str.substring(0, expPos); [EOL]         } else { [EOL]             mant = str; [EOL]         } [EOL]         dec = null; [EOL]     } [EOL]     if (!Character.isDigit(lastChar) && lastChar != '.') { [EOL]         if (expPos > -1 && expPos < str.length() - 1) { [EOL]             exp = str.substring(expPos + 1, str.length() - 1); [EOL]         } else { [EOL]             exp = null; [EOL]         } [EOL]         final String numeric = str.substring(0, str.length() - 1); [EOL]         final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL]         switch(lastChar) { [EOL]             case 'l': [EOL]             case 'L': [EOL]                 if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { [EOL]                     try { [EOL]                         return createLong(numeric); [EOL]                     } catch (final NumberFormatException nfe) { [EOL]                     } [EOL]                     return createBigInteger(numeric); [EOL]                 } [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             case 'f': [EOL]             case 'F': [EOL]                 try { [EOL]                     final Float f = NumberUtils.createFloat(numeric); [EOL]                     if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL]                         return f; [EOL]                     } [EOL]                 } catch (final NumberFormatException nfe) { [EOL]                 } [EOL]             case 'd': [EOL]             case 'D': [EOL]                 try { [EOL]                     final Double d = NumberUtils.createDouble(numeric); [EOL]                     if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { [EOL]                         return d; [EOL]                     } [EOL]                 } catch (final NumberFormatException nfe) { [EOL]                 } [EOL]                 try { [EOL]                     return createBigDecimal(numeric); [EOL]                 } catch (final NumberFormatException e) { [EOL]                 } [EOL]             default: [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]         } [EOL]     } [EOL]     if (expPos > -1 && expPos < str.length() - 1) { [EOL]         exp = str.substring(expPos + 1, str.length()); [EOL]     } else { [EOL]         exp = null; [EOL]     } [EOL]     if (dec == null && exp == null) { [EOL]         try { [EOL]             return createInteger(str); [EOL]         } catch (final NumberFormatException nfe) { [EOL]         } [EOL]         try { [EOL]             return createLong(str); [EOL]         } catch (final NumberFormatException nfe) { [EOL]         } [EOL]         return createBigInteger(str); [EOL]     } [EOL]     final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL]     try { [EOL]         if (numDecimals <= 7) { [EOL]             final Float f = createFloat(str); [EOL]             if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL]                 return f; [EOL]             } [EOL]         } [EOL]     } catch (final NumberFormatException nfe) { [EOL]     } [EOL]     try { [EOL]         if (numDecimals <= 16) { [EOL]             final Double d = createDouble(str); [EOL]             if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { [EOL]                 return d; [EOL]             } [EOL]         } [EOL]     } catch (final NumberFormatException nfe) { [EOL]     } [EOL]     return createBigDecimal(str); [EOL] } 
 [LINE] try { [LINE] public static Number createNumber(final String str) throws NumberFormatException { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (StringUtils.isBlank(str)) { [EOL]         throw new NumberFormatException("A blank string is not a valid number"); [EOL]     } [EOL]     final String[] hex_prefixes = { "0x", "0X", "-0x", "-0X", "#", "-#" }; [EOL]     int pfxLen = 0; [EOL]     for (final String pfx : hex_prefixes) { [EOL]         if (str.startsWith(pfx)) { [EOL]             pfxLen += pfx.length(); [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (pfxLen > 0) { [EOL]         char firstSigDigit = 0; [EOL]         for (int i = pfxLen; i < str.length(); i++) { [EOL]             firstSigDigit = str.charAt(i); [EOL]             if (firstSigDigit == '0') { [EOL]                 pfxLen++; [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         final int hexDigits = str.length() - pfxLen; [EOL]         if (hexDigits > 16 || (hexDigits == 16 && firstSigDigit > '7')) { [EOL]             return createBigInteger(str); [EOL]         } [EOL]         if (hexDigits > 8 || (hexDigits == 8 && firstSigDigit > '7')) { [EOL]             return createLong(str); [EOL]         } [EOL]         return createInteger(str); [EOL]     } [EOL]     final char lastChar = str.charAt(str.length() - 1); [EOL]     String mant; [EOL]     String dec; [EOL]     String exp; [EOL]     final int decPos = str.indexOf('.'); [EOL]     final int expPos = str.indexOf('e') + str.indexOf('E') + 1; [EOL]     int numDecimals = 0; [EOL]     if (decPos > -1) { [EOL]         if (expPos > -1) { [EOL]             if (expPos < decPos || expPos > str.length()) { [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             } [EOL]             dec = str.substring(decPos + 1, expPos); [EOL]         } else { [EOL]             dec = str.substring(decPos + 1); [EOL]         } [EOL]         mant = str.substring(0, decPos); [EOL]         numDecimals = dec.length(); [EOL]     } else { [EOL]         if (expPos > -1) { [EOL]             if (expPos > str.length()) { [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             } [EOL]             mant = str.substring(0, expPos); [EOL]         } else { [EOL]             mant = str; [EOL]         } [EOL]         dec = null; [EOL]     } [EOL]     if (!Character.isDigit(lastChar) && lastChar != '.') { [EOL]         if (expPos > -1 && expPos < str.length() - 1) { [EOL]             exp = str.substring(expPos + 1, str.length() - 1); [EOL]         } else { [EOL]             exp = null; [EOL]         } [EOL]         final String numeric = str.substring(0, str.length() - 1); [EOL]         final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL]         switch(lastChar) { [EOL]             case 'l': [EOL]             case 'L': [EOL]                 if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { [EOL]                     try { [EOL]                         return createLong(numeric); [EOL]                     } catch (final NumberFormatException nfe) { [EOL]                     } [EOL]                     return createBigInteger(numeric); [EOL]                 } [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             case 'f': [EOL]             case 'F': [EOL]                 try { [EOL]                     final Float f = NumberUtils.createFloat(numeric); [EOL]                     if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL]                         return f; [EOL]                     } [EOL]                 } catch (final NumberFormatException nfe) { [EOL]                 } [EOL]             case 'd': [EOL]             case 'D': [EOL]                 try { [EOL]                     final Double d = NumberUtils.createDouble(numeric); [EOL]                     if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { [EOL]                         return d; [EOL]                     } [EOL]                 } catch (final NumberFormatException nfe) { [EOL]                 } [EOL]                 try { [EOL]                     return createBigDecimal(numeric); [EOL]                 } catch (final NumberFormatException e) { [EOL]                 } [EOL]             default: [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]         } [EOL]     } [EOL]     if (expPos > -1 && expPos < str.length() - 1) { [EOL]         exp = str.substring(expPos + 1, str.length()); [EOL]     } else { [EOL]         exp = null; [EOL]     } [EOL]     if (dec == null && exp == null) { [EOL]         try { [EOL]             return createInteger(str); [EOL]         } catch (final NumberFormatException nfe) { [EOL]         } [EOL]         try { [EOL]             return createLong(str); [EOL]         } catch (final NumberFormatException nfe) { [EOL]         } [EOL]         return createBigInteger(str); [EOL]     } [EOL]     final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL]     try { [EOL]         if (numDecimals <= 7) { [EOL]             final Float f = createFloat(str); [EOL]             if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL]                 return f; [EOL]             } [EOL]         } [EOL]     } catch (final NumberFormatException nfe) { [EOL]     } [EOL]     try { [EOL]         if (numDecimals <= 16) { [EOL]             final Double d = createDouble(str); [EOL]             if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { [EOL]                 return d; [EOL]             } [EOL]         } [EOL]     } catch (final NumberFormatException nfe) { [EOL]     } [EOL]     return createBigDecimal(str); [EOL] } 
 [LINE] final Double d = NumberUtils.createDouble(numeric); [LINE] public static Number createNumber(final String str) throws NumberFormatException { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (StringUtils.isBlank(str)) { [EOL]         throw new NumberFormatException("A blank string is not a valid number"); [EOL]     } [EOL]     final String[] hex_prefixes = { "0x", "0X", "-0x", "-0X", "#", "-#" }; [EOL]     int pfxLen = 0; [EOL]     for (final String pfx : hex_prefixes) { [EOL]         if (str.startsWith(pfx)) { [EOL]             pfxLen += pfx.length(); [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (pfxLen > 0) { [EOL]         char firstSigDigit = 0; [EOL]         for (int i = pfxLen; i < str.length(); i++) { [EOL]             firstSigDigit = str.charAt(i); [EOL]             if (firstSigDigit == '0') { [EOL]                 pfxLen++; [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         final int hexDigits = str.length() - pfxLen; [EOL]         if (hexDigits > 16 || (hexDigits == 16 && firstSigDigit > '7')) { [EOL]             return createBigInteger(str); [EOL]         } [EOL]         if (hexDigits > 8 || (hexDigits == 8 && firstSigDigit > '7')) { [EOL]             return createLong(str); [EOL]         } [EOL]         return createInteger(str); [EOL]     } [EOL]     final char lastChar = str.charAt(str.length() - 1); [EOL]     String mant; [EOL]     String dec; [EOL]     String exp; [EOL]     final int decPos = str.indexOf('.'); [EOL]     final int expPos = str.indexOf('e') + str.indexOf('E') + 1; [EOL]     int numDecimals = 0; [EOL]     if (decPos > -1) { [EOL]         if (expPos > -1) { [EOL]             if (expPos < decPos || expPos > str.length()) { [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             } [EOL]             dec = str.substring(decPos + 1, expPos); [EOL]         } else { [EOL]             dec = str.substring(decPos + 1); [EOL]         } [EOL]         mant = str.substring(0, decPos); [EOL]         numDecimals = dec.length(); [EOL]     } else { [EOL]         if (expPos > -1) { [EOL]             if (expPos > str.length()) { [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             } [EOL]             mant = str.substring(0, expPos); [EOL]         } else { [EOL]             mant = str; [EOL]         } [EOL]         dec = null; [EOL]     } [EOL]     if (!Character.isDigit(lastChar) && lastChar != '.') { [EOL]         if (expPos > -1 && expPos < str.length() - 1) { [EOL]             exp = str.substring(expPos + 1, str.length() - 1); [EOL]         } else { [EOL]             exp = null; [EOL]         } [EOL]         final String numeric = str.substring(0, str.length() - 1); [EOL]         final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL]         switch(lastChar) { [EOL]             case 'l': [EOL]             case 'L': [EOL]                 if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { [EOL]                     try { [EOL]                         return createLong(numeric); [EOL]                     } catch (final NumberFormatException nfe) { [EOL]                     } [EOL]                     return createBigInteger(numeric); [EOL]                 } [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             case 'f': [EOL]             case 'F': [EOL]                 try { [EOL]                     final Float f = NumberUtils.createFloat(numeric); [EOL]                     if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL]                         return f; [EOL]                     } [EOL]                 } catch (final NumberFormatException nfe) { [EOL]                 } [EOL]             case 'd': [EOL]             case 'D': [EOL]                 try { [EOL]                     final Double d = NumberUtils.createDouble(numeric); [EOL]                     if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { [EOL]                         return d; [EOL]                     } [EOL]                 } catch (final NumberFormatException nfe) { [EOL]                 } [EOL]                 try { [EOL]                     return createBigDecimal(numeric); [EOL]                 } catch (final NumberFormatException e) { [EOL]                 } [EOL]             default: [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]         } [EOL]     } [EOL]     if (expPos > -1 && expPos < str.length() - 1) { [EOL]         exp = str.substring(expPos + 1, str.length()); [EOL]     } else { [EOL]         exp = null; [EOL]     } [EOL]     if (dec == null && exp == null) { [EOL]         try { [EOL]             return createInteger(str); [EOL]         } catch (final NumberFormatException nfe) { [EOL]         } [EOL]         try { [EOL]             return createLong(str); [EOL]         } catch (final NumberFormatException nfe) { [EOL]         } [EOL]         return createBigInteger(str); [EOL]     } [EOL]     final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL]     try { [EOL]         if (numDecimals <= 7) { [EOL]             final Float f = createFloat(str); [EOL]             if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL]                 return f; [EOL]             } [EOL]         } [EOL]     } catch (final NumberFormatException nfe) { [EOL]     } [EOL]     try { [EOL]         if (numDecimals <= 16) { [EOL]             final Double d = createDouble(str); [EOL]             if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { [EOL]                 return d; [EOL]             } [EOL]         } [EOL]     } catch (final NumberFormatException nfe) { [EOL]     } [EOL]     return createBigDecimal(str); [EOL] } 
 [LINE] for (int i = str.length() - 1; i >= 0; i--) { [LINE] private static boolean isAllZeros(final String str) { [EOL]     if (str == null) { [EOL]         return true; [EOL]     } [EOL]     for (int i = str.length() - 1; i >= 0; i--) { [EOL]         if (str.charAt(i) != '0') { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return str.length() > 0; [EOL] } 
 [LINE] return false; [LINE] private static boolean isAllZeros(final String str) { [EOL]     if (str == null) { [EOL]         return true; [EOL]     } [EOL]     for (int i = str.length() - 1; i >= 0; i--) { [EOL]         if (str.charAt(i) != '0') { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return str.length() > 0; [EOL] } 
 [LINE] if (str == null) { [LINE] public static Double createDouble(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     return Double.valueOf(str); [EOL] } 
 [LINE] return null; [LINE] public static Long createLong(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     return Long.decode(str); [EOL] } 
 [LINE] pos += 2; [LINE] public static BigInteger createBigInteger(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     int pos = 0; [EOL]     int radix = 10; [EOL]     boolean negate = false; [EOL]     if (str.startsWith("-")) { [EOL]         negate = true; [EOL]         pos = 1; [EOL]     } [EOL]     if (str.startsWith("0x", pos) || str.startsWith("0x", pos)) { [EOL]         radix = 16; [EOL]         pos += 2; [EOL]     } else if (str.startsWith("#", pos)) { [EOL]         radix = 16; [EOL]         pos++; [EOL]     } else if (str.startsWith("0", pos) && str.length() > pos + 1) { [EOL]         radix = 8; [EOL]         pos++; [EOL]     } [EOL]     final BigInteger value = new BigInteger(str.substring(pos), radix); [EOL]     return negate ? value.negate() : value; [EOL] } 
 [LINE] radix = 8; [LINE] public static BigInteger createBigInteger(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     int pos = 0; [EOL]     int radix = 10; [EOL]     boolean negate = false; [EOL]     if (str.startsWith("-")) { [EOL]         negate = true; [EOL]         pos = 1; [EOL]     } [EOL]     if (str.startsWith("0x", pos) || str.startsWith("0x", pos)) { [EOL]         radix = 16; [EOL]         pos += 2; [EOL]     } else if (str.startsWith("#", pos)) { [EOL]         radix = 16; [EOL]         pos++; [EOL]     } else if (str.startsWith("0", pos) && str.length() > pos + 1) { [EOL]         radix = 8; [EOL]         pos++; [EOL]     } [EOL]     final BigInteger value = new BigInteger(str.substring(pos), radix); [EOL]     return negate ? value.negate() : value; [EOL] } 
 [LINE] return negate ? value.negate() : value; [LINE] public static BigInteger createBigInteger(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     int pos = 0; [EOL]     int radix = 10; [EOL]     boolean negate = false; [EOL]     if (str.startsWith("-")) { [EOL]         negate = true; [EOL]         pos = 1; [EOL]     } [EOL]     if (str.startsWith("0x", pos) || str.startsWith("0x", pos)) { [EOL]         radix = 16; [EOL]         pos += 2; [EOL]     } else if (str.startsWith("#", pos)) { [EOL]         radix = 16; [EOL]         pos++; [EOL]     } else if (str.startsWith("0", pos) && str.length() > pos + 1) { [EOL]         radix = 8; [EOL]         pos++; [EOL]     } [EOL]     final BigInteger value = new BigInteger(str.substring(pos), radix); [EOL]     return negate ? value.negate() : value; [EOL] } 
 [LINE] return new BigDecimal(str); [LINE] public static BigDecimal createBigDecimal(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (StringUtils.isBlank(str)) { [EOL]         throw new NumberFormatException("A blank string is not a valid number"); [EOL]     } [EOL]     if (str.trim().startsWith("--")) { [EOL]         throw new NumberFormatException(str + " is not a valid number."); [EOL]     } [EOL]     return new BigDecimal(str); [EOL] } 
 [LINE] for (int i = 1; i < array.length; i++) { [LINE] public static long min(final long[] array) { [EOL]     validateArray(array); [EOL]     long min = array[0]; [EOL]     for (int i = 1; i < array.length; i++) { [EOL]         if (array[i] < min) { [EOL]             min = array[i]; [EOL]         } [EOL]     } [EOL]     return min; [EOL] } 
 [LINE] if (array[i] < min) { [LINE] public static long min(final long[] array) { [EOL]     validateArray(array); [EOL]     long min = array[0]; [EOL]     for (int i = 1; i < array.length; i++) { [EOL]         if (array[i] < min) { [EOL]             min = array[i]; [EOL]         } [EOL]     } [EOL]     return min; [EOL] } 
 [LINE] min = array[j]; [LINE] public static int min(final int[] array) { [EOL]     validateArray(array); [EOL]     int min = array[0]; [EOL]     for (int j = 1; j < array.length; j++) { [EOL]         if (array[j] < min) { [EOL]             min = array[j]; [EOL]         } [EOL]     } [EOL]     return min; [EOL] } 
 [LINE] return min; [LINE] public static int min(final int[] array) { [EOL]     validateArray(array); [EOL]     int min = array[0]; [EOL]     for (int j = 1; j < array.length; j++) { [EOL]         if (array[j] < min) { [EOL]             min = array[j]; [EOL]         } [EOL]     } [EOL]     return min; [EOL] } 
 [LINE] short min = array[0]; [LINE] public static short min(final short[] array) { [EOL]     validateArray(array); [EOL]     short min = array[0]; [EOL]     for (int i = 1; i < array.length; i++) { [EOL]         if (array[i] < min) { [EOL]             min = array[i]; [EOL]         } [EOL]     } [EOL]     return min; [EOL] } 
 [LINE] validateArray(array); [LINE] public static byte min(final byte[] array) { [EOL]     validateArray(array); [EOL]     byte min = array[0]; [EOL]     for (int i = 1; i < array.length; i++) { [EOL]         if (array[i] < min) { [EOL]             min = array[i]; [EOL]         } [EOL]     } [EOL]     return min; [EOL] } 
 [LINE] for (int i = 1; i < array.length; i++) { [LINE] public static byte min(final byte[] array) { [EOL]     validateArray(array); [EOL]     byte min = array[0]; [EOL]     for (int i = 1; i < array.length; i++) { [EOL]         if (array[i] < min) { [EOL]             min = array[i]; [EOL]         } [EOL]     } [EOL]     return min; [EOL] } 
 [LINE] double min = array[0]; [LINE] public static double min(final double[] array) { [EOL]     validateArray(array); [EOL]     double min = array[0]; [EOL]     for (int i = 1; i < array.length; i++) { [EOL]         if (Double.isNaN(array[i])) { [EOL]             return Double.NaN; [EOL]         } [EOL]         if (array[i] < min) { [EOL]             min = array[i]; [EOL]         } [EOL]     } [EOL]     return min; [EOL] } 
 [LINE] long max = array[0]; [LINE] public static long max(final long[] array) { [EOL]     validateArray(array); [EOL]     long max = array[0]; [EOL]     for (int j = 1; j < array.length; j++) { [EOL]         if (array[j] > max) { [EOL]             max = array[j]; [EOL]         } [EOL]     } [EOL]     return max; [EOL] } 
 [LINE] for (int j = 1; j < array.length; j++) { [LINE] public static int max(final int[] array) { [EOL]     validateArray(array); [EOL]     int max = array[0]; [EOL]     for (int j = 1; j < array.length; j++) { [EOL]         if (array[j] > max) { [EOL]             max = array[j]; [EOL]         } [EOL]     } [EOL]     return max; [EOL] } 
 [LINE] if (array[j] > max) { [LINE] public static int max(final int[] array) { [EOL]     validateArray(array); [EOL]     int max = array[0]; [EOL]     for (int j = 1; j < array.length; j++) { [EOL]         if (array[j] > max) { [EOL]             max = array[j]; [EOL]         } [EOL]     } [EOL]     return max; [EOL] } 
 [LINE] short max = array[0]; [LINE] public static short max(final short[] array) { [EOL]     validateArray(array); [EOL]     short max = array[0]; [EOL]     for (int i = 1; i < array.length; i++) { [EOL]         if (array[i] > max) { [EOL]             max = array[i]; [EOL]         } [EOL]     } [EOL]     return max; [EOL] } 
 [LINE] validateArray(array); [LINE] public static double max(final double[] array) { [EOL]     validateArray(array); [EOL]     double max = array[0]; [EOL]     for (int j = 1; j < array.length; j++) { [EOL]         if (Double.isNaN(array[j])) { [EOL]             return Double.NaN; [EOL]         } [EOL]         if (array[j] > max) { [EOL]             max = array[j]; [EOL]         } [EOL]     } [EOL]     return max; [EOL] } 
 [LINE] for (int j = 1; j < array.length; j++) { [LINE] public static double max(final double[] array) { [EOL]     validateArray(array); [EOL]     double max = array[0]; [EOL]     for (int j = 1; j < array.length; j++) { [EOL]         if (Double.isNaN(array[j])) { [EOL]             return Double.NaN; [EOL]         } [EOL]         if (array[j] > max) { [EOL]             max = array[j]; [EOL]         } [EOL]     } [EOL]     return max; [EOL] } 
 [LINE] return Double.NaN; [LINE] public static double max(final double[] array) { [EOL]     validateArray(array); [EOL]     double max = array[0]; [EOL]     for (int j = 1; j < array.length; j++) { [EOL]         if (Double.isNaN(array[j])) { [EOL]             return Double.NaN; [EOL]         } [EOL]         if (array[j] > max) { [EOL]             max = array[j]; [EOL]         } [EOL]     } [EOL]     return max; [EOL] } 
 [LINE] a = b; [LINE] public static long min(long a, final long b, final long c) { [EOL]     if (b < a) { [EOL]         a = b; [EOL]     } [EOL]     if (c < a) { [EOL]         a = c; [EOL]     } [EOL]     return a; [EOL] } 
 [LINE] a = c; [LINE] public static long min(long a, final long b, final long c) { [EOL]     if (b < a) { [EOL]         a = b; [EOL]     } [EOL]     if (c < a) { [EOL]         a = c; [EOL]     } [EOL]     return a; [EOL] } 
 [LINE] a = c; [LINE] public static int min(int a, final int b, final int c) { [EOL]     if (b < a) { [EOL]         a = b; [EOL]     } [EOL]     if (c < a) { [EOL]         a = c; [EOL]     } [EOL]     return a; [EOL] } 
 [LINE] if (c < a) { [LINE] public static short min(short a, final short b, final short c) { [EOL]     if (b < a) { [EOL]         a = b; [EOL]     } [EOL]     if (c < a) { [EOL]         a = c; [EOL]     } [EOL]     return a; [EOL] } 
 [LINE] a = c; [LINE] public static int max(int a, final int b, final int c) { [EOL]     if (b > a) { [EOL]         a = b; [EOL]     } [EOL]     if (c > a) { [EOL]         a = c; [EOL]     } [EOL]     return a; [EOL] } 
 [LINE] a = b; [LINE] public static short max(short a, final short b, final short c) { [EOL]     if (b > a) { [EOL]         a = b; [EOL]     } [EOL]     if (c > a) { [EOL]         a = c; [EOL]     } [EOL]     return a; [EOL] } 
 [LINE] return Math.max(Math.max(a, b), c); [LINE] public static float max(final float a, final float b, final float c) { [EOL]     return Math.max(Math.max(a, b), c); [EOL] } 
 [LINE] return false; [LINE] public static boolean isDigits(final String str) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return false; [EOL]     } [EOL]     for (int i = 0; i < str.length(); i++) { [EOL]         if (!Character.isDigit(str.charAt(i))) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] return false; [LINE] public static boolean isDigits(final String str) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return false; [EOL]     } [EOL]     for (int i = 0; i < str.length(); i++) { [EOL]         if (!Character.isDigit(str.charAt(i))) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] return true; [LINE] public static boolean isDigits(final String str) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return false; [EOL]     } [EOL]     for (int i = 0; i < str.length(); i++) { [EOL]         if (!Character.isDigit(str.charAt(i))) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] return false; [LINE] public static boolean isNumber(final String str) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return false; [EOL]     } [EOL]     final char[] chars = str.toCharArray(); [EOL]     int sz = chars.length; [EOL]     boolean hasExp = false; [EOL]     boolean hasDecPoint = false; [EOL]     boolean allowSigns = false; [EOL]     boolean foundDigit = false; [EOL]     final int start = (chars[0] == '-') ? 1 : 0; [EOL]     if (sz > start + 1 && chars[start] == '0' && chars[start + 1] == 'x') { [EOL]         int i = start + 2; [EOL]         if (i == sz) { [EOL]             return false; [EOL]         } [EOL]         for (; i < chars.length; i++) { [EOL]             if ((chars[i] < '0' || chars[i] > '9') && (chars[i] < 'a' || chars[i] > 'f') && (chars[i] < 'A' || chars[i] > 'F')) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     sz--; [EOL]     int i = start; [EOL]     while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             foundDigit = true; [EOL]             allowSigns = false; [EOL]         } else if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             hasDecPoint = true; [EOL]         } else if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             if (hasExp) { [EOL]                 return false; [EOL]             } [EOL]             if (!foundDigit) { [EOL]                 return false; [EOL]             } [EOL]             hasExp = true; [EOL]             allowSigns = true; [EOL]         } else if (chars[i] == '+' || chars[i] == '-') { [EOL]             if (!allowSigns) { [EOL]                 return false; [EOL]             } [EOL]             allowSigns = false; [EOL]             foundDigit = false; [EOL]         } else { [EOL]             return false; [EOL]         } [EOL]         i++; [EOL]     } [EOL]     if (i < chars.length) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             return true; [EOL]         } [EOL]         if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             return false; [EOL]         } [EOL]         if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             return foundDigit; [EOL]         } [EOL]         if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D' || chars[i] == 'f' || chars[i] == 'F')) { [EOL]             return foundDigit; [EOL]         } [EOL]         if (chars[i] == 'l' || chars[i] == 'L') { [EOL]             return foundDigit && !hasExp && !hasDecPoint; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return !allowSigns && foundDigit; [EOL] } 
 [LINE] int sz = chars.length; [LINE] public static boolean isNumber(final String str) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return false; [EOL]     } [EOL]     final char[] chars = str.toCharArray(); [EOL]     int sz = chars.length; [EOL]     boolean hasExp = false; [EOL]     boolean hasDecPoint = false; [EOL]     boolean allowSigns = false; [EOL]     boolean foundDigit = false; [EOL]     final int start = (chars[0] == '-') ? 1 : 0; [EOL]     if (sz > start + 1 && chars[start] == '0' && chars[start + 1] == 'x') { [EOL]         int i = start + 2; [EOL]         if (i == sz) { [EOL]             return false; [EOL]         } [EOL]         for (; i < chars.length; i++) { [EOL]             if ((chars[i] < '0' || chars[i] > '9') && (chars[i] < 'a' || chars[i] > 'f') && (chars[i] < 'A' || chars[i] > 'F')) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     sz--; [EOL]     int i = start; [EOL]     while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             foundDigit = true; [EOL]             allowSigns = false; [EOL]         } else if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             hasDecPoint = true; [EOL]         } else if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             if (hasExp) { [EOL]                 return false; [EOL]             } [EOL]             if (!foundDigit) { [EOL]                 return false; [EOL]             } [EOL]             hasExp = true; [EOL]             allowSigns = true; [EOL]         } else if (chars[i] == '+' || chars[i] == '-') { [EOL]             if (!allowSigns) { [EOL]                 return false; [EOL]             } [EOL]             allowSigns = false; [EOL]             foundDigit = false; [EOL]         } else { [EOL]             return false; [EOL]         } [EOL]         i++; [EOL]     } [EOL]     if (i < chars.length) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             return true; [EOL]         } [EOL]         if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             return false; [EOL]         } [EOL]         if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             return foundDigit; [EOL]         } [EOL]         if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D' || chars[i] == 'f' || chars[i] == 'F')) { [EOL]             return foundDigit; [EOL]         } [EOL]         if (chars[i] == 'l' || chars[i] == 'L') { [EOL]             return foundDigit && !hasExp && !hasDecPoint; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return !allowSigns && foundDigit; [EOL] } 
 [LINE] boolean hasDecPoint = false; [LINE] public static boolean isNumber(final String str) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return false; [EOL]     } [EOL]     final char[] chars = str.toCharArray(); [EOL]     int sz = chars.length; [EOL]     boolean hasExp = false; [EOL]     boolean hasDecPoint = false; [EOL]     boolean allowSigns = false; [EOL]     boolean foundDigit = false; [EOL]     final int start = (chars[0] == '-') ? 1 : 0; [EOL]     if (sz > start + 1 && chars[start] == '0' && chars[start + 1] == 'x') { [EOL]         int i = start + 2; [EOL]         if (i == sz) { [EOL]             return false; [EOL]         } [EOL]         for (; i < chars.length; i++) { [EOL]             if ((chars[i] < '0' || chars[i] > '9') && (chars[i] < 'a' || chars[i] > 'f') && (chars[i] < 'A' || chars[i] > 'F')) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     sz--; [EOL]     int i = start; [EOL]     while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             foundDigit = true; [EOL]             allowSigns = false; [EOL]         } else if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             hasDecPoint = true; [EOL]         } else if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             if (hasExp) { [EOL]                 return false; [EOL]             } [EOL]             if (!foundDigit) { [EOL]                 return false; [EOL]             } [EOL]             hasExp = true; [EOL]             allowSigns = true; [EOL]         } else if (chars[i] == '+' || chars[i] == '-') { [EOL]             if (!allowSigns) { [EOL]                 return false; [EOL]             } [EOL]             allowSigns = false; [EOL]             foundDigit = false; [EOL]         } else { [EOL]             return false; [EOL]         } [EOL]         i++; [EOL]     } [EOL]     if (i < chars.length) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             return true; [EOL]         } [EOL]         if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             return false; [EOL]         } [EOL]         if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             return foundDigit; [EOL]         } [EOL]         if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D' || chars[i] == 'f' || chars[i] == 'F')) { [EOL]             return foundDigit; [EOL]         } [EOL]         if (chars[i] == 'l' || chars[i] == 'L') { [EOL]             return foundDigit && !hasExp && !hasDecPoint; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return !allowSigns && foundDigit; [EOL] } 
 [LINE] while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) { [LINE] public static boolean isNumber(final String str) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return false; [EOL]     } [EOL]     final char[] chars = str.toCharArray(); [EOL]     int sz = chars.length; [EOL]     boolean hasExp = false; [EOL]     boolean hasDecPoint = false; [EOL]     boolean allowSigns = false; [EOL]     boolean foundDigit = false; [EOL]     final int start = (chars[0] == '-') ? 1 : 0; [EOL]     if (sz > start + 1 && chars[start] == '0' && chars[start + 1] == 'x') { [EOL]         int i = start + 2; [EOL]         if (i == sz) { [EOL]             return false; [EOL]         } [EOL]         for (; i < chars.length; i++) { [EOL]             if ((chars[i] < '0' || chars[i] > '9') && (chars[i] < 'a' || chars[i] > 'f') && (chars[i] < 'A' || chars[i] > 'F')) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     sz--; [EOL]     int i = start; [EOL]     while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             foundDigit = true; [EOL]             allowSigns = false; [EOL]         } else if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             hasDecPoint = true; [EOL]         } else if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             if (hasExp) { [EOL]                 return false; [EOL]             } [EOL]             if (!foundDigit) { [EOL]                 return false; [EOL]             } [EOL]             hasExp = true; [EOL]             allowSigns = true; [EOL]         } else if (chars[i] == '+' || chars[i] == '-') { [EOL]             if (!allowSigns) { [EOL]                 return false; [EOL]             } [EOL]             allowSigns = false; [EOL]             foundDigit = false; [EOL]         } else { [EOL]             return false; [EOL]         } [EOL]         i++; [EOL]     } [EOL]     if (i < chars.length) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             return true; [EOL]         } [EOL]         if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             return false; [EOL]         } [EOL]         if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             return foundDigit; [EOL]         } [EOL]         if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D' || chars[i] == 'f' || chars[i] == 'F')) { [EOL]             return foundDigit; [EOL]         } [EOL]         if (chars[i] == 'l' || chars[i] == 'L') { [EOL]             return foundDigit && !hasExp && !hasDecPoint; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return !allowSigns && foundDigit; [EOL] } 
 [LINE] } else if (chars[i] == '.') { [LINE] public static boolean isNumber(final String str) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return false; [EOL]     } [EOL]     final char[] chars = str.toCharArray(); [EOL]     int sz = chars.length; [EOL]     boolean hasExp = false; [EOL]     boolean hasDecPoint = false; [EOL]     boolean allowSigns = false; [EOL]     boolean foundDigit = false; [EOL]     final int start = (chars[0] == '-') ? 1 : 0; [EOL]     if (sz > start + 1 && chars[start] == '0' && chars[start + 1] == 'x') { [EOL]         int i = start + 2; [EOL]         if (i == sz) { [EOL]             return false; [EOL]         } [EOL]         for (; i < chars.length; i++) { [EOL]             if ((chars[i] < '0' || chars[i] > '9') && (chars[i] < 'a' || chars[i] > 'f') && (chars[i] < 'A' || chars[i] > 'F')) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     sz--; [EOL]     int i = start; [EOL]     while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             foundDigit = true; [EOL]             allowSigns = false; [EOL]         } else if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             hasDecPoint = true; [EOL]         } else if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             if (hasExp) { [EOL]                 return false; [EOL]             } [EOL]             if (!foundDigit) { [EOL]                 return false; [EOL]             } [EOL]             hasExp = true; [EOL]             allowSigns = true; [EOL]         } else if (chars[i] == '+' || chars[i] == '-') { [EOL]             if (!allowSigns) { [EOL]                 return false; [EOL]             } [EOL]             allowSigns = false; [EOL]             foundDigit = false; [EOL]         } else { [EOL]             return false; [EOL]         } [EOL]         i++; [EOL]     } [EOL]     if (i < chars.length) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             return true; [EOL]         } [EOL]         if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             return false; [EOL]         } [EOL]         if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             return foundDigit; [EOL]         } [EOL]         if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D' || chars[i] == 'f' || chars[i] == 'F')) { [EOL]             return foundDigit; [EOL]         } [EOL]         if (chars[i] == 'l' || chars[i] == 'L') { [EOL]             return foundDigit && !hasExp && !hasDecPoint; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return !allowSigns && foundDigit; [EOL] } 
 [LINE] if (hasDecPoint || hasExp) { [LINE] public static boolean isNumber(final String str) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return false; [EOL]     } [EOL]     final char[] chars = str.toCharArray(); [EOL]     int sz = chars.length; [EOL]     boolean hasExp = false; [EOL]     boolean hasDecPoint = false; [EOL]     boolean allowSigns = false; [EOL]     boolean foundDigit = false; [EOL]     final int start = (chars[0] == '-') ? 1 : 0; [EOL]     if (sz > start + 1 && chars[start] == '0' && chars[start + 1] == 'x') { [EOL]         int i = start + 2; [EOL]         if (i == sz) { [EOL]             return false; [EOL]         } [EOL]         for (; i < chars.length; i++) { [EOL]             if ((chars[i] < '0' || chars[i] > '9') && (chars[i] < 'a' || chars[i] > 'f') && (chars[i] < 'A' || chars[i] > 'F')) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     sz--; [EOL]     int i = start; [EOL]     while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             foundDigit = true; [EOL]             allowSigns = false; [EOL]         } else if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             hasDecPoint = true; [EOL]         } else if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             if (hasExp) { [EOL]                 return false; [EOL]             } [EOL]             if (!foundDigit) { [EOL]                 return false; [EOL]             } [EOL]             hasExp = true; [EOL]             allowSigns = true; [EOL]         } else if (chars[i] == '+' || chars[i] == '-') { [EOL]             if (!allowSigns) { [EOL]                 return false; [EOL]             } [EOL]             allowSigns = false; [EOL]             foundDigit = false; [EOL]         } else { [EOL]             return false; [EOL]         } [EOL]         i++; [EOL]     } [EOL]     if (i < chars.length) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             return true; [EOL]         } [EOL]         if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             return false; [EOL]         } [EOL]         if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             return foundDigit; [EOL]         } [EOL]         if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D' || chars[i] == 'f' || chars[i] == 'F')) { [EOL]             return foundDigit; [EOL]         } [EOL]         if (chars[i] == 'l' || chars[i] == 'L') { [EOL]             return foundDigit && !hasExp && !hasDecPoint; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return !allowSigns && foundDigit; [EOL] } 
 [LINE] } else if (chars[i] == 'e' || chars[i] == 'E') { [LINE] public static boolean isNumber(final String str) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return false; [EOL]     } [EOL]     final char[] chars = str.toCharArray(); [EOL]     int sz = chars.length; [EOL]     boolean hasExp = false; [EOL]     boolean hasDecPoint = false; [EOL]     boolean allowSigns = false; [EOL]     boolean foundDigit = false; [EOL]     final int start = (chars[0] == '-') ? 1 : 0; [EOL]     if (sz > start + 1 && chars[start] == '0' && chars[start + 1] == 'x') { [EOL]         int i = start + 2; [EOL]         if (i == sz) { [EOL]             return false; [EOL]         } [EOL]         for (; i < chars.length; i++) { [EOL]             if ((chars[i] < '0' || chars[i] > '9') && (chars[i] < 'a' || chars[i] > 'f') && (chars[i] < 'A' || chars[i] > 'F')) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     sz--; [EOL]     int i = start; [EOL]     while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             foundDigit = true; [EOL]             allowSigns = false; [EOL]         } else if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             hasDecPoint = true; [EOL]         } else if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             if (hasExp) { [EOL]                 return false; [EOL]             } [EOL]             if (!foundDigit) { [EOL]                 return false; [EOL]             } [EOL]             hasExp = true; [EOL]             allowSigns = true; [EOL]         } else if (chars[i] == '+' || chars[i] == '-') { [EOL]             if (!allowSigns) { [EOL]                 return false; [EOL]             } [EOL]             allowSigns = false; [EOL]             foundDigit = false; [EOL]         } else { [EOL]             return false; [EOL]         } [EOL]         i++; [EOL]     } [EOL]     if (i < chars.length) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             return true; [EOL]         } [EOL]         if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             return false; [EOL]         } [EOL]         if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             return foundDigit; [EOL]         } [EOL]         if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D' || chars[i] == 'f' || chars[i] == 'F')) { [EOL]             return foundDigit; [EOL]         } [EOL]         if (chars[i] == 'l' || chars[i] == 'L') { [EOL]             return foundDigit && !hasExp && !hasDecPoint; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return !allowSigns && foundDigit; [EOL] } 
 [LINE] i++; [LINE] public static boolean isNumber(final String str) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return false; [EOL]     } [EOL]     final char[] chars = str.toCharArray(); [EOL]     int sz = chars.length; [EOL]     boolean hasExp = false; [EOL]     boolean hasDecPoint = false; [EOL]     boolean allowSigns = false; [EOL]     boolean foundDigit = false; [EOL]     final int start = (chars[0] == '-') ? 1 : 0; [EOL]     if (sz > start + 1 && chars[start] == '0' && chars[start + 1] == 'x') { [EOL]         int i = start + 2; [EOL]         if (i == sz) { [EOL]             return false; [EOL]         } [EOL]         for (; i < chars.length; i++) { [EOL]             if ((chars[i] < '0' || chars[i] > '9') && (chars[i] < 'a' || chars[i] > 'f') && (chars[i] < 'A' || chars[i] > 'F')) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     sz--; [EOL]     int i = start; [EOL]     while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             foundDigit = true; [EOL]             allowSigns = false; [EOL]         } else if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             hasDecPoint = true; [EOL]         } else if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             if (hasExp) { [EOL]                 return false; [EOL]             } [EOL]             if (!foundDigit) { [EOL]                 return false; [EOL]             } [EOL]             hasExp = true; [EOL]             allowSigns = true; [EOL]         } else if (chars[i] == '+' || chars[i] == '-') { [EOL]             if (!allowSigns) { [EOL]                 return false; [EOL]             } [EOL]             allowSigns = false; [EOL]             foundDigit = false; [EOL]         } else { [EOL]             return false; [EOL]         } [EOL]         i++; [EOL]     } [EOL]     if (i < chars.length) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             return true; [EOL]         } [EOL]         if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             return false; [EOL]         } [EOL]         if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             return foundDigit; [EOL]         } [EOL]         if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D' || chars[i] == 'f' || chars[i] == 'F')) { [EOL]             return foundDigit; [EOL]         } [EOL]         if (chars[i] == 'l' || chars[i] == 'L') { [EOL]             return foundDigit && !hasExp && !hasDecPoint; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return !allowSigns && foundDigit; [EOL] } 
 [LINE] if (chars[i] == '.') { [LINE] public static boolean isNumber(final String str) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return false; [EOL]     } [EOL]     final char[] chars = str.toCharArray(); [EOL]     int sz = chars.length; [EOL]     boolean hasExp = false; [EOL]     boolean hasDecPoint = false; [EOL]     boolean allowSigns = false; [EOL]     boolean foundDigit = false; [EOL]     final int start = (chars[0] == '-') ? 1 : 0; [EOL]     if (sz > start + 1 && chars[start] == '0' && chars[start + 1] == 'x') { [EOL]         int i = start + 2; [EOL]         if (i == sz) { [EOL]             return false; [EOL]         } [EOL]         for (; i < chars.length; i++) { [EOL]             if ((chars[i] < '0' || chars[i] > '9') && (chars[i] < 'a' || chars[i] > 'f') && (chars[i] < 'A' || chars[i] > 'F')) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     sz--; [EOL]     int i = start; [EOL]     while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             foundDigit = true; [EOL]             allowSigns = false; [EOL]         } else if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             hasDecPoint = true; [EOL]         } else if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             if (hasExp) { [EOL]                 return false; [EOL]             } [EOL]             if (!foundDigit) { [EOL]                 return false; [EOL]             } [EOL]             hasExp = true; [EOL]             allowSigns = true; [EOL]         } else if (chars[i] == '+' || chars[i] == '-') { [EOL]             if (!allowSigns) { [EOL]                 return false; [EOL]             } [EOL]             allowSigns = false; [EOL]             foundDigit = false; [EOL]         } else { [EOL]             return false; [EOL]         } [EOL]         i++; [EOL]     } [EOL]     if (i < chars.length) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             return true; [EOL]         } [EOL]         if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             return false; [EOL]         } [EOL]         if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             return foundDigit; [EOL]         } [EOL]         if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D' || chars[i] == 'f' || chars[i] == 'F')) { [EOL]             return foundDigit; [EOL]         } [EOL]         if (chars[i] == 'l' || chars[i] == 'L') { [EOL]             return foundDigit && !hasExp && !hasDecPoint; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return !allowSigns && foundDigit; [EOL] } 
 [LINE] return foundDigit; [LINE] public static boolean isNumber(final String str) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return false; [EOL]     } [EOL]     final char[] chars = str.toCharArray(); [EOL]     int sz = chars.length; [EOL]     boolean hasExp = false; [EOL]     boolean hasDecPoint = false; [EOL]     boolean allowSigns = false; [EOL]     boolean foundDigit = false; [EOL]     final int start = (chars[0] == '-') ? 1 : 0; [EOL]     if (sz > start + 1 && chars[start] == '0' && chars[start + 1] == 'x') { [EOL]         int i = start + 2; [EOL]         if (i == sz) { [EOL]             return false; [EOL]         } [EOL]         for (; i < chars.length; i++) { [EOL]             if ((chars[i] < '0' || chars[i] > '9') && (chars[i] < 'a' || chars[i] > 'f') && (chars[i] < 'A' || chars[i] > 'F')) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     sz--; [EOL]     int i = start; [EOL]     while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             foundDigit = true; [EOL]             allowSigns = false; [EOL]         } else if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             hasDecPoint = true; [EOL]         } else if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             if (hasExp) { [EOL]                 return false; [EOL]             } [EOL]             if (!foundDigit) { [EOL]                 return false; [EOL]             } [EOL]             hasExp = true; [EOL]             allowSigns = true; [EOL]         } else if (chars[i] == '+' || chars[i] == '-') { [EOL]             if (!allowSigns) { [EOL]                 return false; [EOL]             } [EOL]             allowSigns = false; [EOL]             foundDigit = false; [EOL]         } else { [EOL]             return false; [EOL]         } [EOL]         i++; [EOL]     } [EOL]     if (i < chars.length) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             return true; [EOL]         } [EOL]         if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             return false; [EOL]         } [EOL]         if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             return foundDigit; [EOL]         } [EOL]         if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D' || chars[i] == 'f' || chars[i] == 'F')) { [EOL]             return foundDigit; [EOL]         } [EOL]         if (chars[i] == 'l' || chars[i] == 'L') { [EOL]             return foundDigit && !hasExp && !hasDecPoint; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return !allowSigns && foundDigit; [EOL] } 
lang3/StringUtils.java
 [LINE] return true; [LINE] public static boolean isBlank(final CharSequence cs) { [EOL]     int strLen; [EOL]     if (cs == null || (strLen = cs.length()) == 0) { [EOL]         return true; [EOL]     } [EOL]     for (int i = 0; i < strLen; i++) { [EOL]         if (Character.isWhitespace(cs.charAt(i)) == false) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] for (int i = 0; i < strLen; i++) { [LINE] public static boolean isBlank(final CharSequence cs) { [EOL]     int strLen; [EOL]     if (cs == null || (strLen = cs.length()) == 0) { [EOL]         return true; [EOL]     } [EOL]     for (int i = 0; i < strLen; i++) { [EOL]         if (Character.isWhitespace(cs.charAt(i)) == false) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] return !StringUtils.isBlank(cs); [LINE] public static boolean isNotBlank(final CharSequence cs) { [EOL]     return !StringUtils.isBlank(cs); [EOL] } 
 [LINE] final String ts = trim(str); [LINE] public static String trimToNull(final String str) { [EOL]     final String ts = trim(str); [EOL]     return isEmpty(ts) ? null : ts; [EOL] } 
 [LINE] int start = 0; [LINE] public static String stripStart(final String str, final String stripChars) { [EOL]     int strLen; [EOL]     if (str == null || (strLen = str.length()) == 0) { [EOL]         return str; [EOL]     } [EOL]     int start = 0; [EOL]     if (stripChars == null) { [EOL]         while (start != strLen && Character.isWhitespace(str.charAt(start))) { [EOL]             start++; [EOL]         } [EOL]     } else if (stripChars.isEmpty()) { [EOL]         return str; [EOL]     } else { [EOL]         while (start != strLen && stripChars.indexOf(str.charAt(start)) != INDEX_NOT_FOUND) { [EOL]             start++; [EOL]         } [EOL]     } [EOL]     return str.substring(start); [EOL] } 
 [LINE] start++; [LINE] public static String stripStart(final String str, final String stripChars) { [EOL]     int strLen; [EOL]     if (str == null || (strLen = str.length()) == 0) { [EOL]         return str; [EOL]     } [EOL]     int start = 0; [EOL]     if (stripChars == null) { [EOL]         while (start != strLen && Character.isWhitespace(str.charAt(start))) { [EOL]             start++; [EOL]         } [EOL]     } else if (stripChars.isEmpty()) { [EOL]         return str; [EOL]     } else { [EOL]         while (start != strLen && stripChars.indexOf(str.charAt(start)) != INDEX_NOT_FOUND) { [EOL]             start++; [EOL]         } [EOL]     } [EOL]     return str.substring(start); [EOL] } 
 [LINE] while (start != strLen && stripChars.indexOf(str.charAt(start)) != INDEX_NOT_FOUND) { [LINE] public static String stripStart(final String str, final String stripChars) { [EOL]     int strLen; [EOL]     if (str == null || (strLen = str.length()) == 0) { [EOL]         return str; [EOL]     } [EOL]     int start = 0; [EOL]     if (stripChars == null) { [EOL]         while (start != strLen && Character.isWhitespace(str.charAt(start))) { [EOL]             start++; [EOL]         } [EOL]     } else if (stripChars.isEmpty()) { [EOL]         return str; [EOL]     } else { [EOL]         while (start != strLen && stripChars.indexOf(str.charAt(start)) != INDEX_NOT_FOUND) { [EOL]             start++; [EOL]         } [EOL]     } [EOL]     return str.substring(start); [EOL] } 
 [LINE] if (str == null || (end = str.length()) == 0) { [LINE] public static String stripEnd(final String str, final String stripChars) { [EOL]     int end; [EOL]     if (str == null || (end = str.length()) == 0) { [EOL]         return str; [EOL]     } [EOL]     if (stripChars == null) { [EOL]         while (end != 0 && Character.isWhitespace(str.charAt(end - 1))) { [EOL]             end--; [EOL]         } [EOL]     } else if (stripChars.isEmpty()) { [EOL]         return str; [EOL]     } else { [EOL]         while (end != 0 && stripChars.indexOf(str.charAt(end - 1)) != INDEX_NOT_FOUND) { [EOL]             end--; [EOL]         } [EOL]     } [EOL]     return str.substring(0, end); [EOL] } 
 [LINE] end--; [LINE] public static String stripEnd(final String str, final String stripChars) { [EOL]     int end; [EOL]     if (str == null || (end = str.length()) == 0) { [EOL]         return str; [EOL]     } [EOL]     if (stripChars == null) { [EOL]         while (end != 0 && Character.isWhitespace(str.charAt(end - 1))) { [EOL]             end--; [EOL]         } [EOL]     } else if (stripChars.isEmpty()) { [EOL]         return str; [EOL]     } else { [EOL]         while (end != 0 && stripChars.indexOf(str.charAt(end - 1)) != INDEX_NOT_FOUND) { [EOL]             end--; [EOL]         } [EOL]     } [EOL]     return str.substring(0, end); [EOL] } 
 [LINE] if (cs1 == null || cs2 == null) { [LINE] public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] } 
 [LINE] return false; [LINE] public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] } 
 [LINE] return cs1.equals(cs2); [LINE] public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] } 
 [LINE] return CharSequenceUtils.regionMatches(str1, true, 0, str2, 0, str1.length()); [LINE] public static boolean equalsIgnoreCase(final CharSequence str1, final CharSequence str2) { [EOL]     if (str1 == null || str2 == null) { [EOL]         return str1 == str2; [EOL]     } else if (str1 == str2) { [EOL]         return true; [EOL]     } else if (str1.length() != str2.length()) { [EOL]         return false; [EOL]     } else { [EOL]         return CharSequenceUtils.regionMatches(str1, true, 0, str2, 0, str1.length()); [EOL]     } [EOL] } 
 [LINE] return INDEX_NOT_FOUND; [LINE] public static int indexOf(final CharSequence seq, final int searchChar) { [EOL]     if (isEmpty(seq)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     return CharSequenceUtils.indexOf(seq, searchChar, 0); [EOL] } 
 [LINE] return INDEX_NOT_FOUND; [LINE] public static int indexOf(final CharSequence seq, final int searchChar, final int startPos) { [EOL]     if (isEmpty(seq)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     return CharSequenceUtils.indexOf(seq, searchChar, startPos); [EOL] } 
 [LINE] return CharSequenceUtils.indexOf(seq, searchSeq, startPos); [LINE] public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) { [EOL]     if (seq == null || searchSeq == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     return CharSequenceUtils.indexOf(seq, searchSeq, startPos); [EOL] } 
 [LINE] if (searchStr.length() == 0) { [LINE] private static int ordinalIndexOf(final CharSequence str, final CharSequence searchStr, final int ordinal, final boolean lastIndex) { [EOL]     if (str == null || searchStr == null || ordinal <= 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (searchStr.length() == 0) { [EOL]         return lastIndex ? str.length() : 0; [EOL]     } [EOL]     int found = 0; [EOL]     int index = lastIndex ? str.length() : INDEX_NOT_FOUND; [EOL]     do { [EOL]         if (lastIndex) { [EOL]             index = CharSequenceUtils.lastIndexOf(str, searchStr, index - 1); [EOL]         } else { [EOL]             index = CharSequenceUtils.indexOf(str, searchStr, index + 1); [EOL]         } [EOL]         if (index < 0) { [EOL]             return index; [EOL]         } [EOL]         found++; [EOL]     } while (found < ordinal); [EOL]     return index; [EOL] } 
 [LINE] if (startPos > endLimit) { [LINE] public static int indexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int startPos) { [EOL]     if (str == null || searchStr == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startPos < 0) { [EOL]         startPos = 0; [EOL]     } [EOL]     final int endLimit = str.length() - searchStr.length() + 1; [EOL]     if (startPos > endLimit) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (searchStr.length() == 0) { [EOL]         return startPos; [EOL]     } [EOL]     for (int i = startPos; i < endLimit; i++) { [EOL]         if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStr.length())) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] } 
 [LINE] return INDEX_NOT_FOUND; [LINE] public static int lastIndexOf(final CharSequence seq, final int searchChar) { [EOL]     if (isEmpty(seq)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     return CharSequenceUtils.lastIndexOf(seq, searchChar, seq.length()); [EOL] } 
 [LINE] return CharSequenceUtils.lastIndexOf(seq, searchChar, seq.length()); [LINE] public static int lastIndexOf(final CharSequence seq, final int searchChar) { [EOL]     if (isEmpty(seq)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     return CharSequenceUtils.lastIndexOf(seq, searchChar, seq.length()); [EOL] } 
 [LINE] if (str == null || searchStr == null) { [LINE] public static int lastIndexOfIgnoreCase(final CharSequence str, final CharSequence searchStr) { [EOL]     if (str == null || searchStr == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     return lastIndexOfIgnoreCase(str, searchStr, str.length()); [EOL] } 
 [LINE] return INDEX_NOT_FOUND; [LINE] public static int lastIndexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int startPos) { [EOL]     if (str == null || searchStr == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startPos > str.length() - searchStr.length()) { [EOL]         startPos = str.length() - searchStr.length(); [EOL]     } [EOL]     if (startPos < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (searchStr.length() == 0) { [EOL]         return startPos; [EOL]     } [EOL]     for (int i = startPos; i >= 0; i--) { [EOL]         if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStr.length())) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] } 
 [LINE] startPos = str.length() - searchStr.length(); [LINE] public static int lastIndexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int startPos) { [EOL]     if (str == null || searchStr == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startPos > str.length() - searchStr.length()) { [EOL]         startPos = str.length() - searchStr.length(); [EOL]     } [EOL]     if (startPos < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (searchStr.length() == 0) { [EOL]         return startPos; [EOL]     } [EOL]     for (int i = startPos; i >= 0; i--) { [EOL]         if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStr.length())) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] } 
 [LINE] return INDEX_NOT_FOUND; [LINE] public static int lastIndexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int startPos) { [EOL]     if (str == null || searchStr == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startPos > str.length() - searchStr.length()) { [EOL]         startPos = str.length() - searchStr.length(); [EOL]     } [EOL]     if (startPos < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (searchStr.length() == 0) { [EOL]         return startPos; [EOL]     } [EOL]     for (int i = startPos; i >= 0; i--) { [EOL]         if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStr.length())) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] } 
 [LINE] return INDEX_NOT_FOUND; [LINE] public static int lastIndexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int startPos) { [EOL]     if (str == null || searchStr == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startPos > str.length() - searchStr.length()) { [EOL]         startPos = str.length() - searchStr.length(); [EOL]     } [EOL]     if (startPos < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (searchStr.length() == 0) { [EOL]         return startPos; [EOL]     } [EOL]     for (int i = startPos; i >= 0; i--) { [EOL]         if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStr.length())) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] } 
 [LINE] return false; [LINE] public static boolean contains(final CharSequence seq, final CharSequence searchSeq) { [EOL]     if (seq == null || searchSeq == null) { [EOL]         return false; [EOL]     } [EOL]     return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0; [EOL] } 
 [LINE] if (str == null || searchStr == null) { [LINE] public static boolean containsIgnoreCase(final CharSequence str, final CharSequence searchStr) { [EOL]     if (str == null || searchStr == null) { [EOL]         return false; [EOL]     } [EOL]     final int len = searchStr.length(); [EOL]     final int max = str.length() - len; [EOL]     for (int i = 0; i <= max; i++) { [EOL]         if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, len)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } 
 [LINE] final int max = str.length() - len; [LINE] public static boolean containsIgnoreCase(final CharSequence str, final CharSequence searchStr) { [EOL]     if (str == null || searchStr == null) { [EOL]         return false; [EOL]     } [EOL]     final int len = searchStr.length(); [EOL]     final int max = str.length() - len; [EOL]     for (int i = 0; i <= max; i++) { [EOL]         if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, len)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } 
 [LINE] final int searchLast = searchLen - 1; [LINE] public static int indexOfAny(final CharSequence cs, final char... searchChars) { [EOL]     if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     final int csLen = cs.length(); [EOL]     final int csLast = csLen - 1; [EOL]     final int searchLen = searchChars.length; [EOL]     final int searchLast = searchLen - 1; [EOL]     for (int i = 0; i < csLen; i++) { [EOL]         final char ch = cs.charAt(i); [EOL]         for (int j = 0; j < searchLen; j++) { [EOL]             if (searchChars[j] == ch) { [EOL]                 if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) { [EOL]                     if (searchChars[j + 1] == cs.charAt(i + 1)) { [EOL]                         return i; [EOL]                     } [EOL]                 } else { [EOL]                     return i; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] } 
 [LINE] if (searchChars[j + 1] == cs.charAt(i + 1)) { [LINE] public static int indexOfAny(final CharSequence cs, final char... searchChars) { [EOL]     if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     final int csLen = cs.length(); [EOL]     final int csLast = csLen - 1; [EOL]     final int searchLen = searchChars.length; [EOL]     final int searchLast = searchLen - 1; [EOL]     for (int i = 0; i < csLen; i++) { [EOL]         final char ch = cs.charAt(i); [EOL]         for (int j = 0; j < searchLen; j++) { [EOL]             if (searchChars[j] == ch) { [EOL]                 if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) { [EOL]                     if (searchChars[j + 1] == cs.charAt(i + 1)) { [EOL]                         return i; [EOL]                     } [EOL]                 } else { [EOL]                     return i; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] } 
 [LINE] return i; [LINE] public static int indexOfAny(final CharSequence cs, final char... searchChars) { [EOL]     if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     final int csLen = cs.length(); [EOL]     final int csLast = csLen - 1; [EOL]     final int searchLen = searchChars.length; [EOL]     final int searchLast = searchLen - 1; [EOL]     for (int i = 0; i < csLen; i++) { [EOL]         final char ch = cs.charAt(i); [EOL]         for (int j = 0; j < searchLen; j++) { [EOL]             if (searchChars[j] == ch) { [EOL]                 if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) { [EOL]                     if (searchChars[j + 1] == cs.charAt(i + 1)) { [EOL]                         return i; [EOL]                     } [EOL]                 } else { [EOL]                     return i; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] } 
 [LINE] if (isEmpty(cs) || isEmpty(searchChars)) { [LINE] public static int indexOfAny(final CharSequence cs, final String searchChars) { [EOL]     if (isEmpty(cs) || isEmpty(searchChars)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     return indexOfAny(cs, searchChars.toCharArray()); [EOL] } 
 [LINE] if (j == searchLast) { [LINE] public static boolean containsAny(final CharSequence cs, final char... searchChars) { [EOL]     if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { [EOL]         return false; [EOL]     } [EOL]     final int csLength = cs.length(); [EOL]     final int searchLength = searchChars.length; [EOL]     final int csLast = csLength - 1; [EOL]     final int searchLast = searchLength - 1; [EOL]     for (int i = 0; i < csLength; i++) { [EOL]         final char ch = cs.charAt(i); [EOL]         for (int j = 0; j < searchLength; j++) { [EOL]             if (searchChars[j] == ch) { [EOL]                 if (Character.isHighSurrogate(ch)) { [EOL]                     if (j == searchLast) { [EOL]                         return true; [EOL]                     } [EOL]                     if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) { [EOL]                         return true; [EOL]                     } [EOL]                 } else { [EOL]                     return true; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return false; [EOL] } 
 [LINE] if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) { [LINE] public static boolean containsAny(final CharSequence cs, final char... searchChars) { [EOL]     if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { [EOL]         return false; [EOL]     } [EOL]     final int csLength = cs.length(); [EOL]     final int searchLength = searchChars.length; [EOL]     final int csLast = csLength - 1; [EOL]     final int searchLast = searchLength - 1; [EOL]     for (int i = 0; i < csLength; i++) { [EOL]         final char ch = cs.charAt(i); [EOL]         for (int j = 0; j < searchLength; j++) { [EOL]             if (searchChars[j] == ch) { [EOL]                 if (Character.isHighSurrogate(ch)) { [EOL]                     if (j == searchLast) { [EOL]                         return true; [EOL]                     } [EOL]                     if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) { [EOL]                         return true; [EOL]                     } [EOL]                 } else { [EOL]                     return true; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return false; [EOL] } 
 [LINE] if (searchChars == null) { [LINE] public static boolean containsAny(final CharSequence cs, final CharSequence searchChars) { [EOL]     if (searchChars == null) { [EOL]         return false; [EOL]     } [EOL]     return containsAny(cs, CharSequenceUtils.toCharArray(searchChars)); [EOL] } 
 [LINE] if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { [LINE] public static int indexOfAnyBut(final CharSequence cs, final char... searchChars) { [EOL]     if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     final int csLen = cs.length(); [EOL]     final int csLast = csLen - 1; [EOL]     final int searchLen = searchChars.length; [EOL]     final int searchLast = searchLen - 1; [EOL]     outer: for (int i = 0; i < csLen; i++) { [EOL]         final char ch = cs.charAt(i); [EOL]         for (int j = 0; j < searchLen; j++) { [EOL]             if (searchChars[j] == ch) { [EOL]                 if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) { [EOL]                     if (searchChars[j + 1] == cs.charAt(i + 1)) { [EOL]                         continue outer; [EOL]                     } [EOL]                 } else { [EOL]                     continue outer; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return i; [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] } 
 [LINE] return INDEX_NOT_FOUND; [LINE] public static int indexOfAnyBut(final CharSequence cs, final char... searchChars) { [EOL]     if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     final int csLen = cs.length(); [EOL]     final int csLast = csLen - 1; [EOL]     final int searchLen = searchChars.length; [EOL]     final int searchLast = searchLen - 1; [EOL]     outer: for (int i = 0; i < csLen; i++) { [EOL]         final char ch = cs.charAt(i); [EOL]         for (int j = 0; j < searchLen; j++) { [EOL]             if (searchChars[j] == ch) { [EOL]                 if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) { [EOL]                     if (searchChars[j + 1] == cs.charAt(i + 1)) { [EOL]                         continue outer; [EOL]                     } [EOL]                 } else { [EOL]                     continue outer; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return i; [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] } 
 [LINE] final int searchLen = searchChars.length; [LINE] public static int indexOfAnyBut(final CharSequence cs, final char... searchChars) { [EOL]     if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     final int csLen = cs.length(); [EOL]     final int csLast = csLen - 1; [EOL]     final int searchLen = searchChars.length; [EOL]     final int searchLast = searchLen - 1; [EOL]     outer: for (int i = 0; i < csLen; i++) { [EOL]         final char ch = cs.charAt(i); [EOL]         for (int j = 0; j < searchLen; j++) { [EOL]             if (searchChars[j] == ch) { [EOL]                 if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) { [EOL]                     if (searchChars[j + 1] == cs.charAt(i + 1)) { [EOL]                         continue outer; [EOL]                     } [EOL]                 } else { [EOL]                     continue outer; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return i; [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] } 
 [LINE] outer: [LINE] public static int indexOfAnyBut(final CharSequence cs, final char... searchChars) { [EOL]     if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     final int csLen = cs.length(); [EOL]     final int csLast = csLen - 1; [EOL]     final int searchLen = searchChars.length; [EOL]     final int searchLast = searchLen - 1; [EOL]     outer: for (int i = 0; i < csLen; i++) { [EOL]         final char ch = cs.charAt(i); [EOL]         for (int j = 0; j < searchLen; j++) { [EOL]             if (searchChars[j] == ch) { [EOL]                 if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) { [EOL]                     if (searchChars[j + 1] == cs.charAt(i + 1)) { [EOL]                         continue outer; [EOL]                     } [EOL]                 } else { [EOL]                     continue outer; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return i; [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] } 
 [LINE] final int strLen = seq.length(); [LINE] public static int indexOfAnyBut(final CharSequence seq, final CharSequence searchChars) { [EOL]     if (isEmpty(seq) || isEmpty(searchChars)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     final int strLen = seq.length(); [EOL]     for (int i = 0; i < strLen; i++) { [EOL]         final char ch = seq.charAt(i); [EOL]         final boolean chFound = CharSequenceUtils.indexOf(searchChars, ch, 0) >= 0; [EOL]         if (i + 1 < strLen && Character.isHighSurrogate(ch)) { [EOL]             final char ch2 = seq.charAt(i + 1); [EOL]             if (chFound && CharSequenceUtils.indexOf(searchChars, ch2, 0) < 0) { [EOL]                 return i; [EOL]             } [EOL]         } else { [EOL]             if (!chFound) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] } 
 [LINE] final char ch = seq.charAt(i); [LINE] public static int indexOfAnyBut(final CharSequence seq, final CharSequence searchChars) { [EOL]     if (isEmpty(seq) || isEmpty(searchChars)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     final int strLen = seq.length(); [EOL]     for (int i = 0; i < strLen; i++) { [EOL]         final char ch = seq.charAt(i); [EOL]         final boolean chFound = CharSequenceUtils.indexOf(searchChars, ch, 0) >= 0; [EOL]         if (i + 1 < strLen && Character.isHighSurrogate(ch)) { [EOL]             final char ch2 = seq.charAt(i + 1); [EOL]             if (chFound && CharSequenceUtils.indexOf(searchChars, ch2, 0) < 0) { [EOL]                 return i; [EOL]             } [EOL]         } else { [EOL]             if (!chFound) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] } 
 [LINE] final char ch2 = seq.charAt(i + 1); [LINE] public static int indexOfAnyBut(final CharSequence seq, final CharSequence searchChars) { [EOL]     if (isEmpty(seq) || isEmpty(searchChars)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     final int strLen = seq.length(); [EOL]     for (int i = 0; i < strLen; i++) { [EOL]         final char ch = seq.charAt(i); [EOL]         final boolean chFound = CharSequenceUtils.indexOf(searchChars, ch, 0) >= 0; [EOL]         if (i + 1 < strLen && Character.isHighSurrogate(ch)) { [EOL]             final char ch2 = seq.charAt(i + 1); [EOL]             if (chFound && CharSequenceUtils.indexOf(searchChars, ch2, 0) < 0) { [EOL]                 return i; [EOL]             } [EOL]         } else { [EOL]             if (!chFound) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] } 
 [LINE] if (chFound && CharSequenceUtils.indexOf(searchChars, ch2, 0) < 0) { [LINE] public static int indexOfAnyBut(final CharSequence seq, final CharSequence searchChars) { [EOL]     if (isEmpty(seq) || isEmpty(searchChars)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     final int strLen = seq.length(); [EOL]     for (int i = 0; i < strLen; i++) { [EOL]         final char ch = seq.charAt(i); [EOL]         final boolean chFound = CharSequenceUtils.indexOf(searchChars, ch, 0) >= 0; [EOL]         if (i + 1 < strLen && Character.isHighSurrogate(ch)) { [EOL]             final char ch2 = seq.charAt(i + 1); [EOL]             if (chFound && CharSequenceUtils.indexOf(searchChars, ch2, 0) < 0) { [EOL]                 return i; [EOL]             } [EOL]         } else { [EOL]             if (!chFound) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] } 
 [LINE] if (valid == null || cs == null) { [LINE] public static boolean containsOnly(final CharSequence cs, final char... valid) { [EOL]     if (valid == null || cs == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs.length() == 0) { [EOL]         return true; [EOL]     } [EOL]     if (valid.length == 0) { [EOL]         return false; [EOL]     } [EOL]     return indexOfAnyBut(cs, valid) == INDEX_NOT_FOUND; [EOL] } 
 [LINE] if (cs.length() == 0) { [LINE] public static boolean containsOnly(final CharSequence cs, final char... valid) { [EOL]     if (valid == null || cs == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs.length() == 0) { [EOL]         return true; [EOL]     } [EOL]     if (valid.length == 0) { [EOL]         return false; [EOL]     } [EOL]     return indexOfAnyBut(cs, valid) == INDEX_NOT_FOUND; [EOL] } 
 [LINE] return indexOfAnyBut(cs, valid) == INDEX_NOT_FOUND; [LINE] public static boolean containsOnly(final CharSequence cs, final char... valid) { [EOL]     if (valid == null || cs == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs.length() == 0) { [EOL]         return true; [EOL]     } [EOL]     if (valid.length == 0) { [EOL]         return false; [EOL]     } [EOL]     return indexOfAnyBut(cs, valid) == INDEX_NOT_FOUND; [EOL] } 
 [LINE] if (cs == null || validChars == null) { [LINE] public static boolean containsOnly(final CharSequence cs, final String validChars) { [EOL]     if (cs == null || validChars == null) { [EOL]         return false; [EOL]     } [EOL]     return containsOnly(cs, validChars.toCharArray()); [EOL] } 
 [LINE] for (int j = 0; j < searchLen; j++) { [LINE] public static boolean containsNone(final CharSequence cs, final char... searchChars) { [EOL]     if (cs == null || searchChars == null) { [EOL]         return true; [EOL]     } [EOL]     final int csLen = cs.length(); [EOL]     final int csLast = csLen - 1; [EOL]     final int searchLen = searchChars.length; [EOL]     final int searchLast = searchLen - 1; [EOL]     for (int i = 0; i < csLen; i++) { [EOL]         final char ch = cs.charAt(i); [EOL]         for (int j = 0; j < searchLen; j++) { [EOL]             if (searchChars[j] == ch) { [EOL]                 if (Character.isHighSurrogate(ch)) { [EOL]                     if (j == searchLast) { [EOL]                         return false; [EOL]                     } [EOL]                     if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) { [EOL]                         return false; [EOL]                     } [EOL]                 } else { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] return false; [LINE] public static boolean containsNone(final CharSequence cs, final char... searchChars) { [EOL]     if (cs == null || searchChars == null) { [EOL]         return true; [EOL]     } [EOL]     final int csLen = cs.length(); [EOL]     final int csLast = csLen - 1; [EOL]     final int searchLen = searchChars.length; [EOL]     final int searchLast = searchLen - 1; [EOL]     for (int i = 0; i < csLen; i++) { [EOL]         final char ch = cs.charAt(i); [EOL]         for (int j = 0; j < searchLen; j++) { [EOL]             if (searchChars[j] == ch) { [EOL]                 if (Character.isHighSurrogate(ch)) { [EOL]                     if (j == searchLast) { [EOL]                         return false; [EOL]                     } [EOL]                     if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) { [EOL]                         return false; [EOL]                     } [EOL]                 } else { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] return containsNone(cs, invalidChars.toCharArray()); [LINE] public static boolean containsNone(final CharSequence cs, final String invalidChars) { [EOL]     if (cs == null || invalidChars == null) { [EOL]         return true; [EOL]     } [EOL]     return containsNone(cs, invalidChars.toCharArray()); [EOL] } 
 [LINE] return INDEX_NOT_FOUND; [LINE] public static int indexOfAny(final CharSequence str, final CharSequence... searchStrs) { [EOL]     if (str == null || searchStrs == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     final int sz = searchStrs.length; [EOL]     int ret = Integer.MAX_VALUE; [EOL]     int tmp = 0; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         final CharSequence search = searchStrs[i]; [EOL]         if (search == null) { [EOL]             continue; [EOL]         } [EOL]         tmp = CharSequenceUtils.indexOf(str, search, 0); [EOL]         if (tmp == INDEX_NOT_FOUND) { [EOL]             continue; [EOL]         } [EOL]         if (tmp < ret) { [EOL]             ret = tmp; [EOL]         } [EOL]     } [EOL]     return ret == Integer.MAX_VALUE ? INDEX_NOT_FOUND : ret; [EOL] } 
 [LINE] final int sz = searchStrs.length; [LINE] public static int lastIndexOfAny(final CharSequence str, final CharSequence... searchStrs) { [EOL]     if (str == null || searchStrs == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     final int sz = searchStrs.length; [EOL]     int ret = INDEX_NOT_FOUND; [EOL]     int tmp = 0; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         final CharSequence search = searchStrs[i]; [EOL]         if (search == null) { [EOL]             continue; [EOL]         } [EOL]         tmp = CharSequenceUtils.lastIndexOf(str, search, str.length()); [EOL]         if (tmp > ret) { [EOL]             ret = tmp; [EOL]         } [EOL]     } [EOL]     return ret; [EOL] } 
 [LINE] int tmp = 0; [LINE] public static int lastIndexOfAny(final CharSequence str, final CharSequence... searchStrs) { [EOL]     if (str == null || searchStrs == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     final int sz = searchStrs.length; [EOL]     int ret = INDEX_NOT_FOUND; [EOL]     int tmp = 0; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         final CharSequence search = searchStrs[i]; [EOL]         if (search == null) { [EOL]             continue; [EOL]         } [EOL]         tmp = CharSequenceUtils.lastIndexOf(str, search, str.length()); [EOL]         if (tmp > ret) { [EOL]             ret = tmp; [EOL]         } [EOL]     } [EOL]     return ret; [EOL] } 
 [LINE] if (search == null) { [LINE] public static int lastIndexOfAny(final CharSequence str, final CharSequence... searchStrs) { [EOL]     if (str == null || searchStrs == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     final int sz = searchStrs.length; [EOL]     int ret = INDEX_NOT_FOUND; [EOL]     int tmp = 0; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         final CharSequence search = searchStrs[i]; [EOL]         if (search == null) { [EOL]             continue; [EOL]         } [EOL]         tmp = CharSequenceUtils.lastIndexOf(str, search, str.length()); [EOL]         if (tmp > ret) { [EOL]             ret = tmp; [EOL]         } [EOL]     } [EOL]     return ret; [EOL] } 
 [LINE] return null; [LINE] public static String substring(final String str, int start) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (start < 0) { [EOL]         start = str.length() + start; [EOL]     } [EOL]     if (start < 0) { [EOL]         start = 0; [EOL]     } [EOL]     if (start > str.length()) { [EOL]         return EMPTY; [EOL]     } [EOL]     return str.substring(start); [EOL] } 
 [LINE] if (start < 0) { [LINE] public static String substring(final String str, int start) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (start < 0) { [EOL]         start = str.length() + start; [EOL]     } [EOL]     if (start < 0) { [EOL]         start = 0; [EOL]     } [EOL]     if (start > str.length()) { [EOL]         return EMPTY; [EOL]     } [EOL]     return str.substring(start); [EOL] } 
 [LINE] if (end > str.length()) { [LINE] public static String substring(final String str, int start, int end) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (end < 0) { [EOL]         end = str.length() + end; [EOL]     } [EOL]     if (start < 0) { [EOL]         start = str.length() + start; [EOL]     } [EOL]     if (end > str.length()) { [EOL]         end = str.length(); [EOL]     } [EOL]     if (start > end) { [EOL]         return EMPTY; [EOL]     } [EOL]     if (start < 0) { [EOL]         start = 0; [EOL]     } [EOL]     if (end < 0) { [EOL]         end = 0; [EOL]     } [EOL]     return str.substring(start, end); [EOL] } 
 [LINE] if (len < 0) { [LINE] public static String left(final String str, final int len) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (len < 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     if (str.length() <= len) { [EOL]         return str; [EOL]     } [EOL]     return str.substring(0, len); [EOL] } 
 [LINE] if (str == null) { [LINE] public static String right(final String str, final int len) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (len < 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     if (str.length() <= len) { [EOL]         return str; [EOL]     } [EOL]     return str.substring(str.length() - len); [EOL] } 
 [LINE] return null; [LINE] public static String right(final String str, final int len) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (len < 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     if (str.length() <= len) { [EOL]         return str; [EOL]     } [EOL]     return str.substring(str.length() - len); [EOL] } 
 [LINE] if (str == null) { [LINE] public static String mid(final String str, int pos, final int len) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (len < 0 || pos > str.length()) { [EOL]         return EMPTY; [EOL]     } [EOL]     if (pos < 0) { [EOL]         pos = 0; [EOL]     } [EOL]     if (str.length() <= pos + len) { [EOL]         return str.substring(pos); [EOL]     } [EOL]     return str.substring(pos, pos + len); [EOL] } 
 [LINE] return str; [LINE] public static String substringBefore(final String str, final String separator) { [EOL]     if (isEmpty(str) || separator == null) { [EOL]         return str; [EOL]     } [EOL]     if (separator.isEmpty()) { [EOL]         return EMPTY; [EOL]     } [EOL]     final int pos = str.indexOf(separator); [EOL]     if (pos == INDEX_NOT_FOUND) { [EOL]         return str; [EOL]     } [EOL]     return str.substring(0, pos); [EOL] } 
 [LINE] if (separator.isEmpty()) { [LINE] public static String substringBefore(final String str, final String separator) { [EOL]     if (isEmpty(str) || separator == null) { [EOL]         return str; [EOL]     } [EOL]     if (separator.isEmpty()) { [EOL]         return EMPTY; [EOL]     } [EOL]     final int pos = str.indexOf(separator); [EOL]     if (pos == INDEX_NOT_FOUND) { [EOL]         return str; [EOL]     } [EOL]     return str.substring(0, pos); [EOL] } 
 [LINE] final int pos = str.indexOf(separator); [LINE] public static String substringBefore(final String str, final String separator) { [EOL]     if (isEmpty(str) || separator == null) { [EOL]         return str; [EOL]     } [EOL]     if (separator.isEmpty()) { [EOL]         return EMPTY; [EOL]     } [EOL]     final int pos = str.indexOf(separator); [EOL]     if (pos == INDEX_NOT_FOUND) { [EOL]         return str; [EOL]     } [EOL]     return str.substring(0, pos); [EOL] } 
 [LINE] return EMPTY; [LINE] public static String substringAfter(final String str, final String separator) { [EOL]     if (isEmpty(str)) { [EOL]         return str; [EOL]     } [EOL]     if (separator == null) { [EOL]         return EMPTY; [EOL]     } [EOL]     final int pos = str.indexOf(separator); [EOL]     if (pos == INDEX_NOT_FOUND) { [EOL]         return EMPTY; [EOL]     } [EOL]     return str.substring(pos + separator.length()); [EOL] } 
 [LINE] final int pos = str.indexOf(separator); [LINE] public static String substringAfter(final String str, final String separator) { [EOL]     if (isEmpty(str)) { [EOL]         return str; [EOL]     } [EOL]     if (separator == null) { [EOL]         return EMPTY; [EOL]     } [EOL]     final int pos = str.indexOf(separator); [EOL]     if (pos == INDEX_NOT_FOUND) { [EOL]         return EMPTY; [EOL]     } [EOL]     return str.substring(pos + separator.length()); [EOL] } 
 [LINE] return null; [LINE] public static String substringBetween(final String str, final String open, final String close) { [EOL]     if (str == null || open == null || close == null) { [EOL]         return null; [EOL]     } [EOL]     final int start = str.indexOf(open); [EOL]     if (start != INDEX_NOT_FOUND) { [EOL]         final int end = str.indexOf(close, start + open.length()); [EOL]         if (end != INDEX_NOT_FOUND) { [EOL]             return str.substring(start + open.length(), end); [EOL]         } [EOL]     } [EOL]     return null; [EOL] } 
 [LINE] if (end != INDEX_NOT_FOUND) { [LINE] public static String substringBetween(final String str, final String open, final String close) { [EOL]     if (str == null || open == null || close == null) { [EOL]         return null; [EOL]     } [EOL]     final int start = str.indexOf(open); [EOL]     if (start != INDEX_NOT_FOUND) { [EOL]         final int end = str.indexOf(close, start + open.length()); [EOL]         if (end != INDEX_NOT_FOUND) { [EOL]             return str.substring(start + open.length(), end); [EOL]         } [EOL]     } [EOL]     return null; [EOL] } 
 [LINE] return null; [LINE] public static String[] substringsBetween(final String str, final String open, final String close) { [EOL]     if (str == null || isEmpty(open) || isEmpty(close)) { [EOL]         return null; [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     if (strLen == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final int closeLen = close.length(); [EOL]     final int openLen = open.length(); [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int pos = 0; [EOL]     while (pos < strLen - closeLen) { [EOL]         int start = str.indexOf(open, pos); [EOL]         if (start < 0) { [EOL]             break; [EOL]         } [EOL]         start += openLen; [EOL]         final int end = str.indexOf(close, start); [EOL]         if (end < 0) { [EOL]             break; [EOL]         } [EOL]         list.add(str.substring(start, end)); [EOL]         pos = end + closeLen; [EOL]     } [EOL]     if (list.isEmpty()) { [EOL]         return null; [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] } 
 [LINE] return ArrayUtils.EMPTY_STRING_ARRAY; [LINE] public static String[] substringsBetween(final String str, final String open, final String close) { [EOL]     if (str == null || isEmpty(open) || isEmpty(close)) { [EOL]         return null; [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     if (strLen == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final int closeLen = close.length(); [EOL]     final int openLen = open.length(); [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int pos = 0; [EOL]     while (pos < strLen - closeLen) { [EOL]         int start = str.indexOf(open, pos); [EOL]         if (start < 0) { [EOL]             break; [EOL]         } [EOL]         start += openLen; [EOL]         final int end = str.indexOf(close, start); [EOL]         if (end < 0) { [EOL]             break; [EOL]         } [EOL]         list.add(str.substring(start, end)); [EOL]         pos = end + closeLen; [EOL]     } [EOL]     if (list.isEmpty()) { [EOL]         return null; [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] } 
 [LINE] int pos = 0; [LINE] public static String[] substringsBetween(final String str, final String open, final String close) { [EOL]     if (str == null || isEmpty(open) || isEmpty(close)) { [EOL]         return null; [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     if (strLen == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final int closeLen = close.length(); [EOL]     final int openLen = open.length(); [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int pos = 0; [EOL]     while (pos < strLen - closeLen) { [EOL]         int start = str.indexOf(open, pos); [EOL]         if (start < 0) { [EOL]             break; [EOL]         } [EOL]         start += openLen; [EOL]         final int end = str.indexOf(close, start); [EOL]         if (end < 0) { [EOL]             break; [EOL]         } [EOL]         list.add(str.substring(start, end)); [EOL]         pos = end + closeLen; [EOL]     } [EOL]     if (list.isEmpty()) { [EOL]         return null; [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] } 
 [LINE] while (pos < strLen - closeLen) { [LINE] public static String[] substringsBetween(final String str, final String open, final String close) { [EOL]     if (str == null || isEmpty(open) || isEmpty(close)) { [EOL]         return null; [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     if (strLen == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final int closeLen = close.length(); [EOL]     final int openLen = open.length(); [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int pos = 0; [EOL]     while (pos < strLen - closeLen) { [EOL]         int start = str.indexOf(open, pos); [EOL]         if (start < 0) { [EOL]             break; [EOL]         } [EOL]         start += openLen; [EOL]         final int end = str.indexOf(close, start); [EOL]         if (end < 0) { [EOL]             break; [EOL]         } [EOL]         list.add(str.substring(start, end)); [EOL]         pos = end + closeLen; [EOL]     } [EOL]     if (list.isEmpty()) { [EOL]         return null; [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] } 
 [LINE] break; [LINE] public static String[] substringsBetween(final String str, final String open, final String close) { [EOL]     if (str == null || isEmpty(open) || isEmpty(close)) { [EOL]         return null; [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     if (strLen == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final int closeLen = close.length(); [EOL]     final int openLen = open.length(); [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int pos = 0; [EOL]     while (pos < strLen - closeLen) { [EOL]         int start = str.indexOf(open, pos); [EOL]         if (start < 0) { [EOL]             break; [EOL]         } [EOL]         start += openLen; [EOL]         final int end = str.indexOf(close, start); [EOL]         if (end < 0) { [EOL]             break; [EOL]         } [EOL]         list.add(str.substring(start, end)); [EOL]         pos = end + closeLen; [EOL]     } [EOL]     if (list.isEmpty()) { [EOL]         return null; [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] } 
 [LINE] list.add(str.substring(start, end)); [LINE] public static String[] substringsBetween(final String str, final String open, final String close) { [EOL]     if (str == null || isEmpty(open) || isEmpty(close)) { [EOL]         return null; [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     if (strLen == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final int closeLen = close.length(); [EOL]     final int openLen = open.length(); [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int pos = 0; [EOL]     while (pos < strLen - closeLen) { [EOL]         int start = str.indexOf(open, pos); [EOL]         if (start < 0) { [EOL]             break; [EOL]         } [EOL]         start += openLen; [EOL]         final int end = str.indexOf(close, start); [EOL]         if (end < 0) { [EOL]             break; [EOL]         } [EOL]         list.add(str.substring(start, end)); [EOL]         pos = end + closeLen; [EOL]     } [EOL]     if (list.isEmpty()) { [EOL]         return null; [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] } 
 [LINE] if (len == 0) { [LINE] private static String[] splitByWholeSeparatorWorker(final String str, final String separator, final int max, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     if (separator == null || EMPTY.equals(separator)) { [EOL]         return splitWorker(str, null, max, preserveAllTokens); [EOL]     } [EOL]     final int separatorLength = separator.length(); [EOL]     final ArrayList<String> substrings = new ArrayList<String>(); [EOL]     int numberOfSubstrings = 0; [EOL]     int beg = 0; [EOL]     int end = 0; [EOL]     while (end < len) { [EOL]         end = str.indexOf(separator, beg); [EOL]         if (end > -1) { [EOL]             if (end > beg) { [EOL]                 numberOfSubstrings += 1; [EOL]                 if (numberOfSubstrings == max) { [EOL]                     end = len; [EOL]                     substrings.add(str.substring(beg)); [EOL]                 } else { [EOL]                     substrings.add(str.substring(beg, end)); [EOL]                     beg = end + separatorLength; [EOL]                 } [EOL]             } else { [EOL]                 if (preserveAllTokens) { [EOL]                     numberOfSubstrings += 1; [EOL]                     if (numberOfSubstrings == max) { [EOL]                         end = len; [EOL]                         substrings.add(str.substring(beg)); [EOL]                     } else { [EOL]                         substrings.add(EMPTY); [EOL]                     } [EOL]                 } [EOL]                 beg = end + separatorLength; [EOL]             } [EOL]         } else { [EOL]             substrings.add(str.substring(beg)); [EOL]             end = len; [EOL]         } [EOL]     } [EOL]     return substrings.toArray(new String[substrings.size()]); [EOL] } 
 [LINE] int numberOfSubstrings = 0; [LINE] private static String[] splitByWholeSeparatorWorker(final String str, final String separator, final int max, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     if (separator == null || EMPTY.equals(separator)) { [EOL]         return splitWorker(str, null, max, preserveAllTokens); [EOL]     } [EOL]     final int separatorLength = separator.length(); [EOL]     final ArrayList<String> substrings = new ArrayList<String>(); [EOL]     int numberOfSubstrings = 0; [EOL]     int beg = 0; [EOL]     int end = 0; [EOL]     while (end < len) { [EOL]         end = str.indexOf(separator, beg); [EOL]         if (end > -1) { [EOL]             if (end > beg) { [EOL]                 numberOfSubstrings += 1; [EOL]                 if (numberOfSubstrings == max) { [EOL]                     end = len; [EOL]                     substrings.add(str.substring(beg)); [EOL]                 } else { [EOL]                     substrings.add(str.substring(beg, end)); [EOL]                     beg = end + separatorLength; [EOL]                 } [EOL]             } else { [EOL]                 if (preserveAllTokens) { [EOL]                     numberOfSubstrings += 1; [EOL]                     if (numberOfSubstrings == max) { [EOL]                         end = len; [EOL]                         substrings.add(str.substring(beg)); [EOL]                     } else { [EOL]                         substrings.add(EMPTY); [EOL]                     } [EOL]                 } [EOL]                 beg = end + separatorLength; [EOL]             } [EOL]         } else { [EOL]             substrings.add(str.substring(beg)); [EOL]             end = len; [EOL]         } [EOL]     } [EOL]     return substrings.toArray(new String[substrings.size()]); [EOL] } 
 [LINE] while (end < len) { [LINE] private static String[] splitByWholeSeparatorWorker(final String str, final String separator, final int max, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     if (separator == null || EMPTY.equals(separator)) { [EOL]         return splitWorker(str, null, max, preserveAllTokens); [EOL]     } [EOL]     final int separatorLength = separator.length(); [EOL]     final ArrayList<String> substrings = new ArrayList<String>(); [EOL]     int numberOfSubstrings = 0; [EOL]     int beg = 0; [EOL]     int end = 0; [EOL]     while (end < len) { [EOL]         end = str.indexOf(separator, beg); [EOL]         if (end > -1) { [EOL]             if (end > beg) { [EOL]                 numberOfSubstrings += 1; [EOL]                 if (numberOfSubstrings == max) { [EOL]                     end = len; [EOL]                     substrings.add(str.substring(beg)); [EOL]                 } else { [EOL]                     substrings.add(str.substring(beg, end)); [EOL]                     beg = end + separatorLength; [EOL]                 } [EOL]             } else { [EOL]                 if (preserveAllTokens) { [EOL]                     numberOfSubstrings += 1; [EOL]                     if (numberOfSubstrings == max) { [EOL]                         end = len; [EOL]                         substrings.add(str.substring(beg)); [EOL]                     } else { [EOL]                         substrings.add(EMPTY); [EOL]                     } [EOL]                 } [EOL]                 beg = end + separatorLength; [EOL]             } [EOL]         } else { [EOL]             substrings.add(str.substring(beg)); [EOL]             end = len; [EOL]         } [EOL]     } [EOL]     return substrings.toArray(new String[substrings.size()]); [EOL] } 
 [LINE] end = str.indexOf(separator, beg); [LINE] private static String[] splitByWholeSeparatorWorker(final String str, final String separator, final int max, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     if (separator == null || EMPTY.equals(separator)) { [EOL]         return splitWorker(str, null, max, preserveAllTokens); [EOL]     } [EOL]     final int separatorLength = separator.length(); [EOL]     final ArrayList<String> substrings = new ArrayList<String>(); [EOL]     int numberOfSubstrings = 0; [EOL]     int beg = 0; [EOL]     int end = 0; [EOL]     while (end < len) { [EOL]         end = str.indexOf(separator, beg); [EOL]         if (end > -1) { [EOL]             if (end > beg) { [EOL]                 numberOfSubstrings += 1; [EOL]                 if (numberOfSubstrings == max) { [EOL]                     end = len; [EOL]                     substrings.add(str.substring(beg)); [EOL]                 } else { [EOL]                     substrings.add(str.substring(beg, end)); [EOL]                     beg = end + separatorLength; [EOL]                 } [EOL]             } else { [EOL]                 if (preserveAllTokens) { [EOL]                     numberOfSubstrings += 1; [EOL]                     if (numberOfSubstrings == max) { [EOL]                         end = len; [EOL]                         substrings.add(str.substring(beg)); [EOL]                     } else { [EOL]                         substrings.add(EMPTY); [EOL]                     } [EOL]                 } [EOL]                 beg = end + separatorLength; [EOL]             } [EOL]         } else { [EOL]             substrings.add(str.substring(beg)); [EOL]             end = len; [EOL]         } [EOL]     } [EOL]     return substrings.toArray(new String[substrings.size()]); [EOL] } 
 [LINE] if (numberOfSubstrings == max) { [LINE] private static String[] splitByWholeSeparatorWorker(final String str, final String separator, final int max, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     if (separator == null || EMPTY.equals(separator)) { [EOL]         return splitWorker(str, null, max, preserveAllTokens); [EOL]     } [EOL]     final int separatorLength = separator.length(); [EOL]     final ArrayList<String> substrings = new ArrayList<String>(); [EOL]     int numberOfSubstrings = 0; [EOL]     int beg = 0; [EOL]     int end = 0; [EOL]     while (end < len) { [EOL]         end = str.indexOf(separator, beg); [EOL]         if (end > -1) { [EOL]             if (end > beg) { [EOL]                 numberOfSubstrings += 1; [EOL]                 if (numberOfSubstrings == max) { [EOL]                     end = len; [EOL]                     substrings.add(str.substring(beg)); [EOL]                 } else { [EOL]                     substrings.add(str.substring(beg, end)); [EOL]                     beg = end + separatorLength; [EOL]                 } [EOL]             } else { [EOL]                 if (preserveAllTokens) { [EOL]                     numberOfSubstrings += 1; [EOL]                     if (numberOfSubstrings == max) { [EOL]                         end = len; [EOL]                         substrings.add(str.substring(beg)); [EOL]                     } else { [EOL]                         substrings.add(EMPTY); [EOL]                     } [EOL]                 } [EOL]                 beg = end + separatorLength; [EOL]             } [EOL]         } else { [EOL]             substrings.add(str.substring(beg)); [EOL]             end = len; [EOL]         } [EOL]     } [EOL]     return substrings.toArray(new String[substrings.size()]); [EOL] } 
 [LINE] substrings.add(str.substring(beg)); [LINE] private static String[] splitByWholeSeparatorWorker(final String str, final String separator, final int max, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     if (separator == null || EMPTY.equals(separator)) { [EOL]         return splitWorker(str, null, max, preserveAllTokens); [EOL]     } [EOL]     final int separatorLength = separator.length(); [EOL]     final ArrayList<String> substrings = new ArrayList<String>(); [EOL]     int numberOfSubstrings = 0; [EOL]     int beg = 0; [EOL]     int end = 0; [EOL]     while (end < len) { [EOL]         end = str.indexOf(separator, beg); [EOL]         if (end > -1) { [EOL]             if (end > beg) { [EOL]                 numberOfSubstrings += 1; [EOL]                 if (numberOfSubstrings == max) { [EOL]                     end = len; [EOL]                     substrings.add(str.substring(beg)); [EOL]                 } else { [EOL]                     substrings.add(str.substring(beg, end)); [EOL]                     beg = end + separatorLength; [EOL]                 } [EOL]             } else { [EOL]                 if (preserveAllTokens) { [EOL]                     numberOfSubstrings += 1; [EOL]                     if (numberOfSubstrings == max) { [EOL]                         end = len; [EOL]                         substrings.add(str.substring(beg)); [EOL]                     } else { [EOL]                         substrings.add(EMPTY); [EOL]                     } [EOL]                 } [EOL]                 beg = end + separatorLength; [EOL]             } [EOL]         } else { [EOL]             substrings.add(str.substring(beg)); [EOL]             end = len; [EOL]         } [EOL]     } [EOL]     return substrings.toArray(new String[substrings.size()]); [EOL] } 
 [LINE] if (preserveAllTokens) { [LINE] private static String[] splitByWholeSeparatorWorker(final String str, final String separator, final int max, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     if (separator == null || EMPTY.equals(separator)) { [EOL]         return splitWorker(str, null, max, preserveAllTokens); [EOL]     } [EOL]     final int separatorLength = separator.length(); [EOL]     final ArrayList<String> substrings = new ArrayList<String>(); [EOL]     int numberOfSubstrings = 0; [EOL]     int beg = 0; [EOL]     int end = 0; [EOL]     while (end < len) { [EOL]         end = str.indexOf(separator, beg); [EOL]         if (end > -1) { [EOL]             if (end > beg) { [EOL]                 numberOfSubstrings += 1; [EOL]                 if (numberOfSubstrings == max) { [EOL]                     end = len; [EOL]                     substrings.add(str.substring(beg)); [EOL]                 } else { [EOL]                     substrings.add(str.substring(beg, end)); [EOL]                     beg = end + separatorLength; [EOL]                 } [EOL]             } else { [EOL]                 if (preserveAllTokens) { [EOL]                     numberOfSubstrings += 1; [EOL]                     if (numberOfSubstrings == max) { [EOL]                         end = len; [EOL]                         substrings.add(str.substring(beg)); [EOL]                     } else { [EOL]                         substrings.add(EMPTY); [EOL]                     } [EOL]                 } [EOL]                 beg = end + separatorLength; [EOL]             } [EOL]         } else { [EOL]             substrings.add(str.substring(beg)); [EOL]             end = len; [EOL]         } [EOL]     } [EOL]     return substrings.toArray(new String[substrings.size()]); [EOL] } 
 [LINE] substrings.add(str.substring(beg)); [LINE] private static String[] splitByWholeSeparatorWorker(final String str, final String separator, final int max, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     if (separator == null || EMPTY.equals(separator)) { [EOL]         return splitWorker(str, null, max, preserveAllTokens); [EOL]     } [EOL]     final int separatorLength = separator.length(); [EOL]     final ArrayList<String> substrings = new ArrayList<String>(); [EOL]     int numberOfSubstrings = 0; [EOL]     int beg = 0; [EOL]     int end = 0; [EOL]     while (end < len) { [EOL]         end = str.indexOf(separator, beg); [EOL]         if (end > -1) { [EOL]             if (end > beg) { [EOL]                 numberOfSubstrings += 1; [EOL]                 if (numberOfSubstrings == max) { [EOL]                     end = len; [EOL]                     substrings.add(str.substring(beg)); [EOL]                 } else { [EOL]                     substrings.add(str.substring(beg, end)); [EOL]                     beg = end + separatorLength; [EOL]                 } [EOL]             } else { [EOL]                 if (preserveAllTokens) { [EOL]                     numberOfSubstrings += 1; [EOL]                     if (numberOfSubstrings == max) { [EOL]                         end = len; [EOL]                         substrings.add(str.substring(beg)); [EOL]                     } else { [EOL]                         substrings.add(EMPTY); [EOL]                     } [EOL]                 } [EOL]                 beg = end + separatorLength; [EOL]             } [EOL]         } else { [EOL]             substrings.add(str.substring(beg)); [EOL]             end = len; [EOL]         } [EOL]     } [EOL]     return substrings.toArray(new String[substrings.size()]); [EOL] } 
 [LINE] final List<String> list = new ArrayList<String>(); [LINE] private static String[] splitWorker(final String str, final char separatorChar, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int i = 0, start = 0; [EOL]     boolean match = false; [EOL]     boolean lastMatch = false; [EOL]     while (i < len) { [EOL]         if (str.charAt(i) == separatorChar) { [EOL]             if (match || preserveAllTokens) { [EOL]                 list.add(str.substring(start, i)); [EOL]                 match = false; [EOL]                 lastMatch = true; [EOL]             } [EOL]             start = ++i; [EOL]             continue; [EOL]         } [EOL]         lastMatch = false; [EOL]         match = true; [EOL]         i++; [EOL]     } [EOL]     if (match || preserveAllTokens && lastMatch) { [EOL]         list.add(str.substring(start, i)); [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] } 
 [LINE] boolean match = false; [LINE] private static String[] splitWorker(final String str, final char separatorChar, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int i = 0, start = 0; [EOL]     boolean match = false; [EOL]     boolean lastMatch = false; [EOL]     while (i < len) { [EOL]         if (str.charAt(i) == separatorChar) { [EOL]             if (match || preserveAllTokens) { [EOL]                 list.add(str.substring(start, i)); [EOL]                 match = false; [EOL]                 lastMatch = true; [EOL]             } [EOL]             start = ++i; [EOL]             continue; [EOL]         } [EOL]         lastMatch = false; [EOL]         match = true; [EOL]         i++; [EOL]     } [EOL]     if (match || preserveAllTokens && lastMatch) { [EOL]         list.add(str.substring(start, i)); [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] } 
 [LINE] list.add(str.substring(start, i)); [LINE] private static String[] splitWorker(final String str, final char separatorChar, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int i = 0, start = 0; [EOL]     boolean match = false; [EOL]     boolean lastMatch = false; [EOL]     while (i < len) { [EOL]         if (str.charAt(i) == separatorChar) { [EOL]             if (match || preserveAllTokens) { [EOL]                 list.add(str.substring(start, i)); [EOL]                 match = false; [EOL]                 lastMatch = true; [EOL]             } [EOL]             start = ++i; [EOL]             continue; [EOL]         } [EOL]         lastMatch = false; [EOL]         match = true; [EOL]         i++; [EOL]     } [EOL]     if (match || preserveAllTokens && lastMatch) { [EOL]         list.add(str.substring(start, i)); [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] } 
 [LINE] match = false; [LINE] private static String[] splitWorker(final String str, final char separatorChar, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int i = 0, start = 0; [EOL]     boolean match = false; [EOL]     boolean lastMatch = false; [EOL]     while (i < len) { [EOL]         if (str.charAt(i) == separatorChar) { [EOL]             if (match || preserveAllTokens) { [EOL]                 list.add(str.substring(start, i)); [EOL]                 match = false; [EOL]                 lastMatch = true; [EOL]             } [EOL]             start = ++i; [EOL]             continue; [EOL]         } [EOL]         lastMatch = false; [EOL]         match = true; [EOL]         i++; [EOL]     } [EOL]     if (match || preserveAllTokens && lastMatch) { [EOL]         list.add(str.substring(start, i)); [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] } 
 [LINE] return null; [LINE] private static String[] splitWorker(final String str, final String separatorChars, final int max, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int sizePlus1 = 1; [EOL]     int i = 0, start = 0; [EOL]     boolean match = false; [EOL]     boolean lastMatch = false; [EOL]     if (separatorChars == null) { [EOL]         while (i < len) { [EOL]             if (Character.isWhitespace(str.charAt(i))) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else if (separatorChars.length() == 1) { [EOL]         final char sep = separatorChars.charAt(0); [EOL]         while (i < len) { [EOL]             if (str.charAt(i) == sep) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else { [EOL]         while (i < len) { [EOL]             if (separatorChars.indexOf(str.charAt(i)) >= 0) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } [EOL]     if (match || preserveAllTokens && lastMatch) { [EOL]         list.add(str.substring(start, i)); [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] } 
 [LINE] final List<String> list = new ArrayList<String>(); [LINE] private static String[] splitWorker(final String str, final String separatorChars, final int max, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int sizePlus1 = 1; [EOL]     int i = 0, start = 0; [EOL]     boolean match = false; [EOL]     boolean lastMatch = false; [EOL]     if (separatorChars == null) { [EOL]         while (i < len) { [EOL]             if (Character.isWhitespace(str.charAt(i))) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else if (separatorChars.length() == 1) { [EOL]         final char sep = separatorChars.charAt(0); [EOL]         while (i < len) { [EOL]             if (str.charAt(i) == sep) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else { [EOL]         while (i < len) { [EOL]             if (separatorChars.indexOf(str.charAt(i)) >= 0) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } [EOL]     if (match || preserveAllTokens && lastMatch) { [EOL]         list.add(str.substring(start, i)); [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] } 
 [LINE] i = len; [LINE] private static String[] splitWorker(final String str, final String separatorChars, final int max, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int sizePlus1 = 1; [EOL]     int i = 0, start = 0; [EOL]     boolean match = false; [EOL]     boolean lastMatch = false; [EOL]     if (separatorChars == null) { [EOL]         while (i < len) { [EOL]             if (Character.isWhitespace(str.charAt(i))) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else if (separatorChars.length() == 1) { [EOL]         final char sep = separatorChars.charAt(0); [EOL]         while (i < len) { [EOL]             if (str.charAt(i) == sep) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else { [EOL]         while (i < len) { [EOL]             if (separatorChars.indexOf(str.charAt(i)) >= 0) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } [EOL]     if (match || preserveAllTokens && lastMatch) { [EOL]         list.add(str.substring(start, i)); [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] } 
 [LINE] lastMatch = false; [LINE] private static String[] splitWorker(final String str, final String separatorChars, final int max, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int sizePlus1 = 1; [EOL]     int i = 0, start = 0; [EOL]     boolean match = false; [EOL]     boolean lastMatch = false; [EOL]     if (separatorChars == null) { [EOL]         while (i < len) { [EOL]             if (Character.isWhitespace(str.charAt(i))) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else if (separatorChars.length() == 1) { [EOL]         final char sep = separatorChars.charAt(0); [EOL]         while (i < len) { [EOL]             if (str.charAt(i) == sep) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else { [EOL]         while (i < len) { [EOL]             if (separatorChars.indexOf(str.charAt(i)) >= 0) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } [EOL]     if (match || preserveAllTokens && lastMatch) { [EOL]         list.add(str.substring(start, i)); [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] } 
 [LINE] list.add(str.substring(start, i)); [LINE] private static String[] splitWorker(final String str, final String separatorChars, final int max, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int sizePlus1 = 1; [EOL]     int i = 0, start = 0; [EOL]     boolean match = false; [EOL]     boolean lastMatch = false; [EOL]     if (separatorChars == null) { [EOL]         while (i < len) { [EOL]             if (Character.isWhitespace(str.charAt(i))) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else if (separatorChars.length() == 1) { [EOL]         final char sep = separatorChars.charAt(0); [EOL]         while (i < len) { [EOL]             if (str.charAt(i) == sep) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else { [EOL]         while (i < len) { [EOL]             if (separatorChars.indexOf(str.charAt(i)) >= 0) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } [EOL]     if (match || preserveAllTokens && lastMatch) { [EOL]         list.add(str.substring(start, i)); [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] } 
 [LINE] start = ++i; [LINE] private static String[] splitWorker(final String str, final String separatorChars, final int max, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int sizePlus1 = 1; [EOL]     int i = 0, start = 0; [EOL]     boolean match = false; [EOL]     boolean lastMatch = false; [EOL]     if (separatorChars == null) { [EOL]         while (i < len) { [EOL]             if (Character.isWhitespace(str.charAt(i))) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else if (separatorChars.length() == 1) { [EOL]         final char sep = separatorChars.charAt(0); [EOL]         while (i < len) { [EOL]             if (str.charAt(i) == sep) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else { [EOL]         while (i < len) { [EOL]             if (separatorChars.indexOf(str.charAt(i)) >= 0) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } [EOL]     if (match || preserveAllTokens && lastMatch) { [EOL]         list.add(str.substring(start, i)); [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] } 
 [LINE] continue; [LINE] private static String[] splitWorker(final String str, final String separatorChars, final int max, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int sizePlus1 = 1; [EOL]     int i = 0, start = 0; [EOL]     boolean match = false; [EOL]     boolean lastMatch = false; [EOL]     if (separatorChars == null) { [EOL]         while (i < len) { [EOL]             if (Character.isWhitespace(str.charAt(i))) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else if (separatorChars.length() == 1) { [EOL]         final char sep = separatorChars.charAt(0); [EOL]         while (i < len) { [EOL]             if (str.charAt(i) == sep) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else { [EOL]         while (i < len) { [EOL]             if (separatorChars.indexOf(str.charAt(i)) >= 0) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } [EOL]     if (match || preserveAllTokens && lastMatch) { [EOL]         list.add(str.substring(start, i)); [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] } 
 [LINE] lastMatch = false; [LINE] private static String[] splitWorker(final String str, final String separatorChars, final int max, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int sizePlus1 = 1; [EOL]     int i = 0, start = 0; [EOL]     boolean match = false; [EOL]     boolean lastMatch = false; [EOL]     if (separatorChars == null) { [EOL]         while (i < len) { [EOL]             if (Character.isWhitespace(str.charAt(i))) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else if (separatorChars.length() == 1) { [EOL]         final char sep = separatorChars.charAt(0); [EOL]         while (i < len) { [EOL]             if (str.charAt(i) == sep) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else { [EOL]         while (i < len) { [EOL]             if (separatorChars.indexOf(str.charAt(i)) >= 0) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } [EOL]     if (match || preserveAllTokens && lastMatch) { [EOL]         list.add(str.substring(start, i)); [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] } 
 [LINE] match = true; [LINE] private static String[] splitWorker(final String str, final String separatorChars, final int max, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int sizePlus1 = 1; [EOL]     int i = 0, start = 0; [EOL]     boolean match = false; [EOL]     boolean lastMatch = false; [EOL]     if (separatorChars == null) { [EOL]         while (i < len) { [EOL]             if (Character.isWhitespace(str.charAt(i))) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else if (separatorChars.length() == 1) { [EOL]         final char sep = separatorChars.charAt(0); [EOL]         while (i < len) { [EOL]             if (str.charAt(i) == sep) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else { [EOL]         while (i < len) { [EOL]             if (separatorChars.indexOf(str.charAt(i)) >= 0) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } [EOL]     if (match || preserveAllTokens && lastMatch) { [EOL]         list.add(str.substring(start, i)); [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] } 
 [LINE] } else if (separatorChars.length() == 1) { [LINE] private static String[] splitWorker(final String str, final String separatorChars, final int max, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int sizePlus1 = 1; [EOL]     int i = 0, start = 0; [EOL]     boolean match = false; [EOL]     boolean lastMatch = false; [EOL]     if (separatorChars == null) { [EOL]         while (i < len) { [EOL]             if (Character.isWhitespace(str.charAt(i))) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else if (separatorChars.length() == 1) { [EOL]         final char sep = separatorChars.charAt(0); [EOL]         while (i < len) { [EOL]             if (str.charAt(i) == sep) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else { [EOL]         while (i < len) { [EOL]             if (separatorChars.indexOf(str.charAt(i)) >= 0) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } [EOL]     if (match || preserveAllTokens && lastMatch) { [EOL]         list.add(str.substring(start, i)); [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] } 
 [LINE] i = len; [LINE] private static String[] splitWorker(final String str, final String separatorChars, final int max, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int sizePlus1 = 1; [EOL]     int i = 0, start = 0; [EOL]     boolean match = false; [EOL]     boolean lastMatch = false; [EOL]     if (separatorChars == null) { [EOL]         while (i < len) { [EOL]             if (Character.isWhitespace(str.charAt(i))) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else if (separatorChars.length() == 1) { [EOL]         final char sep = separatorChars.charAt(0); [EOL]         while (i < len) { [EOL]             if (str.charAt(i) == sep) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else { [EOL]         while (i < len) { [EOL]             if (separatorChars.indexOf(str.charAt(i)) >= 0) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } [EOL]     if (match || preserveAllTokens && lastMatch) { [EOL]         list.add(str.substring(start, i)); [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] } 
 [LINE] lastMatch = false; [LINE] private static String[] splitWorker(final String str, final String separatorChars, final int max, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int sizePlus1 = 1; [EOL]     int i = 0, start = 0; [EOL]     boolean match = false; [EOL]     boolean lastMatch = false; [EOL]     if (separatorChars == null) { [EOL]         while (i < len) { [EOL]             if (Character.isWhitespace(str.charAt(i))) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else if (separatorChars.length() == 1) { [EOL]         final char sep = separatorChars.charAt(0); [EOL]         while (i < len) { [EOL]             if (str.charAt(i) == sep) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else { [EOL]         while (i < len) { [EOL]             if (separatorChars.indexOf(str.charAt(i)) >= 0) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } [EOL]     if (match || preserveAllTokens && lastMatch) { [EOL]         list.add(str.substring(start, i)); [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] } 
 [LINE] start = ++i; [LINE] private static String[] splitWorker(final String str, final String separatorChars, final int max, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int sizePlus1 = 1; [EOL]     int i = 0, start = 0; [EOL]     boolean match = false; [EOL]     boolean lastMatch = false; [EOL]     if (separatorChars == null) { [EOL]         while (i < len) { [EOL]             if (Character.isWhitespace(str.charAt(i))) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else if (separatorChars.length() == 1) { [EOL]         final char sep = separatorChars.charAt(0); [EOL]         while (i < len) { [EOL]             if (str.charAt(i) == sep) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else { [EOL]         while (i < len) { [EOL]             if (separatorChars.indexOf(str.charAt(i)) >= 0) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } [EOL]     if (match || preserveAllTokens && lastMatch) { [EOL]         list.add(str.substring(start, i)); [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] } 
 [LINE] continue; [LINE] private static String[] splitWorker(final String str, final String separatorChars, final int max, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int sizePlus1 = 1; [EOL]     int i = 0, start = 0; [EOL]     boolean match = false; [EOL]     boolean lastMatch = false; [EOL]     if (separatorChars == null) { [EOL]         while (i < len) { [EOL]             if (Character.isWhitespace(str.charAt(i))) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else if (separatorChars.length() == 1) { [EOL]         final char sep = separatorChars.charAt(0); [EOL]         while (i < len) { [EOL]             if (str.charAt(i) == sep) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else { [EOL]         while (i < len) { [EOL]             if (separatorChars.indexOf(str.charAt(i)) >= 0) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } [EOL]     if (match || preserveAllTokens && lastMatch) { [EOL]         list.add(str.substring(start, i)); [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] } 
 [LINE] for (int pos = tokenStart + 1; pos < c.length; pos++) { [LINE] private static String[] splitByCharacterType(final String str, final boolean camelCase) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (str.isEmpty()) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final char[] c = str.toCharArray(); [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int tokenStart = 0; [EOL]     int currentType = Character.getType(c[tokenStart]); [EOL]     for (int pos = tokenStart + 1; pos < c.length; pos++) { [EOL]         final int type = Character.getType(c[pos]); [EOL]         if (type == currentType) { [EOL]             continue; [EOL]         } [EOL]         if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) { [EOL]             final int newTokenStart = pos - 1; [EOL]             if (newTokenStart != tokenStart) { [EOL]                 list.add(new String(c, tokenStart, newTokenStart - tokenStart)); [EOL]                 tokenStart = newTokenStart; [EOL]             } [EOL]         } else { [EOL]             list.add(new String(c, tokenStart, pos - tokenStart)); [EOL]             tokenStart = pos; [EOL]         } [EOL]         currentType = type; [EOL]     } [EOL]     list.add(new String(c, tokenStart, c.length - tokenStart)); [EOL]     return list.toArray(new String[list.size()]); [EOL] } 
 [LINE] if (type == currentType) { [LINE] private static String[] splitByCharacterType(final String str, final boolean camelCase) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (str.isEmpty()) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final char[] c = str.toCharArray(); [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int tokenStart = 0; [EOL]     int currentType = Character.getType(c[tokenStart]); [EOL]     for (int pos = tokenStart + 1; pos < c.length; pos++) { [EOL]         final int type = Character.getType(c[pos]); [EOL]         if (type == currentType) { [EOL]             continue; [EOL]         } [EOL]         if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) { [EOL]             final int newTokenStart = pos - 1; [EOL]             if (newTokenStart != tokenStart) { [EOL]                 list.add(new String(c, tokenStart, newTokenStart - tokenStart)); [EOL]                 tokenStart = newTokenStart; [EOL]             } [EOL]         } else { [EOL]             list.add(new String(c, tokenStart, pos - tokenStart)); [EOL]             tokenStart = pos; [EOL]         } [EOL]         currentType = type; [EOL]     } [EOL]     list.add(new String(c, tokenStart, c.length - tokenStart)); [EOL]     return list.toArray(new String[list.size()]); [EOL] } 
 [LINE] list.add(new String(c, tokenStart, pos - tokenStart)); [LINE] private static String[] splitByCharacterType(final String str, final boolean camelCase) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (str.isEmpty()) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final char[] c = str.toCharArray(); [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int tokenStart = 0; [EOL]     int currentType = Character.getType(c[tokenStart]); [EOL]     for (int pos = tokenStart + 1; pos < c.length; pos++) { [EOL]         final int type = Character.getType(c[pos]); [EOL]         if (type == currentType) { [EOL]             continue; [EOL]         } [EOL]         if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) { [EOL]             final int newTokenStart = pos - 1; [EOL]             if (newTokenStart != tokenStart) { [EOL]                 list.add(new String(c, tokenStart, newTokenStart - tokenStart)); [EOL]                 tokenStart = newTokenStart; [EOL]             } [EOL]         } else { [EOL]             list.add(new String(c, tokenStart, pos - tokenStart)); [EOL]             tokenStart = pos; [EOL]         } [EOL]         currentType = type; [EOL]     } [EOL]     list.add(new String(c, tokenStart, c.length - tokenStart)); [EOL]     return list.toArray(new String[list.size()]); [EOL] } 
 [LINE] currentType = type; [LINE] private static String[] splitByCharacterType(final String str, final boolean camelCase) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (str.isEmpty()) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final char[] c = str.toCharArray(); [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int tokenStart = 0; [EOL]     int currentType = Character.getType(c[tokenStart]); [EOL]     for (int pos = tokenStart + 1; pos < c.length; pos++) { [EOL]         final int type = Character.getType(c[pos]); [EOL]         if (type == currentType) { [EOL]             continue; [EOL]         } [EOL]         if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) { [EOL]             final int newTokenStart = pos - 1; [EOL]             if (newTokenStart != tokenStart) { [EOL]                 list.add(new String(c, tokenStart, newTokenStart - tokenStart)); [EOL]                 tokenStart = newTokenStart; [EOL]             } [EOL]         } else { [EOL]             list.add(new String(c, tokenStart, pos - tokenStart)); [EOL]             tokenStart = pos; [EOL]         } [EOL]         currentType = type; [EOL]     } [EOL]     list.add(new String(c, tokenStart, c.length - tokenStart)); [EOL]     return list.toArray(new String[list.size()]); [EOL] } 
 [LINE] return list.toArray(new String[list.size()]); [LINE] private static String[] splitByCharacterType(final String str, final boolean camelCase) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (str.isEmpty()) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final char[] c = str.toCharArray(); [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int tokenStart = 0; [EOL]     int currentType = Character.getType(c[tokenStart]); [EOL]     for (int pos = tokenStart + 1; pos < c.length; pos++) { [EOL]         final int type = Character.getType(c[pos]); [EOL]         if (type == currentType) { [EOL]             continue; [EOL]         } [EOL]         if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) { [EOL]             final int newTokenStart = pos - 1; [EOL]             if (newTokenStart != tokenStart) { [EOL]                 list.add(new String(c, tokenStart, newTokenStart - tokenStart)); [EOL]                 tokenStart = newTokenStart; [EOL]             } [EOL]         } else { [EOL]             list.add(new String(c, tokenStart, pos - tokenStart)); [EOL]             tokenStart = pos; [EOL]         } [EOL]         currentType = type; [EOL]     } [EOL]     list.add(new String(c, tokenStart, c.length - tokenStart)); [EOL]     return list.toArray(new String[list.size()]); [EOL] } 
 [LINE] return null; [LINE] public static String join(final Object[] array, final char separator) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     return join(array, separator, 0, array.length); [EOL] } 
 [LINE] if (array == null) { [LINE] public static String join(final byte[] array, final char separator) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     return join(array, separator, 0, array.length); [EOL] } 
 [LINE] return null; [LINE] public static String join(final byte[] array, final char separator) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     return join(array, separator, 0, array.length); [EOL] } 
 [LINE] return null; [LINE] public static String join(final float[] array, final char separator) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     return join(array, separator, 0, array.length); [EOL] } 
 [LINE] if (array == null) { [LINE] public static String join(final double[] array, final char separator) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     return join(array, separator, 0, array.length); [EOL] } 
 [LINE] return join(array, separator, 0, array.length); [LINE] public static String join(final double[] array, final char separator) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     return join(array, separator, 0, array.length); [EOL] } 
 [LINE] final int noOfItems = endIndex - startIndex; [LINE] public static String join(final Object[] array, final char separator, final int startIndex, final int endIndex) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     final int noOfItems = endIndex - startIndex; [EOL]     if (noOfItems <= 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final StringBuilder buf = new StringBuilder(noOfItems * 16); [EOL]     for (int i = startIndex; i < endIndex; i++) { [EOL]         if (i > startIndex) { [EOL]             buf.append(separator); [EOL]         } [EOL]         if (array[i] != null) { [EOL]             buf.append(array[i]); [EOL]         } [EOL]     } [EOL]     return buf.toString(); [EOL] } 
 [LINE] return EMPTY; [LINE] public static String join(final Object[] array, final char separator, final int startIndex, final int endIndex) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     final int noOfItems = endIndex - startIndex; [EOL]     if (noOfItems <= 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final StringBuilder buf = new StringBuilder(noOfItems * 16); [EOL]     for (int i = startIndex; i < endIndex; i++) { [EOL]         if (i > startIndex) { [EOL]             buf.append(separator); [EOL]         } [EOL]         if (array[i] != null) { [EOL]             buf.append(array[i]); [EOL]         } [EOL]     } [EOL]     return buf.toString(); [EOL] } 
 [LINE] for (int i = startIndex; i < endIndex; i++) { [LINE] public static String join(final Object[] array, final char separator, final int startIndex, final int endIndex) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     final int noOfItems = endIndex - startIndex; [EOL]     if (noOfItems <= 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final StringBuilder buf = new StringBuilder(noOfItems * 16); [EOL]     for (int i = startIndex; i < endIndex; i++) { [EOL]         if (i > startIndex) { [EOL]             buf.append(separator); [EOL]         } [EOL]         if (array[i] != null) { [EOL]             buf.append(array[i]); [EOL]         } [EOL]     } [EOL]     return buf.toString(); [EOL] } 
 [LINE] final int noOfItems = endIndex - startIndex; [LINE] public static String join(final long[] array, final char separator, final int startIndex, final int endIndex) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     final int noOfItems = endIndex - startIndex; [EOL]     if (noOfItems <= 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final StringBuilder buf = new StringBuilder(noOfItems * 16); [EOL]     for (int i = startIndex; i < endIndex; i++) { [EOL]         if (i > startIndex) { [EOL]             buf.append(separator); [EOL]         } [EOL]         buf.append(array[i]); [EOL]     } [EOL]     return buf.toString(); [EOL] } 
 [LINE] final int noOfItems = endIndex - startIndex; [LINE] public static String join(final byte[] array, final char separator, final int startIndex, final int endIndex) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     final int noOfItems = endIndex - startIndex; [EOL]     if (noOfItems <= 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final StringBuilder buf = new StringBuilder(noOfItems * 16); [EOL]     for (int i = startIndex; i < endIndex; i++) { [EOL]         if (i > startIndex) { [EOL]             buf.append(separator); [EOL]         } [EOL]         buf.append(array[i]); [EOL]     } [EOL]     return buf.toString(); [EOL] } 
 [LINE] for (int i = startIndex; i < endIndex; i++) { [LINE] public static String join(final byte[] array, final char separator, final int startIndex, final int endIndex) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     final int noOfItems = endIndex - startIndex; [EOL]     if (noOfItems <= 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final StringBuilder buf = new StringBuilder(noOfItems * 16); [EOL]     for (int i = startIndex; i < endIndex; i++) { [EOL]         if (i > startIndex) { [EOL]             buf.append(separator); [EOL]         } [EOL]         buf.append(array[i]); [EOL]     } [EOL]     return buf.toString(); [EOL] } 
 [LINE] return buf.toString(); [LINE] public static String join(final byte[] array, final char separator, final int startIndex, final int endIndex) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     final int noOfItems = endIndex - startIndex; [EOL]     if (noOfItems <= 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final StringBuilder buf = new StringBuilder(noOfItems * 16); [EOL]     for (int i = startIndex; i < endIndex; i++) { [EOL]         if (i > startIndex) { [EOL]             buf.append(separator); [EOL]         } [EOL]         buf.append(array[i]); [EOL]     } [EOL]     return buf.toString(); [EOL] } 
 [LINE] final int noOfItems = endIndex - startIndex; [LINE] public static String join(final short[] array, final char separator, final int startIndex, final int endIndex) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     final int noOfItems = endIndex - startIndex; [EOL]     if (noOfItems <= 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final StringBuilder buf = new StringBuilder(noOfItems * 16); [EOL]     for (int i = startIndex; i < endIndex; i++) { [EOL]         if (i > startIndex) { [EOL]             buf.append(separator); [EOL]         } [EOL]         buf.append(array[i]); [EOL]     } [EOL]     return buf.toString(); [EOL] } 
 [LINE] if (i > startIndex) { [LINE] public static String join(final short[] array, final char separator, final int startIndex, final int endIndex) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     final int noOfItems = endIndex - startIndex; [EOL]     if (noOfItems <= 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final StringBuilder buf = new StringBuilder(noOfItems * 16); [EOL]     for (int i = startIndex; i < endIndex; i++) { [EOL]         if (i > startIndex) { [EOL]             buf.append(separator); [EOL]         } [EOL]         buf.append(array[i]); [EOL]     } [EOL]     return buf.toString(); [EOL] } 
 [LINE] buf.append(array[i]); [LINE] public static String join(final short[] array, final char separator, final int startIndex, final int endIndex) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     final int noOfItems = endIndex - startIndex; [EOL]     if (noOfItems <= 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final StringBuilder buf = new StringBuilder(noOfItems * 16); [EOL]     for (int i = startIndex; i < endIndex; i++) { [EOL]         if (i > startIndex) { [EOL]             buf.append(separator); [EOL]         } [EOL]         buf.append(array[i]); [EOL]     } [EOL]     return buf.toString(); [EOL] } 
 [LINE] if (i > startIndex) { [LINE] public static String join(final char[] array, final char separator, final int startIndex, final int endIndex) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     final int noOfItems = endIndex - startIndex; [EOL]     if (noOfItems <= 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final StringBuilder buf = new StringBuilder(noOfItems * 16); [EOL]     for (int i = startIndex; i < endIndex; i++) { [EOL]         if (i > startIndex) { [EOL]             buf.append(separator); [EOL]         } [EOL]         buf.append(array[i]); [EOL]     } [EOL]     return buf.toString(); [EOL] } 
 [LINE] if (array == null) { [LINE] public static String join(final double[] array, final char separator, final int startIndex, final int endIndex) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     final int noOfItems = endIndex - startIndex; [EOL]     if (noOfItems <= 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final StringBuilder buf = new StringBuilder(noOfItems * 16); [EOL]     for (int i = startIndex; i < endIndex; i++) { [EOL]         if (i > startIndex) { [EOL]             buf.append(separator); [EOL]         } [EOL]         buf.append(array[i]); [EOL]     } [EOL]     return buf.toString(); [EOL] } 
 [LINE] final int noOfItems = endIndex - startIndex; [LINE] public static String join(final double[] array, final char separator, final int startIndex, final int endIndex) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     final int noOfItems = endIndex - startIndex; [EOL]     if (noOfItems <= 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final StringBuilder buf = new StringBuilder(noOfItems * 16); [EOL]     for (int i = startIndex; i < endIndex; i++) { [EOL]         if (i > startIndex) { [EOL]             buf.append(separator); [EOL]         } [EOL]         buf.append(array[i]); [EOL]     } [EOL]     return buf.toString(); [EOL] } 
 [LINE] final StringBuilder buf = new StringBuilder(noOfItems * 16); [LINE] public static String join(final double[] array, final char separator, final int startIndex, final int endIndex) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     final int noOfItems = endIndex - startIndex; [EOL]     if (noOfItems <= 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final StringBuilder buf = new StringBuilder(noOfItems * 16); [EOL]     for (int i = startIndex; i < endIndex; i++) { [EOL]         if (i > startIndex) { [EOL]             buf.append(separator); [EOL]         } [EOL]         buf.append(array[i]); [EOL]     } [EOL]     return buf.toString(); [EOL] } 
 [LINE] buf.append(separator); [LINE] public static String join(final double[] array, final char separator, final int startIndex, final int endIndex) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     final int noOfItems = endIndex - startIndex; [EOL]     if (noOfItems <= 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final StringBuilder buf = new StringBuilder(noOfItems * 16); [EOL]     for (int i = startIndex; i < endIndex; i++) { [EOL]         if (i > startIndex) { [EOL]             buf.append(separator); [EOL]         } [EOL]         buf.append(array[i]); [EOL]     } [EOL]     return buf.toString(); [EOL] } 
 [LINE] buf.append(array[i]); [LINE] public static String join(final double[] array, final char separator, final int startIndex, final int endIndex) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     final int noOfItems = endIndex - startIndex; [EOL]     if (noOfItems <= 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final StringBuilder buf = new StringBuilder(noOfItems * 16); [EOL]     for (int i = startIndex; i < endIndex; i++) { [EOL]         if (i > startIndex) { [EOL]             buf.append(separator); [EOL]         } [EOL]         buf.append(array[i]); [EOL]     } [EOL]     return buf.toString(); [EOL] } 
 [LINE] if (array == null) { [LINE] public static String join(final float[] array, final char separator, final int startIndex, final int endIndex) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     final int noOfItems = endIndex - startIndex; [EOL]     if (noOfItems <= 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final StringBuilder buf = new StringBuilder(noOfItems * 16); [EOL]     for (int i = startIndex; i < endIndex; i++) { [EOL]         if (i > startIndex) { [EOL]             buf.append(separator); [EOL]         } [EOL]         buf.append(array[i]); [EOL]     } [EOL]     return buf.toString(); [EOL] } 
 [LINE] final int noOfItems = endIndex - startIndex; [LINE] public static String join(final float[] array, final char separator, final int startIndex, final int endIndex) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     final int noOfItems = endIndex - startIndex; [EOL]     if (noOfItems <= 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final StringBuilder buf = new StringBuilder(noOfItems * 16); [EOL]     for (int i = startIndex; i < endIndex; i++) { [EOL]         if (i > startIndex) { [EOL]             buf.append(separator); [EOL]         } [EOL]         buf.append(array[i]); [EOL]     } [EOL]     return buf.toString(); [EOL] } 
 [LINE] for (int i = startIndex; i < endIndex; i++) { [LINE] public static String join(final float[] array, final char separator, final int startIndex, final int endIndex) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     final int noOfItems = endIndex - startIndex; [EOL]     if (noOfItems <= 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final StringBuilder buf = new StringBuilder(noOfItems * 16); [EOL]     for (int i = startIndex; i < endIndex; i++) { [EOL]         if (i > startIndex) { [EOL]             buf.append(separator); [EOL]         } [EOL]         buf.append(array[i]); [EOL]     } [EOL]     return buf.toString(); [EOL] } 
 [LINE] return join(array, separator, 0, array.length); [LINE] public static String join(final Object[] array, final String separator) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     return join(array, separator, 0, array.length); [EOL] } 
 [LINE] if (array == null) { [LINE] public static String join(final Object[] array, String separator, final int startIndex, final int endIndex) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (separator == null) { [EOL]         separator = EMPTY; [EOL]     } [EOL]     final int noOfItems = endIndex - startIndex; [EOL]     if (noOfItems <= 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final StringBuilder buf = new StringBuilder(noOfItems * 16); [EOL]     for (int i = startIndex; i < endIndex; i++) { [EOL]         if (i > startIndex) { [EOL]             buf.append(separator); [EOL]         } [EOL]         if (array[i] != null) { [EOL]             buf.append(array[i]); [EOL]         } [EOL]     } [EOL]     return buf.toString(); [EOL] } 
 [LINE] if (separator == null) { [LINE] public static String join(final Object[] array, String separator, final int startIndex, final int endIndex) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (separator == null) { [EOL]         separator = EMPTY; [EOL]     } [EOL]     final int noOfItems = endIndex - startIndex; [EOL]     if (noOfItems <= 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final StringBuilder buf = new StringBuilder(noOfItems * 16); [EOL]     for (int i = startIndex; i < endIndex; i++) { [EOL]         if (i > startIndex) { [EOL]             buf.append(separator); [EOL]         } [EOL]         if (array[i] != null) { [EOL]             buf.append(array[i]); [EOL]         } [EOL]     } [EOL]     return buf.toString(); [EOL] } 
 [LINE] if (iterator == null) { [LINE] public static String join(final Iterator<?> iterator, final char separator) { [EOL]     if (iterator == null) { [EOL]         return null; [EOL]     } [EOL]     if (!iterator.hasNext()) { [EOL]         return EMPTY; [EOL]     } [EOL]     final Object first = iterator.next(); [EOL]     if (!iterator.hasNext()) { [EOL]         return ObjectUtils.toString(first); [EOL]     } [EOL]     final StringBuilder buf = new StringBuilder(256); [EOL]     if (first != null) { [EOL]         buf.append(first); [EOL]     } [EOL]     while (iterator.hasNext()) { [EOL]         buf.append(separator); [EOL]         final Object obj = iterator.next(); [EOL]         if (obj != null) { [EOL]             buf.append(obj); [EOL]         } [EOL]     } [EOL]     return buf.toString(); [EOL] } 
 [LINE] return null; [LINE] public static String join(final Iterator<?> iterator, final char separator) { [EOL]     if (iterator == null) { [EOL]         return null; [EOL]     } [EOL]     if (!iterator.hasNext()) { [EOL]         return EMPTY; [EOL]     } [EOL]     final Object first = iterator.next(); [EOL]     if (!iterator.hasNext()) { [EOL]         return ObjectUtils.toString(first); [EOL]     } [EOL]     final StringBuilder buf = new StringBuilder(256); [EOL]     if (first != null) { [EOL]         buf.append(first); [EOL]     } [EOL]     while (iterator.hasNext()) { [EOL]         buf.append(separator); [EOL]         final Object obj = iterator.next(); [EOL]         if (obj != null) { [EOL]             buf.append(obj); [EOL]         } [EOL]     } [EOL]     return buf.toString(); [EOL] } 
 [LINE] if (!iterator.hasNext()) { [LINE] public static String join(final Iterator<?> iterator, final char separator) { [EOL]     if (iterator == null) { [EOL]         return null; [EOL]     } [EOL]     if (!iterator.hasNext()) { [EOL]         return EMPTY; [EOL]     } [EOL]     final Object first = iterator.next(); [EOL]     if (!iterator.hasNext()) { [EOL]         return ObjectUtils.toString(first); [EOL]     } [EOL]     final StringBuilder buf = new StringBuilder(256); [EOL]     if (first != null) { [EOL]         buf.append(first); [EOL]     } [EOL]     while (iterator.hasNext()) { [EOL]         buf.append(separator); [EOL]         final Object obj = iterator.next(); [EOL]         if (obj != null) { [EOL]             buf.append(obj); [EOL]         } [EOL]     } [EOL]     return buf.toString(); [EOL] } 
 [LINE] if (first != null) { [LINE] public static String join(final Iterator<?> iterator, final char separator) { [EOL]     if (iterator == null) { [EOL]         return null; [EOL]     } [EOL]     if (!iterator.hasNext()) { [EOL]         return EMPTY; [EOL]     } [EOL]     final Object first = iterator.next(); [EOL]     if (!iterator.hasNext()) { [EOL]         return ObjectUtils.toString(first); [EOL]     } [EOL]     final StringBuilder buf = new StringBuilder(256); [EOL]     if (first != null) { [EOL]         buf.append(first); [EOL]     } [EOL]     while (iterator.hasNext()) { [EOL]         buf.append(separator); [EOL]         final Object obj = iterator.next(); [EOL]         if (obj != null) { [EOL]             buf.append(obj); [EOL]         } [EOL]     } [EOL]     return buf.toString(); [EOL] } 
 [LINE] buf.append(first); [LINE] public static String join(final Iterator<?> iterator, final char separator) { [EOL]     if (iterator == null) { [EOL]         return null; [EOL]     } [EOL]     if (!iterator.hasNext()) { [EOL]         return EMPTY; [EOL]     } [EOL]     final Object first = iterator.next(); [EOL]     if (!iterator.hasNext()) { [EOL]         return ObjectUtils.toString(first); [EOL]     } [EOL]     final StringBuilder buf = new StringBuilder(256); [EOL]     if (first != null) { [EOL]         buf.append(first); [EOL]     } [EOL]     while (iterator.hasNext()) { [EOL]         buf.append(separator); [EOL]         final Object obj = iterator.next(); [EOL]         if (obj != null) { [EOL]             buf.append(obj); [EOL]         } [EOL]     } [EOL]     return buf.toString(); [EOL] } 
 [LINE] return null; [LINE] public static String join(final Iterator<?> iterator, final String separator) { [EOL]     if (iterator == null) { [EOL]         return null; [EOL]     } [EOL]     if (!iterator.hasNext()) { [EOL]         return EMPTY; [EOL]     } [EOL]     final Object first = iterator.next(); [EOL]     if (!iterator.hasNext()) { [EOL]         return ObjectUtils.toString(first); [EOL]     } [EOL]     final StringBuilder buf = new StringBuilder(256); [EOL]     if (first != null) { [EOL]         buf.append(first); [EOL]     } [EOL]     while (iterator.hasNext()) { [EOL]         if (separator != null) { [EOL]             buf.append(separator); [EOL]         } [EOL]         final Object obj = iterator.next(); [EOL]         if (obj != null) { [EOL]             buf.append(obj); [EOL]         } [EOL]     } [EOL]     return buf.toString(); [EOL] } 
 [LINE] final Object first = iterator.next(); [LINE] public static String join(final Iterator<?> iterator, final String separator) { [EOL]     if (iterator == null) { [EOL]         return null; [EOL]     } [EOL]     if (!iterator.hasNext()) { [EOL]         return EMPTY; [EOL]     } [EOL]     final Object first = iterator.next(); [EOL]     if (!iterator.hasNext()) { [EOL]         return ObjectUtils.toString(first); [EOL]     } [EOL]     final StringBuilder buf = new StringBuilder(256); [EOL]     if (first != null) { [EOL]         buf.append(first); [EOL]     } [EOL]     while (iterator.hasNext()) { [EOL]         if (separator != null) { [EOL]             buf.append(separator); [EOL]         } [EOL]         final Object obj = iterator.next(); [EOL]         if (obj != null) { [EOL]             buf.append(obj); [EOL]         } [EOL]     } [EOL]     return buf.toString(); [EOL] } 
 [LINE] buf.append(obj); [LINE] public static String join(final Iterator<?> iterator, final String separator) { [EOL]     if (iterator == null) { [EOL]         return null; [EOL]     } [EOL]     if (!iterator.hasNext()) { [EOL]         return EMPTY; [EOL]     } [EOL]     final Object first = iterator.next(); [EOL]     if (!iterator.hasNext()) { [EOL]         return ObjectUtils.toString(first); [EOL]     } [EOL]     final StringBuilder buf = new StringBuilder(256); [EOL]     if (first != null) { [EOL]         buf.append(first); [EOL]     } [EOL]     while (iterator.hasNext()) { [EOL]         if (separator != null) { [EOL]             buf.append(separator); [EOL]         } [EOL]         final Object obj = iterator.next(); [EOL]         if (obj != null) { [EOL]             buf.append(obj); [EOL]         } [EOL]     } [EOL]     return buf.toString(); [EOL] } 
 [LINE] if (iterable == null) { [LINE] public static String join(final Iterable<?> iterable, final char separator) { [EOL]     if (iterable == null) { [EOL]         return null; [EOL]     } [EOL]     return join(iterable.iterator(), separator); [EOL] } 
 [LINE] return null; [LINE] public static String join(final Iterable<?> iterable, final char separator) { [EOL]     if (iterable == null) { [EOL]         return null; [EOL]     } [EOL]     return join(iterable.iterator(), separator); [EOL] } 
 [LINE] return str; [LINE] public static String deleteWhitespace(final String str) { [EOL]     if (isEmpty(str)) { [EOL]         return str; [EOL]     } [EOL]     final int sz = str.length(); [EOL]     final char[] chs = new char[sz]; [EOL]     int count = 0; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (!Character.isWhitespace(str.charAt(i))) { [EOL]             chs[count++] = str.charAt(i); [EOL]         } [EOL]     } [EOL]     if (count == sz) { [EOL]         return str; [EOL]     } [EOL]     return new String(chs, 0, count); [EOL] } 
 [LINE] int count = 0; [LINE] public static String deleteWhitespace(final String str) { [EOL]     if (isEmpty(str)) { [EOL]         return str; [EOL]     } [EOL]     final int sz = str.length(); [EOL]     final char[] chs = new char[sz]; [EOL]     int count = 0; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (!Character.isWhitespace(str.charAt(i))) { [EOL]             chs[count++] = str.charAt(i); [EOL]         } [EOL]     } [EOL]     if (count == sz) { [EOL]         return str; [EOL]     } [EOL]     return new String(chs, 0, count); [EOL] } 
 [LINE] if (count == sz) { [LINE] public static String deleteWhitespace(final String str) { [EOL]     if (isEmpty(str)) { [EOL]         return str; [EOL]     } [EOL]     final int sz = str.length(); [EOL]     final char[] chs = new char[sz]; [EOL]     int count = 0; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (!Character.isWhitespace(str.charAt(i))) { [EOL]             chs[count++] = str.charAt(i); [EOL]         } [EOL]     } [EOL]     if (count == sz) { [EOL]         return str; [EOL]     } [EOL]     return new String(chs, 0, count); [EOL] } 
 [LINE] if (isEmpty(str) || isEmpty(remove)) { [LINE] public static String removeStart(final String str, final String remove) { [EOL]     if (isEmpty(str) || isEmpty(remove)) { [EOL]         return str; [EOL]     } [EOL]     if (str.startsWith(remove)) { [EOL]         return str.substring(remove.length()); [EOL]     } [EOL]     return str; [EOL] } 
 [LINE] return str; [LINE] public static String removeStart(final String str, final String remove) { [EOL]     if (isEmpty(str) || isEmpty(remove)) { [EOL]         return str; [EOL]     } [EOL]     if (str.startsWith(remove)) { [EOL]         return str.substring(remove.length()); [EOL]     } [EOL]     return str; [EOL] } 
 [LINE] return str.substring(remove.length()); [LINE] public static String removeStart(final String str, final String remove) { [EOL]     if (isEmpty(str) || isEmpty(remove)) { [EOL]         return str; [EOL]     } [EOL]     if (str.startsWith(remove)) { [EOL]         return str.substring(remove.length()); [EOL]     } [EOL]     return str; [EOL] } 
 [LINE] return str.substring(remove.length()); [LINE] public static String removeStartIgnoreCase(final String str, final String remove) { [EOL]     if (isEmpty(str) || isEmpty(remove)) { [EOL]         return str; [EOL]     } [EOL]     if (startsWithIgnoreCase(str, remove)) { [EOL]         return str.substring(remove.length()); [EOL]     } [EOL]     return str; [EOL] } 
 [LINE] return str; [LINE] public static String removeEndIgnoreCase(final String str, final String remove) { [EOL]     if (isEmpty(str) || isEmpty(remove)) { [EOL]         return str; [EOL]     } [EOL]     if (endsWithIgnoreCase(str, remove)) { [EOL]         return str.substring(0, str.length() - remove.length()); [EOL]     } [EOL]     return str; [EOL] } 
 [LINE] if (chars[i] != remove) { [LINE] public static String remove(final String str, final char remove) { [EOL]     if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) { [EOL]         return str; [EOL]     } [EOL]     final char[] chars = str.toCharArray(); [EOL]     int pos = 0; [EOL]     for (int i = 0; i < chars.length; i++) { [EOL]         if (chars[i] != remove) { [EOL]             chars[pos++] = chars[i]; [EOL]         } [EOL]     } [EOL]     return new String(chars, 0, pos); [EOL] } 
 [LINE] return replace(text, searchString, replacement, -1); [LINE] public static String replace(final String text, final String searchString, final String replacement) { [EOL]     return replace(text, searchString, replacement, -1); [EOL] } 
 [LINE] break; [LINE] public static String replace(final String text, final String searchString, final String replacement, int max) { [EOL]     if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) { [EOL]         return text; [EOL]     } [EOL]     int start = 0; [EOL]     int end = text.indexOf(searchString, start); [EOL]     if (end == INDEX_NOT_FOUND) { [EOL]         return text; [EOL]     } [EOL]     final int replLength = searchString.length(); [EOL]     int increase = replacement.length() - replLength; [EOL]     increase = increase < 0 ? 0 : increase; [EOL]     increase *= max < 0 ? 16 : max > 64 ? 64 : max; [EOL]     final StringBuilder buf = new StringBuilder(text.length() + increase); [EOL]     while (end != INDEX_NOT_FOUND) { [EOL]         buf.append(text.substring(start, end)).append(replacement); [EOL]         start = end + replLength; [EOL]         if (--max == 0) { [EOL]             break; [EOL]         } [EOL]         end = text.indexOf(searchString, start); [EOL]     } [EOL]     buf.append(text.substring(start)); [EOL]     return buf.toString(); [EOL] } 
 [LINE] return replaceEach(text, searchList, replacementList, false, 0); [LINE] public static String replaceEach(final String text, final String[] searchList, final String[] replacementList) { [EOL]     return replaceEach(text, searchList, replacementList, false, 0); [EOL] } 
 [LINE] return text; [LINE] private static String replaceEach(final String text, final String[] searchList, final String[] replacementList, final boolean repeat, final int timeToLive) { [EOL]     if (text == null || text.isEmpty() || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) { [EOL]         return text; [EOL]     } [EOL]     if (timeToLive < 0) { [EOL]         throw new IllegalStateException("Aborting to protect against StackOverflowError - " + "output of one loop is the input of another"); [EOL]     } [EOL]     final int searchLength = searchList.length; [EOL]     final int replacementLength = replacementList.length; [EOL]     if (searchLength != replacementLength) { [EOL]         throw new IllegalArgumentException("Search and Replace array lengths don't match: " + searchLength + " vs " + replacementLength); [EOL]     } [EOL]     final boolean[] noMoreMatchesForReplIndex = new boolean[searchLength]; [EOL]     int textIndex = -1; [EOL]     int replaceIndex = -1; [EOL]     int tempIndex = -1; [EOL]     for (int i = 0; i < searchLength; i++) { [EOL]         if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) { [EOL]             continue; [EOL]         } [EOL]         tempIndex = text.indexOf(searchList[i]); [EOL]         if (tempIndex == -1) { [EOL]             noMoreMatchesForReplIndex[i] = true; [EOL]         } else { [EOL]             if (textIndex == -1 || tempIndex < textIndex) { [EOL]                 textIndex = tempIndex; [EOL]                 replaceIndex = i; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (textIndex == -1) { [EOL]         return text; [EOL]     } [EOL]     int start = 0; [EOL]     int increase = 0; [EOL]     for (int i = 0; i < searchList.length; i++) { [EOL]         if (searchList[i] == null || replacementList[i] == null) { [EOL]             continue; [EOL]         } [EOL]         final int greater = replacementList[i].length() - searchList[i].length(); [EOL]         if (greater > 0) { [EOL]             increase += 3 * greater; [EOL]         } [EOL]     } [EOL]     increase = Math.min(increase, text.length() / 5); [EOL]     final StringBuilder buf = new StringBuilder(text.length() + increase); [EOL]     while (textIndex != -1) { [EOL]         for (int i = start; i < textIndex; i++) { [EOL]             buf.append(text.charAt(i)); [EOL]         } [EOL]         buf.append(replacementList[replaceIndex]); [EOL]         start = textIndex + searchList[replaceIndex].length(); [EOL]         textIndex = -1; [EOL]         replaceIndex = -1; [EOL]         tempIndex = -1; [EOL]         for (int i = 0; i < searchLength; i++) { [EOL]             if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) { [EOL]                 continue; [EOL]             } [EOL]             tempIndex = text.indexOf(searchList[i], start); [EOL]             if (tempIndex == -1) { [EOL]                 noMoreMatchesForReplIndex[i] = true; [EOL]             } else { [EOL]                 if (textIndex == -1 || tempIndex < textIndex) { [EOL]                     textIndex = tempIndex; [EOL]                     replaceIndex = i; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     final int textLength = text.length(); [EOL]     for (int i = start; i < textLength; i++) { [EOL]         buf.append(text.charAt(i)); [EOL]     } [EOL]     final String result = buf.toString(); [EOL]     if (!repeat) { [EOL]         return result; [EOL]     } [EOL]     return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1); [EOL] } 
 [LINE] if (timeToLive < 0) { [LINE] private static String replaceEach(final String text, final String[] searchList, final String[] replacementList, final boolean repeat, final int timeToLive) { [EOL]     if (text == null || text.isEmpty() || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) { [EOL]         return text; [EOL]     } [EOL]     if (timeToLive < 0) { [EOL]         throw new IllegalStateException("Aborting to protect against StackOverflowError - " + "output of one loop is the input of another"); [EOL]     } [EOL]     final int searchLength = searchList.length; [EOL]     final int replacementLength = replacementList.length; [EOL]     if (searchLength != replacementLength) { [EOL]         throw new IllegalArgumentException("Search and Replace array lengths don't match: " + searchLength + " vs " + replacementLength); [EOL]     } [EOL]     final boolean[] noMoreMatchesForReplIndex = new boolean[searchLength]; [EOL]     int textIndex = -1; [EOL]     int replaceIndex = -1; [EOL]     int tempIndex = -1; [EOL]     for (int i = 0; i < searchLength; i++) { [EOL]         if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) { [EOL]             continue; [EOL]         } [EOL]         tempIndex = text.indexOf(searchList[i]); [EOL]         if (tempIndex == -1) { [EOL]             noMoreMatchesForReplIndex[i] = true; [EOL]         } else { [EOL]             if (textIndex == -1 || tempIndex < textIndex) { [EOL]                 textIndex = tempIndex; [EOL]                 replaceIndex = i; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (textIndex == -1) { [EOL]         return text; [EOL]     } [EOL]     int start = 0; [EOL]     int increase = 0; [EOL]     for (int i = 0; i < searchList.length; i++) { [EOL]         if (searchList[i] == null || replacementList[i] == null) { [EOL]             continue; [EOL]         } [EOL]         final int greater = replacementList[i].length() - searchList[i].length(); [EOL]         if (greater > 0) { [EOL]             increase += 3 * greater; [EOL]         } [EOL]     } [EOL]     increase = Math.min(increase, text.length() / 5); [EOL]     final StringBuilder buf = new StringBuilder(text.length() + increase); [EOL]     while (textIndex != -1) { [EOL]         for (int i = start; i < textIndex; i++) { [EOL]             buf.append(text.charAt(i)); [EOL]         } [EOL]         buf.append(replacementList[replaceIndex]); [EOL]         start = textIndex + searchList[replaceIndex].length(); [EOL]         textIndex = -1; [EOL]         replaceIndex = -1; [EOL]         tempIndex = -1; [EOL]         for (int i = 0; i < searchLength; i++) { [EOL]             if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) { [EOL]                 continue; [EOL]             } [EOL]             tempIndex = text.indexOf(searchList[i], start); [EOL]             if (tempIndex == -1) { [EOL]                 noMoreMatchesForReplIndex[i] = true; [EOL]             } else { [EOL]                 if (textIndex == -1 || tempIndex < textIndex) { [EOL]                     textIndex = tempIndex; [EOL]                     replaceIndex = i; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     final int textLength = text.length(); [EOL]     for (int i = start; i < textLength; i++) { [EOL]         buf.append(text.charAt(i)); [EOL]     } [EOL]     final String result = buf.toString(); [EOL]     if (!repeat) { [EOL]         return result; [EOL]     } [EOL]     return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1); [EOL] } 
 [LINE] final int replacementLength = replacementList.length; [LINE] private static String replaceEach(final String text, final String[] searchList, final String[] replacementList, final boolean repeat, final int timeToLive) { [EOL]     if (text == null || text.isEmpty() || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) { [EOL]         return text; [EOL]     } [EOL]     if (timeToLive < 0) { [EOL]         throw new IllegalStateException("Aborting to protect against StackOverflowError - " + "output of one loop is the input of another"); [EOL]     } [EOL]     final int searchLength = searchList.length; [EOL]     final int replacementLength = replacementList.length; [EOL]     if (searchLength != replacementLength) { [EOL]         throw new IllegalArgumentException("Search and Replace array lengths don't match: " + searchLength + " vs " + replacementLength); [EOL]     } [EOL]     final boolean[] noMoreMatchesForReplIndex = new boolean[searchLength]; [EOL]     int textIndex = -1; [EOL]     int replaceIndex = -1; [EOL]     int tempIndex = -1; [EOL]     for (int i = 0; i < searchLength; i++) { [EOL]         if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) { [EOL]             continue; [EOL]         } [EOL]         tempIndex = text.indexOf(searchList[i]); [EOL]         if (tempIndex == -1) { [EOL]             noMoreMatchesForReplIndex[i] = true; [EOL]         } else { [EOL]             if (textIndex == -1 || tempIndex < textIndex) { [EOL]                 textIndex = tempIndex; [EOL]                 replaceIndex = i; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (textIndex == -1) { [EOL]         return text; [EOL]     } [EOL]     int start = 0; [EOL]     int increase = 0; [EOL]     for (int i = 0; i < searchList.length; i++) { [EOL]         if (searchList[i] == null || replacementList[i] == null) { [EOL]             continue; [EOL]         } [EOL]         final int greater = replacementList[i].length() - searchList[i].length(); [EOL]         if (greater > 0) { [EOL]             increase += 3 * greater; [EOL]         } [EOL]     } [EOL]     increase = Math.min(increase, text.length() / 5); [EOL]     final StringBuilder buf = new StringBuilder(text.length() + increase); [EOL]     while (textIndex != -1) { [EOL]         for (int i = start; i < textIndex; i++) { [EOL]             buf.append(text.charAt(i)); [EOL]         } [EOL]         buf.append(replacementList[replaceIndex]); [EOL]         start = textIndex + searchList[replaceIndex].length(); [EOL]         textIndex = -1; [EOL]         replaceIndex = -1; [EOL]         tempIndex = -1; [EOL]         for (int i = 0; i < searchLength; i++) { [EOL]             if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) { [EOL]                 continue; [EOL]             } [EOL]             tempIndex = text.indexOf(searchList[i], start); [EOL]             if (tempIndex == -1) { [EOL]                 noMoreMatchesForReplIndex[i] = true; [EOL]             } else { [EOL]                 if (textIndex == -1 || tempIndex < textIndex) { [EOL]                     textIndex = tempIndex; [EOL]                     replaceIndex = i; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     final int textLength = text.length(); [EOL]     for (int i = start; i < textLength; i++) { [EOL]         buf.append(text.charAt(i)); [EOL]     } [EOL]     final String result = buf.toString(); [EOL]     if (!repeat) { [EOL]         return result; [EOL]     } [EOL]     return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1); [EOL] } 
 [LINE] final boolean[] noMoreMatchesForReplIndex = new boolean[searchLength]; [LINE] private static String replaceEach(final String text, final String[] searchList, final String[] replacementList, final boolean repeat, final int timeToLive) { [EOL]     if (text == null || text.isEmpty() || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) { [EOL]         return text; [EOL]     } [EOL]     if (timeToLive < 0) { [EOL]         throw new IllegalStateException("Aborting to protect against StackOverflowError - " + "output of one loop is the input of another"); [EOL]     } [EOL]     final int searchLength = searchList.length; [EOL]     final int replacementLength = replacementList.length; [EOL]     if (searchLength != replacementLength) { [EOL]         throw new IllegalArgumentException("Search and Replace array lengths don't match: " + searchLength + " vs " + replacementLength); [EOL]     } [EOL]     final boolean[] noMoreMatchesForReplIndex = new boolean[searchLength]; [EOL]     int textIndex = -1; [EOL]     int replaceIndex = -1; [EOL]     int tempIndex = -1; [EOL]     for (int i = 0; i < searchLength; i++) { [EOL]         if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) { [EOL]             continue; [EOL]         } [EOL]         tempIndex = text.indexOf(searchList[i]); [EOL]         if (tempIndex == -1) { [EOL]             noMoreMatchesForReplIndex[i] = true; [EOL]         } else { [EOL]             if (textIndex == -1 || tempIndex < textIndex) { [EOL]                 textIndex = tempIndex; [EOL]                 replaceIndex = i; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (textIndex == -1) { [EOL]         return text; [EOL]     } [EOL]     int start = 0; [EOL]     int increase = 0; [EOL]     for (int i = 0; i < searchList.length; i++) { [EOL]         if (searchList[i] == null || replacementList[i] == null) { [EOL]             continue; [EOL]         } [EOL]         final int greater = replacementList[i].length() - searchList[i].length(); [EOL]         if (greater > 0) { [EOL]             increase += 3 * greater; [EOL]         } [EOL]     } [EOL]     increase = Math.min(increase, text.length() / 5); [EOL]     final StringBuilder buf = new StringBuilder(text.length() + increase); [EOL]     while (textIndex != -1) { [EOL]         for (int i = start; i < textIndex; i++) { [EOL]             buf.append(text.charAt(i)); [EOL]         } [EOL]         buf.append(replacementList[replaceIndex]); [EOL]         start = textIndex + searchList[replaceIndex].length(); [EOL]         textIndex = -1; [EOL]         replaceIndex = -1; [EOL]         tempIndex = -1; [EOL]         for (int i = 0; i < searchLength; i++) { [EOL]             if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) { [EOL]                 continue; [EOL]             } [EOL]             tempIndex = text.indexOf(searchList[i], start); [EOL]             if (tempIndex == -1) { [EOL]                 noMoreMatchesForReplIndex[i] = true; [EOL]             } else { [EOL]                 if (textIndex == -1 || tempIndex < textIndex) { [EOL]                     textIndex = tempIndex; [EOL]                     replaceIndex = i; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     final int textLength = text.length(); [EOL]     for (int i = start; i < textLength; i++) { [EOL]         buf.append(text.charAt(i)); [EOL]     } [EOL]     final String result = buf.toString(); [EOL]     if (!repeat) { [EOL]         return result; [EOL]     } [EOL]     return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1); [EOL] } 
 [LINE] for (int i = 0; i < searchLength; i++) { [LINE] private static String replaceEach(final String text, final String[] searchList, final String[] replacementList, final boolean repeat, final int timeToLive) { [EOL]     if (text == null || text.isEmpty() || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) { [EOL]         return text; [EOL]     } [EOL]     if (timeToLive < 0) { [EOL]         throw new IllegalStateException("Aborting to protect against StackOverflowError - " + "output of one loop is the input of another"); [EOL]     } [EOL]     final int searchLength = searchList.length; [EOL]     final int replacementLength = replacementList.length; [EOL]     if (searchLength != replacementLength) { [EOL]         throw new IllegalArgumentException("Search and Replace array lengths don't match: " + searchLength + " vs " + replacementLength); [EOL]     } [EOL]     final boolean[] noMoreMatchesForReplIndex = new boolean[searchLength]; [EOL]     int textIndex = -1; [EOL]     int replaceIndex = -1; [EOL]     int tempIndex = -1; [EOL]     for (int i = 0; i < searchLength; i++) { [EOL]         if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) { [EOL]             continue; [EOL]         } [EOL]         tempIndex = text.indexOf(searchList[i]); [EOL]         if (tempIndex == -1) { [EOL]             noMoreMatchesForReplIndex[i] = true; [EOL]         } else { [EOL]             if (textIndex == -1 || tempIndex < textIndex) { [EOL]                 textIndex = tempIndex; [EOL]                 replaceIndex = i; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (textIndex == -1) { [EOL]         return text; [EOL]     } [EOL]     int start = 0; [EOL]     int increase = 0; [EOL]     for (int i = 0; i < searchList.length; i++) { [EOL]         if (searchList[i] == null || replacementList[i] == null) { [EOL]             continue; [EOL]         } [EOL]         final int greater = replacementList[i].length() - searchList[i].length(); [EOL]         if (greater > 0) { [EOL]             increase += 3 * greater; [EOL]         } [EOL]     } [EOL]     increase = Math.min(increase, text.length() / 5); [EOL]     final StringBuilder buf = new StringBuilder(text.length() + increase); [EOL]     while (textIndex != -1) { [EOL]         for (int i = start; i < textIndex; i++) { [EOL]             buf.append(text.charAt(i)); [EOL]         } [EOL]         buf.append(replacementList[replaceIndex]); [EOL]         start = textIndex + searchList[replaceIndex].length(); [EOL]         textIndex = -1; [EOL]         replaceIndex = -1; [EOL]         tempIndex = -1; [EOL]         for (int i = 0; i < searchLength; i++) { [EOL]             if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) { [EOL]                 continue; [EOL]             } [EOL]             tempIndex = text.indexOf(searchList[i], start); [EOL]             if (tempIndex == -1) { [EOL]                 noMoreMatchesForReplIndex[i] = true; [EOL]             } else { [EOL]                 if (textIndex == -1 || tempIndex < textIndex) { [EOL]                     textIndex = tempIndex; [EOL]                     replaceIndex = i; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     final int textLength = text.length(); [EOL]     for (int i = start; i < textLength; i++) { [EOL]         buf.append(text.charAt(i)); [EOL]     } [EOL]     final String result = buf.toString(); [EOL]     if (!repeat) { [EOL]         return result; [EOL]     } [EOL]     return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1); [EOL] } 
 [LINE] if (noMoreMatchesForReplIndex[i] || searchList[i] == null || [LINE] private static String replaceEach(final String text, final String[] searchList, final String[] replacementList, final boolean repeat, final int timeToLive) { [EOL]     if (text == null || text.isEmpty() || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) { [EOL]         return text; [EOL]     } [EOL]     if (timeToLive < 0) { [EOL]         throw new IllegalStateException("Aborting to protect against StackOverflowError - " + "output of one loop is the input of another"); [EOL]     } [EOL]     final int searchLength = searchList.length; [EOL]     final int replacementLength = replacementList.length; [EOL]     if (searchLength != replacementLength) { [EOL]         throw new IllegalArgumentException("Search and Replace array lengths don't match: " + searchLength + " vs " + replacementLength); [EOL]     } [EOL]     final boolean[] noMoreMatchesForReplIndex = new boolean[searchLength]; [EOL]     int textIndex = -1; [EOL]     int replaceIndex = -1; [EOL]     int tempIndex = -1; [EOL]     for (int i = 0; i < searchLength; i++) { [EOL]         if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) { [EOL]             continue; [EOL]         } [EOL]         tempIndex = text.indexOf(searchList[i]); [EOL]         if (tempIndex == -1) { [EOL]             noMoreMatchesForReplIndex[i] = true; [EOL]         } else { [EOL]             if (textIndex == -1 || tempIndex < textIndex) { [EOL]                 textIndex = tempIndex; [EOL]                 replaceIndex = i; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (textIndex == -1) { [EOL]         return text; [EOL]     } [EOL]     int start = 0; [EOL]     int increase = 0; [EOL]     for (int i = 0; i < searchList.length; i++) { [EOL]         if (searchList[i] == null || replacementList[i] == null) { [EOL]             continue; [EOL]         } [EOL]         final int greater = replacementList[i].length() - searchList[i].length(); [EOL]         if (greater > 0) { [EOL]             increase += 3 * greater; [EOL]         } [EOL]     } [EOL]     increase = Math.min(increase, text.length() / 5); [EOL]     final StringBuilder buf = new StringBuilder(text.length() + increase); [EOL]     while (textIndex != -1) { [EOL]         for (int i = start; i < textIndex; i++) { [EOL]             buf.append(text.charAt(i)); [EOL]         } [EOL]         buf.append(replacementList[replaceIndex]); [EOL]         start = textIndex + searchList[replaceIndex].length(); [EOL]         textIndex = -1; [EOL]         replaceIndex = -1; [EOL]         tempIndex = -1; [EOL]         for (int i = 0; i < searchLength; i++) { [EOL]             if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) { [EOL]                 continue; [EOL]             } [EOL]             tempIndex = text.indexOf(searchList[i], start); [EOL]             if (tempIndex == -1) { [EOL]                 noMoreMatchesForReplIndex[i] = true; [EOL]             } else { [EOL]                 if (textIndex == -1 || tempIndex < textIndex) { [EOL]                     textIndex = tempIndex; [EOL]                     replaceIndex = i; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     final int textLength = text.length(); [EOL]     for (int i = start; i < textLength; i++) { [EOL]         buf.append(text.charAt(i)); [EOL]     } [EOL]     final String result = buf.toString(); [EOL]     if (!repeat) { [EOL]         return result; [EOL]     } [EOL]     return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1); [EOL] } 
 [LINE] continue; [LINE] private static String replaceEach(final String text, final String[] searchList, final String[] replacementList, final boolean repeat, final int timeToLive) { [EOL]     if (text == null || text.isEmpty() || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) { [EOL]         return text; [EOL]     } [EOL]     if (timeToLive < 0) { [EOL]         throw new IllegalStateException("Aborting to protect against StackOverflowError - " + "output of one loop is the input of another"); [EOL]     } [EOL]     final int searchLength = searchList.length; [EOL]     final int replacementLength = replacementList.length; [EOL]     if (searchLength != replacementLength) { [EOL]         throw new IllegalArgumentException("Search and Replace array lengths don't match: " + searchLength + " vs " + replacementLength); [EOL]     } [EOL]     final boolean[] noMoreMatchesForReplIndex = new boolean[searchLength]; [EOL]     int textIndex = -1; [EOL]     int replaceIndex = -1; [EOL]     int tempIndex = -1; [EOL]     for (int i = 0; i < searchLength; i++) { [EOL]         if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) { [EOL]             continue; [EOL]         } [EOL]         tempIndex = text.indexOf(searchList[i]); [EOL]         if (tempIndex == -1) { [EOL]             noMoreMatchesForReplIndex[i] = true; [EOL]         } else { [EOL]             if (textIndex == -1 || tempIndex < textIndex) { [EOL]                 textIndex = tempIndex; [EOL]                 replaceIndex = i; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (textIndex == -1) { [EOL]         return text; [EOL]     } [EOL]     int start = 0; [EOL]     int increase = 0; [EOL]     for (int i = 0; i < searchList.length; i++) { [EOL]         if (searchList[i] == null || replacementList[i] == null) { [EOL]             continue; [EOL]         } [EOL]         final int greater = replacementList[i].length() - searchList[i].length(); [EOL]         if (greater > 0) { [EOL]             increase += 3 * greater; [EOL]         } [EOL]     } [EOL]     increase = Math.min(increase, text.length() / 5); [EOL]     final StringBuilder buf = new StringBuilder(text.length() + increase); [EOL]     while (textIndex != -1) { [EOL]         for (int i = start; i < textIndex; i++) { [EOL]             buf.append(text.charAt(i)); [EOL]         } [EOL]         buf.append(replacementList[replaceIndex]); [EOL]         start = textIndex + searchList[replaceIndex].length(); [EOL]         textIndex = -1; [EOL]         replaceIndex = -1; [EOL]         tempIndex = -1; [EOL]         for (int i = 0; i < searchLength; i++) { [EOL]             if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) { [EOL]                 continue; [EOL]             } [EOL]             tempIndex = text.indexOf(searchList[i], start); [EOL]             if (tempIndex == -1) { [EOL]                 noMoreMatchesForReplIndex[i] = true; [EOL]             } else { [EOL]                 if (textIndex == -1 || tempIndex < textIndex) { [EOL]                     textIndex = tempIndex; [EOL]                     replaceIndex = i; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     final int textLength = text.length(); [EOL]     for (int i = start; i < textLength; i++) { [EOL]         buf.append(text.charAt(i)); [EOL]     } [EOL]     final String result = buf.toString(); [EOL]     if (!repeat) { [EOL]         return result; [EOL]     } [EOL]     return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1); [EOL] } 
 [LINE] if (tempIndex == -1) { [LINE] private static String replaceEach(final String text, final String[] searchList, final String[] replacementList, final boolean repeat, final int timeToLive) { [EOL]     if (text == null || text.isEmpty() || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) { [EOL]         return text; [EOL]     } [EOL]     if (timeToLive < 0) { [EOL]         throw new IllegalStateException("Aborting to protect against StackOverflowError - " + "output of one loop is the input of another"); [EOL]     } [EOL]     final int searchLength = searchList.length; [EOL]     final int replacementLength = replacementList.length; [EOL]     if (searchLength != replacementLength) { [EOL]         throw new IllegalArgumentException("Search and Replace array lengths don't match: " + searchLength + " vs " + replacementLength); [EOL]     } [EOL]     final boolean[] noMoreMatchesForReplIndex = new boolean[searchLength]; [EOL]     int textIndex = -1; [EOL]     int replaceIndex = -1; [EOL]     int tempIndex = -1; [EOL]     for (int i = 0; i < searchLength; i++) { [EOL]         if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) { [EOL]             continue; [EOL]         } [EOL]         tempIndex = text.indexOf(searchList[i]); [EOL]         if (tempIndex == -1) { [EOL]             noMoreMatchesForReplIndex[i] = true; [EOL]         } else { [EOL]             if (textIndex == -1 || tempIndex < textIndex) { [EOL]                 textIndex = tempIndex; [EOL]                 replaceIndex = i; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (textIndex == -1) { [EOL]         return text; [EOL]     } [EOL]     int start = 0; [EOL]     int increase = 0; [EOL]     for (int i = 0; i < searchList.length; i++) { [EOL]         if (searchList[i] == null || replacementList[i] == null) { [EOL]             continue; [EOL]         } [EOL]         final int greater = replacementList[i].length() - searchList[i].length(); [EOL]         if (greater > 0) { [EOL]             increase += 3 * greater; [EOL]         } [EOL]     } [EOL]     increase = Math.min(increase, text.length() / 5); [EOL]     final StringBuilder buf = new StringBuilder(text.length() + increase); [EOL]     while (textIndex != -1) { [EOL]         for (int i = start; i < textIndex; i++) { [EOL]             buf.append(text.charAt(i)); [EOL]         } [EOL]         buf.append(replacementList[replaceIndex]); [EOL]         start = textIndex + searchList[replaceIndex].length(); [EOL]         textIndex = -1; [EOL]         replaceIndex = -1; [EOL]         tempIndex = -1; [EOL]         for (int i = 0; i < searchLength; i++) { [EOL]             if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) { [EOL]                 continue; [EOL]             } [EOL]             tempIndex = text.indexOf(searchList[i], start); [EOL]             if (tempIndex == -1) { [EOL]                 noMoreMatchesForReplIndex[i] = true; [EOL]             } else { [EOL]                 if (textIndex == -1 || tempIndex < textIndex) { [EOL]                     textIndex = tempIndex; [EOL]                     replaceIndex = i; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     final int textLength = text.length(); [EOL]     for (int i = start; i < textLength; i++) { [EOL]         buf.append(text.charAt(i)); [EOL]     } [EOL]     final String result = buf.toString(); [EOL]     if (!repeat) { [EOL]         return result; [EOL]     } [EOL]     return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1); [EOL] } 
 [LINE] continue; [LINE] private static String replaceEach(final String text, final String[] searchList, final String[] replacementList, final boolean repeat, final int timeToLive) { [EOL]     if (text == null || text.isEmpty() || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) { [EOL]         return text; [EOL]     } [EOL]     if (timeToLive < 0) { [EOL]         throw new IllegalStateException("Aborting to protect against StackOverflowError - " + "output of one loop is the input of another"); [EOL]     } [EOL]     final int searchLength = searchList.length; [EOL]     final int replacementLength = replacementList.length; [EOL]     if (searchLength != replacementLength) { [EOL]         throw new IllegalArgumentException("Search and Replace array lengths don't match: " + searchLength + " vs " + replacementLength); [EOL]     } [EOL]     final boolean[] noMoreMatchesForReplIndex = new boolean[searchLength]; [EOL]     int textIndex = -1; [EOL]     int replaceIndex = -1; [EOL]     int tempIndex = -1; [EOL]     for (int i = 0; i < searchLength; i++) { [EOL]         if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) { [EOL]             continue; [EOL]         } [EOL]         tempIndex = text.indexOf(searchList[i]); [EOL]         if (tempIndex == -1) { [EOL]             noMoreMatchesForReplIndex[i] = true; [EOL]         } else { [EOL]             if (textIndex == -1 || tempIndex < textIndex) { [EOL]                 textIndex = tempIndex; [EOL]                 replaceIndex = i; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (textIndex == -1) { [EOL]         return text; [EOL]     } [EOL]     int start = 0; [EOL]     int increase = 0; [EOL]     for (int i = 0; i < searchList.length; i++) { [EOL]         if (searchList[i] == null || replacementList[i] == null) { [EOL]             continue; [EOL]         } [EOL]         final int greater = replacementList[i].length() - searchList[i].length(); [EOL]         if (greater > 0) { [EOL]             increase += 3 * greater; [EOL]         } [EOL]     } [EOL]     increase = Math.min(increase, text.length() / 5); [EOL]     final StringBuilder buf = new StringBuilder(text.length() + increase); [EOL]     while (textIndex != -1) { [EOL]         for (int i = start; i < textIndex; i++) { [EOL]             buf.append(text.charAt(i)); [EOL]         } [EOL]         buf.append(replacementList[replaceIndex]); [EOL]         start = textIndex + searchList[replaceIndex].length(); [EOL]         textIndex = -1; [EOL]         replaceIndex = -1; [EOL]         tempIndex = -1; [EOL]         for (int i = 0; i < searchLength; i++) { [EOL]             if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) { [EOL]                 continue; [EOL]             } [EOL]             tempIndex = text.indexOf(searchList[i], start); [EOL]             if (tempIndex == -1) { [EOL]                 noMoreMatchesForReplIndex[i] = true; [EOL]             } else { [EOL]                 if (textIndex == -1 || tempIndex < textIndex) { [EOL]                     textIndex = tempIndex; [EOL]                     replaceIndex = i; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     final int textLength = text.length(); [EOL]     for (int i = start; i < textLength; i++) { [EOL]         buf.append(text.charAt(i)); [EOL]     } [EOL]     final String result = buf.toString(); [EOL]     if (!repeat) { [EOL]         return result; [EOL]     } [EOL]     return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1); [EOL] } 
 [LINE] for (int i = start; i < textIndex; i++) { [LINE] private static String replaceEach(final String text, final String[] searchList, final String[] replacementList, final boolean repeat, final int timeToLive) { [EOL]     if (text == null || text.isEmpty() || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) { [EOL]         return text; [EOL]     } [EOL]     if (timeToLive < 0) { [EOL]         throw new IllegalStateException("Aborting to protect against StackOverflowError - " + "output of one loop is the input of another"); [EOL]     } [EOL]     final int searchLength = searchList.length; [EOL]     final int replacementLength = replacementList.length; [EOL]     if (searchLength != replacementLength) { [EOL]         throw new IllegalArgumentException("Search and Replace array lengths don't match: " + searchLength + " vs " + replacementLength); [EOL]     } [EOL]     final boolean[] noMoreMatchesForReplIndex = new boolean[searchLength]; [EOL]     int textIndex = -1; [EOL]     int replaceIndex = -1; [EOL]     int tempIndex = -1; [EOL]     for (int i = 0; i < searchLength; i++) { [EOL]         if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) { [EOL]             continue; [EOL]         } [EOL]         tempIndex = text.indexOf(searchList[i]); [EOL]         if (tempIndex == -1) { [EOL]             noMoreMatchesForReplIndex[i] = true; [EOL]         } else { [EOL]             if (textIndex == -1 || tempIndex < textIndex) { [EOL]                 textIndex = tempIndex; [EOL]                 replaceIndex = i; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (textIndex == -1) { [EOL]         return text; [EOL]     } [EOL]     int start = 0; [EOL]     int increase = 0; [EOL]     for (int i = 0; i < searchList.length; i++) { [EOL]         if (searchList[i] == null || replacementList[i] == null) { [EOL]             continue; [EOL]         } [EOL]         final int greater = replacementList[i].length() - searchList[i].length(); [EOL]         if (greater > 0) { [EOL]             increase += 3 * greater; [EOL]         } [EOL]     } [EOL]     increase = Math.min(increase, text.length() / 5); [EOL]     final StringBuilder buf = new StringBuilder(text.length() + increase); [EOL]     while (textIndex != -1) { [EOL]         for (int i = start; i < textIndex; i++) { [EOL]             buf.append(text.charAt(i)); [EOL]         } [EOL]         buf.append(replacementList[replaceIndex]); [EOL]         start = textIndex + searchList[replaceIndex].length(); [EOL]         textIndex = -1; [EOL]         replaceIndex = -1; [EOL]         tempIndex = -1; [EOL]         for (int i = 0; i < searchLength; i++) { [EOL]             if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) { [EOL]                 continue; [EOL]             } [EOL]             tempIndex = text.indexOf(searchList[i], start); [EOL]             if (tempIndex == -1) { [EOL]                 noMoreMatchesForReplIndex[i] = true; [EOL]             } else { [EOL]                 if (textIndex == -1 || tempIndex < textIndex) { [EOL]                     textIndex = tempIndex; [EOL]                     replaceIndex = i; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     final int textLength = text.length(); [EOL]     for (int i = start; i < textLength; i++) { [EOL]         buf.append(text.charAt(i)); [EOL]     } [EOL]     final String result = buf.toString(); [EOL]     if (!repeat) { [EOL]         return result; [EOL]     } [EOL]     return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1); [EOL] } 
 [LINE] buf.append(text.charAt(i)); [LINE] private static String replaceEach(final String text, final String[] searchList, final String[] replacementList, final boolean repeat, final int timeToLive) { [EOL]     if (text == null || text.isEmpty() || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) { [EOL]         return text; [EOL]     } [EOL]     if (timeToLive < 0) { [EOL]         throw new IllegalStateException("Aborting to protect against StackOverflowError - " + "output of one loop is the input of another"); [EOL]     } [EOL]     final int searchLength = searchList.length; [EOL]     final int replacementLength = replacementList.length; [EOL]     if (searchLength != replacementLength) { [EOL]         throw new IllegalArgumentException("Search and Replace array lengths don't match: " + searchLength + " vs " + replacementLength); [EOL]     } [EOL]     final boolean[] noMoreMatchesForReplIndex = new boolean[searchLength]; [EOL]     int textIndex = -1; [EOL]     int replaceIndex = -1; [EOL]     int tempIndex = -1; [EOL]     for (int i = 0; i < searchLength; i++) { [EOL]         if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) { [EOL]             continue; [EOL]         } [EOL]         tempIndex = text.indexOf(searchList[i]); [EOL]         if (tempIndex == -1) { [EOL]             noMoreMatchesForReplIndex[i] = true; [EOL]         } else { [EOL]             if (textIndex == -1 || tempIndex < textIndex) { [EOL]                 textIndex = tempIndex; [EOL]                 replaceIndex = i; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (textIndex == -1) { [EOL]         return text; [EOL]     } [EOL]     int start = 0; [EOL]     int increase = 0; [EOL]     for (int i = 0; i < searchList.length; i++) { [EOL]         if (searchList[i] == null || replacementList[i] == null) { [EOL]             continue; [EOL]         } [EOL]         final int greater = replacementList[i].length() - searchList[i].length(); [EOL]         if (greater > 0) { [EOL]             increase += 3 * greater; [EOL]         } [EOL]     } [EOL]     increase = Math.min(increase, text.length() / 5); [EOL]     final StringBuilder buf = new StringBuilder(text.length() + increase); [EOL]     while (textIndex != -1) { [EOL]         for (int i = start; i < textIndex; i++) { [EOL]             buf.append(text.charAt(i)); [EOL]         } [EOL]         buf.append(replacementList[replaceIndex]); [EOL]         start = textIndex + searchList[replaceIndex].length(); [EOL]         textIndex = -1; [EOL]         replaceIndex = -1; [EOL]         tempIndex = -1; [EOL]         for (int i = 0; i < searchLength; i++) { [EOL]             if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) { [EOL]                 continue; [EOL]             } [EOL]             tempIndex = text.indexOf(searchList[i], start); [EOL]             if (tempIndex == -1) { [EOL]                 noMoreMatchesForReplIndex[i] = true; [EOL]             } else { [EOL]                 if (textIndex == -1 || tempIndex < textIndex) { [EOL]                     textIndex = tempIndex; [EOL]                     replaceIndex = i; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     final int textLength = text.length(); [EOL]     for (int i = start; i < textLength; i++) { [EOL]         buf.append(text.charAt(i)); [EOL]     } [EOL]     final String result = buf.toString(); [EOL]     if (!repeat) { [EOL]         return result; [EOL]     } [EOL]     return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1); [EOL] } 
 [LINE] start = textIndex + searchList[replaceIndex].length(); [LINE] private static String replaceEach(final String text, final String[] searchList, final String[] replacementList, final boolean repeat, final int timeToLive) { [EOL]     if (text == null || text.isEmpty() || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) { [EOL]         return text; [EOL]     } [EOL]     if (timeToLive < 0) { [EOL]         throw new IllegalStateException("Aborting to protect against StackOverflowError - " + "output of one loop is the input of another"); [EOL]     } [EOL]     final int searchLength = searchList.length; [EOL]     final int replacementLength = replacementList.length; [EOL]     if (searchLength != replacementLength) { [EOL]         throw new IllegalArgumentException("Search and Replace array lengths don't match: " + searchLength + " vs " + replacementLength); [EOL]     } [EOL]     final boolean[] noMoreMatchesForReplIndex = new boolean[searchLength]; [EOL]     int textIndex = -1; [EOL]     int replaceIndex = -1; [EOL]     int tempIndex = -1; [EOL]     for (int i = 0; i < searchLength; i++) { [EOL]         if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) { [EOL]             continue; [EOL]         } [EOL]         tempIndex = text.indexOf(searchList[i]); [EOL]         if (tempIndex == -1) { [EOL]             noMoreMatchesForReplIndex[i] = true; [EOL]         } else { [EOL]             if (textIndex == -1 || tempIndex < textIndex) { [EOL]                 textIndex = tempIndex; [EOL]                 replaceIndex = i; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (textIndex == -1) { [EOL]         return text; [EOL]     } [EOL]     int start = 0; [EOL]     int increase = 0; [EOL]     for (int i = 0; i < searchList.length; i++) { [EOL]         if (searchList[i] == null || replacementList[i] == null) { [EOL]             continue; [EOL]         } [EOL]         final int greater = replacementList[i].length() - searchList[i].length(); [EOL]         if (greater > 0) { [EOL]             increase += 3 * greater; [EOL]         } [EOL]     } [EOL]     increase = Math.min(increase, text.length() / 5); [EOL]     final StringBuilder buf = new StringBuilder(text.length() + increase); [EOL]     while (textIndex != -1) { [EOL]         for (int i = start; i < textIndex; i++) { [EOL]             buf.append(text.charAt(i)); [EOL]         } [EOL]         buf.append(replacementList[replaceIndex]); [EOL]         start = textIndex + searchList[replaceIndex].length(); [EOL]         textIndex = -1; [EOL]         replaceIndex = -1; [EOL]         tempIndex = -1; [EOL]         for (int i = 0; i < searchLength; i++) { [EOL]             if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) { [EOL]                 continue; [EOL]             } [EOL]             tempIndex = text.indexOf(searchList[i], start); [EOL]             if (tempIndex == -1) { [EOL]                 noMoreMatchesForReplIndex[i] = true; [EOL]             } else { [EOL]                 if (textIndex == -1 || tempIndex < textIndex) { [EOL]                     textIndex = tempIndex; [EOL]                     replaceIndex = i; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     final int textLength = text.length(); [EOL]     for (int i = start; i < textLength; i++) { [EOL]         buf.append(text.charAt(i)); [EOL]     } [EOL]     final String result = buf.toString(); [EOL]     if (!repeat) { [EOL]         return result; [EOL]     } [EOL]     return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1); [EOL] } 
 [LINE] textIndex = -1; [LINE] private static String replaceEach(final String text, final String[] searchList, final String[] replacementList, final boolean repeat, final int timeToLive) { [EOL]     if (text == null || text.isEmpty() || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) { [EOL]         return text; [EOL]     } [EOL]     if (timeToLive < 0) { [EOL]         throw new IllegalStateException("Aborting to protect against StackOverflowError - " + "output of one loop is the input of another"); [EOL]     } [EOL]     final int searchLength = searchList.length; [EOL]     final int replacementLength = replacementList.length; [EOL]     if (searchLength != replacementLength) { [EOL]         throw new IllegalArgumentException("Search and Replace array lengths don't match: " + searchLength + " vs " + replacementLength); [EOL]     } [EOL]     final boolean[] noMoreMatchesForReplIndex = new boolean[searchLength]; [EOL]     int textIndex = -1; [EOL]     int replaceIndex = -1; [EOL]     int tempIndex = -1; [EOL]     for (int i = 0; i < searchLength; i++) { [EOL]         if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) { [EOL]             continue; [EOL]         } [EOL]         tempIndex = text.indexOf(searchList[i]); [EOL]         if (tempIndex == -1) { [EOL]             noMoreMatchesForReplIndex[i] = true; [EOL]         } else { [EOL]             if (textIndex == -1 || tempIndex < textIndex) { [EOL]                 textIndex = tempIndex; [EOL]                 replaceIndex = i; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (textIndex == -1) { [EOL]         return text; [EOL]     } [EOL]     int start = 0; [EOL]     int increase = 0; [EOL]     for (int i = 0; i < searchList.length; i++) { [EOL]         if (searchList[i] == null || replacementList[i] == null) { [EOL]             continue; [EOL]         } [EOL]         final int greater = replacementList[i].length() - searchList[i].length(); [EOL]         if (greater > 0) { [EOL]             increase += 3 * greater; [EOL]         } [EOL]     } [EOL]     increase = Math.min(increase, text.length() / 5); [EOL]     final StringBuilder buf = new StringBuilder(text.length() + increase); [EOL]     while (textIndex != -1) { [EOL]         for (int i = start; i < textIndex; i++) { [EOL]             buf.append(text.charAt(i)); [EOL]         } [EOL]         buf.append(replacementList[replaceIndex]); [EOL]         start = textIndex + searchList[replaceIndex].length(); [EOL]         textIndex = -1; [EOL]         replaceIndex = -1; [EOL]         tempIndex = -1; [EOL]         for (int i = 0; i < searchLength; i++) { [EOL]             if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) { [EOL]                 continue; [EOL]             } [EOL]             tempIndex = text.indexOf(searchList[i], start); [EOL]             if (tempIndex == -1) { [EOL]                 noMoreMatchesForReplIndex[i] = true; [EOL]             } else { [EOL]                 if (textIndex == -1 || tempIndex < textIndex) { [EOL]                     textIndex = tempIndex; [EOL]                     replaceIndex = i; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     final int textLength = text.length(); [EOL]     for (int i = start; i < textLength; i++) { [EOL]         buf.append(text.charAt(i)); [EOL]     } [EOL]     final String result = buf.toString(); [EOL]     if (!repeat) { [EOL]         return result; [EOL]     } [EOL]     return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1); [EOL] } 
 [LINE] for (int i = start; i < textLength; i++) { [LINE] private static String replaceEach(final String text, final String[] searchList, final String[] replacementList, final boolean repeat, final int timeToLive) { [EOL]     if (text == null || text.isEmpty() || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) { [EOL]         return text; [EOL]     } [EOL]     if (timeToLive < 0) { [EOL]         throw new IllegalStateException("Aborting to protect against StackOverflowError - " + "output of one loop is the input of another"); [EOL]     } [EOL]     final int searchLength = searchList.length; [EOL]     final int replacementLength = replacementList.length; [EOL]     if (searchLength != replacementLength) { [EOL]         throw new IllegalArgumentException("Search and Replace array lengths don't match: " + searchLength + " vs " + replacementLength); [EOL]     } [EOL]     final boolean[] noMoreMatchesForReplIndex = new boolean[searchLength]; [EOL]     int textIndex = -1; [EOL]     int replaceIndex = -1; [EOL]     int tempIndex = -1; [EOL]     for (int i = 0; i < searchLength; i++) { [EOL]         if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) { [EOL]             continue; [EOL]         } [EOL]         tempIndex = text.indexOf(searchList[i]); [EOL]         if (tempIndex == -1) { [EOL]             noMoreMatchesForReplIndex[i] = true; [EOL]         } else { [EOL]             if (textIndex == -1 || tempIndex < textIndex) { [EOL]                 textIndex = tempIndex; [EOL]                 replaceIndex = i; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (textIndex == -1) { [EOL]         return text; [EOL]     } [EOL]     int start = 0; [EOL]     int increase = 0; [EOL]     for (int i = 0; i < searchList.length; i++) { [EOL]         if (searchList[i] == null || replacementList[i] == null) { [EOL]             continue; [EOL]         } [EOL]         final int greater = replacementList[i].length() - searchList[i].length(); [EOL]         if (greater > 0) { [EOL]             increase += 3 * greater; [EOL]         } [EOL]     } [EOL]     increase = Math.min(increase, text.length() / 5); [EOL]     final StringBuilder buf = new StringBuilder(text.length() + increase); [EOL]     while (textIndex != -1) { [EOL]         for (int i = start; i < textIndex; i++) { [EOL]             buf.append(text.charAt(i)); [EOL]         } [EOL]         buf.append(replacementList[replaceIndex]); [EOL]         start = textIndex + searchList[replaceIndex].length(); [EOL]         textIndex = -1; [EOL]         replaceIndex = -1; [EOL]         tempIndex = -1; [EOL]         for (int i = 0; i < searchLength; i++) { [EOL]             if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) { [EOL]                 continue; [EOL]             } [EOL]             tempIndex = text.indexOf(searchList[i], start); [EOL]             if (tempIndex == -1) { [EOL]                 noMoreMatchesForReplIndex[i] = true; [EOL]             } else { [EOL]                 if (textIndex == -1 || tempIndex < textIndex) { [EOL]                     textIndex = tempIndex; [EOL]                     replaceIndex = i; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     final int textLength = text.length(); [EOL]     for (int i = start; i < textLength; i++) { [EOL]         buf.append(text.charAt(i)); [EOL]     } [EOL]     final String result = buf.toString(); [EOL]     if (!repeat) { [EOL]         return result; [EOL]     } [EOL]     return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1); [EOL] } 
 [LINE] final String result = buf.toString(); [LINE] private static String replaceEach(final String text, final String[] searchList, final String[] replacementList, final boolean repeat, final int timeToLive) { [EOL]     if (text == null || text.isEmpty() || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) { [EOL]         return text; [EOL]     } [EOL]     if (timeToLive < 0) { [EOL]         throw new IllegalStateException("Aborting to protect against StackOverflowError - " + "output of one loop is the input of another"); [EOL]     } [EOL]     final int searchLength = searchList.length; [EOL]     final int replacementLength = replacementList.length; [EOL]     if (searchLength != replacementLength) { [EOL]         throw new IllegalArgumentException("Search and Replace array lengths don't match: " + searchLength + " vs " + replacementLength); [EOL]     } [EOL]     final boolean[] noMoreMatchesForReplIndex = new boolean[searchLength]; [EOL]     int textIndex = -1; [EOL]     int replaceIndex = -1; [EOL]     int tempIndex = -1; [EOL]     for (int i = 0; i < searchLength; i++) { [EOL]         if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) { [EOL]             continue; [EOL]         } [EOL]         tempIndex = text.indexOf(searchList[i]); [EOL]         if (tempIndex == -1) { [EOL]             noMoreMatchesForReplIndex[i] = true; [EOL]         } else { [EOL]             if (textIndex == -1 || tempIndex < textIndex) { [EOL]                 textIndex = tempIndex; [EOL]                 replaceIndex = i; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (textIndex == -1) { [EOL]         return text; [EOL]     } [EOL]     int start = 0; [EOL]     int increase = 0; [EOL]     for (int i = 0; i < searchList.length; i++) { [EOL]         if (searchList[i] == null || replacementList[i] == null) { [EOL]             continue; [EOL]         } [EOL]         final int greater = replacementList[i].length() - searchList[i].length(); [EOL]         if (greater > 0) { [EOL]             increase += 3 * greater; [EOL]         } [EOL]     } [EOL]     increase = Math.min(increase, text.length() / 5); [EOL]     final StringBuilder buf = new StringBuilder(text.length() + increase); [EOL]     while (textIndex != -1) { [EOL]         for (int i = start; i < textIndex; i++) { [EOL]             buf.append(text.charAt(i)); [EOL]         } [EOL]         buf.append(replacementList[replaceIndex]); [EOL]         start = textIndex + searchList[replaceIndex].length(); [EOL]         textIndex = -1; [EOL]         replaceIndex = -1; [EOL]         tempIndex = -1; [EOL]         for (int i = 0; i < searchLength; i++) { [EOL]             if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) { [EOL]                 continue; [EOL]             } [EOL]             tempIndex = text.indexOf(searchList[i], start); [EOL]             if (tempIndex == -1) { [EOL]                 noMoreMatchesForReplIndex[i] = true; [EOL]             } else { [EOL]                 if (textIndex == -1 || tempIndex < textIndex) { [EOL]                     textIndex = tempIndex; [EOL]                     replaceIndex = i; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     final int textLength = text.length(); [EOL]     for (int i = start; i < textLength; i++) { [EOL]         buf.append(text.charAt(i)); [EOL]     } [EOL]     final String result = buf.toString(); [EOL]     if (!repeat) { [EOL]         return result; [EOL]     } [EOL]     return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1); [EOL] } 
 [LINE] return str.replace(searchChar, replaceChar); [LINE] public static String replaceChars(final String str, final char searchChar, final char replaceChar) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     return str.replace(searchChar, replaceChar); [EOL] } 
 [LINE] if (isEmpty(str) || isEmpty(searchChars)) { [LINE] public static String replaceChars(final String str, final String searchChars, String replaceChars) { [EOL]     if (isEmpty(str) || isEmpty(searchChars)) { [EOL]         return str; [EOL]     } [EOL]     if (replaceChars == null) { [EOL]         replaceChars = EMPTY; [EOL]     } [EOL]     boolean modified = false; [EOL]     final int replaceCharsLength = replaceChars.length(); [EOL]     final int strLength = str.length(); [EOL]     final StringBuilder buf = new StringBuilder(strLength); [EOL]     for (int i = 0; i < strLength; i++) { [EOL]         final char ch = str.charAt(i); [EOL]         final int index = searchChars.indexOf(ch); [EOL]         if (index >= 0) { [EOL]             modified = true; [EOL]             if (index < replaceCharsLength) { [EOL]                 buf.append(replaceChars.charAt(index)); [EOL]             } [EOL]         } else { [EOL]             buf.append(ch); [EOL]         } [EOL]     } [EOL]     if (modified) { [EOL]         return buf.toString(); [EOL]     } [EOL]     return str; [EOL] } 
 [LINE] boolean modified = false; [LINE] public static String replaceChars(final String str, final String searchChars, String replaceChars) { [EOL]     if (isEmpty(str) || isEmpty(searchChars)) { [EOL]         return str; [EOL]     } [EOL]     if (replaceChars == null) { [EOL]         replaceChars = EMPTY; [EOL]     } [EOL]     boolean modified = false; [EOL]     final int replaceCharsLength = replaceChars.length(); [EOL]     final int strLength = str.length(); [EOL]     final StringBuilder buf = new StringBuilder(strLength); [EOL]     for (int i = 0; i < strLength; i++) { [EOL]         final char ch = str.charAt(i); [EOL]         final int index = searchChars.indexOf(ch); [EOL]         if (index >= 0) { [EOL]             modified = true; [EOL]             if (index < replaceCharsLength) { [EOL]                 buf.append(replaceChars.charAt(index)); [EOL]             } [EOL]         } else { [EOL]             buf.append(ch); [EOL]         } [EOL]     } [EOL]     if (modified) { [EOL]         return buf.toString(); [EOL]     } [EOL]     return str; [EOL] } 
 [LINE] final StringBuilder buf = new StringBuilder(strLength); [LINE] public static String replaceChars(final String str, final String searchChars, String replaceChars) { [EOL]     if (isEmpty(str) || isEmpty(searchChars)) { [EOL]         return str; [EOL]     } [EOL]     if (replaceChars == null) { [EOL]         replaceChars = EMPTY; [EOL]     } [EOL]     boolean modified = false; [EOL]     final int replaceCharsLength = replaceChars.length(); [EOL]     final int strLength = str.length(); [EOL]     final StringBuilder buf = new StringBuilder(strLength); [EOL]     for (int i = 0; i < strLength; i++) { [EOL]         final char ch = str.charAt(i); [EOL]         final int index = searchChars.indexOf(ch); [EOL]         if (index >= 0) { [EOL]             modified = true; [EOL]             if (index < replaceCharsLength) { [EOL]                 buf.append(replaceChars.charAt(index)); [EOL]             } [EOL]         } else { [EOL]             buf.append(ch); [EOL]         } [EOL]     } [EOL]     if (modified) { [EOL]         return buf.toString(); [EOL]     } [EOL]     return str; [EOL] } 
 [LINE] final char ch = str.charAt(i); [LINE] public static String replaceChars(final String str, final String searchChars, String replaceChars) { [EOL]     if (isEmpty(str) || isEmpty(searchChars)) { [EOL]         return str; [EOL]     } [EOL]     if (replaceChars == null) { [EOL]         replaceChars = EMPTY; [EOL]     } [EOL]     boolean modified = false; [EOL]     final int replaceCharsLength = replaceChars.length(); [EOL]     final int strLength = str.length(); [EOL]     final StringBuilder buf = new StringBuilder(strLength); [EOL]     for (int i = 0; i < strLength; i++) { [EOL]         final char ch = str.charAt(i); [EOL]         final int index = searchChars.indexOf(ch); [EOL]         if (index >= 0) { [EOL]             modified = true; [EOL]             if (index < replaceCharsLength) { [EOL]                 buf.append(replaceChars.charAt(index)); [EOL]             } [EOL]         } else { [EOL]             buf.append(ch); [EOL]         } [EOL]     } [EOL]     if (modified) { [EOL]         return buf.toString(); [EOL]     } [EOL]     return str; [EOL] } 
 [LINE] modified = true; [LINE] public static String replaceChars(final String str, final String searchChars, String replaceChars) { [EOL]     if (isEmpty(str) || isEmpty(searchChars)) { [EOL]         return str; [EOL]     } [EOL]     if (replaceChars == null) { [EOL]         replaceChars = EMPTY; [EOL]     } [EOL]     boolean modified = false; [EOL]     final int replaceCharsLength = replaceChars.length(); [EOL]     final int strLength = str.length(); [EOL]     final StringBuilder buf = new StringBuilder(strLength); [EOL]     for (int i = 0; i < strLength; i++) { [EOL]         final char ch = str.charAt(i); [EOL]         final int index = searchChars.indexOf(ch); [EOL]         if (index >= 0) { [EOL]             modified = true; [EOL]             if (index < replaceCharsLength) { [EOL]                 buf.append(replaceChars.charAt(index)); [EOL]             } [EOL]         } else { [EOL]             buf.append(ch); [EOL]         } [EOL]     } [EOL]     if (modified) { [EOL]         return buf.toString(); [EOL]     } [EOL]     return str; [EOL] } 
 [LINE] if (overlay == null) { [LINE] public static String overlay(final String str, String overlay, int start, int end) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (overlay == null) { [EOL]         overlay = EMPTY; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (start < 0) { [EOL]         start = 0; [EOL]     } [EOL]     if (start > len) { [EOL]         start = len; [EOL]     } [EOL]     if (end < 0) { [EOL]         end = 0; [EOL]     } [EOL]     if (end > len) { [EOL]         end = len; [EOL]     } [EOL]     if (start > end) { [EOL]         final int temp = start; [EOL]         start = end; [EOL]         end = temp; [EOL]     } [EOL]     return new StringBuilder(len + start - end + overlay.length() + 1).append(str.substring(0, start)).append(overlay).append(str.substring(end)).toString(); [EOL] } 
 [LINE] start = 0; [LINE] public static String overlay(final String str, String overlay, int start, int end) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (overlay == null) { [EOL]         overlay = EMPTY; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (start < 0) { [EOL]         start = 0; [EOL]     } [EOL]     if (start > len) { [EOL]         start = len; [EOL]     } [EOL]     if (end < 0) { [EOL]         end = 0; [EOL]     } [EOL]     if (end > len) { [EOL]         end = len; [EOL]     } [EOL]     if (start > end) { [EOL]         final int temp = start; [EOL]         start = end; [EOL]         end = temp; [EOL]     } [EOL]     return new StringBuilder(len + start - end + overlay.length() + 1).append(str.substring(0, start)).append(overlay).append(str.substring(end)).toString(); [EOL] } 
 [LINE] if (end < 0) { [LINE] public static String overlay(final String str, String overlay, int start, int end) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (overlay == null) { [EOL]         overlay = EMPTY; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (start < 0) { [EOL]         start = 0; [EOL]     } [EOL]     if (start > len) { [EOL]         start = len; [EOL]     } [EOL]     if (end < 0) { [EOL]         end = 0; [EOL]     } [EOL]     if (end > len) { [EOL]         end = len; [EOL]     } [EOL]     if (start > end) { [EOL]         final int temp = start; [EOL]         start = end; [EOL]         end = temp; [EOL]     } [EOL]     return new StringBuilder(len + start - end + overlay.length() + 1).append(str.substring(0, start)).append(overlay).append(str.substring(end)).toString(); [EOL] } 
 [LINE] if (start > end) { [LINE] public static String overlay(final String str, String overlay, int start, int end) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (overlay == null) { [EOL]         overlay = EMPTY; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (start < 0) { [EOL]         start = 0; [EOL]     } [EOL]     if (start > len) { [EOL]         start = len; [EOL]     } [EOL]     if (end < 0) { [EOL]         end = 0; [EOL]     } [EOL]     if (end > len) { [EOL]         end = len; [EOL]     } [EOL]     if (start > end) { [EOL]         final int temp = start; [EOL]         start = end; [EOL]         end = temp; [EOL]     } [EOL]     return new StringBuilder(len + start - end + overlay.length() + 1).append(str.substring(0, start)).append(overlay).append(str.substring(end)).toString(); [EOL] } 
 [LINE] return new StringBuilder(len + start - end + overlay.length() + 1) [LINE] public static String overlay(final String str, String overlay, int start, int end) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (overlay == null) { [EOL]         overlay = EMPTY; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (start < 0) { [EOL]         start = 0; [EOL]     } [EOL]     if (start > len) { [EOL]         start = len; [EOL]     } [EOL]     if (end < 0) { [EOL]         end = 0; [EOL]     } [EOL]     if (end > len) { [EOL]         end = len; [EOL]     } [EOL]     if (start > end) { [EOL]         final int temp = start; [EOL]         start = end; [EOL]         end = temp; [EOL]     } [EOL]     return new StringBuilder(len + start - end + overlay.length() + 1).append(str.substring(0, start)).append(overlay).append(str.substring(end)).toString(); [EOL] } 
 [LINE] final char last = str.charAt(lastIdx); [LINE] public static String chomp(final String str) { [EOL]     if (isEmpty(str)) { [EOL]         return str; [EOL]     } [EOL]     if (str.length() == 1) { [EOL]         final char ch = str.charAt(0); [EOL]         if (ch == CharUtils.CR || ch == CharUtils.LF) { [EOL]             return EMPTY; [EOL]         } [EOL]         return str; [EOL]     } [EOL]     int lastIdx = str.length() - 1; [EOL]     final char last = str.charAt(lastIdx); [EOL]     if (last == CharUtils.LF) { [EOL]         if (str.charAt(lastIdx - 1) == CharUtils.CR) { [EOL]             lastIdx--; [EOL]         } [EOL]     } else if (last != CharUtils.CR) { [EOL]         lastIdx++; [EOL]     } [EOL]     return str.substring(0, lastIdx); [EOL] } 
 [LINE] if (last == CharUtils.LF) { [LINE] public static String chomp(final String str) { [EOL]     if (isEmpty(str)) { [EOL]         return str; [EOL]     } [EOL]     if (str.length() == 1) { [EOL]         final char ch = str.charAt(0); [EOL]         if (ch == CharUtils.CR || ch == CharUtils.LF) { [EOL]             return EMPTY; [EOL]         } [EOL]         return str; [EOL]     } [EOL]     int lastIdx = str.length() - 1; [EOL]     final char last = str.charAt(lastIdx); [EOL]     if (last == CharUtils.LF) { [EOL]         if (str.charAt(lastIdx - 1) == CharUtils.CR) { [EOL]             lastIdx--; [EOL]         } [EOL]     } else if (last != CharUtils.CR) { [EOL]         lastIdx++; [EOL]     } [EOL]     return str.substring(0, lastIdx); [EOL] } 
 [LINE] return str; [LINE] public static String repeat(final String str, final int repeat) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (repeat <= 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final int inputLength = str.length(); [EOL]     if (repeat == 1 || inputLength == 0) { [EOL]         return str; [EOL]     } [EOL]     if (inputLength == 1 && repeat <= PAD_LIMIT) { [EOL]         return repeat(str.charAt(0), repeat); [EOL]     } [EOL]     final int outputLength = inputLength * repeat; [EOL]     switch(inputLength) { [EOL]         case 1: [EOL]             return repeat(str.charAt(0), repeat); [EOL]         case 2: [EOL]             final char ch0 = str.charAt(0); [EOL]             final char ch1 = str.charAt(1); [EOL]             final char[] output2 = new char[outputLength]; [EOL]             for (int i = repeat * 2 - 2; i >= 0; i--, i--) { [EOL]                 output2[i] = ch0; [EOL]                 output2[i + 1] = ch1; [EOL]             } [EOL]             return new String(output2); [EOL]         default: [EOL]             final StringBuilder buf = new StringBuilder(outputLength); [EOL]             for (int i = 0; i < repeat; i++) { [EOL]                 buf.append(str); [EOL]             } [EOL]             return buf.toString(); [EOL]     } [EOL] } 
 [LINE] if (inputLength == 1 && repeat <= PAD_LIMIT) { [LINE] public static String repeat(final String str, final int repeat) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (repeat <= 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final int inputLength = str.length(); [EOL]     if (repeat == 1 || inputLength == 0) { [EOL]         return str; [EOL]     } [EOL]     if (inputLength == 1 && repeat <= PAD_LIMIT) { [EOL]         return repeat(str.charAt(0), repeat); [EOL]     } [EOL]     final int outputLength = inputLength * repeat; [EOL]     switch(inputLength) { [EOL]         case 1: [EOL]             return repeat(str.charAt(0), repeat); [EOL]         case 2: [EOL]             final char ch0 = str.charAt(0); [EOL]             final char ch1 = str.charAt(1); [EOL]             final char[] output2 = new char[outputLength]; [EOL]             for (int i = repeat * 2 - 2; i >= 0; i--, i--) { [EOL]                 output2[i] = ch0; [EOL]                 output2[i + 1] = ch1; [EOL]             } [EOL]             return new String(output2); [EOL]         default: [EOL]             final StringBuilder buf = new StringBuilder(outputLength); [EOL]             for (int i = 0; i < repeat; i++) { [EOL]                 buf.append(str); [EOL]             } [EOL]             return buf.toString(); [EOL]     } [EOL] } 
 [LINE] return repeat(str.charAt(0), repeat); [LINE] public static String repeat(final String str, final int repeat) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (repeat <= 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final int inputLength = str.length(); [EOL]     if (repeat == 1 || inputLength == 0) { [EOL]         return str; [EOL]     } [EOL]     if (inputLength == 1 && repeat <= PAD_LIMIT) { [EOL]         return repeat(str.charAt(0), repeat); [EOL]     } [EOL]     final int outputLength = inputLength * repeat; [EOL]     switch(inputLength) { [EOL]         case 1: [EOL]             return repeat(str.charAt(0), repeat); [EOL]         case 2: [EOL]             final char ch0 = str.charAt(0); [EOL]             final char ch1 = str.charAt(1); [EOL]             final char[] output2 = new char[outputLength]; [EOL]             for (int i = repeat * 2 - 2; i >= 0; i--, i--) { [EOL]                 output2[i] = ch0; [EOL]                 output2[i + 1] = ch1; [EOL]             } [EOL]             return new String(output2); [EOL]         default: [EOL]             final StringBuilder buf = new StringBuilder(outputLength); [EOL]             for (int i = 0; i < repeat; i++) { [EOL]                 buf.append(str); [EOL]             } [EOL]             return buf.toString(); [EOL]     } [EOL] } 
 [LINE] final char[] output2 = new char[outputLength]; [LINE] public static String repeat(final String str, final int repeat) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (repeat <= 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final int inputLength = str.length(); [EOL]     if (repeat == 1 || inputLength == 0) { [EOL]         return str; [EOL]     } [EOL]     if (inputLength == 1 && repeat <= PAD_LIMIT) { [EOL]         return repeat(str.charAt(0), repeat); [EOL]     } [EOL]     final int outputLength = inputLength * repeat; [EOL]     switch(inputLength) { [EOL]         case 1: [EOL]             return repeat(str.charAt(0), repeat); [EOL]         case 2: [EOL]             final char ch0 = str.charAt(0); [EOL]             final char ch1 = str.charAt(1); [EOL]             final char[] output2 = new char[outputLength]; [EOL]             for (int i = repeat * 2 - 2; i >= 0; i--, i--) { [EOL]                 output2[i] = ch0; [EOL]                 output2[i + 1] = ch1; [EOL]             } [EOL]             return new String(output2); [EOL]         default: [EOL]             final StringBuilder buf = new StringBuilder(outputLength); [EOL]             for (int i = 0; i < repeat; i++) { [EOL]                 buf.append(str); [EOL]             } [EOL]             return buf.toString(); [EOL]     } [EOL] } 
 [LINE] output2[i + 1] = ch1; [LINE] public static String repeat(final String str, final int repeat) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (repeat <= 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final int inputLength = str.length(); [EOL]     if (repeat == 1 || inputLength == 0) { [EOL]         return str; [EOL]     } [EOL]     if (inputLength == 1 && repeat <= PAD_LIMIT) { [EOL]         return repeat(str.charAt(0), repeat); [EOL]     } [EOL]     final int outputLength = inputLength * repeat; [EOL]     switch(inputLength) { [EOL]         case 1: [EOL]             return repeat(str.charAt(0), repeat); [EOL]         case 2: [EOL]             final char ch0 = str.charAt(0); [EOL]             final char ch1 = str.charAt(1); [EOL]             final char[] output2 = new char[outputLength]; [EOL]             for (int i = repeat * 2 - 2; i >= 0; i--, i--) { [EOL]                 output2[i] = ch0; [EOL]                 output2[i + 1] = ch1; [EOL]             } [EOL]             return new String(output2); [EOL]         default: [EOL]             final StringBuilder buf = new StringBuilder(outputLength); [EOL]             for (int i = 0; i < repeat; i++) { [EOL]                 buf.append(str); [EOL]             } [EOL]             return buf.toString(); [EOL]     } [EOL] } 
 [LINE] final StringBuilder buf = new StringBuilder(outputLength); [LINE] public static String repeat(final String str, final int repeat) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (repeat <= 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final int inputLength = str.length(); [EOL]     if (repeat == 1 || inputLength == 0) { [EOL]         return str; [EOL]     } [EOL]     if (inputLength == 1 && repeat <= PAD_LIMIT) { [EOL]         return repeat(str.charAt(0), repeat); [EOL]     } [EOL]     final int outputLength = inputLength * repeat; [EOL]     switch(inputLength) { [EOL]         case 1: [EOL]             return repeat(str.charAt(0), repeat); [EOL]         case 2: [EOL]             final char ch0 = str.charAt(0); [EOL]             final char ch1 = str.charAt(1); [EOL]             final char[] output2 = new char[outputLength]; [EOL]             for (int i = repeat * 2 - 2; i >= 0; i--, i--) { [EOL]                 output2[i] = ch0; [EOL]                 output2[i + 1] = ch1; [EOL]             } [EOL]             return new String(output2); [EOL]         default: [EOL]             final StringBuilder buf = new StringBuilder(outputLength); [EOL]             for (int i = 0; i < repeat; i++) { [EOL]                 buf.append(str); [EOL]             } [EOL]             return buf.toString(); [EOL]     } [EOL] } 
 [LINE] for (int i = 0; i < repeat; i++) { [LINE] public static String repeat(final String str, final int repeat) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (repeat <= 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final int inputLength = str.length(); [EOL]     if (repeat == 1 || inputLength == 0) { [EOL]         return str; [EOL]     } [EOL]     if (inputLength == 1 && repeat <= PAD_LIMIT) { [EOL]         return repeat(str.charAt(0), repeat); [EOL]     } [EOL]     final int outputLength = inputLength * repeat; [EOL]     switch(inputLength) { [EOL]         case 1: [EOL]             return repeat(str.charAt(0), repeat); [EOL]         case 2: [EOL]             final char ch0 = str.charAt(0); [EOL]             final char ch1 = str.charAt(1); [EOL]             final char[] output2 = new char[outputLength]; [EOL]             for (int i = repeat * 2 - 2; i >= 0; i--, i--) { [EOL]                 output2[i] = ch0; [EOL]                 output2[i + 1] = ch1; [EOL]             } [EOL]             return new String(output2); [EOL]         default: [EOL]             final StringBuilder buf = new StringBuilder(outputLength); [EOL]             for (int i = 0; i < repeat; i++) { [EOL]                 buf.append(str); [EOL]             } [EOL]             return buf.toString(); [EOL]     } [EOL] } 
 [LINE] return repeat(str, repeat); [LINE] public static String repeat(final String str, final String separator, final int repeat) { [EOL]     if (str == null || separator == null) { [EOL]         return repeat(str, repeat); [EOL]     } [EOL]     final String result = repeat(str + separator, repeat); [EOL]     return removeEnd(result, separator); [EOL] } 
 [LINE] final String result = repeat(str + separator, repeat); [LINE] public static String repeat(final String str, final String separator, final int repeat) { [EOL]     if (str == null || separator == null) { [EOL]         return repeat(str, repeat); [EOL]     } [EOL]     final String result = repeat(str + separator, repeat); [EOL]     return removeEnd(result, separator); [EOL] } 
 [LINE] for (int i = repeat - 1; i >= 0; i--) { [LINE] public static String repeat(final char ch, final int repeat) { [EOL]     final char[] buf = new char[repeat]; [EOL]     for (int i = repeat - 1; i >= 0; i--) { [EOL]         buf[i] = ch; [EOL]     } [EOL]     return new String(buf); [EOL] } 
 [LINE] return new String(buf); [LINE] public static String repeat(final char ch, final int repeat) { [EOL]     final char[] buf = new char[repeat]; [EOL]     for (int i = repeat - 1; i >= 0; i--) { [EOL]         buf[i] = ch; [EOL]     } [EOL]     return new String(buf); [EOL] } 
 [LINE] if (pads > PAD_LIMIT) { [LINE] public static String rightPad(final String str, final int size, final char padChar) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int pads = size - str.length(); [EOL]     if (pads <= 0) { [EOL]         return str; [EOL]     } [EOL]     if (pads > PAD_LIMIT) { [EOL]         return rightPad(str, size, String.valueOf(padChar)); [EOL]     } [EOL]     return str.concat(repeat(padChar, pads)); [EOL] } 
 [LINE] return rightPad(str, size, String.valueOf(padChar)); [LINE] public static String rightPad(final String str, final int size, final char padChar) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int pads = size - str.length(); [EOL]     if (pads <= 0) { [EOL]         return str; [EOL]     } [EOL]     if (pads > PAD_LIMIT) { [EOL]         return rightPad(str, size, String.valueOf(padChar)); [EOL]     } [EOL]     return str.concat(repeat(padChar, pads)); [EOL] } 
 [LINE] final int strLen = str.length(); [LINE] public static String rightPad(final String str, final int size, String padStr) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (isEmpty(padStr)) { [EOL]         padStr = SPACE; [EOL]     } [EOL]     final int padLen = padStr.length(); [EOL]     final int strLen = str.length(); [EOL]     final int pads = size - strLen; [EOL]     if (pads <= 0) { [EOL]         return str; [EOL]     } [EOL]     if (padLen == 1 && pads <= PAD_LIMIT) { [EOL]         return rightPad(str, size, padStr.charAt(0)); [EOL]     } [EOL]     if (pads == padLen) { [EOL]         return str.concat(padStr); [EOL]     } else if (pads < padLen) { [EOL]         return str.concat(padStr.substring(0, pads)); [EOL]     } else { [EOL]         final char[] padding = new char[pads]; [EOL]         final char[] padChars = padStr.toCharArray(); [EOL]         for (int i = 0; i < pads; i++) { [EOL]             padding[i] = padChars[i % padLen]; [EOL]         } [EOL]         return str.concat(new String(padding)); [EOL]     } [EOL] } 
 [LINE] final int pads = size - strLen; [LINE] public static String rightPad(final String str, final int size, String padStr) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (isEmpty(padStr)) { [EOL]         padStr = SPACE; [EOL]     } [EOL]     final int padLen = padStr.length(); [EOL]     final int strLen = str.length(); [EOL]     final int pads = size - strLen; [EOL]     if (pads <= 0) { [EOL]         return str; [EOL]     } [EOL]     if (padLen == 1 && pads <= PAD_LIMIT) { [EOL]         return rightPad(str, size, padStr.charAt(0)); [EOL]     } [EOL]     if (pads == padLen) { [EOL]         return str.concat(padStr); [EOL]     } else if (pads < padLen) { [EOL]         return str.concat(padStr.substring(0, pads)); [EOL]     } else { [EOL]         final char[] padding = new char[pads]; [EOL]         final char[] padChars = padStr.toCharArray(); [EOL]         for (int i = 0; i < pads; i++) { [EOL]             padding[i] = padChars[i % padLen]; [EOL]         } [EOL]         return str.concat(new String(padding)); [EOL]     } [EOL] } 
 [LINE] if (pads <= 0) { [LINE] public static String rightPad(final String str, final int size, String padStr) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (isEmpty(padStr)) { [EOL]         padStr = SPACE; [EOL]     } [EOL]     final int padLen = padStr.length(); [EOL]     final int strLen = str.length(); [EOL]     final int pads = size - strLen; [EOL]     if (pads <= 0) { [EOL]         return str; [EOL]     } [EOL]     if (padLen == 1 && pads <= PAD_LIMIT) { [EOL]         return rightPad(str, size, padStr.charAt(0)); [EOL]     } [EOL]     if (pads == padLen) { [EOL]         return str.concat(padStr); [EOL]     } else if (pads < padLen) { [EOL]         return str.concat(padStr.substring(0, pads)); [EOL]     } else { [EOL]         final char[] padding = new char[pads]; [EOL]         final char[] padChars = padStr.toCharArray(); [EOL]         for (int i = 0; i < pads; i++) { [EOL]             padding[i] = padChars[i % padLen]; [EOL]         } [EOL]         return str.concat(new String(padding)); [EOL]     } [EOL] } 
 [LINE] } else if (pads < padLen) { [LINE] public static String rightPad(final String str, final int size, String padStr) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (isEmpty(padStr)) { [EOL]         padStr = SPACE; [EOL]     } [EOL]     final int padLen = padStr.length(); [EOL]     final int strLen = str.length(); [EOL]     final int pads = size - strLen; [EOL]     if (pads <= 0) { [EOL]         return str; [EOL]     } [EOL]     if (padLen == 1 && pads <= PAD_LIMIT) { [EOL]         return rightPad(str, size, padStr.charAt(0)); [EOL]     } [EOL]     if (pads == padLen) { [EOL]         return str.concat(padStr); [EOL]     } else if (pads < padLen) { [EOL]         return str.concat(padStr.substring(0, pads)); [EOL]     } else { [EOL]         final char[] padding = new char[pads]; [EOL]         final char[] padChars = padStr.toCharArray(); [EOL]         for (int i = 0; i < pads; i++) { [EOL]             padding[i] = padChars[i % padLen]; [EOL]         } [EOL]         return str.concat(new String(padding)); [EOL]     } [EOL] } 
 [LINE] padding[i] = padChars[i % padLen]; [LINE] public static String rightPad(final String str, final int size, String padStr) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (isEmpty(padStr)) { [EOL]         padStr = SPACE; [EOL]     } [EOL]     final int padLen = padStr.length(); [EOL]     final int strLen = str.length(); [EOL]     final int pads = size - strLen; [EOL]     if (pads <= 0) { [EOL]         return str; [EOL]     } [EOL]     if (padLen == 1 && pads <= PAD_LIMIT) { [EOL]         return rightPad(str, size, padStr.charAt(0)); [EOL]     } [EOL]     if (pads == padLen) { [EOL]         return str.concat(padStr); [EOL]     } else if (pads < padLen) { [EOL]         return str.concat(padStr.substring(0, pads)); [EOL]     } else { [EOL]         final char[] padding = new char[pads]; [EOL]         final char[] padChars = padStr.toCharArray(); [EOL]         for (int i = 0; i < pads; i++) { [EOL]             padding[i] = padChars[i % padLen]; [EOL]         } [EOL]         return str.concat(new String(padding)); [EOL]     } [EOL] } 
 [LINE] if (pads <= 0) { [LINE] public static String leftPad(final String str, final int size, final char padChar) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int pads = size - str.length(); [EOL]     if (pads <= 0) { [EOL]         return str; [EOL]     } [EOL]     if (pads > PAD_LIMIT) { [EOL]         return leftPad(str, size, String.valueOf(padChar)); [EOL]     } [EOL]     return repeat(padChar, pads).concat(str); [EOL] } 
 [LINE] return null; [LINE] public static String leftPad(final String str, final int size, String padStr) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (isEmpty(padStr)) { [EOL]         padStr = SPACE; [EOL]     } [EOL]     final int padLen = padStr.length(); [EOL]     final int strLen = str.length(); [EOL]     final int pads = size - strLen; [EOL]     if (pads <= 0) { [EOL]         return str; [EOL]     } [EOL]     if (padLen == 1 && pads <= PAD_LIMIT) { [EOL]         return leftPad(str, size, padStr.charAt(0)); [EOL]     } [EOL]     if (pads == padLen) { [EOL]         return padStr.concat(str); [EOL]     } else if (pads < padLen) { [EOL]         return padStr.substring(0, pads).concat(str); [EOL]     } else { [EOL]         final char[] padding = new char[pads]; [EOL]         final char[] padChars = padStr.toCharArray(); [EOL]         for (int i = 0; i < pads; i++) { [EOL]             padding[i] = padChars[i % padLen]; [EOL]         } [EOL]         return new String(padding).concat(str); [EOL]     } [EOL] } 
 [LINE] if (isEmpty(padStr)) { [LINE] public static String leftPad(final String str, final int size, String padStr) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (isEmpty(padStr)) { [EOL]         padStr = SPACE; [EOL]     } [EOL]     final int padLen = padStr.length(); [EOL]     final int strLen = str.length(); [EOL]     final int pads = size - strLen; [EOL]     if (pads <= 0) { [EOL]         return str; [EOL]     } [EOL]     if (padLen == 1 && pads <= PAD_LIMIT) { [EOL]         return leftPad(str, size, padStr.charAt(0)); [EOL]     } [EOL]     if (pads == padLen) { [EOL]         return padStr.concat(str); [EOL]     } else if (pads < padLen) { [EOL]         return padStr.substring(0, pads).concat(str); [EOL]     } else { [EOL]         final char[] padding = new char[pads]; [EOL]         final char[] padChars = padStr.toCharArray(); [EOL]         for (int i = 0; i < pads; i++) { [EOL]             padding[i] = padChars[i % padLen]; [EOL]         } [EOL]         return new String(padding).concat(str); [EOL]     } [EOL] } 
 [LINE] return padStr.substring(0, pads).concat(str); [LINE] public static String leftPad(final String str, final int size, String padStr) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (isEmpty(padStr)) { [EOL]         padStr = SPACE; [EOL]     } [EOL]     final int padLen = padStr.length(); [EOL]     final int strLen = str.length(); [EOL]     final int pads = size - strLen; [EOL]     if (pads <= 0) { [EOL]         return str; [EOL]     } [EOL]     if (padLen == 1 && pads <= PAD_LIMIT) { [EOL]         return leftPad(str, size, padStr.charAt(0)); [EOL]     } [EOL]     if (pads == padLen) { [EOL]         return padStr.concat(str); [EOL]     } else if (pads < padLen) { [EOL]         return padStr.substring(0, pads).concat(str); [EOL]     } else { [EOL]         final char[] padding = new char[pads]; [EOL]         final char[] padChars = padStr.toCharArray(); [EOL]         for (int i = 0; i < pads; i++) { [EOL]             padding[i] = padChars[i % padLen]; [EOL]         } [EOL]         return new String(padding).concat(str); [EOL]     } [EOL] } 
 [LINE] for (int i = 0; i < pads; i++) { [LINE] public static String leftPad(final String str, final int size, String padStr) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (isEmpty(padStr)) { [EOL]         padStr = SPACE; [EOL]     } [EOL]     final int padLen = padStr.length(); [EOL]     final int strLen = str.length(); [EOL]     final int pads = size - strLen; [EOL]     if (pads <= 0) { [EOL]         return str; [EOL]     } [EOL]     if (padLen == 1 && pads <= PAD_LIMIT) { [EOL]         return leftPad(str, size, padStr.charAt(0)); [EOL]     } [EOL]     if (pads == padLen) { [EOL]         return padStr.concat(str); [EOL]     } else if (pads < padLen) { [EOL]         return padStr.substring(0, pads).concat(str); [EOL]     } else { [EOL]         final char[] padding = new char[pads]; [EOL]         final char[] padChars = padStr.toCharArray(); [EOL]         for (int i = 0; i < pads; i++) { [EOL]             padding[i] = padChars[i % padLen]; [EOL]         } [EOL]         return new String(padding).concat(str); [EOL]     } [EOL] } 
 [LINE] padding[i] = padChars[i % padLen]; [LINE] public static String leftPad(final String str, final int size, String padStr) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (isEmpty(padStr)) { [EOL]         padStr = SPACE; [EOL]     } [EOL]     final int padLen = padStr.length(); [EOL]     final int strLen = str.length(); [EOL]     final int pads = size - strLen; [EOL]     if (pads <= 0) { [EOL]         return str; [EOL]     } [EOL]     if (padLen == 1 && pads <= PAD_LIMIT) { [EOL]         return leftPad(str, size, padStr.charAt(0)); [EOL]     } [EOL]     if (pads == padLen) { [EOL]         return padStr.concat(str); [EOL]     } else if (pads < padLen) { [EOL]         return padStr.substring(0, pads).concat(str); [EOL]     } else { [EOL]         final char[] padding = new char[pads]; [EOL]         final char[] padChars = padStr.toCharArray(); [EOL]         for (int i = 0; i < pads; i++) { [EOL]             padding[i] = padChars[i % padLen]; [EOL]         } [EOL]         return new String(padding).concat(str); [EOL]     } [EOL] } 
 [LINE] return str; [LINE] public static String center(String str, final int size, final char padChar) { [EOL]     if (str == null || size <= 0) { [EOL]         return str; [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     final int pads = size - strLen; [EOL]     if (pads <= 0) { [EOL]         return str; [EOL]     } [EOL]     str = leftPad(str, strLen + pads / 2, padChar); [EOL]     str = rightPad(str, size, padChar); [EOL]     return str; [EOL] } 
 [LINE] if (pads <= 0) { [LINE] public static String center(String str, final int size, final char padChar) { [EOL]     if (str == null || size <= 0) { [EOL]         return str; [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     final int pads = size - strLen; [EOL]     if (pads <= 0) { [EOL]         return str; [EOL]     } [EOL]     str = leftPad(str, strLen + pads / 2, padChar); [EOL]     str = rightPad(str, size, padChar); [EOL]     return str; [EOL] } 
 [LINE] return str; [LINE] public static String center(String str, final int size, String padStr) { [EOL]     if (str == null || size <= 0) { [EOL]         return str; [EOL]     } [EOL]     if (isEmpty(padStr)) { [EOL]         padStr = SPACE; [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     final int pads = size - strLen; [EOL]     if (pads <= 0) { [EOL]         return str; [EOL]     } [EOL]     str = leftPad(str, strLen + pads / 2, padStr); [EOL]     str = rightPad(str, size, padStr); [EOL]     return str; [EOL] } 
 [LINE] return str; [LINE] public static String center(String str, final int size, String padStr) { [EOL]     if (str == null || size <= 0) { [EOL]         return str; [EOL]     } [EOL]     if (isEmpty(padStr)) { [EOL]         padStr = SPACE; [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     final int pads = size - strLen; [EOL]     if (pads <= 0) { [EOL]         return str; [EOL]     } [EOL]     str = leftPad(str, strLen + pads / 2, padStr); [EOL]     str = rightPad(str, size, padStr); [EOL]     return str; [EOL] } 
 [LINE] if (str == null) { [LINE] public static String upperCase(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     return str.toUpperCase(); [EOL] } 
 [LINE] return str.toUpperCase(); [LINE] public static String upperCase(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     return str.toUpperCase(); [EOL] } 
 [LINE] return null; [LINE] public static String upperCase(final String str, final Locale locale) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     return str.toUpperCase(locale); [EOL] } 
 [LINE] if (str == null) { [LINE] public static String lowerCase(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     return str.toLowerCase(); [EOL] } 
 [LINE] if (str == null) { [LINE] public static String lowerCase(final String str, final Locale locale) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     return str.toLowerCase(locale); [EOL] } 
 [LINE] return str.toLowerCase(locale); [LINE] public static String lowerCase(final String str, final Locale locale) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     return str.toLowerCase(locale); [EOL] } 
 [LINE] if (str == null || (strLen = str.length()) == 0) { [LINE] public static String uncapitalize(final String str) { [EOL]     int strLen; [EOL]     if (str == null || (strLen = str.length()) == 0) { [EOL]         return str; [EOL]     } [EOL]     char firstChar = str.charAt(0); [EOL]     if (Character.isLowerCase(firstChar)) { [EOL]         return str; [EOL]     } [EOL]     return new StringBuilder(strLen).append(Character.toLowerCase(firstChar)).append(str.substring(1)).toString(); [EOL] } 
 [LINE] if (StringUtils.isEmpty(str)) { [LINE] public static String swapCase(final String str) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return str; [EOL]     } [EOL]     final char[] buffer = str.toCharArray(); [EOL]     for (int i = 0; i < buffer.length; i++) { [EOL]         final char ch = buffer[i]; [EOL]         if (Character.isUpperCase(ch)) { [EOL]             buffer[i] = Character.toLowerCase(ch); [EOL]         } else if (Character.isTitleCase(ch)) { [EOL]             buffer[i] = Character.toLowerCase(ch); [EOL]         } else if (Character.isLowerCase(ch)) { [EOL]             buffer[i] = Character.toUpperCase(ch); [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] } 
 [LINE] if (Character.isUpperCase(ch)) { [LINE] public static String swapCase(final String str) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return str; [EOL]     } [EOL]     final char[] buffer = str.toCharArray(); [EOL]     for (int i = 0; i < buffer.length; i++) { [EOL]         final char ch = buffer[i]; [EOL]         if (Character.isUpperCase(ch)) { [EOL]             buffer[i] = Character.toLowerCase(ch); [EOL]         } else if (Character.isTitleCase(ch)) { [EOL]             buffer[i] = Character.toLowerCase(ch); [EOL]         } else if (Character.isLowerCase(ch)) { [EOL]             buffer[i] = Character.toUpperCase(ch); [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] } 
 [LINE] return new String(buffer); [LINE] public static String swapCase(final String str) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return str; [EOL]     } [EOL]     final char[] buffer = str.toCharArray(); [EOL]     for (int i = 0; i < buffer.length; i++) { [EOL]         final char ch = buffer[i]; [EOL]         if (Character.isUpperCase(ch)) { [EOL]             buffer[i] = Character.toLowerCase(ch); [EOL]         } else if (Character.isTitleCase(ch)) { [EOL]             buffer[i] = Character.toLowerCase(ch); [EOL]         } else if (Character.isLowerCase(ch)) { [EOL]             buffer[i] = Character.toUpperCase(ch); [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] } 
 [LINE] int count = 0; [LINE] public static int countMatches(final CharSequence str, final CharSequence sub) { [EOL]     if (isEmpty(str) || isEmpty(sub)) { [EOL]         return 0; [EOL]     } [EOL]     int count = 0; [EOL]     int idx = 0; [EOL]     while ((idx = CharSequenceUtils.indexOf(str, sub, idx)) != INDEX_NOT_FOUND) { [EOL]         count++; [EOL]         idx += sub.length(); [EOL]     } [EOL]     return count; [EOL] } 
 [LINE] if (cs == null || cs.length() == 0) { [LINE] public static boolean isAlpha(final CharSequence cs) { [EOL]     if (cs == null || cs.length() == 0) { [EOL]         return false; [EOL]     } [EOL]     final int sz = cs.length(); [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (Character.isLetter(cs.charAt(i)) == false) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] for (int i = 0; i < sz; i++) { [LINE] public static boolean isAlphaSpace(final CharSequence cs) { [EOL]     if (cs == null) { [EOL]         return false; [EOL]     } [EOL]     final int sz = cs.length(); [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (Character.isLetter(cs.charAt(i)) == false && cs.charAt(i) != ' ') { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] return false; [LINE] public static boolean isAlphanumericSpace(final CharSequence cs) { [EOL]     if (cs == null) { [EOL]         return false; [EOL]     } [EOL]     final int sz = cs.length(); [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (Character.isLetterOrDigit(cs.charAt(i)) == false && cs.charAt(i) != ' ') { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] if (Character.isLetterOrDigit(cs.charAt(i)) == false && cs.charAt(i) != ' ') { [LINE] public static boolean isAlphanumericSpace(final CharSequence cs) { [EOL]     if (cs == null) { [EOL]         return false; [EOL]     } [EOL]     final int sz = cs.length(); [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (Character.isLetterOrDigit(cs.charAt(i)) == false && cs.charAt(i) != ' ') { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] return true; [LINE] public static boolean isAlphanumericSpace(final CharSequence cs) { [EOL]     if (cs == null) { [EOL]         return false; [EOL]     } [EOL]     final int sz = cs.length(); [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (Character.isLetterOrDigit(cs.charAt(i)) == false && cs.charAt(i) != ' ') { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] return false; [LINE] public static boolean isAsciiPrintable(final CharSequence cs) { [EOL]     if (cs == null) { [EOL]         return false; [EOL]     } [EOL]     final int sz = cs.length(); [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (CharUtils.isAsciiPrintable(cs.charAt(i)) == false) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] if (Character.isDigit(cs.charAt(i)) == false && cs.charAt(i) != ' ') { [LINE] public static boolean isNumericSpace(final CharSequence cs) { [EOL]     if (cs == null) { [EOL]         return false; [EOL]     } [EOL]     final int sz = cs.length(); [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (Character.isDigit(cs.charAt(i)) == false && cs.charAt(i) != ' ') { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] if (cs == null) { [LINE] public static boolean isWhitespace(final CharSequence cs) { [EOL]     if (cs == null) { [EOL]         return false; [EOL]     } [EOL]     final int sz = cs.length(); [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (Character.isWhitespace(cs.charAt(i)) == false) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] if (Character.isWhitespace(cs.charAt(i)) == false) { [LINE] public static boolean isWhitespace(final CharSequence cs) { [EOL]     if (cs == null) { [EOL]         return false; [EOL]     } [EOL]     final int sz = cs.length(); [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (Character.isWhitespace(cs.charAt(i)) == false) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] if (Character.isLowerCase(cs.charAt(i)) == false) { [LINE] public static boolean isAllLowerCase(final CharSequence cs) { [EOL]     if (cs == null || isEmpty(cs)) { [EOL]         return false; [EOL]     } [EOL]     final int sz = cs.length(); [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (Character.isLowerCase(cs.charAt(i)) == false) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] if (Character.isUpperCase(cs.charAt(i)) == false) { [LINE] public static boolean isAllUpperCase(final CharSequence cs) { [EOL]     if (cs == null || isEmpty(cs)) { [EOL]         return false; [EOL]     } [EOL]     final int sz = cs.length(); [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (Character.isUpperCase(cs.charAt(i)) == false) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] return new StringBuilder(str).reverse().toString(); [LINE] public static String reverse(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     return new StringBuilder(str).reverse().toString(); [EOL] } 
 [LINE] return null; [LINE] public static String reverseDelimited(final String str, final char separatorChar) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final String[] strs = split(str, separatorChar); [EOL]     ArrayUtils.reverse(strs); [EOL]     return join(strs, separatorChar); [EOL] } 
 [LINE] if (str == null) { [LINE] public static String abbreviate(final String str, int offset, final int maxWidth) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (maxWidth < 4) { [EOL]         throw new IllegalArgumentException("Minimum abbreviation width is 4"); [EOL]     } [EOL]     if (str.length() <= maxWidth) { [EOL]         return str; [EOL]     } [EOL]     if (offset > str.length()) { [EOL]         offset = str.length(); [EOL]     } [EOL]     if (str.length() - offset < maxWidth - 3) { [EOL]         offset = str.length() - (maxWidth - 3); [EOL]     } [EOL]     final String abrevMarker = "..."; [EOL]     if (offset <= 4) { [EOL]         return str.substring(0, maxWidth - 3) + abrevMarker; [EOL]     } [EOL]     if (maxWidth < 7) { [EOL]         throw new IllegalArgumentException("Minimum abbreviation width with offset is 7"); [EOL]     } [EOL]     if (offset + maxWidth - 3 < str.length()) { [EOL]         return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3); [EOL]     } [EOL]     return abrevMarker + str.substring(str.length() - (maxWidth - 3)); [EOL] } 
 [LINE] return null; [LINE] public static String abbreviate(final String str, int offset, final int maxWidth) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (maxWidth < 4) { [EOL]         throw new IllegalArgumentException("Minimum abbreviation width is 4"); [EOL]     } [EOL]     if (str.length() <= maxWidth) { [EOL]         return str; [EOL]     } [EOL]     if (offset > str.length()) { [EOL]         offset = str.length(); [EOL]     } [EOL]     if (str.length() - offset < maxWidth - 3) { [EOL]         offset = str.length() - (maxWidth - 3); [EOL]     } [EOL]     final String abrevMarker = "..."; [EOL]     if (offset <= 4) { [EOL]         return str.substring(0, maxWidth - 3) + abrevMarker; [EOL]     } [EOL]     if (maxWidth < 7) { [EOL]         throw new IllegalArgumentException("Minimum abbreviation width with offset is 7"); [EOL]     } [EOL]     if (offset + maxWidth - 3 < str.length()) { [EOL]         return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3); [EOL]     } [EOL]     return abrevMarker + str.substring(str.length() - (maxWidth - 3)); [EOL] } 
 [LINE] if (maxWidth < 4) { [LINE] public static String abbreviate(final String str, int offset, final int maxWidth) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (maxWidth < 4) { [EOL]         throw new IllegalArgumentException("Minimum abbreviation width is 4"); [EOL]     } [EOL]     if (str.length() <= maxWidth) { [EOL]         return str; [EOL]     } [EOL]     if (offset > str.length()) { [EOL]         offset = str.length(); [EOL]     } [EOL]     if (str.length() - offset < maxWidth - 3) { [EOL]         offset = str.length() - (maxWidth - 3); [EOL]     } [EOL]     final String abrevMarker = "..."; [EOL]     if (offset <= 4) { [EOL]         return str.substring(0, maxWidth - 3) + abrevMarker; [EOL]     } [EOL]     if (maxWidth < 7) { [EOL]         throw new IllegalArgumentException("Minimum abbreviation width with offset is 7"); [EOL]     } [EOL]     if (offset + maxWidth - 3 < str.length()) { [EOL]         return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3); [EOL]     } [EOL]     return abrevMarker + str.substring(str.length() - (maxWidth - 3)); [EOL] } 
 [LINE] throw new IllegalArgumentException("Minimum abbreviation width is 4"); [LINE] public static String abbreviate(final String str, int offset, final int maxWidth) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (maxWidth < 4) { [EOL]         throw new IllegalArgumentException("Minimum abbreviation width is 4"); [EOL]     } [EOL]     if (str.length() <= maxWidth) { [EOL]         return str; [EOL]     } [EOL]     if (offset > str.length()) { [EOL]         offset = str.length(); [EOL]     } [EOL]     if (str.length() - offset < maxWidth - 3) { [EOL]         offset = str.length() - (maxWidth - 3); [EOL]     } [EOL]     final String abrevMarker = "..."; [EOL]     if (offset <= 4) { [EOL]         return str.substring(0, maxWidth - 3) + abrevMarker; [EOL]     } [EOL]     if (maxWidth < 7) { [EOL]         throw new IllegalArgumentException("Minimum abbreviation width with offset is 7"); [EOL]     } [EOL]     if (offset + maxWidth - 3 < str.length()) { [EOL]         return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3); [EOL]     } [EOL]     return abrevMarker + str.substring(str.length() - (maxWidth - 3)); [EOL] } 
 [LINE] if (offset > str.length()) { [LINE] public static String abbreviate(final String str, int offset, final int maxWidth) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (maxWidth < 4) { [EOL]         throw new IllegalArgumentException("Minimum abbreviation width is 4"); [EOL]     } [EOL]     if (str.length() <= maxWidth) { [EOL]         return str; [EOL]     } [EOL]     if (offset > str.length()) { [EOL]         offset = str.length(); [EOL]     } [EOL]     if (str.length() - offset < maxWidth - 3) { [EOL]         offset = str.length() - (maxWidth - 3); [EOL]     } [EOL]     final String abrevMarker = "..."; [EOL]     if (offset <= 4) { [EOL]         return str.substring(0, maxWidth - 3) + abrevMarker; [EOL]     } [EOL]     if (maxWidth < 7) { [EOL]         throw new IllegalArgumentException("Minimum abbreviation width with offset is 7"); [EOL]     } [EOL]     if (offset + maxWidth - 3 < str.length()) { [EOL]         return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3); [EOL]     } [EOL]     return abrevMarker + str.substring(str.length() - (maxWidth - 3)); [EOL] } 
 [LINE] offset = str.length(); [LINE] public static String abbreviate(final String str, int offset, final int maxWidth) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (maxWidth < 4) { [EOL]         throw new IllegalArgumentException("Minimum abbreviation width is 4"); [EOL]     } [EOL]     if (str.length() <= maxWidth) { [EOL]         return str; [EOL]     } [EOL]     if (offset > str.length()) { [EOL]         offset = str.length(); [EOL]     } [EOL]     if (str.length() - offset < maxWidth - 3) { [EOL]         offset = str.length() - (maxWidth - 3); [EOL]     } [EOL]     final String abrevMarker = "..."; [EOL]     if (offset <= 4) { [EOL]         return str.substring(0, maxWidth - 3) + abrevMarker; [EOL]     } [EOL]     if (maxWidth < 7) { [EOL]         throw new IllegalArgumentException("Minimum abbreviation width with offset is 7"); [EOL]     } [EOL]     if (offset + maxWidth - 3 < str.length()) { [EOL]         return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3); [EOL]     } [EOL]     return abrevMarker + str.substring(str.length() - (maxWidth - 3)); [EOL] } 
 [LINE] final String abrevMarker = "..."; [LINE] public static String abbreviate(final String str, int offset, final int maxWidth) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (maxWidth < 4) { [EOL]         throw new IllegalArgumentException("Minimum abbreviation width is 4"); [EOL]     } [EOL]     if (str.length() <= maxWidth) { [EOL]         return str; [EOL]     } [EOL]     if (offset > str.length()) { [EOL]         offset = str.length(); [EOL]     } [EOL]     if (str.length() - offset < maxWidth - 3) { [EOL]         offset = str.length() - (maxWidth - 3); [EOL]     } [EOL]     final String abrevMarker = "..."; [EOL]     if (offset <= 4) { [EOL]         return str.substring(0, maxWidth - 3) + abrevMarker; [EOL]     } [EOL]     if (maxWidth < 7) { [EOL]         throw new IllegalArgumentException("Minimum abbreviation width with offset is 7"); [EOL]     } [EOL]     if (offset + maxWidth - 3 < str.length()) { [EOL]         return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3); [EOL]     } [EOL]     return abrevMarker + str.substring(str.length() - (maxWidth - 3)); [EOL] } 
 [LINE] if (maxWidth < 7) { [LINE] public static String abbreviate(final String str, int offset, final int maxWidth) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (maxWidth < 4) { [EOL]         throw new IllegalArgumentException("Minimum abbreviation width is 4"); [EOL]     } [EOL]     if (str.length() <= maxWidth) { [EOL]         return str; [EOL]     } [EOL]     if (offset > str.length()) { [EOL]         offset = str.length(); [EOL]     } [EOL]     if (str.length() - offset < maxWidth - 3) { [EOL]         offset = str.length() - (maxWidth - 3); [EOL]     } [EOL]     final String abrevMarker = "..."; [EOL]     if (offset <= 4) { [EOL]         return str.substring(0, maxWidth - 3) + abrevMarker; [EOL]     } [EOL]     if (maxWidth < 7) { [EOL]         throw new IllegalArgumentException("Minimum abbreviation width with offset is 7"); [EOL]     } [EOL]     if (offset + maxWidth - 3 < str.length()) { [EOL]         return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3); [EOL]     } [EOL]     return abrevMarker + str.substring(str.length() - (maxWidth - 3)); [EOL] } 
 [LINE] if (cs1 == cs2) { [LINE] public static int indexOfDifference(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return 0; [EOL]     } [EOL]     int i; [EOL]     for (i = 0; i < cs1.length() && i < cs2.length(); ++i) { [EOL]         if (cs1.charAt(i) != cs2.charAt(i)) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (i < cs2.length() || i < cs1.length()) { [EOL]         return i; [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] } 
 [LINE] for (i = 0; i < cs1.length() && i < cs2.length(); ++i) { [LINE] public static int indexOfDifference(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return 0; [EOL]     } [EOL]     int i; [EOL]     for (i = 0; i < cs1.length() && i < cs2.length(); ++i) { [EOL]         if (cs1.charAt(i) != cs2.charAt(i)) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (i < cs2.length() || i < cs1.length()) { [EOL]         return i; [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] } 
 [LINE] boolean anyStringNull = false; [LINE] public static int indexOfDifference(final CharSequence... css) { [EOL]     if (css == null || css.length <= 1) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     boolean anyStringNull = false; [EOL]     boolean allStringsNull = true; [EOL]     final int arrayLen = css.length; [EOL]     int shortestStrLen = Integer.MAX_VALUE; [EOL]     int longestStrLen = 0; [EOL]     for (int i = 0; i < arrayLen; i++) { [EOL]         if (css[i] == null) { [EOL]             anyStringNull = true; [EOL]             shortestStrLen = 0; [EOL]         } else { [EOL]             allStringsNull = false; [EOL]             shortestStrLen = Math.min(css[i].length(), shortestStrLen); [EOL]             longestStrLen = Math.max(css[i].length(), longestStrLen); [EOL]         } [EOL]     } [EOL]     if (allStringsNull || longestStrLen == 0 && !anyStringNull) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (shortestStrLen == 0) { [EOL]         return 0; [EOL]     } [EOL]     int firstDiff = -1; [EOL]     for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) { [EOL]         final char comparisonChar = css[0].charAt(stringPos); [EOL]         for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) { [EOL]             if (css[arrayPos].charAt(stringPos) != comparisonChar) { [EOL]                 firstDiff = stringPos; [EOL]                 break; [EOL]             } [EOL]         } [EOL]         if (firstDiff != -1) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (firstDiff == -1 && shortestStrLen != longestStrLen) { [EOL]         return shortestStrLen; [EOL]     } [EOL]     return firstDiff; [EOL] } 
 [LINE] longestStrLen = Math.max(css[i].length(), longestStrLen); [LINE] public static int indexOfDifference(final CharSequence... css) { [EOL]     if (css == null || css.length <= 1) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     boolean anyStringNull = false; [EOL]     boolean allStringsNull = true; [EOL]     final int arrayLen = css.length; [EOL]     int shortestStrLen = Integer.MAX_VALUE; [EOL]     int longestStrLen = 0; [EOL]     for (int i = 0; i < arrayLen; i++) { [EOL]         if (css[i] == null) { [EOL]             anyStringNull = true; [EOL]             shortestStrLen = 0; [EOL]         } else { [EOL]             allStringsNull = false; [EOL]             shortestStrLen = Math.min(css[i].length(), shortestStrLen); [EOL]             longestStrLen = Math.max(css[i].length(), longestStrLen); [EOL]         } [EOL]     } [EOL]     if (allStringsNull || longestStrLen == 0 && !anyStringNull) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (shortestStrLen == 0) { [EOL]         return 0; [EOL]     } [EOL]     int firstDiff = -1; [EOL]     for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) { [EOL]         final char comparisonChar = css[0].charAt(stringPos); [EOL]         for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) { [EOL]             if (css[arrayPos].charAt(stringPos) != comparisonChar) { [EOL]                 firstDiff = stringPos; [EOL]                 break; [EOL]             } [EOL]         } [EOL]         if (firstDiff != -1) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (firstDiff == -1 && shortestStrLen != longestStrLen) { [EOL]         return shortestStrLen; [EOL]     } [EOL]     return firstDiff; [EOL] } 
 [LINE] return 0; [LINE] public static int indexOfDifference(final CharSequence... css) { [EOL]     if (css == null || css.length <= 1) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     boolean anyStringNull = false; [EOL]     boolean allStringsNull = true; [EOL]     final int arrayLen = css.length; [EOL]     int shortestStrLen = Integer.MAX_VALUE; [EOL]     int longestStrLen = 0; [EOL]     for (int i = 0; i < arrayLen; i++) { [EOL]         if (css[i] == null) { [EOL]             anyStringNull = true; [EOL]             shortestStrLen = 0; [EOL]         } else { [EOL]             allStringsNull = false; [EOL]             shortestStrLen = Math.min(css[i].length(), shortestStrLen); [EOL]             longestStrLen = Math.max(css[i].length(), longestStrLen); [EOL]         } [EOL]     } [EOL]     if (allStringsNull || longestStrLen == 0 && !anyStringNull) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (shortestStrLen == 0) { [EOL]         return 0; [EOL]     } [EOL]     int firstDiff = -1; [EOL]     for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) { [EOL]         final char comparisonChar = css[0].charAt(stringPos); [EOL]         for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) { [EOL]             if (css[arrayPos].charAt(stringPos) != comparisonChar) { [EOL]                 firstDiff = stringPos; [EOL]                 break; [EOL]             } [EOL]         } [EOL]         if (firstDiff != -1) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (firstDiff == -1 && shortestStrLen != longestStrLen) { [EOL]         return shortestStrLen; [EOL]     } [EOL]     return firstDiff; [EOL] } 
 [LINE] for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) { [LINE] public static int indexOfDifference(final CharSequence... css) { [EOL]     if (css == null || css.length <= 1) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     boolean anyStringNull = false; [EOL]     boolean allStringsNull = true; [EOL]     final int arrayLen = css.length; [EOL]     int shortestStrLen = Integer.MAX_VALUE; [EOL]     int longestStrLen = 0; [EOL]     for (int i = 0; i < arrayLen; i++) { [EOL]         if (css[i] == null) { [EOL]             anyStringNull = true; [EOL]             shortestStrLen = 0; [EOL]         } else { [EOL]             allStringsNull = false; [EOL]             shortestStrLen = Math.min(css[i].length(), shortestStrLen); [EOL]             longestStrLen = Math.max(css[i].length(), longestStrLen); [EOL]         } [EOL]     } [EOL]     if (allStringsNull || longestStrLen == 0 && !anyStringNull) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (shortestStrLen == 0) { [EOL]         return 0; [EOL]     } [EOL]     int firstDiff = -1; [EOL]     for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) { [EOL]         final char comparisonChar = css[0].charAt(stringPos); [EOL]         for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) { [EOL]             if (css[arrayPos].charAt(stringPos) != comparisonChar) { [EOL]                 firstDiff = stringPos; [EOL]                 break; [EOL]             } [EOL]         } [EOL]         if (firstDiff != -1) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (firstDiff == -1 && shortestStrLen != longestStrLen) { [EOL]         return shortestStrLen; [EOL]     } [EOL]     return firstDiff; [EOL] } 
 [LINE] firstDiff = stringPos; [LINE] public static int indexOfDifference(final CharSequence... css) { [EOL]     if (css == null || css.length <= 1) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     boolean anyStringNull = false; [EOL]     boolean allStringsNull = true; [EOL]     final int arrayLen = css.length; [EOL]     int shortestStrLen = Integer.MAX_VALUE; [EOL]     int longestStrLen = 0; [EOL]     for (int i = 0; i < arrayLen; i++) { [EOL]         if (css[i] == null) { [EOL]             anyStringNull = true; [EOL]             shortestStrLen = 0; [EOL]         } else { [EOL]             allStringsNull = false; [EOL]             shortestStrLen = Math.min(css[i].length(), shortestStrLen); [EOL]             longestStrLen = Math.max(css[i].length(), longestStrLen); [EOL]         } [EOL]     } [EOL]     if (allStringsNull || longestStrLen == 0 && !anyStringNull) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (shortestStrLen == 0) { [EOL]         return 0; [EOL]     } [EOL]     int firstDiff = -1; [EOL]     for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) { [EOL]         final char comparisonChar = css[0].charAt(stringPos); [EOL]         for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) { [EOL]             if (css[arrayPos].charAt(stringPos) != comparisonChar) { [EOL]                 firstDiff = stringPos; [EOL]                 break; [EOL]             } [EOL]         } [EOL]         if (firstDiff != -1) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (firstDiff == -1 && shortestStrLen != longestStrLen) { [EOL]         return shortestStrLen; [EOL]     } [EOL]     return firstDiff; [EOL] } 
 [LINE] if (firstDiff != -1) { [LINE] public static int indexOfDifference(final CharSequence... css) { [EOL]     if (css == null || css.length <= 1) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     boolean anyStringNull = false; [EOL]     boolean allStringsNull = true; [EOL]     final int arrayLen = css.length; [EOL]     int shortestStrLen = Integer.MAX_VALUE; [EOL]     int longestStrLen = 0; [EOL]     for (int i = 0; i < arrayLen; i++) { [EOL]         if (css[i] == null) { [EOL]             anyStringNull = true; [EOL]             shortestStrLen = 0; [EOL]         } else { [EOL]             allStringsNull = false; [EOL]             shortestStrLen = Math.min(css[i].length(), shortestStrLen); [EOL]             longestStrLen = Math.max(css[i].length(), longestStrLen); [EOL]         } [EOL]     } [EOL]     if (allStringsNull || longestStrLen == 0 && !anyStringNull) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (shortestStrLen == 0) { [EOL]         return 0; [EOL]     } [EOL]     int firstDiff = -1; [EOL]     for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) { [EOL]         final char comparisonChar = css[0].charAt(stringPos); [EOL]         for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) { [EOL]             if (css[arrayPos].charAt(stringPos) != comparisonChar) { [EOL]                 firstDiff = stringPos; [EOL]                 break; [EOL]             } [EOL]         } [EOL]         if (firstDiff != -1) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (firstDiff == -1 && shortestStrLen != longestStrLen) { [EOL]         return shortestStrLen; [EOL]     } [EOL]     return firstDiff; [EOL] } 
 [LINE] return shortestStrLen; [LINE] public static int indexOfDifference(final CharSequence... css) { [EOL]     if (css == null || css.length <= 1) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     boolean anyStringNull = false; [EOL]     boolean allStringsNull = true; [EOL]     final int arrayLen = css.length; [EOL]     int shortestStrLen = Integer.MAX_VALUE; [EOL]     int longestStrLen = 0; [EOL]     for (int i = 0; i < arrayLen; i++) { [EOL]         if (css[i] == null) { [EOL]             anyStringNull = true; [EOL]             shortestStrLen = 0; [EOL]         } else { [EOL]             allStringsNull = false; [EOL]             shortestStrLen = Math.min(css[i].length(), shortestStrLen); [EOL]             longestStrLen = Math.max(css[i].length(), longestStrLen); [EOL]         } [EOL]     } [EOL]     if (allStringsNull || longestStrLen == 0 && !anyStringNull) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (shortestStrLen == 0) { [EOL]         return 0; [EOL]     } [EOL]     int firstDiff = -1; [EOL]     for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) { [EOL]         final char comparisonChar = css[0].charAt(stringPos); [EOL]         for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) { [EOL]             if (css[arrayPos].charAt(stringPos) != comparisonChar) { [EOL]                 firstDiff = stringPos; [EOL]                 break; [EOL]             } [EOL]         } [EOL]         if (firstDiff != -1) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (firstDiff == -1 && shortestStrLen != longestStrLen) { [EOL]         return shortestStrLen; [EOL]     } [EOL]     return firstDiff; [EOL] } 
 [LINE] if (strs == null || strs.length == 0) { [LINE] public static String getCommonPrefix(final String... strs) { [EOL]     if (strs == null || strs.length == 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final int smallestIndexOfDiff = indexOfDifference(strs); [EOL]     if (smallestIndexOfDiff == INDEX_NOT_FOUND) { [EOL]         if (strs[0] == null) { [EOL]             return EMPTY; [EOL]         } [EOL]         return strs[0]; [EOL]     } else if (smallestIndexOfDiff == 0) { [EOL]         return EMPTY; [EOL]     } else { [EOL]         return strs[0].substring(0, smallestIndexOfDiff); [EOL]     } [EOL] } 
 [LINE] return EMPTY; [LINE] public static String getCommonPrefix(final String... strs) { [EOL]     if (strs == null || strs.length == 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final int smallestIndexOfDiff = indexOfDifference(strs); [EOL]     if (smallestIndexOfDiff == INDEX_NOT_FOUND) { [EOL]         if (strs[0] == null) { [EOL]             return EMPTY; [EOL]         } [EOL]         return strs[0]; [EOL]     } else if (smallestIndexOfDiff == 0) { [EOL]         return EMPTY; [EOL]     } else { [EOL]         return strs[0].substring(0, smallestIndexOfDiff); [EOL]     } [EOL] } 
 [LINE] final int smallestIndexOfDiff = indexOfDifference(strs); [LINE] public static String getCommonPrefix(final String... strs) { [EOL]     if (strs == null || strs.length == 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final int smallestIndexOfDiff = indexOfDifference(strs); [EOL]     if (smallestIndexOfDiff == INDEX_NOT_FOUND) { [EOL]         if (strs[0] == null) { [EOL]             return EMPTY; [EOL]         } [EOL]         return strs[0]; [EOL]     } else if (smallestIndexOfDiff == 0) { [EOL]         return EMPTY; [EOL]     } else { [EOL]         return strs[0].substring(0, smallestIndexOfDiff); [EOL]     } [EOL] } 
 [LINE] if (smallestIndexOfDiff == INDEX_NOT_FOUND) { [LINE] public static String getCommonPrefix(final String... strs) { [EOL]     if (strs == null || strs.length == 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final int smallestIndexOfDiff = indexOfDifference(strs); [EOL]     if (smallestIndexOfDiff == INDEX_NOT_FOUND) { [EOL]         if (strs[0] == null) { [EOL]             return EMPTY; [EOL]         } [EOL]         return strs[0]; [EOL]     } else if (smallestIndexOfDiff == 0) { [EOL]         return EMPTY; [EOL]     } else { [EOL]         return strs[0].substring(0, smallestIndexOfDiff); [EOL]     } [EOL] } 
 [LINE] if (strs[0] == null) { [LINE] public static String getCommonPrefix(final String... strs) { [EOL]     if (strs == null || strs.length == 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final int smallestIndexOfDiff = indexOfDifference(strs); [EOL]     if (smallestIndexOfDiff == INDEX_NOT_FOUND) { [EOL]         if (strs[0] == null) { [EOL]             return EMPTY; [EOL]         } [EOL]         return strs[0]; [EOL]     } else if (smallestIndexOfDiff == 0) { [EOL]         return EMPTY; [EOL]     } else { [EOL]         return strs[0].substring(0, smallestIndexOfDiff); [EOL]     } [EOL] } 
 [LINE] throw new IllegalArgumentException("Strings must not be null"); [LINE] public static int getLevenshteinDistance(CharSequence s, CharSequence t) { [EOL]     if (s == null || t == null) { [EOL]         throw new IllegalArgumentException("Strings must not be null"); [EOL]     } [EOL]     int n = s.length(); [EOL]     int m = t.length(); [EOL]     if (n == 0) { [EOL]         return m; [EOL]     } else if (m == 0) { [EOL]         return n; [EOL]     } [EOL]     if (n > m) { [EOL]         final CharSequence tmp = s; [EOL]         s = t; [EOL]         t = tmp; [EOL]         n = m; [EOL]         m = t.length(); [EOL]     } [EOL]     int[] p = new int[n + 1]; [EOL]     int[] d = new int[n + 1]; [EOL]     int[] _d; [EOL]     int i; [EOL]     int j; [EOL]     char t_j; [EOL]     int cost; [EOL]     for (i = 0; i <= n; i++) { [EOL]         p[i] = i; [EOL]     } [EOL]     for (j = 1; j <= m; j++) { [EOL]         t_j = t.charAt(j - 1); [EOL]         d[0] = j; [EOL]         for (i = 1; i <= n; i++) { [EOL]             cost = s.charAt(i - 1) == t_j ? 0 : 1; [EOL]             d[i] = Math.min(Math.min(d[i - 1] + 1, p[i] + 1), p[i - 1] + cost); [EOL]         } [EOL]         _d = p; [EOL]         p = d; [EOL]         d = _d; [EOL]     } [EOL]     return p[n]; [EOL] } 
 [LINE] if (n == 0) { [LINE] public static int getLevenshteinDistance(CharSequence s, CharSequence t) { [EOL]     if (s == null || t == null) { [EOL]         throw new IllegalArgumentException("Strings must not be null"); [EOL]     } [EOL]     int n = s.length(); [EOL]     int m = t.length(); [EOL]     if (n == 0) { [EOL]         return m; [EOL]     } else if (m == 0) { [EOL]         return n; [EOL]     } [EOL]     if (n > m) { [EOL]         final CharSequence tmp = s; [EOL]         s = t; [EOL]         t = tmp; [EOL]         n = m; [EOL]         m = t.length(); [EOL]     } [EOL]     int[] p = new int[n + 1]; [EOL]     int[] d = new int[n + 1]; [EOL]     int[] _d; [EOL]     int i; [EOL]     int j; [EOL]     char t_j; [EOL]     int cost; [EOL]     for (i = 0; i <= n; i++) { [EOL]         p[i] = i; [EOL]     } [EOL]     for (j = 1; j <= m; j++) { [EOL]         t_j = t.charAt(j - 1); [EOL]         d[0] = j; [EOL]         for (i = 1; i <= n; i++) { [EOL]             cost = s.charAt(i - 1) == t_j ? 0 : 1; [EOL]             d[i] = Math.min(Math.min(d[i - 1] + 1, p[i] + 1), p[i - 1] + cost); [EOL]         } [EOL]         _d = p; [EOL]         p = d; [EOL]         d = _d; [EOL]     } [EOL]     return p[n]; [EOL] } 
 [LINE] s = t; [LINE] public static int getLevenshteinDistance(CharSequence s, CharSequence t) { [EOL]     if (s == null || t == null) { [EOL]         throw new IllegalArgumentException("Strings must not be null"); [EOL]     } [EOL]     int n = s.length(); [EOL]     int m = t.length(); [EOL]     if (n == 0) { [EOL]         return m; [EOL]     } else if (m == 0) { [EOL]         return n; [EOL]     } [EOL]     if (n > m) { [EOL]         final CharSequence tmp = s; [EOL]         s = t; [EOL]         t = tmp; [EOL]         n = m; [EOL]         m = t.length(); [EOL]     } [EOL]     int[] p = new int[n + 1]; [EOL]     int[] d = new int[n + 1]; [EOL]     int[] _d; [EOL]     int i; [EOL]     int j; [EOL]     char t_j; [EOL]     int cost; [EOL]     for (i = 0; i <= n; i++) { [EOL]         p[i] = i; [EOL]     } [EOL]     for (j = 1; j <= m; j++) { [EOL]         t_j = t.charAt(j - 1); [EOL]         d[0] = j; [EOL]         for (i = 1; i <= n; i++) { [EOL]             cost = s.charAt(i - 1) == t_j ? 0 : 1; [EOL]             d[i] = Math.min(Math.min(d[i - 1] + 1, p[i] + 1), p[i - 1] + cost); [EOL]         } [EOL]         _d = p; [EOL]         p = d; [EOL]         d = _d; [EOL]     } [EOL]     return p[n]; [EOL] } 
 [LINE] for (i = 0; i <= n; i++) { [LINE] public static int getLevenshteinDistance(CharSequence s, CharSequence t) { [EOL]     if (s == null || t == null) { [EOL]         throw new IllegalArgumentException("Strings must not be null"); [EOL]     } [EOL]     int n = s.length(); [EOL]     int m = t.length(); [EOL]     if (n == 0) { [EOL]         return m; [EOL]     } else if (m == 0) { [EOL]         return n; [EOL]     } [EOL]     if (n > m) { [EOL]         final CharSequence tmp = s; [EOL]         s = t; [EOL]         t = tmp; [EOL]         n = m; [EOL]         m = t.length(); [EOL]     } [EOL]     int[] p = new int[n + 1]; [EOL]     int[] d = new int[n + 1]; [EOL]     int[] _d; [EOL]     int i; [EOL]     int j; [EOL]     char t_j; [EOL]     int cost; [EOL]     for (i = 0; i <= n; i++) { [EOL]         p[i] = i; [EOL]     } [EOL]     for (j = 1; j <= m; j++) { [EOL]         t_j = t.charAt(j - 1); [EOL]         d[0] = j; [EOL]         for (i = 1; i <= n; i++) { [EOL]             cost = s.charAt(i - 1) == t_j ? 0 : 1; [EOL]             d[i] = Math.min(Math.min(d[i - 1] + 1, p[i] + 1), p[i - 1] + cost); [EOL]         } [EOL]         _d = p; [EOL]         p = d; [EOL]         d = _d; [EOL]     } [EOL]     return p[n]; [EOL] } 
 [LINE] p[i] = i; [LINE] public static int getLevenshteinDistance(CharSequence s, CharSequence t) { [EOL]     if (s == null || t == null) { [EOL]         throw new IllegalArgumentException("Strings must not be null"); [EOL]     } [EOL]     int n = s.length(); [EOL]     int m = t.length(); [EOL]     if (n == 0) { [EOL]         return m; [EOL]     } else if (m == 0) { [EOL]         return n; [EOL]     } [EOL]     if (n > m) { [EOL]         final CharSequence tmp = s; [EOL]         s = t; [EOL]         t = tmp; [EOL]         n = m; [EOL]         m = t.length(); [EOL]     } [EOL]     int[] p = new int[n + 1]; [EOL]     int[] d = new int[n + 1]; [EOL]     int[] _d; [EOL]     int i; [EOL]     int j; [EOL]     char t_j; [EOL]     int cost; [EOL]     for (i = 0; i <= n; i++) { [EOL]         p[i] = i; [EOL]     } [EOL]     for (j = 1; j <= m; j++) { [EOL]         t_j = t.charAt(j - 1); [EOL]         d[0] = j; [EOL]         for (i = 1; i <= n; i++) { [EOL]             cost = s.charAt(i - 1) == t_j ? 0 : 1; [EOL]             d[i] = Math.min(Math.min(d[i - 1] + 1, p[i] + 1), p[i - 1] + cost); [EOL]         } [EOL]         _d = p; [EOL]         p = d; [EOL]         d = _d; [EOL]     } [EOL]     return p[n]; [EOL] } 
 [LINE] t_j = t.charAt(j - 1); [LINE] public static int getLevenshteinDistance(CharSequence s, CharSequence t) { [EOL]     if (s == null || t == null) { [EOL]         throw new IllegalArgumentException("Strings must not be null"); [EOL]     } [EOL]     int n = s.length(); [EOL]     int m = t.length(); [EOL]     if (n == 0) { [EOL]         return m; [EOL]     } else if (m == 0) { [EOL]         return n; [EOL]     } [EOL]     if (n > m) { [EOL]         final CharSequence tmp = s; [EOL]         s = t; [EOL]         t = tmp; [EOL]         n = m; [EOL]         m = t.length(); [EOL]     } [EOL]     int[] p = new int[n + 1]; [EOL]     int[] d = new int[n + 1]; [EOL]     int[] _d; [EOL]     int i; [EOL]     int j; [EOL]     char t_j; [EOL]     int cost; [EOL]     for (i = 0; i <= n; i++) { [EOL]         p[i] = i; [EOL]     } [EOL]     for (j = 1; j <= m; j++) { [EOL]         t_j = t.charAt(j - 1); [EOL]         d[0] = j; [EOL]         for (i = 1; i <= n; i++) { [EOL]             cost = s.charAt(i - 1) == t_j ? 0 : 1; [EOL]             d[i] = Math.min(Math.min(d[i - 1] + 1, p[i] + 1), p[i - 1] + cost); [EOL]         } [EOL]         _d = p; [EOL]         p = d; [EOL]         d = _d; [EOL]     } [EOL]     return p[n]; [EOL] } 
 [LINE] d[0] = j; [LINE] public static int getLevenshteinDistance(CharSequence s, CharSequence t) { [EOL]     if (s == null || t == null) { [EOL]         throw new IllegalArgumentException("Strings must not be null"); [EOL]     } [EOL]     int n = s.length(); [EOL]     int m = t.length(); [EOL]     if (n == 0) { [EOL]         return m; [EOL]     } else if (m == 0) { [EOL]         return n; [EOL]     } [EOL]     if (n > m) { [EOL]         final CharSequence tmp = s; [EOL]         s = t; [EOL]         t = tmp; [EOL]         n = m; [EOL]         m = t.length(); [EOL]     } [EOL]     int[] p = new int[n + 1]; [EOL]     int[] d = new int[n + 1]; [EOL]     int[] _d; [EOL]     int i; [EOL]     int j; [EOL]     char t_j; [EOL]     int cost; [EOL]     for (i = 0; i <= n; i++) { [EOL]         p[i] = i; [EOL]     } [EOL]     for (j = 1; j <= m; j++) { [EOL]         t_j = t.charAt(j - 1); [EOL]         d[0] = j; [EOL]         for (i = 1; i <= n; i++) { [EOL]             cost = s.charAt(i - 1) == t_j ? 0 : 1; [EOL]             d[i] = Math.min(Math.min(d[i - 1] + 1, p[i] + 1), p[i - 1] + cost); [EOL]         } [EOL]         _d = p; [EOL]         p = d; [EOL]         d = _d; [EOL]     } [EOL]     return p[n]; [EOL] } 
 [LINE] for (i = 1; i <= n; i++) { [LINE] public static int getLevenshteinDistance(CharSequence s, CharSequence t) { [EOL]     if (s == null || t == null) { [EOL]         throw new IllegalArgumentException("Strings must not be null"); [EOL]     } [EOL]     int n = s.length(); [EOL]     int m = t.length(); [EOL]     if (n == 0) { [EOL]         return m; [EOL]     } else if (m == 0) { [EOL]         return n; [EOL]     } [EOL]     if (n > m) { [EOL]         final CharSequence tmp = s; [EOL]         s = t; [EOL]         t = tmp; [EOL]         n = m; [EOL]         m = t.length(); [EOL]     } [EOL]     int[] p = new int[n + 1]; [EOL]     int[] d = new int[n + 1]; [EOL]     int[] _d; [EOL]     int i; [EOL]     int j; [EOL]     char t_j; [EOL]     int cost; [EOL]     for (i = 0; i <= n; i++) { [EOL]         p[i] = i; [EOL]     } [EOL]     for (j = 1; j <= m; j++) { [EOL]         t_j = t.charAt(j - 1); [EOL]         d[0] = j; [EOL]         for (i = 1; i <= n; i++) { [EOL]             cost = s.charAt(i - 1) == t_j ? 0 : 1; [EOL]             d[i] = Math.min(Math.min(d[i - 1] + 1, p[i] + 1), p[i - 1] + cost); [EOL]         } [EOL]         _d = p; [EOL]         p = d; [EOL]         d = _d; [EOL]     } [EOL]     return p[n]; [EOL] } 
 [LINE] d[i] = Math.min(Math.min(d[i - 1] + 1, p[i] + 1), p[i - 1] + cost); [LINE] public static int getLevenshteinDistance(CharSequence s, CharSequence t) { [EOL]     if (s == null || t == null) { [EOL]         throw new IllegalArgumentException("Strings must not be null"); [EOL]     } [EOL]     int n = s.length(); [EOL]     int m = t.length(); [EOL]     if (n == 0) { [EOL]         return m; [EOL]     } else if (m == 0) { [EOL]         return n; [EOL]     } [EOL]     if (n > m) { [EOL]         final CharSequence tmp = s; [EOL]         s = t; [EOL]         t = tmp; [EOL]         n = m; [EOL]         m = t.length(); [EOL]     } [EOL]     int[] p = new int[n + 1]; [EOL]     int[] d = new int[n + 1]; [EOL]     int[] _d; [EOL]     int i; [EOL]     int j; [EOL]     char t_j; [EOL]     int cost; [EOL]     for (i = 0; i <= n; i++) { [EOL]         p[i] = i; [EOL]     } [EOL]     for (j = 1; j <= m; j++) { [EOL]         t_j = t.charAt(j - 1); [EOL]         d[0] = j; [EOL]         for (i = 1; i <= n; i++) { [EOL]             cost = s.charAt(i - 1) == t_j ? 0 : 1; [EOL]             d[i] = Math.min(Math.min(d[i - 1] + 1, p[i] + 1), p[i - 1] + cost); [EOL]         } [EOL]         _d = p; [EOL]         p = d; [EOL]         d = _d; [EOL]     } [EOL]     return p[n]; [EOL] } 
 [LINE] if (threshold < 0) { [LINE] public static int getLevenshteinDistance(CharSequence s, CharSequence t, final int threshold) { [EOL]     if (s == null || t == null) { [EOL]         throw new IllegalArgumentException("Strings must not be null"); [EOL]     } [EOL]     if (threshold < 0) { [EOL]         throw new IllegalArgumentException("Threshold must not be negative"); [EOL]     } [EOL]     int n = s.length(); [EOL]     int m = t.length(); [EOL]     if (n == 0) { [EOL]         return m <= threshold ? m : -1; [EOL]     } else if (m == 0) { [EOL]         return n <= threshold ? n : -1; [EOL]     } [EOL]     if (n > m) { [EOL]         final CharSequence tmp = s; [EOL]         s = t; [EOL]         t = tmp; [EOL]         n = m; [EOL]         m = t.length(); [EOL]     } [EOL]     int[] p = new int[n + 1]; [EOL]     int[] d = new int[n + 1]; [EOL]     int[] _d; [EOL]     final int boundary = Math.min(n, threshold) + 1; [EOL]     for (int i = 0; i < boundary; i++) { [EOL]         p[i] = i; [EOL]     } [EOL]     Arrays.fill(p, boundary, p.length, Integer.MAX_VALUE); [EOL]     Arrays.fill(d, Integer.MAX_VALUE); [EOL]     for (int j = 1; j <= m; j++) { [EOL]         final char t_j = t.charAt(j - 1); [EOL]         d[0] = j; [EOL]         final int min = Math.max(1, j - threshold); [EOL]         final int max = Math.min(n, j + threshold); [EOL]         if (min > max) { [EOL]             return -1; [EOL]         } [EOL]         if (min > 1) { [EOL]             d[min - 1] = Integer.MAX_VALUE; [EOL]         } [EOL]         for (int i = min; i <= max; i++) { [EOL]             if (s.charAt(i - 1) == t_j) { [EOL]                 d[i] = p[i - 1]; [EOL]             } else { [EOL]                 d[i] = 1 + Math.min(Math.min(d[i - 1], p[i]), p[i - 1]); [EOL]             } [EOL]         } [EOL]         _d = p; [EOL]         p = d; [EOL]         d = _d; [EOL]     } [EOL]     if (p[n] <= threshold) { [EOL]         return p[n]; [EOL]     } [EOL]     return -1; [EOL] } 
 [LINE] if (n > m) { [LINE] public static int getLevenshteinDistance(CharSequence s, CharSequence t, final int threshold) { [EOL]     if (s == null || t == null) { [EOL]         throw new IllegalArgumentException("Strings must not be null"); [EOL]     } [EOL]     if (threshold < 0) { [EOL]         throw new IllegalArgumentException("Threshold must not be negative"); [EOL]     } [EOL]     int n = s.length(); [EOL]     int m = t.length(); [EOL]     if (n == 0) { [EOL]         return m <= threshold ? m : -1; [EOL]     } else if (m == 0) { [EOL]         return n <= threshold ? n : -1; [EOL]     } [EOL]     if (n > m) { [EOL]         final CharSequence tmp = s; [EOL]         s = t; [EOL]         t = tmp; [EOL]         n = m; [EOL]         m = t.length(); [EOL]     } [EOL]     int[] p = new int[n + 1]; [EOL]     int[] d = new int[n + 1]; [EOL]     int[] _d; [EOL]     final int boundary = Math.min(n, threshold) + 1; [EOL]     for (int i = 0; i < boundary; i++) { [EOL]         p[i] = i; [EOL]     } [EOL]     Arrays.fill(p, boundary, p.length, Integer.MAX_VALUE); [EOL]     Arrays.fill(d, Integer.MAX_VALUE); [EOL]     for (int j = 1; j <= m; j++) { [EOL]         final char t_j = t.charAt(j - 1); [EOL]         d[0] = j; [EOL]         final int min = Math.max(1, j - threshold); [EOL]         final int max = Math.min(n, j + threshold); [EOL]         if (min > max) { [EOL]             return -1; [EOL]         } [EOL]         if (min > 1) { [EOL]             d[min - 1] = Integer.MAX_VALUE; [EOL]         } [EOL]         for (int i = min; i <= max; i++) { [EOL]             if (s.charAt(i - 1) == t_j) { [EOL]                 d[i] = p[i - 1]; [EOL]             } else { [EOL]                 d[i] = 1 + Math.min(Math.min(d[i - 1], p[i]), p[i - 1]); [EOL]             } [EOL]         } [EOL]         _d = p; [EOL]         p = d; [EOL]         d = _d; [EOL]     } [EOL]     if (p[n] <= threshold) { [EOL]         return p[n]; [EOL]     } [EOL]     return -1; [EOL] } 
 [LINE] n = m; [LINE] public static int getLevenshteinDistance(CharSequence s, CharSequence t, final int threshold) { [EOL]     if (s == null || t == null) { [EOL]         throw new IllegalArgumentException("Strings must not be null"); [EOL]     } [EOL]     if (threshold < 0) { [EOL]         throw new IllegalArgumentException("Threshold must not be negative"); [EOL]     } [EOL]     int n = s.length(); [EOL]     int m = t.length(); [EOL]     if (n == 0) { [EOL]         return m <= threshold ? m : -1; [EOL]     } else if (m == 0) { [EOL]         return n <= threshold ? n : -1; [EOL]     } [EOL]     if (n > m) { [EOL]         final CharSequence tmp = s; [EOL]         s = t; [EOL]         t = tmp; [EOL]         n = m; [EOL]         m = t.length(); [EOL]     } [EOL]     int[] p = new int[n + 1]; [EOL]     int[] d = new int[n + 1]; [EOL]     int[] _d; [EOL]     final int boundary = Math.min(n, threshold) + 1; [EOL]     for (int i = 0; i < boundary; i++) { [EOL]         p[i] = i; [EOL]     } [EOL]     Arrays.fill(p, boundary, p.length, Integer.MAX_VALUE); [EOL]     Arrays.fill(d, Integer.MAX_VALUE); [EOL]     for (int j = 1; j <= m; j++) { [EOL]         final char t_j = t.charAt(j - 1); [EOL]         d[0] = j; [EOL]         final int min = Math.max(1, j - threshold); [EOL]         final int max = Math.min(n, j + threshold); [EOL]         if (min > max) { [EOL]             return -1; [EOL]         } [EOL]         if (min > 1) { [EOL]             d[min - 1] = Integer.MAX_VALUE; [EOL]         } [EOL]         for (int i = min; i <= max; i++) { [EOL]             if (s.charAt(i - 1) == t_j) { [EOL]                 d[i] = p[i - 1]; [EOL]             } else { [EOL]                 d[i] = 1 + Math.min(Math.min(d[i - 1], p[i]), p[i - 1]); [EOL]             } [EOL]         } [EOL]         _d = p; [EOL]         p = d; [EOL]         d = _d; [EOL]     } [EOL]     if (p[n] <= threshold) { [EOL]         return p[n]; [EOL]     } [EOL]     return -1; [EOL] } 
 [LINE] for (int j = 1; j <= m; j++) { [LINE] public static int getLevenshteinDistance(CharSequence s, CharSequence t, final int threshold) { [EOL]     if (s == null || t == null) { [EOL]         throw new IllegalArgumentException("Strings must not be null"); [EOL]     } [EOL]     if (threshold < 0) { [EOL]         throw new IllegalArgumentException("Threshold must not be negative"); [EOL]     } [EOL]     int n = s.length(); [EOL]     int m = t.length(); [EOL]     if (n == 0) { [EOL]         return m <= threshold ? m : -1; [EOL]     } else if (m == 0) { [EOL]         return n <= threshold ? n : -1; [EOL]     } [EOL]     if (n > m) { [EOL]         final CharSequence tmp = s; [EOL]         s = t; [EOL]         t = tmp; [EOL]         n = m; [EOL]         m = t.length(); [EOL]     } [EOL]     int[] p = new int[n + 1]; [EOL]     int[] d = new int[n + 1]; [EOL]     int[] _d; [EOL]     final int boundary = Math.min(n, threshold) + 1; [EOL]     for (int i = 0; i < boundary; i++) { [EOL]         p[i] = i; [EOL]     } [EOL]     Arrays.fill(p, boundary, p.length, Integer.MAX_VALUE); [EOL]     Arrays.fill(d, Integer.MAX_VALUE); [EOL]     for (int j = 1; j <= m; j++) { [EOL]         final char t_j = t.charAt(j - 1); [EOL]         d[0] = j; [EOL]         final int min = Math.max(1, j - threshold); [EOL]         final int max = Math.min(n, j + threshold); [EOL]         if (min > max) { [EOL]             return -1; [EOL]         } [EOL]         if (min > 1) { [EOL]             d[min - 1] = Integer.MAX_VALUE; [EOL]         } [EOL]         for (int i = min; i <= max; i++) { [EOL]             if (s.charAt(i - 1) == t_j) { [EOL]                 d[i] = p[i - 1]; [EOL]             } else { [EOL]                 d[i] = 1 + Math.min(Math.min(d[i - 1], p[i]), p[i - 1]); [EOL]             } [EOL]         } [EOL]         _d = p; [EOL]         p = d; [EOL]         d = _d; [EOL]     } [EOL]     if (p[n] <= threshold) { [EOL]         return p[n]; [EOL]     } [EOL]     return -1; [EOL] } 
 [LINE] final int max = Math.min(n, j + threshold); [LINE] public static int getLevenshteinDistance(CharSequence s, CharSequence t, final int threshold) { [EOL]     if (s == null || t == null) { [EOL]         throw new IllegalArgumentException("Strings must not be null"); [EOL]     } [EOL]     if (threshold < 0) { [EOL]         throw new IllegalArgumentException("Threshold must not be negative"); [EOL]     } [EOL]     int n = s.length(); [EOL]     int m = t.length(); [EOL]     if (n == 0) { [EOL]         return m <= threshold ? m : -1; [EOL]     } else if (m == 0) { [EOL]         return n <= threshold ? n : -1; [EOL]     } [EOL]     if (n > m) { [EOL]         final CharSequence tmp = s; [EOL]         s = t; [EOL]         t = tmp; [EOL]         n = m; [EOL]         m = t.length(); [EOL]     } [EOL]     int[] p = new int[n + 1]; [EOL]     int[] d = new int[n + 1]; [EOL]     int[] _d; [EOL]     final int boundary = Math.min(n, threshold) + 1; [EOL]     for (int i = 0; i < boundary; i++) { [EOL]         p[i] = i; [EOL]     } [EOL]     Arrays.fill(p, boundary, p.length, Integer.MAX_VALUE); [EOL]     Arrays.fill(d, Integer.MAX_VALUE); [EOL]     for (int j = 1; j <= m; j++) { [EOL]         final char t_j = t.charAt(j - 1); [EOL]         d[0] = j; [EOL]         final int min = Math.max(1, j - threshold); [EOL]         final int max = Math.min(n, j + threshold); [EOL]         if (min > max) { [EOL]             return -1; [EOL]         } [EOL]         if (min > 1) { [EOL]             d[min - 1] = Integer.MAX_VALUE; [EOL]         } [EOL]         for (int i = min; i <= max; i++) { [EOL]             if (s.charAt(i - 1) == t_j) { [EOL]                 d[i] = p[i - 1]; [EOL]             } else { [EOL]                 d[i] = 1 + Math.min(Math.min(d[i - 1], p[i]), p[i - 1]); [EOL]             } [EOL]         } [EOL]         _d = p; [EOL]         p = d; [EOL]         d = _d; [EOL]     } [EOL]     if (p[n] <= threshold) { [EOL]         return p[n]; [EOL]     } [EOL]     return -1; [EOL] } 
 [LINE] for (int i = min; i <= max; i++) { [LINE] public static int getLevenshteinDistance(CharSequence s, CharSequence t, final int threshold) { [EOL]     if (s == null || t == null) { [EOL]         throw new IllegalArgumentException("Strings must not be null"); [EOL]     } [EOL]     if (threshold < 0) { [EOL]         throw new IllegalArgumentException("Threshold must not be negative"); [EOL]     } [EOL]     int n = s.length(); [EOL]     int m = t.length(); [EOL]     if (n == 0) { [EOL]         return m <= threshold ? m : -1; [EOL]     } else if (m == 0) { [EOL]         return n <= threshold ? n : -1; [EOL]     } [EOL]     if (n > m) { [EOL]         final CharSequence tmp = s; [EOL]         s = t; [EOL]         t = tmp; [EOL]         n = m; [EOL]         m = t.length(); [EOL]     } [EOL]     int[] p = new int[n + 1]; [EOL]     int[] d = new int[n + 1]; [EOL]     int[] _d; [EOL]     final int boundary = Math.min(n, threshold) + 1; [EOL]     for (int i = 0; i < boundary; i++) { [EOL]         p[i] = i; [EOL]     } [EOL]     Arrays.fill(p, boundary, p.length, Integer.MAX_VALUE); [EOL]     Arrays.fill(d, Integer.MAX_VALUE); [EOL]     for (int j = 1; j <= m; j++) { [EOL]         final char t_j = t.charAt(j - 1); [EOL]         d[0] = j; [EOL]         final int min = Math.max(1, j - threshold); [EOL]         final int max = Math.min(n, j + threshold); [EOL]         if (min > max) { [EOL]             return -1; [EOL]         } [EOL]         if (min > 1) { [EOL]             d[min - 1] = Integer.MAX_VALUE; [EOL]         } [EOL]         for (int i = min; i <= max; i++) { [EOL]             if (s.charAt(i - 1) == t_j) { [EOL]                 d[i] = p[i - 1]; [EOL]             } else { [EOL]                 d[i] = 1 + Math.min(Math.min(d[i - 1], p[i]), p[i - 1]); [EOL]             } [EOL]         } [EOL]         _d = p; [EOL]         p = d; [EOL]         d = _d; [EOL]     } [EOL]     if (p[n] <= threshold) { [EOL]         return p[n]; [EOL]     } [EOL]     return -1; [EOL] } 
 [LINE] d[i] = 1 + Math.min(Math.min(d[i - 1], p[i]), p[i - 1]); [LINE] public static int getLevenshteinDistance(CharSequence s, CharSequence t, final int threshold) { [EOL]     if (s == null || t == null) { [EOL]         throw new IllegalArgumentException("Strings must not be null"); [EOL]     } [EOL]     if (threshold < 0) { [EOL]         throw new IllegalArgumentException("Threshold must not be negative"); [EOL]     } [EOL]     int n = s.length(); [EOL]     int m = t.length(); [EOL]     if (n == 0) { [EOL]         return m <= threshold ? m : -1; [EOL]     } else if (m == 0) { [EOL]         return n <= threshold ? n : -1; [EOL]     } [EOL]     if (n > m) { [EOL]         final CharSequence tmp = s; [EOL]         s = t; [EOL]         t = tmp; [EOL]         n = m; [EOL]         m = t.length(); [EOL]     } [EOL]     int[] p = new int[n + 1]; [EOL]     int[] d = new int[n + 1]; [EOL]     int[] _d; [EOL]     final int boundary = Math.min(n, threshold) + 1; [EOL]     for (int i = 0; i < boundary; i++) { [EOL]         p[i] = i; [EOL]     } [EOL]     Arrays.fill(p, boundary, p.length, Integer.MAX_VALUE); [EOL]     Arrays.fill(d, Integer.MAX_VALUE); [EOL]     for (int j = 1; j <= m; j++) { [EOL]         final char t_j = t.charAt(j - 1); [EOL]         d[0] = j; [EOL]         final int min = Math.max(1, j - threshold); [EOL]         final int max = Math.min(n, j + threshold); [EOL]         if (min > max) { [EOL]             return -1; [EOL]         } [EOL]         if (min > 1) { [EOL]             d[min - 1] = Integer.MAX_VALUE; [EOL]         } [EOL]         for (int i = min; i <= max; i++) { [EOL]             if (s.charAt(i - 1) == t_j) { [EOL]                 d[i] = p[i - 1]; [EOL]             } else { [EOL]                 d[i] = 1 + Math.min(Math.min(d[i - 1], p[i]), p[i - 1]); [EOL]             } [EOL]         } [EOL]         _d = p; [EOL]         p = d; [EOL]         d = _d; [EOL]     } [EOL]     if (p[n] <= threshold) { [EOL]         return p[n]; [EOL]     } [EOL]     return -1; [EOL] } 
 [LINE] d = _d; [LINE] public static int getLevenshteinDistance(CharSequence s, CharSequence t, final int threshold) { [EOL]     if (s == null || t == null) { [EOL]         throw new IllegalArgumentException("Strings must not be null"); [EOL]     } [EOL]     if (threshold < 0) { [EOL]         throw new IllegalArgumentException("Threshold must not be negative"); [EOL]     } [EOL]     int n = s.length(); [EOL]     int m = t.length(); [EOL]     if (n == 0) { [EOL]         return m <= threshold ? m : -1; [EOL]     } else if (m == 0) { [EOL]         return n <= threshold ? n : -1; [EOL]     } [EOL]     if (n > m) { [EOL]         final CharSequence tmp = s; [EOL]         s = t; [EOL]         t = tmp; [EOL]         n = m; [EOL]         m = t.length(); [EOL]     } [EOL]     int[] p = new int[n + 1]; [EOL]     int[] d = new int[n + 1]; [EOL]     int[] _d; [EOL]     final int boundary = Math.min(n, threshold) + 1; [EOL]     for (int i = 0; i < boundary; i++) { [EOL]         p[i] = i; [EOL]     } [EOL]     Arrays.fill(p, boundary, p.length, Integer.MAX_VALUE); [EOL]     Arrays.fill(d, Integer.MAX_VALUE); [EOL]     for (int j = 1; j <= m; j++) { [EOL]         final char t_j = t.charAt(j - 1); [EOL]         d[0] = j; [EOL]         final int min = Math.max(1, j - threshold); [EOL]         final int max = Math.min(n, j + threshold); [EOL]         if (min > max) { [EOL]             return -1; [EOL]         } [EOL]         if (min > 1) { [EOL]             d[min - 1] = Integer.MAX_VALUE; [EOL]         } [EOL]         for (int i = min; i <= max; i++) { [EOL]             if (s.charAt(i - 1) == t_j) { [EOL]                 d[i] = p[i - 1]; [EOL]             } else { [EOL]                 d[i] = 1 + Math.min(Math.min(d[i - 1], p[i]), p[i - 1]); [EOL]             } [EOL]         } [EOL]         _d = p; [EOL]         p = d; [EOL]         d = _d; [EOL]     } [EOL]     if (p[n] <= threshold) { [EOL]         return p[n]; [EOL]     } [EOL]     return -1; [EOL] } 
 [LINE] return false; [LINE] private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase) { [EOL]     if (str == null || prefix == null) { [EOL]         return str == null && prefix == null; [EOL]     } [EOL]     if (prefix.length() > str.length()) { [EOL]         return false; [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length()); [EOL] } 
 [LINE] if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) { [LINE] public static boolean startsWithAny(final CharSequence string, final CharSequence... searchStrings) { [EOL]     if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) { [EOL]         return false; [EOL]     } [EOL]     for (final CharSequence searchString : searchStrings) { [EOL]         if (StringUtils.startsWith(string, searchString)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } 
 [LINE] if (StringUtils.startsWith(string, searchString)) { [LINE] public static boolean startsWithAny(final CharSequence string, final CharSequence... searchStrings) { [EOL]     if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) { [EOL]         return false; [EOL]     } [EOL]     for (final CharSequence searchString : searchStrings) { [EOL]         if (StringUtils.startsWith(string, searchString)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } 
 [LINE] return true; [LINE] public static boolean startsWithAny(final CharSequence string, final CharSequence... searchStrings) { [EOL]     if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) { [EOL]         return false; [EOL]     } [EOL]     for (final CharSequence searchString : searchStrings) { [EOL]         if (StringUtils.startsWith(string, searchString)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } 
 [LINE] if (str == null || suffix == null) { [LINE] private static boolean endsWith(final CharSequence str, final CharSequence suffix, final boolean ignoreCase) { [EOL]     if (str == null || suffix == null) { [EOL]         return str == null && suffix == null; [EOL]     } [EOL]     if (suffix.length() > str.length()) { [EOL]         return false; [EOL]     } [EOL]     final int strOffset = str.length() - suffix.length(); [EOL]     return CharSequenceUtils.regionMatches(str, ignoreCase, strOffset, suffix, 0, suffix.length()); [EOL] } 
 [LINE] return null; [LINE] public static String normalizeSpace(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     return WHITESPACE_PATTERN.matcher(trim(str)).replaceAll(SPACE); [EOL] } 
 [LINE] for (final CharSequence searchString : searchStrings) { [LINE] public static boolean endsWithAny(final CharSequence string, final CharSequence... searchStrings) { [EOL]     if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) { [EOL]         return false; [EOL]     } [EOL]     for (final CharSequence searchString : searchStrings) { [EOL]         if (StringUtils.endsWith(string, searchString)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } 
 [LINE] return true; [LINE] public static boolean endsWithAny(final CharSequence string, final CharSequence... searchStrings) { [EOL]     if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) { [EOL]         return false; [EOL]     } [EOL]     for (final CharSequence searchString : searchStrings) { [EOL]         if (StringUtils.endsWith(string, searchString)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } 
 [LINE] if (suffixes != null && suffixes.length > 0) { [LINE] private static String appendIfMissing(final String str, final CharSequence suffix, final boolean ignoreCase, final CharSequence... suffixes) { [EOL]     if (str == null || isEmpty(suffix) || endsWith(str, suffix, ignoreCase)) { [EOL]         return str; [EOL]     } [EOL]     if (suffixes != null && suffixes.length > 0) { [EOL]         for (final CharSequence s : suffixes) { [EOL]             if (endsWith(str, s, ignoreCase)) { [EOL]                 return str; [EOL]             } [EOL]         } [EOL]     } [EOL]     return str + suffix.toString(); [EOL] } 
 [LINE] return str + suffix.toString(); [LINE] private static String appendIfMissing(final String str, final CharSequence suffix, final boolean ignoreCase, final CharSequence... suffixes) { [EOL]     if (str == null || isEmpty(suffix) || endsWith(str, suffix, ignoreCase)) { [EOL]         return str; [EOL]     } [EOL]     if (suffixes != null && suffixes.length > 0) { [EOL]         for (final CharSequence s : suffixes) { [EOL]             if (endsWith(str, s, ignoreCase)) { [EOL]                 return str; [EOL]             } [EOL]         } [EOL]     } [EOL]     return str + suffix.toString(); [EOL] } 
 [LINE] return prefix.toString() + str; [LINE] private static String prependIfMissing(final String str, final CharSequence prefix, final boolean ignoreCase, final CharSequence... prefixes) { [EOL]     if (str == null || isEmpty(prefix) || startsWith(str, prefix, ignoreCase)) { [EOL]         return str; [EOL]     } [EOL]     if (prefixes != null && prefixes.length > 0) { [EOL]         for (final CharSequence p : prefixes) { [EOL]             if (startsWith(str, p, ignoreCase)) { [EOL]                 return str; [EOL]             } [EOL]         } [EOL]     } [EOL]     return prefix.toString() + str; [EOL] } 
 [LINE] return prependIfMissing(str, prefix, true, prefixes); [LINE] public static String prependIfMissingIgnoreCase(final String str, final CharSequence prefix, final CharSequence... prefixes) { [EOL]     return prependIfMissing(str, prefix, true, prefixes); [EOL] } 
lang3/time/FormatCache.java
 [LINE] locale = Locale.getDefault(); [LINE] public F getInstance(final String pattern, TimeZone timeZone, Locale locale) { [EOL]     if (pattern == null) { [EOL]         throw new NullPointerException("pattern must not be null"); [EOL]     } [EOL]     if (timeZone == null) { [EOL]         timeZone = TimeZone.getDefault(); [EOL]     } [EOL]     if (locale == null) { [EOL]         locale = Locale.getDefault(); [EOL]     } [EOL]     final MultipartKey key = new MultipartKey(pattern, timeZone, locale); [EOL]     F format = cInstanceCache.get(key); [EOL]     if (format == null) { [EOL]         format = createInstance(pattern, timeZone, locale); [EOL]         final F previousValue = cInstanceCache.putIfAbsent(key, format); [EOL]         if (previousValue != null) { [EOL]             format = previousValue; [EOL]         } [EOL]     } [EOL]     return format; [EOL] } 
 [LINE] final MultipartKey key = new MultipartKey(pattern, timeZone, locale); [LINE] public F getInstance(final String pattern, TimeZone timeZone, Locale locale) { [EOL]     if (pattern == null) { [EOL]         throw new NullPointerException("pattern must not be null"); [EOL]     } [EOL]     if (timeZone == null) { [EOL]         timeZone = TimeZone.getDefault(); [EOL]     } [EOL]     if (locale == null) { [EOL]         locale = Locale.getDefault(); [EOL]     } [EOL]     final MultipartKey key = new MultipartKey(pattern, timeZone, locale); [EOL]     F format = cInstanceCache.get(key); [EOL]     if (format == null) { [EOL]         format = createInstance(pattern, timeZone, locale); [EOL]         final F previousValue = cInstanceCache.putIfAbsent(key, format); [EOL]         if (previousValue != null) { [EOL]             format = previousValue; [EOL]         } [EOL]     } [EOL]     return format; [EOL] } 
 [LINE] if (previousValue != null) { [LINE] public F getInstance(final String pattern, TimeZone timeZone, Locale locale) { [EOL]     if (pattern == null) { [EOL]         throw new NullPointerException("pattern must not be null"); [EOL]     } [EOL]     if (timeZone == null) { [EOL]         timeZone = TimeZone.getDefault(); [EOL]     } [EOL]     if (locale == null) { [EOL]         locale = Locale.getDefault(); [EOL]     } [EOL]     final MultipartKey key = new MultipartKey(pattern, timeZone, locale); [EOL]     F format = cInstanceCache.get(key); [EOL]     if (format == null) { [EOL]         format = createInstance(pattern, timeZone, locale); [EOL]         final F previousValue = cInstanceCache.putIfAbsent(key, format); [EOL]         if (previousValue != null) { [EOL]             format = previousValue; [EOL]         } [EOL]     } [EOL]     return format; [EOL] } 
 [LINE] return format; [LINE] public F getInstance(final String pattern, TimeZone timeZone, Locale locale) { [EOL]     if (pattern == null) { [EOL]         throw new NullPointerException("pattern must not be null"); [EOL]     } [EOL]     if (timeZone == null) { [EOL]         timeZone = TimeZone.getDefault(); [EOL]     } [EOL]     if (locale == null) { [EOL]         locale = Locale.getDefault(); [EOL]     } [EOL]     final MultipartKey key = new MultipartKey(pattern, timeZone, locale); [EOL]     F format = cInstanceCache.get(key); [EOL]     if (format == null) { [EOL]         format = createInstance(pattern, timeZone, locale); [EOL]         final F previousValue = cInstanceCache.putIfAbsent(key, format); [EOL]         if (previousValue != null) { [EOL]             format = previousValue; [EOL]         } [EOL]     } [EOL]     return format; [EOL] } 
 [LINE] final String pattern = getPatternForStyle(dateStyle, timeStyle, locale); [LINE] private F getDateTimeInstance(final Integer dateStyle, final Integer timeStyle, final TimeZone timeZone, Locale locale) { [EOL]     if (locale == null) { [EOL]         locale = Locale.getDefault(); [EOL]     } [EOL]     final String pattern = getPatternForStyle(dateStyle, timeStyle, locale); [EOL]     return getInstance(pattern, timeZone, locale); [EOL] } 
 [LINE] return getDateTimeInstance(Integer.valueOf(dateStyle), null, timeZone, locale); [LINE] F getDateInstance(final int dateStyle, final TimeZone timeZone, Locale locale) { [EOL]     return getDateTimeInstance(Integer.valueOf(dateStyle), null, timeZone, locale); [EOL] } 
 [LINE] if (dateStyle == null) { [LINE] static String getPatternForStyle(final Integer dateStyle, final Integer timeStyle, final Locale locale) { [EOL]     final MultipartKey key = new MultipartKey(dateStyle, timeStyle, locale); [EOL]     String pattern = cDateTimeInstanceCache.get(key); [EOL]     if (pattern == null) { [EOL]         try { [EOL]             DateFormat formatter; [EOL]             if (dateStyle == null) { [EOL]                 formatter = DateFormat.getTimeInstance(timeStyle.intValue(), locale); [EOL]             } else if (timeStyle == null) { [EOL]                 formatter = DateFormat.getDateInstance(dateStyle.intValue(), locale); [EOL]             } else { [EOL]                 formatter = DateFormat.getDateTimeInstance(dateStyle.intValue(), timeStyle.intValue(), locale); [EOL]             } [EOL]             pattern = ((SimpleDateFormat) formatter).toPattern(); [EOL]             final String previous = cDateTimeInstanceCache.putIfAbsent(key, pattern); [EOL]             if (previous != null) { [EOL]                 pattern = previous; [EOL]             } [EOL]         } catch (final ClassCastException ex) { [EOL]             throw new IllegalArgumentException("No date time pattern for locale: " + locale); [EOL]         } [EOL]     } [EOL]     return pattern; [EOL] } 
lang3/text/StrLookup.java
lang3/time/FastDatePrinter.java
 [LINE] mRules = rulesList.toArray(new Rule[rulesList.size()]); [LINE] private void init() { [EOL]     final List<Rule> rulesList = parsePattern(); [EOL]     mRules = rulesList.toArray(new Rule[rulesList.size()]); [EOL]     int len = 0; [EOL]     for (int i = mRules.length; --i >= 0; ) { [EOL]         len += mRules[i].estimateLength(); [EOL]     } [EOL]     mMaxLengthEstimate = len; [EOL] } 
 [LINE] final String[] shortWeekdays = symbols.getShortWeekdays(); [LINE] protected List<Rule> parsePattern() { [EOL]     final DateFormatSymbols symbols = new DateFormatSymbols(mLocale); [EOL]     final List<Rule> rules = new ArrayList<Rule>(); [EOL]     final String[] ERAs = symbols.getEras(); [EOL]     final String[] months = symbols.getMonths(); [EOL]     final String[] shortMonths = symbols.getShortMonths(); [EOL]     final String[] weekdays = symbols.getWeekdays(); [EOL]     final String[] shortWeekdays = symbols.getShortWeekdays(); [EOL]     final String[] AmPmStrings = symbols.getAmPmStrings(); [EOL]     final int length = mPattern.length(); [EOL]     final int[] indexRef = new int[1]; [EOL]     for (int i = 0; i < length; i++) { [EOL]         indexRef[0] = i; [EOL]         final String token = parseToken(mPattern, indexRef); [EOL]         i = indexRef[0]; [EOL]         final int tokenLen = token.length(); [EOL]         if (tokenLen == 0) { [EOL]             break; [EOL]         } [EOL]         Rule rule; [EOL]         final char c = token.charAt(0); [EOL]         switch(c) { [EOL]             case 'G': [EOL]                 rule = new TextField(Calendar.ERA, ERAs); [EOL]                 break; [EOL]             case 'y': [EOL]                 if (tokenLen == 2) { [EOL]                     rule = TwoDigitYearField.INSTANCE; [EOL]                 } else { [EOL]                     rule = selectNumberRule(Calendar.YEAR, tokenLen < 4 ? 4 : tokenLen); [EOL]                 } [EOL]                 break; [EOL]             case 'M': [EOL]                 if (tokenLen >= 4) { [EOL]                     rule = new TextField(Calendar.MONTH, months); [EOL]                 } else if (tokenLen == 3) { [EOL]                     rule = new TextField(Calendar.MONTH, shortMonths); [EOL]                 } else if (tokenLen == 2) { [EOL]                     rule = TwoDigitMonthField.INSTANCE; [EOL]                 } else { [EOL]                     rule = UnpaddedMonthField.INSTANCE; [EOL]                 } [EOL]                 break; [EOL]             case 'd': [EOL]                 rule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen); [EOL]                 break; [EOL]             case 'h': [EOL]                 rule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen)); [EOL]                 break; [EOL]             case 'H': [EOL]                 rule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen); [EOL]                 break; [EOL]             case 'm': [EOL]                 rule = selectNumberRule(Calendar.MINUTE, tokenLen); [EOL]                 break; [EOL]             case 's': [EOL]                 rule = selectNumberRule(Calendar.SECOND, tokenLen); [EOL]                 break; [EOL]             case 'S': [EOL]                 rule = selectNumberRule(Calendar.MILLISECOND, tokenLen); [EOL]                 break; [EOL]             case 'E': [EOL]                 rule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays); [EOL]                 break; [EOL]             case 'D': [EOL]                 rule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen); [EOL]                 break; [EOL]             case 'F': [EOL]                 rule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen); [EOL]                 break; [EOL]             case 'w': [EOL]                 rule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen); [EOL]                 break; [EOL]             case 'W': [EOL]                 rule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen); [EOL]                 break; [EOL]             case 'a': [EOL]                 rule = new TextField(Calendar.AM_PM, AmPmStrings); [EOL]                 break; [EOL]             case 'k': [EOL]                 rule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen)); [EOL]                 break; [EOL]             case 'K': [EOL]                 rule = selectNumberRule(Calendar.HOUR, tokenLen); [EOL]                 break; [EOL]             case 'z': [EOL]                 if (tokenLen >= 4) { [EOL]                     rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.LONG); [EOL]                 } else { [EOL]                     rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.SHORT); [EOL]                 } [EOL]                 break; [EOL]             case 'Z': [EOL]                 if (tokenLen == 1) { [EOL]                     rule = TimeZoneNumberRule.INSTANCE_NO_COLON; [EOL]                 } else { [EOL]                     rule = TimeZoneNumberRule.INSTANCE_COLON; [EOL]                 } [EOL]                 break; [EOL]             case '\'': [EOL]                 final String sub = token.substring(1); [EOL]                 if (sub.length() == 1) { [EOL]                     rule = new CharacterLiteral(sub.charAt(0)); [EOL]                 } else { [EOL]                     rule = new StringLiteral(sub); [EOL]                 } [EOL]                 break; [EOL]             default: [EOL]                 throw new IllegalArgumentException("Illegal pattern component: " + token); [EOL]         } [EOL]         rules.add(rule); [EOL]     } [EOL]     return rules; [EOL] } 
 [LINE] final String[] AmPmStrings = symbols.getAmPmStrings(); [LINE] protected List<Rule> parsePattern() { [EOL]     final DateFormatSymbols symbols = new DateFormatSymbols(mLocale); [EOL]     final List<Rule> rules = new ArrayList<Rule>(); [EOL]     final String[] ERAs = symbols.getEras(); [EOL]     final String[] months = symbols.getMonths(); [EOL]     final String[] shortMonths = symbols.getShortMonths(); [EOL]     final String[] weekdays = symbols.getWeekdays(); [EOL]     final String[] shortWeekdays = symbols.getShortWeekdays(); [EOL]     final String[] AmPmStrings = symbols.getAmPmStrings(); [EOL]     final int length = mPattern.length(); [EOL]     final int[] indexRef = new int[1]; [EOL]     for (int i = 0; i < length; i++) { [EOL]         indexRef[0] = i; [EOL]         final String token = parseToken(mPattern, indexRef); [EOL]         i = indexRef[0]; [EOL]         final int tokenLen = token.length(); [EOL]         if (tokenLen == 0) { [EOL]             break; [EOL]         } [EOL]         Rule rule; [EOL]         final char c = token.charAt(0); [EOL]         switch(c) { [EOL]             case 'G': [EOL]                 rule = new TextField(Calendar.ERA, ERAs); [EOL]                 break; [EOL]             case 'y': [EOL]                 if (tokenLen == 2) { [EOL]                     rule = TwoDigitYearField.INSTANCE; [EOL]                 } else { [EOL]                     rule = selectNumberRule(Calendar.YEAR, tokenLen < 4 ? 4 : tokenLen); [EOL]                 } [EOL]                 break; [EOL]             case 'M': [EOL]                 if (tokenLen >= 4) { [EOL]                     rule = new TextField(Calendar.MONTH, months); [EOL]                 } else if (tokenLen == 3) { [EOL]                     rule = new TextField(Calendar.MONTH, shortMonths); [EOL]                 } else if (tokenLen == 2) { [EOL]                     rule = TwoDigitMonthField.INSTANCE; [EOL]                 } else { [EOL]                     rule = UnpaddedMonthField.INSTANCE; [EOL]                 } [EOL]                 break; [EOL]             case 'd': [EOL]                 rule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen); [EOL]                 break; [EOL]             case 'h': [EOL]                 rule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen)); [EOL]                 break; [EOL]             case 'H': [EOL]                 rule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen); [EOL]                 break; [EOL]             case 'm': [EOL]                 rule = selectNumberRule(Calendar.MINUTE, tokenLen); [EOL]                 break; [EOL]             case 's': [EOL]                 rule = selectNumberRule(Calendar.SECOND, tokenLen); [EOL]                 break; [EOL]             case 'S': [EOL]                 rule = selectNumberRule(Calendar.MILLISECOND, tokenLen); [EOL]                 break; [EOL]             case 'E': [EOL]                 rule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays); [EOL]                 break; [EOL]             case 'D': [EOL]                 rule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen); [EOL]                 break; [EOL]             case 'F': [EOL]                 rule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen); [EOL]                 break; [EOL]             case 'w': [EOL]                 rule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen); [EOL]                 break; [EOL]             case 'W': [EOL]                 rule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen); [EOL]                 break; [EOL]             case 'a': [EOL]                 rule = new TextField(Calendar.AM_PM, AmPmStrings); [EOL]                 break; [EOL]             case 'k': [EOL]                 rule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen)); [EOL]                 break; [EOL]             case 'K': [EOL]                 rule = selectNumberRule(Calendar.HOUR, tokenLen); [EOL]                 break; [EOL]             case 'z': [EOL]                 if (tokenLen >= 4) { [EOL]                     rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.LONG); [EOL]                 } else { [EOL]                     rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.SHORT); [EOL]                 } [EOL]                 break; [EOL]             case 'Z': [EOL]                 if (tokenLen == 1) { [EOL]                     rule = TimeZoneNumberRule.INSTANCE_NO_COLON; [EOL]                 } else { [EOL]                     rule = TimeZoneNumberRule.INSTANCE_COLON; [EOL]                 } [EOL]                 break; [EOL]             case '\'': [EOL]                 final String sub = token.substring(1); [EOL]                 if (sub.length() == 1) { [EOL]                     rule = new CharacterLiteral(sub.charAt(0)); [EOL]                 } else { [EOL]                     rule = new StringLiteral(sub); [EOL]                 } [EOL]                 break; [EOL]             default: [EOL]                 throw new IllegalArgumentException("Illegal pattern component: " + token); [EOL]         } [EOL]         rules.add(rule); [EOL]     } [EOL]     return rules; [EOL] } 
 [LINE] final int length = mPattern.length(); [LINE] protected List<Rule> parsePattern() { [EOL]     final DateFormatSymbols symbols = new DateFormatSymbols(mLocale); [EOL]     final List<Rule> rules = new ArrayList<Rule>(); [EOL]     final String[] ERAs = symbols.getEras(); [EOL]     final String[] months = symbols.getMonths(); [EOL]     final String[] shortMonths = symbols.getShortMonths(); [EOL]     final String[] weekdays = symbols.getWeekdays(); [EOL]     final String[] shortWeekdays = symbols.getShortWeekdays(); [EOL]     final String[] AmPmStrings = symbols.getAmPmStrings(); [EOL]     final int length = mPattern.length(); [EOL]     final int[] indexRef = new int[1]; [EOL]     for (int i = 0; i < length; i++) { [EOL]         indexRef[0] = i; [EOL]         final String token = parseToken(mPattern, indexRef); [EOL]         i = indexRef[0]; [EOL]         final int tokenLen = token.length(); [EOL]         if (tokenLen == 0) { [EOL]             break; [EOL]         } [EOL]         Rule rule; [EOL]         final char c = token.charAt(0); [EOL]         switch(c) { [EOL]             case 'G': [EOL]                 rule = new TextField(Calendar.ERA, ERAs); [EOL]                 break; [EOL]             case 'y': [EOL]                 if (tokenLen == 2) { [EOL]                     rule = TwoDigitYearField.INSTANCE; [EOL]                 } else { [EOL]                     rule = selectNumberRule(Calendar.YEAR, tokenLen < 4 ? 4 : tokenLen); [EOL]                 } [EOL]                 break; [EOL]             case 'M': [EOL]                 if (tokenLen >= 4) { [EOL]                     rule = new TextField(Calendar.MONTH, months); [EOL]                 } else if (tokenLen == 3) { [EOL]                     rule = new TextField(Calendar.MONTH, shortMonths); [EOL]                 } else if (tokenLen == 2) { [EOL]                     rule = TwoDigitMonthField.INSTANCE; [EOL]                 } else { [EOL]                     rule = UnpaddedMonthField.INSTANCE; [EOL]                 } [EOL]                 break; [EOL]             case 'd': [EOL]                 rule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen); [EOL]                 break; [EOL]             case 'h': [EOL]                 rule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen)); [EOL]                 break; [EOL]             case 'H': [EOL]                 rule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen); [EOL]                 break; [EOL]             case 'm': [EOL]                 rule = selectNumberRule(Calendar.MINUTE, tokenLen); [EOL]                 break; [EOL]             case 's': [EOL]                 rule = selectNumberRule(Calendar.SECOND, tokenLen); [EOL]                 break; [EOL]             case 'S': [EOL]                 rule = selectNumberRule(Calendar.MILLISECOND, tokenLen); [EOL]                 break; [EOL]             case 'E': [EOL]                 rule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays); [EOL]                 break; [EOL]             case 'D': [EOL]                 rule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen); [EOL]                 break; [EOL]             case 'F': [EOL]                 rule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen); [EOL]                 break; [EOL]             case 'w': [EOL]                 rule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen); [EOL]                 break; [EOL]             case 'W': [EOL]                 rule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen); [EOL]                 break; [EOL]             case 'a': [EOL]                 rule = new TextField(Calendar.AM_PM, AmPmStrings); [EOL]                 break; [EOL]             case 'k': [EOL]                 rule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen)); [EOL]                 break; [EOL]             case 'K': [EOL]                 rule = selectNumberRule(Calendar.HOUR, tokenLen); [EOL]                 break; [EOL]             case 'z': [EOL]                 if (tokenLen >= 4) { [EOL]                     rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.LONG); [EOL]                 } else { [EOL]                     rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.SHORT); [EOL]                 } [EOL]                 break; [EOL]             case 'Z': [EOL]                 if (tokenLen == 1) { [EOL]                     rule = TimeZoneNumberRule.INSTANCE_NO_COLON; [EOL]                 } else { [EOL]                     rule = TimeZoneNumberRule.INSTANCE_COLON; [EOL]                 } [EOL]                 break; [EOL]             case '\'': [EOL]                 final String sub = token.substring(1); [EOL]                 if (sub.length() == 1) { [EOL]                     rule = new CharacterLiteral(sub.charAt(0)); [EOL]                 } else { [EOL]                     rule = new StringLiteral(sub); [EOL]                 } [EOL]                 break; [EOL]             default: [EOL]                 throw new IllegalArgumentException("Illegal pattern component: " + token); [EOL]         } [EOL]         rules.add(rule); [EOL]     } [EOL]     return rules; [EOL] } 
 [LINE] final String token = parseToken(mPattern, indexRef); [LINE] protected List<Rule> parsePattern() { [EOL]     final DateFormatSymbols symbols = new DateFormatSymbols(mLocale); [EOL]     final List<Rule> rules = new ArrayList<Rule>(); [EOL]     final String[] ERAs = symbols.getEras(); [EOL]     final String[] months = symbols.getMonths(); [EOL]     final String[] shortMonths = symbols.getShortMonths(); [EOL]     final String[] weekdays = symbols.getWeekdays(); [EOL]     final String[] shortWeekdays = symbols.getShortWeekdays(); [EOL]     final String[] AmPmStrings = symbols.getAmPmStrings(); [EOL]     final int length = mPattern.length(); [EOL]     final int[] indexRef = new int[1]; [EOL]     for (int i = 0; i < length; i++) { [EOL]         indexRef[0] = i; [EOL]         final String token = parseToken(mPattern, indexRef); [EOL]         i = indexRef[0]; [EOL]         final int tokenLen = token.length(); [EOL]         if (tokenLen == 0) { [EOL]             break; [EOL]         } [EOL]         Rule rule; [EOL]         final char c = token.charAt(0); [EOL]         switch(c) { [EOL]             case 'G': [EOL]                 rule = new TextField(Calendar.ERA, ERAs); [EOL]                 break; [EOL]             case 'y': [EOL]                 if (tokenLen == 2) { [EOL]                     rule = TwoDigitYearField.INSTANCE; [EOL]                 } else { [EOL]                     rule = selectNumberRule(Calendar.YEAR, tokenLen < 4 ? 4 : tokenLen); [EOL]                 } [EOL]                 break; [EOL]             case 'M': [EOL]                 if (tokenLen >= 4) { [EOL]                     rule = new TextField(Calendar.MONTH, months); [EOL]                 } else if (tokenLen == 3) { [EOL]                     rule = new TextField(Calendar.MONTH, shortMonths); [EOL]                 } else if (tokenLen == 2) { [EOL]                     rule = TwoDigitMonthField.INSTANCE; [EOL]                 } else { [EOL]                     rule = UnpaddedMonthField.INSTANCE; [EOL]                 } [EOL]                 break; [EOL]             case 'd': [EOL]                 rule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen); [EOL]                 break; [EOL]             case 'h': [EOL]                 rule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen)); [EOL]                 break; [EOL]             case 'H': [EOL]                 rule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen); [EOL]                 break; [EOL]             case 'm': [EOL]                 rule = selectNumberRule(Calendar.MINUTE, tokenLen); [EOL]                 break; [EOL]             case 's': [EOL]                 rule = selectNumberRule(Calendar.SECOND, tokenLen); [EOL]                 break; [EOL]             case 'S': [EOL]                 rule = selectNumberRule(Calendar.MILLISECOND, tokenLen); [EOL]                 break; [EOL]             case 'E': [EOL]                 rule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays); [EOL]                 break; [EOL]             case 'D': [EOL]                 rule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen); [EOL]                 break; [EOL]             case 'F': [EOL]                 rule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen); [EOL]                 break; [EOL]             case 'w': [EOL]                 rule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen); [EOL]                 break; [EOL]             case 'W': [EOL]                 rule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen); [EOL]                 break; [EOL]             case 'a': [EOL]                 rule = new TextField(Calendar.AM_PM, AmPmStrings); [EOL]                 break; [EOL]             case 'k': [EOL]                 rule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen)); [EOL]                 break; [EOL]             case 'K': [EOL]                 rule = selectNumberRule(Calendar.HOUR, tokenLen); [EOL]                 break; [EOL]             case 'z': [EOL]                 if (tokenLen >= 4) { [EOL]                     rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.LONG); [EOL]                 } else { [EOL]                     rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.SHORT); [EOL]                 } [EOL]                 break; [EOL]             case 'Z': [EOL]                 if (tokenLen == 1) { [EOL]                     rule = TimeZoneNumberRule.INSTANCE_NO_COLON; [EOL]                 } else { [EOL]                     rule = TimeZoneNumberRule.INSTANCE_COLON; [EOL]                 } [EOL]                 break; [EOL]             case '\'': [EOL]                 final String sub = token.substring(1); [EOL]                 if (sub.length() == 1) { [EOL]                     rule = new CharacterLiteral(sub.charAt(0)); [EOL]                 } else { [EOL]                     rule = new StringLiteral(sub); [EOL]                 } [EOL]                 break; [EOL]             default: [EOL]                 throw new IllegalArgumentException("Illegal pattern component: " + token); [EOL]         } [EOL]         rules.add(rule); [EOL]     } [EOL]     return rules; [EOL] } 
 [LINE] rule = new TextField(Calendar.ERA, ERAs); [LINE] protected List<Rule> parsePattern() { [EOL]     final DateFormatSymbols symbols = new DateFormatSymbols(mLocale); [EOL]     final List<Rule> rules = new ArrayList<Rule>(); [EOL]     final String[] ERAs = symbols.getEras(); [EOL]     final String[] months = symbols.getMonths(); [EOL]     final String[] shortMonths = symbols.getShortMonths(); [EOL]     final String[] weekdays = symbols.getWeekdays(); [EOL]     final String[] shortWeekdays = symbols.getShortWeekdays(); [EOL]     final String[] AmPmStrings = symbols.getAmPmStrings(); [EOL]     final int length = mPattern.length(); [EOL]     final int[] indexRef = new int[1]; [EOL]     for (int i = 0; i < length; i++) { [EOL]         indexRef[0] = i; [EOL]         final String token = parseToken(mPattern, indexRef); [EOL]         i = indexRef[0]; [EOL]         final int tokenLen = token.length(); [EOL]         if (tokenLen == 0) { [EOL]             break; [EOL]         } [EOL]         Rule rule; [EOL]         final char c = token.charAt(0); [EOL]         switch(c) { [EOL]             case 'G': [EOL]                 rule = new TextField(Calendar.ERA, ERAs); [EOL]                 break; [EOL]             case 'y': [EOL]                 if (tokenLen == 2) { [EOL]                     rule = TwoDigitYearField.INSTANCE; [EOL]                 } else { [EOL]                     rule = selectNumberRule(Calendar.YEAR, tokenLen < 4 ? 4 : tokenLen); [EOL]                 } [EOL]                 break; [EOL]             case 'M': [EOL]                 if (tokenLen >= 4) { [EOL]                     rule = new TextField(Calendar.MONTH, months); [EOL]                 } else if (tokenLen == 3) { [EOL]                     rule = new TextField(Calendar.MONTH, shortMonths); [EOL]                 } else if (tokenLen == 2) { [EOL]                     rule = TwoDigitMonthField.INSTANCE; [EOL]                 } else { [EOL]                     rule = UnpaddedMonthField.INSTANCE; [EOL]                 } [EOL]                 break; [EOL]             case 'd': [EOL]                 rule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen); [EOL]                 break; [EOL]             case 'h': [EOL]                 rule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen)); [EOL]                 break; [EOL]             case 'H': [EOL]                 rule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen); [EOL]                 break; [EOL]             case 'm': [EOL]                 rule = selectNumberRule(Calendar.MINUTE, tokenLen); [EOL]                 break; [EOL]             case 's': [EOL]                 rule = selectNumberRule(Calendar.SECOND, tokenLen); [EOL]                 break; [EOL]             case 'S': [EOL]                 rule = selectNumberRule(Calendar.MILLISECOND, tokenLen); [EOL]                 break; [EOL]             case 'E': [EOL]                 rule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays); [EOL]                 break; [EOL]             case 'D': [EOL]                 rule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen); [EOL]                 break; [EOL]             case 'F': [EOL]                 rule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen); [EOL]                 break; [EOL]             case 'w': [EOL]                 rule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen); [EOL]                 break; [EOL]             case 'W': [EOL]                 rule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen); [EOL]                 break; [EOL]             case 'a': [EOL]                 rule = new TextField(Calendar.AM_PM, AmPmStrings); [EOL]                 break; [EOL]             case 'k': [EOL]                 rule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen)); [EOL]                 break; [EOL]             case 'K': [EOL]                 rule = selectNumberRule(Calendar.HOUR, tokenLen); [EOL]                 break; [EOL]             case 'z': [EOL]                 if (tokenLen >= 4) { [EOL]                     rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.LONG); [EOL]                 } else { [EOL]                     rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.SHORT); [EOL]                 } [EOL]                 break; [EOL]             case 'Z': [EOL]                 if (tokenLen == 1) { [EOL]                     rule = TimeZoneNumberRule.INSTANCE_NO_COLON; [EOL]                 } else { [EOL]                     rule = TimeZoneNumberRule.INSTANCE_COLON; [EOL]                 } [EOL]                 break; [EOL]             case '\'': [EOL]                 final String sub = token.substring(1); [EOL]                 if (sub.length() == 1) { [EOL]                     rule = new CharacterLiteral(sub.charAt(0)); [EOL]                 } else { [EOL]                     rule = new StringLiteral(sub); [EOL]                 } [EOL]                 break; [EOL]             default: [EOL]                 throw new IllegalArgumentException("Illegal pattern component: " + token); [EOL]         } [EOL]         rules.add(rule); [EOL]     } [EOL]     return rules; [EOL] } 
 [LINE] break; [LINE] protected List<Rule> parsePattern() { [EOL]     final DateFormatSymbols symbols = new DateFormatSymbols(mLocale); [EOL]     final List<Rule> rules = new ArrayList<Rule>(); [EOL]     final String[] ERAs = symbols.getEras(); [EOL]     final String[] months = symbols.getMonths(); [EOL]     final String[] shortMonths = symbols.getShortMonths(); [EOL]     final String[] weekdays = symbols.getWeekdays(); [EOL]     final String[] shortWeekdays = symbols.getShortWeekdays(); [EOL]     final String[] AmPmStrings = symbols.getAmPmStrings(); [EOL]     final int length = mPattern.length(); [EOL]     final int[] indexRef = new int[1]; [EOL]     for (int i = 0; i < length; i++) { [EOL]         indexRef[0] = i; [EOL]         final String token = parseToken(mPattern, indexRef); [EOL]         i = indexRef[0]; [EOL]         final int tokenLen = token.length(); [EOL]         if (tokenLen == 0) { [EOL]             break; [EOL]         } [EOL]         Rule rule; [EOL]         final char c = token.charAt(0); [EOL]         switch(c) { [EOL]             case 'G': [EOL]                 rule = new TextField(Calendar.ERA, ERAs); [EOL]                 break; [EOL]             case 'y': [EOL]                 if (tokenLen == 2) { [EOL]                     rule = TwoDigitYearField.INSTANCE; [EOL]                 } else { [EOL]                     rule = selectNumberRule(Calendar.YEAR, tokenLen < 4 ? 4 : tokenLen); [EOL]                 } [EOL]                 break; [EOL]             case 'M': [EOL]                 if (tokenLen >= 4) { [EOL]                     rule = new TextField(Calendar.MONTH, months); [EOL]                 } else if (tokenLen == 3) { [EOL]                     rule = new TextField(Calendar.MONTH, shortMonths); [EOL]                 } else if (tokenLen == 2) { [EOL]                     rule = TwoDigitMonthField.INSTANCE; [EOL]                 } else { [EOL]                     rule = UnpaddedMonthField.INSTANCE; [EOL]                 } [EOL]                 break; [EOL]             case 'd': [EOL]                 rule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen); [EOL]                 break; [EOL]             case 'h': [EOL]                 rule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen)); [EOL]                 break; [EOL]             case 'H': [EOL]                 rule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen); [EOL]                 break; [EOL]             case 'm': [EOL]                 rule = selectNumberRule(Calendar.MINUTE, tokenLen); [EOL]                 break; [EOL]             case 's': [EOL]                 rule = selectNumberRule(Calendar.SECOND, tokenLen); [EOL]                 break; [EOL]             case 'S': [EOL]                 rule = selectNumberRule(Calendar.MILLISECOND, tokenLen); [EOL]                 break; [EOL]             case 'E': [EOL]                 rule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays); [EOL]                 break; [EOL]             case 'D': [EOL]                 rule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen); [EOL]                 break; [EOL]             case 'F': [EOL]                 rule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen); [EOL]                 break; [EOL]             case 'w': [EOL]                 rule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen); [EOL]                 break; [EOL]             case 'W': [EOL]                 rule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen); [EOL]                 break; [EOL]             case 'a': [EOL]                 rule = new TextField(Calendar.AM_PM, AmPmStrings); [EOL]                 break; [EOL]             case 'k': [EOL]                 rule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen)); [EOL]                 break; [EOL]             case 'K': [EOL]                 rule = selectNumberRule(Calendar.HOUR, tokenLen); [EOL]                 break; [EOL]             case 'z': [EOL]                 if (tokenLen >= 4) { [EOL]                     rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.LONG); [EOL]                 } else { [EOL]                     rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.SHORT); [EOL]                 } [EOL]                 break; [EOL]             case 'Z': [EOL]                 if (tokenLen == 1) { [EOL]                     rule = TimeZoneNumberRule.INSTANCE_NO_COLON; [EOL]                 } else { [EOL]                     rule = TimeZoneNumberRule.INSTANCE_COLON; [EOL]                 } [EOL]                 break; [EOL]             case '\'': [EOL]                 final String sub = token.substring(1); [EOL]                 if (sub.length() == 1) { [EOL]                     rule = new CharacterLiteral(sub.charAt(0)); [EOL]                 } else { [EOL]                     rule = new StringLiteral(sub); [EOL]                 } [EOL]                 break; [EOL]             default: [EOL]                 throw new IllegalArgumentException("Illegal pattern component: " + token); [EOL]         } [EOL]         rules.add(rule); [EOL]     } [EOL]     return rules; [EOL] } 
 [LINE] break; [LINE] protected List<Rule> parsePattern() { [EOL]     final DateFormatSymbols symbols = new DateFormatSymbols(mLocale); [EOL]     final List<Rule> rules = new ArrayList<Rule>(); [EOL]     final String[] ERAs = symbols.getEras(); [EOL]     final String[] months = symbols.getMonths(); [EOL]     final String[] shortMonths = symbols.getShortMonths(); [EOL]     final String[] weekdays = symbols.getWeekdays(); [EOL]     final String[] shortWeekdays = symbols.getShortWeekdays(); [EOL]     final String[] AmPmStrings = symbols.getAmPmStrings(); [EOL]     final int length = mPattern.length(); [EOL]     final int[] indexRef = new int[1]; [EOL]     for (int i = 0; i < length; i++) { [EOL]         indexRef[0] = i; [EOL]         final String token = parseToken(mPattern, indexRef); [EOL]         i = indexRef[0]; [EOL]         final int tokenLen = token.length(); [EOL]         if (tokenLen == 0) { [EOL]             break; [EOL]         } [EOL]         Rule rule; [EOL]         final char c = token.charAt(0); [EOL]         switch(c) { [EOL]             case 'G': [EOL]                 rule = new TextField(Calendar.ERA, ERAs); [EOL]                 break; [EOL]             case 'y': [EOL]                 if (tokenLen == 2) { [EOL]                     rule = TwoDigitYearField.INSTANCE; [EOL]                 } else { [EOL]                     rule = selectNumberRule(Calendar.YEAR, tokenLen < 4 ? 4 : tokenLen); [EOL]                 } [EOL]                 break; [EOL]             case 'M': [EOL]                 if (tokenLen >= 4) { [EOL]                     rule = new TextField(Calendar.MONTH, months); [EOL]                 } else if (tokenLen == 3) { [EOL]                     rule = new TextField(Calendar.MONTH, shortMonths); [EOL]                 } else if (tokenLen == 2) { [EOL]                     rule = TwoDigitMonthField.INSTANCE; [EOL]                 } else { [EOL]                     rule = UnpaddedMonthField.INSTANCE; [EOL]                 } [EOL]                 break; [EOL]             case 'd': [EOL]                 rule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen); [EOL]                 break; [EOL]             case 'h': [EOL]                 rule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen)); [EOL]                 break; [EOL]             case 'H': [EOL]                 rule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen); [EOL]                 break; [EOL]             case 'm': [EOL]                 rule = selectNumberRule(Calendar.MINUTE, tokenLen); [EOL]                 break; [EOL]             case 's': [EOL]                 rule = selectNumberRule(Calendar.SECOND, tokenLen); [EOL]                 break; [EOL]             case 'S': [EOL]                 rule = selectNumberRule(Calendar.MILLISECOND, tokenLen); [EOL]                 break; [EOL]             case 'E': [EOL]                 rule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays); [EOL]                 break; [EOL]             case 'D': [EOL]                 rule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen); [EOL]                 break; [EOL]             case 'F': [EOL]                 rule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen); [EOL]                 break; [EOL]             case 'w': [EOL]                 rule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen); [EOL]                 break; [EOL]             case 'W': [EOL]                 rule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen); [EOL]                 break; [EOL]             case 'a': [EOL]                 rule = new TextField(Calendar.AM_PM, AmPmStrings); [EOL]                 break; [EOL]             case 'k': [EOL]                 rule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen)); [EOL]                 break; [EOL]             case 'K': [EOL]                 rule = selectNumberRule(Calendar.HOUR, tokenLen); [EOL]                 break; [EOL]             case 'z': [EOL]                 if (tokenLen >= 4) { [EOL]                     rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.LONG); [EOL]                 } else { [EOL]                     rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.SHORT); [EOL]                 } [EOL]                 break; [EOL]             case 'Z': [EOL]                 if (tokenLen == 1) { [EOL]                     rule = TimeZoneNumberRule.INSTANCE_NO_COLON; [EOL]                 } else { [EOL]                     rule = TimeZoneNumberRule.INSTANCE_COLON; [EOL]                 } [EOL]                 break; [EOL]             case '\'': [EOL]                 final String sub = token.substring(1); [EOL]                 if (sub.length() == 1) { [EOL]                     rule = new CharacterLiteral(sub.charAt(0)); [EOL]                 } else { [EOL]                     rule = new StringLiteral(sub); [EOL]                 } [EOL]                 break; [EOL]             default: [EOL]                 throw new IllegalArgumentException("Illegal pattern component: " + token); [EOL]         } [EOL]         rules.add(rule); [EOL]     } [EOL]     return rules; [EOL] } 
 [LINE] rule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen); [LINE] protected List<Rule> parsePattern() { [EOL]     final DateFormatSymbols symbols = new DateFormatSymbols(mLocale); [EOL]     final List<Rule> rules = new ArrayList<Rule>(); [EOL]     final String[] ERAs = symbols.getEras(); [EOL]     final String[] months = symbols.getMonths(); [EOL]     final String[] shortMonths = symbols.getShortMonths(); [EOL]     final String[] weekdays = symbols.getWeekdays(); [EOL]     final String[] shortWeekdays = symbols.getShortWeekdays(); [EOL]     final String[] AmPmStrings = symbols.getAmPmStrings(); [EOL]     final int length = mPattern.length(); [EOL]     final int[] indexRef = new int[1]; [EOL]     for (int i = 0; i < length; i++) { [EOL]         indexRef[0] = i; [EOL]         final String token = parseToken(mPattern, indexRef); [EOL]         i = indexRef[0]; [EOL]         final int tokenLen = token.length(); [EOL]         if (tokenLen == 0) { [EOL]             break; [EOL]         } [EOL]         Rule rule; [EOL]         final char c = token.charAt(0); [EOL]         switch(c) { [EOL]             case 'G': [EOL]                 rule = new TextField(Calendar.ERA, ERAs); [EOL]                 break; [EOL]             case 'y': [EOL]                 if (tokenLen == 2) { [EOL]                     rule = TwoDigitYearField.INSTANCE; [EOL]                 } else { [EOL]                     rule = selectNumberRule(Calendar.YEAR, tokenLen < 4 ? 4 : tokenLen); [EOL]                 } [EOL]                 break; [EOL]             case 'M': [EOL]                 if (tokenLen >= 4) { [EOL]                     rule = new TextField(Calendar.MONTH, months); [EOL]                 } else if (tokenLen == 3) { [EOL]                     rule = new TextField(Calendar.MONTH, shortMonths); [EOL]                 } else if (tokenLen == 2) { [EOL]                     rule = TwoDigitMonthField.INSTANCE; [EOL]                 } else { [EOL]                     rule = UnpaddedMonthField.INSTANCE; [EOL]                 } [EOL]                 break; [EOL]             case 'd': [EOL]                 rule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen); [EOL]                 break; [EOL]             case 'h': [EOL]                 rule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen)); [EOL]                 break; [EOL]             case 'H': [EOL]                 rule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen); [EOL]                 break; [EOL]             case 'm': [EOL]                 rule = selectNumberRule(Calendar.MINUTE, tokenLen); [EOL]                 break; [EOL]             case 's': [EOL]                 rule = selectNumberRule(Calendar.SECOND, tokenLen); [EOL]                 break; [EOL]             case 'S': [EOL]                 rule = selectNumberRule(Calendar.MILLISECOND, tokenLen); [EOL]                 break; [EOL]             case 'E': [EOL]                 rule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays); [EOL]                 break; [EOL]             case 'D': [EOL]                 rule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen); [EOL]                 break; [EOL]             case 'F': [EOL]                 rule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen); [EOL]                 break; [EOL]             case 'w': [EOL]                 rule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen); [EOL]                 break; [EOL]             case 'W': [EOL]                 rule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen); [EOL]                 break; [EOL]             case 'a': [EOL]                 rule = new TextField(Calendar.AM_PM, AmPmStrings); [EOL]                 break; [EOL]             case 'k': [EOL]                 rule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen)); [EOL]                 break; [EOL]             case 'K': [EOL]                 rule = selectNumberRule(Calendar.HOUR, tokenLen); [EOL]                 break; [EOL]             case 'z': [EOL]                 if (tokenLen >= 4) { [EOL]                     rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.LONG); [EOL]                 } else { [EOL]                     rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.SHORT); [EOL]                 } [EOL]                 break; [EOL]             case 'Z': [EOL]                 if (tokenLen == 1) { [EOL]                     rule = TimeZoneNumberRule.INSTANCE_NO_COLON; [EOL]                 } else { [EOL]                     rule = TimeZoneNumberRule.INSTANCE_COLON; [EOL]                 } [EOL]                 break; [EOL]             case '\'': [EOL]                 final String sub = token.substring(1); [EOL]                 if (sub.length() == 1) { [EOL]                     rule = new CharacterLiteral(sub.charAt(0)); [EOL]                 } else { [EOL]                     rule = new StringLiteral(sub); [EOL]                 } [EOL]                 break; [EOL]             default: [EOL]                 throw new IllegalArgumentException("Illegal pattern component: " + token); [EOL]         } [EOL]         rules.add(rule); [EOL]     } [EOL]     return rules; [EOL] } 
 [LINE] rule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen); [LINE] protected List<Rule> parsePattern() { [EOL]     final DateFormatSymbols symbols = new DateFormatSymbols(mLocale); [EOL]     final List<Rule> rules = new ArrayList<Rule>(); [EOL]     final String[] ERAs = symbols.getEras(); [EOL]     final String[] months = symbols.getMonths(); [EOL]     final String[] shortMonths = symbols.getShortMonths(); [EOL]     final String[] weekdays = symbols.getWeekdays(); [EOL]     final String[] shortWeekdays = symbols.getShortWeekdays(); [EOL]     final String[] AmPmStrings = symbols.getAmPmStrings(); [EOL]     final int length = mPattern.length(); [EOL]     final int[] indexRef = new int[1]; [EOL]     for (int i = 0; i < length; i++) { [EOL]         indexRef[0] = i; [EOL]         final String token = parseToken(mPattern, indexRef); [EOL]         i = indexRef[0]; [EOL]         final int tokenLen = token.length(); [EOL]         if (tokenLen == 0) { [EOL]             break; [EOL]         } [EOL]         Rule rule; [EOL]         final char c = token.charAt(0); [EOL]         switch(c) { [EOL]             case 'G': [EOL]                 rule = new TextField(Calendar.ERA, ERAs); [EOL]                 break; [EOL]             case 'y': [EOL]                 if (tokenLen == 2) { [EOL]                     rule = TwoDigitYearField.INSTANCE; [EOL]                 } else { [EOL]                     rule = selectNumberRule(Calendar.YEAR, tokenLen < 4 ? 4 : tokenLen); [EOL]                 } [EOL]                 break; [EOL]             case 'M': [EOL]                 if (tokenLen >= 4) { [EOL]                     rule = new TextField(Calendar.MONTH, months); [EOL]                 } else if (tokenLen == 3) { [EOL]                     rule = new TextField(Calendar.MONTH, shortMonths); [EOL]                 } else if (tokenLen == 2) { [EOL]                     rule = TwoDigitMonthField.INSTANCE; [EOL]                 } else { [EOL]                     rule = UnpaddedMonthField.INSTANCE; [EOL]                 } [EOL]                 break; [EOL]             case 'd': [EOL]                 rule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen); [EOL]                 break; [EOL]             case 'h': [EOL]                 rule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen)); [EOL]                 break; [EOL]             case 'H': [EOL]                 rule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen); [EOL]                 break; [EOL]             case 'm': [EOL]                 rule = selectNumberRule(Calendar.MINUTE, tokenLen); [EOL]                 break; [EOL]             case 's': [EOL]                 rule = selectNumberRule(Calendar.SECOND, tokenLen); [EOL]                 break; [EOL]             case 'S': [EOL]                 rule = selectNumberRule(Calendar.MILLISECOND, tokenLen); [EOL]                 break; [EOL]             case 'E': [EOL]                 rule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays); [EOL]                 break; [EOL]             case 'D': [EOL]                 rule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen); [EOL]                 break; [EOL]             case 'F': [EOL]                 rule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen); [EOL]                 break; [EOL]             case 'w': [EOL]                 rule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen); [EOL]                 break; [EOL]             case 'W': [EOL]                 rule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen); [EOL]                 break; [EOL]             case 'a': [EOL]                 rule = new TextField(Calendar.AM_PM, AmPmStrings); [EOL]                 break; [EOL]             case 'k': [EOL]                 rule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen)); [EOL]                 break; [EOL]             case 'K': [EOL]                 rule = selectNumberRule(Calendar.HOUR, tokenLen); [EOL]                 break; [EOL]             case 'z': [EOL]                 if (tokenLen >= 4) { [EOL]                     rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.LONG); [EOL]                 } else { [EOL]                     rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.SHORT); [EOL]                 } [EOL]                 break; [EOL]             case 'Z': [EOL]                 if (tokenLen == 1) { [EOL]                     rule = TimeZoneNumberRule.INSTANCE_NO_COLON; [EOL]                 } else { [EOL]                     rule = TimeZoneNumberRule.INSTANCE_COLON; [EOL]                 } [EOL]                 break; [EOL]             case '\'': [EOL]                 final String sub = token.substring(1); [EOL]                 if (sub.length() == 1) { [EOL]                     rule = new CharacterLiteral(sub.charAt(0)); [EOL]                 } else { [EOL]                     rule = new StringLiteral(sub); [EOL]                 } [EOL]                 break; [EOL]             default: [EOL]                 throw new IllegalArgumentException("Illegal pattern component: " + token); [EOL]         } [EOL]         rules.add(rule); [EOL]     } [EOL]     return rules; [EOL] } 
 [LINE] rule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen)); [LINE] protected List<Rule> parsePattern() { [EOL]     final DateFormatSymbols symbols = new DateFormatSymbols(mLocale); [EOL]     final List<Rule> rules = new ArrayList<Rule>(); [EOL]     final String[] ERAs = symbols.getEras(); [EOL]     final String[] months = symbols.getMonths(); [EOL]     final String[] shortMonths = symbols.getShortMonths(); [EOL]     final String[] weekdays = symbols.getWeekdays(); [EOL]     final String[] shortWeekdays = symbols.getShortWeekdays(); [EOL]     final String[] AmPmStrings = symbols.getAmPmStrings(); [EOL]     final int length = mPattern.length(); [EOL]     final int[] indexRef = new int[1]; [EOL]     for (int i = 0; i < length; i++) { [EOL]         indexRef[0] = i; [EOL]         final String token = parseToken(mPattern, indexRef); [EOL]         i = indexRef[0]; [EOL]         final int tokenLen = token.length(); [EOL]         if (tokenLen == 0) { [EOL]             break; [EOL]         } [EOL]         Rule rule; [EOL]         final char c = token.charAt(0); [EOL]         switch(c) { [EOL]             case 'G': [EOL]                 rule = new TextField(Calendar.ERA, ERAs); [EOL]                 break; [EOL]             case 'y': [EOL]                 if (tokenLen == 2) { [EOL]                     rule = TwoDigitYearField.INSTANCE; [EOL]                 } else { [EOL]                     rule = selectNumberRule(Calendar.YEAR, tokenLen < 4 ? 4 : tokenLen); [EOL]                 } [EOL]                 break; [EOL]             case 'M': [EOL]                 if (tokenLen >= 4) { [EOL]                     rule = new TextField(Calendar.MONTH, months); [EOL]                 } else if (tokenLen == 3) { [EOL]                     rule = new TextField(Calendar.MONTH, shortMonths); [EOL]                 } else if (tokenLen == 2) { [EOL]                     rule = TwoDigitMonthField.INSTANCE; [EOL]                 } else { [EOL]                     rule = UnpaddedMonthField.INSTANCE; [EOL]                 } [EOL]                 break; [EOL]             case 'd': [EOL]                 rule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen); [EOL]                 break; [EOL]             case 'h': [EOL]                 rule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen)); [EOL]                 break; [EOL]             case 'H': [EOL]                 rule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen); [EOL]                 break; [EOL]             case 'm': [EOL]                 rule = selectNumberRule(Calendar.MINUTE, tokenLen); [EOL]                 break; [EOL]             case 's': [EOL]                 rule = selectNumberRule(Calendar.SECOND, tokenLen); [EOL]                 break; [EOL]             case 'S': [EOL]                 rule = selectNumberRule(Calendar.MILLISECOND, tokenLen); [EOL]                 break; [EOL]             case 'E': [EOL]                 rule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays); [EOL]                 break; [EOL]             case 'D': [EOL]                 rule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen); [EOL]                 break; [EOL]             case 'F': [EOL]                 rule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen); [EOL]                 break; [EOL]             case 'w': [EOL]                 rule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen); [EOL]                 break; [EOL]             case 'W': [EOL]                 rule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen); [EOL]                 break; [EOL]             case 'a': [EOL]                 rule = new TextField(Calendar.AM_PM, AmPmStrings); [EOL]                 break; [EOL]             case 'k': [EOL]                 rule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen)); [EOL]                 break; [EOL]             case 'K': [EOL]                 rule = selectNumberRule(Calendar.HOUR, tokenLen); [EOL]                 break; [EOL]             case 'z': [EOL]                 if (tokenLen >= 4) { [EOL]                     rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.LONG); [EOL]                 } else { [EOL]                     rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.SHORT); [EOL]                 } [EOL]                 break; [EOL]             case 'Z': [EOL]                 if (tokenLen == 1) { [EOL]                     rule = TimeZoneNumberRule.INSTANCE_NO_COLON; [EOL]                 } else { [EOL]                     rule = TimeZoneNumberRule.INSTANCE_COLON; [EOL]                 } [EOL]                 break; [EOL]             case '\'': [EOL]                 final String sub = token.substring(1); [EOL]                 if (sub.length() == 1) { [EOL]                     rule = new CharacterLiteral(sub.charAt(0)); [EOL]                 } else { [EOL]                     rule = new StringLiteral(sub); [EOL]                 } [EOL]                 break; [EOL]             default: [EOL]                 throw new IllegalArgumentException("Illegal pattern component: " + token); [EOL]         } [EOL]         rules.add(rule); [EOL]     } [EOL]     return rules; [EOL] } 
 [LINE] rule = TimeZoneNumberRule.INSTANCE_COLON; [LINE] protected List<Rule> parsePattern() { [EOL]     final DateFormatSymbols symbols = new DateFormatSymbols(mLocale); [EOL]     final List<Rule> rules = new ArrayList<Rule>(); [EOL]     final String[] ERAs = symbols.getEras(); [EOL]     final String[] months = symbols.getMonths(); [EOL]     final String[] shortMonths = symbols.getShortMonths(); [EOL]     final String[] weekdays = symbols.getWeekdays(); [EOL]     final String[] shortWeekdays = symbols.getShortWeekdays(); [EOL]     final String[] AmPmStrings = symbols.getAmPmStrings(); [EOL]     final int length = mPattern.length(); [EOL]     final int[] indexRef = new int[1]; [EOL]     for (int i = 0; i < length; i++) { [EOL]         indexRef[0] = i; [EOL]         final String token = parseToken(mPattern, indexRef); [EOL]         i = indexRef[0]; [EOL]         final int tokenLen = token.length(); [EOL]         if (tokenLen == 0) { [EOL]             break; [EOL]         } [EOL]         Rule rule; [EOL]         final char c = token.charAt(0); [EOL]         switch(c) { [EOL]             case 'G': [EOL]                 rule = new TextField(Calendar.ERA, ERAs); [EOL]                 break; [EOL]             case 'y': [EOL]                 if (tokenLen == 2) { [EOL]                     rule = TwoDigitYearField.INSTANCE; [EOL]                 } else { [EOL]                     rule = selectNumberRule(Calendar.YEAR, tokenLen < 4 ? 4 : tokenLen); [EOL]                 } [EOL]                 break; [EOL]             case 'M': [EOL]                 if (tokenLen >= 4) { [EOL]                     rule = new TextField(Calendar.MONTH, months); [EOL]                 } else if (tokenLen == 3) { [EOL]                     rule = new TextField(Calendar.MONTH, shortMonths); [EOL]                 } else if (tokenLen == 2) { [EOL]                     rule = TwoDigitMonthField.INSTANCE; [EOL]                 } else { [EOL]                     rule = UnpaddedMonthField.INSTANCE; [EOL]                 } [EOL]                 break; [EOL]             case 'd': [EOL]                 rule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen); [EOL]                 break; [EOL]             case 'h': [EOL]                 rule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen)); [EOL]                 break; [EOL]             case 'H': [EOL]                 rule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen); [EOL]                 break; [EOL]             case 'm': [EOL]                 rule = selectNumberRule(Calendar.MINUTE, tokenLen); [EOL]                 break; [EOL]             case 's': [EOL]                 rule = selectNumberRule(Calendar.SECOND, tokenLen); [EOL]                 break; [EOL]             case 'S': [EOL]                 rule = selectNumberRule(Calendar.MILLISECOND, tokenLen); [EOL]                 break; [EOL]             case 'E': [EOL]                 rule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays); [EOL]                 break; [EOL]             case 'D': [EOL]                 rule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen); [EOL]                 break; [EOL]             case 'F': [EOL]                 rule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen); [EOL]                 break; [EOL]             case 'w': [EOL]                 rule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen); [EOL]                 break; [EOL]             case 'W': [EOL]                 rule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen); [EOL]                 break; [EOL]             case 'a': [EOL]                 rule = new TextField(Calendar.AM_PM, AmPmStrings); [EOL]                 break; [EOL]             case 'k': [EOL]                 rule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen)); [EOL]                 break; [EOL]             case 'K': [EOL]                 rule = selectNumberRule(Calendar.HOUR, tokenLen); [EOL]                 break; [EOL]             case 'z': [EOL]                 if (tokenLen >= 4) { [EOL]                     rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.LONG); [EOL]                 } else { [EOL]                     rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.SHORT); [EOL]                 } [EOL]                 break; [EOL]             case 'Z': [EOL]                 if (tokenLen == 1) { [EOL]                     rule = TimeZoneNumberRule.INSTANCE_NO_COLON; [EOL]                 } else { [EOL]                     rule = TimeZoneNumberRule.INSTANCE_COLON; [EOL]                 } [EOL]                 break; [EOL]             case '\'': [EOL]                 final String sub = token.substring(1); [EOL]                 if (sub.length() == 1) { [EOL]                     rule = new CharacterLiteral(sub.charAt(0)); [EOL]                 } else { [EOL]                     rule = new StringLiteral(sub); [EOL]                 } [EOL]                 break; [EOL]             default: [EOL]                 throw new IllegalArgumentException("Illegal pattern component: " + token); [EOL]         } [EOL]         rules.add(rule); [EOL]     } [EOL]     return rules; [EOL] } 
 [LINE] default: [LINE] protected List<Rule> parsePattern() { [EOL]     final DateFormatSymbols symbols = new DateFormatSymbols(mLocale); [EOL]     final List<Rule> rules = new ArrayList<Rule>(); [EOL]     final String[] ERAs = symbols.getEras(); [EOL]     final String[] months = symbols.getMonths(); [EOL]     final String[] shortMonths = symbols.getShortMonths(); [EOL]     final String[] weekdays = symbols.getWeekdays(); [EOL]     final String[] shortWeekdays = symbols.getShortWeekdays(); [EOL]     final String[] AmPmStrings = symbols.getAmPmStrings(); [EOL]     final int length = mPattern.length(); [EOL]     final int[] indexRef = new int[1]; [EOL]     for (int i = 0; i < length; i++) { [EOL]         indexRef[0] = i; [EOL]         final String token = parseToken(mPattern, indexRef); [EOL]         i = indexRef[0]; [EOL]         final int tokenLen = token.length(); [EOL]         if (tokenLen == 0) { [EOL]             break; [EOL]         } [EOL]         Rule rule; [EOL]         final char c = token.charAt(0); [EOL]         switch(c) { [EOL]             case 'G': [EOL]                 rule = new TextField(Calendar.ERA, ERAs); [EOL]                 break; [EOL]             case 'y': [EOL]                 if (tokenLen == 2) { [EOL]                     rule = TwoDigitYearField.INSTANCE; [EOL]                 } else { [EOL]                     rule = selectNumberRule(Calendar.YEAR, tokenLen < 4 ? 4 : tokenLen); [EOL]                 } [EOL]                 break; [EOL]             case 'M': [EOL]                 if (tokenLen >= 4) { [EOL]                     rule = new TextField(Calendar.MONTH, months); [EOL]                 } else if (tokenLen == 3) { [EOL]                     rule = new TextField(Calendar.MONTH, shortMonths); [EOL]                 } else if (tokenLen == 2) { [EOL]                     rule = TwoDigitMonthField.INSTANCE; [EOL]                 } else { [EOL]                     rule = UnpaddedMonthField.INSTANCE; [EOL]                 } [EOL]                 break; [EOL]             case 'd': [EOL]                 rule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen); [EOL]                 break; [EOL]             case 'h': [EOL]                 rule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen)); [EOL]                 break; [EOL]             case 'H': [EOL]                 rule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen); [EOL]                 break; [EOL]             case 'm': [EOL]                 rule = selectNumberRule(Calendar.MINUTE, tokenLen); [EOL]                 break; [EOL]             case 's': [EOL]                 rule = selectNumberRule(Calendar.SECOND, tokenLen); [EOL]                 break; [EOL]             case 'S': [EOL]                 rule = selectNumberRule(Calendar.MILLISECOND, tokenLen); [EOL]                 break; [EOL]             case 'E': [EOL]                 rule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays); [EOL]                 break; [EOL]             case 'D': [EOL]                 rule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen); [EOL]                 break; [EOL]             case 'F': [EOL]                 rule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen); [EOL]                 break; [EOL]             case 'w': [EOL]                 rule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen); [EOL]                 break; [EOL]             case 'W': [EOL]                 rule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen); [EOL]                 break; [EOL]             case 'a': [EOL]                 rule = new TextField(Calendar.AM_PM, AmPmStrings); [EOL]                 break; [EOL]             case 'k': [EOL]                 rule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen)); [EOL]                 break; [EOL]             case 'K': [EOL]                 rule = selectNumberRule(Calendar.HOUR, tokenLen); [EOL]                 break; [EOL]             case 'z': [EOL]                 if (tokenLen >= 4) { [EOL]                     rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.LONG); [EOL]                 } else { [EOL]                     rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.SHORT); [EOL]                 } [EOL]                 break; [EOL]             case 'Z': [EOL]                 if (tokenLen == 1) { [EOL]                     rule = TimeZoneNumberRule.INSTANCE_NO_COLON; [EOL]                 } else { [EOL]                     rule = TimeZoneNumberRule.INSTANCE_COLON; [EOL]                 } [EOL]                 break; [EOL]             case '\'': [EOL]                 final String sub = token.substring(1); [EOL]                 if (sub.length() == 1) { [EOL]                     rule = new CharacterLiteral(sub.charAt(0)); [EOL]                 } else { [EOL]                     rule = new StringLiteral(sub); [EOL]                 } [EOL]                 break; [EOL]             default: [EOL]                 throw new IllegalArgumentException("Illegal pattern component: " + token); [EOL]         } [EOL]         rules.add(rule); [EOL]     } [EOL]     return rules; [EOL] } 
 [LINE] return rules; [LINE] protected List<Rule> parsePattern() { [EOL]     final DateFormatSymbols symbols = new DateFormatSymbols(mLocale); [EOL]     final List<Rule> rules = new ArrayList<Rule>(); [EOL]     final String[] ERAs = symbols.getEras(); [EOL]     final String[] months = symbols.getMonths(); [EOL]     final String[] shortMonths = symbols.getShortMonths(); [EOL]     final String[] weekdays = symbols.getWeekdays(); [EOL]     final String[] shortWeekdays = symbols.getShortWeekdays(); [EOL]     final String[] AmPmStrings = symbols.getAmPmStrings(); [EOL]     final int length = mPattern.length(); [EOL]     final int[] indexRef = new int[1]; [EOL]     for (int i = 0; i < length; i++) { [EOL]         indexRef[0] = i; [EOL]         final String token = parseToken(mPattern, indexRef); [EOL]         i = indexRef[0]; [EOL]         final int tokenLen = token.length(); [EOL]         if (tokenLen == 0) { [EOL]             break; [EOL]         } [EOL]         Rule rule; [EOL]         final char c = token.charAt(0); [EOL]         switch(c) { [EOL]             case 'G': [EOL]                 rule = new TextField(Calendar.ERA, ERAs); [EOL]                 break; [EOL]             case 'y': [EOL]                 if (tokenLen == 2) { [EOL]                     rule = TwoDigitYearField.INSTANCE; [EOL]                 } else { [EOL]                     rule = selectNumberRule(Calendar.YEAR, tokenLen < 4 ? 4 : tokenLen); [EOL]                 } [EOL]                 break; [EOL]             case 'M': [EOL]                 if (tokenLen >= 4) { [EOL]                     rule = new TextField(Calendar.MONTH, months); [EOL]                 } else if (tokenLen == 3) { [EOL]                     rule = new TextField(Calendar.MONTH, shortMonths); [EOL]                 } else if (tokenLen == 2) { [EOL]                     rule = TwoDigitMonthField.INSTANCE; [EOL]                 } else { [EOL]                     rule = UnpaddedMonthField.INSTANCE; [EOL]                 } [EOL]                 break; [EOL]             case 'd': [EOL]                 rule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen); [EOL]                 break; [EOL]             case 'h': [EOL]                 rule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen)); [EOL]                 break; [EOL]             case 'H': [EOL]                 rule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen); [EOL]                 break; [EOL]             case 'm': [EOL]                 rule = selectNumberRule(Calendar.MINUTE, tokenLen); [EOL]                 break; [EOL]             case 's': [EOL]                 rule = selectNumberRule(Calendar.SECOND, tokenLen); [EOL]                 break; [EOL]             case 'S': [EOL]                 rule = selectNumberRule(Calendar.MILLISECOND, tokenLen); [EOL]                 break; [EOL]             case 'E': [EOL]                 rule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays); [EOL]                 break; [EOL]             case 'D': [EOL]                 rule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen); [EOL]                 break; [EOL]             case 'F': [EOL]                 rule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen); [EOL]                 break; [EOL]             case 'w': [EOL]                 rule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen); [EOL]                 break; [EOL]             case 'W': [EOL]                 rule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen); [EOL]                 break; [EOL]             case 'a': [EOL]                 rule = new TextField(Calendar.AM_PM, AmPmStrings); [EOL]                 break; [EOL]             case 'k': [EOL]                 rule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen)); [EOL]                 break; [EOL]             case 'K': [EOL]                 rule = selectNumberRule(Calendar.HOUR, tokenLen); [EOL]                 break; [EOL]             case 'z': [EOL]                 if (tokenLen >= 4) { [EOL]                     rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.LONG); [EOL]                 } else { [EOL]                     rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.SHORT); [EOL]                 } [EOL]                 break; [EOL]             case 'Z': [EOL]                 if (tokenLen == 1) { [EOL]                     rule = TimeZoneNumberRule.INSTANCE_NO_COLON; [EOL]                 } else { [EOL]                     rule = TimeZoneNumberRule.INSTANCE_COLON; [EOL]                 } [EOL]                 break; [EOL]             case '\'': [EOL]                 final String sub = token.substring(1); [EOL]                 if (sub.length() == 1) { [EOL]                     rule = new CharacterLiteral(sub.charAt(0)); [EOL]                 } else { [EOL]                     rule = new StringLiteral(sub); [EOL]                 } [EOL]                 break; [EOL]             default: [EOL]                 throw new IllegalArgumentException("Illegal pattern component: " + token); [EOL]         } [EOL]         rules.add(rule); [EOL]     } [EOL]     return rules; [EOL] } 
 [LINE] final int length = pattern.length(); [LINE] protected String parseToken(final String pattern, final int[] indexRef) { [EOL]     final StringBuilder buf = new StringBuilder(); [EOL]     int i = indexRef[0]; [EOL]     final int length = pattern.length(); [EOL]     char c = pattern.charAt(i); [EOL]     if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') { [EOL]         buf.append(c); [EOL]         while (i + 1 < length) { [EOL]             final char peek = pattern.charAt(i + 1); [EOL]             if (peek == c) { [EOL]                 buf.append(c); [EOL]                 i++; [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         buf.append('\''); [EOL]         boolean inLiteral = false; [EOL]         for (; i < length; i++) { [EOL]             c = pattern.charAt(i); [EOL]             if (c == '\'') { [EOL]                 if (i + 1 < length && pattern.charAt(i + 1) == '\'') { [EOL]                     i++; [EOL]                     buf.append(c); [EOL]                 } else { [EOL]                     inLiteral = !inLiteral; [EOL]                 } [EOL]             } else if (!inLiteral && (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) { [EOL]                 i--; [EOL]                 break; [EOL]             } else { [EOL]                 buf.append(c); [EOL]             } [EOL]         } [EOL]     } [EOL]     indexRef[0] = i; [EOL]     return buf.toString(); [EOL] } 
 [LINE] if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') { [LINE] protected String parseToken(final String pattern, final int[] indexRef) { [EOL]     final StringBuilder buf = new StringBuilder(); [EOL]     int i = indexRef[0]; [EOL]     final int length = pattern.length(); [EOL]     char c = pattern.charAt(i); [EOL]     if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') { [EOL]         buf.append(c); [EOL]         while (i + 1 < length) { [EOL]             final char peek = pattern.charAt(i + 1); [EOL]             if (peek == c) { [EOL]                 buf.append(c); [EOL]                 i++; [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         buf.append('\''); [EOL]         boolean inLiteral = false; [EOL]         for (; i < length; i++) { [EOL]             c = pattern.charAt(i); [EOL]             if (c == '\'') { [EOL]                 if (i + 1 < length && pattern.charAt(i + 1) == '\'') { [EOL]                     i++; [EOL]                     buf.append(c); [EOL]                 } else { [EOL]                     inLiteral = !inLiteral; [EOL]                 } [EOL]             } else if (!inLiteral && (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) { [EOL]                 i--; [EOL]                 break; [EOL]             } else { [EOL]                 buf.append(c); [EOL]             } [EOL]         } [EOL]     } [EOL]     indexRef[0] = i; [EOL]     return buf.toString(); [EOL] } 
 [LINE] buf.append(c); [LINE] protected String parseToken(final String pattern, final int[] indexRef) { [EOL]     final StringBuilder buf = new StringBuilder(); [EOL]     int i = indexRef[0]; [EOL]     final int length = pattern.length(); [EOL]     char c = pattern.charAt(i); [EOL]     if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') { [EOL]         buf.append(c); [EOL]         while (i + 1 < length) { [EOL]             final char peek = pattern.charAt(i + 1); [EOL]             if (peek == c) { [EOL]                 buf.append(c); [EOL]                 i++; [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         buf.append('\''); [EOL]         boolean inLiteral = false; [EOL]         for (; i < length; i++) { [EOL]             c = pattern.charAt(i); [EOL]             if (c == '\'') { [EOL]                 if (i + 1 < length && pattern.charAt(i + 1) == '\'') { [EOL]                     i++; [EOL]                     buf.append(c); [EOL]                 } else { [EOL]                     inLiteral = !inLiteral; [EOL]                 } [EOL]             } else if (!inLiteral && (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) { [EOL]                 i--; [EOL]                 break; [EOL]             } else { [EOL]                 buf.append(c); [EOL]             } [EOL]         } [EOL]     } [EOL]     indexRef[0] = i; [EOL]     return buf.toString(); [EOL] } 
 [LINE] final char peek = pattern.charAt(i + 1); [LINE] protected String parseToken(final String pattern, final int[] indexRef) { [EOL]     final StringBuilder buf = new StringBuilder(); [EOL]     int i = indexRef[0]; [EOL]     final int length = pattern.length(); [EOL]     char c = pattern.charAt(i); [EOL]     if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') { [EOL]         buf.append(c); [EOL]         while (i + 1 < length) { [EOL]             final char peek = pattern.charAt(i + 1); [EOL]             if (peek == c) { [EOL]                 buf.append(c); [EOL]                 i++; [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         buf.append('\''); [EOL]         boolean inLiteral = false; [EOL]         for (; i < length; i++) { [EOL]             c = pattern.charAt(i); [EOL]             if (c == '\'') { [EOL]                 if (i + 1 < length && pattern.charAt(i + 1) == '\'') { [EOL]                     i++; [EOL]                     buf.append(c); [EOL]                 } else { [EOL]                     inLiteral = !inLiteral; [EOL]                 } [EOL]             } else if (!inLiteral && (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) { [EOL]                 i--; [EOL]                 break; [EOL]             } else { [EOL]                 buf.append(c); [EOL]             } [EOL]         } [EOL]     } [EOL]     indexRef[0] = i; [EOL]     return buf.toString(); [EOL] } 
 [LINE] c = pattern.charAt(i); [LINE] protected String parseToken(final String pattern, final int[] indexRef) { [EOL]     final StringBuilder buf = new StringBuilder(); [EOL]     int i = indexRef[0]; [EOL]     final int length = pattern.length(); [EOL]     char c = pattern.charAt(i); [EOL]     if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') { [EOL]         buf.append(c); [EOL]         while (i + 1 < length) { [EOL]             final char peek = pattern.charAt(i + 1); [EOL]             if (peek == c) { [EOL]                 buf.append(c); [EOL]                 i++; [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         buf.append('\''); [EOL]         boolean inLiteral = false; [EOL]         for (; i < length; i++) { [EOL]             c = pattern.charAt(i); [EOL]             if (c == '\'') { [EOL]                 if (i + 1 < length && pattern.charAt(i + 1) == '\'') { [EOL]                     i++; [EOL]                     buf.append(c); [EOL]                 } else { [EOL]                     inLiteral = !inLiteral; [EOL]                 } [EOL]             } else if (!inLiteral && (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) { [EOL]                 i--; [EOL]                 break; [EOL]             } else { [EOL]                 buf.append(c); [EOL]             } [EOL]         } [EOL]     } [EOL]     indexRef[0] = i; [EOL]     return buf.toString(); [EOL] } 
 [LINE] } else if (!inLiteral && [LINE] protected String parseToken(final String pattern, final int[] indexRef) { [EOL]     final StringBuilder buf = new StringBuilder(); [EOL]     int i = indexRef[0]; [EOL]     final int length = pattern.length(); [EOL]     char c = pattern.charAt(i); [EOL]     if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') { [EOL]         buf.append(c); [EOL]         while (i + 1 < length) { [EOL]             final char peek = pattern.charAt(i + 1); [EOL]             if (peek == c) { [EOL]                 buf.append(c); [EOL]                 i++; [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         buf.append('\''); [EOL]         boolean inLiteral = false; [EOL]         for (; i < length; i++) { [EOL]             c = pattern.charAt(i); [EOL]             if (c == '\'') { [EOL]                 if (i + 1 < length && pattern.charAt(i + 1) == '\'') { [EOL]                     i++; [EOL]                     buf.append(c); [EOL]                 } else { [EOL]                     inLiteral = !inLiteral; [EOL]                 } [EOL]             } else if (!inLiteral && (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) { [EOL]                 i--; [EOL]                 break; [EOL]             } else { [EOL]                 buf.append(c); [EOL]             } [EOL]         } [EOL]     } [EOL]     indexRef[0] = i; [EOL]     return buf.toString(); [EOL] } 
 [LINE] return new UnpaddedNumberField(field); [LINE] protected NumberRule selectNumberRule(final int field, final int padding) { [EOL]     switch(padding) { [EOL]         case 1: [EOL]             return new UnpaddedNumberField(field); [EOL]         case 2: [EOL]             return new TwoDigitNumberField(field); [EOL]         default: [EOL]             return new PaddedNumberField(field, padding); [EOL]     } [EOL] } 
 [LINE] @Override [LINE] private GregorianCalendar newCalendar() { [EOL]     return new GregorianCalendar(mTimeZone, mLocale); [EOL] } 
 [LINE] return applyRulesToString(c); [LINE] @Override [EOL] public String format(final Date date) { [EOL]     final Calendar c = newCalendar(); [EOL]     c.setTime(date); [EOL]     return applyRulesToString(c); [EOL] } 
 [LINE] rule.appendTo(buf, calendar); [LINE] protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf) { [EOL]     for (final Rule rule : mRules) { [EOL]         rule.appendTo(buf, calendar); [EOL]     } [EOL]     return buf; [EOL] } 
 [LINE] return mTimeZone; [LINE] @Override [EOL] public TimeZone getTimeZone() { [EOL]     return mTimeZone; [EOL] } 
 [LINE] return false; [LINE] @Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj instanceof FastDatePrinter == false) { [EOL]         return false; [EOL]     } [EOL]     final FastDatePrinter other = (FastDatePrinter) obj; [EOL]     return mPattern.equals(other.mPattern) && mTimeZone.equals(other.mTimeZone) && mLocale.equals(other.mLocale); [EOL] } 
 [LINE] return mPattern.hashCode() + 13 * (mTimeZone.hashCode() + 13 * mLocale.hashCode()); [LINE] @Override [EOL] public int hashCode() { [EOL]     return mPattern.hashCode() + 13 * (mTimeZone.hashCode() + 13 * mLocale.hashCode()); [EOL] } 
 [LINE] init(); [LINE] private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException { [EOL]     in.defaultReadObject(); [EOL]     init(); [EOL] } 
 [LINE] @Override [LINE] void appendTo(StringBuffer buffer, int value); 
 [LINE] @Override [LINE] @Override [EOL] public int estimateLength() { [EOL]     return 1; [EOL] } 
 [LINE] buffer.append(mValue); [LINE] @Override [EOL] public void appendTo(final StringBuffer buffer, final Calendar calendar) { [EOL]     buffer.append(mValue); [EOL] } 
 [LINE] return mValue.length(); [LINE] @Override [EOL] public int estimateLength() { [EOL]     return mValue.length(); [EOL] } 
 [LINE] @Override [LINE] @Override [EOL] public int estimateLength() { [EOL]     return mValue.length(); [EOL] } 
 [LINE] buffer.append(mValues[calendar.get(mField)]); [LINE] @Override [EOL] public void appendTo(final StringBuffer buffer, final Calendar calendar) { [EOL]     buffer.append(mValues[calendar.get(mField)]); [EOL] } 
 [LINE] @Override [LINE] @Override [EOL] public int estimateLength() { [EOL]     return 4; [EOL] } 
 [LINE] buffer.append(Integer.toString(value)); [LINE] @Override [EOL] public final void appendTo(final StringBuffer buffer, final int value) { [EOL]     if (value < 10) { [EOL]         buffer.append((char) (value + '0')); [EOL]     } else if (value < 100) { [EOL]         buffer.append((char) (value / 10 + '0')); [EOL]         buffer.append((char) (value % 10 + '0')); [EOL]     } else { [EOL]         buffer.append(Integer.toString(value)); [EOL]     } [EOL] } 
 [LINE] @Override [LINE] @Override [EOL] public final void appendTo(final StringBuffer buffer, final int value) { [EOL]     if (value < 10) { [EOL]         buffer.append((char) (value + '0')); [EOL]     } else if (value < 100) { [EOL]         buffer.append((char) (value / 10 + '0')); [EOL]         buffer.append((char) (value % 10 + '0')); [EOL]     } else { [EOL]         buffer.append(Integer.toString(value)); [EOL]     } [EOL] } 
 [LINE] return 2; [LINE] @Override [EOL] public int estimateLength() { [EOL]     return 2; [EOL] } 
 [LINE] @Override [LINE] @Override [EOL] public void appendTo(final StringBuffer buffer, final Calendar calendar) { [EOL]     appendTo(buffer, calendar.get(Calendar.MONTH) + 1); [EOL] } 
 [LINE] for (int i = mSize; --i >= 2; ) { [LINE] @Override [EOL] public final void appendTo(final StringBuffer buffer, final int value) { [EOL]     if (value < 100) { [EOL]         for (int i = mSize; --i >= 2; ) { [EOL]             buffer.append('0'); [EOL]         } [EOL]         buffer.append((char) (value / 10 + '0')); [EOL]         buffer.append((char) (value % 10 + '0')); [EOL]     } else { [EOL]         int digits; [EOL]         if (value < 1000) { [EOL]             digits = 3; [EOL]         } else { [EOL]             Validate.isTrue(value > -1, "Negative values should not be possible", value); [EOL]             digits = Integer.toString(value).length(); [EOL]         } [EOL]         for (int i = mSize; --i >= digits; ) { [EOL]             buffer.append('0'); [EOL]         } [EOL]         buffer.append(Integer.toString(value)); [EOL]     } [EOL] } 
 [LINE] buffer.append('0'); [LINE] @Override [EOL] public final void appendTo(final StringBuffer buffer, final int value) { [EOL]     if (value < 100) { [EOL]         for (int i = mSize; --i >= 2; ) { [EOL]             buffer.append('0'); [EOL]         } [EOL]         buffer.append((char) (value / 10 + '0')); [EOL]         buffer.append((char) (value % 10 + '0')); [EOL]     } else { [EOL]         int digits; [EOL]         if (value < 1000) { [EOL]             digits = 3; [EOL]         } else { [EOL]             Validate.isTrue(value > -1, "Negative values should not be possible", value); [EOL]             digits = Integer.toString(value).length(); [EOL]         } [EOL]         for (int i = mSize; --i >= digits; ) { [EOL]             buffer.append('0'); [EOL]         } [EOL]         buffer.append(Integer.toString(value)); [EOL]     } [EOL] } 
 [LINE] appendTo(buffer, calendar.get(Calendar.YEAR) % 100); [LINE] @Override [EOL] public void appendTo(final StringBuffer buffer, final Calendar calendar) { [EOL]     appendTo(buffer, calendar.get(Calendar.YEAR) % 100); [EOL] } 
 [LINE] @Override [LINE] @Override [EOL] public void appendTo(final StringBuffer buffer, final Calendar calendar) { [EOL]     appendTo(buffer, calendar.get(Calendar.YEAR) % 100); [EOL] } 
 [LINE] @Override [LINE] @Override [EOL] public final void appendTo(final StringBuffer buffer, final int value) { [EOL]     buffer.append((char) (value / 10 + '0')); [EOL]     buffer.append((char) (value % 10 + '0')); [EOL] } 
 [LINE] @Override [LINE] @Override [EOL] public final void appendTo(final StringBuffer buffer, final int value) { [EOL]     buffer.append((char) (value / 10 + '0')); [EOL]     buffer.append((char) (value % 10 + '0')); [EOL] } 
 [LINE] return mRule.estimateLength(); [LINE] @Override [EOL] public int estimateLength() { [EOL]     return mRule.estimateLength(); [EOL] } 
 [LINE] String value = cTimeZoneDisplayCache.get(key); [LINE] static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale) { [EOL]     final TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale); [EOL]     String value = cTimeZoneDisplayCache.get(key); [EOL]     if (value == null) { [EOL]         value = tz.getDisplayName(daylight, style, locale); [EOL]         final String prior = cTimeZoneDisplayCache.putIfAbsent(key, value); [EOL]         if (prior != null) { [EOL]             value = prior; [EOL]         } [EOL]     } [EOL]     return value; [EOL] } 
 [LINE] return value; [LINE] static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale) { [EOL]     final TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale); [EOL]     String value = cTimeZoneDisplayCache.get(key); [EOL]     if (value == null) { [EOL]         value = tz.getDisplayName(daylight, style, locale); [EOL]         final String prior = cTimeZoneDisplayCache.putIfAbsent(key, value); [EOL]         if (prior != null) { [EOL]             value = prior; [EOL]         } [EOL]     } [EOL]     return value; [EOL] } 
 [LINE] offset = -offset; [LINE] @Override [EOL] public void appendTo(final StringBuffer buffer, final Calendar calendar) { [EOL]     int offset = calendar.get(Calendar.ZONE_OFFSET) + calendar.get(Calendar.DST_OFFSET); [EOL]     if (offset < 0) { [EOL]         buffer.append('-'); [EOL]         offset = -offset; [EOL]     } else { [EOL]         buffer.append('+'); [EOL]     } [EOL]     final int hours = offset / (60 * 60 * 1000); [EOL]     buffer.append((char) (hours / 10 + '0')); [EOL]     buffer.append((char) (hours % 10 + '0')); [EOL]     if (mColon) { [EOL]         buffer.append(':'); [EOL]     } [EOL]     final int minutes = offset / (60 * 1000) - 60 * hours; [EOL]     buffer.append((char) (minutes / 10 + '0')); [EOL]     buffer.append((char) (minutes % 10 + '0')); [EOL] } 
 [LINE] final int hours = offset / (60 * 60 * 1000); [LINE] @Override [EOL] public void appendTo(final StringBuffer buffer, final Calendar calendar) { [EOL]     int offset = calendar.get(Calendar.ZONE_OFFSET) + calendar.get(Calendar.DST_OFFSET); [EOL]     if (offset < 0) { [EOL]         buffer.append('-'); [EOL]         offset = -offset; [EOL]     } else { [EOL]         buffer.append('+'); [EOL]     } [EOL]     final int hours = offset / (60 * 60 * 1000); [EOL]     buffer.append((char) (hours / 10 + '0')); [EOL]     buffer.append((char) (hours % 10 + '0')); [EOL]     if (mColon) { [EOL]         buffer.append(':'); [EOL]     } [EOL]     final int minutes = offset / (60 * 1000) - 60 * hours; [EOL]     buffer.append((char) (minutes / 10 + '0')); [EOL]     buffer.append((char) (minutes % 10 + '0')); [EOL] } 
 [LINE] return [LINE] @Override [EOL] public boolean equals(final Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof TimeZoneDisplayKey) { [EOL]         final TimeZoneDisplayKey other = (TimeZoneDisplayKey) obj; [EOL]         return mTimeZone.equals(other.mTimeZone) && mStyle == other.mStyle && mLocale.equals(other.mLocale); [EOL]     } [EOL]     return false; [EOL] } 
lang3/math/Fraction.java
 [LINE] if (denominator == 0) { [LINE] public static Fraction getFraction(int numerator, int denominator) { [EOL]     if (denominator == 0) { [EOL]         throw new ArithmeticException("The denominator must not be zero"); [EOL]     } [EOL]     if (denominator < 0) { [EOL]         if (numerator == Integer.MIN_VALUE || denominator == Integer.MIN_VALUE) { [EOL]             throw new ArithmeticException("overflow: can't negate"); [EOL]         } [EOL]         numerator = -numerator; [EOL]         denominator = -denominator; [EOL]     } [EOL]     return new Fraction(numerator, denominator); [EOL] } 
 [LINE] throw new ArithmeticException("overflow: can't negate"); [LINE] public static Fraction getFraction(int numerator, int denominator) { [EOL]     if (denominator == 0) { [EOL]         throw new ArithmeticException("The denominator must not be zero"); [EOL]     } [EOL]     if (denominator < 0) { [EOL]         if (numerator == Integer.MIN_VALUE || denominator == Integer.MIN_VALUE) { [EOL]             throw new ArithmeticException("overflow: can't negate"); [EOL]         } [EOL]         numerator = -numerator; [EOL]         denominator = -denominator; [EOL]     } [EOL]     return new Fraction(numerator, denominator); [EOL] } 
 [LINE] throw new ArithmeticException("The denominator must not be zero"); [LINE] public static Fraction getFraction(final int whole, final int numerator, final int denominator) { [EOL]     if (denominator == 0) { [EOL]         throw new ArithmeticException("The denominator must not be zero"); [EOL]     } [EOL]     if (denominator < 0) { [EOL]         throw new ArithmeticException("The denominator must not be negative"); [EOL]     } [EOL]     if (numerator < 0) { [EOL]         throw new ArithmeticException("The numerator must not be negative"); [EOL]     } [EOL]     long numeratorValue; [EOL]     if (whole < 0) { [EOL]         numeratorValue = whole * (long) denominator - numerator; [EOL]     } else { [EOL]         numeratorValue = whole * (long) denominator + numerator; [EOL]     } [EOL]     if (numeratorValue < Integer.MIN_VALUE || numeratorValue > Integer.MAX_VALUE) { [EOL]         throw new ArithmeticException("Numerator too large to represent as an Integer."); [EOL]     } [EOL]     return new Fraction((int) numeratorValue, denominator); [EOL] } 
 [LINE] final int sign = value < 0 ? -1 : 1; [LINE] public static Fraction getFraction(double value) { [EOL]     final int sign = value < 0 ? -1 : 1; [EOL]     value = Math.abs(value); [EOL]     if (value > Integer.MAX_VALUE || Double.isNaN(value)) { [EOL]         throw new ArithmeticException("The value must not be greater than Integer.MAX_VALUE or NaN"); [EOL]     } [EOL]     final int wholeNumber = (int) value; [EOL]     value -= wholeNumber; [EOL]     int numer0 = 0; [EOL]     int denom0 = 1; [EOL]     int numer1 = 1; [EOL]     int denom1 = 0; [EOL]     int numer2 = 0; [EOL]     int denom2 = 0; [EOL]     int a1 = (int) value; [EOL]     int a2 = 0; [EOL]     double x1 = 1; [EOL]     double x2 = 0; [EOL]     double y1 = value - a1; [EOL]     double y2 = 0; [EOL]     double delta1, delta2 = Double.MAX_VALUE; [EOL]     double fraction; [EOL]     int i = 1; [EOL]     do { [EOL]         delta1 = delta2; [EOL]         a2 = (int) (x1 / y1); [EOL]         x2 = y1; [EOL]         y2 = x1 - a2 * y1; [EOL]         numer2 = a1 * numer1 + numer0; [EOL]         denom2 = a1 * denom1 + denom0; [EOL]         fraction = (double) numer2 / (double) denom2; [EOL]         delta2 = Math.abs(value - fraction); [EOL]         a1 = a2; [EOL]         x1 = x2; [EOL]         y1 = y2; [EOL]         numer0 = numer1; [EOL]         denom0 = denom1; [EOL]         numer1 = numer2; [EOL]         denom1 = denom2; [EOL]         i++; [EOL]     } while (delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25); [EOL]     if (i == 25) { [EOL]         throw new ArithmeticException("Unable to convert double to fraction"); [EOL]     } [EOL]     return getReducedFraction((numer0 + wholeNumber * denom0) * sign, denom0); [EOL] } 
 [LINE] value = Math.abs(value); [LINE] public static Fraction getFraction(double value) { [EOL]     final int sign = value < 0 ? -1 : 1; [EOL]     value = Math.abs(value); [EOL]     if (value > Integer.MAX_VALUE || Double.isNaN(value)) { [EOL]         throw new ArithmeticException("The value must not be greater than Integer.MAX_VALUE or NaN"); [EOL]     } [EOL]     final int wholeNumber = (int) value; [EOL]     value -= wholeNumber; [EOL]     int numer0 = 0; [EOL]     int denom0 = 1; [EOL]     int numer1 = 1; [EOL]     int denom1 = 0; [EOL]     int numer2 = 0; [EOL]     int denom2 = 0; [EOL]     int a1 = (int) value; [EOL]     int a2 = 0; [EOL]     double x1 = 1; [EOL]     double x2 = 0; [EOL]     double y1 = value - a1; [EOL]     double y2 = 0; [EOL]     double delta1, delta2 = Double.MAX_VALUE; [EOL]     double fraction; [EOL]     int i = 1; [EOL]     do { [EOL]         delta1 = delta2; [EOL]         a2 = (int) (x1 / y1); [EOL]         x2 = y1; [EOL]         y2 = x1 - a2 * y1; [EOL]         numer2 = a1 * numer1 + numer0; [EOL]         denom2 = a1 * denom1 + denom0; [EOL]         fraction = (double) numer2 / (double) denom2; [EOL]         delta2 = Math.abs(value - fraction); [EOL]         a1 = a2; [EOL]         x1 = x2; [EOL]         y1 = y2; [EOL]         numer0 = numer1; [EOL]         denom0 = denom1; [EOL]         numer1 = numer2; [EOL]         denom1 = denom2; [EOL]         i++; [EOL]     } while (delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25); [EOL]     if (i == 25) { [EOL]         throw new ArithmeticException("Unable to convert double to fraction"); [EOL]     } [EOL]     return getReducedFraction((numer0 + wholeNumber * denom0) * sign, denom0); [EOL] } 
 [LINE] delta2 = Math.abs(value - fraction); [LINE] public static Fraction getFraction(double value) { [EOL]     final int sign = value < 0 ? -1 : 1; [EOL]     value = Math.abs(value); [EOL]     if (value > Integer.MAX_VALUE || Double.isNaN(value)) { [EOL]         throw new ArithmeticException("The value must not be greater than Integer.MAX_VALUE or NaN"); [EOL]     } [EOL]     final int wholeNumber = (int) value; [EOL]     value -= wholeNumber; [EOL]     int numer0 = 0; [EOL]     int denom0 = 1; [EOL]     int numer1 = 1; [EOL]     int denom1 = 0; [EOL]     int numer2 = 0; [EOL]     int denom2 = 0; [EOL]     int a1 = (int) value; [EOL]     int a2 = 0; [EOL]     double x1 = 1; [EOL]     double x2 = 0; [EOL]     double y1 = value - a1; [EOL]     double y2 = 0; [EOL]     double delta1, delta2 = Double.MAX_VALUE; [EOL]     double fraction; [EOL]     int i = 1; [EOL]     do { [EOL]         delta1 = delta2; [EOL]         a2 = (int) (x1 / y1); [EOL]         x2 = y1; [EOL]         y2 = x1 - a2 * y1; [EOL]         numer2 = a1 * numer1 + numer0; [EOL]         denom2 = a1 * denom1 + denom0; [EOL]         fraction = (double) numer2 / (double) denom2; [EOL]         delta2 = Math.abs(value - fraction); [EOL]         a1 = a2; [EOL]         x1 = x2; [EOL]         y1 = y2; [EOL]         numer0 = numer1; [EOL]         denom0 = denom1; [EOL]         numer1 = numer2; [EOL]         denom1 = denom2; [EOL]         i++; [EOL]     } while (delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25); [EOL]     if (i == 25) { [EOL]         throw new ArithmeticException("Unable to convert double to fraction"); [EOL]     } [EOL]     return getReducedFraction((numer0 + wholeNumber * denom0) * sign, denom0); [EOL] } 
 [LINE] x1 = x2; [LINE] public static Fraction getFraction(double value) { [EOL]     final int sign = value < 0 ? -1 : 1; [EOL]     value = Math.abs(value); [EOL]     if (value > Integer.MAX_VALUE || Double.isNaN(value)) { [EOL]         throw new ArithmeticException("The value must not be greater than Integer.MAX_VALUE or NaN"); [EOL]     } [EOL]     final int wholeNumber = (int) value; [EOL]     value -= wholeNumber; [EOL]     int numer0 = 0; [EOL]     int denom0 = 1; [EOL]     int numer1 = 1; [EOL]     int denom1 = 0; [EOL]     int numer2 = 0; [EOL]     int denom2 = 0; [EOL]     int a1 = (int) value; [EOL]     int a2 = 0; [EOL]     double x1 = 1; [EOL]     double x2 = 0; [EOL]     double y1 = value - a1; [EOL]     double y2 = 0; [EOL]     double delta1, delta2 = Double.MAX_VALUE; [EOL]     double fraction; [EOL]     int i = 1; [EOL]     do { [EOL]         delta1 = delta2; [EOL]         a2 = (int) (x1 / y1); [EOL]         x2 = y1; [EOL]         y2 = x1 - a2 * y1; [EOL]         numer2 = a1 * numer1 + numer0; [EOL]         denom2 = a1 * denom1 + denom0; [EOL]         fraction = (double) numer2 / (double) denom2; [EOL]         delta2 = Math.abs(value - fraction); [EOL]         a1 = a2; [EOL]         x1 = x2; [EOL]         y1 = y2; [EOL]         numer0 = numer1; [EOL]         denom0 = denom1; [EOL]         numer1 = numer2; [EOL]         denom1 = denom2; [EOL]         i++; [EOL]     } while (delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25); [EOL]     if (i == 25) { [EOL]         throw new ArithmeticException("Unable to convert double to fraction"); [EOL]     } [EOL]     return getReducedFraction((numer0 + wholeNumber * denom0) * sign, denom0); [EOL] } 
 [LINE] y1 = y2; [LINE] public static Fraction getFraction(double value) { [EOL]     final int sign = value < 0 ? -1 : 1; [EOL]     value = Math.abs(value); [EOL]     if (value > Integer.MAX_VALUE || Double.isNaN(value)) { [EOL]         throw new ArithmeticException("The value must not be greater than Integer.MAX_VALUE or NaN"); [EOL]     } [EOL]     final int wholeNumber = (int) value; [EOL]     value -= wholeNumber; [EOL]     int numer0 = 0; [EOL]     int denom0 = 1; [EOL]     int numer1 = 1; [EOL]     int denom1 = 0; [EOL]     int numer2 = 0; [EOL]     int denom2 = 0; [EOL]     int a1 = (int) value; [EOL]     int a2 = 0; [EOL]     double x1 = 1; [EOL]     double x2 = 0; [EOL]     double y1 = value - a1; [EOL]     double y2 = 0; [EOL]     double delta1, delta2 = Double.MAX_VALUE; [EOL]     double fraction; [EOL]     int i = 1; [EOL]     do { [EOL]         delta1 = delta2; [EOL]         a2 = (int) (x1 / y1); [EOL]         x2 = y1; [EOL]         y2 = x1 - a2 * y1; [EOL]         numer2 = a1 * numer1 + numer0; [EOL]         denom2 = a1 * denom1 + denom0; [EOL]         fraction = (double) numer2 / (double) denom2; [EOL]         delta2 = Math.abs(value - fraction); [EOL]         a1 = a2; [EOL]         x1 = x2; [EOL]         y1 = y2; [EOL]         numer0 = numer1; [EOL]         denom0 = denom1; [EOL]         numer1 = numer2; [EOL]         denom1 = denom2; [EOL]         i++; [EOL]     } while (delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25); [EOL]     if (i == 25) { [EOL]         throw new ArithmeticException("Unable to convert double to fraction"); [EOL]     } [EOL]     return getReducedFraction((numer0 + wholeNumber * denom0) * sign, denom0); [EOL] } 
 [LINE] denom0 = denom1; [LINE] public static Fraction getFraction(double value) { [EOL]     final int sign = value < 0 ? -1 : 1; [EOL]     value = Math.abs(value); [EOL]     if (value > Integer.MAX_VALUE || Double.isNaN(value)) { [EOL]         throw new ArithmeticException("The value must not be greater than Integer.MAX_VALUE or NaN"); [EOL]     } [EOL]     final int wholeNumber = (int) value; [EOL]     value -= wholeNumber; [EOL]     int numer0 = 0; [EOL]     int denom0 = 1; [EOL]     int numer1 = 1; [EOL]     int denom1 = 0; [EOL]     int numer2 = 0; [EOL]     int denom2 = 0; [EOL]     int a1 = (int) value; [EOL]     int a2 = 0; [EOL]     double x1 = 1; [EOL]     double x2 = 0; [EOL]     double y1 = value - a1; [EOL]     double y2 = 0; [EOL]     double delta1, delta2 = Double.MAX_VALUE; [EOL]     double fraction; [EOL]     int i = 1; [EOL]     do { [EOL]         delta1 = delta2; [EOL]         a2 = (int) (x1 / y1); [EOL]         x2 = y1; [EOL]         y2 = x1 - a2 * y1; [EOL]         numer2 = a1 * numer1 + numer0; [EOL]         denom2 = a1 * denom1 + denom0; [EOL]         fraction = (double) numer2 / (double) denom2; [EOL]         delta2 = Math.abs(value - fraction); [EOL]         a1 = a2; [EOL]         x1 = x2; [EOL]         y1 = y2; [EOL]         numer0 = numer1; [EOL]         denom0 = denom1; [EOL]         numer1 = numer2; [EOL]         denom1 = denom2; [EOL]         i++; [EOL]     } while (delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25); [EOL]     if (i == 25) { [EOL]         throw new ArithmeticException("Unable to convert double to fraction"); [EOL]     } [EOL]     return getReducedFraction((numer0 + wholeNumber * denom0) * sign, denom0); [EOL] } 
 [LINE] if (i == 25) { [LINE] public static Fraction getFraction(double value) { [EOL]     final int sign = value < 0 ? -1 : 1; [EOL]     value = Math.abs(value); [EOL]     if (value > Integer.MAX_VALUE || Double.isNaN(value)) { [EOL]         throw new ArithmeticException("The value must not be greater than Integer.MAX_VALUE or NaN"); [EOL]     } [EOL]     final int wholeNumber = (int) value; [EOL]     value -= wholeNumber; [EOL]     int numer0 = 0; [EOL]     int denom0 = 1; [EOL]     int numer1 = 1; [EOL]     int denom1 = 0; [EOL]     int numer2 = 0; [EOL]     int denom2 = 0; [EOL]     int a1 = (int) value; [EOL]     int a2 = 0; [EOL]     double x1 = 1; [EOL]     double x2 = 0; [EOL]     double y1 = value - a1; [EOL]     double y2 = 0; [EOL]     double delta1, delta2 = Double.MAX_VALUE; [EOL]     double fraction; [EOL]     int i = 1; [EOL]     do { [EOL]         delta1 = delta2; [EOL]         a2 = (int) (x1 / y1); [EOL]         x2 = y1; [EOL]         y2 = x1 - a2 * y1; [EOL]         numer2 = a1 * numer1 + numer0; [EOL]         denom2 = a1 * denom1 + denom0; [EOL]         fraction = (double) numer2 / (double) denom2; [EOL]         delta2 = Math.abs(value - fraction); [EOL]         a1 = a2; [EOL]         x1 = x2; [EOL]         y1 = y2; [EOL]         numer0 = numer1; [EOL]         denom0 = denom1; [EOL]         numer1 = numer2; [EOL]         denom1 = denom2; [EOL]         i++; [EOL]     } while (delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25); [EOL]     if (i == 25) { [EOL]         throw new ArithmeticException("Unable to convert double to fraction"); [EOL]     } [EOL]     return getReducedFraction((numer0 + wholeNumber * denom0) * sign, denom0); [EOL] } 
 [LINE] if (str == null) { [LINE] public static Fraction getFraction(String str) { [EOL]     if (str == null) { [EOL]         throw new IllegalArgumentException("The string must not be null"); [EOL]     } [EOL]     int pos = str.indexOf('.'); [EOL]     if (pos >= 0) { [EOL]         return getFraction(Double.parseDouble(str)); [EOL]     } [EOL]     pos = str.indexOf(' '); [EOL]     if (pos > 0) { [EOL]         final int whole = Integer.parseInt(str.substring(0, pos)); [EOL]         str = str.substring(pos + 1); [EOL]         pos = str.indexOf('/'); [EOL]         if (pos < 0) { [EOL]             throw new NumberFormatException("The fraction could not be parsed as the format X Y/Z"); [EOL]         } else { [EOL]             final int numer = Integer.parseInt(str.substring(0, pos)); [EOL]             final int denom = Integer.parseInt(str.substring(pos + 1)); [EOL]             return getFraction(whole, numer, denom); [EOL]         } [EOL]     } [EOL]     pos = str.indexOf('/'); [EOL]     if (pos < 0) { [EOL]         return getFraction(Integer.parseInt(str), 1); [EOL]     } else { [EOL]         final int numer = Integer.parseInt(str.substring(0, pos)); [EOL]         final int denom = Integer.parseInt(str.substring(pos + 1)); [EOL]         return getFraction(numer, denom); [EOL]     } [EOL] } 
 [LINE] return getFraction(Double.parseDouble(str)); [LINE] public static Fraction getFraction(String str) { [EOL]     if (str == null) { [EOL]         throw new IllegalArgumentException("The string must not be null"); [EOL]     } [EOL]     int pos = str.indexOf('.'); [EOL]     if (pos >= 0) { [EOL]         return getFraction(Double.parseDouble(str)); [EOL]     } [EOL]     pos = str.indexOf(' '); [EOL]     if (pos > 0) { [EOL]         final int whole = Integer.parseInt(str.substring(0, pos)); [EOL]         str = str.substring(pos + 1); [EOL]         pos = str.indexOf('/'); [EOL]         if (pos < 0) { [EOL]             throw new NumberFormatException("The fraction could not be parsed as the format X Y/Z"); [EOL]         } else { [EOL]             final int numer = Integer.parseInt(str.substring(0, pos)); [EOL]             final int denom = Integer.parseInt(str.substring(pos + 1)); [EOL]             return getFraction(whole, numer, denom); [EOL]         } [EOL]     } [EOL]     pos = str.indexOf('/'); [EOL]     if (pos < 0) { [EOL]         return getFraction(Integer.parseInt(str), 1); [EOL]     } else { [EOL]         final int numer = Integer.parseInt(str.substring(0, pos)); [EOL]         final int denom = Integer.parseInt(str.substring(pos + 1)); [EOL]         return getFraction(numer, denom); [EOL]     } [EOL] } 
 [LINE] if (pos > 0) { [LINE] public static Fraction getFraction(String str) { [EOL]     if (str == null) { [EOL]         throw new IllegalArgumentException("The string must not be null"); [EOL]     } [EOL]     int pos = str.indexOf('.'); [EOL]     if (pos >= 0) { [EOL]         return getFraction(Double.parseDouble(str)); [EOL]     } [EOL]     pos = str.indexOf(' '); [EOL]     if (pos > 0) { [EOL]         final int whole = Integer.parseInt(str.substring(0, pos)); [EOL]         str = str.substring(pos + 1); [EOL]         pos = str.indexOf('/'); [EOL]         if (pos < 0) { [EOL]             throw new NumberFormatException("The fraction could not be parsed as the format X Y/Z"); [EOL]         } else { [EOL]             final int numer = Integer.parseInt(str.substring(0, pos)); [EOL]             final int denom = Integer.parseInt(str.substring(pos + 1)); [EOL]             return getFraction(whole, numer, denom); [EOL]         } [EOL]     } [EOL]     pos = str.indexOf('/'); [EOL]     if (pos < 0) { [EOL]         return getFraction(Integer.parseInt(str), 1); [EOL]     } else { [EOL]         final int numer = Integer.parseInt(str.substring(0, pos)); [EOL]         final int denom = Integer.parseInt(str.substring(pos + 1)); [EOL]         return getFraction(numer, denom); [EOL]     } [EOL] } 
 [LINE] return getFraction(numer, denom); [LINE] public static Fraction getFraction(String str) { [EOL]     if (str == null) { [EOL]         throw new IllegalArgumentException("The string must not be null"); [EOL]     } [EOL]     int pos = str.indexOf('.'); [EOL]     if (pos >= 0) { [EOL]         return getFraction(Double.parseDouble(str)); [EOL]     } [EOL]     pos = str.indexOf(' '); [EOL]     if (pos > 0) { [EOL]         final int whole = Integer.parseInt(str.substring(0, pos)); [EOL]         str = str.substring(pos + 1); [EOL]         pos = str.indexOf('/'); [EOL]         if (pos < 0) { [EOL]             throw new NumberFormatException("The fraction could not be parsed as the format X Y/Z"); [EOL]         } else { [EOL]             final int numer = Integer.parseInt(str.substring(0, pos)); [EOL]             final int denom = Integer.parseInt(str.substring(pos + 1)); [EOL]             return getFraction(whole, numer, denom); [EOL]         } [EOL]     } [EOL]     pos = str.indexOf('/'); [EOL]     if (pos < 0) { [EOL]         return getFraction(Integer.parseInt(str), 1); [EOL]     } else { [EOL]         final int numer = Integer.parseInt(str.substring(0, pos)); [EOL]         final int denom = Integer.parseInt(str.substring(pos + 1)); [EOL]         return getFraction(numer, denom); [EOL]     } [EOL] } 
 [LINE] return (long) numerator / denominator; [LINE] @Override [EOL] public long longValue() { [EOL]     return (long) numerator / denominator; [EOL] } 
 [LINE] @Override [LINE] @Override [EOL] public long longValue() { [EOL]     return (long) numerator / denominator; [EOL] } 
 [LINE] return (float) numerator / (float) denominator; [LINE] @Override [EOL] public float floatValue() { [EOL]     return (float) numerator / (float) denominator; [EOL] } 
 [LINE] return (double) numerator / (double) denominator; [LINE] @Override [EOL] public double doubleValue() { [EOL]     return (double) numerator / (double) denominator; [EOL] } 
 [LINE] if (numerator == 0) { [LINE] public Fraction reduce() { [EOL]     if (numerator == 0) { [EOL]         return equals(ZERO) ? this : ZERO; [EOL]     } [EOL]     final int gcd = greatestCommonDivisor(Math.abs(numerator), denominator); [EOL]     if (gcd == 1) { [EOL]         return this; [EOL]     } [EOL]     return Fraction.getFraction(numerator / gcd, denominator / gcd); [EOL] } 
 [LINE] if (power == 1) { [LINE] public Fraction pow(final int power) { [EOL]     if (power == 1) { [EOL]         return this; [EOL]     } else if (power == 0) { [EOL]         return ONE; [EOL]     } else if (power < 0) { [EOL]         if (power == Integer.MIN_VALUE) { [EOL]             return this.invert().pow(2).pow(-(power / 2)); [EOL]         } [EOL]         return this.invert().pow(-power); [EOL]     } else { [EOL]         final Fraction f = this.multiplyBy(this); [EOL]         if (power % 2 == 0) { [EOL]             return f.pow(power / 2); [EOL]         } else { [EOL]             return f.pow(power / 2).multiplyBy(this); [EOL]         } [EOL]     } [EOL] } 
 [LINE] if (u == 0 || v == 0) { [LINE] private static int greatestCommonDivisor(int u, int v) { [EOL]     if (u == 0 || v == 0) { [EOL]         if (u == Integer.MIN_VALUE || v == Integer.MIN_VALUE) { [EOL]             throw new ArithmeticException("overflow: gcd is 2^31"); [EOL]         } [EOL]         return Math.abs(u) + Math.abs(v); [EOL]     } [EOL]     if (Math.abs(u) == 1 || Math.abs(v) == 1) { [EOL]         return 1; [EOL]     } [EOL]     if (u > 0) { [EOL]         u = -u; [EOL]     } [EOL]     if (v > 0) { [EOL]         v = -v; [EOL]     } [EOL]     int k = 0; [EOL]     while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { [EOL]         u /= 2; [EOL]         v /= 2; [EOL]         k++; [EOL]     } [EOL]     if (k == 31) { [EOL]         throw new ArithmeticException("overflow: gcd is 2^31"); [EOL]     } [EOL]     int t = (u & 1) == 1 ? v : -(u / 2); [EOL]     do { [EOL]         while ((t & 1) == 0) { [EOL]             t /= 2; [EOL]         } [EOL]         if (t > 0) { [EOL]             u = -t; [EOL]         } else { [EOL]             v = t; [EOL]         } [EOL]         t = (v - u) / 2; [EOL]     } while (t != 0); [EOL]     return -u * (1 << k); [EOL] } 
 [LINE] throw new IllegalArgumentException("The fraction must not be null"); [LINE] private Fraction addSub(final Fraction fraction, final boolean isAdd) { [EOL]     if (fraction == null) { [EOL]         throw new IllegalArgumentException("The fraction must not be null"); [EOL]     } [EOL]     if (numerator == 0) { [EOL]         return isAdd ? fraction : fraction.negate(); [EOL]     } [EOL]     if (fraction.numerator == 0) { [EOL]         return this; [EOL]     } [EOL]     final int d1 = greatestCommonDivisor(denominator, fraction.denominator); [EOL]     if (d1 == 1) { [EOL]         final int uvp = mulAndCheck(numerator, fraction.denominator); [EOL]         final int upv = mulAndCheck(fraction.numerator, denominator); [EOL]         return new Fraction(isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv), mulPosAndCheck(denominator, fraction.denominator)); [EOL]     } [EOL]     final BigInteger uvp = BigInteger.valueOf(numerator).multiply(BigInteger.valueOf(fraction.denominator / d1)); [EOL]     final BigInteger upv = BigInteger.valueOf(fraction.numerator).multiply(BigInteger.valueOf(denominator / d1)); [EOL]     final BigInteger t = isAdd ? uvp.add(upv) : uvp.subtract(upv); [EOL]     final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue(); [EOL]     final int d2 = tmodd1 == 0 ? d1 : greatestCommonDivisor(tmodd1, d1); [EOL]     final BigInteger w = t.divide(BigInteger.valueOf(d2)); [EOL]     if (w.bitLength() > 31) { [EOL]         throw new ArithmeticException("overflow: numerator too large after multiply"); [EOL]     } [EOL]     return new Fraction(w.intValue(), mulPosAndCheck(denominator / d1, fraction.denominator / d2)); [EOL] } 
 [LINE] final int d1 = greatestCommonDivisor(denominator, fraction.denominator); [LINE] private Fraction addSub(final Fraction fraction, final boolean isAdd) { [EOL]     if (fraction == null) { [EOL]         throw new IllegalArgumentException("The fraction must not be null"); [EOL]     } [EOL]     if (numerator == 0) { [EOL]         return isAdd ? fraction : fraction.negate(); [EOL]     } [EOL]     if (fraction.numerator == 0) { [EOL]         return this; [EOL]     } [EOL]     final int d1 = greatestCommonDivisor(denominator, fraction.denominator); [EOL]     if (d1 == 1) { [EOL]         final int uvp = mulAndCheck(numerator, fraction.denominator); [EOL]         final int upv = mulAndCheck(fraction.numerator, denominator); [EOL]         return new Fraction(isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv), mulPosAndCheck(denominator, fraction.denominator)); [EOL]     } [EOL]     final BigInteger uvp = BigInteger.valueOf(numerator).multiply(BigInteger.valueOf(fraction.denominator / d1)); [EOL]     final BigInteger upv = BigInteger.valueOf(fraction.numerator).multiply(BigInteger.valueOf(denominator / d1)); [EOL]     final BigInteger t = isAdd ? uvp.add(upv) : uvp.subtract(upv); [EOL]     final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue(); [EOL]     final int d2 = tmodd1 == 0 ? d1 : greatestCommonDivisor(tmodd1, d1); [EOL]     final BigInteger w = t.divide(BigInteger.valueOf(d2)); [EOL]     if (w.bitLength() > 31) { [EOL]         throw new ArithmeticException("overflow: numerator too large after multiply"); [EOL]     } [EOL]     return new Fraction(w.intValue(), mulPosAndCheck(denominator / d1, fraction.denominator / d2)); [EOL] } 
 [LINE] final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue(); [LINE] private Fraction addSub(final Fraction fraction, final boolean isAdd) { [EOL]     if (fraction == null) { [EOL]         throw new IllegalArgumentException("The fraction must not be null"); [EOL]     } [EOL]     if (numerator == 0) { [EOL]         return isAdd ? fraction : fraction.negate(); [EOL]     } [EOL]     if (fraction.numerator == 0) { [EOL]         return this; [EOL]     } [EOL]     final int d1 = greatestCommonDivisor(denominator, fraction.denominator); [EOL]     if (d1 == 1) { [EOL]         final int uvp = mulAndCheck(numerator, fraction.denominator); [EOL]         final int upv = mulAndCheck(fraction.numerator, denominator); [EOL]         return new Fraction(isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv), mulPosAndCheck(denominator, fraction.denominator)); [EOL]     } [EOL]     final BigInteger uvp = BigInteger.valueOf(numerator).multiply(BigInteger.valueOf(fraction.denominator / d1)); [EOL]     final BigInteger upv = BigInteger.valueOf(fraction.numerator).multiply(BigInteger.valueOf(denominator / d1)); [EOL]     final BigInteger t = isAdd ? uvp.add(upv) : uvp.subtract(upv); [EOL]     final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue(); [EOL]     final int d2 = tmodd1 == 0 ? d1 : greatestCommonDivisor(tmodd1, d1); [EOL]     final BigInteger w = t.divide(BigInteger.valueOf(d2)); [EOL]     if (w.bitLength() > 31) { [EOL]         throw new ArithmeticException("overflow: numerator too large after multiply"); [EOL]     } [EOL]     return new Fraction(w.intValue(), mulPosAndCheck(denominator / d1, fraction.denominator / d2)); [EOL] } 
 [LINE] if (w.bitLength() > 31) { [LINE] private Fraction addSub(final Fraction fraction, final boolean isAdd) { [EOL]     if (fraction == null) { [EOL]         throw new IllegalArgumentException("The fraction must not be null"); [EOL]     } [EOL]     if (numerator == 0) { [EOL]         return isAdd ? fraction : fraction.negate(); [EOL]     } [EOL]     if (fraction.numerator == 0) { [EOL]         return this; [EOL]     } [EOL]     final int d1 = greatestCommonDivisor(denominator, fraction.denominator); [EOL]     if (d1 == 1) { [EOL]         final int uvp = mulAndCheck(numerator, fraction.denominator); [EOL]         final int upv = mulAndCheck(fraction.numerator, denominator); [EOL]         return new Fraction(isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv), mulPosAndCheck(denominator, fraction.denominator)); [EOL]     } [EOL]     final BigInteger uvp = BigInteger.valueOf(numerator).multiply(BigInteger.valueOf(fraction.denominator / d1)); [EOL]     final BigInteger upv = BigInteger.valueOf(fraction.numerator).multiply(BigInteger.valueOf(denominator / d1)); [EOL]     final BigInteger t = isAdd ? uvp.add(upv) : uvp.subtract(upv); [EOL]     final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue(); [EOL]     final int d2 = tmodd1 == 0 ? d1 : greatestCommonDivisor(tmodd1, d1); [EOL]     final BigInteger w = t.divide(BigInteger.valueOf(d2)); [EOL]     if (w.bitLength() > 31) { [EOL]         throw new ArithmeticException("overflow: numerator too large after multiply"); [EOL]     } [EOL]     return new Fraction(w.intValue(), mulPosAndCheck(denominator / d1, fraction.denominator / d2)); [EOL] } 
 [LINE] throw new ArithmeticException [LINE] private Fraction addSub(final Fraction fraction, final boolean isAdd) { [EOL]     if (fraction == null) { [EOL]         throw new IllegalArgumentException("The fraction must not be null"); [EOL]     } [EOL]     if (numerator == 0) { [EOL]         return isAdd ? fraction : fraction.negate(); [EOL]     } [EOL]     if (fraction.numerator == 0) { [EOL]         return this; [EOL]     } [EOL]     final int d1 = greatestCommonDivisor(denominator, fraction.denominator); [EOL]     if (d1 == 1) { [EOL]         final int uvp = mulAndCheck(numerator, fraction.denominator); [EOL]         final int upv = mulAndCheck(fraction.numerator, denominator); [EOL]         return new Fraction(isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv), mulPosAndCheck(denominator, fraction.denominator)); [EOL]     } [EOL]     final BigInteger uvp = BigInteger.valueOf(numerator).multiply(BigInteger.valueOf(fraction.denominator / d1)); [EOL]     final BigInteger upv = BigInteger.valueOf(fraction.numerator).multiply(BigInteger.valueOf(denominator / d1)); [EOL]     final BigInteger t = isAdd ? uvp.add(upv) : uvp.subtract(upv); [EOL]     final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue(); [EOL]     final int d2 = tmodd1 == 0 ? d1 : greatestCommonDivisor(tmodd1, d1); [EOL]     final BigInteger w = t.divide(BigInteger.valueOf(d2)); [EOL]     if (w.bitLength() > 31) { [EOL]         throw new ArithmeticException("overflow: numerator too large after multiply"); [EOL]     } [EOL]     return new Fraction(w.intValue(), mulPosAndCheck(denominator / d1, fraction.denominator / d2)); [EOL] } 
 [LINE] throw new IllegalArgumentException("The fraction must not be null"); [LINE] public Fraction multiplyBy(final Fraction fraction) { [EOL]     if (fraction == null) { [EOL]         throw new IllegalArgumentException("The fraction must not be null"); [EOL]     } [EOL]     if (numerator == 0 || fraction.numerator == 0) { [EOL]         return ZERO; [EOL]     } [EOL]     final int d1 = greatestCommonDivisor(numerator, fraction.denominator); [EOL]     final int d2 = greatestCommonDivisor(fraction.numerator, denominator); [EOL]     return getReducedFraction(mulAndCheck(numerator / d1, fraction.numerator / d2), mulPosAndCheck(denominator / d2, fraction.denominator / d1)); [EOL] } 
 [LINE] throw new IllegalArgumentException("The fraction must not be null"); [LINE] public Fraction divideBy(final Fraction fraction) { [EOL]     if (fraction == null) { [EOL]         throw new IllegalArgumentException("The fraction must not be null"); [EOL]     } [EOL]     if (fraction.numerator == 0) { [EOL]         throw new ArithmeticException("The fraction to divide by must not be zero"); [EOL]     } [EOL]     return multiplyBy(fraction.invert()); [EOL] } 
 [LINE] if (obj instanceof Fraction == false) { [LINE] @Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof Fraction == false) { [EOL]         return false; [EOL]     } [EOL]     final Fraction other = (Fraction) obj; [EOL]     return getNumerator() == other.getNumerator() && getDenominator() == other.getDenominator(); [EOL] } 
 [LINE] return 0; [LINE] @Override [EOL] public int compareTo(final Fraction other) { [EOL]     if (this == other) { [EOL]         return 0; [EOL]     } [EOL]     if (numerator == other.numerator && denominator == other.denominator) { [EOL]         return 0; [EOL]     } [EOL]     final long first = (long) numerator * (long) other.denominator; [EOL]     final long second = (long) other.numerator * (long) denominator; [EOL]     if (first == second) { [EOL]         return 0; [EOL]     } else if (first < second) { [EOL]         return -1; [EOL]     } else { [EOL]         return 1; [EOL]     } [EOL] } 
 [LINE] if (numerator == other.numerator && denominator == other.denominator) { [LINE] @Override [EOL] public int compareTo(final Fraction other) { [EOL]     if (this == other) { [EOL]         return 0; [EOL]     } [EOL]     if (numerator == other.numerator && denominator == other.denominator) { [EOL]         return 0; [EOL]     } [EOL]     final long first = (long) numerator * (long) other.denominator; [EOL]     final long second = (long) other.numerator * (long) denominator; [EOL]     if (first == second) { [EOL]         return 0; [EOL]     } else if (first < second) { [EOL]         return -1; [EOL]     } else { [EOL]         return 1; [EOL]     } [EOL] } 
 [LINE] return 0; [LINE] @Override [EOL] public int compareTo(final Fraction other) { [EOL]     if (this == other) { [EOL]         return 0; [EOL]     } [EOL]     if (numerator == other.numerator && denominator == other.denominator) { [EOL]         return 0; [EOL]     } [EOL]     final long first = (long) numerator * (long) other.denominator; [EOL]     final long second = (long) other.numerator * (long) denominator; [EOL]     if (first == second) { [EOL]         return 0; [EOL]     } else if (first < second) { [EOL]         return -1; [EOL]     } else { [EOL]         return 1; [EOL]     } [EOL] } 
 [LINE] final long second = (long) other.numerator * (long) denominator; [LINE] @Override [EOL] public int compareTo(final Fraction other) { [EOL]     if (this == other) { [EOL]         return 0; [EOL]     } [EOL]     if (numerator == other.numerator && denominator == other.denominator) { [EOL]         return 0; [EOL]     } [EOL]     final long first = (long) numerator * (long) other.denominator; [EOL]     final long second = (long) other.numerator * (long) denominator; [EOL]     if (first == second) { [EOL]         return 0; [EOL]     } else if (first < second) { [EOL]         return -1; [EOL]     } else { [EOL]         return 1; [EOL]     } [EOL] } 
 [LINE] if (properNumerator == 0) { [LINE] public String toProperString() { [EOL]     if (toProperString == null) { [EOL]         if (numerator == 0) { [EOL]             toProperString = "0"; [EOL]         } else if (numerator == denominator) { [EOL]             toProperString = "1"; [EOL]         } else if (numerator == -1 * denominator) { [EOL]             toProperString = "-1"; [EOL]         } else if ((numerator > 0 ? -numerator : numerator) < -denominator) { [EOL]             final int properNumerator = getProperNumerator(); [EOL]             if (properNumerator == 0) { [EOL]                 toProperString = Integer.toString(getProperWhole()); [EOL]             } else { [EOL]                 toProperString = new StringBuilder(32).append(getProperWhole()).append(' ').append(properNumerator).append('/').append(getDenominator()).toString(); [EOL]             } [EOL]         } else { [EOL]             toProperString = new StringBuilder(32).append(getNumerator()).append('/').append(getDenominator()).toString(); [EOL]         } [EOL]     } [EOL]     return toProperString; [EOL] } 
 [LINE] toProperString = Integer.toString(getProperWhole()); [LINE] public String toProperString() { [EOL]     if (toProperString == null) { [EOL]         if (numerator == 0) { [EOL]             toProperString = "0"; [EOL]         } else if (numerator == denominator) { [EOL]             toProperString = "1"; [EOL]         } else if (numerator == -1 * denominator) { [EOL]             toProperString = "-1"; [EOL]         } else if ((numerator > 0 ? -numerator : numerator) < -denominator) { [EOL]             final int properNumerator = getProperNumerator(); [EOL]             if (properNumerator == 0) { [EOL]                 toProperString = Integer.toString(getProperWhole()); [EOL]             } else { [EOL]                 toProperString = new StringBuilder(32).append(getProperWhole()).append(' ').append(properNumerator).append('/').append(getDenominator()).toString(); [EOL]             } [EOL]         } else { [EOL]             toProperString = new StringBuilder(32).append(getNumerator()).append('/').append(getDenominator()).toString(); [EOL]         } [EOL]     } [EOL]     return toProperString; [EOL] } 
 [LINE] toProperString = new StringBuilder(32) [LINE] public String toProperString() { [EOL]     if (toProperString == null) { [EOL]         if (numerator == 0) { [EOL]             toProperString = "0"; [EOL]         } else if (numerator == denominator) { [EOL]             toProperString = "1"; [EOL]         } else if (numerator == -1 * denominator) { [EOL]             toProperString = "-1"; [EOL]         } else if ((numerator > 0 ? -numerator : numerator) < -denominator) { [EOL]             final int properNumerator = getProperNumerator(); [EOL]             if (properNumerator == 0) { [EOL]                 toProperString = Integer.toString(getProperWhole()); [EOL]             } else { [EOL]                 toProperString = new StringBuilder(32).append(getProperWhole()).append(' ').append(properNumerator).append('/').append(getDenominator()).toString(); [EOL]             } [EOL]         } else { [EOL]             toProperString = new StringBuilder(32).append(getNumerator()).append('/').append(getDenominator()).toString(); [EOL]         } [EOL]     } [EOL]     return toProperString; [EOL] } 
lang3/Conversion.java
 [LINE] return 0x8; [LINE] public static int hexDigitMsb0ToInt(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return 0x0; [EOL]         case '1': [EOL]             return 0x8; [EOL]         case '2': [EOL]             return 0x4; [EOL]         case '3': [EOL]             return 0xC; [EOL]         case '4': [EOL]             return 0x2; [EOL]         case '5': [EOL]             return 0xA; [EOL]         case '6': [EOL]             return 0x6; [EOL]         case '7': [EOL]             return 0xE; [EOL]         case '8': [EOL]             return 0x1; [EOL]         case '9': [EOL]             return 0x9; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return 0x5; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return 0xD; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return 0x3; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return 0xB; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return 0x7; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return 0xF; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] return 0x6; [LINE] public static int hexDigitMsb0ToInt(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return 0x0; [EOL]         case '1': [EOL]             return 0x8; [EOL]         case '2': [EOL]             return 0x4; [EOL]         case '3': [EOL]             return 0xC; [EOL]         case '4': [EOL]             return 0x2; [EOL]         case '5': [EOL]             return 0xA; [EOL]         case '6': [EOL]             return 0x6; [EOL]         case '7': [EOL]             return 0xE; [EOL]         case '8': [EOL]             return 0x1; [EOL]         case '9': [EOL]             return 0x9; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return 0x5; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return 0xD; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return 0x3; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return 0xB; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return 0x7; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return 0xF; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] case '9': [LINE] public static int hexDigitMsb0ToInt(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return 0x0; [EOL]         case '1': [EOL]             return 0x8; [EOL]         case '2': [EOL]             return 0x4; [EOL]         case '3': [EOL]             return 0xC; [EOL]         case '4': [EOL]             return 0x2; [EOL]         case '5': [EOL]             return 0xA; [EOL]         case '6': [EOL]             return 0x6; [EOL]         case '7': [EOL]             return 0xE; [EOL]         case '8': [EOL]             return 0x1; [EOL]         case '9': [EOL]             return 0x9; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return 0x5; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return 0xD; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return 0x3; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return 0xB; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return 0x7; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return 0xF; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] return 0xF; [LINE] public static int hexDigitMsb0ToInt(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return 0x0; [EOL]         case '1': [EOL]             return 0x8; [EOL]         case '2': [EOL]             return 0x4; [EOL]         case '3': [EOL]             return 0xC; [EOL]         case '4': [EOL]             return 0x2; [EOL]         case '5': [EOL]             return 0xA; [EOL]         case '6': [EOL]             return 0x6; [EOL]         case '7': [EOL]             return 0xE; [EOL]         case '8': [EOL]             return 0x1; [EOL]         case '9': [EOL]             return 0x9; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return 0x5; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return 0xD; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return 0x3; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return 0xB; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return 0x7; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return 0xF; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] case '4': [LINE] public static boolean[] hexDigitToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '2': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '3': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case '4': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '5': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case '8': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] case '7': [LINE] public static boolean[] hexDigitToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '2': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '3': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case '4': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '5': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case '8': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] case '8': [LINE] public static boolean[] hexDigitToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '2': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '3': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case '4': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '5': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case '8': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] case 'A': [LINE] public static boolean[] hexDigitToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '2': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '3': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case '4': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '5': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case '8': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] case 'E': [LINE] public static boolean[] hexDigitToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '2': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '3': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case '4': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '5': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case '8': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] case '4': [LINE] public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '2': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '3': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case '4': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '5': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case '8': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] case 'D': [LINE] public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '2': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '3': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case '4': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '5': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case '8': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] case 'E': [LINE] public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '2': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '3': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case '4': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '5': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case '8': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] case 'F': [LINE] public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '2': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '3': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case '4': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '5': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case '8': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] } 
 [LINE] return binaryToHexDigit(src, 0); [LINE] public static char binaryToHexDigit(final boolean[] src) { [EOL]     return binaryToHexDigit(src, 0); [EOL] } 
 [LINE] if (src[srcPos]) { [LINE] public static char binaryToHexDigit(final boolean[] src, final int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] } 
 [LINE] if (src[srcPos]) { [LINE] public static char binaryToHexDigit(final boolean[] src, final int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] } 
 [LINE] return 'c'; [LINE] public static char binaryToHexDigit(final boolean[] src, final int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] } 
 [LINE] if (src[srcPos]) { [LINE] public static char binaryToHexDigit(final boolean[] src, final int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] } 
 [LINE] return '7'; [LINE] public static char binaryToHexDigit(final boolean[] src, final int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] } 
 [LINE] return '5'; [LINE] public static char binaryToHexDigit(final boolean[] src, final int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] } 
 [LINE] return '4'; [LINE] public static char binaryToHexDigit(final boolean[] src, final int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] } 
 [LINE] return '3'; [LINE] public static char binaryToHexDigit(final boolean[] src, final int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] } 
 [LINE] return '1'; [LINE] public static char binaryToHexDigit(final boolean[] src, final int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] } 
 [LINE] if (src[srcPos + 2]) { [LINE] public static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos) { [EOL]     if (src.length > 8) { [EOL]         throw new IllegalArgumentException("src.length>8: src.length=" + src.length); [EOL]     } [EOL]     if (src.length - srcPos < 4) { [EOL]         throw new IllegalArgumentException("src.length-srcPos<4: src.length=" + src.length + ", srcPos=" + srcPos); [EOL]     } [EOL]     if (src[srcPos + 3]) { [EOL]         if (src[srcPos + 2]) { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return '7'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return '3'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return '5'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '1'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src[srcPos + 2]) { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'e'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'a'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'c'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '8'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] } 
 [LINE] if (src[srcPos + 1]) { [LINE] public static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos) { [EOL]     if (src.length > 8) { [EOL]         throw new IllegalArgumentException("src.length>8: src.length=" + src.length); [EOL]     } [EOL]     if (src.length - srcPos < 4) { [EOL]         throw new IllegalArgumentException("src.length-srcPos<4: src.length=" + src.length + ", srcPos=" + srcPos); [EOL]     } [EOL]     if (src[srcPos + 3]) { [EOL]         if (src[srcPos + 2]) { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return '7'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return '3'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return '5'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '1'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src[srcPos + 2]) { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'e'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'a'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'c'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '8'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] } 
 [LINE] if (src[srcPos]) { [LINE] public static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos) { [EOL]     if (src.length > 8) { [EOL]         throw new IllegalArgumentException("src.length>8: src.length=" + src.length); [EOL]     } [EOL]     if (src.length - srcPos < 4) { [EOL]         throw new IllegalArgumentException("src.length-srcPos<4: src.length=" + src.length + ", srcPos=" + srcPos); [EOL]     } [EOL]     if (src[srcPos + 3]) { [EOL]         if (src[srcPos + 2]) { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return '7'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return '3'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return '5'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '1'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src[srcPos + 2]) { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'e'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'a'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'c'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '8'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] } 
 [LINE] return 'd'; [LINE] public static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos) { [EOL]     if (src.length > 8) { [EOL]         throw new IllegalArgumentException("src.length>8: src.length=" + src.length); [EOL]     } [EOL]     if (src.length - srcPos < 4) { [EOL]         throw new IllegalArgumentException("src.length-srcPos<4: src.length=" + src.length + ", srcPos=" + srcPos); [EOL]     } [EOL]     if (src[srcPos + 3]) { [EOL]         if (src[srcPos + 2]) { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return '7'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return '3'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return '5'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '1'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src[srcPos + 2]) { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'e'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'a'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'c'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '8'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] } 
 [LINE] return 'e'; [LINE] public static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos) { [EOL]     if (src.length > 8) { [EOL]         throw new IllegalArgumentException("src.length>8: src.length=" + src.length); [EOL]     } [EOL]     if (src.length - srcPos < 4) { [EOL]         throw new IllegalArgumentException("src.length-srcPos<4: src.length=" + src.length + ", srcPos=" + srcPos); [EOL]     } [EOL]     if (src[srcPos + 3]) { [EOL]         if (src[srcPos + 2]) { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return '7'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return '3'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return '5'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '1'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src[srcPos + 2]) { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'e'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'a'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'c'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '8'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] } 
 [LINE] return '6'; [LINE] public static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos) { [EOL]     if (src.length > 8) { [EOL]         throw new IllegalArgumentException("src.length>8: src.length=" + src.length); [EOL]     } [EOL]     if (src.length - srcPos < 4) { [EOL]         throw new IllegalArgumentException("src.length-srcPos<4: src.length=" + src.length + ", srcPos=" + srcPos); [EOL]     } [EOL]     if (src[srcPos + 3]) { [EOL]         if (src[srcPos + 2]) { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return '7'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return '3'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return '5'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '1'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src[srcPos + 2]) { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'e'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'a'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'c'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '8'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] } 
 [LINE] return '4'; [LINE] public static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos) { [EOL]     if (src.length > 8) { [EOL]         throw new IllegalArgumentException("src.length>8: src.length=" + src.length); [EOL]     } [EOL]     if (src.length - srcPos < 4) { [EOL]         throw new IllegalArgumentException("src.length-srcPos<4: src.length=" + src.length + ", srcPos=" + srcPos); [EOL]     } [EOL]     if (src[srcPos + 3]) { [EOL]         if (src[srcPos + 2]) { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return '7'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return '3'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return '5'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '1'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src[srcPos + 2]) { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'e'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'a'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'c'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '8'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] } 
 [LINE] return '8'; [LINE] public static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos) { [EOL]     if (src.length > 8) { [EOL]         throw new IllegalArgumentException("src.length>8: src.length=" + src.length); [EOL]     } [EOL]     if (src.length - srcPos < 4) { [EOL]         throw new IllegalArgumentException("src.length-srcPos<4: src.length=" + src.length + ", srcPos=" + srcPos); [EOL]     } [EOL]     if (src[srcPos + 3]) { [EOL]         if (src[srcPos + 2]) { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return '7'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return '3'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return '5'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '1'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src[srcPos + 2]) { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'e'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'a'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'c'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '8'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] } 
 [LINE] if (src.length == 0) { [LINE] public static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     final int beSrcPos = src.length - 1 - srcPos; [EOL]     final int srcLen = Math.min(4, beSrcPos + 1); [EOL]     final boolean[] paddedSrc = new boolean[4]; [EOL]     System.arraycopy(src, beSrcPos + 1 - srcLen, paddedSrc, 4 - srcLen, srcLen); [EOL]     src = paddedSrc; [EOL]     srcPos = 0; [EOL]     if (src[srcPos]) { [EOL]         if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] } 
 [LINE] if (src.length > srcPos + 1 && src[srcPos + 1]) { [LINE] public static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     final int beSrcPos = src.length - 1 - srcPos; [EOL]     final int srcLen = Math.min(4, beSrcPos + 1); [EOL]     final boolean[] paddedSrc = new boolean[4]; [EOL]     System.arraycopy(src, beSrcPos + 1 - srcLen, paddedSrc, 4 - srcLen, srcLen); [EOL]     src = paddedSrc; [EOL]     srcPos = 0; [EOL]     if (src[srcPos]) { [EOL]         if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] } 
 [LINE] return 'f'; [LINE] public static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     final int beSrcPos = src.length - 1 - srcPos; [EOL]     final int srcLen = Math.min(4, beSrcPos + 1); [EOL]     final boolean[] paddedSrc = new boolean[4]; [EOL]     System.arraycopy(src, beSrcPos + 1 - srcLen, paddedSrc, 4 - srcLen, srcLen); [EOL]     src = paddedSrc; [EOL]     srcPos = 0; [EOL]     if (src[srcPos]) { [EOL]         if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] } 
 [LINE] return 'd'; [LINE] public static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     final int beSrcPos = src.length - 1 - srcPos; [EOL]     final int srcLen = Math.min(4, beSrcPos + 1); [EOL]     final boolean[] paddedSrc = new boolean[4]; [EOL]     System.arraycopy(src, beSrcPos + 1 - srcLen, paddedSrc, 4 - srcLen, srcLen); [EOL]     src = paddedSrc; [EOL]     srcPos = 0; [EOL]     if (src[srcPos]) { [EOL]         if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] } 
 [LINE] return 'a'; [LINE] public static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     final int beSrcPos = src.length - 1 - srcPos; [EOL]     final int srcLen = Math.min(4, beSrcPos + 1); [EOL]     final boolean[] paddedSrc = new boolean[4]; [EOL]     System.arraycopy(src, beSrcPos + 1 - srcLen, paddedSrc, 4 - srcLen, srcLen); [EOL]     src = paddedSrc; [EOL]     srcPos = 0; [EOL]     if (src[srcPos]) { [EOL]         if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] } 
 [LINE] return c; [LINE] public static char intToHexDigit(final int nibble) { [EOL]     final char c = Character.forDigit(nibble, 16); [EOL]     if (c == Character.MIN_VALUE) { [EOL]         throw new IllegalArgumentException("nibble value not between 0 and 15: " + nibble); [EOL]     } [EOL]     return c; [EOL] } 
 [LINE] return '8'; [LINE] public static char intToHexDigitMsb0(final int nibble) { [EOL]     switch(nibble) { [EOL]         case 0x0: [EOL]             return '0'; [EOL]         case 0x1: [EOL]             return '8'; [EOL]         case 0x2: [EOL]             return '4'; [EOL]         case 0x3: [EOL]             return 'c'; [EOL]         case 0x4: [EOL]             return '2'; [EOL]         case 0x5: [EOL]             return 'a'; [EOL]         case 0x6: [EOL]             return '6'; [EOL]         case 0x7: [EOL]             return 'e'; [EOL]         case 0x8: [EOL]             return '1'; [EOL]         case 0x9: [EOL]             return '9'; [EOL]         case 0xA: [EOL]             return '5'; [EOL]         case 0xB: [EOL]             return 'd'; [EOL]         case 0xC: [EOL]             return '3'; [EOL]         case 0xD: [EOL]             return 'b'; [EOL]         case 0xE: [EOL]             return '7'; [EOL]         case 0xF: [EOL]             return 'f'; [EOL]         default: [EOL]             throw new IllegalArgumentException("nibble value not between 0 and 15: " + nibble); [EOL]     } [EOL] } 
 [LINE] return 'a'; [LINE] public static char intToHexDigitMsb0(final int nibble) { [EOL]     switch(nibble) { [EOL]         case 0x0: [EOL]             return '0'; [EOL]         case 0x1: [EOL]             return '8'; [EOL]         case 0x2: [EOL]             return '4'; [EOL]         case 0x3: [EOL]             return 'c'; [EOL]         case 0x4: [EOL]             return '2'; [EOL]         case 0x5: [EOL]             return 'a'; [EOL]         case 0x6: [EOL]             return '6'; [EOL]         case 0x7: [EOL]             return 'e'; [EOL]         case 0x8: [EOL]             return '1'; [EOL]         case 0x9: [EOL]             return '9'; [EOL]         case 0xA: [EOL]             return '5'; [EOL]         case 0xB: [EOL]             return 'd'; [EOL]         case 0xC: [EOL]             return '3'; [EOL]         case 0xD: [EOL]             return 'b'; [EOL]         case 0xE: [EOL]             return '7'; [EOL]         case 0xF: [EOL]             return 'f'; [EOL]         default: [EOL]             throw new IllegalArgumentException("nibble value not between 0 and 15: " + nibble); [EOL]     } [EOL] } 
 [LINE] case 0x7: [LINE] public static char intToHexDigitMsb0(final int nibble) { [EOL]     switch(nibble) { [EOL]         case 0x0: [EOL]             return '0'; [EOL]         case 0x1: [EOL]             return '8'; [EOL]         case 0x2: [EOL]             return '4'; [EOL]         case 0x3: [EOL]             return 'c'; [EOL]         case 0x4: [EOL]             return '2'; [EOL]         case 0x5: [EOL]             return 'a'; [EOL]         case 0x6: [EOL]             return '6'; [EOL]         case 0x7: [EOL]             return 'e'; [EOL]         case 0x8: [EOL]             return '1'; [EOL]         case 0x9: [EOL]             return '9'; [EOL]         case 0xA: [EOL]             return '5'; [EOL]         case 0xB: [EOL]             return 'd'; [EOL]         case 0xC: [EOL]             return '3'; [EOL]         case 0xD: [EOL]             return 'b'; [EOL]         case 0xE: [EOL]             return '7'; [EOL]         case 0xF: [EOL]             return 'f'; [EOL]         default: [EOL]             throw new IllegalArgumentException("nibble value not between 0 and 15: " + nibble); [EOL]     } [EOL] } 
 [LINE] return 'e'; [LINE] public static char intToHexDigitMsb0(final int nibble) { [EOL]     switch(nibble) { [EOL]         case 0x0: [EOL]             return '0'; [EOL]         case 0x1: [EOL]             return '8'; [EOL]         case 0x2: [EOL]             return '4'; [EOL]         case 0x3: [EOL]             return 'c'; [EOL]         case 0x4: [EOL]             return '2'; [EOL]         case 0x5: [EOL]             return 'a'; [EOL]         case 0x6: [EOL]             return '6'; [EOL]         case 0x7: [EOL]             return 'e'; [EOL]         case 0x8: [EOL]             return '1'; [EOL]         case 0x9: [EOL]             return '9'; [EOL]         case 0xA: [EOL]             return '5'; [EOL]         case 0xB: [EOL]             return 'd'; [EOL]         case 0xC: [EOL]             return '3'; [EOL]         case 0xD: [EOL]             return 'b'; [EOL]         case 0xE: [EOL]             return '7'; [EOL]         case 0xF: [EOL]             return 'f'; [EOL]         default: [EOL]             throw new IllegalArgumentException("nibble value not between 0 and 15: " + nibble); [EOL]     } [EOL] } 
 [LINE] case 0xD: [LINE] public static char intToHexDigitMsb0(final int nibble) { [EOL]     switch(nibble) { [EOL]         case 0x0: [EOL]             return '0'; [EOL]         case 0x1: [EOL]             return '8'; [EOL]         case 0x2: [EOL]             return '4'; [EOL]         case 0x3: [EOL]             return 'c'; [EOL]         case 0x4: [EOL]             return '2'; [EOL]         case 0x5: [EOL]             return 'a'; [EOL]         case 0x6: [EOL]             return '6'; [EOL]         case 0x7: [EOL]             return 'e'; [EOL]         case 0x8: [EOL]             return '1'; [EOL]         case 0x9: [EOL]             return '9'; [EOL]         case 0xA: [EOL]             return '5'; [EOL]         case 0xB: [EOL]             return 'd'; [EOL]         case 0xC: [EOL]             return '3'; [EOL]         case 0xD: [EOL]             return 'b'; [EOL]         case 0xE: [EOL]             return '7'; [EOL]         case 0xF: [EOL]             return 'f'; [EOL]         default: [EOL]             throw new IllegalArgumentException("nibble value not between 0 and 15: " + nibble); [EOL]     } [EOL] } 
 [LINE] case 0xF: [LINE] public static char intToHexDigitMsb0(final int nibble) { [EOL]     switch(nibble) { [EOL]         case 0x0: [EOL]             return '0'; [EOL]         case 0x1: [EOL]             return '8'; [EOL]         case 0x2: [EOL]             return '4'; [EOL]         case 0x3: [EOL]             return 'c'; [EOL]         case 0x4: [EOL]             return '2'; [EOL]         case 0x5: [EOL]             return 'a'; [EOL]         case 0x6: [EOL]             return '6'; [EOL]         case 0x7: [EOL]             return 'e'; [EOL]         case 0x8: [EOL]             return '1'; [EOL]         case 0x9: [EOL]             return '9'; [EOL]         case 0xA: [EOL]             return '5'; [EOL]         case 0xB: [EOL]             return 'd'; [EOL]         case 0xC: [EOL]             return '3'; [EOL]         case 0xD: [EOL]             return 'b'; [EOL]         case 0xE: [EOL]             return '7'; [EOL]         case 0xF: [EOL]             return 'f'; [EOL]         default: [EOL]             throw new IllegalArgumentException("nibble value not between 0 and 15: " + nibble); [EOL]     } [EOL] } 
 [LINE] default: [LINE] public static char intToHexDigitMsb0(final int nibble) { [EOL]     switch(nibble) { [EOL]         case 0x0: [EOL]             return '0'; [EOL]         case 0x1: [EOL]             return '8'; [EOL]         case 0x2: [EOL]             return '4'; [EOL]         case 0x3: [EOL]             return 'c'; [EOL]         case 0x4: [EOL]             return '2'; [EOL]         case 0x5: [EOL]             return 'a'; [EOL]         case 0x6: [EOL]             return '6'; [EOL]         case 0x7: [EOL]             return 'e'; [EOL]         case 0x8: [EOL]             return '1'; [EOL]         case 0x9: [EOL]             return '9'; [EOL]         case 0xA: [EOL]             return '5'; [EOL]         case 0xB: [EOL]             return 'd'; [EOL]         case 0xC: [EOL]             return '3'; [EOL]         case 0xD: [EOL]             return 'b'; [EOL]         case 0xE: [EOL]             return '7'; [EOL]         case 0xF: [EOL]             return 'f'; [EOL]         default: [EOL]             throw new IllegalArgumentException("nibble value not between 0 and 15: " + nibble); [EOL]     } [EOL] } 
 [LINE] int out = dstInit; [LINE] public static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nShorts) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nShorts - 1) * 16 + dstPos >= 32) { [EOL]         throw new IllegalArgumentException("(nShorts-1)*16+dstPos is greather or equal to than 32"); [EOL]     } [EOL]     int out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nShorts; i++) { [EOL]         shift = i * 16 + dstPos; [EOL]         final int bits = (0xffff & src[i + srcPos]) << shift; [EOL]         final int mask = 0xffff << shift; [EOL]         out = (out & ~mask) | bits; [EOL]     } [EOL]     return out; [EOL] } 
 [LINE] return dstInit; [LINE] public static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nBytes) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nBytes - 1) * 8 + dstPos >= 64) { [EOL]         throw new IllegalArgumentException("(nBytes-1)*8+dstPos is greather or equal to than 64"); [EOL]     } [EOL]     long out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBytes; i++) { [EOL]         shift = i * 8 + dstPos; [EOL]         final long bits = (0xffL & src[i + srcPos]) << shift; [EOL]         final long mask = 0xffL << shift; [EOL]         out = (out & ~mask) | bits; [EOL]     } [EOL]     return out; [EOL] } 
 [LINE] shift = i * 8 + dstPos; [LINE] public static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nBytes) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nBytes - 1) * 8 + dstPos >= 64) { [EOL]         throw new IllegalArgumentException("(nBytes-1)*8+dstPos is greather or equal to than 64"); [EOL]     } [EOL]     long out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBytes; i++) { [EOL]         shift = i * 8 + dstPos; [EOL]         final long bits = (0xffL & src[i + srcPos]) << shift; [EOL]         final long mask = 0xffL << shift; [EOL]         out = (out & ~mask) | bits; [EOL]     } [EOL]     return out; [EOL] } 
 [LINE] return out; [LINE] public static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nBytes) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nBytes - 1) * 8 + dstPos >= 32) { [EOL]         throw new IllegalArgumentException("(nBytes-1)*8+dstPos is greather or equal to than 32"); [EOL]     } [EOL]     int out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBytes; i++) { [EOL]         shift = i * 8 + dstPos; [EOL]         final int bits = (0xff & src[i + srcPos]) << shift; [EOL]         final int mask = 0xff << shift; [EOL]         out = (out & ~mask) | bits; [EOL]     } [EOL]     return out; [EOL] } 
 [LINE] if ((src.length == 0 && srcPos == 0) || 0 == nBytes) { [LINE] public static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nBytes) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nBytes - 1) * 8 + dstPos >= 16) { [EOL]         throw new IllegalArgumentException("(nBytes-1)*8+dstPos is greather or equal to than 16"); [EOL]     } [EOL]     short out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBytes; i++) { [EOL]         shift = i * 8 + dstPos; [EOL]         final int bits = (0xff & src[i + srcPos]) << shift; [EOL]         final int mask = 0xff << shift; [EOL]         out = (short) ((out & ~mask) | bits); [EOL]     } [EOL]     return out; [EOL] } 
 [LINE] shift = i * 4 + dstPos; [LINE] public static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex) { [EOL]     if (0 == nHex) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nHex - 1) * 4 + dstPos >= 64) { [EOL]         throw new IllegalArgumentException("(nHexs-1)*4+dstPos is greather or equal to than 64"); [EOL]     } [EOL]     long out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nHex; i++) { [EOL]         shift = i * 4 + dstPos; [EOL]         final long bits = (0xfL & hexDigitToInt(src.charAt(i + srcPos))) << shift; [EOL]         final long mask = 0xfL << shift; [EOL]         out = (out & ~mask) | bits; [EOL]     } [EOL]     return out; [EOL] } 
 [LINE] if ((nHex - 1) * 4 + dstPos >= 16) { [LINE] public static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex) { [EOL]     if (0 == nHex) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nHex - 1) * 4 + dstPos >= 16) { [EOL]         throw new IllegalArgumentException("(nHexs-1)*4+dstPos is greather or equal to than 16"); [EOL]     } [EOL]     short out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nHex; i++) { [EOL]         shift = i * 4 + dstPos; [EOL]         final int bits = (0xf & hexDigitToInt(src.charAt(i + srcPos))) << shift; [EOL]         final int mask = 0xf << shift; [EOL]         out = (short) ((out & ~mask) | bits); [EOL]     } [EOL]     return out; [EOL] } 
 [LINE] int shift = 0; [LINE] public static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex) { [EOL]     if (0 == nHex) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nHex - 1) * 4 + dstPos >= 16) { [EOL]         throw new IllegalArgumentException("(nHexs-1)*4+dstPos is greather or equal to than 16"); [EOL]     } [EOL]     short out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nHex; i++) { [EOL]         shift = i * 4 + dstPos; [EOL]         final int bits = (0xf & hexDigitToInt(src.charAt(i + srcPos))) << shift; [EOL]         final int mask = 0xf << shift; [EOL]         out = (short) ((out & ~mask) | bits); [EOL]     } [EOL]     return out; [EOL] } 
 [LINE] shift = i * 4 + dstPos; [LINE] public static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex) { [EOL]     if (0 == nHex) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nHex - 1) * 4 + dstPos >= 16) { [EOL]         throw new IllegalArgumentException("(nHexs-1)*4+dstPos is greather or equal to than 16"); [EOL]     } [EOL]     short out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nHex; i++) { [EOL]         shift = i * 4 + dstPos; [EOL]         final int bits = (0xf & hexDigitToInt(src.charAt(i + srcPos))) << shift; [EOL]         final int mask = 0xf << shift; [EOL]         out = (short) ((out & ~mask) | bits); [EOL]     } [EOL]     return out; [EOL] } 
 [LINE] byte out = dstInit; [LINE] public static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex) { [EOL]     if (0 == nHex) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nHex - 1) * 4 + dstPos >= 8) { [EOL]         throw new IllegalArgumentException("(nHexs-1)*4+dstPos is greather or equal to than 8"); [EOL]     } [EOL]     byte out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nHex; i++) { [EOL]         shift = i * 4 + dstPos; [EOL]         final int bits = (0xf & hexDigitToInt(src.charAt(i + srcPos))) << shift; [EOL]         final int mask = 0xf << shift; [EOL]         out = (byte) ((out & ~mask) | bits); [EOL]     } [EOL]     return out; [EOL] } 
 [LINE] final int mask = 0xf << shift; [LINE] public static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex) { [EOL]     if (0 == nHex) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nHex - 1) * 4 + dstPos >= 8) { [EOL]         throw new IllegalArgumentException("(nHexs-1)*4+dstPos is greather or equal to than 8"); [EOL]     } [EOL]     byte out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nHex; i++) { [EOL]         shift = i * 4 + dstPos; [EOL]         final int bits = (0xf & hexDigitToInt(src.charAt(i + srcPos))) << shift; [EOL]         final int mask = 0xf << shift; [EOL]         out = (byte) ((out & ~mask) | bits); [EOL]     } [EOL]     return out; [EOL] } 
 [LINE] long out = dstInit; [LINE] public static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nBools) { [EOL]         return dstInit; [EOL]     } [EOL]     if (nBools - 1 + dstPos >= 64) { [EOL]         throw new IllegalArgumentException("nBools-1+dstPos is greather or equal to than 64"); [EOL]     } [EOL]     long out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBools; i++) { [EOL]         shift = i * 1 + dstPos; [EOL]         final long bits = (src[i + srcPos] ? 1L : 0) << shift; [EOL]         final long mask = 0x1L << shift; [EOL]         out = (out & ~mask) | bits; [EOL]     } [EOL]     return out; [EOL] } 
 [LINE] return out; [LINE] public static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nBools) { [EOL]         return dstInit; [EOL]     } [EOL]     if (nBools - 1 + dstPos >= 64) { [EOL]         throw new IllegalArgumentException("nBools-1+dstPos is greather or equal to than 64"); [EOL]     } [EOL]     long out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBools; i++) { [EOL]         shift = i * 1 + dstPos; [EOL]         final long bits = (src[i + srcPos] ? 1L : 0) << shift; [EOL]         final long mask = 0x1L << shift; [EOL]         out = (out & ~mask) | bits; [EOL]     } [EOL]     return out; [EOL] } 
 [LINE] if ((src.length == 0 && srcPos == 0) || 0 == nBools) { [LINE] public static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nBools) { [EOL]         return dstInit; [EOL]     } [EOL]     if (nBools - 1 + dstPos >= 32) { [EOL]         throw new IllegalArgumentException("nBools-1+dstPos is greather or equal to than 32"); [EOL]     } [EOL]     int out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBools; i++) { [EOL]         shift = i * 1 + dstPos; [EOL]         final int bits = (src[i + srcPos] ? 1 : 0) << shift; [EOL]         final int mask = 0x1 << shift; [EOL]         out = (out & ~mask) | bits; [EOL]     } [EOL]     return out; [EOL] } 
 [LINE] return dstInit; [LINE] public static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nBools) { [EOL]         return dstInit; [EOL]     } [EOL]     if (nBools - 1 + dstPos >= 32) { [EOL]         throw new IllegalArgumentException("nBools-1+dstPos is greather or equal to than 32"); [EOL]     } [EOL]     int out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBools; i++) { [EOL]         shift = i * 1 + dstPos; [EOL]         final int bits = (src[i + srcPos] ? 1 : 0) << shift; [EOL]         final int mask = 0x1 << shift; [EOL]         out = (out & ~mask) | bits; [EOL]     } [EOL]     return out; [EOL] } 
 [LINE] if (nBools - 1 + dstPos >= 32) { [LINE] public static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nBools) { [EOL]         return dstInit; [EOL]     } [EOL]     if (nBools - 1 + dstPos >= 32) { [EOL]         throw new IllegalArgumentException("nBools-1+dstPos is greather or equal to than 32"); [EOL]     } [EOL]     int out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBools; i++) { [EOL]         shift = i * 1 + dstPos; [EOL]         final int bits = (src[i + srcPos] ? 1 : 0) << shift; [EOL]         final int mask = 0x1 << shift; [EOL]         out = (out & ~mask) | bits; [EOL]     } [EOL]     return out; [EOL] } 
 [LINE] int out = dstInit; [LINE] public static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nBools) { [EOL]         return dstInit; [EOL]     } [EOL]     if (nBools - 1 + dstPos >= 32) { [EOL]         throw new IllegalArgumentException("nBools-1+dstPos is greather or equal to than 32"); [EOL]     } [EOL]     int out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBools; i++) { [EOL]         shift = i * 1 + dstPos; [EOL]         final int bits = (src[i + srcPos] ? 1 : 0) << shift; [EOL]         final int mask = 0x1 << shift; [EOL]         out = (out & ~mask) | bits; [EOL]     } [EOL]     return out; [EOL] } 
 [LINE] shift = i * 1 + dstPos; [LINE] public static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nBools) { [EOL]         return dstInit; [EOL]     } [EOL]     if (nBools - 1 + dstPos >= 32) { [EOL]         throw new IllegalArgumentException("nBools-1+dstPos is greather or equal to than 32"); [EOL]     } [EOL]     int out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBools; i++) { [EOL]         shift = i * 1 + dstPos; [EOL]         final int bits = (src[i + srcPos] ? 1 : 0) << shift; [EOL]         final int mask = 0x1 << shift; [EOL]         out = (out & ~mask) | bits; [EOL]     } [EOL]     return out; [EOL] } 
 [LINE] out = (out & ~mask) | bits; [LINE] public static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nBools) { [EOL]         return dstInit; [EOL]     } [EOL]     if (nBools - 1 + dstPos >= 32) { [EOL]         throw new IllegalArgumentException("nBools-1+dstPos is greather or equal to than 32"); [EOL]     } [EOL]     int out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBools; i++) { [EOL]         shift = i * 1 + dstPos; [EOL]         final int bits = (src[i + srcPos] ? 1 : 0) << shift; [EOL]         final int mask = 0x1 << shift; [EOL]         out = (out & ~mask) | bits; [EOL]     } [EOL]     return out; [EOL] } 
 [LINE] return dstInit; [LINE] public static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nBools) { [EOL]         return dstInit; [EOL]     } [EOL]     if (nBools - 1 + dstPos >= 16) { [EOL]         throw new IllegalArgumentException("nBools-1+dstPos is greather or equal to than 16"); [EOL]     } [EOL]     short out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBools; i++) { [EOL]         shift = i * 1 + dstPos; [EOL]         final int bits = (src[i + srcPos] ? 1 : 0) << shift; [EOL]         final int mask = 0x1 << shift; [EOL]         out = (short) ((out & ~mask) | bits); [EOL]     } [EOL]     return out; [EOL] } 
 [LINE] short out = dstInit; [LINE] public static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nBools) { [EOL]         return dstInit; [EOL]     } [EOL]     if (nBools - 1 + dstPos >= 16) { [EOL]         throw new IllegalArgumentException("nBools-1+dstPos is greather or equal to than 16"); [EOL]     } [EOL]     short out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBools; i++) { [EOL]         shift = i * 1 + dstPos; [EOL]         final int bits = (src[i + srcPos] ? 1 : 0) << shift; [EOL]         final int mask = 0x1 << shift; [EOL]         out = (short) ((out & ~mask) | bits); [EOL]     } [EOL]     return out; [EOL] } 
 [LINE] if ((src.length == 0 && srcPos == 0) || 0 == nBools) { [LINE] public static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nBools) { [EOL]         return dstInit; [EOL]     } [EOL]     if (nBools - 1 + dstPos >= 8) { [EOL]         throw new IllegalArgumentException("nBools-1+dstPos is greather or equal to than 8"); [EOL]     } [EOL]     byte out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBools; i++) { [EOL]         shift = i * 1 + dstPos; [EOL]         final int bits = (src[i + srcPos] ? 1 : 0) << shift; [EOL]         final int mask = 0x1 << shift; [EOL]         out = (byte) ((out & ~mask) | bits); [EOL]     } [EOL]     return out; [EOL] } 
 [LINE] return dstInit; [LINE] public static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nBools) { [EOL]         return dstInit; [EOL]     } [EOL]     if (nBools - 1 + dstPos >= 8) { [EOL]         throw new IllegalArgumentException("nBools-1+dstPos is greather or equal to than 8"); [EOL]     } [EOL]     byte out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBools; i++) { [EOL]         shift = i * 1 + dstPos; [EOL]         final int bits = (src[i + srcPos] ? 1 : 0) << shift; [EOL]         final int mask = 0x1 << shift; [EOL]         out = (byte) ((out & ~mask) | bits); [EOL]     } [EOL]     return out; [EOL] } 
 [LINE] if (0 == nShorts) { [LINE] public static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts) { [EOL]     if (0 == nShorts) { [EOL]         return dst; [EOL]     } [EOL]     if ((nShorts - 1) * 16 + srcPos >= 64) { [EOL]         throw new IllegalArgumentException("(nShorts-1)*16+srcPos is greather or equal to than 64"); [EOL]     } [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nShorts; i++) { [EOL]         shift = i * 16 + srcPos; [EOL]         dst[dstPos + i] = (short) (0xffff & (src >> shift)); [EOL]     } [EOL]     return dst; [EOL] } 
 [LINE] if ((nShorts - 1) * 16 + srcPos >= 64) { [LINE] public static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts) { [EOL]     if (0 == nShorts) { [EOL]         return dst; [EOL]     } [EOL]     if ((nShorts - 1) * 16 + srcPos >= 64) { [EOL]         throw new IllegalArgumentException("(nShorts-1)*16+srcPos is greather or equal to than 64"); [EOL]     } [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nShorts; i++) { [EOL]         shift = i * 16 + srcPos; [EOL]         dst[dstPos + i] = (short) (0xffff & (src >> shift)); [EOL]     } [EOL]     return dst; [EOL] } 
 [LINE] int shift = 0; [LINE] public static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts) { [EOL]     if (0 == nShorts) { [EOL]         return dst; [EOL]     } [EOL]     if ((nShorts - 1) * 16 + srcPos >= 64) { [EOL]         throw new IllegalArgumentException("(nShorts-1)*16+srcPos is greather or equal to than 64"); [EOL]     } [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nShorts; i++) { [EOL]         shift = i * 16 + srcPos; [EOL]         dst[dstPos + i] = (short) (0xffff & (src >> shift)); [EOL]     } [EOL]     return dst; [EOL] } 
 [LINE] shift = i * 16 + srcPos; [LINE] public static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts) { [EOL]     if (0 == nShorts) { [EOL]         return dst; [EOL]     } [EOL]     if ((nShorts - 1) * 16 + srcPos >= 64) { [EOL]         throw new IllegalArgumentException("(nShorts-1)*16+srcPos is greather or equal to than 64"); [EOL]     } [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nShorts; i++) { [EOL]         shift = i * 16 + srcPos; [EOL]         dst[dstPos + i] = (short) (0xffff & (src >> shift)); [EOL]     } [EOL]     return dst; [EOL] } 
 [LINE] shift = i * 16 + srcPos; [LINE] public static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts) { [EOL]     if (0 == nShorts) { [EOL]         return dst; [EOL]     } [EOL]     if ((nShorts - 1) * 16 + srcPos >= 32) { [EOL]         throw new IllegalArgumentException("(nShorts-1)*16+srcPos is greather or equal to than 32"); [EOL]     } [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nShorts; i++) { [EOL]         shift = i * 16 + srcPos; [EOL]         dst[dstPos + i] = (short) (0xffff & (src >> shift)); [EOL]     } [EOL]     return dst; [EOL] } 
 [LINE] return dst; [LINE] public static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes) { [EOL]     if (0 == nBytes) { [EOL]         return dst; [EOL]     } [EOL]     if ((nBytes - 1) * 8 + srcPos >= 64) { [EOL]         throw new IllegalArgumentException("(nBytes-1)*8+srcPos is greather or equal to than 64"); [EOL]     } [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBytes; i++) { [EOL]         shift = i * 8 + srcPos; [EOL]         dst[dstPos + i] = (byte) (0xff & (src >> shift)); [EOL]     } [EOL]     return dst; [EOL] } 
 [LINE] if ((nBytes - 1) * 8 + srcPos >= 16) { [LINE] public static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes) { [EOL]     if (0 == nBytes) { [EOL]         return dst; [EOL]     } [EOL]     if ((nBytes - 1) * 8 + srcPos >= 16) { [EOL]         throw new IllegalArgumentException("(nBytes-1)*8+srcPos is greather or equal to than 16"); [EOL]     } [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBytes; i++) { [EOL]         shift = i * 8 + srcPos; [EOL]         dst[dstPos + i] = (byte) (0xff & (src >> shift)); [EOL]     } [EOL]     return dst; [EOL] } 
 [LINE] return dstInit; [LINE] public static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) { [EOL]     if (0 == nHexs) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nHexs - 1) * 4 + srcPos >= 64) { [EOL]         throw new IllegalArgumentException("(nHexs-1)*4+srcPos is greather or equal to than 64"); [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(dstInit); [EOL]     int shift = 0; [EOL]     int append = sb.length(); [EOL]     for (int i = 0; i < nHexs; i++) { [EOL]         shift = i * 4 + srcPos; [EOL]         final int bits = (int) (0xF & (src >> shift)); [EOL]         if (dstPos + i == append) { [EOL]             ++append; [EOL]             sb.append(intToHexDigit(bits)); [EOL]         } else { [EOL]             sb.setCharAt(dstPos + i, intToHexDigit(bits)); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] } 
 [LINE] sb.setCharAt(dstPos + i, intToHexDigit(bits)); [LINE] public static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) { [EOL]     if (0 == nHexs) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nHexs - 1) * 4 + srcPos >= 64) { [EOL]         throw new IllegalArgumentException("(nHexs-1)*4+srcPos is greather or equal to than 64"); [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(dstInit); [EOL]     int shift = 0; [EOL]     int append = sb.length(); [EOL]     for (int i = 0; i < nHexs; i++) { [EOL]         shift = i * 4 + srcPos; [EOL]         final int bits = (int) (0xF & (src >> shift)); [EOL]         if (dstPos + i == append) { [EOL]             ++append; [EOL]             sb.append(intToHexDigit(bits)); [EOL]         } else { [EOL]             sb.setCharAt(dstPos + i, intToHexDigit(bits)); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] } 
 [LINE] if ((nHexs - 1) * 4 + srcPos >= 32) { [LINE] public static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) { [EOL]     if (0 == nHexs) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nHexs - 1) * 4 + srcPos >= 32) { [EOL]         throw new IllegalArgumentException("(nHexs-1)*4+srcPos is greather or equal to than 32"); [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(dstInit); [EOL]     int shift = 0; [EOL]     int append = sb.length(); [EOL]     for (int i = 0; i < nHexs; i++) { [EOL]         shift = i * 4 + srcPos; [EOL]         final int bits = 0xF & (src >> shift); [EOL]         if (dstPos + i == append) { [EOL]             ++append; [EOL]             sb.append(intToHexDigit(bits)); [EOL]         } else { [EOL]             sb.setCharAt(dstPos + i, intToHexDigit(bits)); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] } 
 [LINE] shift = i * 4 + srcPos; [LINE] public static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) { [EOL]     if (0 == nHexs) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nHexs - 1) * 4 + srcPos >= 32) { [EOL]         throw new IllegalArgumentException("(nHexs-1)*4+srcPos is greather or equal to than 32"); [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(dstInit); [EOL]     int shift = 0; [EOL]     int append = sb.length(); [EOL]     for (int i = 0; i < nHexs; i++) { [EOL]         shift = i * 4 + srcPos; [EOL]         final int bits = 0xF & (src >> shift); [EOL]         if (dstPos + i == append) { [EOL]             ++append; [EOL]             sb.append(intToHexDigit(bits)); [EOL]         } else { [EOL]             sb.setCharAt(dstPos + i, intToHexDigit(bits)); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] } 
 [LINE] if (0 == nHexs) { [LINE] public static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) { [EOL]     if (0 == nHexs) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nHexs - 1) * 4 + srcPos >= 16) { [EOL]         throw new IllegalArgumentException("(nHexs-1)*4+srcPos is greather or equal to than 16"); [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(dstInit); [EOL]     int shift = 0; [EOL]     int append = sb.length(); [EOL]     for (int i = 0; i < nHexs; i++) { [EOL]         shift = i * 4 + srcPos; [EOL]         final int bits = 0xF & (src >> shift); [EOL]         if (dstPos + i == append) { [EOL]             ++append; [EOL]             sb.append(intToHexDigit(bits)); [EOL]         } else { [EOL]             sb.setCharAt(dstPos + i, intToHexDigit(bits)); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] } 
 [LINE] final StringBuilder sb = new StringBuilder(dstInit); [LINE] public static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) { [EOL]     if (0 == nHexs) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nHexs - 1) * 4 + srcPos >= 16) { [EOL]         throw new IllegalArgumentException("(nHexs-1)*4+srcPos is greather or equal to than 16"); [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(dstInit); [EOL]     int shift = 0; [EOL]     int append = sb.length(); [EOL]     for (int i = 0; i < nHexs; i++) { [EOL]         shift = i * 4 + srcPos; [EOL]         final int bits = 0xF & (src >> shift); [EOL]         if (dstPos + i == append) { [EOL]             ++append; [EOL]             sb.append(intToHexDigit(bits)); [EOL]         } else { [EOL]             sb.setCharAt(dstPos + i, intToHexDigit(bits)); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] } 
 [LINE] shift = i * 4 + srcPos; [LINE] public static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) { [EOL]     if (0 == nHexs) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nHexs - 1) * 4 + srcPos >= 16) { [EOL]         throw new IllegalArgumentException("(nHexs-1)*4+srcPos is greather or equal to than 16"); [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(dstInit); [EOL]     int shift = 0; [EOL]     int append = sb.length(); [EOL]     for (int i = 0; i < nHexs; i++) { [EOL]         shift = i * 4 + srcPos; [EOL]         final int bits = 0xF & (src >> shift); [EOL]         if (dstPos + i == append) { [EOL]             ++append; [EOL]             sb.append(intToHexDigit(bits)); [EOL]         } else { [EOL]             sb.setCharAt(dstPos + i, intToHexDigit(bits)); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] } 
 [LINE] if (0 == nHexs) { [LINE] public static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) { [EOL]     if (0 == nHexs) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nHexs - 1) * 4 + srcPos >= 8) { [EOL]         throw new IllegalArgumentException("(nHexs-1)*4+srcPos is greather or equal to than 8"); [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(dstInit); [EOL]     int shift = 0; [EOL]     int append = sb.length(); [EOL]     for (int i = 0; i < nHexs; i++) { [EOL]         shift = i * 4 + srcPos; [EOL]         final int bits = 0xF & (src >> shift); [EOL]         if (dstPos + i == append) { [EOL]             ++append; [EOL]             sb.append(intToHexDigit(bits)); [EOL]         } else { [EOL]             sb.setCharAt(dstPos + i, intToHexDigit(bits)); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] } 
 [LINE] int append = sb.length(); [LINE] public static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) { [EOL]     if (0 == nHexs) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nHexs - 1) * 4 + srcPos >= 8) { [EOL]         throw new IllegalArgumentException("(nHexs-1)*4+srcPos is greather or equal to than 8"); [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(dstInit); [EOL]     int shift = 0; [EOL]     int append = sb.length(); [EOL]     for (int i = 0; i < nHexs; i++) { [EOL]         shift = i * 4 + srcPos; [EOL]         final int bits = 0xF & (src >> shift); [EOL]         if (dstPos + i == append) { [EOL]             ++append; [EOL]             sb.append(intToHexDigit(bits)); [EOL]         } else { [EOL]             sb.setCharAt(dstPos + i, intToHexDigit(bits)); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] } 
 [LINE] if (0 == nBools) { [LINE] public static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools) { [EOL]     if (0 == nBools) { [EOL]         return dst; [EOL]     } [EOL]     if (nBools - 1 + srcPos >= 64) { [EOL]         throw new IllegalArgumentException("nBools-1+srcPos is greather or equal to than 64"); [EOL]     } [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBools; i++) { [EOL]         shift = i * 1 + srcPos; [EOL]         dst[dstPos + i] = ((0x1 & (src >> shift)) != 0); [EOL]     } [EOL]     return dst; [EOL] } 
 [LINE] if (nBools - 1 + srcPos >= 64) { [LINE] public static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools) { [EOL]     if (0 == nBools) { [EOL]         return dst; [EOL]     } [EOL]     if (nBools - 1 + srcPos >= 64) { [EOL]         throw new IllegalArgumentException("nBools-1+srcPos is greather or equal to than 64"); [EOL]     } [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBools; i++) { [EOL]         shift = i * 1 + srcPos; [EOL]         dst[dstPos + i] = ((0x1 & (src >> shift)) != 0); [EOL]     } [EOL]     return dst; [EOL] } 
 [LINE] shift = i * 1 + srcPos; [LINE] public static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools) { [EOL]     if (0 == nBools) { [EOL]         return dst; [EOL]     } [EOL]     if (nBools - 1 + srcPos >= 64) { [EOL]         throw new IllegalArgumentException("nBools-1+srcPos is greather or equal to than 64"); [EOL]     } [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBools; i++) { [EOL]         shift = i * 1 + srcPos; [EOL]         dst[dstPos + i] = ((0x1 & (src >> shift)) != 0); [EOL]     } [EOL]     return dst; [EOL] } 
 [LINE] dst[dstPos + i] = ((0x1 & (src >> shift)) != 0); [LINE] public static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools) { [EOL]     if (0 == nBools) { [EOL]         return dst; [EOL]     } [EOL]     if (nBools - 1 + srcPos >= 64) { [EOL]         throw new IllegalArgumentException("nBools-1+srcPos is greather or equal to than 64"); [EOL]     } [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBools; i++) { [EOL]         shift = i * 1 + srcPos; [EOL]         dst[dstPos + i] = ((0x1 & (src >> shift)) != 0); [EOL]     } [EOL]     return dst; [EOL] } 
 [LINE] if (0 == nBools) { [LINE] public static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools) { [EOL]     if (0 == nBools) { [EOL]         return dst; [EOL]     } [EOL]     if (nBools - 1 + srcPos >= 32) { [EOL]         throw new IllegalArgumentException("nBools-1+srcPos is greather or equal to than 32"); [EOL]     } [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBools; i++) { [EOL]         shift = i * 1 + srcPos; [EOL]         dst[dstPos + i] = ((0x1 & (src >> shift)) != 0); [EOL]     } [EOL]     return dst; [EOL] } 
 [LINE] return dst; [LINE] public static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools) { [EOL]     if (0 == nBools) { [EOL]         return dst; [EOL]     } [EOL]     if (nBools - 1 + srcPos >= 32) { [EOL]         throw new IllegalArgumentException("nBools-1+srcPos is greather or equal to than 32"); [EOL]     } [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBools; i++) { [EOL]         shift = i * 1 + srcPos; [EOL]         dst[dstPos + i] = ((0x1 & (src >> shift)) != 0); [EOL]     } [EOL]     return dst; [EOL] } 
 [LINE] int shift = 0; [LINE] public static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools) { [EOL]     if (0 == nBools) { [EOL]         return dst; [EOL]     } [EOL]     if (nBools - 1 + srcPos >= 32) { [EOL]         throw new IllegalArgumentException("nBools-1+srcPos is greather or equal to than 32"); [EOL]     } [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBools; i++) { [EOL]         shift = i * 1 + srcPos; [EOL]         dst[dstPos + i] = ((0x1 & (src >> shift)) != 0); [EOL]     } [EOL]     return dst; [EOL] } 
 [LINE] return dst; [LINE] public static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools) { [EOL]     if (0 == nBools) { [EOL]         return dst; [EOL]     } [EOL]     if (nBools - 1 + srcPos >= 16) { [EOL]         throw new IllegalArgumentException("nBools-1+srcPos is greather or equal to than 16"); [EOL]     } [EOL]     int shift = 0; [EOL]     assert ((nBools - 1) * 1 < 16 - srcPos); [EOL]     for (int i = 0; i < nBools; i++) { [EOL]         shift = i * 1 + srcPos; [EOL]         dst[dstPos + i] = ((0x1 & (src >> shift)) != 0); [EOL]     } [EOL]     return dst; [EOL] } 
 [LINE] if (nBools - 1 + srcPos >= 16) { [LINE] public static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools) { [EOL]     if (0 == nBools) { [EOL]         return dst; [EOL]     } [EOL]     if (nBools - 1 + srcPos >= 16) { [EOL]         throw new IllegalArgumentException("nBools-1+srcPos is greather or equal to than 16"); [EOL]     } [EOL]     int shift = 0; [EOL]     assert ((nBools - 1) * 1 < 16 - srcPos); [EOL]     for (int i = 0; i < nBools; i++) { [EOL]         shift = i * 1 + srcPos; [EOL]         dst[dstPos + i] = ((0x1 & (src >> shift)) != 0); [EOL]     } [EOL]     return dst; [EOL] } 
 [LINE] dst[dstPos + i] = ((0x1 & (src >> shift)) != 0); [LINE] public static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools) { [EOL]     if (0 == nBools) { [EOL]         return dst; [EOL]     } [EOL]     if (nBools - 1 + srcPos >= 16) { [EOL]         throw new IllegalArgumentException("nBools-1+srcPos is greather or equal to than 16"); [EOL]     } [EOL]     int shift = 0; [EOL]     assert ((nBools - 1) * 1 < 16 - srcPos); [EOL]     for (int i = 0; i < nBools; i++) { [EOL]         shift = i * 1 + srcPos; [EOL]         dst[dstPos + i] = ((0x1 & (src >> shift)) != 0); [EOL]     } [EOL]     return dst; [EOL] } 
 [LINE] return dst; [LINE] public static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools) { [EOL]     if (0 == nBools) { [EOL]         return dst; [EOL]     } [EOL]     if (nBools - 1 + srcPos >= 16) { [EOL]         throw new IllegalArgumentException("nBools-1+srcPos is greather or equal to than 16"); [EOL]     } [EOL]     int shift = 0; [EOL]     assert ((nBools - 1) * 1 < 16 - srcPos); [EOL]     for (int i = 0; i < nBools; i++) { [EOL]         shift = i * 1 + srcPos; [EOL]         dst[dstPos + i] = ((0x1 & (src >> shift)) != 0); [EOL]     } [EOL]     return dst; [EOL] } 
lang3/text/translate/NumericEntityEscaper.java
 [LINE] return outsideOf(codepoint, Integer.MAX_VALUE); [LINE] public static NumericEntityEscaper below(final int codepoint) { [EOL]     return outsideOf(codepoint, Integer.MAX_VALUE); [EOL] } 
 [LINE] return outsideOf(0, codepoint); [LINE] public static NumericEntityEscaper above(final int codepoint) { [EOL]     return outsideOf(0, codepoint); [EOL] } 
 [LINE] return new NumericEntityEscaper(codepointLow, codepointHigh, true); [LINE] public static NumericEntityEscaper between(final int codepointLow, final int codepointHigh) { [EOL]     return new NumericEntityEscaper(codepointLow, codepointHigh, true); [EOL] } 
 [LINE] return new NumericEntityEscaper(codepointLow, codepointHigh, false); [LINE] public static NumericEntityEscaper outsideOf(final int codepointLow, final int codepointHigh) { [EOL]     return new NumericEntityEscaper(codepointLow, codepointHigh, false); [EOL] } 
 [LINE] out.write("&#"); [LINE] @Override [EOL] public boolean translate(final int codepoint, final Writer out) throws IOException { [EOL]     if (between) { [EOL]         if (codepoint < below || codepoint > above) { [EOL]             return false; [EOL]         } [EOL]     } else { [EOL]         if (codepoint >= below && codepoint <= above) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     out.write("&#"); [EOL]     out.write(Integer.toString(codepoint, 10)); [EOL]     out.write(';'); [EOL]     return true; [EOL] } 
 [LINE] out.write(';'); [LINE] @Override [EOL] public boolean translate(final int codepoint, final Writer out) throws IOException { [EOL]     if (between) { [EOL]         if (codepoint < below || codepoint > above) { [EOL]             return false; [EOL]         } [EOL]     } else { [EOL]         if (codepoint >= below && codepoint <= above) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     out.write("&#"); [EOL]     out.write(Integer.toString(codepoint, 10)); [EOL]     out.write(';'); [EOL]     return true; [EOL] } 
 [LINE] return true; [LINE] @Override [EOL] public boolean translate(final int codepoint, final Writer out) throws IOException { [EOL]     if (between) { [EOL]         if (codepoint < below || codepoint > above) { [EOL]             return false; [EOL]         } [EOL]     } else { [EOL]         if (codepoint >= below && codepoint <= above) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     out.write("&#"); [EOL]     out.write(Integer.toString(codepoint, 10)); [EOL]     out.write(';'); [EOL]     return true; [EOL] } 
lang3/ObjectUtils.java
 [LINE] if (val != null) { [LINE] public static <T> T firstNonNull(final T... values) { [EOL]     if (values != null) { [EOL]         for (final T val : values) { [EOL]             if (val != null) { [EOL]                 return val; [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] } 
 [LINE] if (object1 == object2) { [LINE] public static boolean equals(final Object object1, final Object object2) { [EOL]     if (object1 == object2) { [EOL]         return true; [EOL]     } [EOL]     if (object1 == null || object2 == null) { [EOL]         return false; [EOL]     } [EOL]     return object1.equals(object2); [EOL] } 
 [LINE] return true; [LINE] public static boolean equals(final Object object1, final Object object2) { [EOL]     if (object1 == object2) { [EOL]         return true; [EOL]     } [EOL]     if (object1 == null || object2 == null) { [EOL]         return false; [EOL]     } [EOL]     return object1.equals(object2); [EOL] } 
 [LINE] if (object1 == null || object2 == null) { [LINE] public static boolean equals(final Object object1, final Object object2) { [EOL]     if (object1 == object2) { [EOL]         return true; [EOL]     } [EOL]     if (object1 == null || object2 == null) { [EOL]         return false; [EOL]     } [EOL]     return object1.equals(object2); [EOL] } 
 [LINE] final StringBuilder builder = new StringBuilder(); [LINE] public static String identityToString(final Object object) { [EOL]     if (object == null) { [EOL]         return null; [EOL]     } [EOL]     final StringBuilder builder = new StringBuilder(); [EOL]     identityToString(builder, object); [EOL]     return builder.toString(); [EOL] } 
 [LINE] T result = null; [LINE] public static <T extends Comparable<? super T>> T min(final T... values) { [EOL]     T result = null; [EOL]     if (values != null) { [EOL]         for (final T value : values) { [EOL]             if (compare(value, result, true) < 0) { [EOL]                 result = value; [EOL]             } [EOL]         } [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] for (final T value : values) { [LINE] public static <T extends Comparable<? super T>> T min(final T... values) { [EOL]     T result = null; [EOL]     if (values != null) { [EOL]         for (final T value : values) { [EOL]             if (compare(value, result, true) < 0) { [EOL]                 result = value; [EOL]             } [EOL]         } [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] T result = null; [LINE] public static <T extends Comparable<? super T>> T max(final T... values) { [EOL]     T result = null; [EOL]     if (values != null) { [EOL]         for (final T value : values) { [EOL]             if (compare(value, result, false) > 0) { [EOL]                 result = value; [EOL]             } [EOL]         } [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] return result; [LINE] public static <T extends Comparable<? super T>> T max(final T... values) { [EOL]     T result = null; [EOL]     if (values != null) { [EOL]         for (final T value : values) { [EOL]             if (compare(value, result, false) > 0) { [EOL]                 result = value; [EOL]             } [EOL]         } [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] return 0; [LINE] public static <T extends Comparable<? super T>> int compare(final T c1, final T c2, final boolean nullGreater) { [EOL]     if (c1 == c2) { [EOL]         return 0; [EOL]     } else if (c1 == null) { [EOL]         return nullGreater ? 1 : -1; [EOL]     } else if (c2 == null) { [EOL]         return nullGreater ? -1 : 1; [EOL]     } [EOL]     return c1.compareTo(c2); [EOL] } 
 [LINE] Validate.noNullElements(items); [LINE] public static <T extends Comparable<? super T>> T median(final T... items) { [EOL]     Validate.notEmpty(items); [EOL]     Validate.noNullElements(items); [EOL]     final TreeSet<T> sort = new TreeSet<T>(); [EOL]     Collections.addAll(sort, items); [EOL]     @SuppressWarnings("unchecked") [EOL]     final T result = (T) sort.toArray()[(sort.size() - 1) / 2]; [EOL]     return result; [EOL] } 
 [LINE] Validate.notEmpty(items, "null/empty items"); [LINE] public static <T> T median(final Comparator<T> comparator, final T... items) { [EOL]     Validate.notEmpty(items, "null/empty items"); [EOL]     Validate.noNullElements(items); [EOL]     Validate.notNull(comparator, "null comparator"); [EOL]     final TreeSet<T> sort = new TreeSet<T>(comparator); [EOL]     Collections.addAll(sort, items); [EOL]     @SuppressWarnings("unchecked") [EOL]     final T result = (T) sort.toArray()[(sort.size() - 1) / 2]; [EOL]     return result; [EOL] } 
 [LINE] Validate.notNull(comparator, "null comparator"); [LINE] public static <T> T median(final Comparator<T> comparator, final T... items) { [EOL]     Validate.notEmpty(items, "null/empty items"); [EOL]     Validate.noNullElements(items); [EOL]     Validate.notNull(comparator, "null comparator"); [EOL]     final TreeSet<T> sort = new TreeSet<T>(comparator); [EOL]     Collections.addAll(sort, items); [EOL]     @SuppressWarnings("unchecked") [EOL]     final T result = (T) sort.toArray()[(sort.size() - 1) / 2]; [EOL]     return result; [EOL] } 
 [LINE] final TreeSet<T> sort = new TreeSet<T>(comparator); [LINE] public static <T> T median(final Comparator<T> comparator, final T... items) { [EOL]     Validate.notEmpty(items, "null/empty items"); [EOL]     Validate.noNullElements(items); [EOL]     Validate.notNull(comparator, "null comparator"); [EOL]     final TreeSet<T> sort = new TreeSet<T>(comparator); [EOL]     Collections.addAll(sort, items); [EOL]     @SuppressWarnings("unchecked") [EOL]     final T result = (T) sort.toArray()[(sort.size() - 1) / 2]; [EOL]     return result; [EOL] } 
 [LINE] return result; [LINE] public static <T> T median(final Comparator<T> comparator, final T... items) { [EOL]     Validate.notEmpty(items, "null/empty items"); [EOL]     Validate.noNullElements(items); [EOL]     Validate.notNull(comparator, "null comparator"); [EOL]     final TreeSet<T> sort = new TreeSet<T>(comparator); [EOL]     Collections.addAll(sort, items); [EOL]     @SuppressWarnings("unchecked") [EOL]     final T result = (T) sort.toArray()[(sort.size() - 1) / 2]; [EOL]     return result; [EOL] } 
 [LINE] for (final T t : items) { [LINE] public static <T> T mode(final T... items) { [EOL]     if (ArrayUtils.isNotEmpty(items)) { [EOL]         final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(items.length); [EOL]         for (final T t : items) { [EOL]             final MutableInt count = occurrences.get(t); [EOL]             if (count == null) { [EOL]                 occurrences.put(t, new MutableInt(1)); [EOL]             } else { [EOL]                 count.increment(); [EOL]             } [EOL]         } [EOL]         T result = null; [EOL]         int max = 0; [EOL]         for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) { [EOL]             final int cmp = e.getValue().intValue(); [EOL]             if (cmp == max) { [EOL]                 result = null; [EOL]             } else if (cmp > max) { [EOL]                 max = cmp; [EOL]                 result = e.getKey(); [EOL]             } [EOL]         } [EOL]         return result; [EOL]     } [EOL]     return null; [EOL] } 
 [LINE] count.increment(); [LINE] public static <T> T mode(final T... items) { [EOL]     if (ArrayUtils.isNotEmpty(items)) { [EOL]         final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(items.length); [EOL]         for (final T t : items) { [EOL]             final MutableInt count = occurrences.get(t); [EOL]             if (count == null) { [EOL]                 occurrences.put(t, new MutableInt(1)); [EOL]             } else { [EOL]                 count.increment(); [EOL]             } [EOL]         } [EOL]         T result = null; [EOL]         int max = 0; [EOL]         for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) { [EOL]             final int cmp = e.getValue().intValue(); [EOL]             if (cmp == max) { [EOL]                 result = null; [EOL]             } else if (cmp > max) { [EOL]                 max = cmp; [EOL]                 result = e.getKey(); [EOL]             } [EOL]         } [EOL]         return result; [EOL]     } [EOL]     return null; [EOL] } 
 [LINE] T result = null; [LINE] public static <T> T mode(final T... items) { [EOL]     if (ArrayUtils.isNotEmpty(items)) { [EOL]         final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(items.length); [EOL]         for (final T t : items) { [EOL]             final MutableInt count = occurrences.get(t); [EOL]             if (count == null) { [EOL]                 occurrences.put(t, new MutableInt(1)); [EOL]             } else { [EOL]                 count.increment(); [EOL]             } [EOL]         } [EOL]         T result = null; [EOL]         int max = 0; [EOL]         for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) { [EOL]             final int cmp = e.getValue().intValue(); [EOL]             if (cmp == max) { [EOL]                 result = null; [EOL]             } else if (cmp > max) { [EOL]                 max = cmp; [EOL]                 result = e.getKey(); [EOL]             } [EOL]         } [EOL]         return result; [EOL]     } [EOL]     return null; [EOL] } 
 [LINE] for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) { [LINE] public static <T> T mode(final T... items) { [EOL]     if (ArrayUtils.isNotEmpty(items)) { [EOL]         final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(items.length); [EOL]         for (final T t : items) { [EOL]             final MutableInt count = occurrences.get(t); [EOL]             if (count == null) { [EOL]                 occurrences.put(t, new MutableInt(1)); [EOL]             } else { [EOL]                 count.increment(); [EOL]             } [EOL]         } [EOL]         T result = null; [EOL]         int max = 0; [EOL]         for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) { [EOL]             final int cmp = e.getValue().intValue(); [EOL]             if (cmp == max) { [EOL]                 result = null; [EOL]             } else if (cmp > max) { [EOL]                 max = cmp; [EOL]                 result = e.getKey(); [EOL]             } [EOL]         } [EOL]         return result; [EOL]     } [EOL]     return null; [EOL] } 
 [LINE] if (obj instanceof Cloneable) { [LINE] public static <T> T clone(final T obj) { [EOL]     if (obj instanceof Cloneable) { [EOL]         final Object result; [EOL]         if (obj.getClass().isArray()) { [EOL]             final Class<?> componentType = obj.getClass().getComponentType(); [EOL]             if (!componentType.isPrimitive()) { [EOL]                 result = ((Object[]) obj).clone(); [EOL]             } else { [EOL]                 int length = Array.getLength(obj); [EOL]                 result = Array.newInstance(componentType, length); [EOL]                 while (length-- > 0) { [EOL]                     Array.set(result, length, Array.get(obj, length)); [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             try { [EOL]                 final Method clone = obj.getClass().getMethod("clone"); [EOL]                 result = clone.invoke(obj); [EOL]             } catch (final NoSuchMethodException e) { [EOL]                 throw new CloneFailedException("Cloneable type " + obj.getClass().getName() + " has no clone method", e); [EOL]             } catch (final IllegalAccessException e) { [EOL]                 throw new CloneFailedException("Cannot clone Cloneable type " + obj.getClass().getName(), e); [EOL]             } catch (final InvocationTargetException e) { [EOL]                 throw new CloneFailedException("Exception cloning Cloneable type " + obj.getClass().getName(), e.getCause()); [EOL]             } [EOL]         } [EOL]         @SuppressWarnings("unchecked") [EOL]         final T checked = (T) result; [EOL]         return checked; [EOL]     } [EOL]     return null; [EOL] } 
 [LINE] final Class<?> componentType = obj.getClass().getComponentType(); [LINE] public static <T> T clone(final T obj) { [EOL]     if (obj instanceof Cloneable) { [EOL]         final Object result; [EOL]         if (obj.getClass().isArray()) { [EOL]             final Class<?> componentType = obj.getClass().getComponentType(); [EOL]             if (!componentType.isPrimitive()) { [EOL]                 result = ((Object[]) obj).clone(); [EOL]             } else { [EOL]                 int length = Array.getLength(obj); [EOL]                 result = Array.newInstance(componentType, length); [EOL]                 while (length-- > 0) { [EOL]                     Array.set(result, length, Array.get(obj, length)); [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             try { [EOL]                 final Method clone = obj.getClass().getMethod("clone"); [EOL]                 result = clone.invoke(obj); [EOL]             } catch (final NoSuchMethodException e) { [EOL]                 throw new CloneFailedException("Cloneable type " + obj.getClass().getName() + " has no clone method", e); [EOL]             } catch (final IllegalAccessException e) { [EOL]                 throw new CloneFailedException("Cannot clone Cloneable type " + obj.getClass().getName(), e); [EOL]             } catch (final InvocationTargetException e) { [EOL]                 throw new CloneFailedException("Exception cloning Cloneable type " + obj.getClass().getName(), e.getCause()); [EOL]             } [EOL]         } [EOL]         @SuppressWarnings("unchecked") [EOL]         final T checked = (T) result; [EOL]         return checked; [EOL]     } [EOL]     return null; [EOL] } 
 [LINE] if (!componentType.isPrimitive()) { [LINE] public static <T> T clone(final T obj) { [EOL]     if (obj instanceof Cloneable) { [EOL]         final Object result; [EOL]         if (obj.getClass().isArray()) { [EOL]             final Class<?> componentType = obj.getClass().getComponentType(); [EOL]             if (!componentType.isPrimitive()) { [EOL]                 result = ((Object[]) obj).clone(); [EOL]             } else { [EOL]                 int length = Array.getLength(obj); [EOL]                 result = Array.newInstance(componentType, length); [EOL]                 while (length-- > 0) { [EOL]                     Array.set(result, length, Array.get(obj, length)); [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             try { [EOL]                 final Method clone = obj.getClass().getMethod("clone"); [EOL]                 result = clone.invoke(obj); [EOL]             } catch (final NoSuchMethodException e) { [EOL]                 throw new CloneFailedException("Cloneable type " + obj.getClass().getName() + " has no clone method", e); [EOL]             } catch (final IllegalAccessException e) { [EOL]                 throw new CloneFailedException("Cannot clone Cloneable type " + obj.getClass().getName(), e); [EOL]             } catch (final InvocationTargetException e) { [EOL]                 throw new CloneFailedException("Exception cloning Cloneable type " + obj.getClass().getName(), e.getCause()); [EOL]             } [EOL]         } [EOL]         @SuppressWarnings("unchecked") [EOL]         final T checked = (T) result; [EOL]         return checked; [EOL]     } [EOL]     return null; [EOL] } 
 [LINE] int length = Array.getLength(obj); [LINE] public static <T> T clone(final T obj) { [EOL]     if (obj instanceof Cloneable) { [EOL]         final Object result; [EOL]         if (obj.getClass().isArray()) { [EOL]             final Class<?> componentType = obj.getClass().getComponentType(); [EOL]             if (!componentType.isPrimitive()) { [EOL]                 result = ((Object[]) obj).clone(); [EOL]             } else { [EOL]                 int length = Array.getLength(obj); [EOL]                 result = Array.newInstance(componentType, length); [EOL]                 while (length-- > 0) { [EOL]                     Array.set(result, length, Array.get(obj, length)); [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             try { [EOL]                 final Method clone = obj.getClass().getMethod("clone"); [EOL]                 result = clone.invoke(obj); [EOL]             } catch (final NoSuchMethodException e) { [EOL]                 throw new CloneFailedException("Cloneable type " + obj.getClass().getName() + " has no clone method", e); [EOL]             } catch (final IllegalAccessException e) { [EOL]                 throw new CloneFailedException("Cannot clone Cloneable type " + obj.getClass().getName(), e); [EOL]             } catch (final InvocationTargetException e) { [EOL]                 throw new CloneFailedException("Exception cloning Cloneable type " + obj.getClass().getName(), e.getCause()); [EOL]             } [EOL]         } [EOL]         @SuppressWarnings("unchecked") [EOL]         final T checked = (T) result; [EOL]         return checked; [EOL]     } [EOL]     return null; [EOL] } 
 [LINE] while (length-- > 0) { [LINE] public static <T> T clone(final T obj) { [EOL]     if (obj instanceof Cloneable) { [EOL]         final Object result; [EOL]         if (obj.getClass().isArray()) { [EOL]             final Class<?> componentType = obj.getClass().getComponentType(); [EOL]             if (!componentType.isPrimitive()) { [EOL]                 result = ((Object[]) obj).clone(); [EOL]             } else { [EOL]                 int length = Array.getLength(obj); [EOL]                 result = Array.newInstance(componentType, length); [EOL]                 while (length-- > 0) { [EOL]                     Array.set(result, length, Array.get(obj, length)); [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             try { [EOL]                 final Method clone = obj.getClass().getMethod("clone"); [EOL]                 result = clone.invoke(obj); [EOL]             } catch (final NoSuchMethodException e) { [EOL]                 throw new CloneFailedException("Cloneable type " + obj.getClass().getName() + " has no clone method", e); [EOL]             } catch (final IllegalAccessException e) { [EOL]                 throw new CloneFailedException("Cannot clone Cloneable type " + obj.getClass().getName(), e); [EOL]             } catch (final InvocationTargetException e) { [EOL]                 throw new CloneFailedException("Exception cloning Cloneable type " + obj.getClass().getName(), e.getCause()); [EOL]             } [EOL]         } [EOL]         @SuppressWarnings("unchecked") [EOL]         final T checked = (T) result; [EOL]         return checked; [EOL]     } [EOL]     return null; [EOL] } 
 [LINE] result = clone.invoke(obj); [LINE] public static <T> T clone(final T obj) { [EOL]     if (obj instanceof Cloneable) { [EOL]         final Object result; [EOL]         if (obj.getClass().isArray()) { [EOL]             final Class<?> componentType = obj.getClass().getComponentType(); [EOL]             if (!componentType.isPrimitive()) { [EOL]                 result = ((Object[]) obj).clone(); [EOL]             } else { [EOL]                 int length = Array.getLength(obj); [EOL]                 result = Array.newInstance(componentType, length); [EOL]                 while (length-- > 0) { [EOL]                     Array.set(result, length, Array.get(obj, length)); [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             try { [EOL]                 final Method clone = obj.getClass().getMethod("clone"); [EOL]                 result = clone.invoke(obj); [EOL]             } catch (final NoSuchMethodException e) { [EOL]                 throw new CloneFailedException("Cloneable type " + obj.getClass().getName() + " has no clone method", e); [EOL]             } catch (final IllegalAccessException e) { [EOL]                 throw new CloneFailedException("Cannot clone Cloneable type " + obj.getClass().getName(), e); [EOL]             } catch (final InvocationTargetException e) { [EOL]                 throw new CloneFailedException("Exception cloning Cloneable type " + obj.getClass().getName(), e.getCause()); [EOL]             } [EOL]         } [EOL]         @SuppressWarnings("unchecked") [EOL]         final T checked = (T) result; [EOL]         return checked; [EOL]     } [EOL]     return null; [EOL] } 
lang3/exception/ExceptionUtils.java
 [LINE] @Deprecated [LINE] @Deprecated [EOL] public static String[] getDefaultCauseMethodNames() { [EOL]     return ArrayUtils.clone(CAUSE_METHOD_NAMES); [EOL] } 
 [LINE] return getCause(throwable, CAUSE_METHOD_NAMES); [LINE] @Deprecated [EOL] public static Throwable getCause(final Throwable throwable) { [EOL]     return getCause(throwable, CAUSE_METHOD_NAMES); [EOL] } 
 [LINE] return null; [LINE] @Deprecated [EOL] public static Throwable getCause(final Throwable throwable, String[] methodNames) { [EOL]     if (throwable == null) { [EOL]         return null; [EOL]     } [EOL]     if (methodNames == null) { [EOL]         methodNames = CAUSE_METHOD_NAMES; [EOL]     } [EOL]     for (final String methodName : methodNames) { [EOL]         if (methodName != null) { [EOL]             final Throwable cause = getCauseUsingMethodName(throwable, methodName); [EOL]             if (cause != null) { [EOL]                 return cause; [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] } 
 [LINE] if (methodName != null) { [LINE] @Deprecated [EOL] public static Throwable getCause(final Throwable throwable, String[] methodNames) { [EOL]     if (throwable == null) { [EOL]         return null; [EOL]     } [EOL]     if (methodNames == null) { [EOL]         methodNames = CAUSE_METHOD_NAMES; [EOL]     } [EOL]     for (final String methodName : methodNames) { [EOL]         if (methodName != null) { [EOL]             final Throwable cause = getCauseUsingMethodName(throwable, methodName); [EOL]             if (cause != null) { [EOL]                 return cause; [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] } 
 [LINE] final List<Throwable> list = getThrowableList(throwable); [LINE] public static Throwable getRootCause(final Throwable throwable) { [EOL]     final List<Throwable> list = getThrowableList(throwable); [EOL]     return list.size() < 2 ? null : (Throwable) list.get(list.size() - 1); [EOL] } 
 [LINE] try { [LINE] private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName) { [EOL]     Method method = null; [EOL]     try { [EOL]         method = throwable.getClass().getMethod(methodName); [EOL]     } catch (final NoSuchMethodException ignored) { [EOL]     } catch (final SecurityException ignored) { [EOL]     } [EOL]     if (method != null && Throwable.class.isAssignableFrom(method.getReturnType())) { [EOL]         try { [EOL]             return (Throwable) method.invoke(throwable); [EOL]         } catch (final IllegalAccessException ignored) { [EOL]         } catch (final IllegalArgumentException ignored) { [EOL]         } catch (final InvocationTargetException ignored) { [EOL]         } [EOL]     } [EOL]     return null; [EOL] } 
 [LINE] method = throwable.getClass().getMethod(methodName); [LINE] private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName) { [EOL]     Method method = null; [EOL]     try { [EOL]         method = throwable.getClass().getMethod(methodName); [EOL]     } catch (final NoSuchMethodException ignored) { [EOL]     } catch (final SecurityException ignored) { [EOL]     } [EOL]     if (method != null && Throwable.class.isAssignableFrom(method.getReturnType())) { [EOL]         try { [EOL]             return (Throwable) method.invoke(throwable); [EOL]         } catch (final IllegalAccessException ignored) { [EOL]         } catch (final IllegalArgumentException ignored) { [EOL]         } catch (final InvocationTargetException ignored) { [EOL]         } [EOL]     } [EOL]     return null; [EOL] } 
 [LINE] return getThrowableList(throwable).size(); [LINE] public static int getThrowableCount(final Throwable throwable) { [EOL]     return getThrowableList(throwable).size(); [EOL] } 
 [LINE] final List<Throwable> list = new ArrayList<Throwable>(); [LINE] public static List<Throwable> getThrowableList(Throwable throwable) { [EOL]     final List<Throwable> list = new ArrayList<Throwable>(); [EOL]     while (throwable != null && list.contains(throwable) == false) { [EOL]         list.add(throwable); [EOL]         throwable = ExceptionUtils.getCause(throwable); [EOL]     } [EOL]     return list; [EOL] } 
 [LINE] return -1; [LINE] private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass) { [EOL]     if (throwable == null || type == null) { [EOL]         return -1; [EOL]     } [EOL]     if (fromIndex < 0) { [EOL]         fromIndex = 0; [EOL]     } [EOL]     final Throwable[] throwables = ExceptionUtils.getThrowables(throwable); [EOL]     if (fromIndex >= throwables.length) { [EOL]         return -1; [EOL]     } [EOL]     if (subclass) { [EOL]         for (int i = fromIndex; i < throwables.length; i++) { [EOL]             if (type.isAssignableFrom(throwables[i].getClass())) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         for (int i = fromIndex; i < throwables.length; i++) { [EOL]             if (type.equals(throwables[i].getClass())) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } [EOL]     return -1; [EOL] } 
 [LINE] fromIndex = 0; [LINE] private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass) { [EOL]     if (throwable == null || type == null) { [EOL]         return -1; [EOL]     } [EOL]     if (fromIndex < 0) { [EOL]         fromIndex = 0; [EOL]     } [EOL]     final Throwable[] throwables = ExceptionUtils.getThrowables(throwable); [EOL]     if (fromIndex >= throwables.length) { [EOL]         return -1; [EOL]     } [EOL]     if (subclass) { [EOL]         for (int i = fromIndex; i < throwables.length; i++) { [EOL]             if (type.isAssignableFrom(throwables[i].getClass())) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         for (int i = fromIndex; i < throwables.length; i++) { [EOL]             if (type.equals(throwables[i].getClass())) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } [EOL]     return -1; [EOL] } 
 [LINE] if (subclass) { [LINE] private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass) { [EOL]     if (throwable == null || type == null) { [EOL]         return -1; [EOL]     } [EOL]     if (fromIndex < 0) { [EOL]         fromIndex = 0; [EOL]     } [EOL]     final Throwable[] throwables = ExceptionUtils.getThrowables(throwable); [EOL]     if (fromIndex >= throwables.length) { [EOL]         return -1; [EOL]     } [EOL]     if (subclass) { [EOL]         for (int i = fromIndex; i < throwables.length; i++) { [EOL]             if (type.isAssignableFrom(throwables[i].getClass())) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         for (int i = fromIndex; i < throwables.length; i++) { [EOL]             if (type.equals(throwables[i].getClass())) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } [EOL]     return -1; [EOL] } 
 [LINE] for (int i = fromIndex; i < throwables.length; i++) { [LINE] private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass) { [EOL]     if (throwable == null || type == null) { [EOL]         return -1; [EOL]     } [EOL]     if (fromIndex < 0) { [EOL]         fromIndex = 0; [EOL]     } [EOL]     final Throwable[] throwables = ExceptionUtils.getThrowables(throwable); [EOL]     if (fromIndex >= throwables.length) { [EOL]         return -1; [EOL]     } [EOL]     if (subclass) { [EOL]         for (int i = fromIndex; i < throwables.length; i++) { [EOL]             if (type.isAssignableFrom(throwables[i].getClass())) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         for (int i = fromIndex; i < throwables.length; i++) { [EOL]             if (type.equals(throwables[i].getClass())) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } [EOL]     return -1; [EOL] } 
 [LINE] return i; [LINE] private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass) { [EOL]     if (throwable == null || type == null) { [EOL]         return -1; [EOL]     } [EOL]     if (fromIndex < 0) { [EOL]         fromIndex = 0; [EOL]     } [EOL]     final Throwable[] throwables = ExceptionUtils.getThrowables(throwable); [EOL]     if (fromIndex >= throwables.length) { [EOL]         return -1; [EOL]     } [EOL]     if (subclass) { [EOL]         for (int i = fromIndex; i < throwables.length; i++) { [EOL]             if (type.isAssignableFrom(throwables[i].getClass())) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         for (int i = fromIndex; i < throwables.length; i++) { [EOL]             if (type.equals(throwables[i].getClass())) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } [EOL]     return -1; [EOL] } 
 [LINE] if (type.equals(throwables[i].getClass())) { [LINE] private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass) { [EOL]     if (throwable == null || type == null) { [EOL]         return -1; [EOL]     } [EOL]     if (fromIndex < 0) { [EOL]         fromIndex = 0; [EOL]     } [EOL]     final Throwable[] throwables = ExceptionUtils.getThrowables(throwable); [EOL]     if (fromIndex >= throwables.length) { [EOL]         return -1; [EOL]     } [EOL]     if (subclass) { [EOL]         for (int i = fromIndex; i < throwables.length; i++) { [EOL]             if (type.isAssignableFrom(throwables[i].getClass())) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         for (int i = fromIndex; i < throwables.length; i++) { [EOL]             if (type.equals(throwables[i].getClass())) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } [EOL]     return -1; [EOL] } 
 [LINE] return i; [LINE] private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass) { [EOL]     if (throwable == null || type == null) { [EOL]         return -1; [EOL]     } [EOL]     if (fromIndex < 0) { [EOL]         fromIndex = 0; [EOL]     } [EOL]     final Throwable[] throwables = ExceptionUtils.getThrowables(throwable); [EOL]     if (fromIndex >= throwables.length) { [EOL]         return -1; [EOL]     } [EOL]     if (subclass) { [EOL]         for (int i = fromIndex; i < throwables.length; i++) { [EOL]             if (type.isAssignableFrom(throwables[i].getClass())) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         for (int i = fromIndex; i < throwables.length; i++) { [EOL]             if (type.equals(throwables[i].getClass())) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } [EOL]     return -1; [EOL] } 
 [LINE] return; [LINE] public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream stream) { [EOL]     if (throwable == null) { [EOL]         return; [EOL]     } [EOL]     if (stream == null) { [EOL]         throw new IllegalArgumentException("The PrintStream must not be null"); [EOL]     } [EOL]     final String[] trace = getRootCauseStackTrace(throwable); [EOL]     for (final String element : trace) { [EOL]         stream.println(element); [EOL]     } [EOL]     stream.flush(); [EOL] } 
 [LINE] writer.println(element); [LINE] public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer) { [EOL]     if (throwable == null) { [EOL]         return; [EOL]     } [EOL]     if (writer == null) { [EOL]         throw new IllegalArgumentException("The PrintWriter must not be null"); [EOL]     } [EOL]     final String[] trace = getRootCauseStackTrace(throwable); [EOL]     for (final String element : trace) { [EOL]         writer.println(element); [EOL]     } [EOL]     writer.flush(); [EOL] } 
 [LINE] final int count = throwables.length; [LINE] public static String[] getRootCauseStackTrace(final Throwable throwable) { [EOL]     if (throwable == null) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final Throwable[] throwables = getThrowables(throwable); [EOL]     final int count = throwables.length; [EOL]     final List<String> frames = new ArrayList<String>(); [EOL]     List<String> nextTrace = getStackFrameList(throwables[count - 1]); [EOL]     for (int i = count; --i >= 0; ) { [EOL]         final List<String> trace = nextTrace; [EOL]         if (i != 0) { [EOL]             nextTrace = getStackFrameList(throwables[i - 1]); [EOL]             removeCommonFrames(trace, nextTrace); [EOL]         } [EOL]         if (i == count - 1) { [EOL]             frames.add(throwables[i].toString()); [EOL]         } else { [EOL]             frames.add(WRAPPED_MARKER + throwables[i].toString()); [EOL]         } [EOL]         for (int j = 0; j < trace.size(); j++) { [EOL]             frames.add(trace.get(j)); [EOL]         } [EOL]     } [EOL]     return frames.toArray(new String[frames.size()]); [EOL] } 
 [LINE] if (i != 0) { [LINE] public static String[] getRootCauseStackTrace(final Throwable throwable) { [EOL]     if (throwable == null) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final Throwable[] throwables = getThrowables(throwable); [EOL]     final int count = throwables.length; [EOL]     final List<String> frames = new ArrayList<String>(); [EOL]     List<String> nextTrace = getStackFrameList(throwables[count - 1]); [EOL]     for (int i = count; --i >= 0; ) { [EOL]         final List<String> trace = nextTrace; [EOL]         if (i != 0) { [EOL]             nextTrace = getStackFrameList(throwables[i - 1]); [EOL]             removeCommonFrames(trace, nextTrace); [EOL]         } [EOL]         if (i == count - 1) { [EOL]             frames.add(throwables[i].toString()); [EOL]         } else { [EOL]             frames.add(WRAPPED_MARKER + throwables[i].toString()); [EOL]         } [EOL]         for (int j = 0; j < trace.size(); j++) { [EOL]             frames.add(trace.get(j)); [EOL]         } [EOL]     } [EOL]     return frames.toArray(new String[frames.size()]); [EOL] } 
 [LINE] int causeFrameIndex = causeFrames.size() - 1; [LINE] public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames) { [EOL]     if (causeFrames == null || wrapperFrames == null) { [EOL]         throw new IllegalArgumentException("The List must not be null"); [EOL]     } [EOL]     int causeFrameIndex = causeFrames.size() - 1; [EOL]     int wrapperFrameIndex = wrapperFrames.size() - 1; [EOL]     while (causeFrameIndex >= 0 && wrapperFrameIndex >= 0) { [EOL]         final String causeFrame = causeFrames.get(causeFrameIndex); [EOL]         final String wrapperFrame = wrapperFrames.get(wrapperFrameIndex); [EOL]         if (causeFrame.equals(wrapperFrame)) { [EOL]             causeFrames.remove(causeFrameIndex); [EOL]         } [EOL]         causeFrameIndex--; [EOL]         wrapperFrameIndex--; [EOL]     } [EOL] } 
 [LINE] causeFrames.remove(causeFrameIndex); [LINE] public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames) { [EOL]     if (causeFrames == null || wrapperFrames == null) { [EOL]         throw new IllegalArgumentException("The List must not be null"); [EOL]     } [EOL]     int causeFrameIndex = causeFrames.size() - 1; [EOL]     int wrapperFrameIndex = wrapperFrames.size() - 1; [EOL]     while (causeFrameIndex >= 0 && wrapperFrameIndex >= 0) { [EOL]         final String causeFrame = causeFrames.get(causeFrameIndex); [EOL]         final String wrapperFrame = wrapperFrames.get(wrapperFrameIndex); [EOL]         if (causeFrame.equals(wrapperFrame)) { [EOL]             causeFrames.remove(causeFrameIndex); [EOL]         } [EOL]         causeFrameIndex--; [EOL]         wrapperFrameIndex--; [EOL]     } [EOL] } 
 [LINE] final StringWriter sw = new StringWriter(); [LINE] public static String getStackTrace(final Throwable throwable) { [EOL]     final StringWriter sw = new StringWriter(); [EOL]     final PrintWriter pw = new PrintWriter(sw, true); [EOL]     throwable.printStackTrace(pw); [EOL]     return sw.getBuffer().toString(); [EOL] } 
 [LINE] final PrintWriter pw = new PrintWriter(sw, true); [LINE] public static String getStackTrace(final Throwable throwable) { [EOL]     final StringWriter sw = new StringWriter(); [EOL]     final PrintWriter pw = new PrintWriter(sw, true); [EOL]     throwable.printStackTrace(pw); [EOL]     return sw.getBuffer().toString(); [EOL] } 
 [LINE] throwable.printStackTrace(pw); [LINE] public static String getStackTrace(final Throwable throwable) { [EOL]     final StringWriter sw = new StringWriter(); [EOL]     final PrintWriter pw = new PrintWriter(sw, true); [EOL]     throwable.printStackTrace(pw); [EOL]     return sw.getBuffer().toString(); [EOL] } 
 [LINE] final List<String> list = new ArrayList<String>(); [LINE] static List<String> getStackFrameList(final Throwable t) { [EOL]     final String stackTrace = getStackTrace(t); [EOL]     final String linebreak = SystemUtils.LINE_SEPARATOR; [EOL]     final StringTokenizer frames = new StringTokenizer(stackTrace, linebreak); [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     boolean traceStarted = false; [EOL]     while (frames.hasMoreTokens()) { [EOL]         final String token = frames.nextToken(); [EOL]         final int at = token.indexOf("at"); [EOL]         if (at != -1 && token.substring(0, at).trim().isEmpty()) { [EOL]             traceStarted = true; [EOL]             list.add(token); [EOL]         } else if (traceStarted) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     return list; [EOL] } 
 [LINE] boolean traceStarted = false; [LINE] static List<String> getStackFrameList(final Throwable t) { [EOL]     final String stackTrace = getStackTrace(t); [EOL]     final String linebreak = SystemUtils.LINE_SEPARATOR; [EOL]     final StringTokenizer frames = new StringTokenizer(stackTrace, linebreak); [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     boolean traceStarted = false; [EOL]     while (frames.hasMoreTokens()) { [EOL]         final String token = frames.nextToken(); [EOL]         final int at = token.indexOf("at"); [EOL]         if (at != -1 && token.substring(0, at).trim().isEmpty()) { [EOL]             traceStarted = true; [EOL]             list.add(token); [EOL]         } else if (traceStarted) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     return list; [EOL] } 
 [LINE] while (frames.hasMoreTokens()) { [LINE] static List<String> getStackFrameList(final Throwable t) { [EOL]     final String stackTrace = getStackTrace(t); [EOL]     final String linebreak = SystemUtils.LINE_SEPARATOR; [EOL]     final StringTokenizer frames = new StringTokenizer(stackTrace, linebreak); [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     boolean traceStarted = false; [EOL]     while (frames.hasMoreTokens()) { [EOL]         final String token = frames.nextToken(); [EOL]         final int at = token.indexOf("at"); [EOL]         if (at != -1 && token.substring(0, at).trim().isEmpty()) { [EOL]             traceStarted = true; [EOL]             list.add(token); [EOL]         } else if (traceStarted) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     return list; [EOL] } 
 [LINE] final int at = token.indexOf("at"); [LINE] static List<String> getStackFrameList(final Throwable t) { [EOL]     final String stackTrace = getStackTrace(t); [EOL]     final String linebreak = SystemUtils.LINE_SEPARATOR; [EOL]     final StringTokenizer frames = new StringTokenizer(stackTrace, linebreak); [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     boolean traceStarted = false; [EOL]     while (frames.hasMoreTokens()) { [EOL]         final String token = frames.nextToken(); [EOL]         final int at = token.indexOf("at"); [EOL]         if (at != -1 && token.substring(0, at).trim().isEmpty()) { [EOL]             traceStarted = true; [EOL]             list.add(token); [EOL]         } else if (traceStarted) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     return list; [EOL] } 
 [LINE] traceStarted = true; [LINE] static List<String> getStackFrameList(final Throwable t) { [EOL]     final String stackTrace = getStackTrace(t); [EOL]     final String linebreak = SystemUtils.LINE_SEPARATOR; [EOL]     final StringTokenizer frames = new StringTokenizer(stackTrace, linebreak); [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     boolean traceStarted = false; [EOL]     while (frames.hasMoreTokens()) { [EOL]         final String token = frames.nextToken(); [EOL]         final int at = token.indexOf("at"); [EOL]         if (at != -1 && token.substring(0, at).trim().isEmpty()) { [EOL]             traceStarted = true; [EOL]             list.add(token); [EOL]         } else if (traceStarted) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     return list; [EOL] } 
 [LINE] } else if (traceStarted) { [LINE] static List<String> getStackFrameList(final Throwable t) { [EOL]     final String stackTrace = getStackTrace(t); [EOL]     final String linebreak = SystemUtils.LINE_SEPARATOR; [EOL]     final StringTokenizer frames = new StringTokenizer(stackTrace, linebreak); [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     boolean traceStarted = false; [EOL]     while (frames.hasMoreTokens()) { [EOL]         final String token = frames.nextToken(); [EOL]         final int at = token.indexOf("at"); [EOL]         if (at != -1 && token.substring(0, at).trim().isEmpty()) { [EOL]             traceStarted = true; [EOL]             list.add(token); [EOL]         } else if (traceStarted) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     return list; [EOL] } 
 [LINE] if (th == null) { [LINE] public static String getMessage(final Throwable th) { [EOL]     if (th == null) { [EOL]         return ""; [EOL]     } [EOL]     final String clsName = ClassUtils.getShortClassName(th, null); [EOL]     final String msg = th.getMessage(); [EOL]     return clsName + ": " + StringUtils.defaultString(msg); [EOL] } 
 [LINE] return clsName + ": " + StringUtils.defaultString(msg); [LINE] public static String getMessage(final Throwable th) { [EOL]     if (th == null) { [EOL]         return ""; [EOL]     } [EOL]     final String clsName = ClassUtils.getShortClassName(th, null); [EOL]     final String msg = th.getMessage(); [EOL]     return clsName + ": " + StringUtils.defaultString(msg); [EOL] } 
 [LINE] root = root == null ? th : root; [LINE] public static String getRootCauseMessage(final Throwable th) { [EOL]     Throwable root = ExceptionUtils.getRootCause(th); [EOL]     root = root == null ? th : root; [EOL]     return getMessage(root); [EOL] } 
 [LINE] return getMessage(root); [LINE] public static String getRootCauseMessage(final Throwable th) { [EOL]     Throwable root = ExceptionUtils.getRootCause(th); [EOL]     root = root == null ? th : root; [EOL]     return getMessage(root); [EOL] } 
lang3/text/StrMatcher.java
 [LINE] return DOUBLE_QUOTE_MATCHER; [LINE] public static StrMatcher doubleQuoteMatcher() { [EOL]     return DOUBLE_QUOTE_MATCHER; [EOL] } 
 [LINE] return NONE_MATCHER; [LINE] public static StrMatcher charSetMatcher(final char... chars) { [EOL]     if (chars == null || chars.length == 0) { [EOL]         return NONE_MATCHER; [EOL]     } [EOL]     if (chars.length == 1) { [EOL]         return new CharMatcher(chars[0]); [EOL]     } [EOL]     return new CharSetMatcher(chars); [EOL] } 
 [LINE] if (StringUtils.isEmpty(chars)) { [LINE] public static StrMatcher charSetMatcher(final String chars) { [EOL]     if (StringUtils.isEmpty(chars)) { [EOL]         return NONE_MATCHER; [EOL]     } [EOL]     if (chars.length() == 1) { [EOL]         return new CharMatcher(chars.charAt(0)); [EOL]     } [EOL]     return new CharSetMatcher(chars.toCharArray()); [EOL] } 
 [LINE] return new StringMatcher(str); [LINE] public static StrMatcher stringMatcher(final String str) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return NONE_MATCHER; [EOL]     } [EOL]     return new StringMatcher(str); [EOL] } 
 [LINE] for (int i = 0; i < chars.length; i++, pos++) { [LINE] @Override [EOL] public int isMatch(final char[] buffer, int pos, final int bufferStart, final int bufferEnd) { [EOL]     final int len = chars.length; [EOL]     if (pos + len > bufferEnd) { [EOL]         return 0; [EOL]     } [EOL]     for (int i = 0; i < chars.length; i++, pos++) { [EOL]         if (chars[i] != buffer[pos]) { [EOL]             return 0; [EOL]         } [EOL]     } [EOL]     return len; [EOL] } 
 [LINE] return buffer[pos] <= 32 ? 1 : 0; [LINE] @Override [EOL] public int isMatch(final char[] buffer, final int pos, final int bufferStart, final int bufferEnd) { [EOL]     return buffer[pos] <= 32 ? 1 : 0; [EOL] } 
lang3/concurrent/ConcurrentException.java
lang3/text/translate/JavaUnicodeEscaper.java
lang3/time/FastDateParser.java
 [LINE] final List<Strategy> collector = new ArrayList<Strategy>(); [LINE] private void init() { [EOL]     final Calendar definingCalendar = Calendar.getInstance(timeZone, locale); [EOL]     thisYear = definingCalendar.get(Calendar.YEAR); [EOL]     final StringBuilder regex = new StringBuilder(); [EOL]     final List<Strategy> collector = new ArrayList<Strategy>(); [EOL]     final Matcher patternMatcher = formatPattern.matcher(pattern); [EOL]     if (!patternMatcher.lookingAt()) { [EOL]         throw new IllegalArgumentException("Illegal pattern character '" + pattern.charAt(patternMatcher.regionStart()) + "'"); [EOL]     } [EOL]     currentFormatField = patternMatcher.group(); [EOL]     Strategy currentStrategy = getStrategy(currentFormatField, definingCalendar); [EOL]     for (; ; ) { [EOL]         patternMatcher.region(patternMatcher.end(), patternMatcher.regionEnd()); [EOL]         if (!patternMatcher.lookingAt()) { [EOL]             nextStrategy = null; [EOL]             break; [EOL]         } [EOL]         final String nextFormatField = patternMatcher.group(); [EOL]         nextStrategy = getStrategy(nextFormatField, definingCalendar); [EOL]         if (currentStrategy.addRegex(this, regex)) { [EOL]             collector.add(currentStrategy); [EOL]         } [EOL]         currentFormatField = nextFormatField; [EOL]         currentStrategy = nextStrategy; [EOL]     } [EOL]     if (patternMatcher.regionStart() != patternMatcher.regionEnd()) { [EOL]         throw new IllegalArgumentException("Failed to parse \"" + pattern + "\" ; gave up at index " + patternMatcher.regionStart()); [EOL]     } [EOL]     if (currentStrategy.addRegex(this, regex)) { [EOL]         collector.add(currentStrategy); [EOL]     } [EOL]     currentFormatField = null; [EOL]     strategies = collector.toArray(new Strategy[collector.size()]); [EOL]     parsePattern = Pattern.compile(regex.toString()); [EOL] } 
 [LINE] break; [LINE] private void init() { [EOL]     final Calendar definingCalendar = Calendar.getInstance(timeZone, locale); [EOL]     thisYear = definingCalendar.get(Calendar.YEAR); [EOL]     final StringBuilder regex = new StringBuilder(); [EOL]     final List<Strategy> collector = new ArrayList<Strategy>(); [EOL]     final Matcher patternMatcher = formatPattern.matcher(pattern); [EOL]     if (!patternMatcher.lookingAt()) { [EOL]         throw new IllegalArgumentException("Illegal pattern character '" + pattern.charAt(patternMatcher.regionStart()) + "'"); [EOL]     } [EOL]     currentFormatField = patternMatcher.group(); [EOL]     Strategy currentStrategy = getStrategy(currentFormatField, definingCalendar); [EOL]     for (; ; ) { [EOL]         patternMatcher.region(patternMatcher.end(), patternMatcher.regionEnd()); [EOL]         if (!patternMatcher.lookingAt()) { [EOL]             nextStrategy = null; [EOL]             break; [EOL]         } [EOL]         final String nextFormatField = patternMatcher.group(); [EOL]         nextStrategy = getStrategy(nextFormatField, definingCalendar); [EOL]         if (currentStrategy.addRegex(this, regex)) { [EOL]             collector.add(currentStrategy); [EOL]         } [EOL]         currentFormatField = nextFormatField; [EOL]         currentStrategy = nextStrategy; [EOL]     } [EOL]     if (patternMatcher.regionStart() != patternMatcher.regionEnd()) { [EOL]         throw new IllegalArgumentException("Failed to parse \"" + pattern + "\" ; gave up at index " + patternMatcher.regionStart()); [EOL]     } [EOL]     if (currentStrategy.addRegex(this, regex)) { [EOL]         collector.add(currentStrategy); [EOL]     } [EOL]     currentFormatField = null; [EOL]     strategies = collector.toArray(new Strategy[collector.size()]); [EOL]     parsePattern = Pattern.compile(regex.toString()); [EOL] } 
 [LINE] collector.add(currentStrategy); [LINE] private void init() { [EOL]     final Calendar definingCalendar = Calendar.getInstance(timeZone, locale); [EOL]     thisYear = definingCalendar.get(Calendar.YEAR); [EOL]     final StringBuilder regex = new StringBuilder(); [EOL]     final List<Strategy> collector = new ArrayList<Strategy>(); [EOL]     final Matcher patternMatcher = formatPattern.matcher(pattern); [EOL]     if (!patternMatcher.lookingAt()) { [EOL]         throw new IllegalArgumentException("Illegal pattern character '" + pattern.charAt(patternMatcher.regionStart()) + "'"); [EOL]     } [EOL]     currentFormatField = patternMatcher.group(); [EOL]     Strategy currentStrategy = getStrategy(currentFormatField, definingCalendar); [EOL]     for (; ; ) { [EOL]         patternMatcher.region(patternMatcher.end(), patternMatcher.regionEnd()); [EOL]         if (!patternMatcher.lookingAt()) { [EOL]             nextStrategy = null; [EOL]             break; [EOL]         } [EOL]         final String nextFormatField = patternMatcher.group(); [EOL]         nextStrategy = getStrategy(nextFormatField, definingCalendar); [EOL]         if (currentStrategy.addRegex(this, regex)) { [EOL]             collector.add(currentStrategy); [EOL]         } [EOL]         currentFormatField = nextFormatField; [EOL]         currentStrategy = nextStrategy; [EOL]     } [EOL]     if (patternMatcher.regionStart() != patternMatcher.regionEnd()) { [EOL]         throw new IllegalArgumentException("Failed to parse \"" + pattern + "\" ; gave up at index " + patternMatcher.regionStart()); [EOL]     } [EOL]     if (currentStrategy.addRegex(this, regex)) { [EOL]         collector.add(currentStrategy); [EOL]     } [EOL]     currentFormatField = null; [EOL]     strategies = collector.toArray(new Strategy[collector.size()]); [EOL]     parsePattern = Pattern.compile(regex.toString()); [EOL] } 
 [LINE] @Override [LINE] @Override [EOL] public boolean equals(final Object obj) { [EOL]     if (!(obj instanceof FastDateParser)) { [EOL]         return false; [EOL]     } [EOL]     final FastDateParser other = (FastDateParser) obj; [EOL]     return pattern.equals(other.pattern) && timeZone.equals(other.timeZone) && locale.equals(other.locale); [EOL] } 
 [LINE] @Override [LINE] @Override [EOL] public Object parseObject(final String source, final ParsePosition pos) { [EOL]     return parse(source, pos); [EOL] } 
 [LINE] break; [LINE] private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote) { [EOL]     regex.append("\\Q"); [EOL]     for (int i = 0; i < value.length(); ++i) { [EOL]         char c = value.charAt(i); [EOL]         switch(c) { [EOL]             case '\'': [EOL]                 if (unquote) { [EOL]                     if (++i == value.length()) { [EOL]                         return regex; [EOL]                     } [EOL]                     c = value.charAt(i); [EOL]                 } [EOL]                 break; [EOL]             case '\\': [EOL]                 if (++i == value.length()) { [EOL]                     break; [EOL]                 } [EOL]                 regex.append(c); [EOL]                 c = value.charAt(i); [EOL]                 if (c == 'E') { [EOL]                     regex.append("E\\\\E\\"); [EOL]                     c = 'Q'; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         regex.append(c); [EOL]     } [EOL]     regex.append("\\E"); [EOL]     return regex; [EOL] } 
 [LINE] case '\\': [LINE] private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote) { [EOL]     regex.append("\\Q"); [EOL]     for (int i = 0; i < value.length(); ++i) { [EOL]         char c = value.charAt(i); [EOL]         switch(c) { [EOL]             case '\'': [EOL]                 if (unquote) { [EOL]                     if (++i == value.length()) { [EOL]                         return regex; [EOL]                     } [EOL]                     c = value.charAt(i); [EOL]                 } [EOL]                 break; [EOL]             case '\\': [EOL]                 if (++i == value.length()) { [EOL]                     break; [EOL]                 } [EOL]                 regex.append(c); [EOL]                 c = value.charAt(i); [EOL]                 if (c == 'E') { [EOL]                     regex.append("E\\\\E\\"); [EOL]                     c = 'Q'; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         regex.append(c); [EOL]     } [EOL]     regex.append("\\E"); [EOL]     return regex; [EOL] } 
 [LINE] break; [LINE] private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote) { [EOL]     regex.append("\\Q"); [EOL]     for (int i = 0; i < value.length(); ++i) { [EOL]         char c = value.charAt(i); [EOL]         switch(c) { [EOL]             case '\'': [EOL]                 if (unquote) { [EOL]                     if (++i == value.length()) { [EOL]                         return regex; [EOL]                     } [EOL]                     c = value.charAt(i); [EOL]                 } [EOL]                 break; [EOL]             case '\\': [EOL]                 if (++i == value.length()) { [EOL]                     break; [EOL]                 } [EOL]                 regex.append(c); [EOL]                 c = value.charAt(i); [EOL]                 if (c == 'E') { [EOL]                     regex.append("E\\\\E\\"); [EOL]                     c = 'Q'; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         regex.append(c); [EOL]     } [EOL]     regex.append("\\E"); [EOL]     return regex; [EOL] } 
 [LINE] return definingCalendar.getDisplayNames(field, Calendar.ALL_STYLES, locale); [LINE] private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale) { [EOL]     return definingCalendar.getDisplayNames(field, Calendar.ALL_STYLES, locale); [EOL] } 
 [LINE] return getLocaleSpecificStrategy(Calendar.AM_PM, definingCalendar); [LINE] private Strategy getStrategy(String formatField, final Calendar definingCalendar) { [EOL]     switch(formatField.charAt(0)) { [EOL]         case '\'': [EOL]             if (formatField.length() > 2) { [EOL]                 formatField = formatField.substring(1, formatField.length() - 1); [EOL]             } [EOL]         default: [EOL]             return new CopyQuotedStrategy(formatField); [EOL]         case 'D': [EOL]             return DAY_OF_YEAR_STRATEGY; [EOL]         case 'E': [EOL]             return getLocaleSpecificStrategy(Calendar.DAY_OF_WEEK, definingCalendar); [EOL]         case 'F': [EOL]             return DAY_OF_WEEK_IN_MONTH_STRATEGY; [EOL]         case 'G': [EOL]             return getLocaleSpecificStrategy(Calendar.ERA, definingCalendar); [EOL]         case 'H': [EOL]             return MODULO_HOUR_OF_DAY_STRATEGY; [EOL]         case 'K': [EOL]             return HOUR_STRATEGY; [EOL]         case 'M': [EOL]             return formatField.length() >= 3 ? getLocaleSpecificStrategy(Calendar.MONTH, definingCalendar) : NUMBER_MONTH_STRATEGY; [EOL]         case 'S': [EOL]             return MILLISECOND_STRATEGY; [EOL]         case 'W': [EOL]             return WEEK_OF_MONTH_STRATEGY; [EOL]         case 'a': [EOL]             return getLocaleSpecificStrategy(Calendar.AM_PM, definingCalendar); [EOL]         case 'd': [EOL]             return DAY_OF_MONTH_STRATEGY; [EOL]         case 'h': [EOL]             return MODULO_HOUR_STRATEGY; [EOL]         case 'k': [EOL]             return HOUR_OF_DAY_STRATEGY; [EOL]         case 'm': [EOL]             return MINUTE_STRATEGY; [EOL]         case 's': [EOL]             return SECOND_STRATEGY; [EOL]         case 'w': [EOL]             return WEEK_OF_YEAR_STRATEGY; [EOL]         case 'y': [EOL]             return formatField.length() > 2 ? LITERAL_YEAR_STRATEGY : ABBREVIATED_YEAR_STRATEGY; [EOL]         case 'Z': [EOL]         case 'z': [EOL]             return getLocaleSpecificStrategy(Calendar.ZONE_OFFSET, definingCalendar); [EOL]     } [EOL] } 
 [LINE] case 'd': [LINE] private Strategy getStrategy(String formatField, final Calendar definingCalendar) { [EOL]     switch(formatField.charAt(0)) { [EOL]         case '\'': [EOL]             if (formatField.length() > 2) { [EOL]                 formatField = formatField.substring(1, formatField.length() - 1); [EOL]             } [EOL]         default: [EOL]             return new CopyQuotedStrategy(formatField); [EOL]         case 'D': [EOL]             return DAY_OF_YEAR_STRATEGY; [EOL]         case 'E': [EOL]             return getLocaleSpecificStrategy(Calendar.DAY_OF_WEEK, definingCalendar); [EOL]         case 'F': [EOL]             return DAY_OF_WEEK_IN_MONTH_STRATEGY; [EOL]         case 'G': [EOL]             return getLocaleSpecificStrategy(Calendar.ERA, definingCalendar); [EOL]         case 'H': [EOL]             return MODULO_HOUR_OF_DAY_STRATEGY; [EOL]         case 'K': [EOL]             return HOUR_STRATEGY; [EOL]         case 'M': [EOL]             return formatField.length() >= 3 ? getLocaleSpecificStrategy(Calendar.MONTH, definingCalendar) : NUMBER_MONTH_STRATEGY; [EOL]         case 'S': [EOL]             return MILLISECOND_STRATEGY; [EOL]         case 'W': [EOL]             return WEEK_OF_MONTH_STRATEGY; [EOL]         case 'a': [EOL]             return getLocaleSpecificStrategy(Calendar.AM_PM, definingCalendar); [EOL]         case 'd': [EOL]             return DAY_OF_MONTH_STRATEGY; [EOL]         case 'h': [EOL]             return MODULO_HOUR_STRATEGY; [EOL]         case 'k': [EOL]             return HOUR_OF_DAY_STRATEGY; [EOL]         case 'm': [EOL]             return MINUTE_STRATEGY; [EOL]         case 's': [EOL]             return SECOND_STRATEGY; [EOL]         case 'w': [EOL]             return WEEK_OF_YEAR_STRATEGY; [EOL]         case 'y': [EOL]             return formatField.length() > 2 ? LITERAL_YEAR_STRATEGY : ABBREVIATED_YEAR_STRATEGY; [EOL]         case 'Z': [EOL]         case 'z': [EOL]             return getLocaleSpecificStrategy(Calendar.ZONE_OFFSET, definingCalendar); [EOL]     } [EOL] } 
 [LINE] case 'h': [LINE] private Strategy getStrategy(String formatField, final Calendar definingCalendar) { [EOL]     switch(formatField.charAt(0)) { [EOL]         case '\'': [EOL]             if (formatField.length() > 2) { [EOL]                 formatField = formatField.substring(1, formatField.length() - 1); [EOL]             } [EOL]         default: [EOL]             return new CopyQuotedStrategy(formatField); [EOL]         case 'D': [EOL]             return DAY_OF_YEAR_STRATEGY; [EOL]         case 'E': [EOL]             return getLocaleSpecificStrategy(Calendar.DAY_OF_WEEK, definingCalendar); [EOL]         case 'F': [EOL]             return DAY_OF_WEEK_IN_MONTH_STRATEGY; [EOL]         case 'G': [EOL]             return getLocaleSpecificStrategy(Calendar.ERA, definingCalendar); [EOL]         case 'H': [EOL]             return MODULO_HOUR_OF_DAY_STRATEGY; [EOL]         case 'K': [EOL]             return HOUR_STRATEGY; [EOL]         case 'M': [EOL]             return formatField.length() >= 3 ? getLocaleSpecificStrategy(Calendar.MONTH, definingCalendar) : NUMBER_MONTH_STRATEGY; [EOL]         case 'S': [EOL]             return MILLISECOND_STRATEGY; [EOL]         case 'W': [EOL]             return WEEK_OF_MONTH_STRATEGY; [EOL]         case 'a': [EOL]             return getLocaleSpecificStrategy(Calendar.AM_PM, definingCalendar); [EOL]         case 'd': [EOL]             return DAY_OF_MONTH_STRATEGY; [EOL]         case 'h': [EOL]             return MODULO_HOUR_STRATEGY; [EOL]         case 'k': [EOL]             return HOUR_OF_DAY_STRATEGY; [EOL]         case 'm': [EOL]             return MINUTE_STRATEGY; [EOL]         case 's': [EOL]             return SECOND_STRATEGY; [EOL]         case 'w': [EOL]             return WEEK_OF_YEAR_STRATEGY; [EOL]         case 'y': [EOL]             return formatField.length() > 2 ? LITERAL_YEAR_STRATEGY : ABBREVIATED_YEAR_STRATEGY; [EOL]         case 'Z': [EOL]         case 'z': [EOL]             return getLocaleSpecificStrategy(Calendar.ZONE_OFFSET, definingCalendar); [EOL]     } [EOL] } 
 [LINE] return WEEK_OF_YEAR_STRATEGY; [LINE] private Strategy getStrategy(String formatField, final Calendar definingCalendar) { [EOL]     switch(formatField.charAt(0)) { [EOL]         case '\'': [EOL]             if (formatField.length() > 2) { [EOL]                 formatField = formatField.substring(1, formatField.length() - 1); [EOL]             } [EOL]         default: [EOL]             return new CopyQuotedStrategy(formatField); [EOL]         case 'D': [EOL]             return DAY_OF_YEAR_STRATEGY; [EOL]         case 'E': [EOL]             return getLocaleSpecificStrategy(Calendar.DAY_OF_WEEK, definingCalendar); [EOL]         case 'F': [EOL]             return DAY_OF_WEEK_IN_MONTH_STRATEGY; [EOL]         case 'G': [EOL]             return getLocaleSpecificStrategy(Calendar.ERA, definingCalendar); [EOL]         case 'H': [EOL]             return MODULO_HOUR_OF_DAY_STRATEGY; [EOL]         case 'K': [EOL]             return HOUR_STRATEGY; [EOL]         case 'M': [EOL]             return formatField.length() >= 3 ? getLocaleSpecificStrategy(Calendar.MONTH, definingCalendar) : NUMBER_MONTH_STRATEGY; [EOL]         case 'S': [EOL]             return MILLISECOND_STRATEGY; [EOL]         case 'W': [EOL]             return WEEK_OF_MONTH_STRATEGY; [EOL]         case 'a': [EOL]             return getLocaleSpecificStrategy(Calendar.AM_PM, definingCalendar); [EOL]         case 'd': [EOL]             return DAY_OF_MONTH_STRATEGY; [EOL]         case 'h': [EOL]             return MODULO_HOUR_STRATEGY; [EOL]         case 'k': [EOL]             return HOUR_OF_DAY_STRATEGY; [EOL]         case 'm': [EOL]             return MINUTE_STRATEGY; [EOL]         case 's': [EOL]             return SECOND_STRATEGY; [EOL]         case 'w': [EOL]             return WEEK_OF_YEAR_STRATEGY; [EOL]         case 'y': [EOL]             return formatField.length() > 2 ? LITERAL_YEAR_STRATEGY : ABBREVIATED_YEAR_STRATEGY; [EOL]         case 'Z': [EOL]         case 'z': [EOL]             return getLocaleSpecificStrategy(Calendar.ZONE_OFFSET, definingCalendar); [EOL]     } [EOL] } 
 [LINE] @Override [LINE] @Override [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex) { [EOL]     escapeRegex(regex, formatField, true); [EOL]     return false; [EOL] } 
 [LINE] @Override [LINE] @Override [EOL] boolean isNumber() { [EOL]     return true; [EOL] } 
 [LINE] @Override [LINE] @Override [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value) { [EOL]     TimeZone tz; [EOL]     if (value.charAt(0) == '+' || value.charAt(0) == '-') { [EOL]         tz = TimeZone.getTimeZone("GMT" + value); [EOL]     } else if (value.startsWith("GMT")) { [EOL]         tz = TimeZone.getTimeZone(value); [EOL]     } else { [EOL]         tz = tzNames.get(value); [EOL]         if (tz == null) { [EOL]             throw new IllegalArgumentException(value + " is not a supported timezone name"); [EOL]         } [EOL]     } [EOL]     cal.setTimeZone(tz); [EOL] } 
 [LINE] @Override [LINE] @Override [EOL] int modify(final int iValue) { [EOL]     return iValue % 24; [EOL] } 
lang3/exception/DefaultExceptionContext.java
 [LINE] contextValues.add(new ImmutablePair<String, Object>(label, value)); [LINE] @Override [EOL] public DefaultExceptionContext addContextValue(final String label, final Object value) { [EOL]     contextValues.add(new ImmutablePair<String, Object>(label, value)); [EOL]     return this; [EOL] } 
 [LINE] values.add(pair.getValue()); [LINE] @Override [EOL] public List<Object> getContextValues(final String label) { [EOL]     final List<Object> values = new ArrayList<Object>(); [EOL]     for (final Pair<String, Object> pair : contextValues) { [EOL]         if (StringUtils.equals(label, pair.getKey())) { [EOL]             values.add(pair.getValue()); [EOL]         } [EOL]     } [EOL]     return values; [EOL] } 
 [LINE] return null; [LINE] @Override [EOL] public Object getFirstContextValue(final String label) { [EOL]     for (final Pair<String, Object> pair : contextValues) { [EOL]         if (StringUtils.equals(label, pair.getKey())) { [EOL]             return pair.getValue(); [EOL]         } [EOL]     } [EOL]     return null; [EOL] } 
 [LINE] return labels; [LINE] @Override [EOL] public Set<String> getContextLabels() { [EOL]     final Set<String> labels = new HashSet<String>(); [EOL]     for (final Pair<String, Object> pair : contextValues) { [EOL]         labels.add(pair.getKey()); [EOL]     } [EOL]     return labels; [EOL] } 
 [LINE] if (baseMessage != null) { [LINE] @Override [EOL] public String getFormattedExceptionMessage(final String baseMessage) { [EOL]     final StringBuilder buffer = new StringBuilder(256); [EOL]     if (baseMessage != null) { [EOL]         buffer.append(baseMessage); [EOL]     } [EOL]     if (contextValues.size() > 0) { [EOL]         if (buffer.length() > 0) { [EOL]             buffer.append('\n'); [EOL]         } [EOL]         buffer.append("Exception Context:\n"); [EOL]         int i = 0; [EOL]         for (final Pair<String, Object> pair : contextValues) { [EOL]             buffer.append("\t["); [EOL]             buffer.append(++i); [EOL]             buffer.append(':'); [EOL]             buffer.append(pair.getKey()); [EOL]             buffer.append("="); [EOL]             final Object value = pair.getValue(); [EOL]             if (value == null) { [EOL]                 buffer.append("null"); [EOL]             } else { [EOL]                 String valueStr; [EOL]                 try { [EOL]                     valueStr = value.toString(); [EOL]                 } catch (final Exception e) { [EOL]                     valueStr = "Exception thrown on toString(): " + ExceptionUtils.getStackTrace(e); [EOL]                 } [EOL]                 buffer.append(valueStr); [EOL]             } [EOL]             buffer.append("]\n"); [EOL]         } [EOL]         buffer.append("---------------------------------"); [EOL]     } [EOL]     return buffer.toString(); [EOL] } 
 [LINE] if (contextValues.size() > 0) { [LINE] @Override [EOL] public String getFormattedExceptionMessage(final String baseMessage) { [EOL]     final StringBuilder buffer = new StringBuilder(256); [EOL]     if (baseMessage != null) { [EOL]         buffer.append(baseMessage); [EOL]     } [EOL]     if (contextValues.size() > 0) { [EOL]         if (buffer.length() > 0) { [EOL]             buffer.append('\n'); [EOL]         } [EOL]         buffer.append("Exception Context:\n"); [EOL]         int i = 0; [EOL]         for (final Pair<String, Object> pair : contextValues) { [EOL]             buffer.append("\t["); [EOL]             buffer.append(++i); [EOL]             buffer.append(':'); [EOL]             buffer.append(pair.getKey()); [EOL]             buffer.append("="); [EOL]             final Object value = pair.getValue(); [EOL]             if (value == null) { [EOL]                 buffer.append("null"); [EOL]             } else { [EOL]                 String valueStr; [EOL]                 try { [EOL]                     valueStr = value.toString(); [EOL]                 } catch (final Exception e) { [EOL]                     valueStr = "Exception thrown on toString(): " + ExceptionUtils.getStackTrace(e); [EOL]                 } [EOL]                 buffer.append(valueStr); [EOL]             } [EOL]             buffer.append("]\n"); [EOL]         } [EOL]         buffer.append("---------------------------------"); [EOL]     } [EOL]     return buffer.toString(); [EOL] } 
 [LINE] if (buffer.length() > 0) { [LINE] @Override [EOL] public String getFormattedExceptionMessage(final String baseMessage) { [EOL]     final StringBuilder buffer = new StringBuilder(256); [EOL]     if (baseMessage != null) { [EOL]         buffer.append(baseMessage); [EOL]     } [EOL]     if (contextValues.size() > 0) { [EOL]         if (buffer.length() > 0) { [EOL]             buffer.append('\n'); [EOL]         } [EOL]         buffer.append("Exception Context:\n"); [EOL]         int i = 0; [EOL]         for (final Pair<String, Object> pair : contextValues) { [EOL]             buffer.append("\t["); [EOL]             buffer.append(++i); [EOL]             buffer.append(':'); [EOL]             buffer.append(pair.getKey()); [EOL]             buffer.append("="); [EOL]             final Object value = pair.getValue(); [EOL]             if (value == null) { [EOL]                 buffer.append("null"); [EOL]             } else { [EOL]                 String valueStr; [EOL]                 try { [EOL]                     valueStr = value.toString(); [EOL]                 } catch (final Exception e) { [EOL]                     valueStr = "Exception thrown on toString(): " + ExceptionUtils.getStackTrace(e); [EOL]                 } [EOL]                 buffer.append(valueStr); [EOL]             } [EOL]             buffer.append("]\n"); [EOL]         } [EOL]         buffer.append("---------------------------------"); [EOL]     } [EOL]     return buffer.toString(); [EOL] } 
 [LINE] buffer.append('\n'); [LINE] @Override [EOL] public String getFormattedExceptionMessage(final String baseMessage) { [EOL]     final StringBuilder buffer = new StringBuilder(256); [EOL]     if (baseMessage != null) { [EOL]         buffer.append(baseMessage); [EOL]     } [EOL]     if (contextValues.size() > 0) { [EOL]         if (buffer.length() > 0) { [EOL]             buffer.append('\n'); [EOL]         } [EOL]         buffer.append("Exception Context:\n"); [EOL]         int i = 0; [EOL]         for (final Pair<String, Object> pair : contextValues) { [EOL]             buffer.append("\t["); [EOL]             buffer.append(++i); [EOL]             buffer.append(':'); [EOL]             buffer.append(pair.getKey()); [EOL]             buffer.append("="); [EOL]             final Object value = pair.getValue(); [EOL]             if (value == null) { [EOL]                 buffer.append("null"); [EOL]             } else { [EOL]                 String valueStr; [EOL]                 try { [EOL]                     valueStr = value.toString(); [EOL]                 } catch (final Exception e) { [EOL]                     valueStr = "Exception thrown on toString(): " + ExceptionUtils.getStackTrace(e); [EOL]                 } [EOL]                 buffer.append(valueStr); [EOL]             } [EOL]             buffer.append("]\n"); [EOL]         } [EOL]         buffer.append("---------------------------------"); [EOL]     } [EOL]     return buffer.toString(); [EOL] } 
 [LINE] buffer.append("\t["); [LINE] @Override [EOL] public String getFormattedExceptionMessage(final String baseMessage) { [EOL]     final StringBuilder buffer = new StringBuilder(256); [EOL]     if (baseMessage != null) { [EOL]         buffer.append(baseMessage); [EOL]     } [EOL]     if (contextValues.size() > 0) { [EOL]         if (buffer.length() > 0) { [EOL]             buffer.append('\n'); [EOL]         } [EOL]         buffer.append("Exception Context:\n"); [EOL]         int i = 0; [EOL]         for (final Pair<String, Object> pair : contextValues) { [EOL]             buffer.append("\t["); [EOL]             buffer.append(++i); [EOL]             buffer.append(':'); [EOL]             buffer.append(pair.getKey()); [EOL]             buffer.append("="); [EOL]             final Object value = pair.getValue(); [EOL]             if (value == null) { [EOL]                 buffer.append("null"); [EOL]             } else { [EOL]                 String valueStr; [EOL]                 try { [EOL]                     valueStr = value.toString(); [EOL]                 } catch (final Exception e) { [EOL]                     valueStr = "Exception thrown on toString(): " + ExceptionUtils.getStackTrace(e); [EOL]                 } [EOL]                 buffer.append(valueStr); [EOL]             } [EOL]             buffer.append("]\n"); [EOL]         } [EOL]         buffer.append("---------------------------------"); [EOL]     } [EOL]     return buffer.toString(); [EOL] } 
 [LINE] String valueStr; [LINE] @Override [EOL] public String getFormattedExceptionMessage(final String baseMessage) { [EOL]     final StringBuilder buffer = new StringBuilder(256); [EOL]     if (baseMessage != null) { [EOL]         buffer.append(baseMessage); [EOL]     } [EOL]     if (contextValues.size() > 0) { [EOL]         if (buffer.length() > 0) { [EOL]             buffer.append('\n'); [EOL]         } [EOL]         buffer.append("Exception Context:\n"); [EOL]         int i = 0; [EOL]         for (final Pair<String, Object> pair : contextValues) { [EOL]             buffer.append("\t["); [EOL]             buffer.append(++i); [EOL]             buffer.append(':'); [EOL]             buffer.append(pair.getKey()); [EOL]             buffer.append("="); [EOL]             final Object value = pair.getValue(); [EOL]             if (value == null) { [EOL]                 buffer.append("null"); [EOL]             } else { [EOL]                 String valueStr; [EOL]                 try { [EOL]                     valueStr = value.toString(); [EOL]                 } catch (final Exception e) { [EOL]                     valueStr = "Exception thrown on toString(): " + ExceptionUtils.getStackTrace(e); [EOL]                 } [EOL]                 buffer.append(valueStr); [EOL]             } [EOL]             buffer.append("]\n"); [EOL]         } [EOL]         buffer.append("---------------------------------"); [EOL]     } [EOL]     return buffer.toString(); [EOL] } 
 [LINE] try { [LINE] @Override [EOL] public String getFormattedExceptionMessage(final String baseMessage) { [EOL]     final StringBuilder buffer = new StringBuilder(256); [EOL]     if (baseMessage != null) { [EOL]         buffer.append(baseMessage); [EOL]     } [EOL]     if (contextValues.size() > 0) { [EOL]         if (buffer.length() > 0) { [EOL]             buffer.append('\n'); [EOL]         } [EOL]         buffer.append("Exception Context:\n"); [EOL]         int i = 0; [EOL]         for (final Pair<String, Object> pair : contextValues) { [EOL]             buffer.append("\t["); [EOL]             buffer.append(++i); [EOL]             buffer.append(':'); [EOL]             buffer.append(pair.getKey()); [EOL]             buffer.append("="); [EOL]             final Object value = pair.getValue(); [EOL]             if (value == null) { [EOL]                 buffer.append("null"); [EOL]             } else { [EOL]                 String valueStr; [EOL]                 try { [EOL]                     valueStr = value.toString(); [EOL]                 } catch (final Exception e) { [EOL]                     valueStr = "Exception thrown on toString(): " + ExceptionUtils.getStackTrace(e); [EOL]                 } [EOL]                 buffer.append(valueStr); [EOL]             } [EOL]             buffer.append("]\n"); [EOL]         } [EOL]         buffer.append("---------------------------------"); [EOL]     } [EOL]     return buffer.toString(); [EOL] } 
lang3/text/translate/UnicodeUnescaper.java
 [LINE] out.write((char) value); [LINE] @Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     if (input.charAt(index) == '\\' && index + 1 < input.length() && input.charAt(index + 1) == 'u') { [EOL]         int i = 2; [EOL]         while (index + i < input.length() && input.charAt(index + i) == 'u') { [EOL]             i++; [EOL]         } [EOL]         if (index + i < input.length() && input.charAt(index + i) == '+') { [EOL]             i++; [EOL]         } [EOL]         if (index + i + 4 <= input.length()) { [EOL]             final CharSequence unicode = input.subSequence(index + i, index + i + 4); [EOL]             try { [EOL]                 final int value = Integer.parseInt(unicode.toString(), 16); [EOL]                 out.write((char) value); [EOL]             } catch (final NumberFormatException nfe) { [EOL]                 throw new IllegalArgumentException("Unable to parse unicode value: " + unicode, nfe); [EOL]             } [EOL]             return i + 4; [EOL]         } else { [EOL]             throw new IllegalArgumentException("Less than 4 hex digits in unicode value: '" + input.subSequence(index, input.length()) + "' due to end of CharSequence"); [EOL]         } [EOL]     } [EOL]     return 0; [EOL] } 
lang3/builder/HashCodeBuilder.java
 [LINE] AccessibleObject.setAccessible(fields, true); [LINE] private static void reflectionAppend(final Object object, final Class<?> clazz, final HashCodeBuilder builder, final boolean useTransients, final String[] excludeFields) { [EOL]     if (isRegistered(object)) { [EOL]         return; [EOL]     } [EOL]     try { [EOL]         register(object); [EOL]         final Field[] fields = clazz.getDeclaredFields(); [EOL]         AccessibleObject.setAccessible(fields, true); [EOL]         for (final Field field : fields) { [EOL]             if (!ArrayUtils.contains(excludeFields, field.getName()) && (field.getName().indexOf('$') == -1) && (useTransients || !Modifier.isTransient(field.getModifiers())) && (!Modifier.isStatic(field.getModifiers()))) { [EOL]                 try { [EOL]                     final Object fieldValue = field.get(object); [EOL]                     builder.append(fieldValue); [EOL]                 } catch (final IllegalAccessException e) { [EOL]                     throw new InternalError("Unexpected IllegalAccessException"); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } finally { [EOL]         unregister(object); [EOL]     } [EOL] } 
 [LINE] unregister(object); [LINE] private static void reflectionAppend(final Object object, final Class<?> clazz, final HashCodeBuilder builder, final boolean useTransients, final String[] excludeFields) { [EOL]     if (isRegistered(object)) { [EOL]         return; [EOL]     } [EOL]     try { [EOL]         register(object); [EOL]         final Field[] fields = clazz.getDeclaredFields(); [EOL]         AccessibleObject.setAccessible(fields, true); [EOL]         for (final Field field : fields) { [EOL]             if (!ArrayUtils.contains(excludeFields, field.getName()) && (field.getName().indexOf('$') == -1) && (useTransients || !Modifier.isTransient(field.getModifiers())) && (!Modifier.isStatic(field.getModifiers()))) { [EOL]                 try { [EOL]                     final Object fieldValue = field.get(object); [EOL]                     builder.append(fieldValue); [EOL]                 } catch (final IllegalAccessException e) { [EOL]                     throw new InternalError("Unexpected IllegalAccessException"); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } finally { [EOL]         unregister(object); [EOL]     } [EOL] } 
 [LINE] return reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, object, testTransients, null); [LINE] public static int reflectionHashCode(final int initialNonZeroOddNumber, final int multiplierNonZeroOddNumber, final Object object, final boolean testTransients) { [EOL]     return reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, object, testTransients, null); [EOL] } 
 [LINE] final HashCodeBuilder builder = new HashCodeBuilder(initialNonZeroOddNumber, multiplierNonZeroOddNumber); [LINE] public static <T> int reflectionHashCode(final int initialNonZeroOddNumber, final int multiplierNonZeroOddNumber, final T object, final boolean testTransients, final Class<? super T> reflectUpToClass, final String... excludeFields) { [EOL]     if (object == null) { [EOL]         throw new IllegalArgumentException("The object to build a hash code for must not be null"); [EOL]     } [EOL]     final HashCodeBuilder builder = new HashCodeBuilder(initialNonZeroOddNumber, multiplierNonZeroOddNumber); [EOL]     Class<?> clazz = object.getClass(); [EOL]     reflectionAppend(object, clazz, builder, testTransients, excludeFields); [EOL]     while (clazz.getSuperclass() != null && clazz != reflectUpToClass) { [EOL]         clazz = clazz.getSuperclass(); [EOL]         reflectionAppend(object, clazz, builder, testTransients, excludeFields); [EOL]     } [EOL]     return builder.toHashCode(); [EOL] } 
 [LINE] reflectionAppend(object, clazz, builder, testTransients, excludeFields); [LINE] public static <T> int reflectionHashCode(final int initialNonZeroOddNumber, final int multiplierNonZeroOddNumber, final T object, final boolean testTransients, final Class<? super T> reflectUpToClass, final String... excludeFields) { [EOL]     if (object == null) { [EOL]         throw new IllegalArgumentException("The object to build a hash code for must not be null"); [EOL]     } [EOL]     final HashCodeBuilder builder = new HashCodeBuilder(initialNonZeroOddNumber, multiplierNonZeroOddNumber); [EOL]     Class<?> clazz = object.getClass(); [EOL]     reflectionAppend(object, clazz, builder, testTransients, excludeFields); [EOL]     while (clazz.getSuperclass() != null && clazz != reflectUpToClass) { [EOL]         clazz = clazz.getSuperclass(); [EOL]         reflectionAppend(object, clazz, builder, testTransients, excludeFields); [EOL]     } [EOL]     return builder.toHashCode(); [EOL] } 
 [LINE] REGISTRY.set(new HashSet<IDKey>()); [LINE] static void register(final Object value) { [EOL]     synchronized (HashCodeBuilder.class) { [EOL]         if (getRegistry() == null) { [EOL]             REGISTRY.set(new HashSet<IDKey>()); [EOL]         } [EOL]     } [EOL]     getRegistry().add(new IDKey(value)); [EOL] } 
 [LINE] iTotal = iTotal * iConstant; [LINE] public HashCodeBuilder append(final boolean[] array) { [EOL]     if (array == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         for (final boolean element : array) { [EOL]             append(element); [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] if (array == null) { [LINE] public HashCodeBuilder append(final byte[] array) { [EOL]     if (array == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         for (final byte element : array) { [EOL]             append(element); [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] if (array == null) { [LINE] public HashCodeBuilder append(final char[] array) { [EOL]     if (array == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         for (final char element : array) { [EOL]             append(element); [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] append(element); [LINE] public HashCodeBuilder append(final char[] array) { [EOL]     if (array == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         for (final char element : array) { [EOL]             append(element); [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] return append(Double.doubleToLongBits(value)); [LINE] public HashCodeBuilder append(final double value) { [EOL]     return append(Double.doubleToLongBits(value)); [EOL] } 
 [LINE] if (array == null) { [LINE] public HashCodeBuilder append(final double[] array) { [EOL]     if (array == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         for (final double element : array) { [EOL]             append(element); [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] return this; [LINE] public HashCodeBuilder append(final double[] array) { [EOL]     if (array == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         for (final double element : array) { [EOL]             append(element); [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] iTotal = iTotal * iConstant + Float.floatToIntBits(value); [LINE] public HashCodeBuilder append(final float value) { [EOL]     iTotal = iTotal * iConstant + Float.floatToIntBits(value); [EOL]     return this; [EOL] } 
 [LINE] return this; [LINE] public HashCodeBuilder append(final int[] array) { [EOL]     if (array == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         for (final int element : array) { [EOL]             append(element); [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] return this; [LINE] public HashCodeBuilder append(final long value) { [EOL]     iTotal = iTotal * iConstant + ((int) (value ^ (value >> 32))); [EOL]     return this; [EOL] } 
 [LINE] if (array == null) { [LINE] public HashCodeBuilder append(final long[] array) { [EOL]     if (array == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         for (final long element : array) { [EOL]             append(element); [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] append((long[]) object); [LINE] public HashCodeBuilder append(final Object object) { [EOL]     if (object == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         if (object.getClass().isArray()) { [EOL]             if (object instanceof long[]) { [EOL]                 append((long[]) object); [EOL]             } else if (object instanceof int[]) { [EOL]                 append((int[]) object); [EOL]             } else if (object instanceof short[]) { [EOL]                 append((short[]) object); [EOL]             } else if (object instanceof char[]) { [EOL]                 append((char[]) object); [EOL]             } else if (object instanceof byte[]) { [EOL]                 append((byte[]) object); [EOL]             } else if (object instanceof double[]) { [EOL]                 append((double[]) object); [EOL]             } else if (object instanceof float[]) { [EOL]                 append((float[]) object); [EOL]             } else if (object instanceof boolean[]) { [EOL]                 append((boolean[]) object); [EOL]             } else { [EOL]                 append((Object[]) object); [EOL]             } [EOL]         } else { [EOL]             iTotal = iTotal * iConstant + object.hashCode(); [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] append((char[]) object); [LINE] public HashCodeBuilder append(final Object object) { [EOL]     if (object == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         if (object.getClass().isArray()) { [EOL]             if (object instanceof long[]) { [EOL]                 append((long[]) object); [EOL]             } else if (object instanceof int[]) { [EOL]                 append((int[]) object); [EOL]             } else if (object instanceof short[]) { [EOL]                 append((short[]) object); [EOL]             } else if (object instanceof char[]) { [EOL]                 append((char[]) object); [EOL]             } else if (object instanceof byte[]) { [EOL]                 append((byte[]) object); [EOL]             } else if (object instanceof double[]) { [EOL]                 append((double[]) object); [EOL]             } else if (object instanceof float[]) { [EOL]                 append((float[]) object); [EOL]             } else if (object instanceof boolean[]) { [EOL]                 append((boolean[]) object); [EOL]             } else { [EOL]                 append((Object[]) object); [EOL]             } [EOL]         } else { [EOL]             iTotal = iTotal * iConstant + object.hashCode(); [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] append((boolean[]) object); [LINE] public HashCodeBuilder append(final Object object) { [EOL]     if (object == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         if (object.getClass().isArray()) { [EOL]             if (object instanceof long[]) { [EOL]                 append((long[]) object); [EOL]             } else if (object instanceof int[]) { [EOL]                 append((int[]) object); [EOL]             } else if (object instanceof short[]) { [EOL]                 append((short[]) object); [EOL]             } else if (object instanceof char[]) { [EOL]                 append((char[]) object); [EOL]             } else if (object instanceof byte[]) { [EOL]                 append((byte[]) object); [EOL]             } else if (object instanceof double[]) { [EOL]                 append((double[]) object); [EOL]             } else if (object instanceof float[]) { [EOL]                 append((float[]) object); [EOL]             } else if (object instanceof boolean[]) { [EOL]                 append((boolean[]) object); [EOL]             } else { [EOL]                 append((Object[]) object); [EOL]             } [EOL]         } else { [EOL]             iTotal = iTotal * iConstant + object.hashCode(); [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] append(element); [LINE] public HashCodeBuilder append(final Object[] array) { [EOL]     if (array == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         for (final Object element : array) { [EOL]             append(element); [EOL]         } [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] return this; [LINE] public HashCodeBuilder appendSuper(final int superHashCode) { [EOL]     iTotal = iTotal * iConstant + superHashCode; [EOL]     return this; [EOL] } 
 [LINE] return toHashCode(); [LINE] @Override [EOL] public int hashCode() { [EOL]     return toHashCode(); [EOL] } 
lang3/text/CompositeFormat.java
lang3/concurrent/CallableBackgroundInitializer.java
 [LINE] if (call == null) { [LINE] private void checkCallable(final Callable<T> call) { [EOL]     if (call == null) { [EOL]         throw new IllegalArgumentException("Callable must not be null!"); [EOL]     } [EOL] } 
lang3/text/translate/OctalUnescaper.java
 [LINE] int end = index + 2; [LINE] @Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     if (input.charAt(index) == '\\' && index < (input.length() - 1) && Character.isDigit(input.charAt(index + 1))) { [EOL]         final int start = index + 1; [EOL]         int end = index + 2; [EOL]         while (end < input.length() && Character.isDigit(input.charAt(end))) { [EOL]             end++; [EOL]             if (Integer.parseInt(input.subSequence(start, end).toString(), 10) > OCTAL_MAX) { [EOL]                 end--; [EOL]                 break; [EOL]             } [EOL]         } [EOL]         out.write(Integer.parseInt(input.subSequence(start, end).toString(), 8)); [EOL]         return 1 + end - start; [EOL]     } [EOL]     return 0; [EOL] } 
 [LINE] return 0; [LINE] @Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     if (input.charAt(index) == '\\' && index < (input.length() - 1) && Character.isDigit(input.charAt(index + 1))) { [EOL]         final int start = index + 1; [EOL]         int end = index + 2; [EOL]         while (end < input.length() && Character.isDigit(input.charAt(end))) { [EOL]             end++; [EOL]             if (Integer.parseInt(input.subSequence(start, end).toString(), 10) > OCTAL_MAX) { [EOL]                 end--; [EOL]                 break; [EOL]             } [EOL]         } [EOL]         out.write(Integer.parseInt(input.subSequence(start, end).toString(), 8)); [EOL]         return 1 + end - start; [EOL]     } [EOL]     return 0; [EOL] } 
lang3/text/FormattableUtils.java
 [LINE] public static Formatter append(final CharSequence seq, final Formatter formatter, final int flags, final int width, [LINE] public static Formatter append(final CharSequence seq, final Formatter formatter, final int flags, final int width, final int precision) { [EOL]     return append(seq, formatter, flags, width, precision, ' ', null); [EOL] } 
 [LINE] public static Formatter append(final CharSequence seq, final Formatter formatter, final int flags, final int width, [LINE] public static Formatter append(final CharSequence seq, final Formatter formatter, final int flags, final int width, final int precision, final CharSequence ellipsis) { [EOL]     return append(seq, formatter, flags, width, precision, ' ', ellipsis); [EOL] } 
 [LINE] Validate.isTrue(ellipsis == null || precision < 0 || ellipsis.length() <= precision, [LINE] public static Formatter append(final CharSequence seq, final Formatter formatter, final int flags, final int width, final int precision, final char padChar, final CharSequence ellipsis) { [EOL]     Validate.isTrue(ellipsis == null || precision < 0 || ellipsis.length() <= precision, "Specified ellipsis '%1$s' exceeds precision of %2$s", ellipsis, Integer.valueOf(precision)); [EOL]     final StringBuilder buf = new StringBuilder(seq); [EOL]     if (precision >= 0 && precision < seq.length()) { [EOL]         final CharSequence _ellipsis = ObjectUtils.defaultIfNull(ellipsis, StringUtils.EMPTY); [EOL]         buf.replace(precision - _ellipsis.length(), seq.length(), _ellipsis.toString()); [EOL]     } [EOL]     final boolean leftJustify = (flags & LEFT_JUSTIFY) == LEFT_JUSTIFY; [EOL]     for (int i = buf.length(); i < width; i++) { [EOL]         buf.insert(leftJustify ? i : 0, padChar); [EOL]     } [EOL]     formatter.format(buf.toString()); [EOL]     return formatter; [EOL] } 
 [LINE] final StringBuilder buf = new StringBuilder(seq); [LINE] public static Formatter append(final CharSequence seq, final Formatter formatter, final int flags, final int width, final int precision, final char padChar, final CharSequence ellipsis) { [EOL]     Validate.isTrue(ellipsis == null || precision < 0 || ellipsis.length() <= precision, "Specified ellipsis '%1$s' exceeds precision of %2$s", ellipsis, Integer.valueOf(precision)); [EOL]     final StringBuilder buf = new StringBuilder(seq); [EOL]     if (precision >= 0 && precision < seq.length()) { [EOL]         final CharSequence _ellipsis = ObjectUtils.defaultIfNull(ellipsis, StringUtils.EMPTY); [EOL]         buf.replace(precision - _ellipsis.length(), seq.length(), _ellipsis.toString()); [EOL]     } [EOL]     final boolean leftJustify = (flags & LEFT_JUSTIFY) == LEFT_JUSTIFY; [EOL]     for (int i = buf.length(); i < width; i++) { [EOL]         buf.insert(leftJustify ? i : 0, padChar); [EOL]     } [EOL]     formatter.format(buf.toString()); [EOL]     return formatter; [EOL] } 
lang3/text/translate/EntityArrays.java
lang3/concurrent/ConstantInitializer.java
 [LINE] return getObject(); [LINE] @Override [EOL] public T get() throws ConcurrentException { [EOL]     return getObject(); [EOL] } 
 [LINE] @Override [LINE] @Override [EOL] public int hashCode() { [EOL]     return getObject() != null ? getObject().hashCode() : 0; [EOL] } 
 [LINE] if (this == obj) { [LINE] @Override [EOL] public boolean equals(final Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (!(obj instanceof ConstantInitializer<?>)) { [EOL]         return false; [EOL]     } [EOL]     final ConstantInitializer<?> c = (ConstantInitializer<?>) obj; [EOL]     return ObjectUtils.equals(getObject(), c.getObject()); [EOL] } 
 [LINE] return true; [LINE] @Override [EOL] public boolean equals(final Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (!(obj instanceof ConstantInitializer<?>)) { [EOL]         return false; [EOL]     } [EOL]     final ConstantInitializer<?> c = (ConstantInitializer<?>) obj; [EOL]     return ObjectUtils.equals(getObject(), c.getObject()); [EOL] } 
 [LINE] return String.format(FMT_TO_STRING, Integer.valueOf(System.identityHashCode(this)), [LINE] @Override [EOL] public String toString() { [EOL]     return String.format(FMT_TO_STRING, Integer.valueOf(System.identityHashCode(this)), String.valueOf(getObject())); [EOL] } 
lang3/text/translate/CharSequenceTranslator.java
 [LINE] try { [LINE] public final String translate(final CharSequence input) { [EOL]     if (input == null) { [EOL]         return null; [EOL]     } [EOL]     try { [EOL]         final StringWriter writer = new StringWriter(input.length() * 2); [EOL]         translate(input, writer); [EOL]         return writer.toString(); [EOL]     } catch (final IOException ioe) { [EOL]         throw new RuntimeException(ioe); [EOL]     } [EOL] } 
 [LINE] throw new IllegalArgumentException("The Writer must not be null"); [LINE] public final void translate(final CharSequence input, final Writer out) throws IOException { [EOL]     if (out == null) { [EOL]         throw new IllegalArgumentException("The Writer must not be null"); [EOL]     } [EOL]     if (input == null) { [EOL]         return; [EOL]     } [EOL]     int pos = 0; [EOL]     final int len = input.length(); [EOL]     while (pos < len) { [EOL]         final int consumed = translate(input, pos, out); [EOL]         if (consumed == 0) { [EOL]             final char[] c = Character.toChars(Character.codePointAt(input, pos)); [EOL]             out.write(c); [EOL]             pos += c.length; [EOL]             continue; [EOL]         } [EOL]         for (int pt = 0; pt < consumed; pt++) { [EOL]             pos += Character.charCount(Character.codePointAt(input, pt)); [EOL]         } [EOL]     } [EOL] } 
 [LINE] int pos = 0; [LINE] public final void translate(final CharSequence input, final Writer out) throws IOException { [EOL]     if (out == null) { [EOL]         throw new IllegalArgumentException("The Writer must not be null"); [EOL]     } [EOL]     if (input == null) { [EOL]         return; [EOL]     } [EOL]     int pos = 0; [EOL]     final int len = input.length(); [EOL]     while (pos < len) { [EOL]         final int consumed = translate(input, pos, out); [EOL]         if (consumed == 0) { [EOL]             final char[] c = Character.toChars(Character.codePointAt(input, pos)); [EOL]             out.write(c); [EOL]             pos += c.length; [EOL]             continue; [EOL]         } [EOL]         for (int pt = 0; pt < consumed; pt++) { [EOL]             pos += Character.charCount(Character.codePointAt(input, pt)); [EOL]         } [EOL]     } [EOL] } 
 [LINE] if (consumed == 0) { [LINE] public final void translate(final CharSequence input, final Writer out) throws IOException { [EOL]     if (out == null) { [EOL]         throw new IllegalArgumentException("The Writer must not be null"); [EOL]     } [EOL]     if (input == null) { [EOL]         return; [EOL]     } [EOL]     int pos = 0; [EOL]     final int len = input.length(); [EOL]     while (pos < len) { [EOL]         final int consumed = translate(input, pos, out); [EOL]         if (consumed == 0) { [EOL]             final char[] c = Character.toChars(Character.codePointAt(input, pos)); [EOL]             out.write(c); [EOL]             pos += c.length; [EOL]             continue; [EOL]         } [EOL]         for (int pt = 0; pt < consumed; pt++) { [EOL]             pos += Character.charCount(Character.codePointAt(input, pt)); [EOL]         } [EOL]     } [EOL] } 
 [LINE] out.write(c); [LINE] public final void translate(final CharSequence input, final Writer out) throws IOException { [EOL]     if (out == null) { [EOL]         throw new IllegalArgumentException("The Writer must not be null"); [EOL]     } [EOL]     if (input == null) { [EOL]         return; [EOL]     } [EOL]     int pos = 0; [EOL]     final int len = input.length(); [EOL]     while (pos < len) { [EOL]         final int consumed = translate(input, pos, out); [EOL]         if (consumed == 0) { [EOL]             final char[] c = Character.toChars(Character.codePointAt(input, pos)); [EOL]             out.write(c); [EOL]             pos += c.length; [EOL]             continue; [EOL]         } [EOL]         for (int pt = 0; pt < consumed; pt++) { [EOL]             pos += Character.charCount(Character.codePointAt(input, pt)); [EOL]         } [EOL]     } [EOL] } 
 [LINE] continue; [LINE] public final void translate(final CharSequence input, final Writer out) throws IOException { [EOL]     if (out == null) { [EOL]         throw new IllegalArgumentException("The Writer must not be null"); [EOL]     } [EOL]     if (input == null) { [EOL]         return; [EOL]     } [EOL]     int pos = 0; [EOL]     final int len = input.length(); [EOL]     while (pos < len) { [EOL]         final int consumed = translate(input, pos, out); [EOL]         if (consumed == 0) { [EOL]             final char[] c = Character.toChars(Character.codePointAt(input, pos)); [EOL]             out.write(c); [EOL]             pos += c.length; [EOL]             continue; [EOL]         } [EOL]         for (int pt = 0; pt < consumed; pt++) { [EOL]             pos += Character.charCount(Character.codePointAt(input, pt)); [EOL]         } [EOL]     } [EOL] } 
 [LINE] pos += Character.charCount(Character.codePointAt(input, pt)); [LINE] public final void translate(final CharSequence input, final Writer out) throws IOException { [EOL]     if (out == null) { [EOL]         throw new IllegalArgumentException("The Writer must not be null"); [EOL]     } [EOL]     if (input == null) { [EOL]         return; [EOL]     } [EOL]     int pos = 0; [EOL]     final int len = input.length(); [EOL]     while (pos < len) { [EOL]         final int consumed = translate(input, pos, out); [EOL]         if (consumed == 0) { [EOL]             final char[] c = Character.toChars(Character.codePointAt(input, pos)); [EOL]             out.write(c); [EOL]             pos += c.length; [EOL]             continue; [EOL]         } [EOL]         for (int pt = 0; pt < consumed; pt++) { [EOL]             pos += Character.charCount(Character.codePointAt(input, pt)); [EOL]         } [EOL]     } [EOL] } 
lang3/time/DurationFormatUtils.java
 [LINE] duration = tmp; [LINE] public static String formatDurationWords(final long durationMillis, final boolean suppressLeadingZeroElements, final boolean suppressTrailingZeroElements) { [EOL]     String duration = formatDuration(durationMillis, "d' days 'H' hours 'm' minutes 's' seconds'"); [EOL]     if (suppressLeadingZeroElements) { [EOL]         duration = " " + duration; [EOL]         String tmp = StringUtils.replaceOnce(duration, " 0 days", ""); [EOL]         if (tmp.length() != duration.length()) { [EOL]             duration = tmp; [EOL]             tmp = StringUtils.replaceOnce(duration, " 0 hours", ""); [EOL]             if (tmp.length() != duration.length()) { [EOL]                 duration = tmp; [EOL]                 tmp = StringUtils.replaceOnce(duration, " 0 minutes", ""); [EOL]                 duration = tmp; [EOL]                 if (tmp.length() != duration.length()) { [EOL]                     duration = StringUtils.replaceOnce(tmp, " 0 seconds", ""); [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (duration.length() != 0) { [EOL]             duration = duration.substring(1); [EOL]         } [EOL]     } [EOL]     if (suppressTrailingZeroElements) { [EOL]         String tmp = StringUtils.replaceOnce(duration, " 0 seconds", ""); [EOL]         if (tmp.length() != duration.length()) { [EOL]             duration = tmp; [EOL]             tmp = StringUtils.replaceOnce(duration, " 0 minutes", ""); [EOL]             if (tmp.length() != duration.length()) { [EOL]                 duration = tmp; [EOL]                 tmp = StringUtils.replaceOnce(duration, " 0 hours", ""); [EOL]                 if (tmp.length() != duration.length()) { [EOL]                     duration = StringUtils.replaceOnce(tmp, " 0 days", ""); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     duration = " " + duration; [EOL]     duration = StringUtils.replaceOnce(duration, " 1 seconds", " 1 second"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 minutes", " 1 minute"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 hours", " 1 hour"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 days", " 1 day"); [EOL]     return duration.trim(); [EOL] } 
 [LINE] tmp = StringUtils.replaceOnce(duration, " 0 hours", ""); [LINE] public static String formatDurationWords(final long durationMillis, final boolean suppressLeadingZeroElements, final boolean suppressTrailingZeroElements) { [EOL]     String duration = formatDuration(durationMillis, "d' days 'H' hours 'm' minutes 's' seconds'"); [EOL]     if (suppressLeadingZeroElements) { [EOL]         duration = " " + duration; [EOL]         String tmp = StringUtils.replaceOnce(duration, " 0 days", ""); [EOL]         if (tmp.length() != duration.length()) { [EOL]             duration = tmp; [EOL]             tmp = StringUtils.replaceOnce(duration, " 0 hours", ""); [EOL]             if (tmp.length() != duration.length()) { [EOL]                 duration = tmp; [EOL]                 tmp = StringUtils.replaceOnce(duration, " 0 minutes", ""); [EOL]                 duration = tmp; [EOL]                 if (tmp.length() != duration.length()) { [EOL]                     duration = StringUtils.replaceOnce(tmp, " 0 seconds", ""); [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (duration.length() != 0) { [EOL]             duration = duration.substring(1); [EOL]         } [EOL]     } [EOL]     if (suppressTrailingZeroElements) { [EOL]         String tmp = StringUtils.replaceOnce(duration, " 0 seconds", ""); [EOL]         if (tmp.length() != duration.length()) { [EOL]             duration = tmp; [EOL]             tmp = StringUtils.replaceOnce(duration, " 0 minutes", ""); [EOL]             if (tmp.length() != duration.length()) { [EOL]                 duration = tmp; [EOL]                 tmp = StringUtils.replaceOnce(duration, " 0 hours", ""); [EOL]                 if (tmp.length() != duration.length()) { [EOL]                     duration = StringUtils.replaceOnce(tmp, " 0 days", ""); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     duration = " " + duration; [EOL]     duration = StringUtils.replaceOnce(duration, " 1 seconds", " 1 second"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 minutes", " 1 minute"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 hours", " 1 hour"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 days", " 1 day"); [EOL]     return duration.trim(); [EOL] } 
 [LINE] tmp = StringUtils.replaceOnce(duration, " 0 minutes", ""); [LINE] public static String formatDurationWords(final long durationMillis, final boolean suppressLeadingZeroElements, final boolean suppressTrailingZeroElements) { [EOL]     String duration = formatDuration(durationMillis, "d' days 'H' hours 'm' minutes 's' seconds'"); [EOL]     if (suppressLeadingZeroElements) { [EOL]         duration = " " + duration; [EOL]         String tmp = StringUtils.replaceOnce(duration, " 0 days", ""); [EOL]         if (tmp.length() != duration.length()) { [EOL]             duration = tmp; [EOL]             tmp = StringUtils.replaceOnce(duration, " 0 hours", ""); [EOL]             if (tmp.length() != duration.length()) { [EOL]                 duration = tmp; [EOL]                 tmp = StringUtils.replaceOnce(duration, " 0 minutes", ""); [EOL]                 duration = tmp; [EOL]                 if (tmp.length() != duration.length()) { [EOL]                     duration = StringUtils.replaceOnce(tmp, " 0 seconds", ""); [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (duration.length() != 0) { [EOL]             duration = duration.substring(1); [EOL]         } [EOL]     } [EOL]     if (suppressTrailingZeroElements) { [EOL]         String tmp = StringUtils.replaceOnce(duration, " 0 seconds", ""); [EOL]         if (tmp.length() != duration.length()) { [EOL]             duration = tmp; [EOL]             tmp = StringUtils.replaceOnce(duration, " 0 minutes", ""); [EOL]             if (tmp.length() != duration.length()) { [EOL]                 duration = tmp; [EOL]                 tmp = StringUtils.replaceOnce(duration, " 0 hours", ""); [EOL]                 if (tmp.length() != duration.length()) { [EOL]                     duration = StringUtils.replaceOnce(tmp, " 0 days", ""); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     duration = " " + duration; [EOL]     duration = StringUtils.replaceOnce(duration, " 1 seconds", " 1 second"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 minutes", " 1 minute"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 hours", " 1 hour"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 days", " 1 day"); [EOL]     return duration.trim(); [EOL] } 
 [LINE] tmp = StringUtils.replaceOnce(duration, " 0 minutes", ""); [LINE] public static String formatDurationWords(final long durationMillis, final boolean suppressLeadingZeroElements, final boolean suppressTrailingZeroElements) { [EOL]     String duration = formatDuration(durationMillis, "d' days 'H' hours 'm' minutes 's' seconds'"); [EOL]     if (suppressLeadingZeroElements) { [EOL]         duration = " " + duration; [EOL]         String tmp = StringUtils.replaceOnce(duration, " 0 days", ""); [EOL]         if (tmp.length() != duration.length()) { [EOL]             duration = tmp; [EOL]             tmp = StringUtils.replaceOnce(duration, " 0 hours", ""); [EOL]             if (tmp.length() != duration.length()) { [EOL]                 duration = tmp; [EOL]                 tmp = StringUtils.replaceOnce(duration, " 0 minutes", ""); [EOL]                 duration = tmp; [EOL]                 if (tmp.length() != duration.length()) { [EOL]                     duration = StringUtils.replaceOnce(tmp, " 0 seconds", ""); [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (duration.length() != 0) { [EOL]             duration = duration.substring(1); [EOL]         } [EOL]     } [EOL]     if (suppressTrailingZeroElements) { [EOL]         String tmp = StringUtils.replaceOnce(duration, " 0 seconds", ""); [EOL]         if (tmp.length() != duration.length()) { [EOL]             duration = tmp; [EOL]             tmp = StringUtils.replaceOnce(duration, " 0 minutes", ""); [EOL]             if (tmp.length() != duration.length()) { [EOL]                 duration = tmp; [EOL]                 tmp = StringUtils.replaceOnce(duration, " 0 hours", ""); [EOL]                 if (tmp.length() != duration.length()) { [EOL]                     duration = StringUtils.replaceOnce(tmp, " 0 days", ""); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     duration = " " + duration; [EOL]     duration = StringUtils.replaceOnce(duration, " 1 seconds", " 1 second"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 minutes", " 1 minute"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 hours", " 1 hour"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 days", " 1 day"); [EOL]     return duration.trim(); [EOL] } 
 [LINE] end.setTime(new Date(endMillis)); [LINE] public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, final TimeZone timezone) { [EOL]     final Token[] tokens = lexx(format); [EOL]     final Calendar start = Calendar.getInstance(timezone); [EOL]     start.setTime(new Date(startMillis)); [EOL]     final Calendar end = Calendar.getInstance(timezone); [EOL]     end.setTime(new Date(endMillis)); [EOL]     int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND); [EOL]     int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND); [EOL]     int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE); [EOL]     int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY); [EOL]     int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH); [EOL]     int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH); [EOL]     int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR); [EOL]     while (milliseconds < 0) { [EOL]         milliseconds += 1000; [EOL]         seconds -= 1; [EOL]     } [EOL]     while (seconds < 0) { [EOL]         seconds += 60; [EOL]         minutes -= 1; [EOL]     } [EOL]     while (minutes < 0) { [EOL]         minutes += 60; [EOL]         hours -= 1; [EOL]     } [EOL]     while (hours < 0) { [EOL]         hours += 24; [EOL]         days -= 1; [EOL]     } [EOL]     if (Token.containsTokenWithValue(tokens, M)) { [EOL]         while (days < 0) { [EOL]             days += start.getActualMaximum(Calendar.DAY_OF_MONTH); [EOL]             months -= 1; [EOL]             start.add(Calendar.MONTH, 1); [EOL]         } [EOL]         while (months < 0) { [EOL]             months += 12; [EOL]             years -= 1; [EOL]         } [EOL]         if (!Token.containsTokenWithValue(tokens, y) && years != 0) { [EOL]             while (years != 0) { [EOL]                 months += 12 * years; [EOL]                 years = 0; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (!Token.containsTokenWithValue(tokens, y)) { [EOL]             int target = end.get(Calendar.YEAR); [EOL]             if (months < 0) { [EOL]                 target -= 1; [EOL]             } [EOL]             while (start.get(Calendar.YEAR) != target) { [EOL]                 days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR); [EOL]                 if (start instanceof GregorianCalendar && start.get(Calendar.MONTH) == Calendar.FEBRUARY && start.get(Calendar.DAY_OF_MONTH) == 29) { [EOL]                     days += 1; [EOL]                 } [EOL]                 start.add(Calendar.YEAR, 1); [EOL]                 days += start.get(Calendar.DAY_OF_YEAR); [EOL]             } [EOL]             years = 0; [EOL]         } [EOL]         while (start.get(Calendar.MONTH) != end.get(Calendar.MONTH)) { [EOL]             days += start.getActualMaximum(Calendar.DAY_OF_MONTH); [EOL]             start.add(Calendar.MONTH, 1); [EOL]         } [EOL]         months = 0; [EOL]         while (days < 0) { [EOL]             days += start.getActualMaximum(Calendar.DAY_OF_MONTH); [EOL]             months -= 1; [EOL]             start.add(Calendar.MONTH, 1); [EOL]         } [EOL]     } [EOL]     if (!Token.containsTokenWithValue(tokens, d)) { [EOL]         hours += 24 * days; [EOL]         days = 0; [EOL]     } [EOL]     if (!Token.containsTokenWithValue(tokens, H)) { [EOL]         minutes += 60 * hours; [EOL]         hours = 0; [EOL]     } [EOL]     if (!Token.containsTokenWithValue(tokens, m)) { [EOL]         seconds += 60 * minutes; [EOL]         minutes = 0; [EOL]     } [EOL]     if (!Token.containsTokenWithValue(tokens, s)) { [EOL]         milliseconds += 1000 * seconds; [EOL]         seconds = 0; [EOL]     } [EOL]     return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros); [EOL] } 
 [LINE] int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH); [LINE] public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, final TimeZone timezone) { [EOL]     final Token[] tokens = lexx(format); [EOL]     final Calendar start = Calendar.getInstance(timezone); [EOL]     start.setTime(new Date(startMillis)); [EOL]     final Calendar end = Calendar.getInstance(timezone); [EOL]     end.setTime(new Date(endMillis)); [EOL]     int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND); [EOL]     int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND); [EOL]     int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE); [EOL]     int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY); [EOL]     int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH); [EOL]     int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH); [EOL]     int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR); [EOL]     while (milliseconds < 0) { [EOL]         milliseconds += 1000; [EOL]         seconds -= 1; [EOL]     } [EOL]     while (seconds < 0) { [EOL]         seconds += 60; [EOL]         minutes -= 1; [EOL]     } [EOL]     while (minutes < 0) { [EOL]         minutes += 60; [EOL]         hours -= 1; [EOL]     } [EOL]     while (hours < 0) { [EOL]         hours += 24; [EOL]         days -= 1; [EOL]     } [EOL]     if (Token.containsTokenWithValue(tokens, M)) { [EOL]         while (days < 0) { [EOL]             days += start.getActualMaximum(Calendar.DAY_OF_MONTH); [EOL]             months -= 1; [EOL]             start.add(Calendar.MONTH, 1); [EOL]         } [EOL]         while (months < 0) { [EOL]             months += 12; [EOL]             years -= 1; [EOL]         } [EOL]         if (!Token.containsTokenWithValue(tokens, y) && years != 0) { [EOL]             while (years != 0) { [EOL]                 months += 12 * years; [EOL]                 years = 0; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (!Token.containsTokenWithValue(tokens, y)) { [EOL]             int target = end.get(Calendar.YEAR); [EOL]             if (months < 0) { [EOL]                 target -= 1; [EOL]             } [EOL]             while (start.get(Calendar.YEAR) != target) { [EOL]                 days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR); [EOL]                 if (start instanceof GregorianCalendar && start.get(Calendar.MONTH) == Calendar.FEBRUARY && start.get(Calendar.DAY_OF_MONTH) == 29) { [EOL]                     days += 1; [EOL]                 } [EOL]                 start.add(Calendar.YEAR, 1); [EOL]                 days += start.get(Calendar.DAY_OF_YEAR); [EOL]             } [EOL]             years = 0; [EOL]         } [EOL]         while (start.get(Calendar.MONTH) != end.get(Calendar.MONTH)) { [EOL]             days += start.getActualMaximum(Calendar.DAY_OF_MONTH); [EOL]             start.add(Calendar.MONTH, 1); [EOL]         } [EOL]         months = 0; [EOL]         while (days < 0) { [EOL]             days += start.getActualMaximum(Calendar.DAY_OF_MONTH); [EOL]             months -= 1; [EOL]             start.add(Calendar.MONTH, 1); [EOL]         } [EOL]     } [EOL]     if (!Token.containsTokenWithValue(tokens, d)) { [EOL]         hours += 24 * days; [EOL]         days = 0; [EOL]     } [EOL]     if (!Token.containsTokenWithValue(tokens, H)) { [EOL]         minutes += 60 * hours; [EOL]         hours = 0; [EOL]     } [EOL]     if (!Token.containsTokenWithValue(tokens, m)) { [EOL]         seconds += 60 * minutes; [EOL]         minutes = 0; [EOL]     } [EOL]     if (!Token.containsTokenWithValue(tokens, s)) { [EOL]         milliseconds += 1000 * seconds; [EOL]         seconds = 0; [EOL]     } [EOL]     return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros); [EOL] } 
 [LINE] int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH); [LINE] public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, final TimeZone timezone) { [EOL]     final Token[] tokens = lexx(format); [EOL]     final Calendar start = Calendar.getInstance(timezone); [EOL]     start.setTime(new Date(startMillis)); [EOL]     final Calendar end = Calendar.getInstance(timezone); [EOL]     end.setTime(new Date(endMillis)); [EOL]     int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND); [EOL]     int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND); [EOL]     int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE); [EOL]     int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY); [EOL]     int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH); [EOL]     int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH); [EOL]     int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR); [EOL]     while (milliseconds < 0) { [EOL]         milliseconds += 1000; [EOL]         seconds -= 1; [EOL]     } [EOL]     while (seconds < 0) { [EOL]         seconds += 60; [EOL]         minutes -= 1; [EOL]     } [EOL]     while (minutes < 0) { [EOL]         minutes += 60; [EOL]         hours -= 1; [EOL]     } [EOL]     while (hours < 0) { [EOL]         hours += 24; [EOL]         days -= 1; [EOL]     } [EOL]     if (Token.containsTokenWithValue(tokens, M)) { [EOL]         while (days < 0) { [EOL]             days += start.getActualMaximum(Calendar.DAY_OF_MONTH); [EOL]             months -= 1; [EOL]             start.add(Calendar.MONTH, 1); [EOL]         } [EOL]         while (months < 0) { [EOL]             months += 12; [EOL]             years -= 1; [EOL]         } [EOL]         if (!Token.containsTokenWithValue(tokens, y) && years != 0) { [EOL]             while (years != 0) { [EOL]                 months += 12 * years; [EOL]                 years = 0; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (!Token.containsTokenWithValue(tokens, y)) { [EOL]             int target = end.get(Calendar.YEAR); [EOL]             if (months < 0) { [EOL]                 target -= 1; [EOL]             } [EOL]             while (start.get(Calendar.YEAR) != target) { [EOL]                 days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR); [EOL]                 if (start instanceof GregorianCalendar && start.get(Calendar.MONTH) == Calendar.FEBRUARY && start.get(Calendar.DAY_OF_MONTH) == 29) { [EOL]                     days += 1; [EOL]                 } [EOL]                 start.add(Calendar.YEAR, 1); [EOL]                 days += start.get(Calendar.DAY_OF_YEAR); [EOL]             } [EOL]             years = 0; [EOL]         } [EOL]         while (start.get(Calendar.MONTH) != end.get(Calendar.MONTH)) { [EOL]             days += start.getActualMaximum(Calendar.DAY_OF_MONTH); [EOL]             start.add(Calendar.MONTH, 1); [EOL]         } [EOL]         months = 0; [EOL]         while (days < 0) { [EOL]             days += start.getActualMaximum(Calendar.DAY_OF_MONTH); [EOL]             months -= 1; [EOL]             start.add(Calendar.MONTH, 1); [EOL]         } [EOL]     } [EOL]     if (!Token.containsTokenWithValue(tokens, d)) { [EOL]         hours += 24 * days; [EOL]         days = 0; [EOL]     } [EOL]     if (!Token.containsTokenWithValue(tokens, H)) { [EOL]         minutes += 60 * hours; [EOL]         hours = 0; [EOL]     } [EOL]     if (!Token.containsTokenWithValue(tokens, m)) { [EOL]         seconds += 60 * minutes; [EOL]         minutes = 0; [EOL]     } [EOL]     if (!Token.containsTokenWithValue(tokens, s)) { [EOL]         milliseconds += 1000 * seconds; [EOL]         seconds = 0; [EOL]     } [EOL]     return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros); [EOL] } 
 [LINE] int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR); [LINE] public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, final TimeZone timezone) { [EOL]     final Token[] tokens = lexx(format); [EOL]     final Calendar start = Calendar.getInstance(timezone); [EOL]     start.setTime(new Date(startMillis)); [EOL]     final Calendar end = Calendar.getInstance(timezone); [EOL]     end.setTime(new Date(endMillis)); [EOL]     int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND); [EOL]     int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND); [EOL]     int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE); [EOL]     int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY); [EOL]     int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH); [EOL]     int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH); [EOL]     int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR); [EOL]     while (milliseconds < 0) { [EOL]         milliseconds += 1000; [EOL]         seconds -= 1; [EOL]     } [EOL]     while (seconds < 0) { [EOL]         seconds += 60; [EOL]         minutes -= 1; [EOL]     } [EOL]     while (minutes < 0) { [EOL]         minutes += 60; [EOL]         hours -= 1; [EOL]     } [EOL]     while (hours < 0) { [EOL]         hours += 24; [EOL]         days -= 1; [EOL]     } [EOL]     if (Token.containsTokenWithValue(tokens, M)) { [EOL]         while (days < 0) { [EOL]             days += start.getActualMaximum(Calendar.DAY_OF_MONTH); [EOL]             months -= 1; [EOL]             start.add(Calendar.MONTH, 1); [EOL]         } [EOL]         while (months < 0) { [EOL]             months += 12; [EOL]             years -= 1; [EOL]         } [EOL]         if (!Token.containsTokenWithValue(tokens, y) && years != 0) { [EOL]             while (years != 0) { [EOL]                 months += 12 * years; [EOL]                 years = 0; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (!Token.containsTokenWithValue(tokens, y)) { [EOL]             int target = end.get(Calendar.YEAR); [EOL]             if (months < 0) { [EOL]                 target -= 1; [EOL]             } [EOL]             while (start.get(Calendar.YEAR) != target) { [EOL]                 days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR); [EOL]                 if (start instanceof GregorianCalendar && start.get(Calendar.MONTH) == Calendar.FEBRUARY && start.get(Calendar.DAY_OF_MONTH) == 29) { [EOL]                     days += 1; [EOL]                 } [EOL]                 start.add(Calendar.YEAR, 1); [EOL]                 days += start.get(Calendar.DAY_OF_YEAR); [EOL]             } [EOL]             years = 0; [EOL]         } [EOL]         while (start.get(Calendar.MONTH) != end.get(Calendar.MONTH)) { [EOL]             days += start.getActualMaximum(Calendar.DAY_OF_MONTH); [EOL]             start.add(Calendar.MONTH, 1); [EOL]         } [EOL]         months = 0; [EOL]         while (days < 0) { [EOL]             days += start.getActualMaximum(Calendar.DAY_OF_MONTH); [EOL]             months -= 1; [EOL]             start.add(Calendar.MONTH, 1); [EOL]         } [EOL]     } [EOL]     if (!Token.containsTokenWithValue(tokens, d)) { [EOL]         hours += 24 * days; [EOL]         days = 0; [EOL]     } [EOL]     if (!Token.containsTokenWithValue(tokens, H)) { [EOL]         minutes += 60 * hours; [EOL]         hours = 0; [EOL]     } [EOL]     if (!Token.containsTokenWithValue(tokens, m)) { [EOL]         seconds += 60 * minutes; [EOL]         minutes = 0; [EOL]     } [EOL]     if (!Token.containsTokenWithValue(tokens, s)) { [EOL]         milliseconds += 1000 * seconds; [EOL]         seconds = 0; [EOL]     } [EOL]     return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros); [EOL] } 
 [LINE] while (milliseconds < 0) { [LINE] public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, final TimeZone timezone) { [EOL]     final Token[] tokens = lexx(format); [EOL]     final Calendar start = Calendar.getInstance(timezone); [EOL]     start.setTime(new Date(startMillis)); [EOL]     final Calendar end = Calendar.getInstance(timezone); [EOL]     end.setTime(new Date(endMillis)); [EOL]     int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND); [EOL]     int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND); [EOL]     int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE); [EOL]     int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY); [EOL]     int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH); [EOL]     int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH); [EOL]     int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR); [EOL]     while (milliseconds < 0) { [EOL]         milliseconds += 1000; [EOL]         seconds -= 1; [EOL]     } [EOL]     while (seconds < 0) { [EOL]         seconds += 60; [EOL]         minutes -= 1; [EOL]     } [EOL]     while (minutes < 0) { [EOL]         minutes += 60; [EOL]         hours -= 1; [EOL]     } [EOL]     while (hours < 0) { [EOL]         hours += 24; [EOL]         days -= 1; [EOL]     } [EOL]     if (Token.containsTokenWithValue(tokens, M)) { [EOL]         while (days < 0) { [EOL]             days += start.getActualMaximum(Calendar.DAY_OF_MONTH); [EOL]             months -= 1; [EOL]             start.add(Calendar.MONTH, 1); [EOL]         } [EOL]         while (months < 0) { [EOL]             months += 12; [EOL]             years -= 1; [EOL]         } [EOL]         if (!Token.containsTokenWithValue(tokens, y) && years != 0) { [EOL]             while (years != 0) { [EOL]                 months += 12 * years; [EOL]                 years = 0; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (!Token.containsTokenWithValue(tokens, y)) { [EOL]             int target = end.get(Calendar.YEAR); [EOL]             if (months < 0) { [EOL]                 target -= 1; [EOL]             } [EOL]             while (start.get(Calendar.YEAR) != target) { [EOL]                 days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR); [EOL]                 if (start instanceof GregorianCalendar && start.get(Calendar.MONTH) == Calendar.FEBRUARY && start.get(Calendar.DAY_OF_MONTH) == 29) { [EOL]                     days += 1; [EOL]                 } [EOL]                 start.add(Calendar.YEAR, 1); [EOL]                 days += start.get(Calendar.DAY_OF_YEAR); [EOL]             } [EOL]             years = 0; [EOL]         } [EOL]         while (start.get(Calendar.MONTH) != end.get(Calendar.MONTH)) { [EOL]             days += start.getActualMaximum(Calendar.DAY_OF_MONTH); [EOL]             start.add(Calendar.MONTH, 1); [EOL]         } [EOL]         months = 0; [EOL]         while (days < 0) { [EOL]             days += start.getActualMaximum(Calendar.DAY_OF_MONTH); [EOL]             months -= 1; [EOL]             start.add(Calendar.MONTH, 1); [EOL]         } [EOL]     } [EOL]     if (!Token.containsTokenWithValue(tokens, d)) { [EOL]         hours += 24 * days; [EOL]         days = 0; [EOL]     } [EOL]     if (!Token.containsTokenWithValue(tokens, H)) { [EOL]         minutes += 60 * hours; [EOL]         hours = 0; [EOL]     } [EOL]     if (!Token.containsTokenWithValue(tokens, m)) { [EOL]         seconds += 60 * minutes; [EOL]         minutes = 0; [EOL]     } [EOL]     if (!Token.containsTokenWithValue(tokens, s)) { [EOL]         milliseconds += 1000 * seconds; [EOL]         seconds = 0; [EOL]     } [EOL]     return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros); [EOL] } 
 [LINE] while (hours < 0) { [LINE] public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, final TimeZone timezone) { [EOL]     final Token[] tokens = lexx(format); [EOL]     final Calendar start = Calendar.getInstance(timezone); [EOL]     start.setTime(new Date(startMillis)); [EOL]     final Calendar end = Calendar.getInstance(timezone); [EOL]     end.setTime(new Date(endMillis)); [EOL]     int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND); [EOL]     int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND); [EOL]     int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE); [EOL]     int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY); [EOL]     int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH); [EOL]     int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH); [EOL]     int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR); [EOL]     while (milliseconds < 0) { [EOL]         milliseconds += 1000; [EOL]         seconds -= 1; [EOL]     } [EOL]     while (seconds < 0) { [EOL]         seconds += 60; [EOL]         minutes -= 1; [EOL]     } [EOL]     while (minutes < 0) { [EOL]         minutes += 60; [EOL]         hours -= 1; [EOL]     } [EOL]     while (hours < 0) { [EOL]         hours += 24; [EOL]         days -= 1; [EOL]     } [EOL]     if (Token.containsTokenWithValue(tokens, M)) { [EOL]         while (days < 0) { [EOL]             days += start.getActualMaximum(Calendar.DAY_OF_MONTH); [EOL]             months -= 1; [EOL]             start.add(Calendar.MONTH, 1); [EOL]         } [EOL]         while (months < 0) { [EOL]             months += 12; [EOL]             years -= 1; [EOL]         } [EOL]         if (!Token.containsTokenWithValue(tokens, y) && years != 0) { [EOL]             while (years != 0) { [EOL]                 months += 12 * years; [EOL]                 years = 0; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (!Token.containsTokenWithValue(tokens, y)) { [EOL]             int target = end.get(Calendar.YEAR); [EOL]             if (months < 0) { [EOL]                 target -= 1; [EOL]             } [EOL]             while (start.get(Calendar.YEAR) != target) { [EOL]                 days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR); [EOL]                 if (start instanceof GregorianCalendar && start.get(Calendar.MONTH) == Calendar.FEBRUARY && start.get(Calendar.DAY_OF_MONTH) == 29) { [EOL]                     days += 1; [EOL]                 } [EOL]                 start.add(Calendar.YEAR, 1); [EOL]                 days += start.get(Calendar.DAY_OF_YEAR); [EOL]             } [EOL]             years = 0; [EOL]         } [EOL]         while (start.get(Calendar.MONTH) != end.get(Calendar.MONTH)) { [EOL]             days += start.getActualMaximum(Calendar.DAY_OF_MONTH); [EOL]             start.add(Calendar.MONTH, 1); [EOL]         } [EOL]         months = 0; [EOL]         while (days < 0) { [EOL]             days += start.getActualMaximum(Calendar.DAY_OF_MONTH); [EOL]             months -= 1; [EOL]             start.add(Calendar.MONTH, 1); [EOL]         } [EOL]     } [EOL]     if (!Token.containsTokenWithValue(tokens, d)) { [EOL]         hours += 24 * days; [EOL]         days = 0; [EOL]     } [EOL]     if (!Token.containsTokenWithValue(tokens, H)) { [EOL]         minutes += 60 * hours; [EOL]         hours = 0; [EOL]     } [EOL]     if (!Token.containsTokenWithValue(tokens, m)) { [EOL]         seconds += 60 * minutes; [EOL]         minutes = 0; [EOL]     } [EOL]     if (!Token.containsTokenWithValue(tokens, s)) { [EOL]         milliseconds += 1000 * seconds; [EOL]         seconds = 0; [EOL]     } [EOL]     return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros); [EOL] } 
 [LINE] days -= 1; [LINE] public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, final TimeZone timezone) { [EOL]     final Token[] tokens = lexx(format); [EOL]     final Calendar start = Calendar.getInstance(timezone); [EOL]     start.setTime(new Date(startMillis)); [EOL]     final Calendar end = Calendar.getInstance(timezone); [EOL]     end.setTime(new Date(endMillis)); [EOL]     int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND); [EOL]     int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND); [EOL]     int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE); [EOL]     int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY); [EOL]     int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH); [EOL]     int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH); [EOL]     int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR); [EOL]     while (milliseconds < 0) { [EOL]         milliseconds += 1000; [EOL]         seconds -= 1; [EOL]     } [EOL]     while (seconds < 0) { [EOL]         seconds += 60; [EOL]         minutes -= 1; [EOL]     } [EOL]     while (minutes < 0) { [EOL]         minutes += 60; [EOL]         hours -= 1; [EOL]     } [EOL]     while (hours < 0) { [EOL]         hours += 24; [EOL]         days -= 1; [EOL]     } [EOL]     if (Token.containsTokenWithValue(tokens, M)) { [EOL]         while (days < 0) { [EOL]             days += start.getActualMaximum(Calendar.DAY_OF_MONTH); [EOL]             months -= 1; [EOL]             start.add(Calendar.MONTH, 1); [EOL]         } [EOL]         while (months < 0) { [EOL]             months += 12; [EOL]             years -= 1; [EOL]         } [EOL]         if (!Token.containsTokenWithValue(tokens, y) && years != 0) { [EOL]             while (years != 0) { [EOL]                 months += 12 * years; [EOL]                 years = 0; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (!Token.containsTokenWithValue(tokens, y)) { [EOL]             int target = end.get(Calendar.YEAR); [EOL]             if (months < 0) { [EOL]                 target -= 1; [EOL]             } [EOL]             while (start.get(Calendar.YEAR) != target) { [EOL]                 days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR); [EOL]                 if (start instanceof GregorianCalendar && start.get(Calendar.MONTH) == Calendar.FEBRUARY && start.get(Calendar.DAY_OF_MONTH) == 29) { [EOL]                     days += 1; [EOL]                 } [EOL]                 start.add(Calendar.YEAR, 1); [EOL]                 days += start.get(Calendar.DAY_OF_YEAR); [EOL]             } [EOL]             years = 0; [EOL]         } [EOL]         while (start.get(Calendar.MONTH) != end.get(Calendar.MONTH)) { [EOL]             days += start.getActualMaximum(Calendar.DAY_OF_MONTH); [EOL]             start.add(Calendar.MONTH, 1); [EOL]         } [EOL]         months = 0; [EOL]         while (days < 0) { [EOL]             days += start.getActualMaximum(Calendar.DAY_OF_MONTH); [EOL]             months -= 1; [EOL]             start.add(Calendar.MONTH, 1); [EOL]         } [EOL]     } [EOL]     if (!Token.containsTokenWithValue(tokens, d)) { [EOL]         hours += 24 * days; [EOL]         days = 0; [EOL]     } [EOL]     if (!Token.containsTokenWithValue(tokens, H)) { [EOL]         minutes += 60 * hours; [EOL]         hours = 0; [EOL]     } [EOL]     if (!Token.containsTokenWithValue(tokens, m)) { [EOL]         seconds += 60 * minutes; [EOL]         minutes = 0; [EOL]     } [EOL]     if (!Token.containsTokenWithValue(tokens, s)) { [EOL]         milliseconds += 1000 * seconds; [EOL]         seconds = 0; [EOL]     } [EOL]     return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros); [EOL] } 
 [LINE] if (months < 0) { [LINE] public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, final TimeZone timezone) { [EOL]     final Token[] tokens = lexx(format); [EOL]     final Calendar start = Calendar.getInstance(timezone); [EOL]     start.setTime(new Date(startMillis)); [EOL]     final Calendar end = Calendar.getInstance(timezone); [EOL]     end.setTime(new Date(endMillis)); [EOL]     int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND); [EOL]     int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND); [EOL]     int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE); [EOL]     int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY); [EOL]     int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH); [EOL]     int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH); [EOL]     int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR); [EOL]     while (milliseconds < 0) { [EOL]         milliseconds += 1000; [EOL]         seconds -= 1; [EOL]     } [EOL]     while (seconds < 0) { [EOL]         seconds += 60; [EOL]         minutes -= 1; [EOL]     } [EOL]     while (minutes < 0) { [EOL]         minutes += 60; [EOL]         hours -= 1; [EOL]     } [EOL]     while (hours < 0) { [EOL]         hours += 24; [EOL]         days -= 1; [EOL]     } [EOL]     if (Token.containsTokenWithValue(tokens, M)) { [EOL]         while (days < 0) { [EOL]             days += start.getActualMaximum(Calendar.DAY_OF_MONTH); [EOL]             months -= 1; [EOL]             start.add(Calendar.MONTH, 1); [EOL]         } [EOL]         while (months < 0) { [EOL]             months += 12; [EOL]             years -= 1; [EOL]         } [EOL]         if (!Token.containsTokenWithValue(tokens, y) && years != 0) { [EOL]             while (years != 0) { [EOL]                 months += 12 * years; [EOL]                 years = 0; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (!Token.containsTokenWithValue(tokens, y)) { [EOL]             int target = end.get(Calendar.YEAR); [EOL]             if (months < 0) { [EOL]                 target -= 1; [EOL]             } [EOL]             while (start.get(Calendar.YEAR) != target) { [EOL]                 days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR); [EOL]                 if (start instanceof GregorianCalendar && start.get(Calendar.MONTH) == Calendar.FEBRUARY && start.get(Calendar.DAY_OF_MONTH) == 29) { [EOL]                     days += 1; [EOL]                 } [EOL]                 start.add(Calendar.YEAR, 1); [EOL]                 days += start.get(Calendar.DAY_OF_YEAR); [EOL]             } [EOL]             years = 0; [EOL]         } [EOL]         while (start.get(Calendar.MONTH) != end.get(Calendar.MONTH)) { [EOL]             days += start.getActualMaximum(Calendar.DAY_OF_MONTH); [EOL]             start.add(Calendar.MONTH, 1); [EOL]         } [EOL]         months = 0; [EOL]         while (days < 0) { [EOL]             days += start.getActualMaximum(Calendar.DAY_OF_MONTH); [EOL]             months -= 1; [EOL]             start.add(Calendar.MONTH, 1); [EOL]         } [EOL]     } [EOL]     if (!Token.containsTokenWithValue(tokens, d)) { [EOL]         hours += 24 * days; [EOL]         days = 0; [EOL]     } [EOL]     if (!Token.containsTokenWithValue(tokens, H)) { [EOL]         minutes += 60 * hours; [EOL]         hours = 0; [EOL]     } [EOL]     if (!Token.containsTokenWithValue(tokens, m)) { [EOL]         seconds += 60 * minutes; [EOL]         minutes = 0; [EOL]     } [EOL]     if (!Token.containsTokenWithValue(tokens, s)) { [EOL]         milliseconds += 1000 * seconds; [EOL]         seconds = 0; [EOL]     } [EOL]     return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros); [EOL] } 
 [LINE] lastOutputSeconds = false; [LINE] static String format(final Token[] tokens, final int years, final int months, final int days, final int hours, final int minutes, final int seconds, int milliseconds, final boolean padWithZeros) { [EOL]     final StringBuilder buffer = new StringBuilder(); [EOL]     boolean lastOutputSeconds = false; [EOL]     final int sz = tokens.length; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         final Token token = tokens[i]; [EOL]         final Object value = token.getValue(); [EOL]         final int count = token.getCount(); [EOL]         if (value instanceof StringBuilder) { [EOL]             buffer.append(value.toString()); [EOL]         } else { [EOL]             if (value == y) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(years), count, '0') : Integer.toString(years)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == M) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(months), count, '0') : Integer.toString(months)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == d) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(days), count, '0') : Integer.toString(days)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == H) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(hours), count, '0') : Integer.toString(hours)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == m) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(minutes), count, '0') : Integer.toString(minutes)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == s) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(seconds), count, '0') : Integer.toString(seconds)); [EOL]                 lastOutputSeconds = true; [EOL]             } else if (value == S) { [EOL]                 if (lastOutputSeconds) { [EOL]                     milliseconds += 1000; [EOL]                     final String str = padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds); [EOL]                     buffer.append(str.substring(1)); [EOL]                 } else { [EOL]                     buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds)); [EOL]                 } [EOL]                 lastOutputSeconds = false; [EOL]             } [EOL]         } [EOL]     } [EOL]     return buffer.toString(); [EOL] } 
 [LINE] } else if (value == d) { [LINE] static String format(final Token[] tokens, final int years, final int months, final int days, final int hours, final int minutes, final int seconds, int milliseconds, final boolean padWithZeros) { [EOL]     final StringBuilder buffer = new StringBuilder(); [EOL]     boolean lastOutputSeconds = false; [EOL]     final int sz = tokens.length; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         final Token token = tokens[i]; [EOL]         final Object value = token.getValue(); [EOL]         final int count = token.getCount(); [EOL]         if (value instanceof StringBuilder) { [EOL]             buffer.append(value.toString()); [EOL]         } else { [EOL]             if (value == y) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(years), count, '0') : Integer.toString(years)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == M) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(months), count, '0') : Integer.toString(months)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == d) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(days), count, '0') : Integer.toString(days)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == H) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(hours), count, '0') : Integer.toString(hours)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == m) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(minutes), count, '0') : Integer.toString(minutes)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == s) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(seconds), count, '0') : Integer.toString(seconds)); [EOL]                 lastOutputSeconds = true; [EOL]             } else if (value == S) { [EOL]                 if (lastOutputSeconds) { [EOL]                     milliseconds += 1000; [EOL]                     final String str = padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds); [EOL]                     buffer.append(str.substring(1)); [EOL]                 } else { [EOL]                     buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds)); [EOL]                 } [EOL]                 lastOutputSeconds = false; [EOL]             } [EOL]         } [EOL]     } [EOL]     return buffer.toString(); [EOL] } 
 [LINE] buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(hours), count, '0') : Integer [LINE] static String format(final Token[] tokens, final int years, final int months, final int days, final int hours, final int minutes, final int seconds, int milliseconds, final boolean padWithZeros) { [EOL]     final StringBuilder buffer = new StringBuilder(); [EOL]     boolean lastOutputSeconds = false; [EOL]     final int sz = tokens.length; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         final Token token = tokens[i]; [EOL]         final Object value = token.getValue(); [EOL]         final int count = token.getCount(); [EOL]         if (value instanceof StringBuilder) { [EOL]             buffer.append(value.toString()); [EOL]         } else { [EOL]             if (value == y) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(years), count, '0') : Integer.toString(years)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == M) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(months), count, '0') : Integer.toString(months)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == d) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(days), count, '0') : Integer.toString(days)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == H) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(hours), count, '0') : Integer.toString(hours)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == m) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(minutes), count, '0') : Integer.toString(minutes)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == s) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(seconds), count, '0') : Integer.toString(seconds)); [EOL]                 lastOutputSeconds = true; [EOL]             } else if (value == S) { [EOL]                 if (lastOutputSeconds) { [EOL]                     milliseconds += 1000; [EOL]                     final String str = padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds); [EOL]                     buffer.append(str.substring(1)); [EOL]                 } else { [EOL]                     buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds)); [EOL]                 } [EOL]                 lastOutputSeconds = false; [EOL]             } [EOL]         } [EOL]     } [EOL]     return buffer.toString(); [EOL] } 
 [LINE] } else if (value == s) { [LINE] static String format(final Token[] tokens, final int years, final int months, final int days, final int hours, final int minutes, final int seconds, int milliseconds, final boolean padWithZeros) { [EOL]     final StringBuilder buffer = new StringBuilder(); [EOL]     boolean lastOutputSeconds = false; [EOL]     final int sz = tokens.length; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         final Token token = tokens[i]; [EOL]         final Object value = token.getValue(); [EOL]         final int count = token.getCount(); [EOL]         if (value instanceof StringBuilder) { [EOL]             buffer.append(value.toString()); [EOL]         } else { [EOL]             if (value == y) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(years), count, '0') : Integer.toString(years)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == M) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(months), count, '0') : Integer.toString(months)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == d) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(days), count, '0') : Integer.toString(days)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == H) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(hours), count, '0') : Integer.toString(hours)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == m) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(minutes), count, '0') : Integer.toString(minutes)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == s) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(seconds), count, '0') : Integer.toString(seconds)); [EOL]                 lastOutputSeconds = true; [EOL]             } else if (value == S) { [EOL]                 if (lastOutputSeconds) { [EOL]                     milliseconds += 1000; [EOL]                     final String str = padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds); [EOL]                     buffer.append(str.substring(1)); [EOL]                 } else { [EOL]                     buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds)); [EOL]                 } [EOL]                 lastOutputSeconds = false; [EOL]             } [EOL]         } [EOL]     } [EOL]     return buffer.toString(); [EOL] } 
 [LINE] lastOutputSeconds = true; [LINE] static String format(final Token[] tokens, final int years, final int months, final int days, final int hours, final int minutes, final int seconds, int milliseconds, final boolean padWithZeros) { [EOL]     final StringBuilder buffer = new StringBuilder(); [EOL]     boolean lastOutputSeconds = false; [EOL]     final int sz = tokens.length; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         final Token token = tokens[i]; [EOL]         final Object value = token.getValue(); [EOL]         final int count = token.getCount(); [EOL]         if (value instanceof StringBuilder) { [EOL]             buffer.append(value.toString()); [EOL]         } else { [EOL]             if (value == y) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(years), count, '0') : Integer.toString(years)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == M) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(months), count, '0') : Integer.toString(months)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == d) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(days), count, '0') : Integer.toString(days)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == H) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(hours), count, '0') : Integer.toString(hours)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == m) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(minutes), count, '0') : Integer.toString(minutes)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == s) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(seconds), count, '0') : Integer.toString(seconds)); [EOL]                 lastOutputSeconds = true; [EOL]             } else if (value == S) { [EOL]                 if (lastOutputSeconds) { [EOL]                     milliseconds += 1000; [EOL]                     final String str = padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds); [EOL]                     buffer.append(str.substring(1)); [EOL]                 } else { [EOL]                     buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds)); [EOL]                 } [EOL]                 lastOutputSeconds = false; [EOL]             } [EOL]         } [EOL]     } [EOL]     return buffer.toString(); [EOL] } 
 [LINE] list.add(new Token(buffer)); [LINE] static Token[] lexx(final String format) { [EOL]     final char[] array = format.toCharArray(); [EOL]     final ArrayList<Token> list = new ArrayList<Token>(array.length); [EOL]     boolean inLiteral = false; [EOL]     StringBuilder buffer = null; [EOL]     Token previous = null; [EOL]     final int sz = array.length; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         final char ch = array[i]; [EOL]         if (inLiteral && ch != '\'') { [EOL]             buffer.append(ch); [EOL]             continue; [EOL]         } [EOL]         Object value = null; [EOL]         switch(ch) { [EOL]             case '\'': [EOL]                 if (inLiteral) { [EOL]                     buffer = null; [EOL]                     inLiteral = false; [EOL]                 } else { [EOL]                     buffer = new StringBuilder(); [EOL]                     list.add(new Token(buffer)); [EOL]                     inLiteral = true; [EOL]                 } [EOL]                 break; [EOL]             case 'y': [EOL]                 value = y; [EOL]                 break; [EOL]             case 'M': [EOL]                 value = M; [EOL]                 break; [EOL]             case 'd': [EOL]                 value = d; [EOL]                 break; [EOL]             case 'H': [EOL]                 value = H; [EOL]                 break; [EOL]             case 'm': [EOL]                 value = m; [EOL]                 break; [EOL]             case 's': [EOL]                 value = s; [EOL]                 break; [EOL]             case 'S': [EOL]                 value = S; [EOL]                 break; [EOL]             default: [EOL]                 if (buffer == null) { [EOL]                     buffer = new StringBuilder(); [EOL]                     list.add(new Token(buffer)); [EOL]                 } [EOL]                 buffer.append(ch); [EOL]         } [EOL]         if (value != null) { [EOL]             if (previous != null && previous.getValue() == value) { [EOL]                 previous.increment(); [EOL]             } else { [EOL]                 final Token token = new Token(value); [EOL]                 list.add(token); [EOL]                 previous = token; [EOL]             } [EOL]             buffer = null; [EOL]         } [EOL]     } [EOL]     return list.toArray(new Token[list.size()]); [EOL] } 
 [LINE] default: [LINE] static Token[] lexx(final String format) { [EOL]     final char[] array = format.toCharArray(); [EOL]     final ArrayList<Token> list = new ArrayList<Token>(array.length); [EOL]     boolean inLiteral = false; [EOL]     StringBuilder buffer = null; [EOL]     Token previous = null; [EOL]     final int sz = array.length; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         final char ch = array[i]; [EOL]         if (inLiteral && ch != '\'') { [EOL]             buffer.append(ch); [EOL]             continue; [EOL]         } [EOL]         Object value = null; [EOL]         switch(ch) { [EOL]             case '\'': [EOL]                 if (inLiteral) { [EOL]                     buffer = null; [EOL]                     inLiteral = false; [EOL]                 } else { [EOL]                     buffer = new StringBuilder(); [EOL]                     list.add(new Token(buffer)); [EOL]                     inLiteral = true; [EOL]                 } [EOL]                 break; [EOL]             case 'y': [EOL]                 value = y; [EOL]                 break; [EOL]             case 'M': [EOL]                 value = M; [EOL]                 break; [EOL]             case 'd': [EOL]                 value = d; [EOL]                 break; [EOL]             case 'H': [EOL]                 value = H; [EOL]                 break; [EOL]             case 'm': [EOL]                 value = m; [EOL]                 break; [EOL]             case 's': [EOL]                 value = s; [EOL]                 break; [EOL]             case 'S': [EOL]                 value = S; [EOL]                 break; [EOL]             default: [EOL]                 if (buffer == null) { [EOL]                     buffer = new StringBuilder(); [EOL]                     list.add(new Token(buffer)); [EOL]                 } [EOL]                 buffer.append(ch); [EOL]         } [EOL]         if (value != null) { [EOL]             if (previous != null && previous.getValue() == value) { [EOL]                 previous.increment(); [EOL]             } else { [EOL]                 final Token token = new Token(value); [EOL]                 list.add(token); [EOL]                 previous = token; [EOL]             } [EOL]             buffer = null; [EOL]         } [EOL]     } [EOL]     return list.toArray(new Token[list.size()]); [EOL] } 
 [LINE] if (value != null) { [LINE] static Token[] lexx(final String format) { [EOL]     final char[] array = format.toCharArray(); [EOL]     final ArrayList<Token> list = new ArrayList<Token>(array.length); [EOL]     boolean inLiteral = false; [EOL]     StringBuilder buffer = null; [EOL]     Token previous = null; [EOL]     final int sz = array.length; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         final char ch = array[i]; [EOL]         if (inLiteral && ch != '\'') { [EOL]             buffer.append(ch); [EOL]             continue; [EOL]         } [EOL]         Object value = null; [EOL]         switch(ch) { [EOL]             case '\'': [EOL]                 if (inLiteral) { [EOL]                     buffer = null; [EOL]                     inLiteral = false; [EOL]                 } else { [EOL]                     buffer = new StringBuilder(); [EOL]                     list.add(new Token(buffer)); [EOL]                     inLiteral = true; [EOL]                 } [EOL]                 break; [EOL]             case 'y': [EOL]                 value = y; [EOL]                 break; [EOL]             case 'M': [EOL]                 value = M; [EOL]                 break; [EOL]             case 'd': [EOL]                 value = d; [EOL]                 break; [EOL]             case 'H': [EOL]                 value = H; [EOL]                 break; [EOL]             case 'm': [EOL]                 value = m; [EOL]                 break; [EOL]             case 's': [EOL]                 value = s; [EOL]                 break; [EOL]             case 'S': [EOL]                 value = S; [EOL]                 break; [EOL]             default: [EOL]                 if (buffer == null) { [EOL]                     buffer = new StringBuilder(); [EOL]                     list.add(new Token(buffer)); [EOL]                 } [EOL]                 buffer.append(ch); [EOL]         } [EOL]         if (value != null) { [EOL]             if (previous != null && previous.getValue() == value) { [EOL]                 previous.increment(); [EOL]             } else { [EOL]                 final Token token = new Token(value); [EOL]                 list.add(token); [EOL]                 previous = token; [EOL]             } [EOL]             buffer = null; [EOL]         } [EOL]     } [EOL]     return list.toArray(new Token[list.size()]); [EOL] } 
 [LINE] final Token token = new Token(value); [LINE] static Token[] lexx(final String format) { [EOL]     final char[] array = format.toCharArray(); [EOL]     final ArrayList<Token> list = new ArrayList<Token>(array.length); [EOL]     boolean inLiteral = false; [EOL]     StringBuilder buffer = null; [EOL]     Token previous = null; [EOL]     final int sz = array.length; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         final char ch = array[i]; [EOL]         if (inLiteral && ch != '\'') { [EOL]             buffer.append(ch); [EOL]             continue; [EOL]         } [EOL]         Object value = null; [EOL]         switch(ch) { [EOL]             case '\'': [EOL]                 if (inLiteral) { [EOL]                     buffer = null; [EOL]                     inLiteral = false; [EOL]                 } else { [EOL]                     buffer = new StringBuilder(); [EOL]                     list.add(new Token(buffer)); [EOL]                     inLiteral = true; [EOL]                 } [EOL]                 break; [EOL]             case 'y': [EOL]                 value = y; [EOL]                 break; [EOL]             case 'M': [EOL]                 value = M; [EOL]                 break; [EOL]             case 'd': [EOL]                 value = d; [EOL]                 break; [EOL]             case 'H': [EOL]                 value = H; [EOL]                 break; [EOL]             case 'm': [EOL]                 value = m; [EOL]                 break; [EOL]             case 's': [EOL]                 value = s; [EOL]                 break; [EOL]             case 'S': [EOL]                 value = S; [EOL]                 break; [EOL]             default: [EOL]                 if (buffer == null) { [EOL]                     buffer = new StringBuilder(); [EOL]                     list.add(new Token(buffer)); [EOL]                 } [EOL]                 buffer.append(ch); [EOL]         } [EOL]         if (value != null) { [EOL]             if (previous != null && previous.getValue() == value) { [EOL]                 previous.increment(); [EOL]             } else { [EOL]                 final Token token = new Token(value); [EOL]                 list.add(token); [EOL]                 previous = token; [EOL]             } [EOL]             buffer = null; [EOL]         } [EOL]     } [EOL]     return list.toArray(new Token[list.size()]); [EOL] } 
 [LINE] for (int i = 0; i < sz; i++) { [LINE] static boolean containsTokenWithValue(final Token[] tokens, final Object value) { [EOL]     final int sz = tokens.length; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (tokens[i].getValue() == value) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } 
 [LINE] if (obj2 instanceof Token) { [LINE] @Override [EOL] public boolean equals(final Object obj2) { [EOL]     if (obj2 instanceof Token) { [EOL]         final Token tok2 = (Token) obj2; [EOL]         if (this.value.getClass() != tok2.value.getClass()) { [EOL]             return false; [EOL]         } [EOL]         if (this.count != tok2.count) { [EOL]             return false; [EOL]         } [EOL]         if (this.value instanceof StringBuilder) { [EOL]             return this.value.toString().equals(tok2.value.toString()); [EOL]         } else if (this.value instanceof Number) { [EOL]             return this.value.equals(tok2.value); [EOL]         } else { [EOL]             return this.value == tok2.value; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } 
 [LINE] return false; [LINE] @Override [EOL] public boolean equals(final Object obj2) { [EOL]     if (obj2 instanceof Token) { [EOL]         final Token tok2 = (Token) obj2; [EOL]         if (this.value.getClass() != tok2.value.getClass()) { [EOL]             return false; [EOL]         } [EOL]         if (this.count != tok2.count) { [EOL]             return false; [EOL]         } [EOL]         if (this.value instanceof StringBuilder) { [EOL]             return this.value.toString().equals(tok2.value.toString()); [EOL]         } else if (this.value instanceof Number) { [EOL]             return this.value.equals(tok2.value); [EOL]         } else { [EOL]             return this.value == tok2.value; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } 
lang3/CharSetUtils.java
 [LINE] final char[] chrs = str.toCharArray(); [LINE] public static String squeeze(final String str, final String... set) { [EOL]     if (StringUtils.isEmpty(str) || deepEmpty(set)) { [EOL]         return str; [EOL]     } [EOL]     final CharSet chars = CharSet.getInstance(set); [EOL]     final StringBuilder buffer = new StringBuilder(str.length()); [EOL]     final char[] chrs = str.toCharArray(); [EOL]     final int sz = chrs.length; [EOL]     char lastChar = ' '; [EOL]     char ch = ' '; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         ch = chrs[i]; [EOL]         if (ch == lastChar && i != 0 && chars.contains(ch)) { [EOL]             continue; [EOL]         } [EOL]         buffer.append(ch); [EOL]         lastChar = ch; [EOL]     } [EOL]     return buffer.toString(); [EOL] } 
 [LINE] if (ch == lastChar && i != 0 && chars.contains(ch)) { [LINE] public static String squeeze(final String str, final String... set) { [EOL]     if (StringUtils.isEmpty(str) || deepEmpty(set)) { [EOL]         return str; [EOL]     } [EOL]     final CharSet chars = CharSet.getInstance(set); [EOL]     final StringBuilder buffer = new StringBuilder(str.length()); [EOL]     final char[] chrs = str.toCharArray(); [EOL]     final int sz = chrs.length; [EOL]     char lastChar = ' '; [EOL]     char ch = ' '; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         ch = chrs[i]; [EOL]         if (ch == lastChar && i != 0 && chars.contains(ch)) { [EOL]             continue; [EOL]         } [EOL]         buffer.append(ch); [EOL]         lastChar = ch; [EOL]     } [EOL]     return buffer.toString(); [EOL] } 
 [LINE] for (final char c : str.toCharArray()) { [LINE] public static boolean containsAny(final String str, final String... set) { [EOL]     if (StringUtils.isEmpty(str) || deepEmpty(set)) { [EOL]         return false; [EOL]     } [EOL]     final CharSet chars = CharSet.getInstance(set); [EOL]     for (final char c : str.toCharArray()) { [EOL]         if (chars.contains(c)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } 
 [LINE] for (final char c : str.toCharArray()) { [LINE] public static int count(final String str, final String... set) { [EOL]     if (StringUtils.isEmpty(str) || deepEmpty(set)) { [EOL]         return 0; [EOL]     } [EOL]     final CharSet chars = CharSet.getInstance(set); [EOL]     int count = 0; [EOL]     for (final char c : str.toCharArray()) { [EOL]         if (chars.contains(c)) { [EOL]             count++; [EOL]         } [EOL]     } [EOL]     return count; [EOL] } 
 [LINE] return str; [LINE] public static String delete(final String str, final String... set) { [EOL]     if (StringUtils.isEmpty(str) || deepEmpty(set)) { [EOL]         return str; [EOL]     } [EOL]     return modify(str, set, false); [EOL] } 
 [LINE] if (strings != null) { [LINE] private static boolean deepEmpty(final String[] strings) { [EOL]     if (strings != null) { [EOL]         for (final String s : strings) { [EOL]             if (StringUtils.isNotEmpty(s)) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] return true; [LINE] private static boolean deepEmpty(final String[] strings) { [EOL]     if (strings != null) { [EOL]         for (final String s : strings) { [EOL]             if (StringUtils.isNotEmpty(s)) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
lang3/concurrent/BackgroundInitializer.java
 [LINE] return false; [LINE] public synchronized boolean start() { [EOL]     if (!isStarted()) { [EOL]         ExecutorService tempExec; [EOL]         executor = getExternalExecutor(); [EOL]         if (executor == null) { [EOL]             executor = tempExec = createExecutor(); [EOL]         } else { [EOL]             tempExec = null; [EOL]         } [EOL]         future = executor.submit(createTask(tempExec)); [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] } 
 [LINE] return getFuture().get(); [LINE] @Override [EOL] public T get() throws ConcurrentException { [EOL]     try { [EOL]         return getFuture().get(); [EOL]     } catch (final ExecutionException execex) { [EOL]         ConcurrentUtils.handleCause(execex); [EOL]         return null; [EOL]     } catch (final InterruptedException iex) { [EOL]         Thread.currentThread().interrupt(); [EOL]         throw new ConcurrentException(iex); [EOL]     } [EOL] } 
 [LINE] try { [LINE] @Override [EOL] public T call() throws Exception { [EOL]     try { [EOL]         return initialize(); [EOL]     } finally { [EOL]         if (execFinally != null) { [EOL]             execFinally.shutdown(); [EOL]         } [EOL]     } [EOL] } 
 [LINE] return initialize(); [LINE] @Override [EOL] public T call() throws Exception { [EOL]     try { [EOL]         return initialize(); [EOL]     } finally { [EOL]         if (execFinally != null) { [EOL]             execFinally.shutdown(); [EOL]         } [EOL]     } [EOL] } 
lang3/CharSet.java
 [LINE] return null; [LINE] public static CharSet getInstance(final String... setStrs) { [EOL]     if (setStrs == null) { [EOL]         return null; [EOL]     } [EOL]     if (setStrs.length == 1) { [EOL]         final CharSet common = COMMON.get(setStrs[0]); [EOL]         if (common != null) { [EOL]             return common; [EOL]         } [EOL]     } [EOL]     return new CharSet(setStrs); [EOL] } 
 [LINE] final CharSet common = COMMON.get(setStrs[0]); [LINE] public static CharSet getInstance(final String... setStrs) { [EOL]     if (setStrs == null) { [EOL]         return null; [EOL]     } [EOL]     if (setStrs.length == 1) { [EOL]         final CharSet common = COMMON.get(setStrs[0]); [EOL]         if (common != null) { [EOL]             return common; [EOL]         } [EOL]     } [EOL]     return new CharSet(setStrs); [EOL] } 
 [LINE] if (common != null) { [LINE] public static CharSet getInstance(final String... setStrs) { [EOL]     if (setStrs == null) { [EOL]         return null; [EOL]     } [EOL]     if (setStrs.length == 1) { [EOL]         final CharSet common = COMMON.get(setStrs[0]); [EOL]         if (common != null) { [EOL]             return common; [EOL]         } [EOL]     } [EOL]     return new CharSet(setStrs); [EOL] } 
 [LINE] if (str == null) { [LINE] protected void add(final String str) { [EOL]     if (str == null) { [EOL]         return; [EOL]     } [EOL]     final int len = str.length(); [EOL]     int pos = 0; [EOL]     while (pos < len) { [EOL]         final int remainder = len - pos; [EOL]         if (remainder >= 4 && str.charAt(pos) == '^' && str.charAt(pos + 2) == '-') { [EOL]             set.add(CharRange.isNotIn(str.charAt(pos + 1), str.charAt(pos + 3))); [EOL]             pos += 4; [EOL]         } else if (remainder >= 3 && str.charAt(pos + 1) == '-') { [EOL]             set.add(CharRange.isIn(str.charAt(pos), str.charAt(pos + 2))); [EOL]             pos += 3; [EOL]         } else if (remainder >= 2 && str.charAt(pos) == '^') { [EOL]             set.add(CharRange.isNot(str.charAt(pos + 1))); [EOL]             pos += 2; [EOL]         } else { [EOL]             set.add(CharRange.is(str.charAt(pos))); [EOL]             pos += 1; [EOL]         } [EOL]     } [EOL] } 
 [LINE] while (pos < len) { [LINE] protected void add(final String str) { [EOL]     if (str == null) { [EOL]         return; [EOL]     } [EOL]     final int len = str.length(); [EOL]     int pos = 0; [EOL]     while (pos < len) { [EOL]         final int remainder = len - pos; [EOL]         if (remainder >= 4 && str.charAt(pos) == '^' && str.charAt(pos + 2) == '-') { [EOL]             set.add(CharRange.isNotIn(str.charAt(pos + 1), str.charAt(pos + 3))); [EOL]             pos += 4; [EOL]         } else if (remainder >= 3 && str.charAt(pos + 1) == '-') { [EOL]             set.add(CharRange.isIn(str.charAt(pos), str.charAt(pos + 2))); [EOL]             pos += 3; [EOL]         } else if (remainder >= 2 && str.charAt(pos) == '^') { [EOL]             set.add(CharRange.isNot(str.charAt(pos + 1))); [EOL]             pos += 2; [EOL]         } else { [EOL]             set.add(CharRange.is(str.charAt(pos))); [EOL]             pos += 1; [EOL]         } [EOL]     } [EOL] } 
 [LINE] set.add(CharRange.isNotIn(str.charAt(pos + 1), str.charAt(pos + 3))); [LINE] protected void add(final String str) { [EOL]     if (str == null) { [EOL]         return; [EOL]     } [EOL]     final int len = str.length(); [EOL]     int pos = 0; [EOL]     while (pos < len) { [EOL]         final int remainder = len - pos; [EOL]         if (remainder >= 4 && str.charAt(pos) == '^' && str.charAt(pos + 2) == '-') { [EOL]             set.add(CharRange.isNotIn(str.charAt(pos + 1), str.charAt(pos + 3))); [EOL]             pos += 4; [EOL]         } else if (remainder >= 3 && str.charAt(pos + 1) == '-') { [EOL]             set.add(CharRange.isIn(str.charAt(pos), str.charAt(pos + 2))); [EOL]             pos += 3; [EOL]         } else if (remainder >= 2 && str.charAt(pos) == '^') { [EOL]             set.add(CharRange.isNot(str.charAt(pos + 1))); [EOL]             pos += 2; [EOL]         } else { [EOL]             set.add(CharRange.is(str.charAt(pos))); [EOL]             pos += 1; [EOL]         } [EOL]     } [EOL] } 
 [LINE] set.add(CharRange.is(str.charAt(pos))); [LINE] protected void add(final String str) { [EOL]     if (str == null) { [EOL]         return; [EOL]     } [EOL]     final int len = str.length(); [EOL]     int pos = 0; [EOL]     while (pos < len) { [EOL]         final int remainder = len - pos; [EOL]         if (remainder >= 4 && str.charAt(pos) == '^' && str.charAt(pos + 2) == '-') { [EOL]             set.add(CharRange.isNotIn(str.charAt(pos + 1), str.charAt(pos + 3))); [EOL]             pos += 4; [EOL]         } else if (remainder >= 3 && str.charAt(pos + 1) == '-') { [EOL]             set.add(CharRange.isIn(str.charAt(pos), str.charAt(pos + 2))); [EOL]             pos += 3; [EOL]         } else if (remainder >= 2 && str.charAt(pos) == '^') { [EOL]             set.add(CharRange.isNot(str.charAt(pos + 1))); [EOL]             pos += 2; [EOL]         } else { [EOL]             set.add(CharRange.is(str.charAt(pos))); [EOL]             pos += 1; [EOL]         } [EOL]     } [EOL] } 
 [LINE] for (final CharRange range : set) { [LINE] public boolean contains(final char ch) { [EOL]     for (final CharRange range : set) { [EOL]         if (range.contains(ch)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } 
 [LINE] return false; [LINE] public boolean contains(final char ch) { [EOL]     for (final CharRange range : set) { [EOL]         if (range.contains(ch)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } 
 [LINE] return false; [LINE] @Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof CharSet == false) { [EOL]         return false; [EOL]     } [EOL]     final CharSet other = (CharSet) obj; [EOL]     return set.equals(other.set); [EOL] } 
 [LINE] return set.equals(other.set); [LINE] @Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof CharSet == false) { [EOL]         return false; [EOL]     } [EOL]     final CharSet other = (CharSet) obj; [EOL]     return set.equals(other.set); [EOL] } 
 [LINE] @Override [LINE] @Override [EOL] public int hashCode() { [EOL]     return 89 + set.hashCode(); [EOL] } 
lang3/tuple/MutablePair.java
 [LINE] return new MutablePair<L, R>(left, right); [LINE] public static <L, R> MutablePair<L, R> of(final L left, final R right) { [EOL]     return new MutablePair<L, R>(left, right); [EOL] } 
 [LINE] this.right = right; [LINE] public void setRight(final R right) { [EOL]     this.right = right; [EOL] } 
lang3/CharEncoding.java
lang3/reflect/FieldUtils.java
 [LINE] if (cls == null) { [LINE] public static Field getField(final Class<?> cls, final String fieldName, final boolean forceAccess) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     if (fieldName == null) { [EOL]         throw new IllegalArgumentException("The field name must not be null"); [EOL]     } [EOL]     for (Class<?> acls = cls; acls != null; acls = acls.getSuperclass()) { [EOL]         try { [EOL]             final Field field = acls.getDeclaredField(fieldName); [EOL]             if (!Modifier.isPublic(field.getModifiers())) { [EOL]                 if (forceAccess) { [EOL]                     field.setAccessible(true); [EOL]                 } else { [EOL]                     continue; [EOL]                 } [EOL]             } [EOL]             return field; [EOL]         } catch (final NoSuchFieldException ex) { [EOL]         } [EOL]     } [EOL]     Field match = null; [EOL]     for (final Class<?> class1 : ClassUtils.getAllInterfaces(cls)) { [EOL]         try { [EOL]             final Field test = ((Class<?>) class1).getField(fieldName); [EOL]             if (match != null) { [EOL]                 throw new IllegalArgumentException("Reference to field " + fieldName + " is ambiguous relative to " + cls + "; a matching field exists on two or more implemented interfaces."); [EOL]             } [EOL]             match = test; [EOL]         } catch (final NoSuchFieldException ex) { [EOL]         } [EOL]     } [EOL]     return match; [EOL] } 
 [LINE] try { [LINE] public static Field getField(final Class<?> cls, final String fieldName, final boolean forceAccess) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     if (fieldName == null) { [EOL]         throw new IllegalArgumentException("The field name must not be null"); [EOL]     } [EOL]     for (Class<?> acls = cls; acls != null; acls = acls.getSuperclass()) { [EOL]         try { [EOL]             final Field field = acls.getDeclaredField(fieldName); [EOL]             if (!Modifier.isPublic(field.getModifiers())) { [EOL]                 if (forceAccess) { [EOL]                     field.setAccessible(true); [EOL]                 } else { [EOL]                     continue; [EOL]                 } [EOL]             } [EOL]             return field; [EOL]         } catch (final NoSuchFieldException ex) { [EOL]         } [EOL]     } [EOL]     Field match = null; [EOL]     for (final Class<?> class1 : ClassUtils.getAllInterfaces(cls)) { [EOL]         try { [EOL]             final Field test = ((Class<?>) class1).getField(fieldName); [EOL]             if (match != null) { [EOL]                 throw new IllegalArgumentException("Reference to field " + fieldName + " is ambiguous relative to " + cls + "; a matching field exists on two or more implemented interfaces."); [EOL]             } [EOL]             match = test; [EOL]         } catch (final NoSuchFieldException ex) { [EOL]         } [EOL]     } [EOL]     return match; [EOL] } 
 [LINE] final Field field = acls.getDeclaredField(fieldName); [LINE] public static Field getField(final Class<?> cls, final String fieldName, final boolean forceAccess) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     if (fieldName == null) { [EOL]         throw new IllegalArgumentException("The field name must not be null"); [EOL]     } [EOL]     for (Class<?> acls = cls; acls != null; acls = acls.getSuperclass()) { [EOL]         try { [EOL]             final Field field = acls.getDeclaredField(fieldName); [EOL]             if (!Modifier.isPublic(field.getModifiers())) { [EOL]                 if (forceAccess) { [EOL]                     field.setAccessible(true); [EOL]                 } else { [EOL]                     continue; [EOL]                 } [EOL]             } [EOL]             return field; [EOL]         } catch (final NoSuchFieldException ex) { [EOL]         } [EOL]     } [EOL]     Field match = null; [EOL]     for (final Class<?> class1 : ClassUtils.getAllInterfaces(cls)) { [EOL]         try { [EOL]             final Field test = ((Class<?>) class1).getField(fieldName); [EOL]             if (match != null) { [EOL]                 throw new IllegalArgumentException("Reference to field " + fieldName + " is ambiguous relative to " + cls + "; a matching field exists on two or more implemented interfaces."); [EOL]             } [EOL]             match = test; [EOL]         } catch (final NoSuchFieldException ex) { [EOL]         } [EOL]     } [EOL]     return match; [EOL] } 
 [LINE] field.setAccessible(true); [LINE] public static Field getField(final Class<?> cls, final String fieldName, final boolean forceAccess) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     if (fieldName == null) { [EOL]         throw new IllegalArgumentException("The field name must not be null"); [EOL]     } [EOL]     for (Class<?> acls = cls; acls != null; acls = acls.getSuperclass()) { [EOL]         try { [EOL]             final Field field = acls.getDeclaredField(fieldName); [EOL]             if (!Modifier.isPublic(field.getModifiers())) { [EOL]                 if (forceAccess) { [EOL]                     field.setAccessible(true); [EOL]                 } else { [EOL]                     continue; [EOL]                 } [EOL]             } [EOL]             return field; [EOL]         } catch (final NoSuchFieldException ex) { [EOL]         } [EOL]     } [EOL]     Field match = null; [EOL]     for (final Class<?> class1 : ClassUtils.getAllInterfaces(cls)) { [EOL]         try { [EOL]             final Field test = ((Class<?>) class1).getField(fieldName); [EOL]             if (match != null) { [EOL]                 throw new IllegalArgumentException("Reference to field " + fieldName + " is ambiguous relative to " + cls + "; a matching field exists on two or more implemented interfaces."); [EOL]             } [EOL]             match = test; [EOL]         } catch (final NoSuchFieldException ex) { [EOL]         } [EOL]     } [EOL]     return match; [EOL] } 
 [LINE] continue; [LINE] public static Field getField(final Class<?> cls, final String fieldName, final boolean forceAccess) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     if (fieldName == null) { [EOL]         throw new IllegalArgumentException("The field name must not be null"); [EOL]     } [EOL]     for (Class<?> acls = cls; acls != null; acls = acls.getSuperclass()) { [EOL]         try { [EOL]             final Field field = acls.getDeclaredField(fieldName); [EOL]             if (!Modifier.isPublic(field.getModifiers())) { [EOL]                 if (forceAccess) { [EOL]                     field.setAccessible(true); [EOL]                 } else { [EOL]                     continue; [EOL]                 } [EOL]             } [EOL]             return field; [EOL]         } catch (final NoSuchFieldException ex) { [EOL]         } [EOL]     } [EOL]     Field match = null; [EOL]     for (final Class<?> class1 : ClassUtils.getAllInterfaces(cls)) { [EOL]         try { [EOL]             final Field test = ((Class<?>) class1).getField(fieldName); [EOL]             if (match != null) { [EOL]                 throw new IllegalArgumentException("Reference to field " + fieldName + " is ambiguous relative to " + cls + "; a matching field exists on two or more implemented interfaces."); [EOL]             } [EOL]             match = test; [EOL]         } catch (final NoSuchFieldException ex) { [EOL]         } [EOL]     } [EOL]     return match; [EOL] } 
 [LINE] return field; [LINE] public static Field getField(final Class<?> cls, final String fieldName, final boolean forceAccess) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     if (fieldName == null) { [EOL]         throw new IllegalArgumentException("The field name must not be null"); [EOL]     } [EOL]     for (Class<?> acls = cls; acls != null; acls = acls.getSuperclass()) { [EOL]         try { [EOL]             final Field field = acls.getDeclaredField(fieldName); [EOL]             if (!Modifier.isPublic(field.getModifiers())) { [EOL]                 if (forceAccess) { [EOL]                     field.setAccessible(true); [EOL]                 } else { [EOL]                     continue; [EOL]                 } [EOL]             } [EOL]             return field; [EOL]         } catch (final NoSuchFieldException ex) { [EOL]         } [EOL]     } [EOL]     Field match = null; [EOL]     for (final Class<?> class1 : ClassUtils.getAllInterfaces(cls)) { [EOL]         try { [EOL]             final Field test = ((Class<?>) class1).getField(fieldName); [EOL]             if (match != null) { [EOL]                 throw new IllegalArgumentException("Reference to field " + fieldName + " is ambiguous relative to " + cls + "; a matching field exists on two or more implemented interfaces."); [EOL]             } [EOL]             match = test; [EOL]         } catch (final NoSuchFieldException ex) { [EOL]         } [EOL]     } [EOL]     return match; [EOL] } 
 [LINE] if (match != null) { [LINE] public static Field getField(final Class<?> cls, final String fieldName, final boolean forceAccess) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     if (fieldName == null) { [EOL]         throw new IllegalArgumentException("The field name must not be null"); [EOL]     } [EOL]     for (Class<?> acls = cls; acls != null; acls = acls.getSuperclass()) { [EOL]         try { [EOL]             final Field field = acls.getDeclaredField(fieldName); [EOL]             if (!Modifier.isPublic(field.getModifiers())) { [EOL]                 if (forceAccess) { [EOL]                     field.setAccessible(true); [EOL]                 } else { [EOL]                     continue; [EOL]                 } [EOL]             } [EOL]             return field; [EOL]         } catch (final NoSuchFieldException ex) { [EOL]         } [EOL]     } [EOL]     Field match = null; [EOL]     for (final Class<?> class1 : ClassUtils.getAllInterfaces(cls)) { [EOL]         try { [EOL]             final Field test = ((Class<?>) class1).getField(fieldName); [EOL]             if (match != null) { [EOL]                 throw new IllegalArgumentException("Reference to field " + fieldName + " is ambiguous relative to " + cls + "; a matching field exists on two or more implemented interfaces."); [EOL]             } [EOL]             match = test; [EOL]         } catch (final NoSuchFieldException ex) { [EOL]         } [EOL]     } [EOL]     return match; [EOL] } 
 [LINE] throw new IllegalArgumentException("Reference to field " + fieldName + " is ambiguous relative to " + cls + [LINE] public static Field getField(final Class<?> cls, final String fieldName, final boolean forceAccess) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     if (fieldName == null) { [EOL]         throw new IllegalArgumentException("The field name must not be null"); [EOL]     } [EOL]     for (Class<?> acls = cls; acls != null; acls = acls.getSuperclass()) { [EOL]         try { [EOL]             final Field field = acls.getDeclaredField(fieldName); [EOL]             if (!Modifier.isPublic(field.getModifiers())) { [EOL]                 if (forceAccess) { [EOL]                     field.setAccessible(true); [EOL]                 } else { [EOL]                     continue; [EOL]                 } [EOL]             } [EOL]             return field; [EOL]         } catch (final NoSuchFieldException ex) { [EOL]         } [EOL]     } [EOL]     Field match = null; [EOL]     for (final Class<?> class1 : ClassUtils.getAllInterfaces(cls)) { [EOL]         try { [EOL]             final Field test = ((Class<?>) class1).getField(fieldName); [EOL]             if (match != null) { [EOL]                 throw new IllegalArgumentException("Reference to field " + fieldName + " is ambiguous relative to " + cls + "; a matching field exists on two or more implemented interfaces."); [EOL]             } [EOL]             match = test; [EOL]         } catch (final NoSuchFieldException ex) { [EOL]         } [EOL]     } [EOL]     return match; [EOL] } 
 [LINE] match = test; [LINE] public static Field getField(final Class<?> cls, final String fieldName, final boolean forceAccess) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     if (fieldName == null) { [EOL]         throw new IllegalArgumentException("The field name must not be null"); [EOL]     } [EOL]     for (Class<?> acls = cls; acls != null; acls = acls.getSuperclass()) { [EOL]         try { [EOL]             final Field field = acls.getDeclaredField(fieldName); [EOL]             if (!Modifier.isPublic(field.getModifiers())) { [EOL]                 if (forceAccess) { [EOL]                     field.setAccessible(true); [EOL]                 } else { [EOL]                     continue; [EOL]                 } [EOL]             } [EOL]             return field; [EOL]         } catch (final NoSuchFieldException ex) { [EOL]         } [EOL]     } [EOL]     Field match = null; [EOL]     for (final Class<?> class1 : ClassUtils.getAllInterfaces(cls)) { [EOL]         try { [EOL]             final Field test = ((Class<?>) class1).getField(fieldName); [EOL]             if (match != null) { [EOL]                 throw new IllegalArgumentException("Reference to field " + fieldName + " is ambiguous relative to " + cls + "; a matching field exists on two or more implemented interfaces."); [EOL]             } [EOL]             match = test; [EOL]         } catch (final NoSuchFieldException ex) { [EOL]         } [EOL]     } [EOL]     return match; [EOL] } 
 [LINE] return field; [LINE] public static Field getDeclaredField(final Class<?> cls, final String fieldName, final boolean forceAccess) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     if (fieldName == null) { [EOL]         throw new IllegalArgumentException("The field name must not be null"); [EOL]     } [EOL]     try { [EOL]         final Field field = cls.getDeclaredField(fieldName); [EOL]         if (!MemberUtils.isAccessible(field)) { [EOL]             if (forceAccess) { [EOL]                 field.setAccessible(true); [EOL]             } else { [EOL]                 return null; [EOL]             } [EOL]         } [EOL]         return field; [EOL]     } catch (final NoSuchFieldException e) { [EOL]     } [EOL]     return null; [EOL] } 
 [LINE] if (cls == null) { [LINE] public static List<Field> getAllFieldsList(Class<?> cls) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     List<Field> allFields = new ArrayList<Field>(); [EOL]     Class<?> currentClass = cls; [EOL]     while (currentClass != null) { [EOL]         final Field[] declaredFields = currentClass.getDeclaredFields(); [EOL]         for (Field field : declaredFields) { [EOL]             allFields.add(field); [EOL]         } [EOL]         currentClass = currentClass.getSuperclass(); [EOL]     } [EOL]     return allFields; [EOL] } 
 [LINE] currentClass = currentClass.getSuperclass(); [LINE] public static List<Field> getAllFieldsList(Class<?> cls) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     List<Field> allFields = new ArrayList<Field>(); [EOL]     Class<?> currentClass = cls; [EOL]     while (currentClass != null) { [EOL]         final Field[] declaredFields = currentClass.getDeclaredFields(); [EOL]         for (Field field : declaredFields) { [EOL]             allFields.add(field); [EOL]         } [EOL]         currentClass = currentClass.getSuperclass(); [EOL]     } [EOL]     return allFields; [EOL] } 
 [LINE] return allFields; [LINE] public static List<Field> getAllFieldsList(Class<?> cls) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     List<Field> allFields = new ArrayList<Field>(); [EOL]     Class<?> currentClass = cls; [EOL]     while (currentClass != null) { [EOL]         final Field[] declaredFields = currentClass.getDeclaredFields(); [EOL]         for (Field field : declaredFields) { [EOL]             allFields.add(field); [EOL]         } [EOL]         currentClass = currentClass.getSuperclass(); [EOL]     } [EOL]     return allFields; [EOL] } 
 [LINE] throw new IllegalArgumentException("The field must not be null"); [LINE] public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("The field must not be null"); [EOL]     } [EOL]     if (!Modifier.isStatic(field.getModifiers())) { [EOL]         throw new IllegalArgumentException("The field '" + field.getName() + "' is not static"); [EOL]     } [EOL]     return readField(field, (Object) null, forceAccess); [EOL] } 
 [LINE] throw new IllegalArgumentException("The field '" + field.getName() + "' is not static"); [LINE] public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("The field must not be null"); [EOL]     } [EOL]     if (!Modifier.isStatic(field.getModifiers())) { [EOL]         throw new IllegalArgumentException("The field '" + field.getName() + "' is not static"); [EOL]     } [EOL]     return readField(field, (Object) null, forceAccess); [EOL] } 
 [LINE] return readStaticField(field, false); [LINE] public static Object readStaticField(final Class<?> cls, final String fieldName, final boolean forceAccess) throws IllegalAccessException { [EOL]     final Field field = getField(cls, fieldName, forceAccess); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Cannot locate field " + fieldName + " on " + cls); [EOL]     } [EOL]     return readStaticField(field, false); [EOL] } 
 [LINE] if (target == null) { [LINE] public static Object readField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (target == null) { [EOL]         throw new IllegalArgumentException("target object must not be null"); [EOL]     } [EOL]     final Class<?> cls = target.getClass(); [EOL]     final Field field = getField(cls, fieldName, forceAccess); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Cannot locate field " + fieldName + " on " + cls); [EOL]     } [EOL]     return readField(field, target); [EOL] } 
 [LINE] throw new IllegalArgumentException("target object must not be null"); [LINE] public static Object readField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (target == null) { [EOL]         throw new IllegalArgumentException("target object must not be null"); [EOL]     } [EOL]     final Class<?> cls = target.getClass(); [EOL]     final Field field = getField(cls, fieldName, forceAccess); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Cannot locate field " + fieldName + " on " + cls); [EOL]     } [EOL]     return readField(field, target); [EOL] } 
 [LINE] if (!Modifier.isStatic(field.getModifiers())) { [LINE] public static void writeStaticField(final Field field, final Object value, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("The field must not be null"); [EOL]     } [EOL]     if (!Modifier.isStatic(field.getModifiers())) { [EOL]         throw new IllegalArgumentException("The field '" + field.getName() + "' is not static"); [EOL]     } [EOL]     writeField(field, (Object) null, value, forceAccess); [EOL] } 
 [LINE] writeField(field, (Object) null, value, forceAccess); [LINE] public static void writeStaticField(final Field field, final Object value, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("The field must not be null"); [EOL]     } [EOL]     if (!Modifier.isStatic(field.getModifiers())) { [EOL]         throw new IllegalArgumentException("The field '" + field.getName() + "' is not static"); [EOL]     } [EOL]     writeField(field, (Object) null, value, forceAccess); [EOL] } 
 [LINE] writeStaticField(cls, fieldName, value, false); [LINE] public static void writeStaticField(final Class<?> cls, final String fieldName, final Object value) throws IllegalAccessException { [EOL]     writeStaticField(cls, fieldName, value, false); [EOL] } 
 [LINE] final Field field = getField(cls, fieldName, forceAccess); [LINE] public static void writeStaticField(final Class<?> cls, final String fieldName, final Object value, final boolean forceAccess) throws IllegalAccessException { [EOL]     final Field field = getField(cls, fieldName, forceAccess); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Cannot locate field " + fieldName + " on " + cls); [EOL]     } [EOL]     writeStaticField(field, value); [EOL] } 
 [LINE] if (field == null) { [LINE] public static void writeStaticField(final Class<?> cls, final String fieldName, final Object value, final boolean forceAccess) throws IllegalAccessException { [EOL]     final Field field = getField(cls, fieldName, forceAccess); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Cannot locate field " + fieldName + " on " + cls); [EOL]     } [EOL]     writeStaticField(field, value); [EOL] } 
 [LINE] writeField(field, (Object) null, value); [LINE] public static void writeDeclaredStaticField(final Class<?> cls, final String fieldName, final Object value, final boolean forceAccess) throws IllegalAccessException { [EOL]     final Field field = getDeclaredField(cls, fieldName, forceAccess); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Cannot locate declared field " + cls.getName() + "." + fieldName); [EOL]     } [EOL]     writeField(field, (Object) null, value); [EOL] } 
 [LINE] if (forceAccess && !field.isAccessible()) { [LINE] public static void writeField(final Field field, final Object target, final Object value, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("The field must not be null"); [EOL]     } [EOL]     if (forceAccess && !field.isAccessible()) { [EOL]         field.setAccessible(true); [EOL]     } else { [EOL]         MemberUtils.setAccessibleWorkaround(field); [EOL]     } [EOL]     field.set(target, value); [EOL] } 
 [LINE] MemberUtils.setAccessibleWorkaround(field); [LINE] public static void writeField(final Field field, final Object target, final Object value, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("The field must not be null"); [EOL]     } [EOL]     if (forceAccess && !field.isAccessible()) { [EOL]         field.setAccessible(true); [EOL]     } else { [EOL]         MemberUtils.setAccessibleWorkaround(field); [EOL]     } [EOL]     field.set(target, value); [EOL] } 
 [LINE] writeField(target, fieldName, value, false); [LINE] public static void writeField(final Object target, final String fieldName, final Object value) throws IllegalAccessException { [EOL]     writeField(target, fieldName, value, false); [EOL] } 
 [LINE] if (target == null) { [LINE] public static void writeField(final Object target, final String fieldName, final Object value, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (target == null) { [EOL]         throw new IllegalArgumentException("target object must not be null"); [EOL]     } [EOL]     final Class<?> cls = target.getClass(); [EOL]     final Field field = getField(cls, fieldName, forceAccess); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Cannot locate declared field " + cls.getName() + "." + fieldName); [EOL]     } [EOL]     writeField(field, target, value); [EOL] } 
 [LINE] final Field field = getField(cls, fieldName, forceAccess); [LINE] public static void writeField(final Object target, final String fieldName, final Object value, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (target == null) { [EOL]         throw new IllegalArgumentException("target object must not be null"); [EOL]     } [EOL]     final Class<?> cls = target.getClass(); [EOL]     final Field field = getField(cls, fieldName, forceAccess); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Cannot locate declared field " + cls.getName() + "." + fieldName); [EOL]     } [EOL]     writeField(field, target, value); [EOL] } 
lang3/EnumUtils.java
 [LINE] try { [LINE] public static <E extends Enum<E>> boolean isValidEnum(final Class<E> enumClass, final String enumName) { [EOL]     if (enumName == null) { [EOL]         return false; [EOL]     } [EOL]     try { [EOL]         Enum.valueOf(enumClass, enumName); [EOL]         return true; [EOL]     } catch (final IllegalArgumentException ex) { [EOL]         return false; [EOL]     } [EOL] } 
 [LINE] return null; [LINE] public static <E extends Enum<E>> E getEnum(final Class<E> enumClass, final String enumName) { [EOL]     if (enumName == null) { [EOL]         return null; [EOL]     } [EOL]     try { [EOL]         return Enum.valueOf(enumClass, enumName); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]         return null; [EOL]     } [EOL] } 
 [LINE] try { [LINE] public static <E extends Enum<E>> E getEnum(final Class<E> enumClass, final String enumName) { [EOL]     if (enumName == null) { [EOL]         return null; [EOL]     } [EOL]     try { [EOL]         return Enum.valueOf(enumClass, enumName); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]         return null; [EOL]     } [EOL] } 
 [LINE] Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED); [LINE] public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values) { [EOL]     checkBitVectorable(enumClass); [EOL]     Validate.notNull(values); [EOL]     long total = 0; [EOL]     for (final E constant : values) { [EOL]         Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED); [EOL]         total |= 1 << constant.ordinal(); [EOL]     } [EOL]     return total; [EOL] } 
 [LINE] total |= 1 << constant.ordinal(); [LINE] public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values) { [EOL]     checkBitVectorable(enumClass); [EOL]     Validate.notNull(values); [EOL]     long total = 0; [EOL]     for (final E constant : values) { [EOL]         Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED); [EOL]         total |= 1 << constant.ordinal(); [EOL]     } [EOL]     return total; [EOL] } 
 [LINE] return total; [LINE] public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values) { [EOL]     checkBitVectorable(enumClass); [EOL]     Validate.notNull(values); [EOL]     long total = 0; [EOL]     for (final E constant : values) { [EOL]         Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED); [EOL]         total |= 1 << constant.ordinal(); [EOL]     } [EOL]     return total; [EOL] } 
 [LINE] for (final E constant : values) { [LINE] public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values) { [EOL]     asEnum(enumClass); [EOL]     Validate.notNull(values); [EOL]     final EnumSet<E> condensed = EnumSet.noneOf(enumClass); [EOL]     for (final E constant : values) { [EOL]         Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED); [EOL]         condensed.add(constant); [EOL]     } [EOL]     final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1]; [EOL]     for (final E value : condensed) { [EOL]         result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE); [EOL]     } [EOL]     ArrayUtils.reverse(result); [EOL]     return result; [EOL] } 
 [LINE] Collections.addAll(condensed, values); [LINE] public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final E... values) { [EOL]     asEnum(enumClass); [EOL]     Validate.noNullElements(values); [EOL]     final EnumSet<E> condensed = EnumSet.noneOf(enumClass); [EOL]     Collections.addAll(condensed, values); [EOL]     final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1]; [EOL]     for (final E value : condensed) { [EOL]         result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE); [EOL]     } [EOL]     ArrayUtils.reverse(result); [EOL]     return result; [EOL] } 
 [LINE] return result; [LINE] public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final E... values) { [EOL]     asEnum(enumClass); [EOL]     Validate.noNullElements(values); [EOL]     final EnumSet<E> condensed = EnumSet.noneOf(enumClass); [EOL]     Collections.addAll(condensed, values); [EOL]     final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1]; [EOL]     for (final E value : condensed) { [EOL]         result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE); [EOL]     } [EOL]     ArrayUtils.reverse(result); [EOL]     return result; [EOL] } 
 [LINE] checkBitVectorable(enumClass).getEnumConstants(); [LINE] public static <E extends Enum<E>> EnumSet<E> processBitVector(final Class<E> enumClass, final long value) { [EOL]     checkBitVectorable(enumClass).getEnumConstants(); [EOL]     return processBitVectors(enumClass, value); [EOL] } 
 [LINE] return results; [LINE] public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values) { [EOL]     final EnumSet<E> results = EnumSet.noneOf(asEnum(enumClass)); [EOL]     values = ArrayUtils.clone(Validate.notNull(values)); [EOL]     ArrayUtils.reverse(values); [EOL]     for (final E constant : enumClass.getEnumConstants()) { [EOL]         final int block = constant.ordinal() / Long.SIZE; [EOL]         if (block < values.length && (values[block] & 1 << (constant.ordinal() % Long.SIZE)) != 0) { [EOL]             results.add(constant); [EOL]         } [EOL]     } [EOL]     return results; [EOL] } 
 [LINE] Validate.notNull(enumClass, ENUM_CLASS_MUST_BE_DEFINED); [LINE] private static <E extends Enum<E>> Class<E> asEnum(final Class<E> enumClass) { [EOL]     Validate.notNull(enumClass, ENUM_CLASS_MUST_BE_DEFINED); [EOL]     Validate.isTrue(enumClass.isEnum(), S_DOES_NOT_SEEM_TO_BE_AN_ENUM_TYPE, enumClass); [EOL]     return enumClass; [EOL] } 
lang3/text/WordUtils.java
 [LINE] wrappedLine.append(newLineStr); [LINE] public static String wrap(final String str, int wrapLength, String newLineStr, final boolean wrapLongWords) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (newLineStr == null) { [EOL]         newLineStr = SystemUtils.LINE_SEPARATOR; [EOL]     } [EOL]     if (wrapLength < 1) { [EOL]         wrapLength = 1; [EOL]     } [EOL]     final int inputLineLength = str.length(); [EOL]     int offset = 0; [EOL]     final StringBuilder wrappedLine = new StringBuilder(inputLineLength + 32); [EOL]     while (inputLineLength - offset > wrapLength) { [EOL]         if (str.charAt(offset) == ' ') { [EOL]             offset++; [EOL]             continue; [EOL]         } [EOL]         int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset); [EOL]         if (spaceToWrapAt >= offset) { [EOL]             wrappedLine.append(str.substring(offset, spaceToWrapAt)); [EOL]             wrappedLine.append(newLineStr); [EOL]             offset = spaceToWrapAt + 1; [EOL]         } else { [EOL]             if (wrapLongWords) { [EOL]                 wrappedLine.append(str.substring(offset, wrapLength + offset)); [EOL]                 wrappedLine.append(newLineStr); [EOL]                 offset += wrapLength; [EOL]             } else { [EOL]                 spaceToWrapAt = str.indexOf(' ', wrapLength + offset); [EOL]                 if (spaceToWrapAt >= 0) { [EOL]                     wrappedLine.append(str.substring(offset, spaceToWrapAt)); [EOL]                     wrappedLine.append(newLineStr); [EOL]                     offset = spaceToWrapAt + 1; [EOL]                 } else { [EOL]                     wrappedLine.append(str.substring(offset)); [EOL]                     offset = inputLineLength; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     wrappedLine.append(str.substring(offset)); [EOL]     return wrappedLine.toString(); [EOL] } 
 [LINE] if (wrapLongWords) { [LINE] public static String wrap(final String str, int wrapLength, String newLineStr, final boolean wrapLongWords) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (newLineStr == null) { [EOL]         newLineStr = SystemUtils.LINE_SEPARATOR; [EOL]     } [EOL]     if (wrapLength < 1) { [EOL]         wrapLength = 1; [EOL]     } [EOL]     final int inputLineLength = str.length(); [EOL]     int offset = 0; [EOL]     final StringBuilder wrappedLine = new StringBuilder(inputLineLength + 32); [EOL]     while (inputLineLength - offset > wrapLength) { [EOL]         if (str.charAt(offset) == ' ') { [EOL]             offset++; [EOL]             continue; [EOL]         } [EOL]         int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset); [EOL]         if (spaceToWrapAt >= offset) { [EOL]             wrappedLine.append(str.substring(offset, spaceToWrapAt)); [EOL]             wrappedLine.append(newLineStr); [EOL]             offset = spaceToWrapAt + 1; [EOL]         } else { [EOL]             if (wrapLongWords) { [EOL]                 wrappedLine.append(str.substring(offset, wrapLength + offset)); [EOL]                 wrappedLine.append(newLineStr); [EOL]                 offset += wrapLength; [EOL]             } else { [EOL]                 spaceToWrapAt = str.indexOf(' ', wrapLength + offset); [EOL]                 if (spaceToWrapAt >= 0) { [EOL]                     wrappedLine.append(str.substring(offset, spaceToWrapAt)); [EOL]                     wrappedLine.append(newLineStr); [EOL]                     offset = spaceToWrapAt + 1; [EOL]                 } else { [EOL]                     wrappedLine.append(str.substring(offset)); [EOL]                     offset = inputLineLength; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     wrappedLine.append(str.substring(offset)); [EOL]     return wrappedLine.toString(); [EOL] } 
 [LINE] wrappedLine.append(newLineStr); [LINE] public static String wrap(final String str, int wrapLength, String newLineStr, final boolean wrapLongWords) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (newLineStr == null) { [EOL]         newLineStr = SystemUtils.LINE_SEPARATOR; [EOL]     } [EOL]     if (wrapLength < 1) { [EOL]         wrapLength = 1; [EOL]     } [EOL]     final int inputLineLength = str.length(); [EOL]     int offset = 0; [EOL]     final StringBuilder wrappedLine = new StringBuilder(inputLineLength + 32); [EOL]     while (inputLineLength - offset > wrapLength) { [EOL]         if (str.charAt(offset) == ' ') { [EOL]             offset++; [EOL]             continue; [EOL]         } [EOL]         int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset); [EOL]         if (spaceToWrapAt >= offset) { [EOL]             wrappedLine.append(str.substring(offset, spaceToWrapAt)); [EOL]             wrappedLine.append(newLineStr); [EOL]             offset = spaceToWrapAt + 1; [EOL]         } else { [EOL]             if (wrapLongWords) { [EOL]                 wrappedLine.append(str.substring(offset, wrapLength + offset)); [EOL]                 wrappedLine.append(newLineStr); [EOL]                 offset += wrapLength; [EOL]             } else { [EOL]                 spaceToWrapAt = str.indexOf(' ', wrapLength + offset); [EOL]                 if (spaceToWrapAt >= 0) { [EOL]                     wrappedLine.append(str.substring(offset, spaceToWrapAt)); [EOL]                     wrappedLine.append(newLineStr); [EOL]                     offset = spaceToWrapAt + 1; [EOL]                 } else { [EOL]                     wrappedLine.append(str.substring(offset)); [EOL]                     offset = inputLineLength; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     wrappedLine.append(str.substring(offset)); [EOL]     return wrappedLine.toString(); [EOL] } 
 [LINE] if (spaceToWrapAt >= 0) { [LINE] public static String wrap(final String str, int wrapLength, String newLineStr, final boolean wrapLongWords) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (newLineStr == null) { [EOL]         newLineStr = SystemUtils.LINE_SEPARATOR; [EOL]     } [EOL]     if (wrapLength < 1) { [EOL]         wrapLength = 1; [EOL]     } [EOL]     final int inputLineLength = str.length(); [EOL]     int offset = 0; [EOL]     final StringBuilder wrappedLine = new StringBuilder(inputLineLength + 32); [EOL]     while (inputLineLength - offset > wrapLength) { [EOL]         if (str.charAt(offset) == ' ') { [EOL]             offset++; [EOL]             continue; [EOL]         } [EOL]         int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset); [EOL]         if (spaceToWrapAt >= offset) { [EOL]             wrappedLine.append(str.substring(offset, spaceToWrapAt)); [EOL]             wrappedLine.append(newLineStr); [EOL]             offset = spaceToWrapAt + 1; [EOL]         } else { [EOL]             if (wrapLongWords) { [EOL]                 wrappedLine.append(str.substring(offset, wrapLength + offset)); [EOL]                 wrappedLine.append(newLineStr); [EOL]                 offset += wrapLength; [EOL]             } else { [EOL]                 spaceToWrapAt = str.indexOf(' ', wrapLength + offset); [EOL]                 if (spaceToWrapAt >= 0) { [EOL]                     wrappedLine.append(str.substring(offset, spaceToWrapAt)); [EOL]                     wrappedLine.append(newLineStr); [EOL]                     offset = spaceToWrapAt + 1; [EOL]                 } else { [EOL]                     wrappedLine.append(str.substring(offset)); [EOL]                     offset = inputLineLength; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     wrappedLine.append(str.substring(offset)); [EOL]     return wrappedLine.toString(); [EOL] } 
 [LINE] wrappedLine.append(newLineStr); [LINE] public static String wrap(final String str, int wrapLength, String newLineStr, final boolean wrapLongWords) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (newLineStr == null) { [EOL]         newLineStr = SystemUtils.LINE_SEPARATOR; [EOL]     } [EOL]     if (wrapLength < 1) { [EOL]         wrapLength = 1; [EOL]     } [EOL]     final int inputLineLength = str.length(); [EOL]     int offset = 0; [EOL]     final StringBuilder wrappedLine = new StringBuilder(inputLineLength + 32); [EOL]     while (inputLineLength - offset > wrapLength) { [EOL]         if (str.charAt(offset) == ' ') { [EOL]             offset++; [EOL]             continue; [EOL]         } [EOL]         int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset); [EOL]         if (spaceToWrapAt >= offset) { [EOL]             wrappedLine.append(str.substring(offset, spaceToWrapAt)); [EOL]             wrappedLine.append(newLineStr); [EOL]             offset = spaceToWrapAt + 1; [EOL]         } else { [EOL]             if (wrapLongWords) { [EOL]                 wrappedLine.append(str.substring(offset, wrapLength + offset)); [EOL]                 wrappedLine.append(newLineStr); [EOL]                 offset += wrapLength; [EOL]             } else { [EOL]                 spaceToWrapAt = str.indexOf(' ', wrapLength + offset); [EOL]                 if (spaceToWrapAt >= 0) { [EOL]                     wrappedLine.append(str.substring(offset, spaceToWrapAt)); [EOL]                     wrappedLine.append(newLineStr); [EOL]                     offset = spaceToWrapAt + 1; [EOL]                 } else { [EOL]                     wrappedLine.append(str.substring(offset)); [EOL]                     offset = inputLineLength; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     wrappedLine.append(str.substring(offset)); [EOL]     return wrappedLine.toString(); [EOL] } 
 [LINE] wrappedLine.append(str.substring(offset)); [LINE] public static String wrap(final String str, int wrapLength, String newLineStr, final boolean wrapLongWords) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (newLineStr == null) { [EOL]         newLineStr = SystemUtils.LINE_SEPARATOR; [EOL]     } [EOL]     if (wrapLength < 1) { [EOL]         wrapLength = 1; [EOL]     } [EOL]     final int inputLineLength = str.length(); [EOL]     int offset = 0; [EOL]     final StringBuilder wrappedLine = new StringBuilder(inputLineLength + 32); [EOL]     while (inputLineLength - offset > wrapLength) { [EOL]         if (str.charAt(offset) == ' ') { [EOL]             offset++; [EOL]             continue; [EOL]         } [EOL]         int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset); [EOL]         if (spaceToWrapAt >= offset) { [EOL]             wrappedLine.append(str.substring(offset, spaceToWrapAt)); [EOL]             wrappedLine.append(newLineStr); [EOL]             offset = spaceToWrapAt + 1; [EOL]         } else { [EOL]             if (wrapLongWords) { [EOL]                 wrappedLine.append(str.substring(offset, wrapLength + offset)); [EOL]                 wrappedLine.append(newLineStr); [EOL]                 offset += wrapLength; [EOL]             } else { [EOL]                 spaceToWrapAt = str.indexOf(' ', wrapLength + offset); [EOL]                 if (spaceToWrapAt >= 0) { [EOL]                     wrappedLine.append(str.substring(offset, spaceToWrapAt)); [EOL]                     wrappedLine.append(newLineStr); [EOL]                     offset = spaceToWrapAt + 1; [EOL]                 } else { [EOL]                     wrappedLine.append(str.substring(offset)); [EOL]                     offset = inputLineLength; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     wrappedLine.append(str.substring(offset)); [EOL]     return wrappedLine.toString(); [EOL] } 
 [LINE] boolean capitalizeNext = true; [LINE] public static String capitalize(final String str, final char... delimiters) { [EOL]     final int delimLen = delimiters == null ? -1 : delimiters.length; [EOL]     if (StringUtils.isEmpty(str) || delimLen == 0) { [EOL]         return str; [EOL]     } [EOL]     final char[] buffer = str.toCharArray(); [EOL]     boolean capitalizeNext = true; [EOL]     for (int i = 0; i < buffer.length; i++) { [EOL]         final char ch = buffer[i]; [EOL]         if (isDelimiter(ch, delimiters)) { [EOL]             capitalizeNext = true; [EOL]         } else if (capitalizeNext) { [EOL]             buffer[i] = Character.toTitleCase(ch); [EOL]             capitalizeNext = false; [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] } 
 [LINE] if (isDelimiter(ch, delimiters)) { [LINE] public static String capitalize(final String str, final char... delimiters) { [EOL]     final int delimLen = delimiters == null ? -1 : delimiters.length; [EOL]     if (StringUtils.isEmpty(str) || delimLen == 0) { [EOL]         return str; [EOL]     } [EOL]     final char[] buffer = str.toCharArray(); [EOL]     boolean capitalizeNext = true; [EOL]     for (int i = 0; i < buffer.length; i++) { [EOL]         final char ch = buffer[i]; [EOL]         if (isDelimiter(ch, delimiters)) { [EOL]             capitalizeNext = true; [EOL]         } else if (capitalizeNext) { [EOL]             buffer[i] = Character.toTitleCase(ch); [EOL]             capitalizeNext = false; [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] } 
 [LINE] capitalizeNext = true; [LINE] public static String capitalize(final String str, final char... delimiters) { [EOL]     final int delimLen = delimiters == null ? -1 : delimiters.length; [EOL]     if (StringUtils.isEmpty(str) || delimLen == 0) { [EOL]         return str; [EOL]     } [EOL]     final char[] buffer = str.toCharArray(); [EOL]     boolean capitalizeNext = true; [EOL]     for (int i = 0; i < buffer.length; i++) { [EOL]         final char ch = buffer[i]; [EOL]         if (isDelimiter(ch, delimiters)) { [EOL]             capitalizeNext = true; [EOL]         } else if (capitalizeNext) { [EOL]             buffer[i] = Character.toTitleCase(ch); [EOL]             capitalizeNext = false; [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] } 
 [LINE] final int delimLen = delimiters == null ? -1 : delimiters.length; [LINE] public static String uncapitalize(final String str, final char... delimiters) { [EOL]     final int delimLen = delimiters == null ? -1 : delimiters.length; [EOL]     if (StringUtils.isEmpty(str) || delimLen == 0) { [EOL]         return str; [EOL]     } [EOL]     final char[] buffer = str.toCharArray(); [EOL]     boolean uncapitalizeNext = true; [EOL]     for (int i = 0; i < buffer.length; i++) { [EOL]         final char ch = buffer[i]; [EOL]         if (isDelimiter(ch, delimiters)) { [EOL]             uncapitalizeNext = true; [EOL]         } else if (uncapitalizeNext) { [EOL]             buffer[i] = Character.toLowerCase(ch); [EOL]             uncapitalizeNext = false; [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] } 
 [LINE] return new String(buffer); [LINE] public static String uncapitalize(final String str, final char... delimiters) { [EOL]     final int delimLen = delimiters == null ? -1 : delimiters.length; [EOL]     if (StringUtils.isEmpty(str) || delimLen == 0) { [EOL]         return str; [EOL]     } [EOL]     final char[] buffer = str.toCharArray(); [EOL]     boolean uncapitalizeNext = true; [EOL]     for (int i = 0; i < buffer.length; i++) { [EOL]         final char ch = buffer[i]; [EOL]         if (isDelimiter(ch, delimiters)) { [EOL]             uncapitalizeNext = true; [EOL]         } else if (uncapitalizeNext) { [EOL]             buffer[i] = Character.toLowerCase(ch); [EOL]             uncapitalizeNext = false; [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] } 
 [LINE] return str; [LINE] public static String swapCase(final String str) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return str; [EOL]     } [EOL]     final char[] buffer = str.toCharArray(); [EOL]     boolean whitespace = true; [EOL]     for (int i = 0; i < buffer.length; i++) { [EOL]         final char ch = buffer[i]; [EOL]         if (Character.isUpperCase(ch)) { [EOL]             buffer[i] = Character.toLowerCase(ch); [EOL]             whitespace = false; [EOL]         } else if (Character.isTitleCase(ch)) { [EOL]             buffer[i] = Character.toLowerCase(ch); [EOL]             whitespace = false; [EOL]         } else if (Character.isLowerCase(ch)) { [EOL]             if (whitespace) { [EOL]                 buffer[i] = Character.toTitleCase(ch); [EOL]                 whitespace = false; [EOL]             } else { [EOL]                 buffer[i] = Character.toUpperCase(ch); [EOL]             } [EOL]         } else { [EOL]             whitespace = Character.isWhitespace(ch); [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] } 
 [LINE] final char[] buffer = str.toCharArray(); [LINE] public static String swapCase(final String str) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return str; [EOL]     } [EOL]     final char[] buffer = str.toCharArray(); [EOL]     boolean whitespace = true; [EOL]     for (int i = 0; i < buffer.length; i++) { [EOL]         final char ch = buffer[i]; [EOL]         if (Character.isUpperCase(ch)) { [EOL]             buffer[i] = Character.toLowerCase(ch); [EOL]             whitespace = false; [EOL]         } else if (Character.isTitleCase(ch)) { [EOL]             buffer[i] = Character.toLowerCase(ch); [EOL]             whitespace = false; [EOL]         } else if (Character.isLowerCase(ch)) { [EOL]             if (whitespace) { [EOL]                 buffer[i] = Character.toTitleCase(ch); [EOL]                 whitespace = false; [EOL]             } else { [EOL]                 buffer[i] = Character.toUpperCase(ch); [EOL]             } [EOL]         } else { [EOL]             whitespace = Character.isWhitespace(ch); [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] } 
 [LINE] final char ch = buffer[i]; [LINE] public static String swapCase(final String str) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return str; [EOL]     } [EOL]     final char[] buffer = str.toCharArray(); [EOL]     boolean whitespace = true; [EOL]     for (int i = 0; i < buffer.length; i++) { [EOL]         final char ch = buffer[i]; [EOL]         if (Character.isUpperCase(ch)) { [EOL]             buffer[i] = Character.toLowerCase(ch); [EOL]             whitespace = false; [EOL]         } else if (Character.isTitleCase(ch)) { [EOL]             buffer[i] = Character.toLowerCase(ch); [EOL]             whitespace = false; [EOL]         } else if (Character.isLowerCase(ch)) { [EOL]             if (whitespace) { [EOL]                 buffer[i] = Character.toTitleCase(ch); [EOL]                 whitespace = false; [EOL]             } else { [EOL]                 buffer[i] = Character.toUpperCase(ch); [EOL]             } [EOL]         } else { [EOL]             whitespace = Character.isWhitespace(ch); [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] } 
 [LINE] if (Character.isUpperCase(ch)) { [LINE] public static String swapCase(final String str) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return str; [EOL]     } [EOL]     final char[] buffer = str.toCharArray(); [EOL]     boolean whitespace = true; [EOL]     for (int i = 0; i < buffer.length; i++) { [EOL]         final char ch = buffer[i]; [EOL]         if (Character.isUpperCase(ch)) { [EOL]             buffer[i] = Character.toLowerCase(ch); [EOL]             whitespace = false; [EOL]         } else if (Character.isTitleCase(ch)) { [EOL]             buffer[i] = Character.toLowerCase(ch); [EOL]             whitespace = false; [EOL]         } else if (Character.isLowerCase(ch)) { [EOL]             if (whitespace) { [EOL]                 buffer[i] = Character.toTitleCase(ch); [EOL]                 whitespace = false; [EOL]             } else { [EOL]                 buffer[i] = Character.toUpperCase(ch); [EOL]             } [EOL]         } else { [EOL]             whitespace = Character.isWhitespace(ch); [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] } 
 [LINE] return new String(buffer); [LINE] public static String swapCase(final String str) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return str; [EOL]     } [EOL]     final char[] buffer = str.toCharArray(); [EOL]     boolean whitespace = true; [EOL]     for (int i = 0; i < buffer.length; i++) { [EOL]         final char ch = buffer[i]; [EOL]         if (Character.isUpperCase(ch)) { [EOL]             buffer[i] = Character.toLowerCase(ch); [EOL]             whitespace = false; [EOL]         } else if (Character.isTitleCase(ch)) { [EOL]             buffer[i] = Character.toLowerCase(ch); [EOL]             whitespace = false; [EOL]         } else if (Character.isLowerCase(ch)) { [EOL]             if (whitespace) { [EOL]                 buffer[i] = Character.toTitleCase(ch); [EOL]                 whitespace = false; [EOL]             } else { [EOL]                 buffer[i] = Character.toUpperCase(ch); [EOL]             } [EOL]         } else { [EOL]             whitespace = Character.isWhitespace(ch); [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] } 
 [LINE] return ""; [LINE] public static String initials(final String str, final char... delimiters) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return str; [EOL]     } [EOL]     if (delimiters != null && delimiters.length == 0) { [EOL]         return ""; [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     final char[] buf = new char[strLen / 2 + 1]; [EOL]     int count = 0; [EOL]     boolean lastWasGap = true; [EOL]     for (int i = 0; i < strLen; i++) { [EOL]         final char ch = str.charAt(i); [EOL]         if (isDelimiter(ch, delimiters)) { [EOL]             lastWasGap = true; [EOL]         } else if (lastWasGap) { [EOL]             buf[count++] = ch; [EOL]             lastWasGap = false; [EOL]         } else { [EOL]             continue; [EOL]         } [EOL]     } [EOL]     return new String(buf, 0, count); [EOL] } 
 [LINE] boolean lastWasGap = true; [LINE] public static String initials(final String str, final char... delimiters) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return str; [EOL]     } [EOL]     if (delimiters != null && delimiters.length == 0) { [EOL]         return ""; [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     final char[] buf = new char[strLen / 2 + 1]; [EOL]     int count = 0; [EOL]     boolean lastWasGap = true; [EOL]     for (int i = 0; i < strLen; i++) { [EOL]         final char ch = str.charAt(i); [EOL]         if (isDelimiter(ch, delimiters)) { [EOL]             lastWasGap = true; [EOL]         } else if (lastWasGap) { [EOL]             buf[count++] = ch; [EOL]             lastWasGap = false; [EOL]         } else { [EOL]             continue; [EOL]         } [EOL]     } [EOL]     return new String(buf, 0, count); [EOL] } 
 [LINE] for (int i = 0; i < strLen; i++) { [LINE] public static String initials(final String str, final char... delimiters) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return str; [EOL]     } [EOL]     if (delimiters != null && delimiters.length == 0) { [EOL]         return ""; [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     final char[] buf = new char[strLen / 2 + 1]; [EOL]     int count = 0; [EOL]     boolean lastWasGap = true; [EOL]     for (int i = 0; i < strLen; i++) { [EOL]         final char ch = str.charAt(i); [EOL]         if (isDelimiter(ch, delimiters)) { [EOL]             lastWasGap = true; [EOL]         } else if (lastWasGap) { [EOL]             buf[count++] = ch; [EOL]             lastWasGap = false; [EOL]         } else { [EOL]             continue; [EOL]         } [EOL]     } [EOL]     return new String(buf, 0, count); [EOL] } 
 [LINE] return true; [LINE] private static boolean isDelimiter(final char ch, final char[] delimiters) { [EOL]     if (delimiters == null) { [EOL]         return Character.isWhitespace(ch); [EOL]     } [EOL]     for (final char delimiter : delimiters) { [EOL]         if (ch == delimiter) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } 
lang3/time/DateUtils.java
 [LINE] final Calendar cal1 = Calendar.getInstance(); [LINE] public static boolean isSameDay(final Date date1, final Date date2) { [EOL]     if (date1 == null || date2 == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     final Calendar cal1 = Calendar.getInstance(); [EOL]     cal1.setTime(date1); [EOL]     final Calendar cal2 = Calendar.getInstance(); [EOL]     cal2.setTime(date2); [EOL]     return isSameDay(cal1, cal2); [EOL] } 
 [LINE] final Calendar cal2 = Calendar.getInstance(); [LINE] public static boolean isSameDay(final Date date1, final Date date2) { [EOL]     if (date1 == null || date2 == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     final Calendar cal1 = Calendar.getInstance(); [EOL]     cal1.setTime(date1); [EOL]     final Calendar cal2 = Calendar.getInstance(); [EOL]     cal2.setTime(date2); [EOL]     return isSameDay(cal1, cal2); [EOL] } 
 [LINE] throw new IllegalArgumentException("The date must not be null"); [LINE] public static boolean isSameDay(final Calendar cal1, final Calendar cal2) { [EOL]     if (cal1 == null || cal2 == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     return (cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) && cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR)); [EOL] } 
 [LINE] return date1.getTime() == date2.getTime(); [LINE] public static boolean isSameInstant(final Date date1, final Date date2) { [EOL]     if (date1 == null || date2 == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     return date1.getTime() == date2.getTime(); [EOL] } 
 [LINE] return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) && [LINE] public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2) { [EOL]     if (cal1 == null || cal2 == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) && cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) && cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) && cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) && cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) && cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) && cal1.getClass() == cal2.getClass()); [EOL] } 
 [LINE] throw new IllegalArgumentException("Date and Patterns must not be null"); [LINE] private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException { [EOL]     if (str == null || parsePatterns == null) { [EOL]         throw new IllegalArgumentException("Date and Patterns must not be null"); [EOL]     } [EOL]     SimpleDateFormat parser; [EOL]     if (locale == null) { [EOL]         parser = new SimpleDateFormat(); [EOL]     } else { [EOL]         parser = new SimpleDateFormat("", locale); [EOL]     } [EOL]     parser.setLenient(lenient); [EOL]     final ParsePosition pos = new ParsePosition(0); [EOL]     for (final String parsePattern : parsePatterns) { [EOL]         String pattern = parsePattern; [EOL]         if (parsePattern.endsWith("ZZ")) { [EOL]             pattern = pattern.substring(0, pattern.length() - 1); [EOL]         } [EOL]         parser.applyPattern(pattern); [EOL]         pos.setIndex(0); [EOL]         String str2 = str; [EOL]         if (parsePattern.endsWith("ZZ")) { [EOL]             str2 = str.replaceAll("([-+][0-9][0-9]):([0-9][0-9])$", "$1$2"); [EOL]         } [EOL]         final Date date = parser.parse(str2, pos); [EOL]         if (date != null && pos.getIndex() == str2.length()) { [EOL]             return date; [EOL]         } [EOL]     } [EOL]     throw new ParseException("Unable to parse the date: " + str, -1); [EOL] } 
 [LINE] if (locale == null) { [LINE] private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException { [EOL]     if (str == null || parsePatterns == null) { [EOL]         throw new IllegalArgumentException("Date and Patterns must not be null"); [EOL]     } [EOL]     SimpleDateFormat parser; [EOL]     if (locale == null) { [EOL]         parser = new SimpleDateFormat(); [EOL]     } else { [EOL]         parser = new SimpleDateFormat("", locale); [EOL]     } [EOL]     parser.setLenient(lenient); [EOL]     final ParsePosition pos = new ParsePosition(0); [EOL]     for (final String parsePattern : parsePatterns) { [EOL]         String pattern = parsePattern; [EOL]         if (parsePattern.endsWith("ZZ")) { [EOL]             pattern = pattern.substring(0, pattern.length() - 1); [EOL]         } [EOL]         parser.applyPattern(pattern); [EOL]         pos.setIndex(0); [EOL]         String str2 = str; [EOL]         if (parsePattern.endsWith("ZZ")) { [EOL]             str2 = str.replaceAll("([-+][0-9][0-9]):([0-9][0-9])$", "$1$2"); [EOL]         } [EOL]         final Date date = parser.parse(str2, pos); [EOL]         if (date != null && pos.getIndex() == str2.length()) { [EOL]             return date; [EOL]         } [EOL]     } [EOL]     throw new ParseException("Unable to parse the date: " + str, -1); [EOL] } 
 [LINE] final ParsePosition pos = new ParsePosition(0); [LINE] private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException { [EOL]     if (str == null || parsePatterns == null) { [EOL]         throw new IllegalArgumentException("Date and Patterns must not be null"); [EOL]     } [EOL]     SimpleDateFormat parser; [EOL]     if (locale == null) { [EOL]         parser = new SimpleDateFormat(); [EOL]     } else { [EOL]         parser = new SimpleDateFormat("", locale); [EOL]     } [EOL]     parser.setLenient(lenient); [EOL]     final ParsePosition pos = new ParsePosition(0); [EOL]     for (final String parsePattern : parsePatterns) { [EOL]         String pattern = parsePattern; [EOL]         if (parsePattern.endsWith("ZZ")) { [EOL]             pattern = pattern.substring(0, pattern.length() - 1); [EOL]         } [EOL]         parser.applyPattern(pattern); [EOL]         pos.setIndex(0); [EOL]         String str2 = str; [EOL]         if (parsePattern.endsWith("ZZ")) { [EOL]             str2 = str.replaceAll("([-+][0-9][0-9]):([0-9][0-9])$", "$1$2"); [EOL]         } [EOL]         final Date date = parser.parse(str2, pos); [EOL]         if (date != null && pos.getIndex() == str2.length()) { [EOL]             return date; [EOL]         } [EOL]     } [EOL]     throw new ParseException("Unable to parse the date: " + str, -1); [EOL] } 
 [LINE] String str2 = str; [LINE] private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException { [EOL]     if (str == null || parsePatterns == null) { [EOL]         throw new IllegalArgumentException("Date and Patterns must not be null"); [EOL]     } [EOL]     SimpleDateFormat parser; [EOL]     if (locale == null) { [EOL]         parser = new SimpleDateFormat(); [EOL]     } else { [EOL]         parser = new SimpleDateFormat("", locale); [EOL]     } [EOL]     parser.setLenient(lenient); [EOL]     final ParsePosition pos = new ParsePosition(0); [EOL]     for (final String parsePattern : parsePatterns) { [EOL]         String pattern = parsePattern; [EOL]         if (parsePattern.endsWith("ZZ")) { [EOL]             pattern = pattern.substring(0, pattern.length() - 1); [EOL]         } [EOL]         parser.applyPattern(pattern); [EOL]         pos.setIndex(0); [EOL]         String str2 = str; [EOL]         if (parsePattern.endsWith("ZZ")) { [EOL]             str2 = str.replaceAll("([-+][0-9][0-9]):([0-9][0-9])$", "$1$2"); [EOL]         } [EOL]         final Date date = parser.parse(str2, pos); [EOL]         if (date != null && pos.getIndex() == str2.length()) { [EOL]             return date; [EOL]         } [EOL]     } [EOL]     throw new ParseException("Unable to parse the date: " + str, -1); [EOL] } 
 [LINE] if (date != null && pos.getIndex() == str2.length()) { [LINE] private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException { [EOL]     if (str == null || parsePatterns == null) { [EOL]         throw new IllegalArgumentException("Date and Patterns must not be null"); [EOL]     } [EOL]     SimpleDateFormat parser; [EOL]     if (locale == null) { [EOL]         parser = new SimpleDateFormat(); [EOL]     } else { [EOL]         parser = new SimpleDateFormat("", locale); [EOL]     } [EOL]     parser.setLenient(lenient); [EOL]     final ParsePosition pos = new ParsePosition(0); [EOL]     for (final String parsePattern : parsePatterns) { [EOL]         String pattern = parsePattern; [EOL]         if (parsePattern.endsWith("ZZ")) { [EOL]             pattern = pattern.substring(0, pattern.length() - 1); [EOL]         } [EOL]         parser.applyPattern(pattern); [EOL]         pos.setIndex(0); [EOL]         String str2 = str; [EOL]         if (parsePattern.endsWith("ZZ")) { [EOL]             str2 = str.replaceAll("([-+][0-9][0-9]):([0-9][0-9])$", "$1$2"); [EOL]         } [EOL]         final Date date = parser.parse(str2, pos); [EOL]         if (date != null && pos.getIndex() == str2.length()) { [EOL]             return date; [EOL]         } [EOL]     } [EOL]     throw new ParseException("Unable to parse the date: " + str, -1); [EOL] } 
 [LINE] return add(date, Calendar.MILLISECOND, amount); [LINE] public static Date addMilliseconds(final Date date, final int amount) { [EOL]     return add(date, Calendar.MILLISECOND, amount); [EOL] } 
 [LINE] c.setTime(date); [LINE] private static Date add(final Date date, final int calendarField, final int amount) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     final Calendar c = Calendar.getInstance(); [EOL]     c.setTime(date); [EOL]     c.add(calendarField, amount); [EOL]     return c.getTime(); [EOL] } 
 [LINE] return set(date, Calendar.MILLISECOND, amount); [LINE] public static Date setMilliseconds(final Date date, final int amount) { [EOL]     return set(date, Calendar.MILLISECOND, amount); [EOL] } 
 [LINE] c.set(calendarField, amount); [LINE] private static Date set(final Date date, final int calendarField, final int amount) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     final Calendar c = Calendar.getInstance(); [EOL]     c.setLenient(false); [EOL]     c.setTime(date); [EOL]     c.set(calendarField, amount); [EOL]     return c.getTime(); [EOL] } 
 [LINE] final Calendar c = Calendar.getInstance(); [LINE] public static Calendar toCalendar(final Date date) { [EOL]     final Calendar c = Calendar.getInstance(); [EOL]     c.setTime(date); [EOL]     return c; [EOL] } 
 [LINE] return c; [LINE] public static Calendar toCalendar(final Date date) { [EOL]     final Calendar c = Calendar.getInstance(); [EOL]     c.setTime(date); [EOL]     return c; [EOL] } 
 [LINE] throw new IllegalArgumentException("The date must not be null"); [LINE] public static Date round(final Date date, final int field) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     final Calendar gval = Calendar.getInstance(); [EOL]     gval.setTime(date); [EOL]     modify(gval, field, MODIFY_ROUND); [EOL]     return gval.getTime(); [EOL] } 
 [LINE] if (date instanceof Date) { [LINE] public static Date round(final Object date, final int field) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     if (date instanceof Date) { [EOL]         return round((Date) date, field); [EOL]     } else if (date instanceof Calendar) { [EOL]         return round((Calendar) date, field).getTime(); [EOL]     } else { [EOL]         throw new ClassCastException("Could not round " + date); [EOL]     } [EOL] } 
 [LINE] return round((Date) date, field); [LINE] public static Date round(final Object date, final int field) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     if (date instanceof Date) { [EOL]         return round((Date) date, field); [EOL]     } else if (date instanceof Calendar) { [EOL]         return round((Calendar) date, field).getTime(); [EOL]     } else { [EOL]         throw new ClassCastException("Could not round " + date); [EOL]     } [EOL] } 
 [LINE] throw new ClassCastException("Could not round " + date); [LINE] public static Date round(final Object date, final int field) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     if (date instanceof Date) { [EOL]         return round((Date) date, field); [EOL]     } else if (date instanceof Calendar) { [EOL]         return round((Calendar) date, field).getTime(); [EOL]     } else { [EOL]         throw new ClassCastException("Could not round " + date); [EOL]     } [EOL] } 
 [LINE] final Calendar gval = Calendar.getInstance(); [LINE] public static Date truncate(final Date date, final int field) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     final Calendar gval = Calendar.getInstance(); [EOL]     gval.setTime(date); [EOL]     modify(gval, field, MODIFY_TRUNCATE); [EOL]     return gval.getTime(); [EOL] } 
 [LINE] modify(truncated, field, MODIFY_TRUNCATE); [LINE] public static Calendar truncate(final Calendar date, final int field) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     final Calendar truncated = (Calendar) date.clone(); [EOL]     modify(truncated, field, MODIFY_TRUNCATE); [EOL]     return truncated; [EOL] } 
 [LINE] return ceiled; [LINE] public static Calendar ceiling(final Calendar date, final int field) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     final Calendar ceiled = (Calendar) date.clone(); [EOL]     modify(ceiled, field, MODIFY_CEILING); [EOL]     return ceiled; [EOL] } 
 [LINE] if (date instanceof Date) { [LINE] public static Date ceiling(final Object date, final int field) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     if (date instanceof Date) { [EOL]         return ceiling((Date) date, field); [EOL]     } else if (date instanceof Calendar) { [EOL]         return ceiling((Calendar) date, field).getTime(); [EOL]     } else { [EOL]         throw new ClassCastException("Could not find ceiling of for type: " + date.getClass()); [EOL]     } [EOL] } 
 [LINE] return ceiling((Calendar) date, field).getTime(); [LINE] public static Date ceiling(final Object date, final int field) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     if (date instanceof Date) { [EOL]         return ceiling((Date) date, field); [EOL]     } else if (date instanceof Calendar) { [EOL]         return ceiling((Calendar) date, field).getTime(); [EOL]     } else { [EOL]         throw new ClassCastException("Could not find ceiling of for type: " + date.getClass()); [EOL]     } [EOL] } 
 [LINE] throw new ClassCastException("Could not find ceiling of for type: " + date.getClass()); [LINE] public static Date ceiling(final Object date, final int field) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     if (date instanceof Date) { [EOL]         return ceiling((Date) date, field); [EOL]     } else if (date instanceof Calendar) { [EOL]         return ceiling((Calendar) date, field).getTime(); [EOL]     } else { [EOL]         throw new ClassCastException("Could not find ceiling of for type: " + date.getClass()); [EOL]     } [EOL] } 
 [LINE] final Date date = val.getTime(); [LINE] private static void modify(final Calendar val, final int field, final int modType) { [EOL]     if (val.get(Calendar.YEAR) > 280000000) { [EOL]         throw new ArithmeticException("Calendar value too large for accurate calculations"); [EOL]     } [EOL]     if (field == Calendar.MILLISECOND) { [EOL]         return; [EOL]     } [EOL]     final Date date = val.getTime(); [EOL]     long time = date.getTime(); [EOL]     boolean done = false; [EOL]     final int millisecs = val.get(Calendar.MILLISECOND); [EOL]     if (MODIFY_TRUNCATE == modType || millisecs < 500) { [EOL]         time = time - millisecs; [EOL]     } [EOL]     if (field == Calendar.SECOND) { [EOL]         done = true; [EOL]     } [EOL]     final int seconds = val.get(Calendar.SECOND); [EOL]     if (!done && (MODIFY_TRUNCATE == modType || seconds < 30)) { [EOL]         time = time - (seconds * 1000L); [EOL]     } [EOL]     if (field == Calendar.MINUTE) { [EOL]         done = true; [EOL]     } [EOL]     final int minutes = val.get(Calendar.MINUTE); [EOL]     if (!done && (MODIFY_TRUNCATE == modType || minutes < 30)) { [EOL]         time = time - (minutes * 60000L); [EOL]     } [EOL]     if (date.getTime() != time) { [EOL]         date.setTime(time); [EOL]         val.setTime(date); [EOL]     } [EOL]     boolean roundUp = false; [EOL]     for (final int[] aField : fields) { [EOL]         for (final int element : aField) { [EOL]             if (element == field) { [EOL]                 if (modType == MODIFY_CEILING || (modType == MODIFY_ROUND && roundUp)) { [EOL]                     if (field == DateUtils.SEMI_MONTH) { [EOL]                         if (val.get(Calendar.DATE) == 1) { [EOL]                             val.add(Calendar.DATE, 15); [EOL]                         } else { [EOL]                             val.add(Calendar.DATE, -15); [EOL]                             val.add(Calendar.MONTH, 1); [EOL]                         } [EOL]                     } else if (field == Calendar.AM_PM) { [EOL]                         if (val.get(Calendar.HOUR_OF_DAY) == 0) { [EOL]                             val.add(Calendar.HOUR_OF_DAY, 12); [EOL]                         } else { [EOL]                             val.add(Calendar.HOUR_OF_DAY, -12); [EOL]                             val.add(Calendar.DATE, 1); [EOL]                         } [EOL]                     } else { [EOL]                         val.add(aField[0], 1); [EOL]                     } [EOL]                 } [EOL]                 return; [EOL]             } [EOL]         } [EOL]         int offset = 0; [EOL]         boolean offsetSet = false; [EOL]         switch(field) { [EOL]             case DateUtils.SEMI_MONTH: [EOL]                 if (aField[0] == Calendar.DATE) { [EOL]                     offset = val.get(Calendar.DATE) - 1; [EOL]                     if (offset >= 15) { [EOL]                         offset -= 15; [EOL]                     } [EOL]                     roundUp = offset > 7; [EOL]                     offsetSet = true; [EOL]                 } [EOL]                 break; [EOL]             case Calendar.AM_PM: [EOL]                 if (aField[0] == Calendar.HOUR_OF_DAY) { [EOL]                     offset = val.get(Calendar.HOUR_OF_DAY); [EOL]                     if (offset >= 12) { [EOL]                         offset -= 12; [EOL]                     } [EOL]                     roundUp = offset >= 6; [EOL]                     offsetSet = true; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         if (!offsetSet) { [EOL]             final int min = val.getActualMinimum(aField[0]); [EOL]             final int max = val.getActualMaximum(aField[0]); [EOL]             offset = val.get(aField[0]) - min; [EOL]             roundUp = offset > ((max - min) / 2); [EOL]         } [EOL]         if (offset != 0) { [EOL]             val.set(aField[0], val.get(aField[0]) - offset); [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The field " + field + " is not supported"); [EOL] } 
 [LINE] if (!done && (MODIFY_TRUNCATE == modType || minutes < 30)) { [LINE] private static void modify(final Calendar val, final int field, final int modType) { [EOL]     if (val.get(Calendar.YEAR) > 280000000) { [EOL]         throw new ArithmeticException("Calendar value too large for accurate calculations"); [EOL]     } [EOL]     if (field == Calendar.MILLISECOND) { [EOL]         return; [EOL]     } [EOL]     final Date date = val.getTime(); [EOL]     long time = date.getTime(); [EOL]     boolean done = false; [EOL]     final int millisecs = val.get(Calendar.MILLISECOND); [EOL]     if (MODIFY_TRUNCATE == modType || millisecs < 500) { [EOL]         time = time - millisecs; [EOL]     } [EOL]     if (field == Calendar.SECOND) { [EOL]         done = true; [EOL]     } [EOL]     final int seconds = val.get(Calendar.SECOND); [EOL]     if (!done && (MODIFY_TRUNCATE == modType || seconds < 30)) { [EOL]         time = time - (seconds * 1000L); [EOL]     } [EOL]     if (field == Calendar.MINUTE) { [EOL]         done = true; [EOL]     } [EOL]     final int minutes = val.get(Calendar.MINUTE); [EOL]     if (!done && (MODIFY_TRUNCATE == modType || minutes < 30)) { [EOL]         time = time - (minutes * 60000L); [EOL]     } [EOL]     if (date.getTime() != time) { [EOL]         date.setTime(time); [EOL]         val.setTime(date); [EOL]     } [EOL]     boolean roundUp = false; [EOL]     for (final int[] aField : fields) { [EOL]         for (final int element : aField) { [EOL]             if (element == field) { [EOL]                 if (modType == MODIFY_CEILING || (modType == MODIFY_ROUND && roundUp)) { [EOL]                     if (field == DateUtils.SEMI_MONTH) { [EOL]                         if (val.get(Calendar.DATE) == 1) { [EOL]                             val.add(Calendar.DATE, 15); [EOL]                         } else { [EOL]                             val.add(Calendar.DATE, -15); [EOL]                             val.add(Calendar.MONTH, 1); [EOL]                         } [EOL]                     } else if (field == Calendar.AM_PM) { [EOL]                         if (val.get(Calendar.HOUR_OF_DAY) == 0) { [EOL]                             val.add(Calendar.HOUR_OF_DAY, 12); [EOL]                         } else { [EOL]                             val.add(Calendar.HOUR_OF_DAY, -12); [EOL]                             val.add(Calendar.DATE, 1); [EOL]                         } [EOL]                     } else { [EOL]                         val.add(aField[0], 1); [EOL]                     } [EOL]                 } [EOL]                 return; [EOL]             } [EOL]         } [EOL]         int offset = 0; [EOL]         boolean offsetSet = false; [EOL]         switch(field) { [EOL]             case DateUtils.SEMI_MONTH: [EOL]                 if (aField[0] == Calendar.DATE) { [EOL]                     offset = val.get(Calendar.DATE) - 1; [EOL]                     if (offset >= 15) { [EOL]                         offset -= 15; [EOL]                     } [EOL]                     roundUp = offset > 7; [EOL]                     offsetSet = true; [EOL]                 } [EOL]                 break; [EOL]             case Calendar.AM_PM: [EOL]                 if (aField[0] == Calendar.HOUR_OF_DAY) { [EOL]                     offset = val.get(Calendar.HOUR_OF_DAY); [EOL]                     if (offset >= 12) { [EOL]                         offset -= 12; [EOL]                     } [EOL]                     roundUp = offset >= 6; [EOL]                     offsetSet = true; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         if (!offsetSet) { [EOL]             final int min = val.getActualMinimum(aField[0]); [EOL]             final int max = val.getActualMaximum(aField[0]); [EOL]             offset = val.get(aField[0]) - min; [EOL]             roundUp = offset > ((max - min) / 2); [EOL]         } [EOL]         if (offset != 0) { [EOL]             val.set(aField[0], val.get(aField[0]) - offset); [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The field " + field + " is not supported"); [EOL] } 
 [LINE] if (date.getTime() != time) { [LINE] private static void modify(final Calendar val, final int field, final int modType) { [EOL]     if (val.get(Calendar.YEAR) > 280000000) { [EOL]         throw new ArithmeticException("Calendar value too large for accurate calculations"); [EOL]     } [EOL]     if (field == Calendar.MILLISECOND) { [EOL]         return; [EOL]     } [EOL]     final Date date = val.getTime(); [EOL]     long time = date.getTime(); [EOL]     boolean done = false; [EOL]     final int millisecs = val.get(Calendar.MILLISECOND); [EOL]     if (MODIFY_TRUNCATE == modType || millisecs < 500) { [EOL]         time = time - millisecs; [EOL]     } [EOL]     if (field == Calendar.SECOND) { [EOL]         done = true; [EOL]     } [EOL]     final int seconds = val.get(Calendar.SECOND); [EOL]     if (!done && (MODIFY_TRUNCATE == modType || seconds < 30)) { [EOL]         time = time - (seconds * 1000L); [EOL]     } [EOL]     if (field == Calendar.MINUTE) { [EOL]         done = true; [EOL]     } [EOL]     final int minutes = val.get(Calendar.MINUTE); [EOL]     if (!done && (MODIFY_TRUNCATE == modType || minutes < 30)) { [EOL]         time = time - (minutes * 60000L); [EOL]     } [EOL]     if (date.getTime() != time) { [EOL]         date.setTime(time); [EOL]         val.setTime(date); [EOL]     } [EOL]     boolean roundUp = false; [EOL]     for (final int[] aField : fields) { [EOL]         for (final int element : aField) { [EOL]             if (element == field) { [EOL]                 if (modType == MODIFY_CEILING || (modType == MODIFY_ROUND && roundUp)) { [EOL]                     if (field == DateUtils.SEMI_MONTH) { [EOL]                         if (val.get(Calendar.DATE) == 1) { [EOL]                             val.add(Calendar.DATE, 15); [EOL]                         } else { [EOL]                             val.add(Calendar.DATE, -15); [EOL]                             val.add(Calendar.MONTH, 1); [EOL]                         } [EOL]                     } else if (field == Calendar.AM_PM) { [EOL]                         if (val.get(Calendar.HOUR_OF_DAY) == 0) { [EOL]                             val.add(Calendar.HOUR_OF_DAY, 12); [EOL]                         } else { [EOL]                             val.add(Calendar.HOUR_OF_DAY, -12); [EOL]                             val.add(Calendar.DATE, 1); [EOL]                         } [EOL]                     } else { [EOL]                         val.add(aField[0], 1); [EOL]                     } [EOL]                 } [EOL]                 return; [EOL]             } [EOL]         } [EOL]         int offset = 0; [EOL]         boolean offsetSet = false; [EOL]         switch(field) { [EOL]             case DateUtils.SEMI_MONTH: [EOL]                 if (aField[0] == Calendar.DATE) { [EOL]                     offset = val.get(Calendar.DATE) - 1; [EOL]                     if (offset >= 15) { [EOL]                         offset -= 15; [EOL]                     } [EOL]                     roundUp = offset > 7; [EOL]                     offsetSet = true; [EOL]                 } [EOL]                 break; [EOL]             case Calendar.AM_PM: [EOL]                 if (aField[0] == Calendar.HOUR_OF_DAY) { [EOL]                     offset = val.get(Calendar.HOUR_OF_DAY); [EOL]                     if (offset >= 12) { [EOL]                         offset -= 12; [EOL]                     } [EOL]                     roundUp = offset >= 6; [EOL]                     offsetSet = true; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         if (!offsetSet) { [EOL]             final int min = val.getActualMinimum(aField[0]); [EOL]             final int max = val.getActualMaximum(aField[0]); [EOL]             offset = val.get(aField[0]) - min; [EOL]             roundUp = offset > ((max - min) / 2); [EOL]         } [EOL]         if (offset != 0) { [EOL]             val.set(aField[0], val.get(aField[0]) - offset); [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The field " + field + " is not supported"); [EOL] } 
 [LINE] date.setTime(time); [LINE] private static void modify(final Calendar val, final int field, final int modType) { [EOL]     if (val.get(Calendar.YEAR) > 280000000) { [EOL]         throw new ArithmeticException("Calendar value too large for accurate calculations"); [EOL]     } [EOL]     if (field == Calendar.MILLISECOND) { [EOL]         return; [EOL]     } [EOL]     final Date date = val.getTime(); [EOL]     long time = date.getTime(); [EOL]     boolean done = false; [EOL]     final int millisecs = val.get(Calendar.MILLISECOND); [EOL]     if (MODIFY_TRUNCATE == modType || millisecs < 500) { [EOL]         time = time - millisecs; [EOL]     } [EOL]     if (field == Calendar.SECOND) { [EOL]         done = true; [EOL]     } [EOL]     final int seconds = val.get(Calendar.SECOND); [EOL]     if (!done && (MODIFY_TRUNCATE == modType || seconds < 30)) { [EOL]         time = time - (seconds * 1000L); [EOL]     } [EOL]     if (field == Calendar.MINUTE) { [EOL]         done = true; [EOL]     } [EOL]     final int minutes = val.get(Calendar.MINUTE); [EOL]     if (!done && (MODIFY_TRUNCATE == modType || minutes < 30)) { [EOL]         time = time - (minutes * 60000L); [EOL]     } [EOL]     if (date.getTime() != time) { [EOL]         date.setTime(time); [EOL]         val.setTime(date); [EOL]     } [EOL]     boolean roundUp = false; [EOL]     for (final int[] aField : fields) { [EOL]         for (final int element : aField) { [EOL]             if (element == field) { [EOL]                 if (modType == MODIFY_CEILING || (modType == MODIFY_ROUND && roundUp)) { [EOL]                     if (field == DateUtils.SEMI_MONTH) { [EOL]                         if (val.get(Calendar.DATE) == 1) { [EOL]                             val.add(Calendar.DATE, 15); [EOL]                         } else { [EOL]                             val.add(Calendar.DATE, -15); [EOL]                             val.add(Calendar.MONTH, 1); [EOL]                         } [EOL]                     } else if (field == Calendar.AM_PM) { [EOL]                         if (val.get(Calendar.HOUR_OF_DAY) == 0) { [EOL]                             val.add(Calendar.HOUR_OF_DAY, 12); [EOL]                         } else { [EOL]                             val.add(Calendar.HOUR_OF_DAY, -12); [EOL]                             val.add(Calendar.DATE, 1); [EOL]                         } [EOL]                     } else { [EOL]                         val.add(aField[0], 1); [EOL]                     } [EOL]                 } [EOL]                 return; [EOL]             } [EOL]         } [EOL]         int offset = 0; [EOL]         boolean offsetSet = false; [EOL]         switch(field) { [EOL]             case DateUtils.SEMI_MONTH: [EOL]                 if (aField[0] == Calendar.DATE) { [EOL]                     offset = val.get(Calendar.DATE) - 1; [EOL]                     if (offset >= 15) { [EOL]                         offset -= 15; [EOL]                     } [EOL]                     roundUp = offset > 7; [EOL]                     offsetSet = true; [EOL]                 } [EOL]                 break; [EOL]             case Calendar.AM_PM: [EOL]                 if (aField[0] == Calendar.HOUR_OF_DAY) { [EOL]                     offset = val.get(Calendar.HOUR_OF_DAY); [EOL]                     if (offset >= 12) { [EOL]                         offset -= 12; [EOL]                     } [EOL]                     roundUp = offset >= 6; [EOL]                     offsetSet = true; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         if (!offsetSet) { [EOL]             final int min = val.getActualMinimum(aField[0]); [EOL]             final int max = val.getActualMaximum(aField[0]); [EOL]             offset = val.get(aField[0]) - min; [EOL]             roundUp = offset > ((max - min) / 2); [EOL]         } [EOL]         if (offset != 0) { [EOL]             val.set(aField[0], val.get(aField[0]) - offset); [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The field " + field + " is not supported"); [EOL] } 
 [LINE] boolean roundUp = false; [LINE] private static void modify(final Calendar val, final int field, final int modType) { [EOL]     if (val.get(Calendar.YEAR) > 280000000) { [EOL]         throw new ArithmeticException("Calendar value too large for accurate calculations"); [EOL]     } [EOL]     if (field == Calendar.MILLISECOND) { [EOL]         return; [EOL]     } [EOL]     final Date date = val.getTime(); [EOL]     long time = date.getTime(); [EOL]     boolean done = false; [EOL]     final int millisecs = val.get(Calendar.MILLISECOND); [EOL]     if (MODIFY_TRUNCATE == modType || millisecs < 500) { [EOL]         time = time - millisecs; [EOL]     } [EOL]     if (field == Calendar.SECOND) { [EOL]         done = true; [EOL]     } [EOL]     final int seconds = val.get(Calendar.SECOND); [EOL]     if (!done && (MODIFY_TRUNCATE == modType || seconds < 30)) { [EOL]         time = time - (seconds * 1000L); [EOL]     } [EOL]     if (field == Calendar.MINUTE) { [EOL]         done = true; [EOL]     } [EOL]     final int minutes = val.get(Calendar.MINUTE); [EOL]     if (!done && (MODIFY_TRUNCATE == modType || minutes < 30)) { [EOL]         time = time - (minutes * 60000L); [EOL]     } [EOL]     if (date.getTime() != time) { [EOL]         date.setTime(time); [EOL]         val.setTime(date); [EOL]     } [EOL]     boolean roundUp = false; [EOL]     for (final int[] aField : fields) { [EOL]         for (final int element : aField) { [EOL]             if (element == field) { [EOL]                 if (modType == MODIFY_CEILING || (modType == MODIFY_ROUND && roundUp)) { [EOL]                     if (field == DateUtils.SEMI_MONTH) { [EOL]                         if (val.get(Calendar.DATE) == 1) { [EOL]                             val.add(Calendar.DATE, 15); [EOL]                         } else { [EOL]                             val.add(Calendar.DATE, -15); [EOL]                             val.add(Calendar.MONTH, 1); [EOL]                         } [EOL]                     } else if (field == Calendar.AM_PM) { [EOL]                         if (val.get(Calendar.HOUR_OF_DAY) == 0) { [EOL]                             val.add(Calendar.HOUR_OF_DAY, 12); [EOL]                         } else { [EOL]                             val.add(Calendar.HOUR_OF_DAY, -12); [EOL]                             val.add(Calendar.DATE, 1); [EOL]                         } [EOL]                     } else { [EOL]                         val.add(aField[0], 1); [EOL]                     } [EOL]                 } [EOL]                 return; [EOL]             } [EOL]         } [EOL]         int offset = 0; [EOL]         boolean offsetSet = false; [EOL]         switch(field) { [EOL]             case DateUtils.SEMI_MONTH: [EOL]                 if (aField[0] == Calendar.DATE) { [EOL]                     offset = val.get(Calendar.DATE) - 1; [EOL]                     if (offset >= 15) { [EOL]                         offset -= 15; [EOL]                     } [EOL]                     roundUp = offset > 7; [EOL]                     offsetSet = true; [EOL]                 } [EOL]                 break; [EOL]             case Calendar.AM_PM: [EOL]                 if (aField[0] == Calendar.HOUR_OF_DAY) { [EOL]                     offset = val.get(Calendar.HOUR_OF_DAY); [EOL]                     if (offset >= 12) { [EOL]                         offset -= 12; [EOL]                     } [EOL]                     roundUp = offset >= 6; [EOL]                     offsetSet = true; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         if (!offsetSet) { [EOL]             final int min = val.getActualMinimum(aField[0]); [EOL]             final int max = val.getActualMaximum(aField[0]); [EOL]             offset = val.get(aField[0]) - min; [EOL]             roundUp = offset > ((max - min) / 2); [EOL]         } [EOL]         if (offset != 0) { [EOL]             val.set(aField[0], val.get(aField[0]) - offset); [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The field " + field + " is not supported"); [EOL] } 
 [LINE] if (modType == MODIFY_CEILING || (modType == MODIFY_ROUND && roundUp)) { [LINE] private static void modify(final Calendar val, final int field, final int modType) { [EOL]     if (val.get(Calendar.YEAR) > 280000000) { [EOL]         throw new ArithmeticException("Calendar value too large for accurate calculations"); [EOL]     } [EOL]     if (field == Calendar.MILLISECOND) { [EOL]         return; [EOL]     } [EOL]     final Date date = val.getTime(); [EOL]     long time = date.getTime(); [EOL]     boolean done = false; [EOL]     final int millisecs = val.get(Calendar.MILLISECOND); [EOL]     if (MODIFY_TRUNCATE == modType || millisecs < 500) { [EOL]         time = time - millisecs; [EOL]     } [EOL]     if (field == Calendar.SECOND) { [EOL]         done = true; [EOL]     } [EOL]     final int seconds = val.get(Calendar.SECOND); [EOL]     if (!done && (MODIFY_TRUNCATE == modType || seconds < 30)) { [EOL]         time = time - (seconds * 1000L); [EOL]     } [EOL]     if (field == Calendar.MINUTE) { [EOL]         done = true; [EOL]     } [EOL]     final int minutes = val.get(Calendar.MINUTE); [EOL]     if (!done && (MODIFY_TRUNCATE == modType || minutes < 30)) { [EOL]         time = time - (minutes * 60000L); [EOL]     } [EOL]     if (date.getTime() != time) { [EOL]         date.setTime(time); [EOL]         val.setTime(date); [EOL]     } [EOL]     boolean roundUp = false; [EOL]     for (final int[] aField : fields) { [EOL]         for (final int element : aField) { [EOL]             if (element == field) { [EOL]                 if (modType == MODIFY_CEILING || (modType == MODIFY_ROUND && roundUp)) { [EOL]                     if (field == DateUtils.SEMI_MONTH) { [EOL]                         if (val.get(Calendar.DATE) == 1) { [EOL]                             val.add(Calendar.DATE, 15); [EOL]                         } else { [EOL]                             val.add(Calendar.DATE, -15); [EOL]                             val.add(Calendar.MONTH, 1); [EOL]                         } [EOL]                     } else if (field == Calendar.AM_PM) { [EOL]                         if (val.get(Calendar.HOUR_OF_DAY) == 0) { [EOL]                             val.add(Calendar.HOUR_OF_DAY, 12); [EOL]                         } else { [EOL]                             val.add(Calendar.HOUR_OF_DAY, -12); [EOL]                             val.add(Calendar.DATE, 1); [EOL]                         } [EOL]                     } else { [EOL]                         val.add(aField[0], 1); [EOL]                     } [EOL]                 } [EOL]                 return; [EOL]             } [EOL]         } [EOL]         int offset = 0; [EOL]         boolean offsetSet = false; [EOL]         switch(field) { [EOL]             case DateUtils.SEMI_MONTH: [EOL]                 if (aField[0] == Calendar.DATE) { [EOL]                     offset = val.get(Calendar.DATE) - 1; [EOL]                     if (offset >= 15) { [EOL]                         offset -= 15; [EOL]                     } [EOL]                     roundUp = offset > 7; [EOL]                     offsetSet = true; [EOL]                 } [EOL]                 break; [EOL]             case Calendar.AM_PM: [EOL]                 if (aField[0] == Calendar.HOUR_OF_DAY) { [EOL]                     offset = val.get(Calendar.HOUR_OF_DAY); [EOL]                     if (offset >= 12) { [EOL]                         offset -= 12; [EOL]                     } [EOL]                     roundUp = offset >= 6; [EOL]                     offsetSet = true; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         if (!offsetSet) { [EOL]             final int min = val.getActualMinimum(aField[0]); [EOL]             final int max = val.getActualMaximum(aField[0]); [EOL]             offset = val.get(aField[0]) - min; [EOL]             roundUp = offset > ((max - min) / 2); [EOL]         } [EOL]         if (offset != 0) { [EOL]             val.set(aField[0], val.get(aField[0]) - offset); [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The field " + field + " is not supported"); [EOL] } 
 [LINE] if (val.get(Calendar.DATE) == 1) { [LINE] private static void modify(final Calendar val, final int field, final int modType) { [EOL]     if (val.get(Calendar.YEAR) > 280000000) { [EOL]         throw new ArithmeticException("Calendar value too large for accurate calculations"); [EOL]     } [EOL]     if (field == Calendar.MILLISECOND) { [EOL]         return; [EOL]     } [EOL]     final Date date = val.getTime(); [EOL]     long time = date.getTime(); [EOL]     boolean done = false; [EOL]     final int millisecs = val.get(Calendar.MILLISECOND); [EOL]     if (MODIFY_TRUNCATE == modType || millisecs < 500) { [EOL]         time = time - millisecs; [EOL]     } [EOL]     if (field == Calendar.SECOND) { [EOL]         done = true; [EOL]     } [EOL]     final int seconds = val.get(Calendar.SECOND); [EOL]     if (!done && (MODIFY_TRUNCATE == modType || seconds < 30)) { [EOL]         time = time - (seconds * 1000L); [EOL]     } [EOL]     if (field == Calendar.MINUTE) { [EOL]         done = true; [EOL]     } [EOL]     final int minutes = val.get(Calendar.MINUTE); [EOL]     if (!done && (MODIFY_TRUNCATE == modType || minutes < 30)) { [EOL]         time = time - (minutes * 60000L); [EOL]     } [EOL]     if (date.getTime() != time) { [EOL]         date.setTime(time); [EOL]         val.setTime(date); [EOL]     } [EOL]     boolean roundUp = false; [EOL]     for (final int[] aField : fields) { [EOL]         for (final int element : aField) { [EOL]             if (element == field) { [EOL]                 if (modType == MODIFY_CEILING || (modType == MODIFY_ROUND && roundUp)) { [EOL]                     if (field == DateUtils.SEMI_MONTH) { [EOL]                         if (val.get(Calendar.DATE) == 1) { [EOL]                             val.add(Calendar.DATE, 15); [EOL]                         } else { [EOL]                             val.add(Calendar.DATE, -15); [EOL]                             val.add(Calendar.MONTH, 1); [EOL]                         } [EOL]                     } else if (field == Calendar.AM_PM) { [EOL]                         if (val.get(Calendar.HOUR_OF_DAY) == 0) { [EOL]                             val.add(Calendar.HOUR_OF_DAY, 12); [EOL]                         } else { [EOL]                             val.add(Calendar.HOUR_OF_DAY, -12); [EOL]                             val.add(Calendar.DATE, 1); [EOL]                         } [EOL]                     } else { [EOL]                         val.add(aField[0], 1); [EOL]                     } [EOL]                 } [EOL]                 return; [EOL]             } [EOL]         } [EOL]         int offset = 0; [EOL]         boolean offsetSet = false; [EOL]         switch(field) { [EOL]             case DateUtils.SEMI_MONTH: [EOL]                 if (aField[0] == Calendar.DATE) { [EOL]                     offset = val.get(Calendar.DATE) - 1; [EOL]                     if (offset >= 15) { [EOL]                         offset -= 15; [EOL]                     } [EOL]                     roundUp = offset > 7; [EOL]                     offsetSet = true; [EOL]                 } [EOL]                 break; [EOL]             case Calendar.AM_PM: [EOL]                 if (aField[0] == Calendar.HOUR_OF_DAY) { [EOL]                     offset = val.get(Calendar.HOUR_OF_DAY); [EOL]                     if (offset >= 12) { [EOL]                         offset -= 12; [EOL]                     } [EOL]                     roundUp = offset >= 6; [EOL]                     offsetSet = true; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         if (!offsetSet) { [EOL]             final int min = val.getActualMinimum(aField[0]); [EOL]             final int max = val.getActualMaximum(aField[0]); [EOL]             offset = val.get(aField[0]) - min; [EOL]             roundUp = offset > ((max - min) / 2); [EOL]         } [EOL]         if (offset != 0) { [EOL]             val.set(aField[0], val.get(aField[0]) - offset); [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The field " + field + " is not supported"); [EOL] } 
 [LINE] offset = val.get(Calendar.DATE) - 1; [LINE] private static void modify(final Calendar val, final int field, final int modType) { [EOL]     if (val.get(Calendar.YEAR) > 280000000) { [EOL]         throw new ArithmeticException("Calendar value too large for accurate calculations"); [EOL]     } [EOL]     if (field == Calendar.MILLISECOND) { [EOL]         return; [EOL]     } [EOL]     final Date date = val.getTime(); [EOL]     long time = date.getTime(); [EOL]     boolean done = false; [EOL]     final int millisecs = val.get(Calendar.MILLISECOND); [EOL]     if (MODIFY_TRUNCATE == modType || millisecs < 500) { [EOL]         time = time - millisecs; [EOL]     } [EOL]     if (field == Calendar.SECOND) { [EOL]         done = true; [EOL]     } [EOL]     final int seconds = val.get(Calendar.SECOND); [EOL]     if (!done && (MODIFY_TRUNCATE == modType || seconds < 30)) { [EOL]         time = time - (seconds * 1000L); [EOL]     } [EOL]     if (field == Calendar.MINUTE) { [EOL]         done = true; [EOL]     } [EOL]     final int minutes = val.get(Calendar.MINUTE); [EOL]     if (!done && (MODIFY_TRUNCATE == modType || minutes < 30)) { [EOL]         time = time - (minutes * 60000L); [EOL]     } [EOL]     if (date.getTime() != time) { [EOL]         date.setTime(time); [EOL]         val.setTime(date); [EOL]     } [EOL]     boolean roundUp = false; [EOL]     for (final int[] aField : fields) { [EOL]         for (final int element : aField) { [EOL]             if (element == field) { [EOL]                 if (modType == MODIFY_CEILING || (modType == MODIFY_ROUND && roundUp)) { [EOL]                     if (field == DateUtils.SEMI_MONTH) { [EOL]                         if (val.get(Calendar.DATE) == 1) { [EOL]                             val.add(Calendar.DATE, 15); [EOL]                         } else { [EOL]                             val.add(Calendar.DATE, -15); [EOL]                             val.add(Calendar.MONTH, 1); [EOL]                         } [EOL]                     } else if (field == Calendar.AM_PM) { [EOL]                         if (val.get(Calendar.HOUR_OF_DAY) == 0) { [EOL]                             val.add(Calendar.HOUR_OF_DAY, 12); [EOL]                         } else { [EOL]                             val.add(Calendar.HOUR_OF_DAY, -12); [EOL]                             val.add(Calendar.DATE, 1); [EOL]                         } [EOL]                     } else { [EOL]                         val.add(aField[0], 1); [EOL]                     } [EOL]                 } [EOL]                 return; [EOL]             } [EOL]         } [EOL]         int offset = 0; [EOL]         boolean offsetSet = false; [EOL]         switch(field) { [EOL]             case DateUtils.SEMI_MONTH: [EOL]                 if (aField[0] == Calendar.DATE) { [EOL]                     offset = val.get(Calendar.DATE) - 1; [EOL]                     if (offset >= 15) { [EOL]                         offset -= 15; [EOL]                     } [EOL]                     roundUp = offset > 7; [EOL]                     offsetSet = true; [EOL]                 } [EOL]                 break; [EOL]             case Calendar.AM_PM: [EOL]                 if (aField[0] == Calendar.HOUR_OF_DAY) { [EOL]                     offset = val.get(Calendar.HOUR_OF_DAY); [EOL]                     if (offset >= 12) { [EOL]                         offset -= 12; [EOL]                     } [EOL]                     roundUp = offset >= 6; [EOL]                     offsetSet = true; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         if (!offsetSet) { [EOL]             final int min = val.getActualMinimum(aField[0]); [EOL]             final int max = val.getActualMaximum(aField[0]); [EOL]             offset = val.get(aField[0]) - min; [EOL]             roundUp = offset > ((max - min) / 2); [EOL]         } [EOL]         if (offset != 0) { [EOL]             val.set(aField[0], val.get(aField[0]) - offset); [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The field " + field + " is not supported"); [EOL] } 
 [LINE] offsetSet = true; [LINE] private static void modify(final Calendar val, final int field, final int modType) { [EOL]     if (val.get(Calendar.YEAR) > 280000000) { [EOL]         throw new ArithmeticException("Calendar value too large for accurate calculations"); [EOL]     } [EOL]     if (field == Calendar.MILLISECOND) { [EOL]         return; [EOL]     } [EOL]     final Date date = val.getTime(); [EOL]     long time = date.getTime(); [EOL]     boolean done = false; [EOL]     final int millisecs = val.get(Calendar.MILLISECOND); [EOL]     if (MODIFY_TRUNCATE == modType || millisecs < 500) { [EOL]         time = time - millisecs; [EOL]     } [EOL]     if (field == Calendar.SECOND) { [EOL]         done = true; [EOL]     } [EOL]     final int seconds = val.get(Calendar.SECOND); [EOL]     if (!done && (MODIFY_TRUNCATE == modType || seconds < 30)) { [EOL]         time = time - (seconds * 1000L); [EOL]     } [EOL]     if (field == Calendar.MINUTE) { [EOL]         done = true; [EOL]     } [EOL]     final int minutes = val.get(Calendar.MINUTE); [EOL]     if (!done && (MODIFY_TRUNCATE == modType || minutes < 30)) { [EOL]         time = time - (minutes * 60000L); [EOL]     } [EOL]     if (date.getTime() != time) { [EOL]         date.setTime(time); [EOL]         val.setTime(date); [EOL]     } [EOL]     boolean roundUp = false; [EOL]     for (final int[] aField : fields) { [EOL]         for (final int element : aField) { [EOL]             if (element == field) { [EOL]                 if (modType == MODIFY_CEILING || (modType == MODIFY_ROUND && roundUp)) { [EOL]                     if (field == DateUtils.SEMI_MONTH) { [EOL]                         if (val.get(Calendar.DATE) == 1) { [EOL]                             val.add(Calendar.DATE, 15); [EOL]                         } else { [EOL]                             val.add(Calendar.DATE, -15); [EOL]                             val.add(Calendar.MONTH, 1); [EOL]                         } [EOL]                     } else if (field == Calendar.AM_PM) { [EOL]                         if (val.get(Calendar.HOUR_OF_DAY) == 0) { [EOL]                             val.add(Calendar.HOUR_OF_DAY, 12); [EOL]                         } else { [EOL]                             val.add(Calendar.HOUR_OF_DAY, -12); [EOL]                             val.add(Calendar.DATE, 1); [EOL]                         } [EOL]                     } else { [EOL]                         val.add(aField[0], 1); [EOL]                     } [EOL]                 } [EOL]                 return; [EOL]             } [EOL]         } [EOL]         int offset = 0; [EOL]         boolean offsetSet = false; [EOL]         switch(field) { [EOL]             case DateUtils.SEMI_MONTH: [EOL]                 if (aField[0] == Calendar.DATE) { [EOL]                     offset = val.get(Calendar.DATE) - 1; [EOL]                     if (offset >= 15) { [EOL]                         offset -= 15; [EOL]                     } [EOL]                     roundUp = offset > 7; [EOL]                     offsetSet = true; [EOL]                 } [EOL]                 break; [EOL]             case Calendar.AM_PM: [EOL]                 if (aField[0] == Calendar.HOUR_OF_DAY) { [EOL]                     offset = val.get(Calendar.HOUR_OF_DAY); [EOL]                     if (offset >= 12) { [EOL]                         offset -= 12; [EOL]                     } [EOL]                     roundUp = offset >= 6; [EOL]                     offsetSet = true; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         if (!offsetSet) { [EOL]             final int min = val.getActualMinimum(aField[0]); [EOL]             final int max = val.getActualMaximum(aField[0]); [EOL]             offset = val.get(aField[0]) - min; [EOL]             roundUp = offset > ((max - min) / 2); [EOL]         } [EOL]         if (offset != 0) { [EOL]             val.set(aField[0], val.get(aField[0]) - offset); [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The field " + field + " is not supported"); [EOL] } 
 [LINE] offset -= 12; [LINE] private static void modify(final Calendar val, final int field, final int modType) { [EOL]     if (val.get(Calendar.YEAR) > 280000000) { [EOL]         throw new ArithmeticException("Calendar value too large for accurate calculations"); [EOL]     } [EOL]     if (field == Calendar.MILLISECOND) { [EOL]         return; [EOL]     } [EOL]     final Date date = val.getTime(); [EOL]     long time = date.getTime(); [EOL]     boolean done = false; [EOL]     final int millisecs = val.get(Calendar.MILLISECOND); [EOL]     if (MODIFY_TRUNCATE == modType || millisecs < 500) { [EOL]         time = time - millisecs; [EOL]     } [EOL]     if (field == Calendar.SECOND) { [EOL]         done = true; [EOL]     } [EOL]     final int seconds = val.get(Calendar.SECOND); [EOL]     if (!done && (MODIFY_TRUNCATE == modType || seconds < 30)) { [EOL]         time = time - (seconds * 1000L); [EOL]     } [EOL]     if (field == Calendar.MINUTE) { [EOL]         done = true; [EOL]     } [EOL]     final int minutes = val.get(Calendar.MINUTE); [EOL]     if (!done && (MODIFY_TRUNCATE == modType || minutes < 30)) { [EOL]         time = time - (minutes * 60000L); [EOL]     } [EOL]     if (date.getTime() != time) { [EOL]         date.setTime(time); [EOL]         val.setTime(date); [EOL]     } [EOL]     boolean roundUp = false; [EOL]     for (final int[] aField : fields) { [EOL]         for (final int element : aField) { [EOL]             if (element == field) { [EOL]                 if (modType == MODIFY_CEILING || (modType == MODIFY_ROUND && roundUp)) { [EOL]                     if (field == DateUtils.SEMI_MONTH) { [EOL]                         if (val.get(Calendar.DATE) == 1) { [EOL]                             val.add(Calendar.DATE, 15); [EOL]                         } else { [EOL]                             val.add(Calendar.DATE, -15); [EOL]                             val.add(Calendar.MONTH, 1); [EOL]                         } [EOL]                     } else if (field == Calendar.AM_PM) { [EOL]                         if (val.get(Calendar.HOUR_OF_DAY) == 0) { [EOL]                             val.add(Calendar.HOUR_OF_DAY, 12); [EOL]                         } else { [EOL]                             val.add(Calendar.HOUR_OF_DAY, -12); [EOL]                             val.add(Calendar.DATE, 1); [EOL]                         } [EOL]                     } else { [EOL]                         val.add(aField[0], 1); [EOL]                     } [EOL]                 } [EOL]                 return; [EOL]             } [EOL]         } [EOL]         int offset = 0; [EOL]         boolean offsetSet = false; [EOL]         switch(field) { [EOL]             case DateUtils.SEMI_MONTH: [EOL]                 if (aField[0] == Calendar.DATE) { [EOL]                     offset = val.get(Calendar.DATE) - 1; [EOL]                     if (offset >= 15) { [EOL]                         offset -= 15; [EOL]                     } [EOL]                     roundUp = offset > 7; [EOL]                     offsetSet = true; [EOL]                 } [EOL]                 break; [EOL]             case Calendar.AM_PM: [EOL]                 if (aField[0] == Calendar.HOUR_OF_DAY) { [EOL]                     offset = val.get(Calendar.HOUR_OF_DAY); [EOL]                     if (offset >= 12) { [EOL]                         offset -= 12; [EOL]                     } [EOL]                     roundUp = offset >= 6; [EOL]                     offsetSet = true; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         if (!offsetSet) { [EOL]             final int min = val.getActualMinimum(aField[0]); [EOL]             final int max = val.getActualMaximum(aField[0]); [EOL]             offset = val.get(aField[0]) - min; [EOL]             roundUp = offset > ((max - min) / 2); [EOL]         } [EOL]         if (offset != 0) { [EOL]             val.set(aField[0], val.get(aField[0]) - offset); [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The field " + field + " is not supported"); [EOL] } 
 [LINE] offsetSet = true; [LINE] private static void modify(final Calendar val, final int field, final int modType) { [EOL]     if (val.get(Calendar.YEAR) > 280000000) { [EOL]         throw new ArithmeticException("Calendar value too large for accurate calculations"); [EOL]     } [EOL]     if (field == Calendar.MILLISECOND) { [EOL]         return; [EOL]     } [EOL]     final Date date = val.getTime(); [EOL]     long time = date.getTime(); [EOL]     boolean done = false; [EOL]     final int millisecs = val.get(Calendar.MILLISECOND); [EOL]     if (MODIFY_TRUNCATE == modType || millisecs < 500) { [EOL]         time = time - millisecs; [EOL]     } [EOL]     if (field == Calendar.SECOND) { [EOL]         done = true; [EOL]     } [EOL]     final int seconds = val.get(Calendar.SECOND); [EOL]     if (!done && (MODIFY_TRUNCATE == modType || seconds < 30)) { [EOL]         time = time - (seconds * 1000L); [EOL]     } [EOL]     if (field == Calendar.MINUTE) { [EOL]         done = true; [EOL]     } [EOL]     final int minutes = val.get(Calendar.MINUTE); [EOL]     if (!done && (MODIFY_TRUNCATE == modType || minutes < 30)) { [EOL]         time = time - (minutes * 60000L); [EOL]     } [EOL]     if (date.getTime() != time) { [EOL]         date.setTime(time); [EOL]         val.setTime(date); [EOL]     } [EOL]     boolean roundUp = false; [EOL]     for (final int[] aField : fields) { [EOL]         for (final int element : aField) { [EOL]             if (element == field) { [EOL]                 if (modType == MODIFY_CEILING || (modType == MODIFY_ROUND && roundUp)) { [EOL]                     if (field == DateUtils.SEMI_MONTH) { [EOL]                         if (val.get(Calendar.DATE) == 1) { [EOL]                             val.add(Calendar.DATE, 15); [EOL]                         } else { [EOL]                             val.add(Calendar.DATE, -15); [EOL]                             val.add(Calendar.MONTH, 1); [EOL]                         } [EOL]                     } else if (field == Calendar.AM_PM) { [EOL]                         if (val.get(Calendar.HOUR_OF_DAY) == 0) { [EOL]                             val.add(Calendar.HOUR_OF_DAY, 12); [EOL]                         } else { [EOL]                             val.add(Calendar.HOUR_OF_DAY, -12); [EOL]                             val.add(Calendar.DATE, 1); [EOL]                         } [EOL]                     } else { [EOL]                         val.add(aField[0], 1); [EOL]                     } [EOL]                 } [EOL]                 return; [EOL]             } [EOL]         } [EOL]         int offset = 0; [EOL]         boolean offsetSet = false; [EOL]         switch(field) { [EOL]             case DateUtils.SEMI_MONTH: [EOL]                 if (aField[0] == Calendar.DATE) { [EOL]                     offset = val.get(Calendar.DATE) - 1; [EOL]                     if (offset >= 15) { [EOL]                         offset -= 15; [EOL]                     } [EOL]                     roundUp = offset > 7; [EOL]                     offsetSet = true; [EOL]                 } [EOL]                 break; [EOL]             case Calendar.AM_PM: [EOL]                 if (aField[0] == Calendar.HOUR_OF_DAY) { [EOL]                     offset = val.get(Calendar.HOUR_OF_DAY); [EOL]                     if (offset >= 12) { [EOL]                         offset -= 12; [EOL]                     } [EOL]                     roundUp = offset >= 6; [EOL]                     offsetSet = true; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         if (!offsetSet) { [EOL]             final int min = val.getActualMinimum(aField[0]); [EOL]             final int max = val.getActualMaximum(aField[0]); [EOL]             offset = val.get(aField[0]) - min; [EOL]             roundUp = offset > ((max - min) / 2); [EOL]         } [EOL]         if (offset != 0) { [EOL]             val.set(aField[0], val.get(aField[0]) - offset); [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The field " + field + " is not supported"); [EOL] } 
 [LINE] roundUp = offset > ((max - min) / 2); [LINE] private static void modify(final Calendar val, final int field, final int modType) { [EOL]     if (val.get(Calendar.YEAR) > 280000000) { [EOL]         throw new ArithmeticException("Calendar value too large for accurate calculations"); [EOL]     } [EOL]     if (field == Calendar.MILLISECOND) { [EOL]         return; [EOL]     } [EOL]     final Date date = val.getTime(); [EOL]     long time = date.getTime(); [EOL]     boolean done = false; [EOL]     final int millisecs = val.get(Calendar.MILLISECOND); [EOL]     if (MODIFY_TRUNCATE == modType || millisecs < 500) { [EOL]         time = time - millisecs; [EOL]     } [EOL]     if (field == Calendar.SECOND) { [EOL]         done = true; [EOL]     } [EOL]     final int seconds = val.get(Calendar.SECOND); [EOL]     if (!done && (MODIFY_TRUNCATE == modType || seconds < 30)) { [EOL]         time = time - (seconds * 1000L); [EOL]     } [EOL]     if (field == Calendar.MINUTE) { [EOL]         done = true; [EOL]     } [EOL]     final int minutes = val.get(Calendar.MINUTE); [EOL]     if (!done && (MODIFY_TRUNCATE == modType || minutes < 30)) { [EOL]         time = time - (minutes * 60000L); [EOL]     } [EOL]     if (date.getTime() != time) { [EOL]         date.setTime(time); [EOL]         val.setTime(date); [EOL]     } [EOL]     boolean roundUp = false; [EOL]     for (final int[] aField : fields) { [EOL]         for (final int element : aField) { [EOL]             if (element == field) { [EOL]                 if (modType == MODIFY_CEILING || (modType == MODIFY_ROUND && roundUp)) { [EOL]                     if (field == DateUtils.SEMI_MONTH) { [EOL]                         if (val.get(Calendar.DATE) == 1) { [EOL]                             val.add(Calendar.DATE, 15); [EOL]                         } else { [EOL]                             val.add(Calendar.DATE, -15); [EOL]                             val.add(Calendar.MONTH, 1); [EOL]                         } [EOL]                     } else if (field == Calendar.AM_PM) { [EOL]                         if (val.get(Calendar.HOUR_OF_DAY) == 0) { [EOL]                             val.add(Calendar.HOUR_OF_DAY, 12); [EOL]                         } else { [EOL]                             val.add(Calendar.HOUR_OF_DAY, -12); [EOL]                             val.add(Calendar.DATE, 1); [EOL]                         } [EOL]                     } else { [EOL]                         val.add(aField[0], 1); [EOL]                     } [EOL]                 } [EOL]                 return; [EOL]             } [EOL]         } [EOL]         int offset = 0; [EOL]         boolean offsetSet = false; [EOL]         switch(field) { [EOL]             case DateUtils.SEMI_MONTH: [EOL]                 if (aField[0] == Calendar.DATE) { [EOL]                     offset = val.get(Calendar.DATE) - 1; [EOL]                     if (offset >= 15) { [EOL]                         offset -= 15; [EOL]                     } [EOL]                     roundUp = offset > 7; [EOL]                     offsetSet = true; [EOL]                 } [EOL]                 break; [EOL]             case Calendar.AM_PM: [EOL]                 if (aField[0] == Calendar.HOUR_OF_DAY) { [EOL]                     offset = val.get(Calendar.HOUR_OF_DAY); [EOL]                     if (offset >= 12) { [EOL]                         offset -= 12; [EOL]                     } [EOL]                     roundUp = offset >= 6; [EOL]                     offsetSet = true; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         if (!offsetSet) { [EOL]             final int min = val.getActualMinimum(aField[0]); [EOL]             final int max = val.getActualMaximum(aField[0]); [EOL]             offset = val.get(aField[0]) - min; [EOL]             roundUp = offset > ((max - min) / 2); [EOL]         } [EOL]         if (offset != 0) { [EOL]             val.set(aField[0], val.get(aField[0]) - offset); [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The field " + field + " is not supported"); [EOL] } 
 [LINE] if (offset != 0) { [LINE] private static void modify(final Calendar val, final int field, final int modType) { [EOL]     if (val.get(Calendar.YEAR) > 280000000) { [EOL]         throw new ArithmeticException("Calendar value too large for accurate calculations"); [EOL]     } [EOL]     if (field == Calendar.MILLISECOND) { [EOL]         return; [EOL]     } [EOL]     final Date date = val.getTime(); [EOL]     long time = date.getTime(); [EOL]     boolean done = false; [EOL]     final int millisecs = val.get(Calendar.MILLISECOND); [EOL]     if (MODIFY_TRUNCATE == modType || millisecs < 500) { [EOL]         time = time - millisecs; [EOL]     } [EOL]     if (field == Calendar.SECOND) { [EOL]         done = true; [EOL]     } [EOL]     final int seconds = val.get(Calendar.SECOND); [EOL]     if (!done && (MODIFY_TRUNCATE == modType || seconds < 30)) { [EOL]         time = time - (seconds * 1000L); [EOL]     } [EOL]     if (field == Calendar.MINUTE) { [EOL]         done = true; [EOL]     } [EOL]     final int minutes = val.get(Calendar.MINUTE); [EOL]     if (!done && (MODIFY_TRUNCATE == modType || minutes < 30)) { [EOL]         time = time - (minutes * 60000L); [EOL]     } [EOL]     if (date.getTime() != time) { [EOL]         date.setTime(time); [EOL]         val.setTime(date); [EOL]     } [EOL]     boolean roundUp = false; [EOL]     for (final int[] aField : fields) { [EOL]         for (final int element : aField) { [EOL]             if (element == field) { [EOL]                 if (modType == MODIFY_CEILING || (modType == MODIFY_ROUND && roundUp)) { [EOL]                     if (field == DateUtils.SEMI_MONTH) { [EOL]                         if (val.get(Calendar.DATE) == 1) { [EOL]                             val.add(Calendar.DATE, 15); [EOL]                         } else { [EOL]                             val.add(Calendar.DATE, -15); [EOL]                             val.add(Calendar.MONTH, 1); [EOL]                         } [EOL]                     } else if (field == Calendar.AM_PM) { [EOL]                         if (val.get(Calendar.HOUR_OF_DAY) == 0) { [EOL]                             val.add(Calendar.HOUR_OF_DAY, 12); [EOL]                         } else { [EOL]                             val.add(Calendar.HOUR_OF_DAY, -12); [EOL]                             val.add(Calendar.DATE, 1); [EOL]                         } [EOL]                     } else { [EOL]                         val.add(aField[0], 1); [EOL]                     } [EOL]                 } [EOL]                 return; [EOL]             } [EOL]         } [EOL]         int offset = 0; [EOL]         boolean offsetSet = false; [EOL]         switch(field) { [EOL]             case DateUtils.SEMI_MONTH: [EOL]                 if (aField[0] == Calendar.DATE) { [EOL]                     offset = val.get(Calendar.DATE) - 1; [EOL]                     if (offset >= 15) { [EOL]                         offset -= 15; [EOL]                     } [EOL]                     roundUp = offset > 7; [EOL]                     offsetSet = true; [EOL]                 } [EOL]                 break; [EOL]             case Calendar.AM_PM: [EOL]                 if (aField[0] == Calendar.HOUR_OF_DAY) { [EOL]                     offset = val.get(Calendar.HOUR_OF_DAY); [EOL]                     if (offset >= 12) { [EOL]                         offset -= 12; [EOL]                     } [EOL]                     roundUp = offset >= 6; [EOL]                     offsetSet = true; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         if (!offsetSet) { [EOL]             final int min = val.getActualMinimum(aField[0]); [EOL]             final int max = val.getActualMaximum(aField[0]); [EOL]             offset = val.get(aField[0]) - min; [EOL]             roundUp = offset > ((max - min) / 2); [EOL]         } [EOL]         if (offset != 0) { [EOL]             val.set(aField[0], val.get(aField[0]) - offset); [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The field " + field + " is not supported"); [EOL] } 
 [LINE] val.set(aField[0], val.get(aField[0]) - offset); [LINE] private static void modify(final Calendar val, final int field, final int modType) { [EOL]     if (val.get(Calendar.YEAR) > 280000000) { [EOL]         throw new ArithmeticException("Calendar value too large for accurate calculations"); [EOL]     } [EOL]     if (field == Calendar.MILLISECOND) { [EOL]         return; [EOL]     } [EOL]     final Date date = val.getTime(); [EOL]     long time = date.getTime(); [EOL]     boolean done = false; [EOL]     final int millisecs = val.get(Calendar.MILLISECOND); [EOL]     if (MODIFY_TRUNCATE == modType || millisecs < 500) { [EOL]         time = time - millisecs; [EOL]     } [EOL]     if (field == Calendar.SECOND) { [EOL]         done = true; [EOL]     } [EOL]     final int seconds = val.get(Calendar.SECOND); [EOL]     if (!done && (MODIFY_TRUNCATE == modType || seconds < 30)) { [EOL]         time = time - (seconds * 1000L); [EOL]     } [EOL]     if (field == Calendar.MINUTE) { [EOL]         done = true; [EOL]     } [EOL]     final int minutes = val.get(Calendar.MINUTE); [EOL]     if (!done && (MODIFY_TRUNCATE == modType || minutes < 30)) { [EOL]         time = time - (minutes * 60000L); [EOL]     } [EOL]     if (date.getTime() != time) { [EOL]         date.setTime(time); [EOL]         val.setTime(date); [EOL]     } [EOL]     boolean roundUp = false; [EOL]     for (final int[] aField : fields) { [EOL]         for (final int element : aField) { [EOL]             if (element == field) { [EOL]                 if (modType == MODIFY_CEILING || (modType == MODIFY_ROUND && roundUp)) { [EOL]                     if (field == DateUtils.SEMI_MONTH) { [EOL]                         if (val.get(Calendar.DATE) == 1) { [EOL]                             val.add(Calendar.DATE, 15); [EOL]                         } else { [EOL]                             val.add(Calendar.DATE, -15); [EOL]                             val.add(Calendar.MONTH, 1); [EOL]                         } [EOL]                     } else if (field == Calendar.AM_PM) { [EOL]                         if (val.get(Calendar.HOUR_OF_DAY) == 0) { [EOL]                             val.add(Calendar.HOUR_OF_DAY, 12); [EOL]                         } else { [EOL]                             val.add(Calendar.HOUR_OF_DAY, -12); [EOL]                             val.add(Calendar.DATE, 1); [EOL]                         } [EOL]                     } else { [EOL]                         val.add(aField[0], 1); [EOL]                     } [EOL]                 } [EOL]                 return; [EOL]             } [EOL]         } [EOL]         int offset = 0; [EOL]         boolean offsetSet = false; [EOL]         switch(field) { [EOL]             case DateUtils.SEMI_MONTH: [EOL]                 if (aField[0] == Calendar.DATE) { [EOL]                     offset = val.get(Calendar.DATE) - 1; [EOL]                     if (offset >= 15) { [EOL]                         offset -= 15; [EOL]                     } [EOL]                     roundUp = offset > 7; [EOL]                     offsetSet = true; [EOL]                 } [EOL]                 break; [EOL]             case Calendar.AM_PM: [EOL]                 if (aField[0] == Calendar.HOUR_OF_DAY) { [EOL]                     offset = val.get(Calendar.HOUR_OF_DAY); [EOL]                     if (offset >= 12) { [EOL]                         offset -= 12; [EOL]                     } [EOL]                     roundUp = offset >= 6; [EOL]                     offsetSet = true; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         if (!offsetSet) { [EOL]             final int min = val.getActualMinimum(aField[0]); [EOL]             final int max = val.getActualMaximum(aField[0]); [EOL]             offset = val.get(aField[0]) - min; [EOL]             roundUp = offset > ((max - min) / 2); [EOL]         } [EOL]         if (offset != 0) { [EOL]             val.set(aField[0], val.get(aField[0]) - offset); [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The field " + field + " is not supported"); [EOL] } 
 [LINE] int startCutoff = Calendar.SUNDAY; [LINE] public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle) { [EOL]     if (focus == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     Calendar start = null; [EOL]     Calendar end = null; [EOL]     int startCutoff = Calendar.SUNDAY; [EOL]     int endCutoff = Calendar.SATURDAY; [EOL]     switch(rangeStyle) { [EOL]         case RANGE_MONTH_SUNDAY: [EOL]         case RANGE_MONTH_MONDAY: [EOL]             start = truncate(focus, Calendar.MONTH); [EOL]             end = (Calendar) start.clone(); [EOL]             end.add(Calendar.MONTH, 1); [EOL]             end.add(Calendar.DATE, -1); [EOL]             if (rangeStyle == RANGE_MONTH_MONDAY) { [EOL]                 startCutoff = Calendar.MONDAY; [EOL]                 endCutoff = Calendar.SUNDAY; [EOL]             } [EOL]             break; [EOL]         case RANGE_WEEK_SUNDAY: [EOL]         case RANGE_WEEK_MONDAY: [EOL]         case RANGE_WEEK_RELATIVE: [EOL]         case RANGE_WEEK_CENTER: [EOL]             start = truncate(focus, Calendar.DATE); [EOL]             end = truncate(focus, Calendar.DATE); [EOL]             switch(rangeStyle) { [EOL]                 case RANGE_WEEK_SUNDAY: [EOL]                     break; [EOL]                 case RANGE_WEEK_MONDAY: [EOL]                     startCutoff = Calendar.MONDAY; [EOL]                     endCutoff = Calendar.SUNDAY; [EOL]                     break; [EOL]                 case RANGE_WEEK_RELATIVE: [EOL]                     startCutoff = focus.get(Calendar.DAY_OF_WEEK); [EOL]                     endCutoff = startCutoff - 1; [EOL]                     break; [EOL]                 case RANGE_WEEK_CENTER: [EOL]                     startCutoff = focus.get(Calendar.DAY_OF_WEEK) - 3; [EOL]                     endCutoff = focus.get(Calendar.DAY_OF_WEEK) + 3; [EOL]                     break; [EOL]             } [EOL]             break; [EOL]         default: [EOL]             throw new IllegalArgumentException("The range style " + rangeStyle + " is not valid."); [EOL]     } [EOL]     if (startCutoff < Calendar.SUNDAY) { [EOL]         startCutoff += 7; [EOL]     } [EOL]     if (startCutoff > Calendar.SATURDAY) { [EOL]         startCutoff -= 7; [EOL]     } [EOL]     if (endCutoff < Calendar.SUNDAY) { [EOL]         endCutoff += 7; [EOL]     } [EOL]     if (endCutoff > Calendar.SATURDAY) { [EOL]         endCutoff -= 7; [EOL]     } [EOL]     while (start.get(Calendar.DAY_OF_WEEK) != startCutoff) { [EOL]         start.add(Calendar.DATE, -1); [EOL]     } [EOL]     while (end.get(Calendar.DAY_OF_WEEK) != endCutoff) { [EOL]         end.add(Calendar.DATE, 1); [EOL]     } [EOL]     return new DateIterator(start, end); [EOL] } 
 [LINE] start = truncate(focus, Calendar.MONTH); [LINE] public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle) { [EOL]     if (focus == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     Calendar start = null; [EOL]     Calendar end = null; [EOL]     int startCutoff = Calendar.SUNDAY; [EOL]     int endCutoff = Calendar.SATURDAY; [EOL]     switch(rangeStyle) { [EOL]         case RANGE_MONTH_SUNDAY: [EOL]         case RANGE_MONTH_MONDAY: [EOL]             start = truncate(focus, Calendar.MONTH); [EOL]             end = (Calendar) start.clone(); [EOL]             end.add(Calendar.MONTH, 1); [EOL]             end.add(Calendar.DATE, -1); [EOL]             if (rangeStyle == RANGE_MONTH_MONDAY) { [EOL]                 startCutoff = Calendar.MONDAY; [EOL]                 endCutoff = Calendar.SUNDAY; [EOL]             } [EOL]             break; [EOL]         case RANGE_WEEK_SUNDAY: [EOL]         case RANGE_WEEK_MONDAY: [EOL]         case RANGE_WEEK_RELATIVE: [EOL]         case RANGE_WEEK_CENTER: [EOL]             start = truncate(focus, Calendar.DATE); [EOL]             end = truncate(focus, Calendar.DATE); [EOL]             switch(rangeStyle) { [EOL]                 case RANGE_WEEK_SUNDAY: [EOL]                     break; [EOL]                 case RANGE_WEEK_MONDAY: [EOL]                     startCutoff = Calendar.MONDAY; [EOL]                     endCutoff = Calendar.SUNDAY; [EOL]                     break; [EOL]                 case RANGE_WEEK_RELATIVE: [EOL]                     startCutoff = focus.get(Calendar.DAY_OF_WEEK); [EOL]                     endCutoff = startCutoff - 1; [EOL]                     break; [EOL]                 case RANGE_WEEK_CENTER: [EOL]                     startCutoff = focus.get(Calendar.DAY_OF_WEEK) - 3; [EOL]                     endCutoff = focus.get(Calendar.DAY_OF_WEEK) + 3; [EOL]                     break; [EOL]             } [EOL]             break; [EOL]         default: [EOL]             throw new IllegalArgumentException("The range style " + rangeStyle + " is not valid."); [EOL]     } [EOL]     if (startCutoff < Calendar.SUNDAY) { [EOL]         startCutoff += 7; [EOL]     } [EOL]     if (startCutoff > Calendar.SATURDAY) { [EOL]         startCutoff -= 7; [EOL]     } [EOL]     if (endCutoff < Calendar.SUNDAY) { [EOL]         endCutoff += 7; [EOL]     } [EOL]     if (endCutoff > Calendar.SATURDAY) { [EOL]         endCutoff -= 7; [EOL]     } [EOL]     while (start.get(Calendar.DAY_OF_WEEK) != startCutoff) { [EOL]         start.add(Calendar.DATE, -1); [EOL]     } [EOL]     while (end.get(Calendar.DAY_OF_WEEK) != endCutoff) { [EOL]         end.add(Calendar.DATE, 1); [EOL]     } [EOL]     return new DateIterator(start, end); [EOL] } 
 [LINE] end = (Calendar) start.clone(); [LINE] public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle) { [EOL]     if (focus == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     Calendar start = null; [EOL]     Calendar end = null; [EOL]     int startCutoff = Calendar.SUNDAY; [EOL]     int endCutoff = Calendar.SATURDAY; [EOL]     switch(rangeStyle) { [EOL]         case RANGE_MONTH_SUNDAY: [EOL]         case RANGE_MONTH_MONDAY: [EOL]             start = truncate(focus, Calendar.MONTH); [EOL]             end = (Calendar) start.clone(); [EOL]             end.add(Calendar.MONTH, 1); [EOL]             end.add(Calendar.DATE, -1); [EOL]             if (rangeStyle == RANGE_MONTH_MONDAY) { [EOL]                 startCutoff = Calendar.MONDAY; [EOL]                 endCutoff = Calendar.SUNDAY; [EOL]             } [EOL]             break; [EOL]         case RANGE_WEEK_SUNDAY: [EOL]         case RANGE_WEEK_MONDAY: [EOL]         case RANGE_WEEK_RELATIVE: [EOL]         case RANGE_WEEK_CENTER: [EOL]             start = truncate(focus, Calendar.DATE); [EOL]             end = truncate(focus, Calendar.DATE); [EOL]             switch(rangeStyle) { [EOL]                 case RANGE_WEEK_SUNDAY: [EOL]                     break; [EOL]                 case RANGE_WEEK_MONDAY: [EOL]                     startCutoff = Calendar.MONDAY; [EOL]                     endCutoff = Calendar.SUNDAY; [EOL]                     break; [EOL]                 case RANGE_WEEK_RELATIVE: [EOL]                     startCutoff = focus.get(Calendar.DAY_OF_WEEK); [EOL]                     endCutoff = startCutoff - 1; [EOL]                     break; [EOL]                 case RANGE_WEEK_CENTER: [EOL]                     startCutoff = focus.get(Calendar.DAY_OF_WEEK) - 3; [EOL]                     endCutoff = focus.get(Calendar.DAY_OF_WEEK) + 3; [EOL]                     break; [EOL]             } [EOL]             break; [EOL]         default: [EOL]             throw new IllegalArgumentException("The range style " + rangeStyle + " is not valid."); [EOL]     } [EOL]     if (startCutoff < Calendar.SUNDAY) { [EOL]         startCutoff += 7; [EOL]     } [EOL]     if (startCutoff > Calendar.SATURDAY) { [EOL]         startCutoff -= 7; [EOL]     } [EOL]     if (endCutoff < Calendar.SUNDAY) { [EOL]         endCutoff += 7; [EOL]     } [EOL]     if (endCutoff > Calendar.SATURDAY) { [EOL]         endCutoff -= 7; [EOL]     } [EOL]     while (start.get(Calendar.DAY_OF_WEEK) != startCutoff) { [EOL]         start.add(Calendar.DATE, -1); [EOL]     } [EOL]     while (end.get(Calendar.DAY_OF_WEEK) != endCutoff) { [EOL]         end.add(Calendar.DATE, 1); [EOL]     } [EOL]     return new DateIterator(start, end); [EOL] } 
 [LINE] startCutoff = Calendar.MONDAY; [LINE] public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle) { [EOL]     if (focus == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     Calendar start = null; [EOL]     Calendar end = null; [EOL]     int startCutoff = Calendar.SUNDAY; [EOL]     int endCutoff = Calendar.SATURDAY; [EOL]     switch(rangeStyle) { [EOL]         case RANGE_MONTH_SUNDAY: [EOL]         case RANGE_MONTH_MONDAY: [EOL]             start = truncate(focus, Calendar.MONTH); [EOL]             end = (Calendar) start.clone(); [EOL]             end.add(Calendar.MONTH, 1); [EOL]             end.add(Calendar.DATE, -1); [EOL]             if (rangeStyle == RANGE_MONTH_MONDAY) { [EOL]                 startCutoff = Calendar.MONDAY; [EOL]                 endCutoff = Calendar.SUNDAY; [EOL]             } [EOL]             break; [EOL]         case RANGE_WEEK_SUNDAY: [EOL]         case RANGE_WEEK_MONDAY: [EOL]         case RANGE_WEEK_RELATIVE: [EOL]         case RANGE_WEEK_CENTER: [EOL]             start = truncate(focus, Calendar.DATE); [EOL]             end = truncate(focus, Calendar.DATE); [EOL]             switch(rangeStyle) { [EOL]                 case RANGE_WEEK_SUNDAY: [EOL]                     break; [EOL]                 case RANGE_WEEK_MONDAY: [EOL]                     startCutoff = Calendar.MONDAY; [EOL]                     endCutoff = Calendar.SUNDAY; [EOL]                     break; [EOL]                 case RANGE_WEEK_RELATIVE: [EOL]                     startCutoff = focus.get(Calendar.DAY_OF_WEEK); [EOL]                     endCutoff = startCutoff - 1; [EOL]                     break; [EOL]                 case RANGE_WEEK_CENTER: [EOL]                     startCutoff = focus.get(Calendar.DAY_OF_WEEK) - 3; [EOL]                     endCutoff = focus.get(Calendar.DAY_OF_WEEK) + 3; [EOL]                     break; [EOL]             } [EOL]             break; [EOL]         default: [EOL]             throw new IllegalArgumentException("The range style " + rangeStyle + " is not valid."); [EOL]     } [EOL]     if (startCutoff < Calendar.SUNDAY) { [EOL]         startCutoff += 7; [EOL]     } [EOL]     if (startCutoff > Calendar.SATURDAY) { [EOL]         startCutoff -= 7; [EOL]     } [EOL]     if (endCutoff < Calendar.SUNDAY) { [EOL]         endCutoff += 7; [EOL]     } [EOL]     if (endCutoff > Calendar.SATURDAY) { [EOL]         endCutoff -= 7; [EOL]     } [EOL]     while (start.get(Calendar.DAY_OF_WEEK) != startCutoff) { [EOL]         start.add(Calendar.DATE, -1); [EOL]     } [EOL]     while (end.get(Calendar.DAY_OF_WEEK) != endCutoff) { [EOL]         end.add(Calendar.DATE, 1); [EOL]     } [EOL]     return new DateIterator(start, end); [EOL] } 
 [LINE] break; [LINE] public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle) { [EOL]     if (focus == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     Calendar start = null; [EOL]     Calendar end = null; [EOL]     int startCutoff = Calendar.SUNDAY; [EOL]     int endCutoff = Calendar.SATURDAY; [EOL]     switch(rangeStyle) { [EOL]         case RANGE_MONTH_SUNDAY: [EOL]         case RANGE_MONTH_MONDAY: [EOL]             start = truncate(focus, Calendar.MONTH); [EOL]             end = (Calendar) start.clone(); [EOL]             end.add(Calendar.MONTH, 1); [EOL]             end.add(Calendar.DATE, -1); [EOL]             if (rangeStyle == RANGE_MONTH_MONDAY) { [EOL]                 startCutoff = Calendar.MONDAY; [EOL]                 endCutoff = Calendar.SUNDAY; [EOL]             } [EOL]             break; [EOL]         case RANGE_WEEK_SUNDAY: [EOL]         case RANGE_WEEK_MONDAY: [EOL]         case RANGE_WEEK_RELATIVE: [EOL]         case RANGE_WEEK_CENTER: [EOL]             start = truncate(focus, Calendar.DATE); [EOL]             end = truncate(focus, Calendar.DATE); [EOL]             switch(rangeStyle) { [EOL]                 case RANGE_WEEK_SUNDAY: [EOL]                     break; [EOL]                 case RANGE_WEEK_MONDAY: [EOL]                     startCutoff = Calendar.MONDAY; [EOL]                     endCutoff = Calendar.SUNDAY; [EOL]                     break; [EOL]                 case RANGE_WEEK_RELATIVE: [EOL]                     startCutoff = focus.get(Calendar.DAY_OF_WEEK); [EOL]                     endCutoff = startCutoff - 1; [EOL]                     break; [EOL]                 case RANGE_WEEK_CENTER: [EOL]                     startCutoff = focus.get(Calendar.DAY_OF_WEEK) - 3; [EOL]                     endCutoff = focus.get(Calendar.DAY_OF_WEEK) + 3; [EOL]                     break; [EOL]             } [EOL]             break; [EOL]         default: [EOL]             throw new IllegalArgumentException("The range style " + rangeStyle + " is not valid."); [EOL]     } [EOL]     if (startCutoff < Calendar.SUNDAY) { [EOL]         startCutoff += 7; [EOL]     } [EOL]     if (startCutoff > Calendar.SATURDAY) { [EOL]         startCutoff -= 7; [EOL]     } [EOL]     if (endCutoff < Calendar.SUNDAY) { [EOL]         endCutoff += 7; [EOL]     } [EOL]     if (endCutoff > Calendar.SATURDAY) { [EOL]         endCutoff -= 7; [EOL]     } [EOL]     while (start.get(Calendar.DAY_OF_WEEK) != startCutoff) { [EOL]         start.add(Calendar.DATE, -1); [EOL]     } [EOL]     while (end.get(Calendar.DAY_OF_WEEK) != endCutoff) { [EOL]         end.add(Calendar.DATE, 1); [EOL]     } [EOL]     return new DateIterator(start, end); [EOL] } 
 [LINE] case RANGE_WEEK_RELATIVE: [LINE] public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle) { [EOL]     if (focus == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     Calendar start = null; [EOL]     Calendar end = null; [EOL]     int startCutoff = Calendar.SUNDAY; [EOL]     int endCutoff = Calendar.SATURDAY; [EOL]     switch(rangeStyle) { [EOL]         case RANGE_MONTH_SUNDAY: [EOL]         case RANGE_MONTH_MONDAY: [EOL]             start = truncate(focus, Calendar.MONTH); [EOL]             end = (Calendar) start.clone(); [EOL]             end.add(Calendar.MONTH, 1); [EOL]             end.add(Calendar.DATE, -1); [EOL]             if (rangeStyle == RANGE_MONTH_MONDAY) { [EOL]                 startCutoff = Calendar.MONDAY; [EOL]                 endCutoff = Calendar.SUNDAY; [EOL]             } [EOL]             break; [EOL]         case RANGE_WEEK_SUNDAY: [EOL]         case RANGE_WEEK_MONDAY: [EOL]         case RANGE_WEEK_RELATIVE: [EOL]         case RANGE_WEEK_CENTER: [EOL]             start = truncate(focus, Calendar.DATE); [EOL]             end = truncate(focus, Calendar.DATE); [EOL]             switch(rangeStyle) { [EOL]                 case RANGE_WEEK_SUNDAY: [EOL]                     break; [EOL]                 case RANGE_WEEK_MONDAY: [EOL]                     startCutoff = Calendar.MONDAY; [EOL]                     endCutoff = Calendar.SUNDAY; [EOL]                     break; [EOL]                 case RANGE_WEEK_RELATIVE: [EOL]                     startCutoff = focus.get(Calendar.DAY_OF_WEEK); [EOL]                     endCutoff = startCutoff - 1; [EOL]                     break; [EOL]                 case RANGE_WEEK_CENTER: [EOL]                     startCutoff = focus.get(Calendar.DAY_OF_WEEK) - 3; [EOL]                     endCutoff = focus.get(Calendar.DAY_OF_WEEK) + 3; [EOL]                     break; [EOL]             } [EOL]             break; [EOL]         default: [EOL]             throw new IllegalArgumentException("The range style " + rangeStyle + " is not valid."); [EOL]     } [EOL]     if (startCutoff < Calendar.SUNDAY) { [EOL]         startCutoff += 7; [EOL]     } [EOL]     if (startCutoff > Calendar.SATURDAY) { [EOL]         startCutoff -= 7; [EOL]     } [EOL]     if (endCutoff < Calendar.SUNDAY) { [EOL]         endCutoff += 7; [EOL]     } [EOL]     if (endCutoff > Calendar.SATURDAY) { [EOL]         endCutoff -= 7; [EOL]     } [EOL]     while (start.get(Calendar.DAY_OF_WEEK) != startCutoff) { [EOL]         start.add(Calendar.DATE, -1); [EOL]     } [EOL]     while (end.get(Calendar.DAY_OF_WEEK) != endCutoff) { [EOL]         end.add(Calendar.DATE, 1); [EOL]     } [EOL]     return new DateIterator(start, end); [EOL] } 
 [LINE] end = truncate(focus, Calendar.DATE); [LINE] public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle) { [EOL]     if (focus == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     Calendar start = null; [EOL]     Calendar end = null; [EOL]     int startCutoff = Calendar.SUNDAY; [EOL]     int endCutoff = Calendar.SATURDAY; [EOL]     switch(rangeStyle) { [EOL]         case RANGE_MONTH_SUNDAY: [EOL]         case RANGE_MONTH_MONDAY: [EOL]             start = truncate(focus, Calendar.MONTH); [EOL]             end = (Calendar) start.clone(); [EOL]             end.add(Calendar.MONTH, 1); [EOL]             end.add(Calendar.DATE, -1); [EOL]             if (rangeStyle == RANGE_MONTH_MONDAY) { [EOL]                 startCutoff = Calendar.MONDAY; [EOL]                 endCutoff = Calendar.SUNDAY; [EOL]             } [EOL]             break; [EOL]         case RANGE_WEEK_SUNDAY: [EOL]         case RANGE_WEEK_MONDAY: [EOL]         case RANGE_WEEK_RELATIVE: [EOL]         case RANGE_WEEK_CENTER: [EOL]             start = truncate(focus, Calendar.DATE); [EOL]             end = truncate(focus, Calendar.DATE); [EOL]             switch(rangeStyle) { [EOL]                 case RANGE_WEEK_SUNDAY: [EOL]                     break; [EOL]                 case RANGE_WEEK_MONDAY: [EOL]                     startCutoff = Calendar.MONDAY; [EOL]                     endCutoff = Calendar.SUNDAY; [EOL]                     break; [EOL]                 case RANGE_WEEK_RELATIVE: [EOL]                     startCutoff = focus.get(Calendar.DAY_OF_WEEK); [EOL]                     endCutoff = startCutoff - 1; [EOL]                     break; [EOL]                 case RANGE_WEEK_CENTER: [EOL]                     startCutoff = focus.get(Calendar.DAY_OF_WEEK) - 3; [EOL]                     endCutoff = focus.get(Calendar.DAY_OF_WEEK) + 3; [EOL]                     break; [EOL]             } [EOL]             break; [EOL]         default: [EOL]             throw new IllegalArgumentException("The range style " + rangeStyle + " is not valid."); [EOL]     } [EOL]     if (startCutoff < Calendar.SUNDAY) { [EOL]         startCutoff += 7; [EOL]     } [EOL]     if (startCutoff > Calendar.SATURDAY) { [EOL]         startCutoff -= 7; [EOL]     } [EOL]     if (endCutoff < Calendar.SUNDAY) { [EOL]         endCutoff += 7; [EOL]     } [EOL]     if (endCutoff > Calendar.SATURDAY) { [EOL]         endCutoff -= 7; [EOL]     } [EOL]     while (start.get(Calendar.DAY_OF_WEEK) != startCutoff) { [EOL]         start.add(Calendar.DATE, -1); [EOL]     } [EOL]     while (end.get(Calendar.DAY_OF_WEEK) != endCutoff) { [EOL]         end.add(Calendar.DATE, 1); [EOL]     } [EOL]     return new DateIterator(start, end); [EOL] } 
 [LINE] case RANGE_WEEK_RELATIVE: [LINE] public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle) { [EOL]     if (focus == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     Calendar start = null; [EOL]     Calendar end = null; [EOL]     int startCutoff = Calendar.SUNDAY; [EOL]     int endCutoff = Calendar.SATURDAY; [EOL]     switch(rangeStyle) { [EOL]         case RANGE_MONTH_SUNDAY: [EOL]         case RANGE_MONTH_MONDAY: [EOL]             start = truncate(focus, Calendar.MONTH); [EOL]             end = (Calendar) start.clone(); [EOL]             end.add(Calendar.MONTH, 1); [EOL]             end.add(Calendar.DATE, -1); [EOL]             if (rangeStyle == RANGE_MONTH_MONDAY) { [EOL]                 startCutoff = Calendar.MONDAY; [EOL]                 endCutoff = Calendar.SUNDAY; [EOL]             } [EOL]             break; [EOL]         case RANGE_WEEK_SUNDAY: [EOL]         case RANGE_WEEK_MONDAY: [EOL]         case RANGE_WEEK_RELATIVE: [EOL]         case RANGE_WEEK_CENTER: [EOL]             start = truncate(focus, Calendar.DATE); [EOL]             end = truncate(focus, Calendar.DATE); [EOL]             switch(rangeStyle) { [EOL]                 case RANGE_WEEK_SUNDAY: [EOL]                     break; [EOL]                 case RANGE_WEEK_MONDAY: [EOL]                     startCutoff = Calendar.MONDAY; [EOL]                     endCutoff = Calendar.SUNDAY; [EOL]                     break; [EOL]                 case RANGE_WEEK_RELATIVE: [EOL]                     startCutoff = focus.get(Calendar.DAY_OF_WEEK); [EOL]                     endCutoff = startCutoff - 1; [EOL]                     break; [EOL]                 case RANGE_WEEK_CENTER: [EOL]                     startCutoff = focus.get(Calendar.DAY_OF_WEEK) - 3; [EOL]                     endCutoff = focus.get(Calendar.DAY_OF_WEEK) + 3; [EOL]                     break; [EOL]             } [EOL]             break; [EOL]         default: [EOL]             throw new IllegalArgumentException("The range style " + rangeStyle + " is not valid."); [EOL]     } [EOL]     if (startCutoff < Calendar.SUNDAY) { [EOL]         startCutoff += 7; [EOL]     } [EOL]     if (startCutoff > Calendar.SATURDAY) { [EOL]         startCutoff -= 7; [EOL]     } [EOL]     if (endCutoff < Calendar.SUNDAY) { [EOL]         endCutoff += 7; [EOL]     } [EOL]     if (endCutoff > Calendar.SATURDAY) { [EOL]         endCutoff -= 7; [EOL]     } [EOL]     while (start.get(Calendar.DAY_OF_WEEK) != startCutoff) { [EOL]         start.add(Calendar.DATE, -1); [EOL]     } [EOL]     while (end.get(Calendar.DAY_OF_WEEK) != endCutoff) { [EOL]         end.add(Calendar.DATE, 1); [EOL]     } [EOL]     return new DateIterator(start, end); [EOL] } 
 [LINE] startCutoff = focus.get(Calendar.DAY_OF_WEEK) - 3; [LINE] public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle) { [EOL]     if (focus == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     Calendar start = null; [EOL]     Calendar end = null; [EOL]     int startCutoff = Calendar.SUNDAY; [EOL]     int endCutoff = Calendar.SATURDAY; [EOL]     switch(rangeStyle) { [EOL]         case RANGE_MONTH_SUNDAY: [EOL]         case RANGE_MONTH_MONDAY: [EOL]             start = truncate(focus, Calendar.MONTH); [EOL]             end = (Calendar) start.clone(); [EOL]             end.add(Calendar.MONTH, 1); [EOL]             end.add(Calendar.DATE, -1); [EOL]             if (rangeStyle == RANGE_MONTH_MONDAY) { [EOL]                 startCutoff = Calendar.MONDAY; [EOL]                 endCutoff = Calendar.SUNDAY; [EOL]             } [EOL]             break; [EOL]         case RANGE_WEEK_SUNDAY: [EOL]         case RANGE_WEEK_MONDAY: [EOL]         case RANGE_WEEK_RELATIVE: [EOL]         case RANGE_WEEK_CENTER: [EOL]             start = truncate(focus, Calendar.DATE); [EOL]             end = truncate(focus, Calendar.DATE); [EOL]             switch(rangeStyle) { [EOL]                 case RANGE_WEEK_SUNDAY: [EOL]                     break; [EOL]                 case RANGE_WEEK_MONDAY: [EOL]                     startCutoff = Calendar.MONDAY; [EOL]                     endCutoff = Calendar.SUNDAY; [EOL]                     break; [EOL]                 case RANGE_WEEK_RELATIVE: [EOL]                     startCutoff = focus.get(Calendar.DAY_OF_WEEK); [EOL]                     endCutoff = startCutoff - 1; [EOL]                     break; [EOL]                 case RANGE_WEEK_CENTER: [EOL]                     startCutoff = focus.get(Calendar.DAY_OF_WEEK) - 3; [EOL]                     endCutoff = focus.get(Calendar.DAY_OF_WEEK) + 3; [EOL]                     break; [EOL]             } [EOL]             break; [EOL]         default: [EOL]             throw new IllegalArgumentException("The range style " + rangeStyle + " is not valid."); [EOL]     } [EOL]     if (startCutoff < Calendar.SUNDAY) { [EOL]         startCutoff += 7; [EOL]     } [EOL]     if (startCutoff > Calendar.SATURDAY) { [EOL]         startCutoff -= 7; [EOL]     } [EOL]     if (endCutoff < Calendar.SUNDAY) { [EOL]         endCutoff += 7; [EOL]     } [EOL]     if (endCutoff > Calendar.SATURDAY) { [EOL]         endCutoff -= 7; [EOL]     } [EOL]     while (start.get(Calendar.DAY_OF_WEEK) != startCutoff) { [EOL]         start.add(Calendar.DATE, -1); [EOL]     } [EOL]     while (end.get(Calendar.DAY_OF_WEEK) != endCutoff) { [EOL]         end.add(Calendar.DATE, 1); [EOL]     } [EOL]     return new DateIterator(start, end); [EOL] } 
 [LINE] throw new IllegalArgumentException("The range style " + rangeStyle + " is not valid."); [LINE] public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle) { [EOL]     if (focus == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     Calendar start = null; [EOL]     Calendar end = null; [EOL]     int startCutoff = Calendar.SUNDAY; [EOL]     int endCutoff = Calendar.SATURDAY; [EOL]     switch(rangeStyle) { [EOL]         case RANGE_MONTH_SUNDAY: [EOL]         case RANGE_MONTH_MONDAY: [EOL]             start = truncate(focus, Calendar.MONTH); [EOL]             end = (Calendar) start.clone(); [EOL]             end.add(Calendar.MONTH, 1); [EOL]             end.add(Calendar.DATE, -1); [EOL]             if (rangeStyle == RANGE_MONTH_MONDAY) { [EOL]                 startCutoff = Calendar.MONDAY; [EOL]                 endCutoff = Calendar.SUNDAY; [EOL]             } [EOL]             break; [EOL]         case RANGE_WEEK_SUNDAY: [EOL]         case RANGE_WEEK_MONDAY: [EOL]         case RANGE_WEEK_RELATIVE: [EOL]         case RANGE_WEEK_CENTER: [EOL]             start = truncate(focus, Calendar.DATE); [EOL]             end = truncate(focus, Calendar.DATE); [EOL]             switch(rangeStyle) { [EOL]                 case RANGE_WEEK_SUNDAY: [EOL]                     break; [EOL]                 case RANGE_WEEK_MONDAY: [EOL]                     startCutoff = Calendar.MONDAY; [EOL]                     endCutoff = Calendar.SUNDAY; [EOL]                     break; [EOL]                 case RANGE_WEEK_RELATIVE: [EOL]                     startCutoff = focus.get(Calendar.DAY_OF_WEEK); [EOL]                     endCutoff = startCutoff - 1; [EOL]                     break; [EOL]                 case RANGE_WEEK_CENTER: [EOL]                     startCutoff = focus.get(Calendar.DAY_OF_WEEK) - 3; [EOL]                     endCutoff = focus.get(Calendar.DAY_OF_WEEK) + 3; [EOL]                     break; [EOL]             } [EOL]             break; [EOL]         default: [EOL]             throw new IllegalArgumentException("The range style " + rangeStyle + " is not valid."); [EOL]     } [EOL]     if (startCutoff < Calendar.SUNDAY) { [EOL]         startCutoff += 7; [EOL]     } [EOL]     if (startCutoff > Calendar.SATURDAY) { [EOL]         startCutoff -= 7; [EOL]     } [EOL]     if (endCutoff < Calendar.SUNDAY) { [EOL]         endCutoff += 7; [EOL]     } [EOL]     if (endCutoff > Calendar.SATURDAY) { [EOL]         endCutoff -= 7; [EOL]     } [EOL]     while (start.get(Calendar.DAY_OF_WEEK) != startCutoff) { [EOL]         start.add(Calendar.DATE, -1); [EOL]     } [EOL]     while (end.get(Calendar.DAY_OF_WEEK) != endCutoff) { [EOL]         end.add(Calendar.DATE, 1); [EOL]     } [EOL]     return new DateIterator(start, end); [EOL] } 
 [LINE] if (startCutoff > Calendar.SATURDAY) { [LINE] public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle) { [EOL]     if (focus == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     Calendar start = null; [EOL]     Calendar end = null; [EOL]     int startCutoff = Calendar.SUNDAY; [EOL]     int endCutoff = Calendar.SATURDAY; [EOL]     switch(rangeStyle) { [EOL]         case RANGE_MONTH_SUNDAY: [EOL]         case RANGE_MONTH_MONDAY: [EOL]             start = truncate(focus, Calendar.MONTH); [EOL]             end = (Calendar) start.clone(); [EOL]             end.add(Calendar.MONTH, 1); [EOL]             end.add(Calendar.DATE, -1); [EOL]             if (rangeStyle == RANGE_MONTH_MONDAY) { [EOL]                 startCutoff = Calendar.MONDAY; [EOL]                 endCutoff = Calendar.SUNDAY; [EOL]             } [EOL]             break; [EOL]         case RANGE_WEEK_SUNDAY: [EOL]         case RANGE_WEEK_MONDAY: [EOL]         case RANGE_WEEK_RELATIVE: [EOL]         case RANGE_WEEK_CENTER: [EOL]             start = truncate(focus, Calendar.DATE); [EOL]             end = truncate(focus, Calendar.DATE); [EOL]             switch(rangeStyle) { [EOL]                 case RANGE_WEEK_SUNDAY: [EOL]                     break; [EOL]                 case RANGE_WEEK_MONDAY: [EOL]                     startCutoff = Calendar.MONDAY; [EOL]                     endCutoff = Calendar.SUNDAY; [EOL]                     break; [EOL]                 case RANGE_WEEK_RELATIVE: [EOL]                     startCutoff = focus.get(Calendar.DAY_OF_WEEK); [EOL]                     endCutoff = startCutoff - 1; [EOL]                     break; [EOL]                 case RANGE_WEEK_CENTER: [EOL]                     startCutoff = focus.get(Calendar.DAY_OF_WEEK) - 3; [EOL]                     endCutoff = focus.get(Calendar.DAY_OF_WEEK) + 3; [EOL]                     break; [EOL]             } [EOL]             break; [EOL]         default: [EOL]             throw new IllegalArgumentException("The range style " + rangeStyle + " is not valid."); [EOL]     } [EOL]     if (startCutoff < Calendar.SUNDAY) { [EOL]         startCutoff += 7; [EOL]     } [EOL]     if (startCutoff > Calendar.SATURDAY) { [EOL]         startCutoff -= 7; [EOL]     } [EOL]     if (endCutoff < Calendar.SUNDAY) { [EOL]         endCutoff += 7; [EOL]     } [EOL]     if (endCutoff > Calendar.SATURDAY) { [EOL]         endCutoff -= 7; [EOL]     } [EOL]     while (start.get(Calendar.DAY_OF_WEEK) != startCutoff) { [EOL]         start.add(Calendar.DATE, -1); [EOL]     } [EOL]     while (end.get(Calendar.DAY_OF_WEEK) != endCutoff) { [EOL]         end.add(Calendar.DATE, 1); [EOL]     } [EOL]     return new DateIterator(start, end); [EOL] } 
 [LINE] endCutoff -= 7; [LINE] public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle) { [EOL]     if (focus == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     Calendar start = null; [EOL]     Calendar end = null; [EOL]     int startCutoff = Calendar.SUNDAY; [EOL]     int endCutoff = Calendar.SATURDAY; [EOL]     switch(rangeStyle) { [EOL]         case RANGE_MONTH_SUNDAY: [EOL]         case RANGE_MONTH_MONDAY: [EOL]             start = truncate(focus, Calendar.MONTH); [EOL]             end = (Calendar) start.clone(); [EOL]             end.add(Calendar.MONTH, 1); [EOL]             end.add(Calendar.DATE, -1); [EOL]             if (rangeStyle == RANGE_MONTH_MONDAY) { [EOL]                 startCutoff = Calendar.MONDAY; [EOL]                 endCutoff = Calendar.SUNDAY; [EOL]             } [EOL]             break; [EOL]         case RANGE_WEEK_SUNDAY: [EOL]         case RANGE_WEEK_MONDAY: [EOL]         case RANGE_WEEK_RELATIVE: [EOL]         case RANGE_WEEK_CENTER: [EOL]             start = truncate(focus, Calendar.DATE); [EOL]             end = truncate(focus, Calendar.DATE); [EOL]             switch(rangeStyle) { [EOL]                 case RANGE_WEEK_SUNDAY: [EOL]                     break; [EOL]                 case RANGE_WEEK_MONDAY: [EOL]                     startCutoff = Calendar.MONDAY; [EOL]                     endCutoff = Calendar.SUNDAY; [EOL]                     break; [EOL]                 case RANGE_WEEK_RELATIVE: [EOL]                     startCutoff = focus.get(Calendar.DAY_OF_WEEK); [EOL]                     endCutoff = startCutoff - 1; [EOL]                     break; [EOL]                 case RANGE_WEEK_CENTER: [EOL]                     startCutoff = focus.get(Calendar.DAY_OF_WEEK) - 3; [EOL]                     endCutoff = focus.get(Calendar.DAY_OF_WEEK) + 3; [EOL]                     break; [EOL]             } [EOL]             break; [EOL]         default: [EOL]             throw new IllegalArgumentException("The range style " + rangeStyle + " is not valid."); [EOL]     } [EOL]     if (startCutoff < Calendar.SUNDAY) { [EOL]         startCutoff += 7; [EOL]     } [EOL]     if (startCutoff > Calendar.SATURDAY) { [EOL]         startCutoff -= 7; [EOL]     } [EOL]     if (endCutoff < Calendar.SUNDAY) { [EOL]         endCutoff += 7; [EOL]     } [EOL]     if (endCutoff > Calendar.SATURDAY) { [EOL]         endCutoff -= 7; [EOL]     } [EOL]     while (start.get(Calendar.DAY_OF_WEEK) != startCutoff) { [EOL]         start.add(Calendar.DATE, -1); [EOL]     } [EOL]     while (end.get(Calendar.DAY_OF_WEEK) != endCutoff) { [EOL]         end.add(Calendar.DATE, 1); [EOL]     } [EOL]     return new DateIterator(start, end); [EOL] } 
 [LINE] while (start.get(Calendar.DAY_OF_WEEK) != startCutoff) { [LINE] public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle) { [EOL]     if (focus == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     Calendar start = null; [EOL]     Calendar end = null; [EOL]     int startCutoff = Calendar.SUNDAY; [EOL]     int endCutoff = Calendar.SATURDAY; [EOL]     switch(rangeStyle) { [EOL]         case RANGE_MONTH_SUNDAY: [EOL]         case RANGE_MONTH_MONDAY: [EOL]             start = truncate(focus, Calendar.MONTH); [EOL]             end = (Calendar) start.clone(); [EOL]             end.add(Calendar.MONTH, 1); [EOL]             end.add(Calendar.DATE, -1); [EOL]             if (rangeStyle == RANGE_MONTH_MONDAY) { [EOL]                 startCutoff = Calendar.MONDAY; [EOL]                 endCutoff = Calendar.SUNDAY; [EOL]             } [EOL]             break; [EOL]         case RANGE_WEEK_SUNDAY: [EOL]         case RANGE_WEEK_MONDAY: [EOL]         case RANGE_WEEK_RELATIVE: [EOL]         case RANGE_WEEK_CENTER: [EOL]             start = truncate(focus, Calendar.DATE); [EOL]             end = truncate(focus, Calendar.DATE); [EOL]             switch(rangeStyle) { [EOL]                 case RANGE_WEEK_SUNDAY: [EOL]                     break; [EOL]                 case RANGE_WEEK_MONDAY: [EOL]                     startCutoff = Calendar.MONDAY; [EOL]                     endCutoff = Calendar.SUNDAY; [EOL]                     break; [EOL]                 case RANGE_WEEK_RELATIVE: [EOL]                     startCutoff = focus.get(Calendar.DAY_OF_WEEK); [EOL]                     endCutoff = startCutoff - 1; [EOL]                     break; [EOL]                 case RANGE_WEEK_CENTER: [EOL]                     startCutoff = focus.get(Calendar.DAY_OF_WEEK) - 3; [EOL]                     endCutoff = focus.get(Calendar.DAY_OF_WEEK) + 3; [EOL]                     break; [EOL]             } [EOL]             break; [EOL]         default: [EOL]             throw new IllegalArgumentException("The range style " + rangeStyle + " is not valid."); [EOL]     } [EOL]     if (startCutoff < Calendar.SUNDAY) { [EOL]         startCutoff += 7; [EOL]     } [EOL]     if (startCutoff > Calendar.SATURDAY) { [EOL]         startCutoff -= 7; [EOL]     } [EOL]     if (endCutoff < Calendar.SUNDAY) { [EOL]         endCutoff += 7; [EOL]     } [EOL]     if (endCutoff > Calendar.SATURDAY) { [EOL]         endCutoff -= 7; [EOL]     } [EOL]     while (start.get(Calendar.DAY_OF_WEEK) != startCutoff) { [EOL]         start.add(Calendar.DATE, -1); [EOL]     } [EOL]     while (end.get(Calendar.DAY_OF_WEEK) != endCutoff) { [EOL]         end.add(Calendar.DATE, 1); [EOL]     } [EOL]     return new DateIterator(start, end); [EOL] } 
 [LINE] start.add(Calendar.DATE, -1); [LINE] public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle) { [EOL]     if (focus == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     Calendar start = null; [EOL]     Calendar end = null; [EOL]     int startCutoff = Calendar.SUNDAY; [EOL]     int endCutoff = Calendar.SATURDAY; [EOL]     switch(rangeStyle) { [EOL]         case RANGE_MONTH_SUNDAY: [EOL]         case RANGE_MONTH_MONDAY: [EOL]             start = truncate(focus, Calendar.MONTH); [EOL]             end = (Calendar) start.clone(); [EOL]             end.add(Calendar.MONTH, 1); [EOL]             end.add(Calendar.DATE, -1); [EOL]             if (rangeStyle == RANGE_MONTH_MONDAY) { [EOL]                 startCutoff = Calendar.MONDAY; [EOL]                 endCutoff = Calendar.SUNDAY; [EOL]             } [EOL]             break; [EOL]         case RANGE_WEEK_SUNDAY: [EOL]         case RANGE_WEEK_MONDAY: [EOL]         case RANGE_WEEK_RELATIVE: [EOL]         case RANGE_WEEK_CENTER: [EOL]             start = truncate(focus, Calendar.DATE); [EOL]             end = truncate(focus, Calendar.DATE); [EOL]             switch(rangeStyle) { [EOL]                 case RANGE_WEEK_SUNDAY: [EOL]                     break; [EOL]                 case RANGE_WEEK_MONDAY: [EOL]                     startCutoff = Calendar.MONDAY; [EOL]                     endCutoff = Calendar.SUNDAY; [EOL]                     break; [EOL]                 case RANGE_WEEK_RELATIVE: [EOL]                     startCutoff = focus.get(Calendar.DAY_OF_WEEK); [EOL]                     endCutoff = startCutoff - 1; [EOL]                     break; [EOL]                 case RANGE_WEEK_CENTER: [EOL]                     startCutoff = focus.get(Calendar.DAY_OF_WEEK) - 3; [EOL]                     endCutoff = focus.get(Calendar.DAY_OF_WEEK) + 3; [EOL]                     break; [EOL]             } [EOL]             break; [EOL]         default: [EOL]             throw new IllegalArgumentException("The range style " + rangeStyle + " is not valid."); [EOL]     } [EOL]     if (startCutoff < Calendar.SUNDAY) { [EOL]         startCutoff += 7; [EOL]     } [EOL]     if (startCutoff > Calendar.SATURDAY) { [EOL]         startCutoff -= 7; [EOL]     } [EOL]     if (endCutoff < Calendar.SUNDAY) { [EOL]         endCutoff += 7; [EOL]     } [EOL]     if (endCutoff > Calendar.SATURDAY) { [EOL]         endCutoff -= 7; [EOL]     } [EOL]     while (start.get(Calendar.DAY_OF_WEEK) != startCutoff) { [EOL]         start.add(Calendar.DATE, -1); [EOL]     } [EOL]     while (end.get(Calendar.DAY_OF_WEEK) != endCutoff) { [EOL]         end.add(Calendar.DATE, 1); [EOL]     } [EOL]     return new DateIterator(start, end); [EOL] } 
 [LINE] return new DateIterator(start, end); [LINE] public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle) { [EOL]     if (focus == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     Calendar start = null; [EOL]     Calendar end = null; [EOL]     int startCutoff = Calendar.SUNDAY; [EOL]     int endCutoff = Calendar.SATURDAY; [EOL]     switch(rangeStyle) { [EOL]         case RANGE_MONTH_SUNDAY: [EOL]         case RANGE_MONTH_MONDAY: [EOL]             start = truncate(focus, Calendar.MONTH); [EOL]             end = (Calendar) start.clone(); [EOL]             end.add(Calendar.MONTH, 1); [EOL]             end.add(Calendar.DATE, -1); [EOL]             if (rangeStyle == RANGE_MONTH_MONDAY) { [EOL]                 startCutoff = Calendar.MONDAY; [EOL]                 endCutoff = Calendar.SUNDAY; [EOL]             } [EOL]             break; [EOL]         case RANGE_WEEK_SUNDAY: [EOL]         case RANGE_WEEK_MONDAY: [EOL]         case RANGE_WEEK_RELATIVE: [EOL]         case RANGE_WEEK_CENTER: [EOL]             start = truncate(focus, Calendar.DATE); [EOL]             end = truncate(focus, Calendar.DATE); [EOL]             switch(rangeStyle) { [EOL]                 case RANGE_WEEK_SUNDAY: [EOL]                     break; [EOL]                 case RANGE_WEEK_MONDAY: [EOL]                     startCutoff = Calendar.MONDAY; [EOL]                     endCutoff = Calendar.SUNDAY; [EOL]                     break; [EOL]                 case RANGE_WEEK_RELATIVE: [EOL]                     startCutoff = focus.get(Calendar.DAY_OF_WEEK); [EOL]                     endCutoff = startCutoff - 1; [EOL]                     break; [EOL]                 case RANGE_WEEK_CENTER: [EOL]                     startCutoff = focus.get(Calendar.DAY_OF_WEEK) - 3; [EOL]                     endCutoff = focus.get(Calendar.DAY_OF_WEEK) + 3; [EOL]                     break; [EOL]             } [EOL]             break; [EOL]         default: [EOL]             throw new IllegalArgumentException("The range style " + rangeStyle + " is not valid."); [EOL]     } [EOL]     if (startCutoff < Calendar.SUNDAY) { [EOL]         startCutoff += 7; [EOL]     } [EOL]     if (startCutoff > Calendar.SATURDAY) { [EOL]         startCutoff -= 7; [EOL]     } [EOL]     if (endCutoff < Calendar.SUNDAY) { [EOL]         endCutoff += 7; [EOL]     } [EOL]     if (endCutoff > Calendar.SATURDAY) { [EOL]         endCutoff -= 7; [EOL]     } [EOL]     while (start.get(Calendar.DAY_OF_WEEK) != startCutoff) { [EOL]         start.add(Calendar.DATE, -1); [EOL]     } [EOL]     while (end.get(Calendar.DAY_OF_WEEK) != endCutoff) { [EOL]         end.add(Calendar.DATE, 1); [EOL]     } [EOL]     return new DateIterator(start, end); [EOL] } 
 [LINE] return iterator((Calendar) focus, rangeStyle); [LINE] public static Iterator<?> iterator(final Object focus, final int rangeStyle) { [EOL]     if (focus == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     if (focus instanceof Date) { [EOL]         return iterator((Date) focus, rangeStyle); [EOL]     } else if (focus instanceof Calendar) { [EOL]         return iterator((Calendar) focus, rangeStyle); [EOL]     } else { [EOL]         throw new ClassCastException("Could not iterate based on " + focus); [EOL]     } [EOL] } 
 [LINE] return getFragment(calendar, fragment, Calendar.MILLISECOND); [LINE] public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment) { [EOL]     return getFragment(calendar, fragment, Calendar.MILLISECOND); [EOL] } 
 [LINE] return getFragment(calendar, fragment, Calendar.SECOND); [LINE] public static long getFragmentInSeconds(final Calendar calendar, final int fragment) { [EOL]     return getFragment(calendar, fragment, Calendar.SECOND); [EOL] } 
 [LINE] case Calendar.YEAR: [LINE] private static long getFragment(final Calendar calendar, final int fragment, final int unit) { [EOL]     if (calendar == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     final long millisPerUnit = getMillisPerUnit(unit); [EOL]     long result = 0; [EOL]     switch(fragment) { [EOL]         case Calendar.YEAR: [EOL]             result += (calendar.get(Calendar.DAY_OF_YEAR) * MILLIS_PER_DAY) / millisPerUnit; [EOL]             break; [EOL]         case Calendar.MONTH: [EOL]             result += (calendar.get(Calendar.DAY_OF_MONTH) * MILLIS_PER_DAY) / millisPerUnit; [EOL]             break; [EOL]     } [EOL]     switch(fragment) { [EOL]         case Calendar.YEAR: [EOL]         case Calendar.MONTH: [EOL]         case Calendar.DAY_OF_YEAR: [EOL]         case Calendar.DATE: [EOL]             result += (calendar.get(Calendar.HOUR_OF_DAY) * MILLIS_PER_HOUR) / millisPerUnit; [EOL]         case Calendar.HOUR_OF_DAY: [EOL]             result += (calendar.get(Calendar.MINUTE) * MILLIS_PER_MINUTE) / millisPerUnit; [EOL]         case Calendar.MINUTE: [EOL]             result += (calendar.get(Calendar.SECOND) * MILLIS_PER_SECOND) / millisPerUnit; [EOL]         case Calendar.SECOND: [EOL]             result += (calendar.get(Calendar.MILLISECOND) * 1) / millisPerUnit; [EOL]             break; [EOL]         case Calendar.MILLISECOND: [EOL]             break; [EOL]         default: [EOL]             throw new IllegalArgumentException("The fragment " + fragment + " is not supported"); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] break; [LINE] private static long getFragment(final Calendar calendar, final int fragment, final int unit) { [EOL]     if (calendar == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     final long millisPerUnit = getMillisPerUnit(unit); [EOL]     long result = 0; [EOL]     switch(fragment) { [EOL]         case Calendar.YEAR: [EOL]             result += (calendar.get(Calendar.DAY_OF_YEAR) * MILLIS_PER_DAY) / millisPerUnit; [EOL]             break; [EOL]         case Calendar.MONTH: [EOL]             result += (calendar.get(Calendar.DAY_OF_MONTH) * MILLIS_PER_DAY) / millisPerUnit; [EOL]             break; [EOL]     } [EOL]     switch(fragment) { [EOL]         case Calendar.YEAR: [EOL]         case Calendar.MONTH: [EOL]         case Calendar.DAY_OF_YEAR: [EOL]         case Calendar.DATE: [EOL]             result += (calendar.get(Calendar.HOUR_OF_DAY) * MILLIS_PER_HOUR) / millisPerUnit; [EOL]         case Calendar.HOUR_OF_DAY: [EOL]             result += (calendar.get(Calendar.MINUTE) * MILLIS_PER_MINUTE) / millisPerUnit; [EOL]         case Calendar.MINUTE: [EOL]             result += (calendar.get(Calendar.SECOND) * MILLIS_PER_SECOND) / millisPerUnit; [EOL]         case Calendar.SECOND: [EOL]             result += (calendar.get(Calendar.MILLISECOND) * 1) / millisPerUnit; [EOL]             break; [EOL]         case Calendar.MILLISECOND: [EOL]             break; [EOL]         default: [EOL]             throw new IllegalArgumentException("The fragment " + fragment + " is not supported"); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] result += (calendar.get(Calendar.HOUR_OF_DAY) * MILLIS_PER_HOUR) / millisPerUnit; [LINE] private static long getFragment(final Calendar calendar, final int fragment, final int unit) { [EOL]     if (calendar == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     final long millisPerUnit = getMillisPerUnit(unit); [EOL]     long result = 0; [EOL]     switch(fragment) { [EOL]         case Calendar.YEAR: [EOL]             result += (calendar.get(Calendar.DAY_OF_YEAR) * MILLIS_PER_DAY) / millisPerUnit; [EOL]             break; [EOL]         case Calendar.MONTH: [EOL]             result += (calendar.get(Calendar.DAY_OF_MONTH) * MILLIS_PER_DAY) / millisPerUnit; [EOL]             break; [EOL]     } [EOL]     switch(fragment) { [EOL]         case Calendar.YEAR: [EOL]         case Calendar.MONTH: [EOL]         case Calendar.DAY_OF_YEAR: [EOL]         case Calendar.DATE: [EOL]             result += (calendar.get(Calendar.HOUR_OF_DAY) * MILLIS_PER_HOUR) / millisPerUnit; [EOL]         case Calendar.HOUR_OF_DAY: [EOL]             result += (calendar.get(Calendar.MINUTE) * MILLIS_PER_MINUTE) / millisPerUnit; [EOL]         case Calendar.MINUTE: [EOL]             result += (calendar.get(Calendar.SECOND) * MILLIS_PER_SECOND) / millisPerUnit; [EOL]         case Calendar.SECOND: [EOL]             result += (calendar.get(Calendar.MILLISECOND) * 1) / millisPerUnit; [EOL]             break; [EOL]         case Calendar.MILLISECOND: [EOL]             break; [EOL]         default: [EOL]             throw new IllegalArgumentException("The fragment " + fragment + " is not supported"); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] long result = Long.MAX_VALUE; [LINE] private static long getMillisPerUnit(final int unit) { [EOL]     long result = Long.MAX_VALUE; [EOL]     switch(unit) { [EOL]         case Calendar.DAY_OF_YEAR: [EOL]         case Calendar.DATE: [EOL]             result = MILLIS_PER_DAY; [EOL]             break; [EOL]         case Calendar.HOUR_OF_DAY: [EOL]             result = MILLIS_PER_HOUR; [EOL]             break; [EOL]         case Calendar.MINUTE: [EOL]             result = MILLIS_PER_MINUTE; [EOL]             break; [EOL]         case Calendar.SECOND: [EOL]             result = MILLIS_PER_SECOND; [EOL]             break; [EOL]         case Calendar.MILLISECOND: [EOL]             result = 1; [EOL]             break; [EOL]         default: [EOL]             throw new IllegalArgumentException("The unit " + unit + " cannot be represented is milleseconds"); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] break; [LINE] private static long getMillisPerUnit(final int unit) { [EOL]     long result = Long.MAX_VALUE; [EOL]     switch(unit) { [EOL]         case Calendar.DAY_OF_YEAR: [EOL]         case Calendar.DATE: [EOL]             result = MILLIS_PER_DAY; [EOL]             break; [EOL]         case Calendar.HOUR_OF_DAY: [EOL]             result = MILLIS_PER_HOUR; [EOL]             break; [EOL]         case Calendar.MINUTE: [EOL]             result = MILLIS_PER_MINUTE; [EOL]             break; [EOL]         case Calendar.SECOND: [EOL]             result = MILLIS_PER_SECOND; [EOL]             break; [EOL]         case Calendar.MILLISECOND: [EOL]             result = 1; [EOL]             break; [EOL]         default: [EOL]             throw new IllegalArgumentException("The unit " + unit + " cannot be represented is milleseconds"); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] case Calendar.MILLISECOND: [LINE] private static long getMillisPerUnit(final int unit) { [EOL]     long result = Long.MAX_VALUE; [EOL]     switch(unit) { [EOL]         case Calendar.DAY_OF_YEAR: [EOL]         case Calendar.DATE: [EOL]             result = MILLIS_PER_DAY; [EOL]             break; [EOL]         case Calendar.HOUR_OF_DAY: [EOL]             result = MILLIS_PER_HOUR; [EOL]             break; [EOL]         case Calendar.MINUTE: [EOL]             result = MILLIS_PER_MINUTE; [EOL]             break; [EOL]         case Calendar.SECOND: [EOL]             result = MILLIS_PER_SECOND; [EOL]             break; [EOL]         case Calendar.MILLISECOND: [EOL]             result = 1; [EOL]             break; [EOL]         default: [EOL]             throw new IllegalArgumentException("The unit " + unit + " cannot be represented is milleseconds"); [EOL]     } [EOL]     return result; [EOL] } 
lang3/builder/IDKey.java
 [LINE] return id; [LINE] @Override [EOL] public int hashCode() { [EOL]     return id; [EOL] } 
lang3/SerializationException.java
lang3/CharRange.java
 [LINE] return new CharRange(start, end, false); [LINE] public static CharRange isIn(final char start, final char end) { [EOL]     return new CharRange(start, end, false); [EOL] } 
 [LINE] if (range.negated) { [LINE] public boolean contains(final CharRange range) { [EOL]     if (range == null) { [EOL]         throw new IllegalArgumentException("The Range must not be null"); [EOL]     } [EOL]     if (negated) { [EOL]         if (range.negated) { [EOL]             return start >= range.start && end <= range.end; [EOL]         } [EOL]         return range.end < start || range.start > end; [EOL]     } [EOL]     if (range.negated) { [EOL]         return start == 0 && end == Character.MAX_VALUE; [EOL]     } [EOL]     return start <= range.start && end >= range.end; [EOL] } 
 [LINE] return range.end < start || range.start > end; [LINE] public boolean contains(final CharRange range) { [EOL]     if (range == null) { [EOL]         throw new IllegalArgumentException("The Range must not be null"); [EOL]     } [EOL]     if (negated) { [EOL]         if (range.negated) { [EOL]             return start >= range.start && end <= range.end; [EOL]         } [EOL]         return range.end < start || range.start > end; [EOL]     } [EOL]     if (range.negated) { [EOL]         return start == 0 && end == Character.MAX_VALUE; [EOL]     } [EOL]     return start <= range.start && end >= range.end; [EOL] } 
 [LINE] if (range.negated) { [LINE] public boolean contains(final CharRange range) { [EOL]     if (range == null) { [EOL]         throw new IllegalArgumentException("The Range must not be null"); [EOL]     } [EOL]     if (negated) { [EOL]         if (range.negated) { [EOL]             return start >= range.start && end <= range.end; [EOL]         } [EOL]         return range.end < start || range.start > end; [EOL]     } [EOL]     if (range.negated) { [EOL]         return start == 0 && end == Character.MAX_VALUE; [EOL]     } [EOL]     return start <= range.start && end >= range.end; [EOL] } 
 [LINE] return start == 0 && end == Character.MAX_VALUE; [LINE] public boolean contains(final CharRange range) { [EOL]     if (range == null) { [EOL]         throw new IllegalArgumentException("The Range must not be null"); [EOL]     } [EOL]     if (negated) { [EOL]         if (range.negated) { [EOL]             return start >= range.start && end <= range.end; [EOL]         } [EOL]         return range.end < start || range.start > end; [EOL]     } [EOL]     if (range.negated) { [EOL]         return start == 0 && end == Character.MAX_VALUE; [EOL]     } [EOL]     return start <= range.start && end >= range.end; [EOL] } 
 [LINE] if (iToString == null) { [LINE] @Override [EOL] public String toString() { [EOL]     if (iToString == null) { [EOL]         final StringBuilder buf = new StringBuilder(4); [EOL]         if (isNegated()) { [EOL]             buf.append('^'); [EOL]         } [EOL]         buf.append(start); [EOL]         if (start != end) { [EOL]             buf.append('-'); [EOL]             buf.append(end); [EOL]         } [EOL]         iToString = buf.toString(); [EOL]     } [EOL]     return iToString; [EOL] } 
 [LINE] buf.append(end); [LINE] @Override [EOL] public String toString() { [EOL]     if (iToString == null) { [EOL]         final StringBuilder buf = new StringBuilder(4); [EOL]         if (isNegated()) { [EOL]             buf.append('^'); [EOL]         } [EOL]         buf.append(start); [EOL]         if (start != end) { [EOL]             buf.append('-'); [EOL]             buf.append(end); [EOL]         } [EOL]         iToString = buf.toString(); [EOL]     } [EOL]     return iToString; [EOL] } 
 [LINE] hasNext = false; [LINE] private void prepareNext() { [EOL]     if (range.negated) { [EOL]         if (current == Character.MAX_VALUE) { [EOL]             hasNext = false; [EOL]         } else if (current + 1 == range.start) { [EOL]             if (range.end == Character.MAX_VALUE) { [EOL]                 hasNext = false; [EOL]             } else { [EOL]                 current = (char) (range.end + 1); [EOL]             } [EOL]         } else { [EOL]             current = (char) (current + 1); [EOL]         } [EOL]     } else if (current < range.end) { [EOL]         current = (char) (current + 1); [EOL]     } else { [EOL]         hasNext = false; [EOL]     } [EOL] } 
 [LINE] if (range.end == Character.MAX_VALUE) { [LINE] private void prepareNext() { [EOL]     if (range.negated) { [EOL]         if (current == Character.MAX_VALUE) { [EOL]             hasNext = false; [EOL]         } else if (current + 1 == range.start) { [EOL]             if (range.end == Character.MAX_VALUE) { [EOL]                 hasNext = false; [EOL]             } else { [EOL]                 current = (char) (range.end + 1); [EOL]             } [EOL]         } else { [EOL]             current = (char) (current + 1); [EOL]         } [EOL]     } else if (current < range.end) { [EOL]         current = (char) (current + 1); [EOL]     } else { [EOL]         hasNext = false; [EOL]     } [EOL] } 
 [LINE] hasNext = false; [LINE] private void prepareNext() { [EOL]     if (range.negated) { [EOL]         if (current == Character.MAX_VALUE) { [EOL]             hasNext = false; [EOL]         } else if (current + 1 == range.start) { [EOL]             if (range.end == Character.MAX_VALUE) { [EOL]                 hasNext = false; [EOL]             } else { [EOL]                 current = (char) (range.end + 1); [EOL]             } [EOL]         } else { [EOL]             current = (char) (current + 1); [EOL]         } [EOL]     } else if (current < range.end) { [EOL]         current = (char) (current + 1); [EOL]     } else { [EOL]         hasNext = false; [EOL]     } [EOL] } 
 [LINE] current = (char) (current + 1); [LINE] private void prepareNext() { [EOL]     if (range.negated) { [EOL]         if (current == Character.MAX_VALUE) { [EOL]             hasNext = false; [EOL]         } else if (current + 1 == range.start) { [EOL]             if (range.end == Character.MAX_VALUE) { [EOL]                 hasNext = false; [EOL]             } else { [EOL]                 current = (char) (range.end + 1); [EOL]             } [EOL]         } else { [EOL]             current = (char) (current + 1); [EOL]         } [EOL]     } else if (current < range.end) { [EOL]         current = (char) (current + 1); [EOL]     } else { [EOL]         hasNext = false; [EOL]     } [EOL] } 
 [LINE] if (hasNext == false) { [LINE] @Override [EOL] public Character next() { [EOL]     if (hasNext == false) { [EOL]         throw new NoSuchElementException(); [EOL]     } [EOL]     final char cur = current; [EOL]     prepareNext(); [EOL]     return Character.valueOf(cur); [EOL] } 
lang3/exception/CloneFailedException.java
lang3/reflect/MemberUtils.java
 [LINE] float totalCost = 0.0f; [LINE] private static float getTotalTransformationCost(final Class<?>[] srcArgs, final Class<?>[] destArgs) { [EOL]     float totalCost = 0.0f; [EOL]     for (int i = 0; i < srcArgs.length; i++) { [EOL]         Class<?> srcClass, destClass; [EOL]         srcClass = srcArgs[i]; [EOL]         destClass = destArgs[i]; [EOL]         totalCost += getObjectTransformationCost(srcClass, destClass); [EOL]     } [EOL]     return totalCost; [EOL] } 
 [LINE] for (int i = 0; i < srcArgs.length; i++) { [LINE] private static float getTotalTransformationCost(final Class<?>[] srcArgs, final Class<?>[] destArgs) { [EOL]     float totalCost = 0.0f; [EOL]     for (int i = 0; i < srcArgs.length; i++) { [EOL]         Class<?> srcClass, destClass; [EOL]         srcClass = srcArgs[i]; [EOL]         destClass = destArgs[i]; [EOL]         totalCost += getObjectTransformationCost(srcClass, destClass); [EOL]     } [EOL]     return totalCost; [EOL] } 
 [LINE] srcClass = srcArgs[i]; [LINE] private static float getTotalTransformationCost(final Class<?>[] srcArgs, final Class<?>[] destArgs) { [EOL]     float totalCost = 0.0f; [EOL]     for (int i = 0; i < srcArgs.length; i++) { [EOL]         Class<?> srcClass, destClass; [EOL]         srcClass = srcArgs[i]; [EOL]         destClass = destArgs[i]; [EOL]         totalCost += getObjectTransformationCost(srcClass, destClass); [EOL]     } [EOL]     return totalCost; [EOL] } 
 [LINE] cost += 0.1f; [LINE] private static float getPrimitivePromotionCost(final Class<?> srcClass, final Class<?> destClass) { [EOL]     float cost = 0.0f; [EOL]     Class<?> cls = srcClass; [EOL]     if (!cls.isPrimitive()) { [EOL]         cost += 0.1f; [EOL]         cls = ClassUtils.wrapperToPrimitive(cls); [EOL]     } [EOL]     for (int i = 0; cls != destClass && i < ORDERED_PRIMITIVE_TYPES.length; i++) { [EOL]         if (cls == ORDERED_PRIMITIVE_TYPES[i]) { [EOL]             cost += 0.1f; [EOL]             if (i < ORDERED_PRIMITIVE_TYPES.length - 1) { [EOL]                 cls = ORDERED_PRIMITIVE_TYPES[i + 1]; [EOL]             } [EOL]         } [EOL]     } [EOL]     return cost; [EOL] } 
lang3/tuple/MutableTriple.java
lang3/text/translate/CodePointTranslator.java
 [LINE] return 0; [LINE] @Override [EOL] public final int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     final int codepoint = Character.codePointAt(input, index); [EOL]     final boolean consumed = translate(codepoint, out); [EOL]     if (consumed) { [EOL]         return 1; [EOL]     } else { [EOL]         return 0; [EOL]     } [EOL] } 
lang3/SerializationUtils.java
 [LINE] return null; [LINE] public static <T extends Serializable> T clone(final T object) { [EOL]     if (object == null) { [EOL]         return null; [EOL]     } [EOL]     final byte[] objectData = serialize(object); [EOL]     final ByteArrayInputStream bais = new ByteArrayInputStream(objectData); [EOL]     ClassLoaderAwareObjectInputStream in = null; [EOL]     try { [EOL]         in = new ClassLoaderAwareObjectInputStream(bais, object.getClass().getClassLoader()); [EOL]         @SuppressWarnings("unchecked") [EOL]         final T readObject = (T) in.readObject(); [EOL]         return readObject; [EOL]     } catch (final ClassNotFoundException ex) { [EOL]         throw new SerializationException("ClassNotFoundException while reading cloned object data", ex); [EOL]     } catch (final IOException ex) { [EOL]         throw new SerializationException("IOException while reading cloned object data", ex); [EOL]     } finally { [EOL]         try { [EOL]             if (in != null) { [EOL]                 in.close(); [EOL]             } [EOL]         } catch (final IOException ex) { [EOL]             throw new SerializationException("IOException on closing cloned object data InputStream.", ex); [EOL]         } [EOL]     } [EOL] } 
 [LINE] in = new ClassLoaderAwareObjectInputStream(bais, object.getClass().getClassLoader()); [LINE] public static <T extends Serializable> T clone(final T object) { [EOL]     if (object == null) { [EOL]         return null; [EOL]     } [EOL]     final byte[] objectData = serialize(object); [EOL]     final ByteArrayInputStream bais = new ByteArrayInputStream(objectData); [EOL]     ClassLoaderAwareObjectInputStream in = null; [EOL]     try { [EOL]         in = new ClassLoaderAwareObjectInputStream(bais, object.getClass().getClassLoader()); [EOL]         @SuppressWarnings("unchecked") [EOL]         final T readObject = (T) in.readObject(); [EOL]         return readObject; [EOL]     } catch (final ClassNotFoundException ex) { [EOL]         throw new SerializationException("ClassNotFoundException while reading cloned object data", ex); [EOL]     } catch (final IOException ex) { [EOL]         throw new SerializationException("IOException while reading cloned object data", ex); [EOL]     } finally { [EOL]         try { [EOL]             if (in != null) { [EOL]                 in.close(); [EOL]             } [EOL]         } catch (final IOException ex) { [EOL]             throw new SerializationException("IOException on closing cloned object data InputStream.", ex); [EOL]         } [EOL]     } [EOL] } 
 [LINE] out.close(); [LINE] public static void serialize(final Serializable obj, final OutputStream outputStream) { [EOL]     if (outputStream == null) { [EOL]         throw new IllegalArgumentException("The OutputStream must not be null"); [EOL]     } [EOL]     ObjectOutputStream out = null; [EOL]     try { [EOL]         out = new ObjectOutputStream(outputStream); [EOL]         out.writeObject(obj); [EOL]     } catch (final IOException ex) { [EOL]         throw new SerializationException(ex); [EOL]     } finally { [EOL]         try { [EOL]             if (out != null) { [EOL]                 out.close(); [EOL]             } [EOL]         } catch (final IOException ex) { [EOL]         } [EOL]     } [EOL] } 
 [LINE] ObjectInputStream in = null; [LINE] public static <T> T deserialize(final InputStream inputStream) { [EOL]     if (inputStream == null) { [EOL]         throw new IllegalArgumentException("The InputStream must not be null"); [EOL]     } [EOL]     ObjectInputStream in = null; [EOL]     try { [EOL]         in = new ObjectInputStream(inputStream); [EOL]         @SuppressWarnings("unchecked") [EOL]         final T obj = (T) in.readObject(); [EOL]         return obj; [EOL]     } catch (final ClassCastException ex) { [EOL]         throw new SerializationException(ex); [EOL]     } catch (final ClassNotFoundException ex) { [EOL]         throw new SerializationException(ex); [EOL]     } catch (final IOException ex) { [EOL]         throw new SerializationException(ex); [EOL]     } finally { [EOL]         try { [EOL]             if (in != null) { [EOL]                 in.close(); [EOL]             } [EOL]         } catch (final IOException ex) { [EOL]         } [EOL]     } [EOL] } 
 [LINE] try { [LINE] public static <T> T deserialize(final InputStream inputStream) { [EOL]     if (inputStream == null) { [EOL]         throw new IllegalArgumentException("The InputStream must not be null"); [EOL]     } [EOL]     ObjectInputStream in = null; [EOL]     try { [EOL]         in = new ObjectInputStream(inputStream); [EOL]         @SuppressWarnings("unchecked") [EOL]         final T obj = (T) in.readObject(); [EOL]         return obj; [EOL]     } catch (final ClassCastException ex) { [EOL]         throw new SerializationException(ex); [EOL]     } catch (final ClassNotFoundException ex) { [EOL]         throw new SerializationException(ex); [EOL]     } catch (final IOException ex) { [EOL]         throw new SerializationException(ex); [EOL]     } finally { [EOL]         try { [EOL]             if (in != null) { [EOL]                 in.close(); [EOL]             } [EOL]         } catch (final IOException ex) { [EOL]         } [EOL]     } [EOL] } 
 [LINE] try { [LINE] public static <T> T deserialize(final InputStream inputStream) { [EOL]     if (inputStream == null) { [EOL]         throw new IllegalArgumentException("The InputStream must not be null"); [EOL]     } [EOL]     ObjectInputStream in = null; [EOL]     try { [EOL]         in = new ObjectInputStream(inputStream); [EOL]         @SuppressWarnings("unchecked") [EOL]         final T obj = (T) in.readObject(); [EOL]         return obj; [EOL]     } catch (final ClassCastException ex) { [EOL]         throw new SerializationException(ex); [EOL]     } catch (final ClassNotFoundException ex) { [EOL]         throw new SerializationException(ex); [EOL]     } catch (final IOException ex) { [EOL]         throw new SerializationException(ex); [EOL]     } finally { [EOL]         try { [EOL]             if (in != null) { [EOL]                 in.close(); [EOL]             } [EOL]         } catch (final IOException ex) { [EOL]         } [EOL]     } [EOL] } 
 [LINE] return SerializationUtils.<T>deserialize(new ByteArrayInputStream(objectData)); [LINE] public static <T> T deserialize(final byte[] objectData) { [EOL]     if (objectData == null) { [EOL]         throw new IllegalArgumentException("The byte[] must not be null"); [EOL]     } [EOL]     return SerializationUtils.<T>deserialize(new ByteArrayInputStream(objectData)); [EOL] } 
 [LINE] final String name = desc.getName(); [LINE] @Override [EOL] protected Class<?> resolveClass(final ObjectStreamClass desc) throws IOException, ClassNotFoundException { [EOL]     final String name = desc.getName(); [EOL]     try { [EOL]         return Class.forName(name, false, classLoader); [EOL]     } catch (final ClassNotFoundException ex) { [EOL]         try { [EOL]             return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); [EOL]         } catch (final ClassNotFoundException cnfe) { [EOL]             final Class<?> cls = primitiveTypes.get(name); [EOL]             if (cls != null) { [EOL]                 return cls; [EOL]             } else { [EOL]                 throw cnfe; [EOL]             } [EOL]         } [EOL]     } [EOL] } 
lang3/builder/ReflectionToStringBuilder.java
 [LINE] list.add(e.toString()); [LINE] static String[] toNoNullStringArray(final Object[] array) { [EOL]     final List<String> list = new ArrayList<String>(array.length); [EOL]     for (final Object e : array) { [EOL]         if (e != null) { [EOL]             list.add(e.toString()); [EOL]         } [EOL]     } [EOL]     return list.toArray(ArrayUtils.EMPTY_STRING_ARRAY); [EOL] } 
 [LINE] return true; [LINE] protected boolean accept(final Field field) { [EOL]     if (field.getName().indexOf(ClassUtils.INNER_CLASS_SEPARATOR_CHAR) != -1) { [EOL]         return false; [EOL]     } [EOL]     if (Modifier.isTransient(field.getModifiers()) && !this.isAppendTransients()) { [EOL]         return false; [EOL]     } [EOL]     if (Modifier.isStatic(field.getModifiers()) && !this.isAppendStatics()) { [EOL]         return false; [EOL]     } [EOL]     if (this.excludeFieldNames != null && Arrays.binarySearch(this.excludeFieldNames, field.getName()) >= 0) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] if (clazz.isArray()) { [LINE] protected void appendFieldsIn(final Class<?> clazz) { [EOL]     if (clazz.isArray()) { [EOL]         this.reflectionAppendArray(this.getObject()); [EOL]         return; [EOL]     } [EOL]     final Field[] fields = clazz.getDeclaredFields(); [EOL]     AccessibleObject.setAccessible(fields, true); [EOL]     for (final Field field : fields) { [EOL]         final String fieldName = field.getName(); [EOL]         if (this.accept(field)) { [EOL]             try { [EOL]                 final Object fieldValue = this.getValue(field); [EOL]                 this.append(fieldName, fieldValue); [EOL]             } catch (final IllegalAccessException ex) { [EOL]                 throw new InternalError("Unexpected IllegalAccessException: " + ex.getMessage()); [EOL]             } [EOL]         } [EOL]     } [EOL] } 
 [LINE] this.reflectionAppendArray(this.getObject()); [LINE] protected void appendFieldsIn(final Class<?> clazz) { [EOL]     if (clazz.isArray()) { [EOL]         this.reflectionAppendArray(this.getObject()); [EOL]         return; [EOL]     } [EOL]     final Field[] fields = clazz.getDeclaredFields(); [EOL]     AccessibleObject.setAccessible(fields, true); [EOL]     for (final Field field : fields) { [EOL]         final String fieldName = field.getName(); [EOL]         if (this.accept(field)) { [EOL]             try { [EOL]                 final Object fieldValue = this.getValue(field); [EOL]                 this.append(fieldName, fieldValue); [EOL]             } catch (final IllegalAccessException ex) { [EOL]                 throw new InternalError("Unexpected IllegalAccessException: " + ex.getMessage()); [EOL]             } [EOL]         } [EOL]     } [EOL] } 
 [LINE] for (final Field field : fields) { [LINE] protected void appendFieldsIn(final Class<?> clazz) { [EOL]     if (clazz.isArray()) { [EOL]         this.reflectionAppendArray(this.getObject()); [EOL]         return; [EOL]     } [EOL]     final Field[] fields = clazz.getDeclaredFields(); [EOL]     AccessibleObject.setAccessible(fields, true); [EOL]     for (final Field field : fields) { [EOL]         final String fieldName = field.getName(); [EOL]         if (this.accept(field)) { [EOL]             try { [EOL]                 final Object fieldValue = this.getValue(field); [EOL]                 this.append(fieldName, fieldValue); [EOL]             } catch (final IllegalAccessException ex) { [EOL]                 throw new InternalError("Unexpected IllegalAccessException: " + ex.getMessage()); [EOL]             } [EOL]         } [EOL]     } [EOL] } 
 [LINE] final String fieldName = field.getName(); [LINE] protected void appendFieldsIn(final Class<?> clazz) { [EOL]     if (clazz.isArray()) { [EOL]         this.reflectionAppendArray(this.getObject()); [EOL]         return; [EOL]     } [EOL]     final Field[] fields = clazz.getDeclaredFields(); [EOL]     AccessibleObject.setAccessible(fields, true); [EOL]     for (final Field field : fields) { [EOL]         final String fieldName = field.getName(); [EOL]         if (this.accept(field)) { [EOL]             try { [EOL]                 final Object fieldValue = this.getValue(field); [EOL]                 this.append(fieldName, fieldValue); [EOL]             } catch (final IllegalAccessException ex) { [EOL]                 throw new InternalError("Unexpected IllegalAccessException: " + ex.getMessage()); [EOL]             } [EOL]         } [EOL]     } [EOL] } 
 [LINE] final Object fieldValue = this.getValue(field); [LINE] protected void appendFieldsIn(final Class<?> clazz) { [EOL]     if (clazz.isArray()) { [EOL]         this.reflectionAppendArray(this.getObject()); [EOL]         return; [EOL]     } [EOL]     final Field[] fields = clazz.getDeclaredFields(); [EOL]     AccessibleObject.setAccessible(fields, true); [EOL]     for (final Field field : fields) { [EOL]         final String fieldName = field.getName(); [EOL]         if (this.accept(field)) { [EOL]             try { [EOL]                 final Object fieldValue = this.getValue(field); [EOL]                 this.append(fieldName, fieldValue); [EOL]             } catch (final IllegalAccessException ex) { [EOL]                 throw new InternalError("Unexpected IllegalAccessException: " + ex.getMessage()); [EOL]             } [EOL]         } [EOL]     } [EOL] } 
 [LINE] this.getStyle().reflectionAppendArrayDetail(this.getStringBuffer(), null, array); [LINE] public ReflectionToStringBuilder reflectionAppendArray(final Object array) { [EOL]     this.getStyle().reflectionAppendArrayDetail(this.getStringBuffer(), null, array); [EOL]     return this; [EOL] } 
 [LINE] Arrays.sort(this.excludeFieldNames); [LINE] public ReflectionToStringBuilder setExcludeFieldNames(final String... excludeFieldNamesParam) { [EOL]     if (excludeFieldNamesParam == null) { [EOL]         this.excludeFieldNames = null; [EOL]     } else { [EOL]         this.excludeFieldNames = toNoNullStringArray(excludeFieldNamesParam); [EOL]         Arrays.sort(this.excludeFieldNames); [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] final Object object = getObject(); [LINE] public void setUpToClass(final Class<?> clazz) { [EOL]     if (clazz != null) { [EOL]         final Object object = getObject(); [EOL]         if (object != null && clazz.isInstance(object) == false) { [EOL]             throw new IllegalArgumentException("Specified class is not a superclass of the object"); [EOL]         } [EOL]     } [EOL]     this.upToClass = clazz; [EOL] } 
 [LINE] this.appendFieldsIn(clazz); [LINE] @Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         return this.getStyle().getNullText(); [EOL]     } [EOL]     Class<?> clazz = this.getObject().getClass(); [EOL]     this.appendFieldsIn(clazz); [EOL]     while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) { [EOL]         clazz = clazz.getSuperclass(); [EOL]         this.appendFieldsIn(clazz); [EOL]     } [EOL]     return super.toString(); [EOL] } 
lang3/concurrent/AtomicInitializer.java
 [LINE] if (result == null) { [LINE] @Override [EOL] public T get() throws ConcurrentException { [EOL]     T result = reference.get(); [EOL]     if (result == null) { [EOL]         result = initialize(); [EOL]         if (!reference.compareAndSet(null, result)) { [EOL]             result = reference.get(); [EOL]         } [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] return result; [LINE] @Override [EOL] public T get() throws ConcurrentException { [EOL]     T result = reference.get(); [EOL]     if (result == null) { [EOL]         result = initialize(); [EOL]         if (!reference.compareAndSet(null, result)) { [EOL]             result = reference.get(); [EOL]         } [EOL]     } [EOL]     return result; [EOL] } 
lang3/tuple/Triple.java
 [LINE] return new StringBuilder().append('(').append(getLeft()).append(',').append(getMiddle()).append(',') [LINE] @Override [EOL] public String toString() { [EOL]     return new StringBuilder().append('(').append(getLeft()).append(',').append(getMiddle()).append(',').append(getRight()).append(')').toString(); [EOL] } 
lang3/CharUtils.java
 [LINE] return null; [LINE] public static Character toCharacterObject(final String str) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return null; [EOL]     } [EOL]     return Character.valueOf(str.charAt(0)); [EOL] } 
 [LINE] if (ch == null) { [LINE] public static char toChar(final Character ch) { [EOL]     if (ch == null) { [EOL]         throw new IllegalArgumentException("The Character must not be null"); [EOL]     } [EOL]     return ch.charValue(); [EOL] } 
 [LINE] if (StringUtils.isEmpty(str)) { [LINE] public static char toChar(final String str) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         throw new IllegalArgumentException("The String must not be empty"); [EOL]     } [EOL]     return str.charAt(0); [EOL] } 
 [LINE] return ch - 48; [LINE] public static int toIntValue(final char ch, final int defaultValue) { [EOL]     if (isAsciiNumeric(ch) == false) { [EOL]         return defaultValue; [EOL]     } [EOL]     return ch - 48; [EOL] } 
 [LINE] if (ch == null) { [LINE] public static int toIntValue(final Character ch) { [EOL]     if (ch == null) { [EOL]         throw new IllegalArgumentException("The character must not be null"); [EOL]     } [EOL]     return toIntValue(ch.charValue()); [EOL] } 
 [LINE] if (ch < 128) { [LINE] public static String toString(final char ch) { [EOL]     if (ch < 128) { [EOL]         return CHAR_STRING_ARRAY[ch]; [EOL]     } [EOL]     return new String(new char[] { ch }); [EOL] } 
 [LINE] return "\\u0" + Integer.toHexString(ch); [LINE] public static String unicodeEscaped(final char ch) { [EOL]     if (ch < 0x10) { [EOL]         return "\\u000" + Integer.toHexString(ch); [EOL]     } else if (ch < 0x100) { [EOL]         return "\\u00" + Integer.toHexString(ch); [EOL]     } else if (ch < 0x1000) { [EOL]         return "\\u0" + Integer.toHexString(ch); [EOL]     } [EOL]     return "\\u" + Integer.toHexString(ch); [EOL] } 
 [LINE] return ch < 32 || ch == 127; [LINE] public static boolean isAsciiControl(final char ch) { [EOL]     return ch < 32 || ch == 127; [EOL] } 
 [LINE] return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z'); [LINE] public static boolean isAsciiAlpha(final char ch) { [EOL]     return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z'); [EOL] } 
 [LINE] return ch >= 'a' && ch <= 'z'; [LINE] public static boolean isAsciiAlphaLower(final char ch) { [EOL]     return ch >= 'a' && ch <= 'z'; [EOL] } 
 [LINE] return ch >= '0' && ch <= '9'; [LINE] public static boolean isAsciiNumeric(final char ch) { [EOL]     return ch >= '0' && ch <= '9'; [EOL] } 
lang3/text/StrTokenizer.java
 [LINE] final StrTokenizer tok = getCSVClone(); [LINE] public static StrTokenizer getCSVInstance(final String input) { [EOL]     final StrTokenizer tok = getCSVClone(); [EOL]     tok.reset(input); [EOL]     return tok; [EOL] } 
 [LINE] tok.reset(input); [LINE] public static StrTokenizer getCSVInstance(final String input) { [EOL]     final StrTokenizer tok = getCSVClone(); [EOL]     tok.reset(input); [EOL]     return tok; [EOL] } 
 [LINE] final StrTokenizer tok = getCSVClone(); [LINE] public static StrTokenizer getCSVInstance(final char[] input) { [EOL]     final StrTokenizer tok = getCSVClone(); [EOL]     tok.reset(input); [EOL]     return tok; [EOL] } 
 [LINE] return getTSVClone(); [LINE] public static StrTokenizer getTSVInstance() { [EOL]     return getTSVClone(); [EOL] } 
 [LINE] final StrTokenizer tok = getTSVClone(); [LINE] public static StrTokenizer getTSVInstance(final String input) { [EOL]     final StrTokenizer tok = getTSVClone(); [EOL]     tok.reset(input); [EOL]     return tok; [EOL] } 
 [LINE] return tok; [LINE] public static StrTokenizer getTSVInstance(final String input) { [EOL]     final StrTokenizer tok = getTSVClone(); [EOL]     tok.reset(input); [EOL]     return tok; [EOL] } 
 [LINE] tok.reset(input); [LINE] public static StrTokenizer getTSVInstance(final char[] input) { [EOL]     final StrTokenizer tok = getTSVClone(); [EOL]     tok.reset(input); [EOL]     return tok; [EOL] } 
 [LINE] return tok; [LINE] public static StrTokenizer getTSVInstance(final char[] input) { [EOL]     final StrTokenizer tok = getTSVClone(); [EOL]     tok.reset(input); [EOL]     return tok; [EOL] } 
 [LINE] return tokens[tokenPos++]; [LINE] public String nextToken() { [EOL]     if (hasNext()) { [EOL]         return tokens[tokenPos++]; [EOL]     } [EOL]     return null; [EOL] } 
 [LINE] return tokens.clone(); [LINE] public String[] getTokenArray() { [EOL]     checkTokenized(); [EOL]     return tokens.clone(); [EOL] } 
 [LINE] this.chars = ArrayUtils.clone(input); [LINE] public StrTokenizer reset(final char[] input) { [EOL]     reset(); [EOL]     this.chars = ArrayUtils.clone(input); [EOL]     return this; [EOL] } 
 [LINE] @Override [LINE] @Override [EOL] public boolean hasNext() { [EOL]     checkTokenized(); [EOL]     return tokenPos < tokens.length; [EOL] } 
 [LINE] checkTokenized(); [LINE] @Override [EOL] public boolean hasPrevious() { [EOL]     checkTokenized(); [EOL]     return tokenPos > 0; [EOL] } 
 [LINE] @Override [LINE] @Override [EOL] public String previous() { [EOL]     if (hasPrevious()) { [EOL]         return tokens[--tokenPos]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] } 
 [LINE] if (chars == null) { [LINE] private void checkTokenized() { [EOL]     if (tokens == null) { [EOL]         if (chars == null) { [EOL]             final List<String> split = tokenize(null, 0, 0); [EOL]             tokens = split.toArray(new String[split.size()]); [EOL]         } else { [EOL]             final List<String> split = tokenize(chars, 0, chars.length); [EOL]             tokens = split.toArray(new String[split.size()]); [EOL]         } [EOL]     } [EOL] } 
 [LINE] tokens = split.toArray(new String[split.size()]); [LINE] private void checkTokenized() { [EOL]     if (tokens == null) { [EOL]         if (chars == null) { [EOL]             final List<String> split = tokenize(null, 0, 0); [EOL]             tokens = split.toArray(new String[split.size()]); [EOL]         } else { [EOL]             final List<String> split = tokenize(chars, 0, chars.length); [EOL]             tokens = split.toArray(new String[split.size()]); [EOL]         } [EOL]     } [EOL] } 
 [LINE] if (chars == null || count == 0) { [LINE] protected List<String> tokenize(final char[] chars, final int offset, final int count) { [EOL]     if (chars == null || count == 0) { [EOL]         return Collections.emptyList(); [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(); [EOL]     final List<String> tokens = new ArrayList<String>(); [EOL]     int pos = offset; [EOL]     while (pos >= 0 && pos < count) { [EOL]         pos = readNextToken(chars, pos, count, buf, tokens); [EOL]         if (pos >= count) { [EOL]             addToken(tokens, ""); [EOL]         } [EOL]     } [EOL]     return tokens; [EOL] } 
 [LINE] pos = readNextToken(chars, pos, count, buf, tokens); [LINE] protected List<String> tokenize(final char[] chars, final int offset, final int count) { [EOL]     if (chars == null || count == 0) { [EOL]         return Collections.emptyList(); [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(); [EOL]     final List<String> tokens = new ArrayList<String>(); [EOL]     int pos = offset; [EOL]     while (pos >= 0 && pos < count) { [EOL]         pos = readNextToken(chars, pos, count, buf, tokens); [EOL]         if (pos >= count) { [EOL]             addToken(tokens, ""); [EOL]         } [EOL]     } [EOL]     return tokens; [EOL] } 
 [LINE] return; [LINE] private void addToken(final List<String> list, String tok) { [EOL]     if (StringUtils.isEmpty(tok)) { [EOL]         if (isIgnoreEmptyTokens()) { [EOL]             return; [EOL]         } [EOL]         if (isEmptyTokenAsNull()) { [EOL]             tok = null; [EOL]         } [EOL]     } [EOL]     list.add(tok); [EOL] } 
 [LINE] tok = null; [LINE] private void addToken(final List<String> list, String tok) { [EOL]     if (StringUtils.isEmpty(tok)) { [EOL]         if (isIgnoreEmptyTokens()) { [EOL]             return; [EOL]         } [EOL]         if (isEmptyTokenAsNull()) { [EOL]             tok = null; [EOL]         } [EOL]     } [EOL]     list.add(tok); [EOL] } 
 [LINE] addToken(tokens, ""); [LINE] private int readNextToken(final char[] chars, int start, final int len, final StrBuilder workArea, final List<String> tokens) { [EOL]     while (start < len) { [EOL]         final int removeLen = Math.max(getIgnoredMatcher().isMatch(chars, start, start, len), getTrimmerMatcher().isMatch(chars, start, start, len)); [EOL]         if (removeLen == 0 || getDelimiterMatcher().isMatch(chars, start, start, len) > 0 || getQuoteMatcher().isMatch(chars, start, start, len) > 0) { [EOL]             break; [EOL]         } [EOL]         start += removeLen; [EOL]     } [EOL]     if (start >= len) { [EOL]         addToken(tokens, ""); [EOL]         return -1; [EOL]     } [EOL]     final int delimLen = getDelimiterMatcher().isMatch(chars, start, start, len); [EOL]     if (delimLen > 0) { [EOL]         addToken(tokens, ""); [EOL]         return start + delimLen; [EOL]     } [EOL]     final int quoteLen = getQuoteMatcher().isMatch(chars, start, start, len); [EOL]     if (quoteLen > 0) { [EOL]         return readWithQuotes(chars, start + quoteLen, len, workArea, tokens, start, quoteLen); [EOL]     } [EOL]     return readWithQuotes(chars, start, len, workArea, tokens, 0, 0); [EOL] } 
 [LINE] return readWithQuotes(chars, start + quoteLen, len, workArea, tokens, start, quoteLen); [LINE] private int readNextToken(final char[] chars, int start, final int len, final StrBuilder workArea, final List<String> tokens) { [EOL]     while (start < len) { [EOL]         final int removeLen = Math.max(getIgnoredMatcher().isMatch(chars, start, start, len), getTrimmerMatcher().isMatch(chars, start, start, len)); [EOL]         if (removeLen == 0 || getDelimiterMatcher().isMatch(chars, start, start, len) > 0 || getQuoteMatcher().isMatch(chars, start, start, len) > 0) { [EOL]             break; [EOL]         } [EOL]         start += removeLen; [EOL]     } [EOL]     if (start >= len) { [EOL]         addToken(tokens, ""); [EOL]         return -1; [EOL]     } [EOL]     final int delimLen = getDelimiterMatcher().isMatch(chars, start, start, len); [EOL]     if (delimLen > 0) { [EOL]         addToken(tokens, ""); [EOL]         return start + delimLen; [EOL]     } [EOL]     final int quoteLen = getQuoteMatcher().isMatch(chars, start, start, len); [EOL]     if (quoteLen > 0) { [EOL]         return readWithQuotes(chars, start + quoteLen, len, workArea, tokens, start, quoteLen); [EOL]     } [EOL]     return readWithQuotes(chars, start, len, workArea, tokens, 0, 0); [EOL] } 
 [LINE] pos += quoteLen * 2; [LINE] private int readWithQuotes(final char[] chars, final int start, final int len, final StrBuilder workArea, final List<String> tokens, final int quoteStart, final int quoteLen) { [EOL]     workArea.clear(); [EOL]     int pos = start; [EOL]     boolean quoting = quoteLen > 0; [EOL]     int trimStart = 0; [EOL]     while (pos < len) { [EOL]         if (quoting) { [EOL]             if (isQuote(chars, pos, len, quoteStart, quoteLen)) { [EOL]                 if (isQuote(chars, pos + quoteLen, len, quoteStart, quoteLen)) { [EOL]                     workArea.append(chars, pos, quoteLen); [EOL]                     pos += quoteLen * 2; [EOL]                     trimStart = workArea.size(); [EOL]                     continue; [EOL]                 } [EOL]                 quoting = false; [EOL]                 pos += quoteLen; [EOL]                 continue; [EOL]             } [EOL]             workArea.append(chars[pos++]); [EOL]             trimStart = workArea.size(); [EOL]         } else { [EOL]             final int delimLen = getDelimiterMatcher().isMatch(chars, pos, start, len); [EOL]             if (delimLen > 0) { [EOL]                 addToken(tokens, workArea.substring(0, trimStart)); [EOL]                 return pos + delimLen; [EOL]             } [EOL]             if (quoteLen > 0 && isQuote(chars, pos, len, quoteStart, quoteLen)) { [EOL]                 quoting = true; [EOL]                 pos += quoteLen; [EOL]                 continue; [EOL]             } [EOL]             final int ignoredLen = getIgnoredMatcher().isMatch(chars, pos, start, len); [EOL]             if (ignoredLen > 0) { [EOL]                 pos += ignoredLen; [EOL]                 continue; [EOL]             } [EOL]             final int trimmedLen = getTrimmerMatcher().isMatch(chars, pos, start, len); [EOL]             if (trimmedLen > 0) { [EOL]                 workArea.append(chars, pos, trimmedLen); [EOL]                 pos += trimmedLen; [EOL]                 continue; [EOL]             } [EOL]             workArea.append(chars[pos++]); [EOL]             trimStart = workArea.size(); [EOL]         } [EOL]     } [EOL]     addToken(tokens, workArea.substring(0, trimStart)); [EOL]     return -1; [EOL] } 
 [LINE] quoting = false; [LINE] private int readWithQuotes(final char[] chars, final int start, final int len, final StrBuilder workArea, final List<String> tokens, final int quoteStart, final int quoteLen) { [EOL]     workArea.clear(); [EOL]     int pos = start; [EOL]     boolean quoting = quoteLen > 0; [EOL]     int trimStart = 0; [EOL]     while (pos < len) { [EOL]         if (quoting) { [EOL]             if (isQuote(chars, pos, len, quoteStart, quoteLen)) { [EOL]                 if (isQuote(chars, pos + quoteLen, len, quoteStart, quoteLen)) { [EOL]                     workArea.append(chars, pos, quoteLen); [EOL]                     pos += quoteLen * 2; [EOL]                     trimStart = workArea.size(); [EOL]                     continue; [EOL]                 } [EOL]                 quoting = false; [EOL]                 pos += quoteLen; [EOL]                 continue; [EOL]             } [EOL]             workArea.append(chars[pos++]); [EOL]             trimStart = workArea.size(); [EOL]         } else { [EOL]             final int delimLen = getDelimiterMatcher().isMatch(chars, pos, start, len); [EOL]             if (delimLen > 0) { [EOL]                 addToken(tokens, workArea.substring(0, trimStart)); [EOL]                 return pos + delimLen; [EOL]             } [EOL]             if (quoteLen > 0 && isQuote(chars, pos, len, quoteStart, quoteLen)) { [EOL]                 quoting = true; [EOL]                 pos += quoteLen; [EOL]                 continue; [EOL]             } [EOL]             final int ignoredLen = getIgnoredMatcher().isMatch(chars, pos, start, len); [EOL]             if (ignoredLen > 0) { [EOL]                 pos += ignoredLen; [EOL]                 continue; [EOL]             } [EOL]             final int trimmedLen = getTrimmerMatcher().isMatch(chars, pos, start, len); [EOL]             if (trimmedLen > 0) { [EOL]                 workArea.append(chars, pos, trimmedLen); [EOL]                 pos += trimmedLen; [EOL]                 continue; [EOL]             } [EOL]             workArea.append(chars[pos++]); [EOL]             trimStart = workArea.size(); [EOL]         } [EOL]     } [EOL]     addToken(tokens, workArea.substring(0, trimStart)); [EOL]     return -1; [EOL] } 
 [LINE] pos += quoteLen; [LINE] private int readWithQuotes(final char[] chars, final int start, final int len, final StrBuilder workArea, final List<String> tokens, final int quoteStart, final int quoteLen) { [EOL]     workArea.clear(); [EOL]     int pos = start; [EOL]     boolean quoting = quoteLen > 0; [EOL]     int trimStart = 0; [EOL]     while (pos < len) { [EOL]         if (quoting) { [EOL]             if (isQuote(chars, pos, len, quoteStart, quoteLen)) { [EOL]                 if (isQuote(chars, pos + quoteLen, len, quoteStart, quoteLen)) { [EOL]                     workArea.append(chars, pos, quoteLen); [EOL]                     pos += quoteLen * 2; [EOL]                     trimStart = workArea.size(); [EOL]                     continue; [EOL]                 } [EOL]                 quoting = false; [EOL]                 pos += quoteLen; [EOL]                 continue; [EOL]             } [EOL]             workArea.append(chars[pos++]); [EOL]             trimStart = workArea.size(); [EOL]         } else { [EOL]             final int delimLen = getDelimiterMatcher().isMatch(chars, pos, start, len); [EOL]             if (delimLen > 0) { [EOL]                 addToken(tokens, workArea.substring(0, trimStart)); [EOL]                 return pos + delimLen; [EOL]             } [EOL]             if (quoteLen > 0 && isQuote(chars, pos, len, quoteStart, quoteLen)) { [EOL]                 quoting = true; [EOL]                 pos += quoteLen; [EOL]                 continue; [EOL]             } [EOL]             final int ignoredLen = getIgnoredMatcher().isMatch(chars, pos, start, len); [EOL]             if (ignoredLen > 0) { [EOL]                 pos += ignoredLen; [EOL]                 continue; [EOL]             } [EOL]             final int trimmedLen = getTrimmerMatcher().isMatch(chars, pos, start, len); [EOL]             if (trimmedLen > 0) { [EOL]                 workArea.append(chars, pos, trimmedLen); [EOL]                 pos += trimmedLen; [EOL]                 continue; [EOL]             } [EOL]             workArea.append(chars[pos++]); [EOL]             trimStart = workArea.size(); [EOL]         } [EOL]     } [EOL]     addToken(tokens, workArea.substring(0, trimStart)); [EOL]     return -1; [EOL] } 
 [LINE] if (quoteLen > 0 && isQuote(chars, pos, len, quoteStart, quoteLen)) { [LINE] private int readWithQuotes(final char[] chars, final int start, final int len, final StrBuilder workArea, final List<String> tokens, final int quoteStart, final int quoteLen) { [EOL]     workArea.clear(); [EOL]     int pos = start; [EOL]     boolean quoting = quoteLen > 0; [EOL]     int trimStart = 0; [EOL]     while (pos < len) { [EOL]         if (quoting) { [EOL]             if (isQuote(chars, pos, len, quoteStart, quoteLen)) { [EOL]                 if (isQuote(chars, pos + quoteLen, len, quoteStart, quoteLen)) { [EOL]                     workArea.append(chars, pos, quoteLen); [EOL]                     pos += quoteLen * 2; [EOL]                     trimStart = workArea.size(); [EOL]                     continue; [EOL]                 } [EOL]                 quoting = false; [EOL]                 pos += quoteLen; [EOL]                 continue; [EOL]             } [EOL]             workArea.append(chars[pos++]); [EOL]             trimStart = workArea.size(); [EOL]         } else { [EOL]             final int delimLen = getDelimiterMatcher().isMatch(chars, pos, start, len); [EOL]             if (delimLen > 0) { [EOL]                 addToken(tokens, workArea.substring(0, trimStart)); [EOL]                 return pos + delimLen; [EOL]             } [EOL]             if (quoteLen > 0 && isQuote(chars, pos, len, quoteStart, quoteLen)) { [EOL]                 quoting = true; [EOL]                 pos += quoteLen; [EOL]                 continue; [EOL]             } [EOL]             final int ignoredLen = getIgnoredMatcher().isMatch(chars, pos, start, len); [EOL]             if (ignoredLen > 0) { [EOL]                 pos += ignoredLen; [EOL]                 continue; [EOL]             } [EOL]             final int trimmedLen = getTrimmerMatcher().isMatch(chars, pos, start, len); [EOL]             if (trimmedLen > 0) { [EOL]                 workArea.append(chars, pos, trimmedLen); [EOL]                 pos += trimmedLen; [EOL]                 continue; [EOL]             } [EOL]             workArea.append(chars[pos++]); [EOL]             trimStart = workArea.size(); [EOL]         } [EOL]     } [EOL]     addToken(tokens, workArea.substring(0, trimStart)); [EOL]     return -1; [EOL] } 
 [LINE] if (ignoredLen > 0) { [LINE] private int readWithQuotes(final char[] chars, final int start, final int len, final StrBuilder workArea, final List<String> tokens, final int quoteStart, final int quoteLen) { [EOL]     workArea.clear(); [EOL]     int pos = start; [EOL]     boolean quoting = quoteLen > 0; [EOL]     int trimStart = 0; [EOL]     while (pos < len) { [EOL]         if (quoting) { [EOL]             if (isQuote(chars, pos, len, quoteStart, quoteLen)) { [EOL]                 if (isQuote(chars, pos + quoteLen, len, quoteStart, quoteLen)) { [EOL]                     workArea.append(chars, pos, quoteLen); [EOL]                     pos += quoteLen * 2; [EOL]                     trimStart = workArea.size(); [EOL]                     continue; [EOL]                 } [EOL]                 quoting = false; [EOL]                 pos += quoteLen; [EOL]                 continue; [EOL]             } [EOL]             workArea.append(chars[pos++]); [EOL]             trimStart = workArea.size(); [EOL]         } else { [EOL]             final int delimLen = getDelimiterMatcher().isMatch(chars, pos, start, len); [EOL]             if (delimLen > 0) { [EOL]                 addToken(tokens, workArea.substring(0, trimStart)); [EOL]                 return pos + delimLen; [EOL]             } [EOL]             if (quoteLen > 0 && isQuote(chars, pos, len, quoteStart, quoteLen)) { [EOL]                 quoting = true; [EOL]                 pos += quoteLen; [EOL]                 continue; [EOL]             } [EOL]             final int ignoredLen = getIgnoredMatcher().isMatch(chars, pos, start, len); [EOL]             if (ignoredLen > 0) { [EOL]                 pos += ignoredLen; [EOL]                 continue; [EOL]             } [EOL]             final int trimmedLen = getTrimmerMatcher().isMatch(chars, pos, start, len); [EOL]             if (trimmedLen > 0) { [EOL]                 workArea.append(chars, pos, trimmedLen); [EOL]                 pos += trimmedLen; [EOL]                 continue; [EOL]             } [EOL]             workArea.append(chars[pos++]); [EOL]             trimStart = workArea.size(); [EOL]         } [EOL]     } [EOL]     addToken(tokens, workArea.substring(0, trimStart)); [EOL]     return -1; [EOL] } 
 [LINE] pos += ignoredLen; [LINE] private int readWithQuotes(final char[] chars, final int start, final int len, final StrBuilder workArea, final List<String> tokens, final int quoteStart, final int quoteLen) { [EOL]     workArea.clear(); [EOL]     int pos = start; [EOL]     boolean quoting = quoteLen > 0; [EOL]     int trimStart = 0; [EOL]     while (pos < len) { [EOL]         if (quoting) { [EOL]             if (isQuote(chars, pos, len, quoteStart, quoteLen)) { [EOL]                 if (isQuote(chars, pos + quoteLen, len, quoteStart, quoteLen)) { [EOL]                     workArea.append(chars, pos, quoteLen); [EOL]                     pos += quoteLen * 2; [EOL]                     trimStart = workArea.size(); [EOL]                     continue; [EOL]                 } [EOL]                 quoting = false; [EOL]                 pos += quoteLen; [EOL]                 continue; [EOL]             } [EOL]             workArea.append(chars[pos++]); [EOL]             trimStart = workArea.size(); [EOL]         } else { [EOL]             final int delimLen = getDelimiterMatcher().isMatch(chars, pos, start, len); [EOL]             if (delimLen > 0) { [EOL]                 addToken(tokens, workArea.substring(0, trimStart)); [EOL]                 return pos + delimLen; [EOL]             } [EOL]             if (quoteLen > 0 && isQuote(chars, pos, len, quoteStart, quoteLen)) { [EOL]                 quoting = true; [EOL]                 pos += quoteLen; [EOL]                 continue; [EOL]             } [EOL]             final int ignoredLen = getIgnoredMatcher().isMatch(chars, pos, start, len); [EOL]             if (ignoredLen > 0) { [EOL]                 pos += ignoredLen; [EOL]                 continue; [EOL]             } [EOL]             final int trimmedLen = getTrimmerMatcher().isMatch(chars, pos, start, len); [EOL]             if (trimmedLen > 0) { [EOL]                 workArea.append(chars, pos, trimmedLen); [EOL]                 pos += trimmedLen; [EOL]                 continue; [EOL]             } [EOL]             workArea.append(chars[pos++]); [EOL]             trimStart = workArea.size(); [EOL]         } [EOL]     } [EOL]     addToken(tokens, workArea.substring(0, trimStart)); [EOL]     return -1; [EOL] } 
 [LINE] if (pos + i >= len || chars[pos + i] != chars[quoteStart + i]) { [LINE] private boolean isQuote(final char[] chars, final int pos, final int len, final int quoteStart, final int quoteLen) { [EOL]     for (int i = 0; i < quoteLen; i++) { [EOL]         if (pos + i >= len || chars[pos + i] != chars[quoteStart + i]) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] return this; [LINE] public StrTokenizer setDelimiterMatcher(final StrMatcher delim) { [EOL]     if (delim == null) { [EOL]         this.delimMatcher = StrMatcher.noneMatcher(); [EOL]     } else { [EOL]         this.delimMatcher = delim; [EOL]     } [EOL]     return this; [EOL] } 
 [LINE] return quoteMatcher; [LINE] public StrMatcher getQuoteMatcher() { [EOL]     return quoteMatcher; [EOL] } 
 [LINE] return this.emptyAsNull; [LINE] public boolean isEmptyTokenAsNull() { [EOL]     return this.emptyAsNull; [EOL] } 
 [LINE] if (chars == null) { [LINE] public String getContent() { [EOL]     if (chars == null) { [EOL]         return null; [EOL]     } [EOL]     return new String(chars); [EOL] } 
 [LINE] return new String(chars); [LINE] public String getContent() { [EOL]     if (chars == null) { [EOL]         return null; [EOL]     } [EOL]     return new String(chars); [EOL] } 
 [LINE] return "StrTokenizer[not tokenized yet]"; [LINE] @Override [EOL] public String toString() { [EOL]     if (tokens == null) { [EOL]         return "StrTokenizer[not tokenized yet]"; [EOL]     } [EOL]     return "StrTokenizer" + getTokenList(); [EOL] } 
lang3/concurrent/TimedSemaphore.java
 [LINE] task.cancel(false); [LINE] public synchronized void shutdown() { [EOL]     if (!shutdown) { [EOL]         if (ownExecutor) { [EOL]             getExecutorService().shutdownNow(); [EOL]         } [EOL]         if (task != null) { [EOL]             task.cancel(false); [EOL]         } [EOL]         shutdown = true; [EOL]     } [EOL] } 
 [LINE] if (task == null) { [LINE] public synchronized void acquire() throws InterruptedException { [EOL]     if (isShutdown()) { [EOL]         throw new IllegalStateException("TimedSemaphore is shut down!"); [EOL]     } [EOL]     if (task == null) { [EOL]         task = startTimer(); [EOL]     } [EOL]     boolean canPass = false; [EOL]     do { [EOL]         canPass = getLimit() <= NO_LIMIT || acquireCount < getLimit(); [EOL]         if (!canPass) { [EOL]             wait(); [EOL]         } else { [EOL]             acquireCount++; [EOL]         } [EOL]     } while (!canPass); [EOL] } 
 [LINE] boolean canPass = false; [LINE] public synchronized void acquire() throws InterruptedException { [EOL]     if (isShutdown()) { [EOL]         throw new IllegalStateException("TimedSemaphore is shut down!"); [EOL]     } [EOL]     if (task == null) { [EOL]         task = startTimer(); [EOL]     } [EOL]     boolean canPass = false; [EOL]     do { [EOL]         canPass = getLimit() <= NO_LIMIT || acquireCount < getLimit(); [EOL]         if (!canPass) { [EOL]             wait(); [EOL]         } else { [EOL]             acquireCount++; [EOL]         } [EOL]     } while (!canPass); [EOL] } 
 [LINE] canPass = getLimit() <= NO_LIMIT || acquireCount < getLimit(); [LINE] public synchronized void acquire() throws InterruptedException { [EOL]     if (isShutdown()) { [EOL]         throw new IllegalStateException("TimedSemaphore is shut down!"); [EOL]     } [EOL]     if (task == null) { [EOL]         task = startTimer(); [EOL]     } [EOL]     boolean canPass = false; [EOL]     do { [EOL]         canPass = getLimit() <= NO_LIMIT || acquireCount < getLimit(); [EOL]         if (!canPass) { [EOL]             wait(); [EOL]         } else { [EOL]             acquireCount++; [EOL]         } [EOL]     } while (!canPass); [EOL] } 
 [LINE] acquireCount++; [LINE] public synchronized void acquire() throws InterruptedException { [EOL]     if (isShutdown()) { [EOL]         throw new IllegalStateException("TimedSemaphore is shut down!"); [EOL]     } [EOL]     if (task == null) { [EOL]         task = startTimer(); [EOL]     } [EOL]     boolean canPass = false; [EOL]     do { [EOL]         canPass = getLimit() <= NO_LIMIT || acquireCount < getLimit(); [EOL]         if (!canPass) { [EOL]             wait(); [EOL]         } else { [EOL]             acquireCount++; [EOL]         } [EOL]     } while (!canPass); [EOL] } 
 [LINE] return period; [LINE] public long getPeriod() { [EOL]     return period; [EOL] } 
 [LINE] return getExecutorService().scheduleAtFixedRate(new Runnable() { [LINE] protected ScheduledFuture<?> startTimer() { [EOL]     return getExecutorService().scheduleAtFixedRate(new Runnable() { [EOL]  [EOL]         @Override [EOL]         public void run() { [EOL]             endOfPeriod(); [EOL]         } [EOL]     }, getPeriod(), getPeriod(), getUnit()); [EOL] } 
 [LINE] endOfPeriod(); [LINE] @Override [EOL] public void run() { [EOL]     endOfPeriod(); [EOL] } 
 [LINE] lastCallsPerPeriod = acquireCount; [LINE] synchronized void endOfPeriod() { [EOL]     lastCallsPerPeriod = acquireCount; [EOL]     totalAcquireCount += acquireCount; [EOL]     periodCount++; [EOL]     acquireCount = 0; [EOL]     notifyAll(); [EOL] } 
lang3/reflect/ConstructorUtils.java
 [LINE] final Constructor<T> ctor = getMatchingAccessibleConstructor(cls, parameterTypes); [LINE] public static <T> T invokeConstructor(final Class<T> cls, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException { [EOL]     if (parameterTypes == null) { [EOL]         parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY; [EOL]     } [EOL]     if (args == null) { [EOL]         args = ArrayUtils.EMPTY_OBJECT_ARRAY; [EOL]     } [EOL]     final Constructor<T> ctor = getMatchingAccessibleConstructor(cls, parameterTypes); [EOL]     if (ctor == null) { [EOL]         throw new NoSuchMethodException("No such accessible constructor on object: " + cls.getName()); [EOL]     } [EOL]     return ctor.newInstance(args); [EOL] } 
 [LINE] final Constructor<T> ctor = getAccessibleConstructor(cls, parameterTypes); [LINE] public static <T> T invokeExactConstructor(final Class<T> cls, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException { [EOL]     if (args == null) { [EOL]         args = ArrayUtils.EMPTY_OBJECT_ARRAY; [EOL]     } [EOL]     if (parameterTypes == null) { [EOL]         parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY; [EOL]     } [EOL]     final Constructor<T> ctor = getAccessibleConstructor(cls, parameterTypes); [EOL]     if (ctor == null) { [EOL]         throw new NoSuchMethodException("No such accessible constructor on object: " + cls.getName()); [EOL]     } [EOL]     return ctor.newInstance(args); [EOL] } 
 [LINE] Constructor<T> result = null; [LINE] public static <T> Constructor<T> getMatchingAccessibleConstructor(final Class<T> cls, final Class<?>... parameterTypes) { [EOL]     try { [EOL]         final Constructor<T> ctor = cls.getConstructor(parameterTypes); [EOL]         MemberUtils.setAccessibleWorkaround(ctor); [EOL]         return ctor; [EOL]     } catch (final NoSuchMethodException e) { [EOL]     } [EOL]     Constructor<T> result = null; [EOL]     final Constructor<?>[] ctors = cls.getConstructors(); [EOL]     for (Constructor<?> ctor : ctors) { [EOL]         if (ClassUtils.isAssignable(parameterTypes, ctor.getParameterTypes(), true)) { [EOL]             ctor = getAccessibleConstructor(ctor); [EOL]             if (ctor != null) { [EOL]                 MemberUtils.setAccessibleWorkaround(ctor); [EOL]                 if (result == null || MemberUtils.compareParameterTypes(ctor.getParameterTypes(), result.getParameterTypes(), parameterTypes) < 0) { [EOL]                     @SuppressWarnings("unchecked") [EOL]                     final Constructor<T> constructor = (Constructor<T>) ctor; [EOL]                     result = constructor; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return result; [EOL] } 
lang3/concurrent/ConcurrentUtils.java
 [LINE] if (ex == null || ex.getCause() == null) { [LINE] public static ConcurrentException extractCause(final ExecutionException ex) { [EOL]     if (ex == null || ex.getCause() == null) { [EOL]         return null; [EOL]     } [EOL]     throwCause(ex); [EOL]     return new ConcurrentException(ex.getMessage(), ex.getCause()); [EOL] } 
 [LINE] return ex; [LINE] static Throwable checkedException(final Throwable ex) { [EOL]     if (ex != null && !(ex instanceof RuntimeException) && !(ex instanceof Error)) { [EOL]         return ex; [EOL]     } else { [EOL]         throw new IllegalArgumentException("Not a checked exception: " + ex); [EOL]     } [EOL] } 
 [LINE] return initializer != null ? initializer.get() : null; [LINE] public static <T> T initialize(final ConcurrentInitializer<T> initializer) throws ConcurrentException { [EOL]     return initializer != null ? initializer.get() : null; [EOL] } 
 [LINE] return initialize(initializer); [LINE] public static <T> T initializeUnchecked(final ConcurrentInitializer<T> initializer) { [EOL]     try { [EOL]         return initialize(initializer); [EOL]     } catch (final ConcurrentException cex) { [EOL]         throw new ConcurrentRuntimeException(cex.getCause()); [EOL]     } [EOL] } 
 [LINE] return putIfAbsent(map, key, init.get()); [LINE] public static <K, V> V createIfAbsent(final ConcurrentMap<K, V> map, final K key, final ConcurrentInitializer<V> init) throws ConcurrentException { [EOL]     if (map == null || init == null) { [EOL]         return null; [EOL]     } [EOL]     final V value = map.get(key); [EOL]     if (value == null) { [EOL]         return putIfAbsent(map, key, init.get()); [EOL]     } [EOL]     return value; [EOL] } 
 [LINE] return false; [LINE] @Override [EOL] public boolean cancel(final boolean mayInterruptIfRunning) { [EOL]     return false; [EOL] } 
lang3/SystemUtils.java
 [LINE] return isOSMatch(OS_NAME, OS_VERSION, osNamePrefix, osVersionPrefix); [LINE] private static boolean getOSMatches(final String osNamePrefix, final String osVersionPrefix) { [EOL]     return isOSMatch(OS_NAME, OS_VERSION, osNamePrefix, osVersionPrefix); [EOL] } 
 [LINE] if (version == null) { [LINE] static boolean isJavaVersionMatch(final String version, final String versionPrefix) { [EOL]     if (version == null) { [EOL]         return false; [EOL]     } [EOL]     return version.startsWith(versionPrefix); [EOL] } 
lang3/AnnotationUtils.java
 [LINE] Class<? extends Annotation> annotationType = null; [LINE] @Override [EOL] protected String getShortClassName(final java.lang.Class<?> cls) { [EOL]     Class<? extends Annotation> annotationType = null; [EOL]     for (final Class<?> iface : ClassUtils.getAllInterfaces(cls)) { [EOL]         if (Annotation.class.isAssignableFrom(iface)) { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Class<? extends Annotation> found = (Class<? extends Annotation>) iface; [EOL]             annotationType = found; [EOL]             break; [EOL]         } [EOL]     } [EOL]     return new StringBuilder(annotationType == null ? "" : annotationType.getName()).insert(0, '@').toString(); [EOL] } 
 [LINE] if (value instanceof Annotation) { [LINE] @Override [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value) { [EOL]     if (value instanceof Annotation) { [EOL]         value = AnnotationUtils.toString((Annotation) value); [EOL]     } [EOL]     super.appendDetail(buffer, fieldName, value); [EOL] } 
 [LINE] super.appendDetail(buffer, fieldName, value); [LINE] @Override [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value) { [EOL]     if (value instanceof Annotation) { [EOL]         value = AnnotationUtils.toString((Annotation) value); [EOL]     } [EOL]     super.appendDetail(buffer, fieldName, value); [EOL] } 
 [LINE] return true; [LINE] public static boolean equals(final Annotation a1, final Annotation a2) { [EOL]     if (a1 == a2) { [EOL]         return true; [EOL]     } [EOL]     if (a1 == null || a2 == null) { [EOL]         return false; [EOL]     } [EOL]     final Class<? extends Annotation> type = a1.annotationType(); [EOL]     final Class<? extends Annotation> type2 = a2.annotationType(); [EOL]     Validate.notNull(type, "Annotation %s with null annotationType()", a1); [EOL]     Validate.notNull(type2, "Annotation %s with null annotationType()", a2); [EOL]     if (!type.equals(type2)) { [EOL]         return false; [EOL]     } [EOL]     try { [EOL]         for (final Method m : type.getDeclaredMethods()) { [EOL]             if (m.getParameterTypes().length == 0 && isValidAnnotationMemberType(m.getReturnType())) { [EOL]                 final Object v1 = m.invoke(a1); [EOL]                 final Object v2 = m.invoke(a2); [EOL]                 if (!memberEquals(m.getReturnType(), v1, v2)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } catch (final IllegalAccessException ex) { [EOL]         return false; [EOL]     } catch (final InvocationTargetException ex) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] return false; [LINE] public static boolean equals(final Annotation a1, final Annotation a2) { [EOL]     if (a1 == a2) { [EOL]         return true; [EOL]     } [EOL]     if (a1 == null || a2 == null) { [EOL]         return false; [EOL]     } [EOL]     final Class<? extends Annotation> type = a1.annotationType(); [EOL]     final Class<? extends Annotation> type2 = a2.annotationType(); [EOL]     Validate.notNull(type, "Annotation %s with null annotationType()", a1); [EOL]     Validate.notNull(type2, "Annotation %s with null annotationType()", a2); [EOL]     if (!type.equals(type2)) { [EOL]         return false; [EOL]     } [EOL]     try { [EOL]         for (final Method m : type.getDeclaredMethods()) { [EOL]             if (m.getParameterTypes().length == 0 && isValidAnnotationMemberType(m.getReturnType())) { [EOL]                 final Object v1 = m.invoke(a1); [EOL]                 final Object v2 = m.invoke(a2); [EOL]                 if (!memberEquals(m.getReturnType(), v1, v2)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } catch (final IllegalAccessException ex) { [EOL]         return false; [EOL]     } catch (final InvocationTargetException ex) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] Validate.notNull(type2, "Annotation %s with null annotationType()", a2); [LINE] public static boolean equals(final Annotation a1, final Annotation a2) { [EOL]     if (a1 == a2) { [EOL]         return true; [EOL]     } [EOL]     if (a1 == null || a2 == null) { [EOL]         return false; [EOL]     } [EOL]     final Class<? extends Annotation> type = a1.annotationType(); [EOL]     final Class<? extends Annotation> type2 = a2.annotationType(); [EOL]     Validate.notNull(type, "Annotation %s with null annotationType()", a1); [EOL]     Validate.notNull(type2, "Annotation %s with null annotationType()", a2); [EOL]     if (!type.equals(type2)) { [EOL]         return false; [EOL]     } [EOL]     try { [EOL]         for (final Method m : type.getDeclaredMethods()) { [EOL]             if (m.getParameterTypes().length == 0 && isValidAnnotationMemberType(m.getReturnType())) { [EOL]                 final Object v1 = m.invoke(a1); [EOL]                 final Object v2 = m.invoke(a2); [EOL]                 if (!memberEquals(m.getReturnType(), v1, v2)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } catch (final IllegalAccessException ex) { [EOL]         return false; [EOL]     } catch (final InvocationTargetException ex) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] for (final Method m : type.getDeclaredMethods()) { [LINE] public static boolean equals(final Annotation a1, final Annotation a2) { [EOL]     if (a1 == a2) { [EOL]         return true; [EOL]     } [EOL]     if (a1 == null || a2 == null) { [EOL]         return false; [EOL]     } [EOL]     final Class<? extends Annotation> type = a1.annotationType(); [EOL]     final Class<? extends Annotation> type2 = a2.annotationType(); [EOL]     Validate.notNull(type, "Annotation %s with null annotationType()", a1); [EOL]     Validate.notNull(type2, "Annotation %s with null annotationType()", a2); [EOL]     if (!type.equals(type2)) { [EOL]         return false; [EOL]     } [EOL]     try { [EOL]         for (final Method m : type.getDeclaredMethods()) { [EOL]             if (m.getParameterTypes().length == 0 && isValidAnnotationMemberType(m.getReturnType())) { [EOL]                 final Object v1 = m.invoke(a1); [EOL]                 final Object v2 = m.invoke(a2); [EOL]                 if (!memberEquals(m.getReturnType(), v1, v2)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } catch (final IllegalAccessException ex) { [EOL]         return false; [EOL]     } catch (final InvocationTargetException ex) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] for (final Method m : type.getDeclaredMethods()) { [LINE] public static int hashCode(final Annotation a) { [EOL]     int result = 0; [EOL]     final Class<? extends Annotation> type = a.annotationType(); [EOL]     for (final Method m : type.getDeclaredMethods()) { [EOL]         try { [EOL]             final Object value = m.invoke(a); [EOL]             if (value == null) { [EOL]                 throw new IllegalStateException(String.format("Annotation method %s returned null", m)); [EOL]             } [EOL]             result += hashMember(m.getName(), value); [EOL]         } catch (final RuntimeException ex) { [EOL]             throw ex; [EOL]         } catch (final Exception ex) { [EOL]             throw new RuntimeException(ex); [EOL]         } [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] for (final Method m : a.annotationType().getDeclaredMethods()) { [LINE] public static String toString(final Annotation a) { [EOL]     final ToStringBuilder builder = new ToStringBuilder(a, TO_STRING_STYLE); [EOL]     for (final Method m : a.annotationType().getDeclaredMethods()) { [EOL]         if (m.getParameterTypes().length > 0) { [EOL]             continue; [EOL]         } [EOL]         try { [EOL]             builder.append(m.getName(), m.invoke(a)); [EOL]         } catch (final RuntimeException ex) { [EOL]             throw ex; [EOL]         } catch (final Exception ex) { [EOL]             throw new RuntimeException(ex); [EOL]         } [EOL]     } [EOL]     return builder.build(); [EOL] } 
 [LINE] return builder.build(); [LINE] public static String toString(final Annotation a) { [EOL]     final ToStringBuilder builder = new ToStringBuilder(a, TO_STRING_STYLE); [EOL]     for (final Method m : a.annotationType().getDeclaredMethods()) { [EOL]         if (m.getParameterTypes().length > 0) { [EOL]             continue; [EOL]         } [EOL]         try { [EOL]             builder.append(m.getName(), m.invoke(a)); [EOL]         } catch (final RuntimeException ex) { [EOL]             throw ex; [EOL]         } catch (final Exception ex) { [EOL]             throw new RuntimeException(ex); [EOL]         } [EOL]     } [EOL]     return builder.build(); [EOL] } 
 [LINE] type = type.getComponentType(); [LINE] public static boolean isValidAnnotationMemberType(Class<?> type) { [EOL]     if (type == null) { [EOL]         return false; [EOL]     } [EOL]     if (type.isArray()) { [EOL]         type = type.getComponentType(); [EOL]     } [EOL]     return type.isPrimitive() || type.isEnum() || type.isAnnotation() || String.class.equals(type) || Class.class.equals(type); [EOL] } 
 [LINE] final int part1 = name.hashCode() * 127; [LINE] private static int hashMember(final String name, final Object value) { [EOL]     final int part1 = name.hashCode() * 127; [EOL]     if (value.getClass().isArray()) { [EOL]         return part1 ^ arrayMemberHash(value.getClass().getComponentType(), value); [EOL]     } [EOL]     if (value instanceof Annotation) { [EOL]         return part1 ^ hashCode((Annotation) value); [EOL]     } [EOL]     return part1 ^ value.hashCode(); [EOL] } 
 [LINE] if (value instanceof Annotation) { [LINE] private static int hashMember(final String name, final Object value) { [EOL]     final int part1 = name.hashCode() * 127; [EOL]     if (value.getClass().isArray()) { [EOL]         return part1 ^ arrayMemberHash(value.getClass().getComponentType(), value); [EOL]     } [EOL]     if (value instanceof Annotation) { [EOL]         return part1 ^ hashCode((Annotation) value); [EOL]     } [EOL]     return part1 ^ value.hashCode(); [EOL] } 
 [LINE] if (type.isArray()) { [LINE] private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2) { [EOL]     if (o1 == o2) { [EOL]         return true; [EOL]     } [EOL]     if (o1 == null || o2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (type.isArray()) { [EOL]         return arrayMemberEquals(type.getComponentType(), o1, o2); [EOL]     } [EOL]     if (type.isAnnotation()) { [EOL]         return equals((Annotation) o1, (Annotation) o2); [EOL]     } [EOL]     return o1.equals(o2); [EOL] } 
 [LINE] if (componentType.equals(Byte.TYPE)) { [LINE] private static boolean arrayMemberEquals(final Class<?> componentType, final Object o1, final Object o2) { [EOL]     if (componentType.isAnnotation()) { [EOL]         return annotationArrayMemberEquals((Annotation[]) o1, (Annotation[]) o2); [EOL]     } [EOL]     if (componentType.equals(Byte.TYPE)) { [EOL]         return Arrays.equals((byte[]) o1, (byte[]) o2); [EOL]     } [EOL]     if (componentType.equals(Short.TYPE)) { [EOL]         return Arrays.equals((short[]) o1, (short[]) o2); [EOL]     } [EOL]     if (componentType.equals(Integer.TYPE)) { [EOL]         return Arrays.equals((int[]) o1, (int[]) o2); [EOL]     } [EOL]     if (componentType.equals(Character.TYPE)) { [EOL]         return Arrays.equals((char[]) o1, (char[]) o2); [EOL]     } [EOL]     if (componentType.equals(Long.TYPE)) { [EOL]         return Arrays.equals((long[]) o1, (long[]) o2); [EOL]     } [EOL]     if (componentType.equals(Float.TYPE)) { [EOL]         return Arrays.equals((float[]) o1, (float[]) o2); [EOL]     } [EOL]     if (componentType.equals(Double.TYPE)) { [EOL]         return Arrays.equals((double[]) o1, (double[]) o2); [EOL]     } [EOL]     if (componentType.equals(Boolean.TYPE)) { [EOL]         return Arrays.equals((boolean[]) o1, (boolean[]) o2); [EOL]     } [EOL]     return Arrays.equals((Object[]) o1, (Object[]) o2); [EOL] } 
 [LINE] return Arrays.equals((byte[]) o1, (byte[]) o2); [LINE] private static boolean arrayMemberEquals(final Class<?> componentType, final Object o1, final Object o2) { [EOL]     if (componentType.isAnnotation()) { [EOL]         return annotationArrayMemberEquals((Annotation[]) o1, (Annotation[]) o2); [EOL]     } [EOL]     if (componentType.equals(Byte.TYPE)) { [EOL]         return Arrays.equals((byte[]) o1, (byte[]) o2); [EOL]     } [EOL]     if (componentType.equals(Short.TYPE)) { [EOL]         return Arrays.equals((short[]) o1, (short[]) o2); [EOL]     } [EOL]     if (componentType.equals(Integer.TYPE)) { [EOL]         return Arrays.equals((int[]) o1, (int[]) o2); [EOL]     } [EOL]     if (componentType.equals(Character.TYPE)) { [EOL]         return Arrays.equals((char[]) o1, (char[]) o2); [EOL]     } [EOL]     if (componentType.equals(Long.TYPE)) { [EOL]         return Arrays.equals((long[]) o1, (long[]) o2); [EOL]     } [EOL]     if (componentType.equals(Float.TYPE)) { [EOL]         return Arrays.equals((float[]) o1, (float[]) o2); [EOL]     } [EOL]     if (componentType.equals(Double.TYPE)) { [EOL]         return Arrays.equals((double[]) o1, (double[]) o2); [EOL]     } [EOL]     if (componentType.equals(Boolean.TYPE)) { [EOL]         return Arrays.equals((boolean[]) o1, (boolean[]) o2); [EOL]     } [EOL]     return Arrays.equals((Object[]) o1, (Object[]) o2); [EOL] } 
 [LINE] return Arrays.equals((short[]) o1, (short[]) o2); [LINE] private static boolean arrayMemberEquals(final Class<?> componentType, final Object o1, final Object o2) { [EOL]     if (componentType.isAnnotation()) { [EOL]         return annotationArrayMemberEquals((Annotation[]) o1, (Annotation[]) o2); [EOL]     } [EOL]     if (componentType.equals(Byte.TYPE)) { [EOL]         return Arrays.equals((byte[]) o1, (byte[]) o2); [EOL]     } [EOL]     if (componentType.equals(Short.TYPE)) { [EOL]         return Arrays.equals((short[]) o1, (short[]) o2); [EOL]     } [EOL]     if (componentType.equals(Integer.TYPE)) { [EOL]         return Arrays.equals((int[]) o1, (int[]) o2); [EOL]     } [EOL]     if (componentType.equals(Character.TYPE)) { [EOL]         return Arrays.equals((char[]) o1, (char[]) o2); [EOL]     } [EOL]     if (componentType.equals(Long.TYPE)) { [EOL]         return Arrays.equals((long[]) o1, (long[]) o2); [EOL]     } [EOL]     if (componentType.equals(Float.TYPE)) { [EOL]         return Arrays.equals((float[]) o1, (float[]) o2); [EOL]     } [EOL]     if (componentType.equals(Double.TYPE)) { [EOL]         return Arrays.equals((double[]) o1, (double[]) o2); [EOL]     } [EOL]     if (componentType.equals(Boolean.TYPE)) { [EOL]         return Arrays.equals((boolean[]) o1, (boolean[]) o2); [EOL]     } [EOL]     return Arrays.equals((Object[]) o1, (Object[]) o2); [EOL] } 
 [LINE] return Arrays.equals((float[]) o1, (float[]) o2); [LINE] private static boolean arrayMemberEquals(final Class<?> componentType, final Object o1, final Object o2) { [EOL]     if (componentType.isAnnotation()) { [EOL]         return annotationArrayMemberEquals((Annotation[]) o1, (Annotation[]) o2); [EOL]     } [EOL]     if (componentType.equals(Byte.TYPE)) { [EOL]         return Arrays.equals((byte[]) o1, (byte[]) o2); [EOL]     } [EOL]     if (componentType.equals(Short.TYPE)) { [EOL]         return Arrays.equals((short[]) o1, (short[]) o2); [EOL]     } [EOL]     if (componentType.equals(Integer.TYPE)) { [EOL]         return Arrays.equals((int[]) o1, (int[]) o2); [EOL]     } [EOL]     if (componentType.equals(Character.TYPE)) { [EOL]         return Arrays.equals((char[]) o1, (char[]) o2); [EOL]     } [EOL]     if (componentType.equals(Long.TYPE)) { [EOL]         return Arrays.equals((long[]) o1, (long[]) o2); [EOL]     } [EOL]     if (componentType.equals(Float.TYPE)) { [EOL]         return Arrays.equals((float[]) o1, (float[]) o2); [EOL]     } [EOL]     if (componentType.equals(Double.TYPE)) { [EOL]         return Arrays.equals((double[]) o1, (double[]) o2); [EOL]     } [EOL]     if (componentType.equals(Boolean.TYPE)) { [EOL]         return Arrays.equals((boolean[]) o1, (boolean[]) o2); [EOL]     } [EOL]     return Arrays.equals((Object[]) o1, (Object[]) o2); [EOL] } 
 [LINE] if (componentType.equals(Double.TYPE)) { [LINE] private static boolean arrayMemberEquals(final Class<?> componentType, final Object o1, final Object o2) { [EOL]     if (componentType.isAnnotation()) { [EOL]         return annotationArrayMemberEquals((Annotation[]) o1, (Annotation[]) o2); [EOL]     } [EOL]     if (componentType.equals(Byte.TYPE)) { [EOL]         return Arrays.equals((byte[]) o1, (byte[]) o2); [EOL]     } [EOL]     if (componentType.equals(Short.TYPE)) { [EOL]         return Arrays.equals((short[]) o1, (short[]) o2); [EOL]     } [EOL]     if (componentType.equals(Integer.TYPE)) { [EOL]         return Arrays.equals((int[]) o1, (int[]) o2); [EOL]     } [EOL]     if (componentType.equals(Character.TYPE)) { [EOL]         return Arrays.equals((char[]) o1, (char[]) o2); [EOL]     } [EOL]     if (componentType.equals(Long.TYPE)) { [EOL]         return Arrays.equals((long[]) o1, (long[]) o2); [EOL]     } [EOL]     if (componentType.equals(Float.TYPE)) { [EOL]         return Arrays.equals((float[]) o1, (float[]) o2); [EOL]     } [EOL]     if (componentType.equals(Double.TYPE)) { [EOL]         return Arrays.equals((double[]) o1, (double[]) o2); [EOL]     } [EOL]     if (componentType.equals(Boolean.TYPE)) { [EOL]         return Arrays.equals((boolean[]) o1, (boolean[]) o2); [EOL]     } [EOL]     return Arrays.equals((Object[]) o1, (Object[]) o2); [EOL] } 
 [LINE] if (componentType.equals(Boolean.TYPE)) { [LINE] private static boolean arrayMemberEquals(final Class<?> componentType, final Object o1, final Object o2) { [EOL]     if (componentType.isAnnotation()) { [EOL]         return annotationArrayMemberEquals((Annotation[]) o1, (Annotation[]) o2); [EOL]     } [EOL]     if (componentType.equals(Byte.TYPE)) { [EOL]         return Arrays.equals((byte[]) o1, (byte[]) o2); [EOL]     } [EOL]     if (componentType.equals(Short.TYPE)) { [EOL]         return Arrays.equals((short[]) o1, (short[]) o2); [EOL]     } [EOL]     if (componentType.equals(Integer.TYPE)) { [EOL]         return Arrays.equals((int[]) o1, (int[]) o2); [EOL]     } [EOL]     if (componentType.equals(Character.TYPE)) { [EOL]         return Arrays.equals((char[]) o1, (char[]) o2); [EOL]     } [EOL]     if (componentType.equals(Long.TYPE)) { [EOL]         return Arrays.equals((long[]) o1, (long[]) o2); [EOL]     } [EOL]     if (componentType.equals(Float.TYPE)) { [EOL]         return Arrays.equals((float[]) o1, (float[]) o2); [EOL]     } [EOL]     if (componentType.equals(Double.TYPE)) { [EOL]         return Arrays.equals((double[]) o1, (double[]) o2); [EOL]     } [EOL]     if (componentType.equals(Boolean.TYPE)) { [EOL]         return Arrays.equals((boolean[]) o1, (boolean[]) o2); [EOL]     } [EOL]     return Arrays.equals((Object[]) o1, (Object[]) o2); [EOL] } 
 [LINE] if (componentType.equals(Byte.TYPE)) { [LINE] private static int arrayMemberHash(final Class<?> componentType, final Object o) { [EOL]     if (componentType.equals(Byte.TYPE)) { [EOL]         return Arrays.hashCode((byte[]) o); [EOL]     } [EOL]     if (componentType.equals(Short.TYPE)) { [EOL]         return Arrays.hashCode((short[]) o); [EOL]     } [EOL]     if (componentType.equals(Integer.TYPE)) { [EOL]         return Arrays.hashCode((int[]) o); [EOL]     } [EOL]     if (componentType.equals(Character.TYPE)) { [EOL]         return Arrays.hashCode((char[]) o); [EOL]     } [EOL]     if (componentType.equals(Long.TYPE)) { [EOL]         return Arrays.hashCode((long[]) o); [EOL]     } [EOL]     if (componentType.equals(Float.TYPE)) { [EOL]         return Arrays.hashCode((float[]) o); [EOL]     } [EOL]     if (componentType.equals(Double.TYPE)) { [EOL]         return Arrays.hashCode((double[]) o); [EOL]     } [EOL]     if (componentType.equals(Boolean.TYPE)) { [EOL]         return Arrays.hashCode((boolean[]) o); [EOL]     } [EOL]     return Arrays.hashCode((Object[]) o); [EOL] } 
 [LINE] if (componentType.equals(Integer.TYPE)) { [LINE] private static int arrayMemberHash(final Class<?> componentType, final Object o) { [EOL]     if (componentType.equals(Byte.TYPE)) { [EOL]         return Arrays.hashCode((byte[]) o); [EOL]     } [EOL]     if (componentType.equals(Short.TYPE)) { [EOL]         return Arrays.hashCode((short[]) o); [EOL]     } [EOL]     if (componentType.equals(Integer.TYPE)) { [EOL]         return Arrays.hashCode((int[]) o); [EOL]     } [EOL]     if (componentType.equals(Character.TYPE)) { [EOL]         return Arrays.hashCode((char[]) o); [EOL]     } [EOL]     if (componentType.equals(Long.TYPE)) { [EOL]         return Arrays.hashCode((long[]) o); [EOL]     } [EOL]     if (componentType.equals(Float.TYPE)) { [EOL]         return Arrays.hashCode((float[]) o); [EOL]     } [EOL]     if (componentType.equals(Double.TYPE)) { [EOL]         return Arrays.hashCode((double[]) o); [EOL]     } [EOL]     if (componentType.equals(Boolean.TYPE)) { [EOL]         return Arrays.hashCode((boolean[]) o); [EOL]     } [EOL]     return Arrays.hashCode((Object[]) o); [EOL] } 
 [LINE] if (componentType.equals(Character.TYPE)) { [LINE] private static int arrayMemberHash(final Class<?> componentType, final Object o) { [EOL]     if (componentType.equals(Byte.TYPE)) { [EOL]         return Arrays.hashCode((byte[]) o); [EOL]     } [EOL]     if (componentType.equals(Short.TYPE)) { [EOL]         return Arrays.hashCode((short[]) o); [EOL]     } [EOL]     if (componentType.equals(Integer.TYPE)) { [EOL]         return Arrays.hashCode((int[]) o); [EOL]     } [EOL]     if (componentType.equals(Character.TYPE)) { [EOL]         return Arrays.hashCode((char[]) o); [EOL]     } [EOL]     if (componentType.equals(Long.TYPE)) { [EOL]         return Arrays.hashCode((long[]) o); [EOL]     } [EOL]     if (componentType.equals(Float.TYPE)) { [EOL]         return Arrays.hashCode((float[]) o); [EOL]     } [EOL]     if (componentType.equals(Double.TYPE)) { [EOL]         return Arrays.hashCode((double[]) o); [EOL]     } [EOL]     if (componentType.equals(Boolean.TYPE)) { [EOL]         return Arrays.hashCode((boolean[]) o); [EOL]     } [EOL]     return Arrays.hashCode((Object[]) o); [EOL] } 
 [LINE] if (componentType.equals(Double.TYPE)) { [LINE] private static int arrayMemberHash(final Class<?> componentType, final Object o) { [EOL]     if (componentType.equals(Byte.TYPE)) { [EOL]         return Arrays.hashCode((byte[]) o); [EOL]     } [EOL]     if (componentType.equals(Short.TYPE)) { [EOL]         return Arrays.hashCode((short[]) o); [EOL]     } [EOL]     if (componentType.equals(Integer.TYPE)) { [EOL]         return Arrays.hashCode((int[]) o); [EOL]     } [EOL]     if (componentType.equals(Character.TYPE)) { [EOL]         return Arrays.hashCode((char[]) o); [EOL]     } [EOL]     if (componentType.equals(Long.TYPE)) { [EOL]         return Arrays.hashCode((long[]) o); [EOL]     } [EOL]     if (componentType.equals(Float.TYPE)) { [EOL]         return Arrays.hashCode((float[]) o); [EOL]     } [EOL]     if (componentType.equals(Double.TYPE)) { [EOL]         return Arrays.hashCode((double[]) o); [EOL]     } [EOL]     if (componentType.equals(Boolean.TYPE)) { [EOL]         return Arrays.hashCode((boolean[]) o); [EOL]     } [EOL]     return Arrays.hashCode((Object[]) o); [EOL] } 
 [LINE] if (componentType.equals(Boolean.TYPE)) { [LINE] private static int arrayMemberHash(final Class<?> componentType, final Object o) { [EOL]     if (componentType.equals(Byte.TYPE)) { [EOL]         return Arrays.hashCode((byte[]) o); [EOL]     } [EOL]     if (componentType.equals(Short.TYPE)) { [EOL]         return Arrays.hashCode((short[]) o); [EOL]     } [EOL]     if (componentType.equals(Integer.TYPE)) { [EOL]         return Arrays.hashCode((int[]) o); [EOL]     } [EOL]     if (componentType.equals(Character.TYPE)) { [EOL]         return Arrays.hashCode((char[]) o); [EOL]     } [EOL]     if (componentType.equals(Long.TYPE)) { [EOL]         return Arrays.hashCode((long[]) o); [EOL]     } [EOL]     if (componentType.equals(Float.TYPE)) { [EOL]         return Arrays.hashCode((float[]) o); [EOL]     } [EOL]     if (componentType.equals(Double.TYPE)) { [EOL]         return Arrays.hashCode((double[]) o); [EOL]     } [EOL]     if (componentType.equals(Boolean.TYPE)) { [EOL]         return Arrays.hashCode((boolean[]) o); [EOL]     } [EOL]     return Arrays.hashCode((Object[]) o); [EOL] } 
 [LINE] return Arrays.hashCode((Object[]) o); [LINE] private static int arrayMemberHash(final Class<?> componentType, final Object o) { [EOL]     if (componentType.equals(Byte.TYPE)) { [EOL]         return Arrays.hashCode((byte[]) o); [EOL]     } [EOL]     if (componentType.equals(Short.TYPE)) { [EOL]         return Arrays.hashCode((short[]) o); [EOL]     } [EOL]     if (componentType.equals(Integer.TYPE)) { [EOL]         return Arrays.hashCode((int[]) o); [EOL]     } [EOL]     if (componentType.equals(Character.TYPE)) { [EOL]         return Arrays.hashCode((char[]) o); [EOL]     } [EOL]     if (componentType.equals(Long.TYPE)) { [EOL]         return Arrays.hashCode((long[]) o); [EOL]     } [EOL]     if (componentType.equals(Float.TYPE)) { [EOL]         return Arrays.hashCode((float[]) o); [EOL]     } [EOL]     if (componentType.equals(Double.TYPE)) { [EOL]         return Arrays.hashCode((double[]) o); [EOL]     } [EOL]     if (componentType.equals(Boolean.TYPE)) { [EOL]         return Arrays.hashCode((boolean[]) o); [EOL]     } [EOL]     return Arrays.hashCode((Object[]) o); [EOL] } 
lang3/event/EventUtils.java
 [LINE] return null; [LINE] @Override [EOL] public Object invoke(final Object proxy, final Method method, final Object[] parameters) throws Throwable { [EOL]     if (eventTypes.isEmpty() || eventTypes.contains(method.getName())) { [EOL]         if (hasMatchingParametersMethod(method)) { [EOL]             return MethodUtils.invokeMethod(target, methodName, parameters); [EOL]         } else { [EOL]             return MethodUtils.invokeMethod(target, methodName); [EOL]         } [EOL]     } [EOL]     return null; [EOL] } 
lang3/ArrayUtils.java
 [LINE] for (int i = 0; i < array.length; i++) { [LINE] public static Map<Object, Object> toMap(final Object[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     final Map<Object, Object> map = new HashMap<Object, Object>((int) (array.length * 1.5)); [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Object object = array[i]; [EOL]         if (object instanceof Map.Entry<?, ?>) { [EOL]             final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) object; [EOL]             map.put(entry.getKey(), entry.getValue()); [EOL]         } else if (object instanceof Object[]) { [EOL]             final Object[] entry = (Object[]) object; [EOL]             if (entry.length < 2) { [EOL]                 throw new IllegalArgumentException("Array element " + i + ", '" + object + "', has a length less than 2"); [EOL]             } [EOL]             map.put(entry[0], entry[1]); [EOL]         } else { [EOL]             throw new IllegalArgumentException("Array element " + i + ", '" + object + "', is neither of type Map.Entry nor an Array"); [EOL]         } [EOL]     } [EOL]     return map; [EOL] } 
 [LINE] map.put(entry[0], entry[1]); [LINE] public static Map<Object, Object> toMap(final Object[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     final Map<Object, Object> map = new HashMap<Object, Object>((int) (array.length * 1.5)); [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Object object = array[i]; [EOL]         if (object instanceof Map.Entry<?, ?>) { [EOL]             final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) object; [EOL]             map.put(entry.getKey(), entry.getValue()); [EOL]         } else if (object instanceof Object[]) { [EOL]             final Object[] entry = (Object[]) object; [EOL]             if (entry.length < 2) { [EOL]                 throw new IllegalArgumentException("Array element " + i + ", '" + object + "', has a length less than 2"); [EOL]             } [EOL]             map.put(entry[0], entry[1]); [EOL]         } else { [EOL]             throw new IllegalArgumentException("Array element " + i + ", '" + object + "', is neither of type Map.Entry nor an Array"); [EOL]         } [EOL]     } [EOL]     return map; [EOL] } 
 [LINE] return null; [LINE] public static <T> T[] clone(final T[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     return array.clone(); [EOL] } 
 [LINE] if (array == null) { [LINE] public static int[] clone(final int[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     return array.clone(); [EOL] } 
 [LINE] return array.clone(); [LINE] public static int[] clone(final int[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     return array.clone(); [EOL] } 
 [LINE] if (array == null) { [LINE] public static char[] clone(final char[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     return array.clone(); [EOL] } 
 [LINE] return null; [LINE] public static char[] clone(final char[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     return array.clone(); [EOL] } 
 [LINE] return array.clone(); [LINE] public static float[] clone(final float[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     return array.clone(); [EOL] } 
 [LINE] if (array == null) { [LINE] public static boolean[] clone(final boolean[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     return array.clone(); [EOL] } 
 [LINE] return EMPTY_STRING_ARRAY; [LINE] public static String[] nullToEmpty(final String[] array) { [EOL]     if (array == null || array.length == 0) { [EOL]         return EMPTY_STRING_ARRAY; [EOL]     } [EOL]     return array; [EOL] } 
 [LINE] return array; [LINE] public static String[] nullToEmpty(final String[] array) { [EOL]     if (array == null || array.length == 0) { [EOL]         return EMPTY_STRING_ARRAY; [EOL]     } [EOL]     return array; [EOL] } 
 [LINE] return EMPTY_INT_ARRAY; [LINE] public static int[] nullToEmpty(final int[] array) { [EOL]     if (array == null || array.length == 0) { [EOL]         return EMPTY_INT_ARRAY; [EOL]     } [EOL]     return array; [EOL] } 
 [LINE] if (array == null || array.length == 0) { [LINE] public static short[] nullToEmpty(final short[] array) { [EOL]     if (array == null || array.length == 0) { [EOL]         return EMPTY_SHORT_ARRAY; [EOL]     } [EOL]     return array; [EOL] } 
 [LINE] return EMPTY_CHAR_ARRAY; [LINE] public static char[] nullToEmpty(final char[] array) { [EOL]     if (array == null || array.length == 0) { [EOL]         return EMPTY_CHAR_ARRAY; [EOL]     } [EOL]     return array; [EOL] } 
 [LINE] if (array == null || array.length == 0) { [LINE] public static float[] nullToEmpty(final float[] array) { [EOL]     if (array == null || array.length == 0) { [EOL]         return EMPTY_FLOAT_ARRAY; [EOL]     } [EOL]     return array; [EOL] } 
 [LINE] return EMPTY_BOOLEAN_ARRAY; [LINE] public static boolean[] nullToEmpty(final boolean[] array) { [EOL]     if (array == null || array.length == 0) { [EOL]         return EMPTY_BOOLEAN_ARRAY; [EOL]     } [EOL]     return array; [EOL] } 
 [LINE] return EMPTY_INTEGER_OBJECT_ARRAY; [LINE] public static Integer[] nullToEmpty(final Integer[] array) { [EOL]     if (array == null || array.length == 0) { [EOL]         return EMPTY_INTEGER_OBJECT_ARRAY; [EOL]     } [EOL]     return array; [EOL] } 
 [LINE] if (endIndexExclusive > array.length) { [LINE] public static <T> T[] subarray(final T[] array, int startIndexInclusive, int endIndexExclusive) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (startIndexInclusive < 0) { [EOL]         startIndexInclusive = 0; [EOL]     } [EOL]     if (endIndexExclusive > array.length) { [EOL]         endIndexExclusive = array.length; [EOL]     } [EOL]     final int newSize = endIndexExclusive - startIndexInclusive; [EOL]     final Class<?> type = array.getClass().getComponentType(); [EOL]     if (newSize <= 0) { [EOL]         @SuppressWarnings("unchecked") [EOL]         final T[] emptyArray = (T[]) Array.newInstance(type, 0); [EOL]         return emptyArray; [EOL]     } [EOL]     @SuppressWarnings("unchecked") [EOL]     final T[] subarray = (T[]) Array.newInstance(type, newSize); [EOL]     System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [EOL]     return subarray; [EOL] } 
 [LINE] final Class<?> type = array.getClass().getComponentType(); [LINE] public static <T> T[] subarray(final T[] array, int startIndexInclusive, int endIndexExclusive) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (startIndexInclusive < 0) { [EOL]         startIndexInclusive = 0; [EOL]     } [EOL]     if (endIndexExclusive > array.length) { [EOL]         endIndexExclusive = array.length; [EOL]     } [EOL]     final int newSize = endIndexExclusive - startIndexInclusive; [EOL]     final Class<?> type = array.getClass().getComponentType(); [EOL]     if (newSize <= 0) { [EOL]         @SuppressWarnings("unchecked") [EOL]         final T[] emptyArray = (T[]) Array.newInstance(type, 0); [EOL]         return emptyArray; [EOL]     } [EOL]     @SuppressWarnings("unchecked") [EOL]     final T[] subarray = (T[]) Array.newInstance(type, newSize); [EOL]     System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [EOL]     return subarray; [EOL] } 
 [LINE] if (newSize <= 0) { [LINE] public static <T> T[] subarray(final T[] array, int startIndexInclusive, int endIndexExclusive) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (startIndexInclusive < 0) { [EOL]         startIndexInclusive = 0; [EOL]     } [EOL]     if (endIndexExclusive > array.length) { [EOL]         endIndexExclusive = array.length; [EOL]     } [EOL]     final int newSize = endIndexExclusive - startIndexInclusive; [EOL]     final Class<?> type = array.getClass().getComponentType(); [EOL]     if (newSize <= 0) { [EOL]         @SuppressWarnings("unchecked") [EOL]         final T[] emptyArray = (T[]) Array.newInstance(type, 0); [EOL]         return emptyArray; [EOL]     } [EOL]     @SuppressWarnings("unchecked") [EOL]     final T[] subarray = (T[]) Array.newInstance(type, newSize); [EOL]     System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [EOL]     return subarray; [EOL] } 
 [LINE] if (array == null) { [LINE] public static long[] subarray(final long[] array, int startIndexInclusive, int endIndexExclusive) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (startIndexInclusive < 0) { [EOL]         startIndexInclusive = 0; [EOL]     } [EOL]     if (endIndexExclusive > array.length) { [EOL]         endIndexExclusive = array.length; [EOL]     } [EOL]     final int newSize = endIndexExclusive - startIndexInclusive; [EOL]     if (newSize <= 0) { [EOL]         return EMPTY_LONG_ARRAY; [EOL]     } [EOL]     final long[] subarray = new long[newSize]; [EOL]     System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [EOL]     return subarray; [EOL] } 
 [LINE] if (startIndexInclusive < 0) { [LINE] public static long[] subarray(final long[] array, int startIndexInclusive, int endIndexExclusive) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (startIndexInclusive < 0) { [EOL]         startIndexInclusive = 0; [EOL]     } [EOL]     if (endIndexExclusive > array.length) { [EOL]         endIndexExclusive = array.length; [EOL]     } [EOL]     final int newSize = endIndexExclusive - startIndexInclusive; [EOL]     if (newSize <= 0) { [EOL]         return EMPTY_LONG_ARRAY; [EOL]     } [EOL]     final long[] subarray = new long[newSize]; [EOL]     System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [EOL]     return subarray; [EOL] } 
 [LINE] final int newSize = endIndexExclusive - startIndexInclusive; [LINE] public static long[] subarray(final long[] array, int startIndexInclusive, int endIndexExclusive) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (startIndexInclusive < 0) { [EOL]         startIndexInclusive = 0; [EOL]     } [EOL]     if (endIndexExclusive > array.length) { [EOL]         endIndexExclusive = array.length; [EOL]     } [EOL]     final int newSize = endIndexExclusive - startIndexInclusive; [EOL]     if (newSize <= 0) { [EOL]         return EMPTY_LONG_ARRAY; [EOL]     } [EOL]     final long[] subarray = new long[newSize]; [EOL]     System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [EOL]     return subarray; [EOL] } 
 [LINE] if (array == null) { [LINE] public static int[] subarray(final int[] array, int startIndexInclusive, int endIndexExclusive) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (startIndexInclusive < 0) { [EOL]         startIndexInclusive = 0; [EOL]     } [EOL]     if (endIndexExclusive > array.length) { [EOL]         endIndexExclusive = array.length; [EOL]     } [EOL]     final int newSize = endIndexExclusive - startIndexInclusive; [EOL]     if (newSize <= 0) { [EOL]         return EMPTY_INT_ARRAY; [EOL]     } [EOL]     final int[] subarray = new int[newSize]; [EOL]     System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [EOL]     return subarray; [EOL] } 
 [LINE] return null; [LINE] public static int[] subarray(final int[] array, int startIndexInclusive, int endIndexExclusive) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (startIndexInclusive < 0) { [EOL]         startIndexInclusive = 0; [EOL]     } [EOL]     if (endIndexExclusive > array.length) { [EOL]         endIndexExclusive = array.length; [EOL]     } [EOL]     final int newSize = endIndexExclusive - startIndexInclusive; [EOL]     if (newSize <= 0) { [EOL]         return EMPTY_INT_ARRAY; [EOL]     } [EOL]     final int[] subarray = new int[newSize]; [EOL]     System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [EOL]     return subarray; [EOL] } 
 [LINE] startIndexInclusive = 0; [LINE] public static int[] subarray(final int[] array, int startIndexInclusive, int endIndexExclusive) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (startIndexInclusive < 0) { [EOL]         startIndexInclusive = 0; [EOL]     } [EOL]     if (endIndexExclusive > array.length) { [EOL]         endIndexExclusive = array.length; [EOL]     } [EOL]     final int newSize = endIndexExclusive - startIndexInclusive; [EOL]     if (newSize <= 0) { [EOL]         return EMPTY_INT_ARRAY; [EOL]     } [EOL]     final int[] subarray = new int[newSize]; [EOL]     System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [EOL]     return subarray; [EOL] } 
 [LINE] endIndexExclusive = array.length; [LINE] public static int[] subarray(final int[] array, int startIndexInclusive, int endIndexExclusive) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (startIndexInclusive < 0) { [EOL]         startIndexInclusive = 0; [EOL]     } [EOL]     if (endIndexExclusive > array.length) { [EOL]         endIndexExclusive = array.length; [EOL]     } [EOL]     final int newSize = endIndexExclusive - startIndexInclusive; [EOL]     if (newSize <= 0) { [EOL]         return EMPTY_INT_ARRAY; [EOL]     } [EOL]     final int[] subarray = new int[newSize]; [EOL]     System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [EOL]     return subarray; [EOL] } 
 [LINE] if (newSize <= 0) { [LINE] public static short[] subarray(final short[] array, int startIndexInclusive, int endIndexExclusive) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (startIndexInclusive < 0) { [EOL]         startIndexInclusive = 0; [EOL]     } [EOL]     if (endIndexExclusive > array.length) { [EOL]         endIndexExclusive = array.length; [EOL]     } [EOL]     final int newSize = endIndexExclusive - startIndexInclusive; [EOL]     if (newSize <= 0) { [EOL]         return EMPTY_SHORT_ARRAY; [EOL]     } [EOL]     final short[] subarray = new short[newSize]; [EOL]     System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [EOL]     return subarray; [EOL] } 
 [LINE] return subarray; [LINE] public static short[] subarray(final short[] array, int startIndexInclusive, int endIndexExclusive) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (startIndexInclusive < 0) { [EOL]         startIndexInclusive = 0; [EOL]     } [EOL]     if (endIndexExclusive > array.length) { [EOL]         endIndexExclusive = array.length; [EOL]     } [EOL]     final int newSize = endIndexExclusive - startIndexInclusive; [EOL]     if (newSize <= 0) { [EOL]         return EMPTY_SHORT_ARRAY; [EOL]     } [EOL]     final short[] subarray = new short[newSize]; [EOL]     System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [EOL]     return subarray; [EOL] } 
 [LINE] if (array == null) { [LINE] public static char[] subarray(final char[] array, int startIndexInclusive, int endIndexExclusive) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (startIndexInclusive < 0) { [EOL]         startIndexInclusive = 0; [EOL]     } [EOL]     if (endIndexExclusive > array.length) { [EOL]         endIndexExclusive = array.length; [EOL]     } [EOL]     final int newSize = endIndexExclusive - startIndexInclusive; [EOL]     if (newSize <= 0) { [EOL]         return EMPTY_CHAR_ARRAY; [EOL]     } [EOL]     final char[] subarray = new char[newSize]; [EOL]     System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [EOL]     return subarray; [EOL] } 
 [LINE] if (startIndexInclusive < 0) { [LINE] public static char[] subarray(final char[] array, int startIndexInclusive, int endIndexExclusive) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (startIndexInclusive < 0) { [EOL]         startIndexInclusive = 0; [EOL]     } [EOL]     if (endIndexExclusive > array.length) { [EOL]         endIndexExclusive = array.length; [EOL]     } [EOL]     final int newSize = endIndexExclusive - startIndexInclusive; [EOL]     if (newSize <= 0) { [EOL]         return EMPTY_CHAR_ARRAY; [EOL]     } [EOL]     final char[] subarray = new char[newSize]; [EOL]     System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [EOL]     return subarray; [EOL] } 
 [LINE] if (endIndexExclusive > array.length) { [LINE] public static char[] subarray(final char[] array, int startIndexInclusive, int endIndexExclusive) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (startIndexInclusive < 0) { [EOL]         startIndexInclusive = 0; [EOL]     } [EOL]     if (endIndexExclusive > array.length) { [EOL]         endIndexExclusive = array.length; [EOL]     } [EOL]     final int newSize = endIndexExclusive - startIndexInclusive; [EOL]     if (newSize <= 0) { [EOL]         return EMPTY_CHAR_ARRAY; [EOL]     } [EOL]     final char[] subarray = new char[newSize]; [EOL]     System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [EOL]     return subarray; [EOL] } 
 [LINE] System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [LINE] public static char[] subarray(final char[] array, int startIndexInclusive, int endIndexExclusive) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (startIndexInclusive < 0) { [EOL]         startIndexInclusive = 0; [EOL]     } [EOL]     if (endIndexExclusive > array.length) { [EOL]         endIndexExclusive = array.length; [EOL]     } [EOL]     final int newSize = endIndexExclusive - startIndexInclusive; [EOL]     if (newSize <= 0) { [EOL]         return EMPTY_CHAR_ARRAY; [EOL]     } [EOL]     final char[] subarray = new char[newSize]; [EOL]     System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [EOL]     return subarray; [EOL] } 
 [LINE] if (array == null) { [LINE] public static byte[] subarray(final byte[] array, int startIndexInclusive, int endIndexExclusive) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (startIndexInclusive < 0) { [EOL]         startIndexInclusive = 0; [EOL]     } [EOL]     if (endIndexExclusive > array.length) { [EOL]         endIndexExclusive = array.length; [EOL]     } [EOL]     final int newSize = endIndexExclusive - startIndexInclusive; [EOL]     if (newSize <= 0) { [EOL]         return EMPTY_BYTE_ARRAY; [EOL]     } [EOL]     final byte[] subarray = new byte[newSize]; [EOL]     System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [EOL]     return subarray; [EOL] } 
 [LINE] return null; [LINE] public static double[] subarray(final double[] array, int startIndexInclusive, int endIndexExclusive) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (startIndexInclusive < 0) { [EOL]         startIndexInclusive = 0; [EOL]     } [EOL]     if (endIndexExclusive > array.length) { [EOL]         endIndexExclusive = array.length; [EOL]     } [EOL]     final int newSize = endIndexExclusive - startIndexInclusive; [EOL]     if (newSize <= 0) { [EOL]         return EMPTY_DOUBLE_ARRAY; [EOL]     } [EOL]     final double[] subarray = new double[newSize]; [EOL]     System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [EOL]     return subarray; [EOL] } 
 [LINE] return null; [LINE] public static float[] subarray(final float[] array, int startIndexInclusive, int endIndexExclusive) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (startIndexInclusive < 0) { [EOL]         startIndexInclusive = 0; [EOL]     } [EOL]     if (endIndexExclusive > array.length) { [EOL]         endIndexExclusive = array.length; [EOL]     } [EOL]     final int newSize = endIndexExclusive - startIndexInclusive; [EOL]     if (newSize <= 0) { [EOL]         return EMPTY_FLOAT_ARRAY; [EOL]     } [EOL]     final float[] subarray = new float[newSize]; [EOL]     System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [EOL]     return subarray; [EOL] } 
 [LINE] if (newSize <= 0) { [LINE] public static float[] subarray(final float[] array, int startIndexInclusive, int endIndexExclusive) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (startIndexInclusive < 0) { [EOL]         startIndexInclusive = 0; [EOL]     } [EOL]     if (endIndexExclusive > array.length) { [EOL]         endIndexExclusive = array.length; [EOL]     } [EOL]     final int newSize = endIndexExclusive - startIndexInclusive; [EOL]     if (newSize <= 0) { [EOL]         return EMPTY_FLOAT_ARRAY; [EOL]     } [EOL]     final float[] subarray = new float[newSize]; [EOL]     System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [EOL]     return subarray; [EOL] } 
 [LINE] final int newSize = endIndexExclusive - startIndexInclusive; [LINE] public static boolean[] subarray(final boolean[] array, int startIndexInclusive, int endIndexExclusive) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (startIndexInclusive < 0) { [EOL]         startIndexInclusive = 0; [EOL]     } [EOL]     if (endIndexExclusive > array.length) { [EOL]         endIndexExclusive = array.length; [EOL]     } [EOL]     final int newSize = endIndexExclusive - startIndexInclusive; [EOL]     if (newSize <= 0) { [EOL]         return EMPTY_BOOLEAN_ARRAY; [EOL]     } [EOL]     final boolean[] subarray = new boolean[newSize]; [EOL]     System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [EOL]     return subarray; [EOL] } 
 [LINE] final boolean[] subarray = new boolean[newSize]; [LINE] public static boolean[] subarray(final boolean[] array, int startIndexInclusive, int endIndexExclusive) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (startIndexInclusive < 0) { [EOL]         startIndexInclusive = 0; [EOL]     } [EOL]     if (endIndexExclusive > array.length) { [EOL]         endIndexExclusive = array.length; [EOL]     } [EOL]     final int newSize = endIndexExclusive - startIndexInclusive; [EOL]     if (newSize <= 0) { [EOL]         return EMPTY_BOOLEAN_ARRAY; [EOL]     } [EOL]     final boolean[] subarray = new boolean[newSize]; [EOL]     System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [EOL]     return subarray; [EOL] } 
 [LINE] return subarray; [LINE] public static boolean[] subarray(final boolean[] array, int startIndexInclusive, int endIndexExclusive) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (startIndexInclusive < 0) { [EOL]         startIndexInclusive = 0; [EOL]     } [EOL]     if (endIndexExclusive > array.length) { [EOL]         endIndexExclusive = array.length; [EOL]     } [EOL]     final int newSize = endIndexExclusive - startIndexInclusive; [EOL]     if (newSize <= 0) { [EOL]         return EMPTY_BOOLEAN_ARRAY; [EOL]     } [EOL]     final boolean[] subarray = new boolean[newSize]; [EOL]     System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [EOL]     return subarray; [EOL] } 
 [LINE] if ((array1 == null && array2 != null && array2.length > 0) || [LINE] public static boolean isSameLength(final Object[] array1, final Object[] array2) { [EOL]     if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] if ((array1 == null && array2 != null && array2.length > 0) || [LINE] public static boolean isSameLength(final char[] array1, final char[] array2) { [EOL]     if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] if ((array1 == null && array2 != null && array2.length > 0) || [LINE] public static boolean isSameLength(final byte[] array1, final byte[] array2) { [EOL]     if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] if ((array1 == null && array2 != null && array2.length > 0) || [LINE] public static boolean isSameLength(final boolean[] array1, final boolean[] array2) { [EOL]     if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] } 
 [LINE] return; [LINE] public static void reverse(final Object[] array) { [EOL]     if (array == null) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     int j = array.length - 1; [EOL]     Object tmp; [EOL]     while (j > i) { [EOL]         tmp = array[j]; [EOL]         array[j] = array[i]; [EOL]         array[i] = tmp; [EOL]         j--; [EOL]         i++; [EOL]     } [EOL] } 
 [LINE] tmp = array[j]; [LINE] public static void reverse(final Object[] array) { [EOL]     if (array == null) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     int j = array.length - 1; [EOL]     Object tmp; [EOL]     while (j > i) { [EOL]         tmp = array[j]; [EOL]         array[j] = array[i]; [EOL]         array[i] = tmp; [EOL]         j--; [EOL]         i++; [EOL]     } [EOL] } 
 [LINE] array[i] = tmp; [LINE] public static void reverse(final Object[] array) { [EOL]     if (array == null) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     int j = array.length - 1; [EOL]     Object tmp; [EOL]     while (j > i) { [EOL]         tmp = array[j]; [EOL]         array[j] = array[i]; [EOL]         array[i] = tmp; [EOL]         j--; [EOL]         i++; [EOL]     } [EOL] } 
 [LINE] while (j > i) { [LINE] public static void reverse(final long[] array) { [EOL]     if (array == null) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     int j = array.length - 1; [EOL]     long tmp; [EOL]     while (j > i) { [EOL]         tmp = array[j]; [EOL]         array[j] = array[i]; [EOL]         array[i] = tmp; [EOL]         j--; [EOL]         i++; [EOL]     } [EOL] } 
 [LINE] array[j] = array[i]; [LINE] public static void reverse(final long[] array) { [EOL]     if (array == null) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     int j = array.length - 1; [EOL]     long tmp; [EOL]     while (j > i) { [EOL]         tmp = array[j]; [EOL]         array[j] = array[i]; [EOL]         array[i] = tmp; [EOL]         j--; [EOL]         i++; [EOL]     } [EOL] } 
 [LINE] j--; [LINE] public static void reverse(final long[] array) { [EOL]     if (array == null) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     int j = array.length - 1; [EOL]     long tmp; [EOL]     while (j > i) { [EOL]         tmp = array[j]; [EOL]         array[j] = array[i]; [EOL]         array[i] = tmp; [EOL]         j--; [EOL]         i++; [EOL]     } [EOL] } 
 [LINE] i++; [LINE] public static void reverse(final long[] array) { [EOL]     if (array == null) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     int j = array.length - 1; [EOL]     long tmp; [EOL]     while (j > i) { [EOL]         tmp = array[j]; [EOL]         array[j] = array[i]; [EOL]         array[i] = tmp; [EOL]         j--; [EOL]         i++; [EOL]     } [EOL] } 
 [LINE] if (array == null) { [LINE] public static void reverse(final int[] array) { [EOL]     if (array == null) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     int j = array.length - 1; [EOL]     int tmp; [EOL]     while (j > i) { [EOL]         tmp = array[j]; [EOL]         array[j] = array[i]; [EOL]         array[i] = tmp; [EOL]         j--; [EOL]         i++; [EOL]     } [EOL] } 
 [LINE] int j = array.length - 1; [LINE] public static void reverse(final int[] array) { [EOL]     if (array == null) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     int j = array.length - 1; [EOL]     int tmp; [EOL]     while (j > i) { [EOL]         tmp = array[j]; [EOL]         array[j] = array[i]; [EOL]         array[i] = tmp; [EOL]         j--; [EOL]         i++; [EOL]     } [EOL] } 
 [LINE] while (j > i) { [LINE] public static void reverse(final int[] array) { [EOL]     if (array == null) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     int j = array.length - 1; [EOL]     int tmp; [EOL]     while (j > i) { [EOL]         tmp = array[j]; [EOL]         array[j] = array[i]; [EOL]         array[i] = tmp; [EOL]         j--; [EOL]         i++; [EOL]     } [EOL] } 
 [LINE] i++; [LINE] public static void reverse(final int[] array) { [EOL]     if (array == null) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     int j = array.length - 1; [EOL]     int tmp; [EOL]     while (j > i) { [EOL]         tmp = array[j]; [EOL]         array[j] = array[i]; [EOL]         array[i] = tmp; [EOL]         j--; [EOL]         i++; [EOL]     } [EOL] } 
 [LINE] return; [LINE] public static void reverse(final short[] array) { [EOL]     if (array == null) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     int j = array.length - 1; [EOL]     short tmp; [EOL]     while (j > i) { [EOL]         tmp = array[j]; [EOL]         array[j] = array[i]; [EOL]         array[i] = tmp; [EOL]         j--; [EOL]         i++; [EOL]     } [EOL] } 
 [LINE] short tmp; [LINE] public static void reverse(final short[] array) { [EOL]     if (array == null) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     int j = array.length - 1; [EOL]     short tmp; [EOL]     while (j > i) { [EOL]         tmp = array[j]; [EOL]         array[j] = array[i]; [EOL]         array[i] = tmp; [EOL]         j--; [EOL]         i++; [EOL]     } [EOL] } 
 [LINE] tmp = array[j]; [LINE] public static void reverse(final short[] array) { [EOL]     if (array == null) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     int j = array.length - 1; [EOL]     short tmp; [EOL]     while (j > i) { [EOL]         tmp = array[j]; [EOL]         array[j] = array[i]; [EOL]         array[i] = tmp; [EOL]         j--; [EOL]         i++; [EOL]     } [EOL] } 
 [LINE] if (array == null) { [LINE] public static void reverse(final char[] array) { [EOL]     if (array == null) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     int j = array.length - 1; [EOL]     char tmp; [EOL]     while (j > i) { [EOL]         tmp = array[j]; [EOL]         array[j] = array[i]; [EOL]         array[i] = tmp; [EOL]         j--; [EOL]         i++; [EOL]     } [EOL] } 
 [LINE] return; [LINE] public static void reverse(final char[] array) { [EOL]     if (array == null) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     int j = array.length - 1; [EOL]     char tmp; [EOL]     while (j > i) { [EOL]         tmp = array[j]; [EOL]         array[j] = array[i]; [EOL]         array[i] = tmp; [EOL]         j--; [EOL]         i++; [EOL]     } [EOL] } 
 [LINE] array[j] = array[i]; [LINE] public static void reverse(final char[] array) { [EOL]     if (array == null) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     int j = array.length - 1; [EOL]     char tmp; [EOL]     while (j > i) { [EOL]         tmp = array[j]; [EOL]         array[j] = array[i]; [EOL]         array[i] = tmp; [EOL]         j--; [EOL]         i++; [EOL]     } [EOL] } 
 [LINE] return; [LINE] public static void reverse(final byte[] array) { [EOL]     if (array == null) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     int j = array.length - 1; [EOL]     byte tmp; [EOL]     while (j > i) { [EOL]         tmp = array[j]; [EOL]         array[j] = array[i]; [EOL]         array[i] = tmp; [EOL]         j--; [EOL]         i++; [EOL]     } [EOL] } 
 [LINE] array[j] = array[i]; [LINE] public static void reverse(final byte[] array) { [EOL]     if (array == null) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     int j = array.length - 1; [EOL]     byte tmp; [EOL]     while (j > i) { [EOL]         tmp = array[j]; [EOL]         array[j] = array[i]; [EOL]         array[i] = tmp; [EOL]         j--; [EOL]         i++; [EOL]     } [EOL] } 
 [LINE] i++; [LINE] public static void reverse(final byte[] array) { [EOL]     if (array == null) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     int j = array.length - 1; [EOL]     byte tmp; [EOL]     while (j > i) { [EOL]         tmp = array[j]; [EOL]         array[j] = array[i]; [EOL]         array[i] = tmp; [EOL]         j--; [EOL]         i++; [EOL]     } [EOL] } 
 [LINE] while (j > i) { [LINE] public static void reverse(final double[] array) { [EOL]     if (array == null) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     int j = array.length - 1; [EOL]     double tmp; [EOL]     while (j > i) { [EOL]         tmp = array[j]; [EOL]         array[j] = array[i]; [EOL]         array[i] = tmp; [EOL]         j--; [EOL]         i++; [EOL]     } [EOL] } 
 [LINE] array[i] = tmp; [LINE] public static void reverse(final double[] array) { [EOL]     if (array == null) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     int j = array.length - 1; [EOL]     double tmp; [EOL]     while (j > i) { [EOL]         tmp = array[j]; [EOL]         array[j] = array[i]; [EOL]         array[i] = tmp; [EOL]         j--; [EOL]         i++; [EOL]     } [EOL] } 
 [LINE] j--; [LINE] public static void reverse(final double[] array) { [EOL]     if (array == null) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     int j = array.length - 1; [EOL]     double tmp; [EOL]     while (j > i) { [EOL]         tmp = array[j]; [EOL]         array[j] = array[i]; [EOL]         array[i] = tmp; [EOL]         j--; [EOL]         i++; [EOL]     } [EOL] } 
 [LINE] if (array == null) { [LINE] public static void reverse(final float[] array) { [EOL]     if (array == null) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     int j = array.length - 1; [EOL]     float tmp; [EOL]     while (j > i) { [EOL]         tmp = array[j]; [EOL]         array[j] = array[i]; [EOL]         array[i] = tmp; [EOL]         j--; [EOL]         i++; [EOL]     } [EOL] } 
 [LINE] int j = array.length - 1; [LINE] public static void reverse(final float[] array) { [EOL]     if (array == null) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     int j = array.length - 1; [EOL]     float tmp; [EOL]     while (j > i) { [EOL]         tmp = array[j]; [EOL]         array[j] = array[i]; [EOL]         array[i] = tmp; [EOL]         j--; [EOL]         i++; [EOL]     } [EOL] } 
 [LINE] int i = 0; [LINE] public static void reverse(final boolean[] array) { [EOL]     if (array == null) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     int j = array.length - 1; [EOL]     boolean tmp; [EOL]     while (j > i) { [EOL]         tmp = array[j]; [EOL]         array[j] = array[i]; [EOL]         array[i] = tmp; [EOL]         j--; [EOL]         i++; [EOL]     } [EOL] } 
 [LINE] int j = array.length - 1; [LINE] public static void reverse(final boolean[] array) { [EOL]     if (array == null) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     int j = array.length - 1; [EOL]     boolean tmp; [EOL]     while (j > i) { [EOL]         tmp = array[j]; [EOL]         array[j] = array[i]; [EOL]         array[i] = tmp; [EOL]         j--; [EOL]         i++; [EOL]     } [EOL] } 
 [LINE] while (j > i) { [LINE] public static void reverse(final boolean[] array) { [EOL]     if (array == null) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     int j = array.length - 1; [EOL]     boolean tmp; [EOL]     while (j > i) { [EOL]         tmp = array[j]; [EOL]         array[j] = array[i]; [EOL]         array[i] = tmp; [EOL]         j--; [EOL]         i++; [EOL]     } [EOL] } 
 [LINE] for (int i = startIndex; i < array.length; i++) { [LINE] public static int indexOf(final Object[] array, final Object objectToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     if (objectToFind == null) { [EOL]         for (int i = startIndex; i < array.length; i++) { [EOL]             if (array[i] == null) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } else if (array.getClass().getComponentType().isInstance(objectToFind)) { [EOL]         for (int i = startIndex; i < array.length; i++) { [EOL]             if (objectToFind.equals(array[i])) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] } 
 [LINE] if (array[i] == null) { [LINE] public static int indexOf(final Object[] array, final Object objectToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     if (objectToFind == null) { [EOL]         for (int i = startIndex; i < array.length; i++) { [EOL]             if (array[i] == null) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } else if (array.getClass().getComponentType().isInstance(objectToFind)) { [EOL]         for (int i = startIndex; i < array.length; i++) { [EOL]             if (objectToFind.equals(array[i])) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] } 
 [LINE] if (array == null) { [LINE] public static int lastIndexOf(final Object[] array, final Object objectToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     if (objectToFind == null) { [EOL]         for (int i = startIndex; i >= 0; i--) { [EOL]             if (array[i] == null) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } else if (array.getClass().getComponentType().isInstance(objectToFind)) { [EOL]         for (int i = startIndex; i >= 0; i--) { [EOL]             if (objectToFind.equals(array[i])) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] } 
 [LINE] return INDEX_NOT_FOUND; [LINE] public static int lastIndexOf(final Object[] array, final Object objectToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     if (objectToFind == null) { [EOL]         for (int i = startIndex; i >= 0; i--) { [EOL]             if (array[i] == null) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } else if (array.getClass().getComponentType().isInstance(objectToFind)) { [EOL]         for (int i = startIndex; i >= 0; i--) { [EOL]             if (objectToFind.equals(array[i])) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] } 
 [LINE] return INDEX_NOT_FOUND; [LINE] public static int lastIndexOf(final Object[] array, final Object objectToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     if (objectToFind == null) { [EOL]         for (int i = startIndex; i >= 0; i--) { [EOL]             if (array[i] == null) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } else if (array.getClass().getComponentType().isInstance(objectToFind)) { [EOL]         for (int i = startIndex; i >= 0; i--) { [EOL]             if (objectToFind.equals(array[i])) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] } 
 [LINE] return i; [LINE] public static int lastIndexOf(final Object[] array, final Object objectToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     if (objectToFind == null) { [EOL]         for (int i = startIndex; i >= 0; i--) { [EOL]             if (array[i] == null) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } else if (array.getClass().getComponentType().isInstance(objectToFind)) { [EOL]         for (int i = startIndex; i >= 0; i--) { [EOL]             if (objectToFind.equals(array[i])) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] } 
 [LINE] return i; [LINE] public static int lastIndexOf(final Object[] array, final Object objectToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     if (objectToFind == null) { [EOL]         for (int i = startIndex; i >= 0; i--) { [EOL]             if (array[i] == null) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } else if (array.getClass().getComponentType().isInstance(objectToFind)) { [EOL]         for (int i = startIndex; i >= 0; i--) { [EOL]             if (objectToFind.equals(array[i])) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] } 
 [LINE] startIndex = 0; [LINE] public static int indexOf(final long[] array, final long valueToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] } 
 [LINE] return lastIndexOf(array, valueToFind, Integer.MAX_VALUE); [LINE] public static int lastIndexOf(final long[] array, final long valueToFind) { [EOL]     return lastIndexOf(array, valueToFind, Integer.MAX_VALUE); [EOL] } 
 [LINE] if (startIndex < 0) { [LINE] public static int lastIndexOf(final long[] array, final long valueToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] } 
 [LINE] if (array == null) { [LINE] public static int lastIndexOf(final int[] array, final int valueToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] } 
 [LINE] } else if (startIndex >= array.length) { [LINE] public static int lastIndexOf(final int[] array, final int valueToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] } 
 [LINE] for (int i = startIndex; i >= 0; i--) { [LINE] public static int lastIndexOf(final int[] array, final int valueToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] } 
 [LINE] startIndex = 0; [LINE] public static int indexOf(final short[] array, final short valueToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] } 
 [LINE] return indexOf(array, valueToFind, 0); [LINE] public static int indexOf(final char[] array, final char valueToFind) { [EOL]     return indexOf(array, valueToFind, 0); [EOL] } 
 [LINE] if (valueToFind == array[i]) { [LINE] public static int indexOf(final char[] array, final char valueToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] } 
 [LINE] return INDEX_NOT_FOUND; [LINE] public static int lastIndexOf(final char[] array, final char valueToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] } 
 [LINE] if (valueToFind == array[i]) { [LINE] public static int indexOf(final byte[] array, final byte valueToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] } 
 [LINE] return i; [LINE] public static int indexOf(final byte[] array, final byte valueToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] } 
 [LINE] if (array == null) { [LINE] public static int lastIndexOf(final byte[] array, final byte valueToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] } 
 [LINE] return INDEX_NOT_FOUND; [LINE] public static int lastIndexOf(final byte[] array, final byte valueToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] } 
 [LINE] return INDEX_NOT_FOUND; [LINE] public static int lastIndexOf(final byte[] array, final byte valueToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] } 
 [LINE] return i; [LINE] public static int lastIndexOf(final byte[] array, final byte valueToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] } 
 [LINE] return indexOf(array, valueToFind, 0); [LINE] public static int indexOf(final double[] array, final double valueToFind) { [EOL]     return indexOf(array, valueToFind, 0); [EOL] } 
 [LINE] if (ArrayUtils.isEmpty(array)) { [LINE] public static int indexOf(final double[] array, final double valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] } 
 [LINE] return INDEX_NOT_FOUND; [LINE] public static int indexOf(final double[] array, final double valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] } 
 [LINE] if (valueToFind == array[i]) { [LINE] public static int indexOf(final double[] array, final double valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] } 
 [LINE] return i; [LINE] public static int indexOf(final double[] array, final double valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] } 
 [LINE] if (startIndex < 0) { [LINE] public static int indexOf(final double[] array, final double valueToFind, int startIndex, final double tolerance) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     final double min = valueToFind - tolerance; [EOL]     final double max = valueToFind + tolerance; [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (array[i] >= min && array[i] <= max) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] } 
 [LINE] startIndex = 0; [LINE] public static int indexOf(final double[] array, final double valueToFind, int startIndex, final double tolerance) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     final double min = valueToFind - tolerance; [EOL]     final double max = valueToFind + tolerance; [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (array[i] >= min && array[i] <= max) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] } 
 [LINE] final double max = valueToFind + tolerance; [LINE] public static int indexOf(final double[] array, final double valueToFind, int startIndex, final double tolerance) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     final double min = valueToFind - tolerance; [EOL]     final double max = valueToFind + tolerance; [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (array[i] >= min && array[i] <= max) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] } 
 [LINE] return INDEX_NOT_FOUND; [LINE] public static int lastIndexOf(final double[] array, final double valueToFind, int startIndex, final double tolerance) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     final double min = valueToFind - tolerance; [EOL]     final double max = valueToFind + tolerance; [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (array[i] >= min && array[i] <= max) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] } 
 [LINE] final double max = valueToFind + tolerance; [LINE] public static int lastIndexOf(final double[] array, final double valueToFind, int startIndex, final double tolerance) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     final double min = valueToFind - tolerance; [EOL]     final double max = valueToFind + tolerance; [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (array[i] >= min && array[i] <= max) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] } 
 [LINE] return indexOf(array, valueToFind, 0, tolerance) != INDEX_NOT_FOUND; [LINE] public static boolean contains(final double[] array, final double valueToFind, final double tolerance) { [EOL]     return indexOf(array, valueToFind, 0, tolerance) != INDEX_NOT_FOUND; [EOL] } 
 [LINE] if (ArrayUtils.isEmpty(array)) { [LINE] public static int indexOf(final float[] array, final float valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] } 
 [LINE] return lastIndexOf(array, valueToFind, Integer.MAX_VALUE); [LINE] public static int lastIndexOf(final float[] array, final float valueToFind) { [EOL]     return lastIndexOf(array, valueToFind, Integer.MAX_VALUE); [EOL] } 
 [LINE] if (startIndex < 0) { [LINE] public static int lastIndexOf(final float[] array, final float valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] } 
 [LINE] for (int i = startIndex; i >= 0; i--) { [LINE] public static int lastIndexOf(final float[] array, final float valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] } 
 [LINE] startIndex = 0; [LINE] public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] } 
 [LINE] for (int i = startIndex; i < array.length; i++) { [LINE] public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] } 
 [LINE] return i; [LINE] public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] } 
 [LINE] return indexOf(array, valueToFind) != INDEX_NOT_FOUND; [LINE] public static boolean contains(final boolean[] array, final boolean valueToFind) { [EOL]     return indexOf(array, valueToFind) != INDEX_NOT_FOUND; [EOL] } 
 [LINE] final char[] result = new char[array.length]; [LINE] public static char[] toPrimitive(final Character[] array, final char valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_CHAR_ARRAY; [EOL]     } [EOL]     final char[] result = new char[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Character b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.charValue()); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] final Character b = array[i]; [LINE] public static char[] toPrimitive(final Character[] array, final char valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_CHAR_ARRAY; [EOL]     } [EOL]     final char[] result = new char[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Character b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.charValue()); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] if (array == null) { [LINE] public static Character[] toObject(final char[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_CHARACTER_OBJECT_ARRAY; [EOL]     } [EOL]     final Character[] result = new Character[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = Character.valueOf(array[i]); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] return null; [LINE] public static Character[] toObject(final char[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_CHARACTER_OBJECT_ARRAY; [EOL]     } [EOL]     final Character[] result = new Character[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = Character.valueOf(array[i]); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] for (int i = 0; i < array.length; i++) { [LINE] public static Character[] toObject(final char[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_CHARACTER_OBJECT_ARRAY; [EOL]     } [EOL]     final Character[] result = new Character[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = Character.valueOf(array[i]); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] } else if (array.length == 0) { [LINE] public static long[] toPrimitive(final Long[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_LONG_ARRAY; [EOL]     } [EOL]     final long[] result = new long[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = array[i].longValue(); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] for (int i = 0; i < array.length; i++) { [LINE] public static long[] toPrimitive(final Long[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_LONG_ARRAY; [EOL]     } [EOL]     final long[] result = new long[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = array[i].longValue(); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] result[i] = array[i].longValue(); [LINE] public static long[] toPrimitive(final Long[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_LONG_ARRAY; [EOL]     } [EOL]     final long[] result = new long[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = array[i].longValue(); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] final long[] result = new long[array.length]; [LINE] public static long[] toPrimitive(final Long[] array, final long valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_LONG_ARRAY; [EOL]     } [EOL]     final long[] result = new long[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Long b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.longValue()); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] result[i] = (b == null ? valueForNull : b.longValue()); [LINE] public static long[] toPrimitive(final Long[] array, final long valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_LONG_ARRAY; [EOL]     } [EOL]     final long[] result = new long[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Long b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.longValue()); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] } else if (array.length == 0) { [LINE] public static Long[] toObject(final long[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_LONG_OBJECT_ARRAY; [EOL]     } [EOL]     final Long[] result = new Long[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = Long.valueOf(array[i]); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] return EMPTY_LONG_OBJECT_ARRAY; [LINE] public static Long[] toObject(final long[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_LONG_OBJECT_ARRAY; [EOL]     } [EOL]     final Long[] result = new Long[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = Long.valueOf(array[i]); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] for (int i = 0; i < array.length; i++) { [LINE] public static Long[] toObject(final long[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_LONG_OBJECT_ARRAY; [EOL]     } [EOL]     final Long[] result = new Long[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = Long.valueOf(array[i]); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] result[i] = Long.valueOf(array[i]); [LINE] public static Long[] toObject(final long[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_LONG_OBJECT_ARRAY; [EOL]     } [EOL]     final Long[] result = new Long[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = Long.valueOf(array[i]); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] for (int i = 0; i < array.length; i++) { [LINE] public static int[] toPrimitive(final Integer[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_INT_ARRAY; [EOL]     } [EOL]     final int[] result = new int[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = array[i].intValue(); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] return result; [LINE] public static int[] toPrimitive(final Integer[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_INT_ARRAY; [EOL]     } [EOL]     final int[] result = new int[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = array[i].intValue(); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] if (array == null) { [LINE] public static int[] toPrimitive(final Integer[] array, final int valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_INT_ARRAY; [EOL]     } [EOL]     final int[] result = new int[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Integer b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.intValue()); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] } else if (array.length == 0) { [LINE] public static int[] toPrimitive(final Integer[] array, final int valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_INT_ARRAY; [EOL]     } [EOL]     final int[] result = new int[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Integer b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.intValue()); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] final Integer[] result = new Integer[array.length]; [LINE] public static Integer[] toObject(final int[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_INTEGER_OBJECT_ARRAY; [EOL]     } [EOL]     final Integer[] result = new Integer[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = Integer.valueOf(array[i]); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] return null; [LINE] public static short[] toPrimitive(final Short[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_SHORT_ARRAY; [EOL]     } [EOL]     final short[] result = new short[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = array[i].shortValue(); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] return result; [LINE] public static short[] toPrimitive(final Short[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_SHORT_ARRAY; [EOL]     } [EOL]     final short[] result = new short[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = array[i].shortValue(); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] final Short b = array[i]; [LINE] public static short[] toPrimitive(final Short[] array, final short valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_SHORT_ARRAY; [EOL]     } [EOL]     final short[] result = new short[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Short b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.shortValue()); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] if (array == null) { [LINE] public static byte[] toPrimitive(final Byte[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_BYTE_ARRAY; [EOL]     } [EOL]     final byte[] result = new byte[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = array[i].byteValue(); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] result[i] = array[i].byteValue(); [LINE] public static byte[] toPrimitive(final Byte[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_BYTE_ARRAY; [EOL]     } [EOL]     final byte[] result = new byte[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = array[i].byteValue(); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] for (int i = 0; i < array.length; i++) { [LINE] public static Byte[] toObject(final byte[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_BYTE_OBJECT_ARRAY; [EOL]     } [EOL]     final Byte[] result = new Byte[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = Byte.valueOf(array[i]); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] if (array == null) { [LINE] public static double[] toPrimitive(final Double[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_DOUBLE_ARRAY; [EOL]     } [EOL]     final double[] result = new double[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = array[i].doubleValue(); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] return null; [LINE] public static double[] toPrimitive(final Double[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_DOUBLE_ARRAY; [EOL]     } [EOL]     final double[] result = new double[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = array[i].doubleValue(); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] } else if (array.length == 0) { [LINE] public static double[] toPrimitive(final Double[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_DOUBLE_ARRAY; [EOL]     } [EOL]     final double[] result = new double[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = array[i].doubleValue(); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] } else if (array.length == 0) { [LINE] public static double[] toPrimitive(final Double[] array, final double valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_DOUBLE_ARRAY; [EOL]     } [EOL]     final double[] result = new double[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Double b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.doubleValue()); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] result[i] = Double.valueOf(array[i]); [LINE] public static Double[] toObject(final double[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_DOUBLE_OBJECT_ARRAY; [EOL]     } [EOL]     final Double[] result = new Double[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = Double.valueOf(array[i]); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] return null; [LINE] public static float[] toPrimitive(final Float[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_FLOAT_ARRAY; [EOL]     } [EOL]     final float[] result = new float[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = array[i].floatValue(); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] for (int i = 0; i < array.length; i++) { [LINE] public static float[] toPrimitive(final Float[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_FLOAT_ARRAY; [EOL]     } [EOL]     final float[] result = new float[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = array[i].floatValue(); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] return result; [LINE] public static float[] toPrimitive(final Float[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_FLOAT_ARRAY; [EOL]     } [EOL]     final float[] result = new float[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = array[i].floatValue(); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] } else if (array.length == 0) { [LINE] public static float[] toPrimitive(final Float[] array, final float valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_FLOAT_ARRAY; [EOL]     } [EOL]     final float[] result = new float[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Float b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.floatValue()); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] return result; [LINE] public static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_BOOLEAN_ARRAY; [EOL]     } [EOL]     final boolean[] result = new boolean[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Boolean b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.booleanValue()); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] } else if (array.length == 0) { [LINE] public static Boolean[] toObject(final boolean[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_BOOLEAN_OBJECT_ARRAY; [EOL]     } [EOL]     final Boolean[] result = new Boolean[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = (array[i] ? Boolean.TRUE : Boolean.FALSE); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] final Boolean[] result = new Boolean[array.length]; [LINE] public static Boolean[] toObject(final boolean[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_BOOLEAN_OBJECT_ARRAY; [EOL]     } [EOL]     final Boolean[] result = new Boolean[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = (array[i] ? Boolean.TRUE : Boolean.FALSE); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] return array == null || array.length == 0; [LINE] public static boolean isEmpty(final long[] array) { [EOL]     return array == null || array.length == 0; [EOL] } 
 [LINE] return array == null || array.length == 0; [LINE] public static boolean isEmpty(final double[] array) { [EOL]     return array == null || array.length == 0; [EOL] } 
 [LINE] return (array != null && array.length != 0); [LINE] public static boolean isNotEmpty(final int[] array) { [EOL]     return (array != null && array.length != 0); [EOL] } 
 [LINE] return (array != null && array.length != 0); [LINE] public static boolean isNotEmpty(final char[] array) { [EOL]     return (array != null && array.length != 0); [EOL] } 
 [LINE] return clone(array2); [LINE] public static <T> T[] addAll(final T[] array1, final T... array2) { [EOL]     if (array1 == null) { [EOL]         return clone(array2); [EOL]     } else if (array2 == null) { [EOL]         return clone(array1); [EOL]     } [EOL]     final Class<?> type1 = array1.getClass().getComponentType(); [EOL]     @SuppressWarnings("unchecked") [EOL]     final T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length); [EOL]     System.arraycopy(array1, 0, joinedArray, 0, array1.length); [EOL]     try { [EOL]         System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); [EOL]     } catch (final ArrayStoreException ase) { [EOL]         final Class<?> type2 = array2.getClass().getComponentType(); [EOL]         if (!type1.isAssignableFrom(type2)) { [EOL]             throw new IllegalArgumentException("Cannot store " + type2.getName() + " in an array of " + type1.getName(), ase); [EOL]         } [EOL]         throw ase; [EOL]     } [EOL]     return joinedArray; [EOL] } 
 [LINE] System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); [LINE] public static <T> T[] addAll(final T[] array1, final T... array2) { [EOL]     if (array1 == null) { [EOL]         return clone(array2); [EOL]     } else if (array2 == null) { [EOL]         return clone(array1); [EOL]     } [EOL]     final Class<?> type1 = array1.getClass().getComponentType(); [EOL]     @SuppressWarnings("unchecked") [EOL]     final T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length); [EOL]     System.arraycopy(array1, 0, joinedArray, 0, array1.length); [EOL]     try { [EOL]         System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); [EOL]     } catch (final ArrayStoreException ase) { [EOL]         final Class<?> type2 = array2.getClass().getComponentType(); [EOL]         if (!type1.isAssignableFrom(type2)) { [EOL]             throw new IllegalArgumentException("Cannot store " + type2.getName() + " in an array of " + type1.getName(), ase); [EOL]         } [EOL]         throw ase; [EOL]     } [EOL]     return joinedArray; [EOL] } 
 [LINE] } else if (array2 == null) { [LINE] public static boolean[] addAll(final boolean[] array1, final boolean... array2) { [EOL]     if (array1 == null) { [EOL]         return clone(array2); [EOL]     } else if (array2 == null) { [EOL]         return clone(array1); [EOL]     } [EOL]     final boolean[] joinedArray = new boolean[array1.length + array2.length]; [EOL]     System.arraycopy(array1, 0, joinedArray, 0, array1.length); [EOL]     System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); [EOL]     return joinedArray; [EOL] } 
 [LINE] return clone(array2); [LINE] public static char[] addAll(final char[] array1, final char... array2) { [EOL]     if (array1 == null) { [EOL]         return clone(array2); [EOL]     } else if (array2 == null) { [EOL]         return clone(array1); [EOL]     } [EOL]     final char[] joinedArray = new char[array1.length + array2.length]; [EOL]     System.arraycopy(array1, 0, joinedArray, 0, array1.length); [EOL]     System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); [EOL]     return joinedArray; [EOL] } 
 [LINE] } else if (array2 == null) { [LINE] public static char[] addAll(final char[] array1, final char... array2) { [EOL]     if (array1 == null) { [EOL]         return clone(array2); [EOL]     } else if (array2 == null) { [EOL]         return clone(array1); [EOL]     } [EOL]     final char[] joinedArray = new char[array1.length + array2.length]; [EOL]     System.arraycopy(array1, 0, joinedArray, 0, array1.length); [EOL]     System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); [EOL]     return joinedArray; [EOL] } 
 [LINE] System.arraycopy(array1, 0, joinedArray, 0, array1.length); [LINE] public static byte[] addAll(final byte[] array1, final byte... array2) { [EOL]     if (array1 == null) { [EOL]         return clone(array2); [EOL]     } else if (array2 == null) { [EOL]         return clone(array1); [EOL]     } [EOL]     final byte[] joinedArray = new byte[array1.length + array2.length]; [EOL]     System.arraycopy(array1, 0, joinedArray, 0, array1.length); [EOL]     System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); [EOL]     return joinedArray; [EOL] } 
 [LINE] final int[] joinedArray = new int[array1.length + array2.length]; [LINE] public static int[] addAll(final int[] array1, final int... array2) { [EOL]     if (array1 == null) { [EOL]         return clone(array2); [EOL]     } else if (array2 == null) { [EOL]         return clone(array1); [EOL]     } [EOL]     final int[] joinedArray = new int[array1.length + array2.length]; [EOL]     System.arraycopy(array1, 0, joinedArray, 0, array1.length); [EOL]     System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); [EOL]     return joinedArray; [EOL] } 
 [LINE] return joinedArray; [LINE] public static long[] addAll(final long[] array1, final long... array2) { [EOL]     if (array1 == null) { [EOL]         return clone(array2); [EOL]     } else if (array2 == null) { [EOL]         return clone(array1); [EOL]     } [EOL]     final long[] joinedArray = new long[array1.length + array2.length]; [EOL]     System.arraycopy(array1, 0, joinedArray, 0, array1.length); [EOL]     System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); [EOL]     return joinedArray; [EOL] } 
 [LINE] } else if (array2 == null) { [LINE] public static float[] addAll(final float[] array1, final float... array2) { [EOL]     if (array1 == null) { [EOL]         return clone(array2); [EOL]     } else if (array2 == null) { [EOL]         return clone(array1); [EOL]     } [EOL]     final float[] joinedArray = new float[array1.length + array2.length]; [EOL]     System.arraycopy(array1, 0, joinedArray, 0, array1.length); [EOL]     System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); [EOL]     return joinedArray; [EOL] } 
 [LINE] return clone(array2); [LINE] public static double[] addAll(final double[] array1, final double... array2) { [EOL]     if (array1 == null) { [EOL]         return clone(array2); [EOL]     } else if (array2 == null) { [EOL]         return clone(array1); [EOL]     } [EOL]     final double[] joinedArray = new double[array1.length + array2.length]; [EOL]     System.arraycopy(array1, 0, joinedArray, 0, array1.length); [EOL]     System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); [EOL]     return joinedArray; [EOL] } 
 [LINE] } else if (array2 == null) { [LINE] public static double[] addAll(final double[] array1, final double... array2) { [EOL]     if (array1 == null) { [EOL]         return clone(array2); [EOL]     } else if (array2 == null) { [EOL]         return clone(array1); [EOL]     } [EOL]     final double[] joinedArray = new double[array1.length + array2.length]; [EOL]     System.arraycopy(array1, 0, joinedArray, 0, array1.length); [EOL]     System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); [EOL]     return joinedArray; [EOL] } 
 [LINE] type = array.getClass(); [LINE] public static <T> T[] add(final T[] array, final T element) { [EOL]     Class<?> type; [EOL]     if (array != null) { [EOL]         type = array.getClass(); [EOL]     } else if (element != null) { [EOL]         type = element.getClass(); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Arguments cannot both be null"); [EOL]     } [EOL]     @SuppressWarnings("unchecked") [EOL]     final T[] newArray = (T[]) copyArrayGrow1(array, type); [EOL]     newArray[newArray.length - 1] = element; [EOL]     return newArray; [EOL] } 
 [LINE] newArray[newArray.length - 1] = element; [LINE] public static boolean[] add(final boolean[] array, final boolean element) { [EOL]     final boolean[] newArray = (boolean[]) copyArrayGrow1(array, Boolean.TYPE); [EOL]     newArray[newArray.length - 1] = element; [EOL]     return newArray; [EOL] } 
 [LINE] newArray[newArray.length - 1] = element; [LINE] public static byte[] add(final byte[] array, final byte element) { [EOL]     final byte[] newArray = (byte[]) copyArrayGrow1(array, Byte.TYPE); [EOL]     newArray[newArray.length - 1] = element; [EOL]     return newArray; [EOL] } 
 [LINE] newArray[newArray.length - 1] = element; [LINE] public static int[] add(final int[] array, final int element) { [EOL]     final int[] newArray = (int[]) copyArrayGrow1(array, Integer.TYPE); [EOL]     newArray[newArray.length - 1] = element; [EOL]     return newArray; [EOL] } 
 [LINE] if (array != null) { [LINE] private static Object copyArrayGrow1(final Object array, final Class<?> newArrayComponentType) { [EOL]     if (array != null) { [EOL]         final int arrayLength = Array.getLength(array); [EOL]         final Object newArray = Array.newInstance(array.getClass().getComponentType(), arrayLength + 1); [EOL]         System.arraycopy(array, 0, newArray, 0, arrayLength); [EOL]         return newArray; [EOL]     } [EOL]     return Array.newInstance(newArrayComponentType, 1); [EOL] } 
 [LINE] if (array != null) { [LINE] public static <T> T[] add(final T[] array, final int index, final T element) { [EOL]     Class<?> clss = null; [EOL]     if (array != null) { [EOL]         clss = array.getClass().getComponentType(); [EOL]     } else if (element != null) { [EOL]         clss = element.getClass(); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Array and element cannot both be null"); [EOL]     } [EOL]     @SuppressWarnings("unchecked") [EOL]     final T[] newArray = (T[]) add(array, index, element, clss); [EOL]     return newArray; [EOL] } 
 [LINE] return newArray; [LINE] public static <T> T[] add(final T[] array, final int index, final T element) { [EOL]     Class<?> clss = null; [EOL]     if (array != null) { [EOL]         clss = array.getClass().getComponentType(); [EOL]     } else if (element != null) { [EOL]         clss = element.getClass(); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Array and element cannot both be null"); [EOL]     } [EOL]     @SuppressWarnings("unchecked") [EOL]     final T[] newArray = (T[]) add(array, index, element, clss); [EOL]     return newArray; [EOL] } 
 [LINE] return (double[]) add(array, index, Double.valueOf(element), Double.TYPE); [LINE] public static double[] add(final double[] array, final int index, final double element) { [EOL]     return (double[]) add(array, index, Double.valueOf(element), Double.TYPE); [EOL] } 
 [LINE] if (index != 0) { [LINE] private static Object add(final Object array, final int index, final Object element, final Class<?> clss) { [EOL]     if (array == null) { [EOL]         if (index != 0) { [EOL]             throw new IndexOutOfBoundsException("Index: " + index + ", Length: 0"); [EOL]         } [EOL]         final Object joinedArray = Array.newInstance(clss, 1); [EOL]         Array.set(joinedArray, 0, element); [EOL]         return joinedArray; [EOL]     } [EOL]     final int length = Array.getLength(array); [EOL]     if (index > length || index < 0) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(clss, length + 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     Array.set(result, index, element); [EOL]     if (index < length) { [EOL]         System.arraycopy(array, index, result, index + 1, length - index); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] return (boolean[]) remove((Object) array, index); [LINE] public static boolean[] remove(final boolean[] array, final int index) { [EOL]     return (boolean[]) remove((Object) array, index); [EOL] } 
 [LINE] return remove(array, index); [LINE] public static boolean[] removeElement(final boolean[] array, final boolean element) { [EOL]     final int index = indexOf(array, element); [EOL]     if (index == INDEX_NOT_FOUND) { [EOL]         return clone(array); [EOL]     } [EOL]     return remove(array, index); [EOL] } 
 [LINE] return (byte[]) remove((Object) array, index); [LINE] public static byte[] remove(final byte[] array, final int index) { [EOL]     return (byte[]) remove((Object) array, index); [EOL] } 
 [LINE] final int index = indexOf(array, element); [LINE] public static char[] removeElement(final char[] array, final char element) { [EOL]     final int index = indexOf(array, element); [EOL]     if (index == INDEX_NOT_FOUND) { [EOL]         return clone(array); [EOL]     } [EOL]     return remove(array, index); [EOL] } 
 [LINE] final int index = indexOf(array, element); [LINE] public static double[] removeElement(final double[] array, final double element) { [EOL]     final int index = indexOf(array, element); [EOL]     if (index == INDEX_NOT_FOUND) { [EOL]         return clone(array); [EOL]     } [EOL]     return remove(array, index); [EOL] } 
 [LINE] return remove(array, index); [LINE] public static double[] removeElement(final double[] array, final double element) { [EOL]     final int index = indexOf(array, element); [EOL]     if (index == INDEX_NOT_FOUND) { [EOL]         return clone(array); [EOL]     } [EOL]     return remove(array, index); [EOL] } 
 [LINE] final int index = indexOf(array, element); [LINE] public static float[] removeElement(final float[] array, final float element) { [EOL]     final int index = indexOf(array, element); [EOL]     if (index == INDEX_NOT_FOUND) { [EOL]         return clone(array); [EOL]     } [EOL]     return remove(array, index); [EOL] } 
 [LINE] return (int[]) remove((Object) array, index); [LINE] public static int[] remove(final int[] array, final int index) { [EOL]     return (int[]) remove((Object) array, index); [EOL] } 
 [LINE] return (short[]) remove((Object) array, index); [LINE] public static short[] remove(final short[] array, final int index) { [EOL]     return (short[]) remove((Object) array, index); [EOL] } 
 [LINE] final int length = getLength(array); [LINE] private static Object remove(final Object array, final int index) { [EOL]     final int length = getLength(array); [EOL]     if (index < 0 || index >= length) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     if (index < length - 1) { [EOL]         System.arraycopy(array, index + 1, result, index, length - index - 1); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [LINE] private static Object remove(final Object array, final int index) { [EOL]     final int length = getLength(array); [EOL]     if (index < 0 || index >= length) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     if (index < length - 1) { [EOL]         System.arraycopy(array, index + 1, result, index, length - index - 1); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] System.arraycopy(array, index + 1, result, index, length - index - 1); [LINE] private static Object remove(final Object array, final int index) { [EOL]     final int length = getLength(array); [EOL]     if (index < 0 || index >= length) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     if (index < length - 1) { [EOL]         System.arraycopy(array, index + 1, result, index, length - index - 1); [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] final MutableInt count = occurrences.get(v); [LINE] public static <T> T[] removeElements(final T[] array, final T... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length); [EOL]     for (final T v : values) { [EOL]         final MutableInt count = occurrences.get(v); [EOL]         if (count == null) { [EOL]             occurrences.put(v, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) { [EOL]         final T v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v, found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     @SuppressWarnings("unchecked") [EOL]     final T[] result = (T[]) removeAll(array, toRemove); [EOL]     return result; [EOL] } 
 [LINE] if (count == null) { [LINE] public static <T> T[] removeElements(final T[] array, final T... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length); [EOL]     for (final T v : values) { [EOL]         final MutableInt count = occurrences.get(v); [EOL]         if (count == null) { [EOL]             occurrences.put(v, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) { [EOL]         final T v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v, found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     @SuppressWarnings("unchecked") [EOL]     final T[] result = (T[]) removeAll(array, toRemove); [EOL]     return result; [EOL] } 
 [LINE] count.increment(); [LINE] public static <T> T[] removeElements(final T[] array, final T... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length); [EOL]     for (final T v : values) { [EOL]         final MutableInt count = occurrences.get(v); [EOL]         if (count == null) { [EOL]             occurrences.put(v, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) { [EOL]         final T v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v, found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     @SuppressWarnings("unchecked") [EOL]     final T[] result = (T[]) removeAll(array, toRemove); [EOL]     return result; [EOL] } 
 [LINE] int found = 0; [LINE] public static <T> T[] removeElements(final T[] array, final T... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length); [EOL]     for (final T v : values) { [EOL]         final MutableInt count = occurrences.get(v); [EOL]         if (count == null) { [EOL]             occurrences.put(v, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) { [EOL]         final T v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v, found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     @SuppressWarnings("unchecked") [EOL]     final T[] result = (T[]) removeAll(array, toRemove); [EOL]     return result; [EOL] } 
 [LINE] for (final Map.Entry<Byte, MutableInt> e : occurrences.entrySet()) { [LINE] public static byte[] removeElements(final byte[] array, final byte... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<Byte, MutableInt> occurrences = new HashMap<Byte, MutableInt>(values.length); [EOL]     for (final byte v : values) { [EOL]         final Byte boxed = Byte.valueOf(v); [EOL]         final MutableInt count = occurrences.get(boxed); [EOL]         if (count == null) { [EOL]             occurrences.put(boxed, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<Byte, MutableInt> e : occurrences.entrySet()) { [EOL]         final Byte v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v.byteValue(), found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     return (byte[]) removeAll(array, toRemove); [EOL] } 
 [LINE] break; [LINE] public static byte[] removeElements(final byte[] array, final byte... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<Byte, MutableInt> occurrences = new HashMap<Byte, MutableInt>(values.length); [EOL]     for (final byte v : values) { [EOL]         final Byte boxed = Byte.valueOf(v); [EOL]         final MutableInt count = occurrences.get(boxed); [EOL]         if (count == null) { [EOL]             occurrences.put(boxed, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<Byte, MutableInt> e : occurrences.entrySet()) { [EOL]         final Byte v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v.byteValue(), found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     return (byte[]) removeAll(array, toRemove); [EOL] } 
 [LINE] return (byte[]) removeAll(array, toRemove); [LINE] public static byte[] removeElements(final byte[] array, final byte... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<Byte, MutableInt> occurrences = new HashMap<Byte, MutableInt>(values.length); [EOL]     for (final byte v : values) { [EOL]         final Byte boxed = Byte.valueOf(v); [EOL]         final MutableInt count = occurrences.get(boxed); [EOL]         if (count == null) { [EOL]             occurrences.put(boxed, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<Byte, MutableInt> e : occurrences.entrySet()) { [EOL]         final Byte v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v.byteValue(), found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     return (byte[]) removeAll(array, toRemove); [EOL] } 
 [LINE] final Short boxed = Short.valueOf(v); [LINE] public static short[] removeElements(final short[] array, final short... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<Short, MutableInt> occurrences = new HashMap<Short, MutableInt>(values.length); [EOL]     for (final short v : values) { [EOL]         final Short boxed = Short.valueOf(v); [EOL]         final MutableInt count = occurrences.get(boxed); [EOL]         if (count == null) { [EOL]             occurrences.put(boxed, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<Short, MutableInt> e : occurrences.entrySet()) { [EOL]         final Short v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v.shortValue(), found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     return (short[]) removeAll(array, toRemove); [EOL] } 
 [LINE] return (int[]) removeAll((Object) array, clone(indices)); [LINE] public static int[] removeAll(final int[] array, final int... indices) { [EOL]     return (int[]) removeAll((Object) array, clone(indices)); [EOL] } 
 [LINE] occurrences.put(boxed, new MutableInt(1)); [LINE] public static int[] removeElements(final int[] array, final int... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<Integer, MutableInt> occurrences = new HashMap<Integer, MutableInt>(values.length); [EOL]     for (final int v : values) { [EOL]         final Integer boxed = Integer.valueOf(v); [EOL]         final MutableInt count = occurrences.get(boxed); [EOL]         if (count == null) { [EOL]             occurrences.put(boxed, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<Integer, MutableInt> e : occurrences.entrySet()) { [EOL]         final Integer v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v.intValue(), found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     return (int[]) removeAll(array, toRemove); [EOL] } 
 [LINE] for (final Map.Entry<Integer, MutableInt> e : occurrences.entrySet()) { [LINE] public static int[] removeElements(final int[] array, final int... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<Integer, MutableInt> occurrences = new HashMap<Integer, MutableInt>(values.length); [EOL]     for (final int v : values) { [EOL]         final Integer boxed = Integer.valueOf(v); [EOL]         final MutableInt count = occurrences.get(boxed); [EOL]         if (count == null) { [EOL]             occurrences.put(boxed, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<Integer, MutableInt> e : occurrences.entrySet()) { [EOL]         final Integer v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v.intValue(), found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     return (int[]) removeAll(array, toRemove); [EOL] } 
 [LINE] final Integer v = e.getKey(); [LINE] public static int[] removeElements(final int[] array, final int... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<Integer, MutableInt> occurrences = new HashMap<Integer, MutableInt>(values.length); [EOL]     for (final int v : values) { [EOL]         final Integer boxed = Integer.valueOf(v); [EOL]         final MutableInt count = occurrences.get(boxed); [EOL]         if (count == null) { [EOL]             occurrences.put(boxed, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<Integer, MutableInt> e : occurrences.entrySet()) { [EOL]         final Integer v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v.intValue(), found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     return (int[]) removeAll(array, toRemove); [EOL] } 
 [LINE] found = indexOf(array, v.intValue(), found); [LINE] public static int[] removeElements(final int[] array, final int... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<Integer, MutableInt> occurrences = new HashMap<Integer, MutableInt>(values.length); [EOL]     for (final int v : values) { [EOL]         final Integer boxed = Integer.valueOf(v); [EOL]         final MutableInt count = occurrences.get(boxed); [EOL]         if (count == null) { [EOL]             occurrences.put(boxed, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<Integer, MutableInt> e : occurrences.entrySet()) { [EOL]         final Integer v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v.intValue(), found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     return (int[]) removeAll(array, toRemove); [EOL] } 
 [LINE] break; [LINE] public static int[] removeElements(final int[] array, final int... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<Integer, MutableInt> occurrences = new HashMap<Integer, MutableInt>(values.length); [EOL]     for (final int v : values) { [EOL]         final Integer boxed = Integer.valueOf(v); [EOL]         final MutableInt count = occurrences.get(boxed); [EOL]         if (count == null) { [EOL]             occurrences.put(boxed, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<Integer, MutableInt> e : occurrences.entrySet()) { [EOL]         final Integer v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v.intValue(), found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     return (int[]) removeAll(array, toRemove); [EOL] } 
 [LINE] final Character boxed = Character.valueOf(v); [LINE] public static char[] removeElements(final char[] array, final char... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<Character, MutableInt> occurrences = new HashMap<Character, MutableInt>(values.length); [EOL]     for (final char v : values) { [EOL]         final Character boxed = Character.valueOf(v); [EOL]         final MutableInt count = occurrences.get(boxed); [EOL]         if (count == null) { [EOL]             occurrences.put(boxed, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<Character, MutableInt> e : occurrences.entrySet()) { [EOL]         final Character v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v.charValue(), found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     return (char[]) removeAll(array, toRemove); [EOL] } 
 [LINE] final MutableInt count = occurrences.get(boxed); [LINE] public static char[] removeElements(final char[] array, final char... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<Character, MutableInt> occurrences = new HashMap<Character, MutableInt>(values.length); [EOL]     for (final char v : values) { [EOL]         final Character boxed = Character.valueOf(v); [EOL]         final MutableInt count = occurrences.get(boxed); [EOL]         if (count == null) { [EOL]             occurrences.put(boxed, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<Character, MutableInt> e : occurrences.entrySet()) { [EOL]         final Character v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v.charValue(), found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     return (char[]) removeAll(array, toRemove); [EOL] } 
 [LINE] final MutableInt count = occurrences.get(boxed); [LINE] public static long[] removeElements(final long[] array, final long... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<Long, MutableInt> occurrences = new HashMap<Long, MutableInt>(values.length); [EOL]     for (final long v : values) { [EOL]         final Long boxed = Long.valueOf(v); [EOL]         final MutableInt count = occurrences.get(boxed); [EOL]         if (count == null) { [EOL]             occurrences.put(boxed, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<Long, MutableInt> e : occurrences.entrySet()) { [EOL]         final Long v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v.longValue(), found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     return (long[]) removeAll(array, toRemove); [EOL] } 
 [LINE] int found = 0; [LINE] public static long[] removeElements(final long[] array, final long... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<Long, MutableInt> occurrences = new HashMap<Long, MutableInt>(values.length); [EOL]     for (final long v : values) { [EOL]         final Long boxed = Long.valueOf(v); [EOL]         final MutableInt count = occurrences.get(boxed); [EOL]         if (count == null) { [EOL]             occurrences.put(boxed, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<Long, MutableInt> e : occurrences.entrySet()) { [EOL]         final Long v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v.longValue(), found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     return (long[]) removeAll(array, toRemove); [EOL] } 
 [LINE] return (long[]) removeAll(array, toRemove); [LINE] public static long[] removeElements(final long[] array, final long... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<Long, MutableInt> occurrences = new HashMap<Long, MutableInt>(values.length); [EOL]     for (final long v : values) { [EOL]         final Long boxed = Long.valueOf(v); [EOL]         final MutableInt count = occurrences.get(boxed); [EOL]         if (count == null) { [EOL]             occurrences.put(boxed, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<Long, MutableInt> e : occurrences.entrySet()) { [EOL]         final Long v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v.longValue(), found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     return (long[]) removeAll(array, toRemove); [EOL] } 
 [LINE] if (isEmpty(array) || isEmpty(values)) { [LINE] public static float[] removeElements(final float[] array, final float... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<Float, MutableInt> occurrences = new HashMap<Float, MutableInt>(values.length); [EOL]     for (final float v : values) { [EOL]         final Float boxed = Float.valueOf(v); [EOL]         final MutableInt count = occurrences.get(boxed); [EOL]         if (count == null) { [EOL]             occurrences.put(boxed, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<Float, MutableInt> e : occurrences.entrySet()) { [EOL]         final Float v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v.floatValue(), found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     return (float[]) removeAll(array, toRemove); [EOL] } 
 [LINE] final HashMap<Float, MutableInt> occurrences = new HashMap<Float, MutableInt>(values.length); [LINE] public static float[] removeElements(final float[] array, final float... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<Float, MutableInt> occurrences = new HashMap<Float, MutableInt>(values.length); [EOL]     for (final float v : values) { [EOL]         final Float boxed = Float.valueOf(v); [EOL]         final MutableInt count = occurrences.get(boxed); [EOL]         if (count == null) { [EOL]             occurrences.put(boxed, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<Float, MutableInt> e : occurrences.entrySet()) { [EOL]         final Float v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v.floatValue(), found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     return (float[]) removeAll(array, toRemove); [EOL] } 
 [LINE] final Float v = e.getKey(); [LINE] public static float[] removeElements(final float[] array, final float... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<Float, MutableInt> occurrences = new HashMap<Float, MutableInt>(values.length); [EOL]     for (final float v : values) { [EOL]         final Float boxed = Float.valueOf(v); [EOL]         final MutableInt count = occurrences.get(boxed); [EOL]         if (count == null) { [EOL]             occurrences.put(boxed, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<Float, MutableInt> e : occurrences.entrySet()) { [EOL]         final Float v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v.floatValue(), found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     return (float[]) removeAll(array, toRemove); [EOL] } 
 [LINE] return (float[]) removeAll(array, toRemove); [LINE] public static float[] removeElements(final float[] array, final float... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<Float, MutableInt> occurrences = new HashMap<Float, MutableInt>(values.length); [EOL]     for (final float v : values) { [EOL]         final Float boxed = Float.valueOf(v); [EOL]         final MutableInt count = occurrences.get(boxed); [EOL]         if (count == null) { [EOL]             occurrences.put(boxed, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<Float, MutableInt> e : occurrences.entrySet()) { [EOL]         final Float v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v.floatValue(), found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     return (float[]) removeAll(array, toRemove); [EOL] } 
 [LINE] return (double[]) removeAll((Object) array, clone(indices)); [LINE] public static double[] removeAll(final double[] array, final int... indices) { [EOL]     return (double[]) removeAll((Object) array, clone(indices)); [EOL] } 
 [LINE] if (isEmpty(array) || isEmpty(values)) { [LINE] public static double[] removeElements(final double[] array, final double... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<Double, MutableInt> occurrences = new HashMap<Double, MutableInt>(values.length); [EOL]     for (final double v : values) { [EOL]         final Double boxed = Double.valueOf(v); [EOL]         final MutableInt count = occurrences.get(boxed); [EOL]         if (count == null) { [EOL]             occurrences.put(boxed, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<Double, MutableInt> e : occurrences.entrySet()) { [EOL]         final Double v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v.doubleValue(), found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     return (double[]) removeAll(array, toRemove); [EOL] } 
 [LINE] final Double boxed = Double.valueOf(v); [LINE] public static double[] removeElements(final double[] array, final double... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<Double, MutableInt> occurrences = new HashMap<Double, MutableInt>(values.length); [EOL]     for (final double v : values) { [EOL]         final Double boxed = Double.valueOf(v); [EOL]         final MutableInt count = occurrences.get(boxed); [EOL]         if (count == null) { [EOL]             occurrences.put(boxed, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<Double, MutableInt> e : occurrences.entrySet()) { [EOL]         final Double v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v.doubleValue(), found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     return (double[]) removeAll(array, toRemove); [EOL] } 
 [LINE] final Double v = e.getKey(); [LINE] public static double[] removeElements(final double[] array, final double... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<Double, MutableInt> occurrences = new HashMap<Double, MutableInt>(values.length); [EOL]     for (final double v : values) { [EOL]         final Double boxed = Double.valueOf(v); [EOL]         final MutableInt count = occurrences.get(boxed); [EOL]         if (count == null) { [EOL]             occurrences.put(boxed, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<Double, MutableInt> e : occurrences.entrySet()) { [EOL]         final Double v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v.doubleValue(), found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     return (double[]) removeAll(array, toRemove); [EOL] } 
 [LINE] found = indexOf(array, v.doubleValue(), found); [LINE] public static double[] removeElements(final double[] array, final double... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<Double, MutableInt> occurrences = new HashMap<Double, MutableInt>(values.length); [EOL]     for (final double v : values) { [EOL]         final Double boxed = Double.valueOf(v); [EOL]         final MutableInt count = occurrences.get(boxed); [EOL]         if (count == null) { [EOL]             occurrences.put(boxed, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<Double, MutableInt> e : occurrences.entrySet()) { [EOL]         final Double v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v.doubleValue(), found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     return (double[]) removeAll(array, toRemove); [EOL] } 
 [LINE] if (found < 0) { [LINE] public static double[] removeElements(final double[] array, final double... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<Double, MutableInt> occurrences = new HashMap<Double, MutableInt>(values.length); [EOL]     for (final double v : values) { [EOL]         final Double boxed = Double.valueOf(v); [EOL]         final MutableInt count = occurrences.get(boxed); [EOL]         if (count == null) { [EOL]             occurrences.put(boxed, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<Double, MutableInt> e : occurrences.entrySet()) { [EOL]         final Double v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v.doubleValue(), found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     return (double[]) removeAll(array, toRemove); [EOL] } 
 [LINE] break; [LINE] public static double[] removeElements(final double[] array, final double... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<Double, MutableInt> occurrences = new HashMap<Double, MutableInt>(values.length); [EOL]     for (final double v : values) { [EOL]         final Double boxed = Double.valueOf(v); [EOL]         final MutableInt count = occurrences.get(boxed); [EOL]         if (count == null) { [EOL]             occurrences.put(boxed, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<Double, MutableInt> e : occurrences.entrySet()) { [EOL]         final Double v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v.doubleValue(), found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     return (double[]) removeAll(array, toRemove); [EOL] } 
 [LINE] return clone(array); [LINE] public static boolean[] removeElements(final boolean[] array, final boolean... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<Boolean, MutableInt> occurrences = new HashMap<Boolean, MutableInt>(2); [EOL]     for (final boolean v : values) { [EOL]         final Boolean boxed = Boolean.valueOf(v); [EOL]         final MutableInt count = occurrences.get(boxed); [EOL]         if (count == null) { [EOL]             occurrences.put(boxed, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<Boolean, MutableInt> e : occurrences.entrySet()) { [EOL]         final Boolean v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v.booleanValue(), found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     return (boolean[]) removeAll(array, toRemove); [EOL] } 
 [LINE] final MutableInt count = occurrences.get(boxed); [LINE] public static boolean[] removeElements(final boolean[] array, final boolean... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<Boolean, MutableInt> occurrences = new HashMap<Boolean, MutableInt>(2); [EOL]     for (final boolean v : values) { [EOL]         final Boolean boxed = Boolean.valueOf(v); [EOL]         final MutableInt count = occurrences.get(boxed); [EOL]         if (count == null) { [EOL]             occurrences.put(boxed, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<Boolean, MutableInt> e : occurrences.entrySet()) { [EOL]         final Boolean v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v.booleanValue(), found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     return (boolean[]) removeAll(array, toRemove); [EOL] } 
 [LINE] count.increment(); [LINE] public static boolean[] removeElements(final boolean[] array, final boolean... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<Boolean, MutableInt> occurrences = new HashMap<Boolean, MutableInt>(2); [EOL]     for (final boolean v : values) { [EOL]         final Boolean boxed = Boolean.valueOf(v); [EOL]         final MutableInt count = occurrences.get(boxed); [EOL]         if (count == null) { [EOL]             occurrences.put(boxed, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<Boolean, MutableInt> e : occurrences.entrySet()) { [EOL]         final Boolean v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v.booleanValue(), found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     return (boolean[]) removeAll(array, toRemove); [EOL] } 
 [LINE] for (final Map.Entry<Boolean, MutableInt> e : occurrences.entrySet()) { [LINE] public static boolean[] removeElements(final boolean[] array, final boolean... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<Boolean, MutableInt> occurrences = new HashMap<Boolean, MutableInt>(2); [EOL]     for (final boolean v : values) { [EOL]         final Boolean boxed = Boolean.valueOf(v); [EOL]         final MutableInt count = occurrences.get(boxed); [EOL]         if (count == null) { [EOL]             occurrences.put(boxed, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<Boolean, MutableInt> e : occurrences.entrySet()) { [EOL]         final Boolean v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v.booleanValue(), found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     return (boolean[]) removeAll(array, toRemove); [EOL] } 
 [LINE] break; [LINE] public static boolean[] removeElements(final boolean[] array, final boolean... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<Boolean, MutableInt> occurrences = new HashMap<Boolean, MutableInt>(2); [EOL]     for (final boolean v : values) { [EOL]         final Boolean boxed = Boolean.valueOf(v); [EOL]         final MutableInt count = occurrences.get(boxed); [EOL]         if (count == null) { [EOL]             occurrences.put(boxed, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<Boolean, MutableInt> e : occurrences.entrySet()) { [EOL]         final Boolean v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v.booleanValue(), found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     return (boolean[]) removeAll(array, toRemove); [EOL] } 
 [LINE] return (boolean[]) removeAll(array, toRemove); [LINE] public static boolean[] removeElements(final boolean[] array, final boolean... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<Boolean, MutableInt> occurrences = new HashMap<Boolean, MutableInt>(2); [EOL]     for (final boolean v : values) { [EOL]         final Boolean boxed = Boolean.valueOf(v); [EOL]         final MutableInt count = occurrences.get(boxed); [EOL]         if (count == null) { [EOL]             occurrences.put(boxed, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<Boolean, MutableInt> e : occurrences.entrySet()) { [EOL]         final Boolean v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v.booleanValue(), found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     return (boolean[]) removeAll(array, toRemove); [EOL] } 
 [LINE] if (isNotEmpty(indices)) { [LINE] static Object removeAll(final Object array, final int... indices) { [EOL]     final int length = getLength(array); [EOL]     int diff = 0; [EOL]     if (isNotEmpty(indices)) { [EOL]         Arrays.sort(indices); [EOL]         int i = indices.length; [EOL]         int prevIndex = length; [EOL]         while (--i >= 0) { [EOL]             final int index = indices[i]; [EOL]             if (index < 0 || index >= length) { [EOL]                 throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]             } [EOL]             if (index >= prevIndex) { [EOL]                 continue; [EOL]             } [EOL]             diff++; [EOL]             prevIndex = index; [EOL]         } [EOL]     } [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), length - diff); [EOL]     if (diff < length) { [EOL]         int end = length; [EOL]         int dest = length - diff; [EOL]         for (int i = indices.length - 1; i >= 0; i--) { [EOL]             final int index = indices[i]; [EOL]             if (end - index > 1) { [EOL]                 final int cp = end - index - 1; [EOL]                 dest -= cp; [EOL]                 System.arraycopy(array, index + 1, result, dest, cp); [EOL]             } [EOL]             end = index; [EOL]         } [EOL]         if (end > 0) { [EOL]             System.arraycopy(array, 0, result, 0, end); [EOL]         } [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] Arrays.sort(indices); [LINE] static Object removeAll(final Object array, final int... indices) { [EOL]     final int length = getLength(array); [EOL]     int diff = 0; [EOL]     if (isNotEmpty(indices)) { [EOL]         Arrays.sort(indices); [EOL]         int i = indices.length; [EOL]         int prevIndex = length; [EOL]         while (--i >= 0) { [EOL]             final int index = indices[i]; [EOL]             if (index < 0 || index >= length) { [EOL]                 throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]             } [EOL]             if (index >= prevIndex) { [EOL]                 continue; [EOL]             } [EOL]             diff++; [EOL]             prevIndex = index; [EOL]         } [EOL]     } [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), length - diff); [EOL]     if (diff < length) { [EOL]         int end = length; [EOL]         int dest = length - diff; [EOL]         for (int i = indices.length - 1; i >= 0; i--) { [EOL]             final int index = indices[i]; [EOL]             if (end - index > 1) { [EOL]                 final int cp = end - index - 1; [EOL]                 dest -= cp; [EOL]                 System.arraycopy(array, index + 1, result, dest, cp); [EOL]             } [EOL]             end = index; [EOL]         } [EOL]         if (end > 0) { [EOL]             System.arraycopy(array, 0, result, 0, end); [EOL]         } [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] if (index >= prevIndex) { [LINE] static Object removeAll(final Object array, final int... indices) { [EOL]     final int length = getLength(array); [EOL]     int diff = 0; [EOL]     if (isNotEmpty(indices)) { [EOL]         Arrays.sort(indices); [EOL]         int i = indices.length; [EOL]         int prevIndex = length; [EOL]         while (--i >= 0) { [EOL]             final int index = indices[i]; [EOL]             if (index < 0 || index >= length) { [EOL]                 throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]             } [EOL]             if (index >= prevIndex) { [EOL]                 continue; [EOL]             } [EOL]             diff++; [EOL]             prevIndex = index; [EOL]         } [EOL]     } [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), length - diff); [EOL]     if (diff < length) { [EOL]         int end = length; [EOL]         int dest = length - diff; [EOL]         for (int i = indices.length - 1; i >= 0; i--) { [EOL]             final int index = indices[i]; [EOL]             if (end - index > 1) { [EOL]                 final int cp = end - index - 1; [EOL]                 dest -= cp; [EOL]                 System.arraycopy(array, index + 1, result, dest, cp); [EOL]             } [EOL]             end = index; [EOL]         } [EOL]         if (end > 0) { [EOL]             System.arraycopy(array, 0, result, 0, end); [EOL]         } [EOL]     } [EOL]     return result; [EOL] } 
 [LINE] count = set - srcIndex; [LINE] static Object removeAll(final Object array, final BitSet indices) { [EOL]     final int srcLength = ArrayUtils.getLength(array); [EOL]     final int removals = indices.cardinality(); [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), srcLength - removals); [EOL]     int srcIndex = 0; [EOL]     int destIndex = 0; [EOL]     int count; [EOL]     int set; [EOL]     while ((set = indices.nextSetBit(srcIndex)) != -1) { [EOL]         count = set - srcIndex; [EOL]         if (count > 0) { [EOL]             System.arraycopy(array, srcIndex, result, destIndex, count); [EOL]             destIndex += count; [EOL]         } [EOL]         srcIndex = indices.nextClearBit(set); [EOL]     } [EOL]     count = srcLength - srcIndex; [EOL]     if (count > 0) { [EOL]         System.arraycopy(array, srcIndex, result, destIndex, count); [EOL]     } [EOL]     return result; [EOL] } 
lang3/LocaleUtils.java
 [LINE] throw new IllegalArgumentException("Invalid locale format: " + str); [LINE] public static Locale toLocale(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (str.contains("#")) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len < 2) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch0 = str.charAt(0); [EOL]     if (ch0 == '_') { [EOL]         if (len < 3) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         final char ch1 = str.charAt(1); [EOL]         final char ch2 = str.charAt(2); [EOL]         if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (len == 3) { [EOL]             return new Locale("", str.substring(1, 3)); [EOL]         } [EOL]         if (len < 5) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (str.charAt(3) != '_') { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         return new Locale("", str.substring(1, 3), str.substring(4)); [EOL]     } [EOL]     final char ch1 = str.charAt(1); [EOL]     if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 2) { [EOL]         return new Locale(str); [EOL]     } [EOL]     if (len < 5) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(2) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch3 = str.charAt(3); [EOL]     if (ch3 == '_') { [EOL]         return new Locale(str.substring(0, 2), "", str.substring(4)); [EOL]     } [EOL]     final char ch4 = str.charAt(4); [EOL]     if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 5) { [EOL]         return new Locale(str.substring(0, 2), str.substring(3, 5)); [EOL]     } [EOL]     if (len < 7) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(5) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6)); [EOL] } 
 [LINE] final int len = str.length(); [LINE] public static Locale toLocale(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (str.contains("#")) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len < 2) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch0 = str.charAt(0); [EOL]     if (ch0 == '_') { [EOL]         if (len < 3) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         final char ch1 = str.charAt(1); [EOL]         final char ch2 = str.charAt(2); [EOL]         if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (len == 3) { [EOL]             return new Locale("", str.substring(1, 3)); [EOL]         } [EOL]         if (len < 5) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (str.charAt(3) != '_') { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         return new Locale("", str.substring(1, 3), str.substring(4)); [EOL]     } [EOL]     final char ch1 = str.charAt(1); [EOL]     if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 2) { [EOL]         return new Locale(str); [EOL]     } [EOL]     if (len < 5) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(2) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch3 = str.charAt(3); [EOL]     if (ch3 == '_') { [EOL]         return new Locale(str.substring(0, 2), "", str.substring(4)); [EOL]     } [EOL]     final char ch4 = str.charAt(4); [EOL]     if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 5) { [EOL]         return new Locale(str.substring(0, 2), str.substring(3, 5)); [EOL]     } [EOL]     if (len < 7) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(5) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6)); [EOL] } 
 [LINE] throw new IllegalArgumentException("Invalid locale format: " + str); [LINE] public static Locale toLocale(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (str.contains("#")) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len < 2) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch0 = str.charAt(0); [EOL]     if (ch0 == '_') { [EOL]         if (len < 3) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         final char ch1 = str.charAt(1); [EOL]         final char ch2 = str.charAt(2); [EOL]         if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (len == 3) { [EOL]             return new Locale("", str.substring(1, 3)); [EOL]         } [EOL]         if (len < 5) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (str.charAt(3) != '_') { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         return new Locale("", str.substring(1, 3), str.substring(4)); [EOL]     } [EOL]     final char ch1 = str.charAt(1); [EOL]     if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 2) { [EOL]         return new Locale(str); [EOL]     } [EOL]     if (len < 5) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(2) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch3 = str.charAt(3); [EOL]     if (ch3 == '_') { [EOL]         return new Locale(str.substring(0, 2), "", str.substring(4)); [EOL]     } [EOL]     final char ch4 = str.charAt(4); [EOL]     if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 5) { [EOL]         return new Locale(str.substring(0, 2), str.substring(3, 5)); [EOL]     } [EOL]     if (len < 7) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(5) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6)); [EOL] } 
 [LINE] throw new IllegalArgumentException("Invalid locale format: " + str); [LINE] public static Locale toLocale(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (str.contains("#")) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len < 2) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch0 = str.charAt(0); [EOL]     if (ch0 == '_') { [EOL]         if (len < 3) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         final char ch1 = str.charAt(1); [EOL]         final char ch2 = str.charAt(2); [EOL]         if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (len == 3) { [EOL]             return new Locale("", str.substring(1, 3)); [EOL]         } [EOL]         if (len < 5) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (str.charAt(3) != '_') { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         return new Locale("", str.substring(1, 3), str.substring(4)); [EOL]     } [EOL]     final char ch1 = str.charAt(1); [EOL]     if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 2) { [EOL]         return new Locale(str); [EOL]     } [EOL]     if (len < 5) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(2) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch3 = str.charAt(3); [EOL]     if (ch3 == '_') { [EOL]         return new Locale(str.substring(0, 2), "", str.substring(4)); [EOL]     } [EOL]     final char ch4 = str.charAt(4); [EOL]     if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 5) { [EOL]         return new Locale(str.substring(0, 2), str.substring(3, 5)); [EOL]     } [EOL]     if (len < 7) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(5) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6)); [EOL] } 
 [LINE] final char ch1 = str.charAt(1); [LINE] public static Locale toLocale(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (str.contains("#")) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len < 2) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch0 = str.charAt(0); [EOL]     if (ch0 == '_') { [EOL]         if (len < 3) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         final char ch1 = str.charAt(1); [EOL]         final char ch2 = str.charAt(2); [EOL]         if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (len == 3) { [EOL]             return new Locale("", str.substring(1, 3)); [EOL]         } [EOL]         if (len < 5) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (str.charAt(3) != '_') { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         return new Locale("", str.substring(1, 3), str.substring(4)); [EOL]     } [EOL]     final char ch1 = str.charAt(1); [EOL]     if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 2) { [EOL]         return new Locale(str); [EOL]     } [EOL]     if (len < 5) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(2) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch3 = str.charAt(3); [EOL]     if (ch3 == '_') { [EOL]         return new Locale(str.substring(0, 2), "", str.substring(4)); [EOL]     } [EOL]     final char ch4 = str.charAt(4); [EOL]     if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 5) { [EOL]         return new Locale(str.substring(0, 2), str.substring(3, 5)); [EOL]     } [EOL]     if (len < 7) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(5) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6)); [EOL] } 
 [LINE] if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) { [LINE] public static Locale toLocale(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (str.contains("#")) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len < 2) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch0 = str.charAt(0); [EOL]     if (ch0 == '_') { [EOL]         if (len < 3) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         final char ch1 = str.charAt(1); [EOL]         final char ch2 = str.charAt(2); [EOL]         if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (len == 3) { [EOL]             return new Locale("", str.substring(1, 3)); [EOL]         } [EOL]         if (len < 5) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (str.charAt(3) != '_') { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         return new Locale("", str.substring(1, 3), str.substring(4)); [EOL]     } [EOL]     final char ch1 = str.charAt(1); [EOL]     if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 2) { [EOL]         return new Locale(str); [EOL]     } [EOL]     if (len < 5) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(2) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch3 = str.charAt(3); [EOL]     if (ch3 == '_') { [EOL]         return new Locale(str.substring(0, 2), "", str.substring(4)); [EOL]     } [EOL]     final char ch4 = str.charAt(4); [EOL]     if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 5) { [EOL]         return new Locale(str.substring(0, 2), str.substring(3, 5)); [EOL]     } [EOL]     if (len < 7) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(5) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6)); [EOL] } 
 [LINE] return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6)); [LINE] public static Locale toLocale(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (str.contains("#")) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len < 2) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch0 = str.charAt(0); [EOL]     if (ch0 == '_') { [EOL]         if (len < 3) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         final char ch1 = str.charAt(1); [EOL]         final char ch2 = str.charAt(2); [EOL]         if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (len == 3) { [EOL]             return new Locale("", str.substring(1, 3)); [EOL]         } [EOL]         if (len < 5) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (str.charAt(3) != '_') { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         return new Locale("", str.substring(1, 3), str.substring(4)); [EOL]     } [EOL]     final char ch1 = str.charAt(1); [EOL]     if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 2) { [EOL]         return new Locale(str); [EOL]     } [EOL]     if (len < 5) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(2) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch3 = str.charAt(3); [EOL]     if (ch3 == '_') { [EOL]         return new Locale(str.substring(0, 2), "", str.substring(4)); [EOL]     } [EOL]     final char ch4 = str.charAt(4); [EOL]     if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 5) { [EOL]         return new Locale(str.substring(0, 2), str.substring(3, 5)); [EOL]     } [EOL]     if (len < 7) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(5) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6)); [EOL] } 
 [LINE] return localeLookupList(locale, locale); [LINE] public static List<Locale> localeLookupList(final Locale locale) { [EOL]     return localeLookupList(locale, locale); [EOL] } 
 [LINE] if (locale != null) { [LINE] public static List<Locale> localeLookupList(final Locale locale, final Locale defaultLocale) { [EOL]     final List<Locale> list = new ArrayList<Locale>(4); [EOL]     if (locale != null) { [EOL]         list.add(locale); [EOL]         if (locale.getVariant().length() > 0) { [EOL]             list.add(new Locale(locale.getLanguage(), locale.getCountry())); [EOL]         } [EOL]         if (locale.getCountry().length() > 0) { [EOL]             list.add(new Locale(locale.getLanguage(), "")); [EOL]         } [EOL]         if (list.contains(defaultLocale) == false) { [EOL]             list.add(defaultLocale); [EOL]         } [EOL]     } [EOL]     return Collections.unmodifiableList(list); [EOL] } 
 [LINE] list.add(new Locale(locale.getLanguage(), "")); [LINE] public static List<Locale> localeLookupList(final Locale locale, final Locale defaultLocale) { [EOL]     final List<Locale> list = new ArrayList<Locale>(4); [EOL]     if (locale != null) { [EOL]         list.add(locale); [EOL]         if (locale.getVariant().length() > 0) { [EOL]             list.add(new Locale(locale.getLanguage(), locale.getCountry())); [EOL]         } [EOL]         if (locale.getCountry().length() > 0) { [EOL]             list.add(new Locale(locale.getLanguage(), "")); [EOL]         } [EOL]         if (list.contains(defaultLocale) == false) { [EOL]             list.add(defaultLocale); [EOL]         } [EOL]     } [EOL]     return Collections.unmodifiableList(list); [EOL] } 
 [LINE] final List<Locale> locales = availableLocaleList(); [LINE] public static List<Locale> languagesByCountry(final String countryCode) { [EOL]     if (countryCode == null) { [EOL]         return Collections.emptyList(); [EOL]     } [EOL]     List<Locale> langs = cLanguagesByCountry.get(countryCode); [EOL]     if (langs == null) { [EOL]         langs = new ArrayList<Locale>(); [EOL]         final List<Locale> locales = availableLocaleList(); [EOL]         for (int i = 0; i < locales.size(); i++) { [EOL]             final Locale locale = locales.get(i); [EOL]             if (countryCode.equals(locale.getCountry()) && locale.getVariant().isEmpty()) { [EOL]                 langs.add(locale); [EOL]             } [EOL]         } [EOL]         langs = Collections.unmodifiableList(langs); [EOL]         cLanguagesByCountry.putIfAbsent(countryCode, langs); [EOL]         langs = cLanguagesByCountry.get(countryCode); [EOL]     } [EOL]     return langs; [EOL] } 
 [LINE] if (countryCode.equals(locale.getCountry()) && [LINE] public static List<Locale> languagesByCountry(final String countryCode) { [EOL]     if (countryCode == null) { [EOL]         return Collections.emptyList(); [EOL]     } [EOL]     List<Locale> langs = cLanguagesByCountry.get(countryCode); [EOL]     if (langs == null) { [EOL]         langs = new ArrayList<Locale>(); [EOL]         final List<Locale> locales = availableLocaleList(); [EOL]         for (int i = 0; i < locales.size(); i++) { [EOL]             final Locale locale = locales.get(i); [EOL]             if (countryCode.equals(locale.getCountry()) && locale.getVariant().isEmpty()) { [EOL]                 langs.add(locale); [EOL]             } [EOL]         } [EOL]         langs = Collections.unmodifiableList(langs); [EOL]         cLanguagesByCountry.putIfAbsent(countryCode, langs); [EOL]         langs = cLanguagesByCountry.get(countryCode); [EOL]     } [EOL]     return langs; [EOL] } 
 [LINE] langs.add(locale); [LINE] public static List<Locale> languagesByCountry(final String countryCode) { [EOL]     if (countryCode == null) { [EOL]         return Collections.emptyList(); [EOL]     } [EOL]     List<Locale> langs = cLanguagesByCountry.get(countryCode); [EOL]     if (langs == null) { [EOL]         langs = new ArrayList<Locale>(); [EOL]         final List<Locale> locales = availableLocaleList(); [EOL]         for (int i = 0; i < locales.size(); i++) { [EOL]             final Locale locale = locales.get(i); [EOL]             if (countryCode.equals(locale.getCountry()) && locale.getVariant().isEmpty()) { [EOL]                 langs.add(locale); [EOL]             } [EOL]         } [EOL]         langs = Collections.unmodifiableList(langs); [EOL]         cLanguagesByCountry.putIfAbsent(countryCode, langs); [EOL]         langs = cLanguagesByCountry.get(countryCode); [EOL]     } [EOL]     return langs; [EOL] } 
 [LINE] return langs; [LINE] public static List<Locale> languagesByCountry(final String countryCode) { [EOL]     if (countryCode == null) { [EOL]         return Collections.emptyList(); [EOL]     } [EOL]     List<Locale> langs = cLanguagesByCountry.get(countryCode); [EOL]     if (langs == null) { [EOL]         langs = new ArrayList<Locale>(); [EOL]         final List<Locale> locales = availableLocaleList(); [EOL]         for (int i = 0; i < locales.size(); i++) { [EOL]             final Locale locale = locales.get(i); [EOL]             if (countryCode.equals(locale.getCountry()) && locale.getVariant().isEmpty()) { [EOL]                 langs.add(locale); [EOL]             } [EOL]         } [EOL]         langs = Collections.unmodifiableList(langs); [EOL]         cLanguagesByCountry.putIfAbsent(countryCode, langs); [EOL]         langs = cLanguagesByCountry.get(countryCode); [EOL]     } [EOL]     return langs; [EOL] } 
 [LINE] if (languageCode == null) { [LINE] public static List<Locale> countriesByLanguage(final String languageCode) { [EOL]     if (languageCode == null) { [EOL]         return Collections.emptyList(); [EOL]     } [EOL]     List<Locale> countries = cCountriesByLanguage.get(languageCode); [EOL]     if (countries == null) { [EOL]         countries = new ArrayList<Locale>(); [EOL]         final List<Locale> locales = availableLocaleList(); [EOL]         for (int i = 0; i < locales.size(); i++) { [EOL]             final Locale locale = locales.get(i); [EOL]             if (languageCode.equals(locale.getLanguage()) && locale.getCountry().length() != 0 && locale.getVariant().isEmpty()) { [EOL]                 countries.add(locale); [EOL]             } [EOL]         } [EOL]         countries = Collections.unmodifiableList(countries); [EOL]         cCountriesByLanguage.putIfAbsent(languageCode, countries); [EOL]         countries = cCountriesByLanguage.get(languageCode); [EOL]     } [EOL]     return countries; [EOL] } 
 [LINE] countries = Collections.unmodifiableList(countries); [LINE] public static List<Locale> countriesByLanguage(final String languageCode) { [EOL]     if (languageCode == null) { [EOL]         return Collections.emptyList(); [EOL]     } [EOL]     List<Locale> countries = cCountriesByLanguage.get(languageCode); [EOL]     if (countries == null) { [EOL]         countries = new ArrayList<Locale>(); [EOL]         final List<Locale> locales = availableLocaleList(); [EOL]         for (int i = 0; i < locales.size(); i++) { [EOL]             final Locale locale = locales.get(i); [EOL]             if (languageCode.equals(locale.getLanguage()) && locale.getCountry().length() != 0 && locale.getVariant().isEmpty()) { [EOL]                 countries.add(locale); [EOL]             } [EOL]         } [EOL]         countries = Collections.unmodifiableList(countries); [EOL]         cCountriesByLanguage.putIfAbsent(languageCode, countries); [EOL]         countries = cCountriesByLanguage.get(languageCode); [EOL]     } [EOL]     return countries; [EOL] } 
lang3/reflect/MethodUtils.java
 [LINE] final Class<?>[] parameterTypes = ClassUtils.toClass(args); [LINE] public static Object invokeMethod(final Object object, final String methodName, Object... args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException { [EOL]     if (args == null) { [EOL]         args = ArrayUtils.EMPTY_OBJECT_ARRAY; [EOL]     } [EOL]     final Class<?>[] parameterTypes = ClassUtils.toClass(args); [EOL]     return invokeMethod(object, methodName, args, parameterTypes); [EOL] } 
 [LINE] public static Object invokeMethod(final Object object, final String methodName, [LINE] public static Object invokeMethod(final Object object, final String methodName, Object... args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException { [EOL]     if (args == null) { [EOL]         args = ArrayUtils.EMPTY_OBJECT_ARRAY; [EOL]     } [EOL]     final Class<?>[] parameterTypes = ClassUtils.toClass(args); [EOL]     return invokeMethod(object, methodName, args, parameterTypes); [EOL] } 
 [LINE] if (method == null) { [LINE] public static Object invokeMethod(final Object object, final String methodName, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException { [EOL]     if (parameterTypes == null) { [EOL]         parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY; [EOL]     } [EOL]     if (args == null) { [EOL]         args = ArrayUtils.EMPTY_OBJECT_ARRAY; [EOL]     } [EOL]     final Method method = getMatchingAccessibleMethod(object.getClass(), methodName, parameterTypes); [EOL]     if (method == null) { [EOL]         throw new NoSuchMethodException("No such accessible method: " + methodName + "() on object: " + object.getClass().getName()); [EOL]     } [EOL]     return method.invoke(object, args); [EOL] } 
 [LINE] final Method method = getAccessibleMethod(object.getClass(), methodName, [LINE] public static Object invokeExactMethod(final Object object, final String methodName, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException { [EOL]     if (args == null) { [EOL]         args = ArrayUtils.EMPTY_OBJECT_ARRAY; [EOL]     } [EOL]     if (parameterTypes == null) { [EOL]         parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY; [EOL]     } [EOL]     final Method method = getAccessibleMethod(object.getClass(), methodName, parameterTypes); [EOL]     if (method == null) { [EOL]         throw new NoSuchMethodException("No such accessible method: " + methodName + "() on object: " + object.getClass().getName()); [EOL]     } [EOL]     return method.invoke(object, args); [EOL] } 
 [LINE] if (method == null) { [LINE] public static Object invokeExactMethod(final Object object, final String methodName, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException { [EOL]     if (args == null) { [EOL]         args = ArrayUtils.EMPTY_OBJECT_ARRAY; [EOL]     } [EOL]     if (parameterTypes == null) { [EOL]         parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY; [EOL]     } [EOL]     final Method method = getAccessibleMethod(object.getClass(), methodName, parameterTypes); [EOL]     if (method == null) { [EOL]         throw new NoSuchMethodException("No such accessible method: " + methodName + "() on object: " + object.getClass().getName()); [EOL]     } [EOL]     return method.invoke(object, args); [EOL] } 
 [LINE] args = ArrayUtils.EMPTY_OBJECT_ARRAY; [LINE] public static Object invokeExactStaticMethod(final Class<?> cls, final String methodName, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException { [EOL]     if (args == null) { [EOL]         args = ArrayUtils.EMPTY_OBJECT_ARRAY; [EOL]     } [EOL]     if (parameterTypes == null) { [EOL]         parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY; [EOL]     } [EOL]     final Method method = getAccessibleMethod(cls, methodName, parameterTypes); [EOL]     if (method == null) { [EOL]         throw new NoSuchMethodException("No such accessible method: " + methodName + "() on class: " + cls.getName()); [EOL]     } [EOL]     return method.invoke(null, args); [EOL] } 
 [LINE] if (parameterTypes == null) { [LINE] public static Object invokeStaticMethod(final Class<?> cls, final String methodName, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException { [EOL]     if (parameterTypes == null) { [EOL]         parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY; [EOL]     } [EOL]     if (args == null) { [EOL]         args = ArrayUtils.EMPTY_OBJECT_ARRAY; [EOL]     } [EOL]     final Method method = getMatchingAccessibleMethod(cls, methodName, parameterTypes); [EOL]     if (method == null) { [EOL]         throw new NoSuchMethodException("No such accessible method: " + methodName + "() on class: " + cls.getName()); [EOL]     } [EOL]     return method.invoke(null, args); [EOL] } 
 [LINE] parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY; [LINE] public static Object invokeStaticMethod(final Class<?> cls, final String methodName, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException { [EOL]     if (parameterTypes == null) { [EOL]         parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY; [EOL]     } [EOL]     if (args == null) { [EOL]         args = ArrayUtils.EMPTY_OBJECT_ARRAY; [EOL]     } [EOL]     final Method method = getMatchingAccessibleMethod(cls, methodName, parameterTypes); [EOL]     if (method == null) { [EOL]         throw new NoSuchMethodException("No such accessible method: " + methodName + "() on class: " + cls.getName()); [EOL]     } [EOL]     return method.invoke(null, args); [EOL] } 
 [LINE] if (args == null) { [LINE] public static Object invokeStaticMethod(final Class<?> cls, final String methodName, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException { [EOL]     if (parameterTypes == null) { [EOL]         parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY; [EOL]     } [EOL]     if (args == null) { [EOL]         args = ArrayUtils.EMPTY_OBJECT_ARRAY; [EOL]     } [EOL]     final Method method = getMatchingAccessibleMethod(cls, methodName, parameterTypes); [EOL]     if (method == null) { [EOL]         throw new NoSuchMethodException("No such accessible method: " + methodName + "() on class: " + cls.getName()); [EOL]     } [EOL]     return method.invoke(null, args); [EOL] } 
 [LINE] try { [LINE] public static Method getAccessibleMethod(final Class<?> cls, final String methodName, final Class<?>... parameterTypes) { [EOL]     try { [EOL]         return getAccessibleMethod(cls.getMethod(methodName, parameterTypes)); [EOL]     } catch (final NoSuchMethodException e) { [EOL]         return null; [EOL]     } [EOL] } 
 [LINE] return null; [LINE] public static Method getAccessibleMethod(final Class<?> cls, final String methodName, final Class<?>... parameterTypes) { [EOL]     try { [EOL]         return getAccessibleMethod(cls.getMethod(methodName, parameterTypes)); [EOL]     } catch (final NoSuchMethodException e) { [EOL]         return null; [EOL]     } [EOL] } 
 [LINE] final Class<?> cls = method.getDeclaringClass(); [LINE] public static Method getAccessibleMethod(Method method) { [EOL]     if (!MemberUtils.isAccessible(method)) { [EOL]         return null; [EOL]     } [EOL]     final Class<?> cls = method.getDeclaringClass(); [EOL]     if (Modifier.isPublic(cls.getModifiers())) { [EOL]         return method; [EOL]     } [EOL]     final String methodName = method.getName(); [EOL]     final Class<?>[] parameterTypes = method.getParameterTypes(); [EOL]     method = getAccessibleMethodFromInterfaceNest(cls, methodName, parameterTypes); [EOL]     if (method == null) { [EOL]         method = getAccessibleMethodFromSuperclass(cls, methodName, parameterTypes); [EOL]     } [EOL]     return method; [EOL] } 
 [LINE] return method; [LINE] public static Method getAccessibleMethod(Method method) { [EOL]     if (!MemberUtils.isAccessible(method)) { [EOL]         return null; [EOL]     } [EOL]     final Class<?> cls = method.getDeclaringClass(); [EOL]     if (Modifier.isPublic(cls.getModifiers())) { [EOL]         return method; [EOL]     } [EOL]     final String methodName = method.getName(); [EOL]     final Class<?>[] parameterTypes = method.getParameterTypes(); [EOL]     method = getAccessibleMethodFromInterfaceNest(cls, methodName, parameterTypes); [EOL]     if (method == null) { [EOL]         method = getAccessibleMethodFromSuperclass(cls, methodName, parameterTypes); [EOL]     } [EOL]     return method; [EOL] } 
 [LINE] final Class<?>[] parameterTypes = method.getParameterTypes(); [LINE] public static Method getAccessibleMethod(Method method) { [EOL]     if (!MemberUtils.isAccessible(method)) { [EOL]         return null; [EOL]     } [EOL]     final Class<?> cls = method.getDeclaringClass(); [EOL]     if (Modifier.isPublic(cls.getModifiers())) { [EOL]         return method; [EOL]     } [EOL]     final String methodName = method.getName(); [EOL]     final Class<?>[] parameterTypes = method.getParameterTypes(); [EOL]     method = getAccessibleMethodFromInterfaceNest(cls, methodName, parameterTypes); [EOL]     if (method == null) { [EOL]         method = getAccessibleMethodFromSuperclass(cls, methodName, parameterTypes); [EOL]     } [EOL]     return method; [EOL] } 
 [LINE] Method method = null; [LINE] private static Method getAccessibleMethodFromInterfaceNest(Class<?> cls, final String methodName, final Class<?>... parameterTypes) { [EOL]     Method method = null; [EOL]     for (; cls != null; cls = cls.getSuperclass()) { [EOL]         final Class<?>[] interfaces = cls.getInterfaces(); [EOL]         for (int i = 0; i < interfaces.length; i++) { [EOL]             if (!Modifier.isPublic(interfaces[i].getModifiers())) { [EOL]                 continue; [EOL]             } [EOL]             try { [EOL]                 method = interfaces[i].getDeclaredMethod(methodName, parameterTypes); [EOL]             } catch (final NoSuchMethodException e) { [EOL]             } [EOL]             if (method != null) { [EOL]                 break; [EOL]             } [EOL]             method = getAccessibleMethodFromInterfaceNest(interfaces[i], methodName, parameterTypes); [EOL]             if (method != null) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     return method; [EOL] } 
 [LINE] for (int i = 0; i < interfaces.length; i++) { [LINE] private static Method getAccessibleMethodFromInterfaceNest(Class<?> cls, final String methodName, final Class<?>... parameterTypes) { [EOL]     Method method = null; [EOL]     for (; cls != null; cls = cls.getSuperclass()) { [EOL]         final Class<?>[] interfaces = cls.getInterfaces(); [EOL]         for (int i = 0; i < interfaces.length; i++) { [EOL]             if (!Modifier.isPublic(interfaces[i].getModifiers())) { [EOL]                 continue; [EOL]             } [EOL]             try { [EOL]                 method = interfaces[i].getDeclaredMethod(methodName, parameterTypes); [EOL]             } catch (final NoSuchMethodException e) { [EOL]             } [EOL]             if (method != null) { [EOL]                 break; [EOL]             } [EOL]             method = getAccessibleMethodFromInterfaceNest(interfaces[i], methodName, parameterTypes); [EOL]             if (method != null) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     return method; [EOL] } 
 [LINE] try { [LINE] private static Method getAccessibleMethodFromInterfaceNest(Class<?> cls, final String methodName, final Class<?>... parameterTypes) { [EOL]     Method method = null; [EOL]     for (; cls != null; cls = cls.getSuperclass()) { [EOL]         final Class<?>[] interfaces = cls.getInterfaces(); [EOL]         for (int i = 0; i < interfaces.length; i++) { [EOL]             if (!Modifier.isPublic(interfaces[i].getModifiers())) { [EOL]                 continue; [EOL]             } [EOL]             try { [EOL]                 method = interfaces[i].getDeclaredMethod(methodName, parameterTypes); [EOL]             } catch (final NoSuchMethodException e) { [EOL]             } [EOL]             if (method != null) { [EOL]                 break; [EOL]             } [EOL]             method = getAccessibleMethodFromInterfaceNest(interfaces[i], methodName, parameterTypes); [EOL]             if (method != null) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     return method; [EOL] } 
 [LINE] try { [LINE] public static Method getMatchingAccessibleMethod(final Class<?> cls, final String methodName, final Class<?>... parameterTypes) { [EOL]     try { [EOL]         final Method method = cls.getMethod(methodName, parameterTypes); [EOL]         MemberUtils.setAccessibleWorkaround(method); [EOL]         return method; [EOL]     } catch (final NoSuchMethodException e) { [EOL]     } [EOL]     Method bestMatch = null; [EOL]     final Method[] methods = cls.getMethods(); [EOL]     for (final Method method : methods) { [EOL]         if (method.getName().equals(methodName) && ClassUtils.isAssignable(parameterTypes, method.getParameterTypes(), true)) { [EOL]             final Method accessibleMethod = getAccessibleMethod(method); [EOL]             if (accessibleMethod != null && (bestMatch == null || MemberUtils.compareParameterTypes(accessibleMethod.getParameterTypes(), bestMatch.getParameterTypes(), parameterTypes) < 0)) { [EOL]                 bestMatch = accessibleMethod; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (bestMatch != null) { [EOL]         MemberUtils.setAccessibleWorkaround(bestMatch); [EOL]     } [EOL]     return bestMatch; [EOL] } 
 [LINE] for (final Method method : methods) { [LINE] public static Method getMatchingAccessibleMethod(final Class<?> cls, final String methodName, final Class<?>... parameterTypes) { [EOL]     try { [EOL]         final Method method = cls.getMethod(methodName, parameterTypes); [EOL]         MemberUtils.setAccessibleWorkaround(method); [EOL]         return method; [EOL]     } catch (final NoSuchMethodException e) { [EOL]     } [EOL]     Method bestMatch = null; [EOL]     final Method[] methods = cls.getMethods(); [EOL]     for (final Method method : methods) { [EOL]         if (method.getName().equals(methodName) && ClassUtils.isAssignable(parameterTypes, method.getParameterTypes(), true)) { [EOL]             final Method accessibleMethod = getAccessibleMethod(method); [EOL]             if (accessibleMethod != null && (bestMatch == null || MemberUtils.compareParameterTypes(accessibleMethod.getParameterTypes(), bestMatch.getParameterTypes(), parameterTypes) < 0)) { [EOL]                 bestMatch = accessibleMethod; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (bestMatch != null) { [EOL]         MemberUtils.setAccessibleWorkaround(bestMatch); [EOL]     } [EOL]     return bestMatch; [EOL] } 
 [LINE] if (method.getName().equals(methodName) && ClassUtils.isAssignable(parameterTypes, method.getParameterTypes(), true)) { [LINE] public static Method getMatchingAccessibleMethod(final Class<?> cls, final String methodName, final Class<?>... parameterTypes) { [EOL]     try { [EOL]         final Method method = cls.getMethod(methodName, parameterTypes); [EOL]         MemberUtils.setAccessibleWorkaround(method); [EOL]         return method; [EOL]     } catch (final NoSuchMethodException e) { [EOL]     } [EOL]     Method bestMatch = null; [EOL]     final Method[] methods = cls.getMethods(); [EOL]     for (final Method method : methods) { [EOL]         if (method.getName().equals(methodName) && ClassUtils.isAssignable(parameterTypes, method.getParameterTypes(), true)) { [EOL]             final Method accessibleMethod = getAccessibleMethod(method); [EOL]             if (accessibleMethod != null && (bestMatch == null || MemberUtils.compareParameterTypes(accessibleMethod.getParameterTypes(), bestMatch.getParameterTypes(), parameterTypes) < 0)) { [EOL]                 bestMatch = accessibleMethod; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (bestMatch != null) { [EOL]         MemberUtils.setAccessibleWorkaround(bestMatch); [EOL]     } [EOL]     return bestMatch; [EOL] } 
 [LINE] MemberUtils.setAccessibleWorkaround(bestMatch); [LINE] public static Method getMatchingAccessibleMethod(final Class<?> cls, final String methodName, final Class<?>... parameterTypes) { [EOL]     try { [EOL]         final Method method = cls.getMethod(methodName, parameterTypes); [EOL]         MemberUtils.setAccessibleWorkaround(method); [EOL]         return method; [EOL]     } catch (final NoSuchMethodException e) { [EOL]     } [EOL]     Method bestMatch = null; [EOL]     final Method[] methods = cls.getMethods(); [EOL]     for (final Method method : methods) { [EOL]         if (method.getName().equals(methodName) && ClassUtils.isAssignable(parameterTypes, method.getParameterTypes(), true)) { [EOL]             final Method accessibleMethod = getAccessibleMethod(method); [EOL]             if (accessibleMethod != null && (bestMatch == null || MemberUtils.compareParameterTypes(accessibleMethod.getParameterTypes(), bestMatch.getParameterTypes(), parameterTypes) < 0)) { [EOL]                 bestMatch = accessibleMethod; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (bestMatch != null) { [EOL]         MemberUtils.setAccessibleWorkaround(bestMatch); [EOL]     } [EOL]     return bestMatch; [EOL] } 
lang3/builder/StandardToStringStyle.java
lang3/tuple/ImmutableTriple.java
lang3/concurrent/BasicThreadFactory.java
 [LINE] return uncaughtExceptionHandler; [LINE] public final Thread.UncaughtExceptionHandler getUncaughtExceptionHandler() { [EOL]     return uncaughtExceptionHandler; [EOL] } 
 [LINE] initializeThread(t); [LINE] @Override [EOL] public Thread newThread(final Runnable r) { [EOL]     final Thread t = getWrappedFactory().newThread(r); [EOL]     initializeThread(t); [EOL]     return t; [EOL] } 
 [LINE] return t; [LINE] @Override [EOL] public Thread newThread(final Runnable r) { [EOL]     final Thread t = getWrappedFactory().newThread(r); [EOL]     initializeThread(t); [EOL]     return t; [EOL] } 
 [LINE] t.setDaemon(getDaemonFlag().booleanValue()); [LINE] private void initializeThread(final Thread t) { [EOL]     if (getNamingPattern() != null) { [EOL]         final Long count = Long.valueOf(threadCounter.incrementAndGet()); [EOL]         t.setName(String.format(getNamingPattern(), count)); [EOL]     } [EOL]     if (getUncaughtExceptionHandler() != null) { [EOL]         t.setUncaughtExceptionHandler(getUncaughtExceptionHandler()); [EOL]     } [EOL]     if (getPriority() != null) { [EOL]         t.setPriority(getPriority().intValue()); [EOL]     } [EOL]     if (getDaemonFlag() != null) { [EOL]         t.setDaemon(getDaemonFlag().booleanValue()); [EOL]     } [EOL] } 
 [LINE] wrappedFactory = factory; [LINE] public Builder wrappedFactory(final ThreadFactory factory) { [EOL]     if (factory == null) { [EOL]         throw new NullPointerException("Wrapped ThreadFactory must not be null!"); [EOL]     } [EOL]     wrappedFactory = factory; [EOL]     return this; [EOL] } 
 [LINE] priority = Integer.valueOf(prio); [LINE] public Builder priority(final int prio) { [EOL]     priority = Integer.valueOf(prio); [EOL]     return this; [EOL] } 
 [LINE] exceptionHandler = handler; [LINE] public Builder uncaughtExceptionHandler(final Thread.UncaughtExceptionHandler handler) { [EOL]     if (handler == null) { [EOL]         throw new NullPointerException("Uncaught exception handler must not be null!"); [EOL]     } [EOL]     exceptionHandler = handler; [EOL]     return this; [EOL] } 
 [LINE] namingPattern = null; [LINE] public void reset() { [EOL]     wrappedFactory = null; [EOL]     exceptionHandler = null; [EOL]     namingPattern = null; [EOL]     priority = null; [EOL]     daemonFlag = null; [EOL] } 
 [LINE] reset(); [LINE] @Override [EOL] public BasicThreadFactory build() { [EOL]     final BasicThreadFactory factory = new BasicThreadFactory(this); [EOL]     reset(); [EOL]     return factory; [EOL] } 
 [LINE] return factory; [LINE] @Override [EOL] public BasicThreadFactory build() { [EOL]     final BasicThreadFactory factory = new BasicThreadFactory(this); [EOL]     reset(); [EOL]     return factory; [EOL] } 
