@Test [EOL]     public void testGet() throws ConcurrentException { [EOL]         assertEquals("Wrong object", VALUE, init.get()); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests equals() if the expected result is true. [EOL]      */ [EOL]
@Test [EOL]     public void testGet() throws ConcurrentException { [EOL]         assertEquals("Wrong object", VALUE, init.get()); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests equals() if the expected result is true. [EOL]      */ [EOL]
@Test [EOL]     public void testGet() throws ConcurrentException { [EOL]         assertEquals("Wrong object", VALUE, init.get()); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests equals() if the expected result is true. [EOL]      */ [EOL]
@Test [EOL]     public void testGet() throws ConcurrentException { [EOL]         assertEquals("Wrong object", VALUE, init.get()); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests equals() if the expected result is true. [EOL]      */ [EOL]
@Test [EOL]     public void testGet() throws ConcurrentException { [EOL]         assertEquals("Wrong object", VALUE, init.get()); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests equals() if the expected result is true. [EOL]      */ [EOL]
@Test [EOL]     public void testGet() throws ConcurrentException { [EOL]         assertEquals("Wrong object", VALUE, init.get()); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests equals() if the expected result is true. [EOL]      */ [EOL]
@Test [EOL]     public void testGet() throws ConcurrentException { [EOL]         assertEquals("Wrong object", VALUE, init.get()); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests equals() if the expected result is true. [EOL]      */ [EOL]
@Test [EOL]     public void testGet() throws ConcurrentException { [EOL]         assertEquals("Wrong object", VALUE, init.get()); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests equals() if the expected result is true. [EOL]      */ [EOL]
@Test [EOL]     public void testInclusiveBetween_withMessage() [EOL]     { [EOL]         Validate.inclusiveBetween("a", "c", "b", "Error"); [EOL]         Validate.inclusiveBetween(0, 2, 1, "Error"); [EOL]         Validate.inclusiveBetween(0, 2, 2, "Error"); [EOL]         try { [EOL]             Validate.inclusiveBetween(0, 5, 6, "Error"); [EOL]             fail("Expecting IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             assertEquals("Error", e.getMessage()); [EOL]         } [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testExclusiveBetween() [EOL]     { [EOL]         Validate.exclusiveBetween("a", "c", "b"); [EOL]         Validate.exclusiveBetween(0, 2, 1); [EOL]         try { [EOL]             Validate.exclusiveBetween(0, 5, 6); [EOL]             fail("Expecting IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             assertEquals("The value 6 is not in the specified exclusive range of 0 to 5", e.getMessage()); [EOL]         } [EOL]         try { [EOL]             Validate.exclusiveBetween(0, 5, 5); [EOL]             fail("Expecting IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             assertEquals("The value 5 is not in the specified exclusive range of 0 to 5", e.getMessage()); [EOL]         } [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testIntegerWithTransients() { [EOL]         testInteger(true); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNpeForNullElement() { [EOL]         final Object[] x1 = new Object[] { Integer.valueOf(1), null, Integer.valueOf(3) }; [EOL]         final Object[] x2 = new Object[] { Integer.valueOf(1), Integer.valueOf(2), Integer.valueOf(3) }; [EOL]  [EOL]         // causes an NPE in 2.0 according to: [EOL]         // http://issues.apache.org/bugzilla/show_bug.cgi?id=33067 [EOL]         new EqualsBuilder().append(x1, x2); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNpeForNullElement() { [EOL]         final Object[] x1 = new Object[] { Integer.valueOf(1), null, Integer.valueOf(3) }; [EOL]         final Object[] x2 = new Object[] { Integer.valueOf(1), Integer.valueOf(2), Integer.valueOf(3) }; [EOL]  [EOL]         // causes an NPE in 2.0 according to: [EOL]         // http://issues.apache.org/bugzilla/show_bug.cgi?id=33067 [EOL]         new EqualsBuilder().append(x1, x2); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNpeForNullElement() { [EOL]         final Object[] x1 = new Object[] { Integer.valueOf(1), null, Integer.valueOf(3) }; [EOL]         final Object[] x2 = new Object[] { Integer.valueOf(1), Integer.valueOf(2), Integer.valueOf(3) }; [EOL]  [EOL]         // causes an NPE in 2.0 according to: [EOL]         // http://issues.apache.org/bugzilla/show_bug.cgi?id=33067 [EOL]         new EqualsBuilder().append(x1, x2); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNpeForNullElement() { [EOL]         final Object[] x1 = new Object[] { Integer.valueOf(1), null, Integer.valueOf(3) }; [EOL]         final Object[] x2 = new Object[] { Integer.valueOf(1), Integer.valueOf(2), Integer.valueOf(3) }; [EOL]  [EOL]         // causes an NPE in 2.0 according to: [EOL]         // http://issues.apache.org/bugzilla/show_bug.cgi?id=33067 [EOL]         new EqualsBuilder().append(x1, x2); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNpeForNullElement() { [EOL]         final Object[] x1 = new Object[] { Integer.valueOf(1), null, Integer.valueOf(3) }; [EOL]         final Object[] x2 = new Object[] { Integer.valueOf(1), Integer.valueOf(2), Integer.valueOf(3) }; [EOL]  [EOL]         // causes an NPE in 2.0 according to: [EOL]         // http://issues.apache.org/bugzilla/show_bug.cgi?id=33067 [EOL]         new EqualsBuilder().append(x1, x2); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNpeForNullElement() { [EOL]         final Object[] x1 = new Object[] { Integer.valueOf(1), null, Integer.valueOf(3) }; [EOL]         final Object[] x2 = new Object[] { Integer.valueOf(1), Integer.valueOf(2), Integer.valueOf(3) }; [EOL]  [EOL]         // causes an NPE in 2.0 according to: [EOL]         // http://issues.apache.org/bugzilla/show_bug.cgi?id=33067 [EOL]         new EqualsBuilder().append(x1, x2); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNpeForNullElement() { [EOL]         final Object[] x1 = new Object[] { Integer.valueOf(1), null, Integer.valueOf(3) }; [EOL]         final Object[] x2 = new Object[] { Integer.valueOf(1), Integer.valueOf(2), Integer.valueOf(3) }; [EOL]  [EOL]         // causes an NPE in 2.0 according to: [EOL]         // http://issues.apache.org/bugzilla/show_bug.cgi?id=33067 [EOL]         new EqualsBuilder().append(x1, x2); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNpeForNullElement() { [EOL]         final Object[] x1 = new Object[] { Integer.valueOf(1), null, Integer.valueOf(3) }; [EOL]         final Object[] x2 = new Object[] { Integer.valueOf(1), Integer.valueOf(2), Integer.valueOf(3) }; [EOL]  [EOL]         // causes an NPE in 2.0 according to: [EOL]         // http://issues.apache.org/bugzilla/show_bug.cgi?id=33067 [EOL]         new EqualsBuilder().append(x1, x2); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNpeForNullElement() { [EOL]         final Object[] x1 = new Object[] { Integer.valueOf(1), null, Integer.valueOf(3) }; [EOL]         final Object[] x2 = new Object[] { Integer.valueOf(1), Integer.valueOf(2), Integer.valueOf(3) }; [EOL]  [EOL]         // causes an NPE in 2.0 according to: [EOL]         // http://issues.apache.org/bugzilla/show_bug.cgi?id=33067 [EOL]         new EqualsBuilder().append(x1, x2); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testCharArrayHiddenByObject() { [EOL]         final char[] array1 = new char[2]; [EOL]         array1[0] = 5; [EOL]         array1[1] = 6; [EOL]         final char[] array2 = new char[2]; [EOL]         array2[0] = 5; [EOL]         array2[1] = 6; [EOL]         final Object obj1 = array1; [EOL]         final Object obj2 = array2; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, array1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, array2).isEquals()); [EOL]         array1[1] = 7; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNpeForNullElement() { [EOL]         final Object[] x1 = new Object[] { Integer.valueOf(1), null, Integer.valueOf(3) }; [EOL]         final Object[] x2 = new Object[] { Integer.valueOf(1), Integer.valueOf(2), Integer.valueOf(3) }; [EOL]  [EOL]         // causes an NPE in 2.0 according to: [EOL]         // http://issues.apache.org/bugzilla/show_bug.cgi?id=33067 [EOL]         new EqualsBuilder().append(x1, x2); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testByteArray() { [EOL]         byte[] obj1 = new byte[2]; [EOL]         obj1[0] = 5; [EOL]         obj1[1] = 6; [EOL]         byte[] obj2 = new byte[2]; [EOL]         obj2[0] = 5; [EOL]         obj2[1] = 6; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         obj1[1] = 7; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]  [EOL]         obj2 = null; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         obj1 = null; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNpeForNullElement() { [EOL]         final Object[] x1 = new Object[] { Integer.valueOf(1), null, Integer.valueOf(3) }; [EOL]         final Object[] x2 = new Object[] { Integer.valueOf(1), Integer.valueOf(2), Integer.valueOf(3) }; [EOL]  [EOL]         // causes an NPE in 2.0 according to: [EOL]         // http://issues.apache.org/bugzilla/show_bug.cgi?id=33067 [EOL]         new EqualsBuilder().append(x1, x2); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNpeForNullElement() { [EOL]         final Object[] x1 = new Object[] { Integer.valueOf(1), null, Integer.valueOf(3) }; [EOL]         final Object[] x2 = new Object[] { Integer.valueOf(1), Integer.valueOf(2), Integer.valueOf(3) }; [EOL]  [EOL]         // causes an NPE in 2.0 according to: [EOL]         // http://issues.apache.org/bugzilla/show_bug.cgi?id=33067 [EOL]         new EqualsBuilder().append(x1, x2); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testFloatArray() { [EOL]         float[] obj1 = new float[2]; [EOL]         obj1[0] = 5; [EOL]         obj1[1] = 6; [EOL]         float[] obj2 = new float[2]; [EOL]         obj2[0] = 5; [EOL]         obj2[1] = 6; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         obj1[1] = 7; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]  [EOL]         obj2 = null; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         obj1 = null; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testFloatArray() { [EOL]         float[] obj1 = new float[2]; [EOL]         obj1[0] = 5; [EOL]         obj1[1] = 6; [EOL]         float[] obj2 = new float[2]; [EOL]         obj2[0] = 5; [EOL]         obj2[1] = 6; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         obj1[1] = 7; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]  [EOL]         obj2 = null; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         obj1 = null; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNpeForNullElement() { [EOL]         final Object[] x1 = new Object[] { Integer.valueOf(1), null, Integer.valueOf(3) }; [EOL]         final Object[] x2 = new Object[] { Integer.valueOf(1), Integer.valueOf(2), Integer.valueOf(3) }; [EOL]  [EOL]         // causes an NPE in 2.0 according to: [EOL]         // http://issues.apache.org/bugzilla/show_bug.cgi?id=33067 [EOL]         new EqualsBuilder().append(x1, x2); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNpeForNullElement() { [EOL]         final Object[] x1 = new Object[] { Integer.valueOf(1), null, Integer.valueOf(3) }; [EOL]         final Object[] x2 = new Object[] { Integer.valueOf(1), Integer.valueOf(2), Integer.valueOf(3) }; [EOL]  [EOL]         // causes an NPE in 2.0 according to: [EOL]         // http://issues.apache.org/bugzilla/show_bug.cgi?id=33067 [EOL]         new EqualsBuilder().append(x1, x2); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNpeForNullElement() { [EOL]         final Object[] x1 = new Object[] { Integer.valueOf(1), null, Integer.valueOf(3) }; [EOL]         final Object[] x2 = new Object[] { Integer.valueOf(1), Integer.valueOf(2), Integer.valueOf(3) }; [EOL]  [EOL]         // causes an NPE in 2.0 according to: [EOL]         // http://issues.apache.org/bugzilla/show_bug.cgi?id=33067 [EOL]         new EqualsBuilder().append(x1, x2); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testShortArray() { [EOL]         short[] obj1 = new short[2]; [EOL]         obj1[0] = 5; [EOL]         obj1[1] = 6; [EOL]         short[] obj2 = new short[2]; [EOL]         obj2[0] = 5; [EOL]         obj2[1] = 6; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         obj1[1] = 7; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]  [EOL]         obj2 = null; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         obj1 = null; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testShortArray() { [EOL]         short[] obj1 = new short[2]; [EOL]         obj1[0] = 5; [EOL]         obj1[1] = 6; [EOL]         short[] obj2 = new short[2]; [EOL]         obj2[0] = 5; [EOL]         obj2[1] = 6; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         obj1[1] = 7; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]  [EOL]         obj2 = null; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         obj1 = null; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testShortArray() { [EOL]         short[] obj1 = new short[2]; [EOL]         obj1[0] = 5; [EOL]         obj1[1] = 6; [EOL]         short[] obj2 = new short[2]; [EOL]         obj2[0] = 5; [EOL]         obj2[1] = 6; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         obj1[1] = 7; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]  [EOL]         obj2 = null; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         obj1 = null; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testByteArray() { [EOL]         byte[] obj1 = new byte[2]; [EOL]         obj1[0] = 5; [EOL]         obj1[1] = 6; [EOL]         byte[] obj2 = new byte[2]; [EOL]         obj2[0] = 5; [EOL]         obj2[1] = 6; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         obj1[1] = 7; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]  [EOL]         obj2 = null; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         obj1 = null; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testByteArray() { [EOL]         byte[] obj1 = new byte[2]; [EOL]         obj1[0] = 5; [EOL]         obj1[1] = 6; [EOL]         byte[] obj2 = new byte[2]; [EOL]         obj2[0] = 5; [EOL]         obj2[1] = 6; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         obj1[1] = 7; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]  [EOL]         obj2 = null; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         obj1 = null; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testByteArray() { [EOL]         byte[] obj1 = new byte[2]; [EOL]         obj1[0] = 5; [EOL]         obj1[1] = 6; [EOL]         byte[] obj2 = new byte[2]; [EOL]         obj2[0] = 5; [EOL]         obj2[1] = 6; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         obj1[1] = 7; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]  [EOL]         obj2 = null; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         obj1 = null; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testDoubleArray() { [EOL]         double[] obj1 = new double[2]; [EOL]         obj1[0] = 5; [EOL]         obj1[1] = 6; [EOL]         double[] obj2 = new double[2]; [EOL]         obj2[0] = 5; [EOL]         obj2[1] = 6; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         obj1[1] = 7; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]  [EOL]         obj2 = null; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         obj1 = null; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testDoubleArray() { [EOL]         double[] obj1 = new double[2]; [EOL]         obj1[0] = 5; [EOL]         obj1[1] = 6; [EOL]         double[] obj2 = new double[2]; [EOL]         obj2[0] = 5; [EOL]         obj2[1] = 6; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         obj1[1] = 7; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]  [EOL]         obj2 = null; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         obj1 = null; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testDoubleArray() { [EOL]         double[] obj1 = new double[2]; [EOL]         obj1[0] = 5; [EOL]         obj1[1] = 6; [EOL]         double[] obj2 = new double[2]; [EOL]         obj2[0] = 5; [EOL]         obj2[1] = 6; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         obj1[1] = 7; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]  [EOL]         obj2 = null; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         obj1 = null; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testBooleanArray() { [EOL]         boolean[] obj1 = new boolean[2]; [EOL]         obj1[0] = true; [EOL]         obj1[1] = false; [EOL]         boolean[] obj2 = new boolean[2]; [EOL]         obj2[0] = true; [EOL]         obj2[1] = false; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         obj1[1] = true; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]  [EOL]         obj2 = null; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         obj1 = null; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testBooleanArray() { [EOL]         boolean[] obj1 = new boolean[2]; [EOL]         obj1[0] = true; [EOL]         obj1[1] = false; [EOL]         boolean[] obj2 = new boolean[2]; [EOL]         obj2[0] = true; [EOL]         obj2[1] = false; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         obj1[1] = true; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]  [EOL]         obj2 = null; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         obj1 = null; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testBooleanArray() { [EOL]         boolean[] obj1 = new boolean[2]; [EOL]         obj1[0] = true; [EOL]         obj1[1] = false; [EOL]         boolean[] obj2 = new boolean[2]; [EOL]         obj2[0] = true; [EOL]         obj2[1] = false; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         obj1[1] = true; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]  [EOL]         obj2 = null; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         obj1 = null; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testRandomStringUtils() { [EOL]         String r1 = RandomStringUtils.random(50); [EOL]         assertEquals("random(50) length", 50, r1.length()); [EOL]         String r2 = RandomStringUtils.random(50); [EOL]         assertEquals("random(50) length", 50, r2.length()); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]          [EOL]         r1 = RandomStringUtils.randomAscii(50); [EOL]         assertEquals("randomAscii(50) length", 50, r1.length()); [EOL]         for(int i = 0; i < r1.length(); i++) { [EOL]             assertTrue("char between 32 and 127", r1.charAt(i) >= 32 && r1.charAt(i) <= 127); [EOL]         }         [EOL]         r2 = RandomStringUtils.randomAscii(50); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]  [EOL]         r1 = RandomStringUtils.randomAlphabetic(50); [EOL]         assertEquals("randomAlphabetic(50)", 50, r1.length()); [EOL]         for(int i = 0; i < r1.length(); i++) { [EOL]          
@Test [EOL]     public void testRandomStringUtils() { [EOL]         String r1 = RandomStringUtils.random(50); [EOL]         assertEquals("random(50) length", 50, r1.length()); [EOL]         String r2 = RandomStringUtils.random(50); [EOL]         assertEquals("random(50) length", 50, r2.length()); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]          [EOL]         r1 = RandomStringUtils.randomAscii(50); [EOL]         assertEquals("randomAscii(50) length", 50, r1.length()); [EOL]         for(int i = 0; i < r1.length(); i++) { [EOL]             assertTrue("char between 32 and 127", r1.charAt(i) >= 32 && r1.charAt(i) <= 127); [EOL]         }         [EOL]         r2 = RandomStringUtils.randomAscii(50); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]  [EOL]         r1 = RandomStringUtils.randomAlphabetic(50); [EOL]         assertEquals("randomAlphabetic(50)", 50, r1.length()); [EOL]         for(int i = 0; i < r1.length(); i++) { [EOL]          
@Test [EOL]     public void testRandomStringUtils() { [EOL]         String r1 = RandomStringUtils.random(50); [EOL]         assertEquals("random(50) length", 50, r1.length()); [EOL]         String r2 = RandomStringUtils.random(50); [EOL]         assertEquals("random(50) length", 50, r2.length()); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]          [EOL]         r1 = RandomStringUtils.randomAscii(50); [EOL]         assertEquals("randomAscii(50) length", 50, r1.length()); [EOL]         for(int i = 0; i < r1.length(); i++) { [EOL]             assertTrue("char between 32 and 127", r1.charAt(i) >= 32 && r1.charAt(i) <= 127); [EOL]         }         [EOL]         r2 = RandomStringUtils.randomAscii(50); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]  [EOL]         r1 = RandomStringUtils.randomAlphabetic(50); [EOL]         assertEquals("randomAlphabetic(50)", 50, r1.length()); [EOL]         for(int i = 0; i < r1.length(); i++) { [EOL]          
@Test [EOL]     public void testRandomStringUtils() { [EOL]         String r1 = RandomStringUtils.random(50); [EOL]         assertEquals("random(50) length", 50, r1.length()); [EOL]         String r2 = RandomStringUtils.random(50); [EOL]         assertEquals("random(50) length", 50, r2.length()); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]          [EOL]         r1 = RandomStringUtils.randomAscii(50); [EOL]         assertEquals("randomAscii(50) length", 50, r1.length()); [EOL]         for(int i = 0; i < r1.length(); i++) { [EOL]             assertTrue("char between 32 and 127", r1.charAt(i) >= 32 && r1.charAt(i) <= 127); [EOL]         }         [EOL]         r2 = RandomStringUtils.randomAscii(50); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]  [EOL]         r1 = RandomStringUtils.randomAlphabetic(50); [EOL]         assertEquals("randomAlphabetic(50)", 50, r1.length()); [EOL]         for(int i = 0; i < r1.length(); i++) { [EOL]          
@Test [EOL]     public void testExceptions() { [EOL]         final char[] DUMMY = new char[]{'a'}; // valid char array [EOL]         try { [EOL]             RandomStringUtils.random(-1); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             RandomStringUtils.random(-1, true, true); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             RandomStringUtils.random(-1, DUMMY); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             RandomStringUtils.random(1, new char[0]); // must not provide empty array => IAE [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             RandomStringUtils.random(-1, ""); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]        
@Test [EOL]     public void testRandomStringUtils() { [EOL]         String r1 = RandomStringUtils.random(50); [EOL]         assertEquals("random(50) length", 50, r1.length()); [EOL]         String r2 = RandomStringUtils.random(50); [EOL]         assertEquals("random(50) length", 50, r2.length()); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]          [EOL]         r1 = RandomStringUtils.randomAscii(50); [EOL]         assertEquals("randomAscii(50) length", 50, r1.length()); [EOL]         for(int i = 0; i < r1.length(); i++) { [EOL]             assertTrue("char between 32 and 127", r1.charAt(i) >= 32 && r1.charAt(i) <= 127); [EOL]         }         [EOL]         r2 = RandomStringUtils.randomAscii(50); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]  [EOL]         r1 = RandomStringUtils.randomAlphabetic(50); [EOL]         assertEquals("randomAlphabetic(50)", 50, r1.length()); [EOL]         for(int i = 0; i < r1.length(); i++) { [EOL]          
@Test [EOL]     public void testExceptions() { [EOL]         final char[] DUMMY = new char[]{'a'}; // valid char array [EOL]         try { [EOL]             RandomStringUtils.random(-1); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             RandomStringUtils.random(-1, true, true); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             RandomStringUtils.random(-1, DUMMY); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             RandomStringUtils.random(1, new char[0]); // must not provide empty array => IAE [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             RandomStringUtils.random(-1, ""); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]        
@Test [EOL]     public void testRandomStringUtils() { [EOL]         String r1 = RandomStringUtils.random(50); [EOL]         assertEquals("random(50) length", 50, r1.length()); [EOL]         String r2 = RandomStringUtils.random(50); [EOL]         assertEquals("random(50) length", 50, r2.length()); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]          [EOL]         r1 = RandomStringUtils.randomAscii(50); [EOL]         assertEquals("randomAscii(50) length", 50, r1.length()); [EOL]         for(int i = 0; i < r1.length(); i++) { [EOL]             assertTrue("char between 32 and 127", r1.charAt(i) >= 32 && r1.charAt(i) <= 127); [EOL]         }         [EOL]         r2 = RandomStringUtils.randomAscii(50); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]  [EOL]         r1 = RandomStringUtils.randomAlphabetic(50); [EOL]         assertEquals("randomAlphabetic(50)", 50, r1.length()); [EOL]         for(int i = 0; i < r1.length(); i++) { [EOL]          
@Test [EOL]     public void testRandomStringUtils() { [EOL]         String r1 = RandomStringUtils.random(50); [EOL]         assertEquals("random(50) length", 50, r1.length()); [EOL]         String r2 = RandomStringUtils.random(50); [EOL]         assertEquals("random(50) length", 50, r2.length()); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]          [EOL]         r1 = RandomStringUtils.randomAscii(50); [EOL]         assertEquals("randomAscii(50) length", 50, r1.length()); [EOL]         for(int i = 0; i < r1.length(); i++) { [EOL]             assertTrue("char between 32 and 127", r1.charAt(i) >= 32 && r1.charAt(i) <= 127); [EOL]         }         [EOL]         r2 = RandomStringUtils.randomAscii(50); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]  [EOL]         r1 = RandomStringUtils.randomAlphabetic(50); [EOL]         assertEquals("randomAlphabetic(50)", 50, r1.length()); [EOL]         for(int i = 0; i < r1.length(); i++) { [EOL]          
@Test [EOL]     public void testRandomStringUtils() { [EOL]         String r1 = RandomStringUtils.random(50); [EOL]         assertEquals("random(50) length", 50, r1.length()); [EOL]         String r2 = RandomStringUtils.random(50); [EOL]         assertEquals("random(50) length", 50, r2.length()); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]          [EOL]         r1 = RandomStringUtils.randomAscii(50); [EOL]         assertEquals("randomAscii(50) length", 50, r1.length()); [EOL]         for(int i = 0; i < r1.length(); i++) { [EOL]             assertTrue("char between 32 and 127", r1.charAt(i) >= 32 && r1.charAt(i) <= 127); [EOL]         }         [EOL]         r2 = RandomStringUtils.randomAscii(50); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]  [EOL]         r1 = RandomStringUtils.randomAlphabetic(50); [EOL]         assertEquals("randomAlphabetic(50)", 50, r1.length()); [EOL]         for(int i = 0; i < r1.length(); i++) { [EOL]          
@Test [EOL]     public void testExceptions() { [EOL]         final char[] DUMMY = new char[]{'a'}; // valid char array [EOL]         try { [EOL]             RandomStringUtils.random(-1); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             RandomStringUtils.random(-1, true, true); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             RandomStringUtils.random(-1, DUMMY); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             RandomStringUtils.random(1, new char[0]); // must not provide empty array => IAE [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             RandomStringUtils.random(-1, ""); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]        
@Test [EOL]     public void testAppendSuper() { [EOL]         assertEquals("", new ToStringBuilder(base).appendSuper("").toString()); [EOL]         assertEquals("<null>", new ToStringBuilder(base).appendSuper("<null>").toString()); [EOL]          [EOL]         assertEquals("hello", new ToStringBuilder(base).appendSuper("").append("a", "hello").toString()); [EOL]         assertEquals("<null>,hello", new ToStringBuilder(base).appendSuper("<null>").append("a", "hello").toString()); [EOL]         assertEquals("hello", new ToStringBuilder(base).appendSuper(null).append("a", "hello").toString()); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[
@Test [EOL]     public void testByteArrayArray() { [EOL]         byte[][] array = new byte[][] {{1, 2}, null, {5}}; [EOL]         assertEquals(baseStr + "[{{1,2},<null>,{5}}]", new ToStringBuilder(base).append(array).toString()); [EOL]         assertEquals(baseStr + "[{{1,2},<null>,{5}}]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]         array = null; [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[
@Test [EOL]     public void testReflectionBooleanArray() { [EOL]         boolean[] array = new boolean[] { true, false, false }; [EOL]         final String baseStr = this.toBaseString(array); [EOL]         assertEquals(baseStr + "[{true,false,false}]", ToStringBuilder.reflectionToString(array)); [EOL]         array = null; [EOL]         assertReflectionArray("<null>", array); [EOL]     } [EOL]  [EOL]     // Reflection Array Array tests [EOL]  [EOL]
@Test [EOL]     public void testReflectionBooleanArray() { [EOL]         boolean[] array = new boolean[] { true, false, false }; [EOL]         final String baseStr = this.toBaseString(array); [EOL]         assertEquals(baseStr + "[{true,false,false}]", ToStringBuilder.reflectionToString(array)); [EOL]         array = null; [EOL]         assertReflectionArray("<null>", array); [EOL]     } [EOL]  [EOL]     // Reflection Array Array tests [EOL]  [EOL]
@Test [EOL]     public void testReflectionBooleanArray() { [EOL]         boolean[] array = new boolean[] { true, false, false }; [EOL]         final String baseStr = this.toBaseString(array); [EOL]         assertEquals(baseStr + "[{true,false,false}]", ToStringBuilder.reflectionToString(array)); [EOL]         array = null; [EOL]         assertReflectionArray("<null>", array); [EOL]     } [EOL]  [EOL]     // Reflection Array Array tests [EOL]  [EOL]
@Test [EOL]     public void testReflectionBooleanArray() { [EOL]         boolean[] array = new boolean[] { true, false, false }; [EOL]         final String baseStr = this.toBaseString(array); [EOL]         assertEquals(baseStr + "[{true,false,false}]", ToStringBuilder.reflectionToString(array)); [EOL]         array = null; [EOL]         assertReflectionArray("<null>", array); [EOL]     } [EOL]  [EOL]     // Reflection Array Array tests [EOL]  [EOL]
@Test [EOL]     public void testReflectionBooleanArray() { [EOL]         boolean[] array = new boolean[] { true, false, false }; [EOL]         final String baseStr = this.toBaseString(array); [EOL]         assertEquals(baseStr + "[{true,false,false}]", ToStringBuilder.reflectionToString(array)); [EOL]         array = null; [EOL]         assertReflectionArray("<null>", array); [EOL]     } [EOL]  [EOL]     // Reflection Array Array tests [EOL]  [EOL]
@Test [EOL]     public void testReflectionBooleanArray() { [EOL]         boolean[] array = new boolean[] { true, false, false }; [EOL]         final String baseStr = this.toBaseString(array); [EOL]         assertEquals(baseStr + "[{true,false,false}]", ToStringBuilder.reflectionToString(array)); [EOL]         array = null; [EOL]         assertReflectionArray("<null>", array); [EOL]     } [EOL]  [EOL]     // Reflection Array Array tests [EOL]  [EOL]
@Test [EOL]     public void testReflectionBooleanArray() { [EOL]         boolean[] array = new boolean[] { true, false, false }; [EOL]         final String baseStr = this.toBaseString(array); [EOL]         assertEquals(baseStr + "[{true,false,false}]", ToStringBuilder.reflectionToString(array)); [EOL]         array = null; [EOL]         assertReflectionArray("<null>", array); [EOL]     } [EOL]  [EOL]     // Reflection Array Array tests [EOL]  [EOL]
@Test [EOL]     public void testReflectionBooleanArray() { [EOL]         boolean[] array = new boolean[] { true, false, false }; [EOL]         final String baseStr = this.toBaseString(array); [EOL]         assertEquals(baseStr + "[{true,false,false}]", ToStringBuilder.reflectionToString(array)); [EOL]         array = null; [EOL]         assertReflectionArray("<null>", array); [EOL]     } [EOL]  [EOL]     // Reflection Array Array tests [EOL]  [EOL]
@Test [EOL]     public void testFloatArray() { [EOL]         float[] array = new float[] {1.0f, 2.9876f, -3.00001f, 4.3f}; [EOL]         assertEquals(baseStr + "[{1.0,2.9876,-3.00001,4.3}]", new ToStringBuilder(base).append(array).toString()); [EOL]         assertEquals(baseStr + "[{1.0,2.9876,-3.00001,4.3}]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]         array = null; [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSetSizeStartText() { [EOL]         final ToStringStyle style = new ToStringStyleImpl(); [EOL]         style.setSizeStartText(null); [EOL]         assertEquals("", style.getSizeStartText()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [E
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [E
@Test [EOL]     public void testGetTypeArguments() { [EOL]         Map<TypeVariable<?>, Type> typeVarAssigns; [EOL]         TypeVariable<?> treeSetTypeVar; [EOL]         Type typeArg; [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Integer.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from Integer: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]         Assert.assertEquals("Type argument of Comparable from Integer: " + typeArg, Integer.class, [EOL]                 typeVarAssigns.get(treeSetTypeVar)); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(int.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from int: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]       
@Test [EOL]     public void testGetTypeArguments() { [EOL]         Map<TypeVariable<?>, Type> typeVarAssigns; [EOL]         TypeVariable<?> treeSetTypeVar; [EOL]         Type typeArg; [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Integer.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from Integer: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]         Assert.assertEquals("Type argument of Comparable from Integer: " + typeArg, Integer.class, [EOL]                 typeVarAssigns.get(treeSetTypeVar)); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(int.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from int: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]       
@Test [EOL]     public void testGetTypeArguments() { [EOL]         Map<TypeVariable<?>, Type> typeVarAssigns; [EOL]         TypeVariable<?> treeSetTypeVar; [EOL]         Type typeArg; [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Integer.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from Integer: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]         Assert.assertEquals("Type argument of Comparable from Integer: " + typeArg, Integer.class, [EOL]                 typeVarAssigns.get(treeSetTypeVar)); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(int.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from int: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]       
@Test [EOL]     public void testIsInstance() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isInstance(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isInstance(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsInstance() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isInstance(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isInstance(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsInstance() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isInstance(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isInstance(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsInstance() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isInstance(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isInstance(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsInstance() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isInstance(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isInstance(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsInstance() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isInstance(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isInstance(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsInstance() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isInstance(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isInstance(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsInstance() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isInstance(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isInstance(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetTypeArguments() { [EOL]         Map<TypeVariable<?>, Type> typeVarAssigns; [EOL]         TypeVariable<?> treeSetTypeVar; [EOL]         Type typeArg; [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Integer.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from Integer: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]         Assert.assertEquals("Type argument of Comparable from Integer: " + typeArg, Integer.class, [EOL]                 typeVarAssigns.get(treeSetTypeVar)); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(int.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from int: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]       
@Test [EOL]     public void testGetTypeArguments() { [EOL]         Map<TypeVariable<?>, Type> typeVarAssigns; [EOL]         TypeVariable<?> treeSetTypeVar; [EOL]         Type typeArg; [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Integer.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from Integer: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]         Assert.assertEquals("Type argument of Comparable from Integer: " + typeArg, Integer.class, [EOL]                 typeVarAssigns.get(treeSetTypeVar)); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(int.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from int: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]       
@Test [EOL]     public void testGetTypeArguments() { [EOL]         Map<TypeVariable<?>, Type> typeVarAssigns; [EOL]         TypeVariable<?> treeSetTypeVar; [EOL]         Type typeArg; [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Integer.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from Integer: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]         Assert.assertEquals("Type argument of Comparable from Integer: " + typeArg, Integer.class, [EOL]                 typeVarAssigns.get(treeSetTypeVar)); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(int.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from int: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]       
@Test [EOL]     public void testGetTypeArguments() { [EOL]         Map<TypeVariable<?>, Type> typeVarAssigns; [EOL]         TypeVariable<?> treeSetTypeVar; [EOL]         Type typeArg; [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Integer.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from Integer: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]         Assert.assertEquals("Type argument of Comparable from Integer: " + typeArg, Integer.class, [EOL]                 typeVarAssigns.get(treeSetTypeVar)); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(int.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from int: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]       
@Test [EOL]     public void testGetTypeArguments() { [EOL]         Map<TypeVariable<?>, Type> typeVarAssigns; [EOL]         TypeVariable<?> treeSetTypeVar; [EOL]         Type typeArg; [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Integer.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from Integer: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]         Assert.assertEquals("Type argument of Comparable from Integer: " + typeArg, Integer.class, [EOL]                 typeVarAssigns.get(treeSetTypeVar)); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(int.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from int: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]       
@Test [EOL]     public void testGetTypeArguments() { [EOL]         Map<TypeVariable<?>, Type> typeVarAssigns; [EOL]         TypeVariable<?> treeSetTypeVar; [EOL]         Type typeArg; [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Integer.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from Integer: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]         Assert.assertEquals("Type argument of Comparable from Integer: " + typeArg, Integer.class, [EOL]                 typeVarAssigns.get(treeSetTypeVar)); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(int.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from int: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]       
@Test [EOL]     public void testGetTypeArguments() { [EOL]         Map<TypeVariable<?>, Type> typeVarAssigns; [EOL]         TypeVariable<?> treeSetTypeVar; [EOL]         Type typeArg; [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Integer.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from Integer: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]         Assert.assertEquals("Type argument of Comparable from Integer: " + typeArg, Integer.class, [EOL]                 typeVarAssigns.get(treeSetTypeVar)); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(int.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from int: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]       
@Test [EOL]     public void testGetTypeArguments() { [EOL]         Map<TypeVariable<?>, Type> typeVarAssigns; [EOL]         TypeVariable<?> treeSetTypeVar; [EOL]         Type typeArg; [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Integer.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from Integer: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]         Assert.assertEquals("Type argument of Comparable from Integer: " + typeArg, Integer.class, [EOL]                 typeVarAssigns.get(treeSetTypeVar)); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(int.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from int: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]       
@Test [EOL]     public void testGetTypeArguments() { [EOL]         Map<TypeVariable<?>, Type> typeVarAssigns; [EOL]         TypeVariable<?> treeSetTypeVar; [EOL]         Type typeArg; [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Integer.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from Integer: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]         Assert.assertEquals("Type argument of Comparable from Integer: " + typeArg, Integer.class, [EOL]                 typeVarAssigns.get(treeSetTypeVar)); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(int.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from int: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]       
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [E
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [E
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [E
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [E
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [E
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [E
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [E
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [E
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [E
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [E
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [E
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [E
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [E
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [E
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [E
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [E
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [E
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [E
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [E
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [E
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [E
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [E
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [E
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [E
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [E
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [E
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [E
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [E
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [E
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [E
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [E
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [E
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [E
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [E
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [E
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [E
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [E
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [E
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [E
@Test [EOL]     public void testGetTypeArguments() { [EOL]         Map<TypeVariable<?>, Type> typeVarAssigns; [EOL]         TypeVariable<?> treeSetTypeVar; [EOL]         Type typeArg; [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Integer.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from Integer: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]         Assert.assertEquals("Type argument of Comparable from Integer: " + typeArg, Integer.class, [EOL]                 typeVarAssigns.get(treeSetTypeVar)); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(int.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from int: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]       
@Test [EOL]     public void testGetTypeArguments() { [EOL]         Map<TypeVariable<?>, Type> typeVarAssigns; [EOL]         TypeVariable<?> treeSetTypeVar; [EOL]         Type typeArg; [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Integer.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from Integer: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]         Assert.assertEquals("Type argument of Comparable from Integer: " + typeArg, Integer.class, [EOL]                 typeVarAssigns.get(treeSetTypeVar)); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(int.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from int: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]       
@Test [EOL]     public void testGetTypeArguments() { [EOL]         Map<TypeVariable<?>, Type> typeVarAssigns; [EOL]         TypeVariable<?> treeSetTypeVar; [EOL]         Type typeArg; [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Integer.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from Integer: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]         Assert.assertEquals("Type argument of Comparable from Integer: " + typeArg, Integer.class, [EOL]                 typeVarAssigns.get(treeSetTypeVar)); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(int.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from int: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]       
@Test [EOL]     public void testGetTypeArguments() { [EOL]         Map<TypeVariable<?>, Type> typeVarAssigns; [EOL]         TypeVariable<?> treeSetTypeVar; [EOL]         Type typeArg; [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Integer.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from Integer: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]         Assert.assertEquals("Type argument of Comparable from Integer: " + typeArg, Integer.class, [EOL]                 typeVarAssigns.get(treeSetTypeVar)); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(int.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from int: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]       
@Test [EOL]     public void testGetTypeArguments() { [EOL]         Map<TypeVariable<?>, Type> typeVarAssigns; [EOL]         TypeVariable<?> treeSetTypeVar; [EOL]         Type typeArg; [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Integer.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from Integer: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]         Assert.assertEquals("Type argument of Comparable from Integer: " + typeArg, Integer.class, [EOL]                 typeVarAssigns.get(treeSetTypeVar)); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(int.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from int: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]       
@Test [EOL]     public void testGetTypeArguments() { [EOL]         Map<TypeVariable<?>, Type> typeVarAssigns; [EOL]         TypeVariable<?> treeSetTypeVar; [EOL]         Type typeArg; [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Integer.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from Integer: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]         Assert.assertEquals("Type argument of Comparable from Integer: " + typeArg, Integer.class, [EOL]                 typeVarAssigns.get(treeSetTypeVar)); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(int.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from int: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]       
@Test [EOL]     public void testGetTypeArguments() { [EOL]         Map<TypeVariable<?>, Type> typeVarAssigns; [EOL]         TypeVariable<?> treeSetTypeVar; [EOL]         Type typeArg; [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Integer.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from Integer: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]         Assert.assertEquals("Type argument of Comparable from Integer: " + typeArg, Integer.class, [EOL]                 typeVarAssigns.get(treeSetTypeVar)); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(int.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from int: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]       
@Test [EOL]     public void testGetTypeArguments() { [EOL]         Map<TypeVariable<?>, Type> typeVarAssigns; [EOL]         TypeVariable<?> treeSetTypeVar; [EOL]         Type typeArg; [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Integer.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from Integer: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]         Assert.assertEquals("Type argument of Comparable from Integer: " + typeArg, Integer.class, [EOL]                 typeVarAssigns.get(treeSetTypeVar)); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(int.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from int: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]       
@Test [EOL]     public void testGetTypeArguments() { [EOL]         Map<TypeVariable<?>, Type> typeVarAssigns; [EOL]         TypeVariable<?> treeSetTypeVar; [EOL]         Type typeArg; [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Integer.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from Integer: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]         Assert.assertEquals("Type argument of Comparable from Integer: " + typeArg, Integer.class, [EOL]                 typeVarAssigns.get(treeSetTypeVar)); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(int.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from int: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]       
@Test [EOL]     public void testDetermineTypeVariableAssignments() throws SecurityException, [EOL]             NoSuchFieldException, NoSuchMethodException { [EOL]         final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable") [EOL]                 .getGenericType(); [EOL]         final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, [EOL]                 iterableType); [EOL]         final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns [EOL]                 .get(treeSetTypeVar)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testDetermineTypeVariableAssignments() throws SecurityException, [EOL]             NoSuchFieldException, NoSuchMethodException { [EOL]         final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable") [EOL]                 .getGenericType(); [EOL]         final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, [EOL]                 iterableType); [EOL]         final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns [EOL]                 .get(treeSetTypeVar)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testDetermineTypeVariableAssignments() throws SecurityException, [EOL]             NoSuchFieldException, NoSuchMethodException { [EOL]         final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable") [EOL]                 .getGenericType(); [EOL]         final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, [EOL]                 iterableType); [EOL]         final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns [EOL]                 .get(treeSetTypeVar)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testDetermineTypeVariableAssignments() throws SecurityException, [EOL]             NoSuchFieldException, NoSuchMethodException { [EOL]         final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable") [EOL]                 .getGenericType(); [EOL]         final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, [EOL]                 iterableType); [EOL]         final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns [EOL]                 .get(treeSetTypeVar)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testDetermineTypeVariableAssignments() throws SecurityException, [EOL]             NoSuchFieldException, NoSuchMethodException { [EOL]         final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable") [EOL]                 .getGenericType(); [EOL]         final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, [EOL]                 iterableType); [EOL]         final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns [EOL]                 .get(treeSetTypeVar)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testDetermineTypeVariableAssignments() throws SecurityException, [EOL]             NoSuchFieldException, NoSuchMethodException { [EOL]         final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable") [EOL]                 .getGenericType(); [EOL]         final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, [EOL]                 iterableType); [EOL]         final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns [EOL]                 .get(treeSetTypeVar)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testDetermineTypeVariableAssignments() throws SecurityException, [EOL]             NoSuchFieldException, NoSuchMethodException { [EOL]         final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable") [EOL]                 .getGenericType(); [EOL]         final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, [EOL]                 iterableType); [EOL]         final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns [EOL]                 .get(treeSetTypeVar)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetTypeArguments() { [EOL]         Map<TypeVariable<?>, Type> typeVarAssigns; [EOL]         TypeVariable<?> treeSetTypeVar; [EOL]         Type typeArg; [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Integer.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from Integer: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]         Assert.assertEquals("Type argument of Comparable from Integer: " + typeArg, Integer.class, [EOL]                 typeVarAssigns.get(treeSetTypeVar)); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(int.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from int: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]       
@Test [EOL]     public void testGetTypeArguments() { [EOL]         Map<TypeVariable<?>, Type> typeVarAssigns; [EOL]         TypeVariable<?> treeSetTypeVar; [EOL]         Type typeArg; [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Integer.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from Integer: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]         Assert.assertEquals("Type argument of Comparable from Integer: " + typeArg, Integer.class, [EOL]                 typeVarAssigns.get(treeSetTypeVar)); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(int.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from int: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]       
@Test [EOL]     public void testGetTypeArguments() { [EOL]         Map<TypeVariable<?>, Type> typeVarAssigns; [EOL]         TypeVariable<?> treeSetTypeVar; [EOL]         Type typeArg; [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Integer.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from Integer: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]         Assert.assertEquals("Type argument of Comparable from Integer: " + typeArg, Integer.class, [EOL]                 typeVarAssigns.get(treeSetTypeVar)); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(int.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from int: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]       
@Test [EOL]     public void testGetTypeArguments() { [EOL]         Map<TypeVariable<?>, Type> typeVarAssigns; [EOL]         TypeVariable<?> treeSetTypeVar; [EOL]         Type typeArg; [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Integer.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from Integer: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]         Assert.assertEquals("Type argument of Comparable from Integer: " + typeArg, Integer.class, [EOL]                 typeVarAssigns.get(treeSetTypeVar)); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(int.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from int: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]       
@Test [EOL]     public void testGetTypeArguments() { [EOL]         Map<TypeVariable<?>, Type> typeVarAssigns; [EOL]         TypeVariable<?> treeSetTypeVar; [EOL]         Type typeArg; [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Integer.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from Integer: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]         Assert.assertEquals("Type argument of Comparable from Integer: " + typeArg, Integer.class, [EOL]                 typeVarAssigns.get(treeSetTypeVar)); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(int.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from int: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]       
@Test [EOL]     public void testGetTypeArguments() { [EOL]         Map<TypeVariable<?>, Type> typeVarAssigns; [EOL]         TypeVariable<?> treeSetTypeVar; [EOL]         Type typeArg; [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Integer.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from Integer: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]         Assert.assertEquals("Type argument of Comparable from Integer: " + typeArg, Integer.class, [EOL]                 typeVarAssigns.get(treeSetTypeVar)); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(int.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from int: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]       
@Test [EOL]     public void testGetTypeArguments() { [EOL]         Map<TypeVariable<?>, Type> typeVarAssigns; [EOL]         TypeVariable<?> treeSetTypeVar; [EOL]         Type typeArg; [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Integer.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from Integer: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]         Assert.assertEquals("Type argument of Comparable from Integer: " + typeArg, Integer.class, [EOL]                 typeVarAssigns.get(treeSetTypeVar)); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(int.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from int: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]       
@Test [EOL]     public void testGetTypeArguments() { [EOL]         Map<TypeVariable<?>, Type> typeVarAssigns; [EOL]         TypeVariable<?> treeSetTypeVar; [EOL]         Type typeArg; [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Integer.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from Integer: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]         Assert.assertEquals("Type argument of Comparable from Integer: " + typeArg, Integer.class, [EOL]                 typeVarAssigns.get(treeSetTypeVar)); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(int.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from int: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]       
@Test [EOL]     public void testGetTypeArguments() { [EOL]         Map<TypeVariable<?>, Type> typeVarAssigns; [EOL]         TypeVariable<?> treeSetTypeVar; [EOL]         Type typeArg; [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Integer.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from Integer: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]         Assert.assertEquals("Type argument of Comparable from Integer: " + typeArg, Integer.class, [EOL]                 typeVarAssigns.get(treeSetTypeVar)); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(int.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from int: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]       
@Test [EOL]     public void testGetTypeArguments() { [EOL]         Map<TypeVariable<?>, Type> typeVarAssigns; [EOL]         TypeVariable<?> treeSetTypeVar; [EOL]         Type typeArg; [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Integer.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from Integer: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]         Assert.assertEquals("Type argument of Comparable from Integer: " + typeArg, Integer.class, [EOL]                 typeVarAssigns.get(treeSetTypeVar)); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(int.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from int: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]       
@Test [EOL]     public void testGetTypeArguments() { [EOL]         Map<TypeVariable<?>, Type> typeVarAssigns; [EOL]         TypeVariable<?> treeSetTypeVar; [EOL]         Type typeArg; [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Integer.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from Integer: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]         Assert.assertEquals("Type argument of Comparable from Integer: " + typeArg, Integer.class, [EOL]                 typeVarAssigns.get(treeSetTypeVar)); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(int.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from int: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]       
@Test [EOL]     public void testGetTypeArguments() { [EOL]         Map<TypeVariable<?>, Type> typeVarAssigns; [EOL]         TypeVariable<?> treeSetTypeVar; [EOL]         Type typeArg; [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Integer.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from Integer: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]         Assert.assertEquals("Type argument of Comparable from Integer: " + typeArg, Integer.class, [EOL]                 typeVarAssigns.get(treeSetTypeVar)); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(int.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from int: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]       
@Test [EOL]     public void testGetTypeArguments() { [EOL]         Map<TypeVariable<?>, Type> typeVarAssigns; [EOL]         TypeVariable<?> treeSetTypeVar; [EOL]         Type typeArg; [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Integer.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from Integer: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]         Assert.assertEquals("Type argument of Comparable from Integer: " + typeArg, Integer.class, [EOL]                 typeVarAssigns.get(treeSetTypeVar)); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(int.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from int: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]       
@Test [EOL]     public void testGetTypeArguments() { [EOL]         Map<TypeVariable<?>, Type> typeVarAssigns; [EOL]         TypeVariable<?> treeSetTypeVar; [EOL]         Type typeArg; [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Integer.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from Integer: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]         Assert.assertEquals("Type argument of Comparable from Integer: " + typeArg, Integer.class, [EOL]                 typeVarAssigns.get(treeSetTypeVar)); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(int.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from int: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]       
@Test [EOL]     public void testGetTypeArguments() { [EOL]         Map<TypeVariable<?>, Type> typeVarAssigns; [EOL]         TypeVariable<?> treeSetTypeVar; [EOL]         Type typeArg; [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Integer.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from Integer: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]         Assert.assertEquals("Type argument of Comparable from Integer: " + typeArg, Integer.class, [EOL]                 typeVarAssigns.get(treeSetTypeVar)); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(int.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from int: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]       
@Test [EOL]     public void testGetTypeArguments() { [EOL]         Map<TypeVariable<?>, Type> typeVarAssigns; [EOL]         TypeVariable<?> treeSetTypeVar; [EOL]         Type typeArg; [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Integer.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from Integer: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]         Assert.assertEquals("Type argument of Comparable from Integer: " + typeArg, Integer.class, [EOL]                 typeVarAssigns.get(treeSetTypeVar)); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(int.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from int: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]       
@Test [EOL]     public void testGetTypeArguments() { [EOL]         Map<TypeVariable<?>, Type> typeVarAssigns; [EOL]         TypeVariable<?> treeSetTypeVar; [EOL]         Type typeArg; [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Integer.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from Integer: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]         Assert.assertEquals("Type argument of Comparable from Integer: " + typeArg, Integer.class, [EOL]                 typeVarAssigns.get(treeSetTypeVar)); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(int.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from int: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]       
@Test [EOL]     public void testGetTypeArguments() { [EOL]         Map<TypeVariable<?>, Type> typeVarAssigns; [EOL]         TypeVariable<?> treeSetTypeVar; [EOL]         Type typeArg; [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Integer.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from Integer: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]         Assert.assertEquals("Type argument of Comparable from Integer: " + typeArg, Integer.class, [EOL]                 typeVarAssigns.get(treeSetTypeVar)); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(int.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from int: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]       
@Test [EOL]     public void testGetTypeArguments() { [EOL]         Map<TypeVariable<?>, Type> typeVarAssigns; [EOL]         TypeVariable<?> treeSetTypeVar; [EOL]         Type typeArg; [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Integer.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from Integer: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]         Assert.assertEquals("Type argument of Comparable from Integer: " + typeArg, Integer.class, [EOL]                 typeVarAssigns.get(treeSetTypeVar)); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(int.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from int: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]       
@Test [EOL]     public void testGetTypeArguments() { [EOL]         Map<TypeVariable<?>, Type> typeVarAssigns; [EOL]         TypeVariable<?> treeSetTypeVar; [EOL]         Type typeArg; [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Integer.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from Integer: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]         Assert.assertEquals("Type argument of Comparable from Integer: " + typeArg, Integer.class, [EOL]                 typeVarAssigns.get(treeSetTypeVar)); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(int.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from int: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]       
@Test [EOL]     public void testGetTypeArguments() { [EOL]         Map<TypeVariable<?>, Type> typeVarAssigns; [EOL]         TypeVariable<?> treeSetTypeVar; [EOL]         Type typeArg; [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Integer.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from Integer: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]         Assert.assertEquals("Type argument of Comparable from Integer: " + typeArg, Integer.class, [EOL]                 typeVarAssigns.get(treeSetTypeVar)); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(int.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from int: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]       
@Test [EOL]     public void testGetTypeArguments() { [EOL]         Map<TypeVariable<?>, Type> typeVarAssigns; [EOL]         TypeVariable<?> treeSetTypeVar; [EOL]         Type typeArg; [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Integer.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from Integer: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]         Assert.assertEquals("Type argument of Comparable from Integer: " + typeArg, Integer.class, [EOL]                 typeVarAssigns.get(treeSetTypeVar)); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(int.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from int: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]       
@Test [EOL]     public void testGetTypeArguments() { [EOL]         Map<TypeVariable<?>, Type> typeVarAssigns; [EOL]         TypeVariable<?> treeSetTypeVar; [EOL]         Type typeArg; [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Integer.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from Integer: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]         Assert.assertEquals("Type argument of Comparable from Integer: " + typeArg, Integer.class, [EOL]                 typeVarAssigns.get(treeSetTypeVar)); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(int.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from int: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]       
@Test [EOL]     public void testGetRawType() throws SecurityException, NoSuchFieldException { [EOL]         final Type stringParentFieldType = GenericTypeHolder.class.getDeclaredField("stringParent") [EOL]                 .getGenericType(); [EOL]         final Type integerParentFieldType = GenericTypeHolder.class.getDeclaredField("integerParent") [EOL]                 .getGenericType(); [EOL]         final Type foosFieldType = GenericTypeHolder.class.getDeclaredField("foos").getGenericType(); [EOL]         final Type genericParentT = GenericParent.class.getTypeParameters()[0]; [EOL]         Assert.assertEquals(GenericParent.class, TypeUtils.getRawType(stringParentFieldType, null)); [EOL]         Assert [EOL]                 .assertEquals(GenericParent.class, TypeUtils.getRawType(integerParentFieldType, [EOL]                         null)); [EOL]         Assert.assertEquals(List.class, TypeUtils.getRawType(foosFieldType, null)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 StringParameterizedChild.class)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 stringParentFieldType));
@Test [EOL]     public void testGetRawType() throws SecurityException, NoSuchFieldException { [EOL]         final Type stringParentFieldType = GenericTypeHolder.class.getDeclaredField("stringParent") [EOL]                 .getGenericType(); [EOL]         final Type integerParentFieldType = GenericTypeHolder.class.getDeclaredField("integerParent") [EOL]                 .getGenericType(); [EOL]         final Type foosFieldType = GenericTypeHolder.class.getDeclaredField("foos").getGenericType(); [EOL]         final Type genericParentT = GenericParent.class.getTypeParameters()[0]; [EOL]         Assert.assertEquals(GenericParent.class, TypeUtils.getRawType(stringParentFieldType, null)); [EOL]         Assert [EOL]                 .assertEquals(GenericParent.class, TypeUtils.getRawType(integerParentFieldType, [EOL]                         null)); [EOL]         Assert.assertEquals(List.class, TypeUtils.getRawType(foosFieldType, null)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 StringParameterizedChild.class)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 stringParentFieldType));
@Test [EOL]     public void testGetRawType() throws SecurityException, NoSuchFieldException { [EOL]         final Type stringParentFieldType = GenericTypeHolder.class.getDeclaredField("stringParent") [EOL]                 .getGenericType(); [EOL]         final Type integerParentFieldType = GenericTypeHolder.class.getDeclaredField("integerParent") [EOL]                 .getGenericType(); [EOL]         final Type foosFieldType = GenericTypeHolder.class.getDeclaredField("foos").getGenericType(); [EOL]         final Type genericParentT = GenericParent.class.getTypeParameters()[0]; [EOL]         Assert.assertEquals(GenericParent.class, TypeUtils.getRawType(stringParentFieldType, null)); [EOL]         Assert [EOL]                 .assertEquals(GenericParent.class, TypeUtils.getRawType(integerParentFieldType, [EOL]                         null)); [EOL]         Assert.assertEquals(List.class, TypeUtils.getRawType(foosFieldType, null)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 StringParameterizedChild.class)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 stringParentFieldType));
@Test [EOL]     public void testGetRawType() throws SecurityException, NoSuchFieldException { [EOL]         final Type stringParentFieldType = GenericTypeHolder.class.getDeclaredField("stringParent") [EOL]                 .getGenericType(); [EOL]         final Type integerParentFieldType = GenericTypeHolder.class.getDeclaredField("integerParent") [EOL]                 .getGenericType(); [EOL]         final Type foosFieldType = GenericTypeHolder.class.getDeclaredField("foos").getGenericType(); [EOL]         final Type genericParentT = GenericParent.class.getTypeParameters()[0]; [EOL]         Assert.assertEquals(GenericParent.class, TypeUtils.getRawType(stringParentFieldType, null)); [EOL]         Assert [EOL]                 .assertEquals(GenericParent.class, TypeUtils.getRawType(integerParentFieldType, [EOL]                         null)); [EOL]         Assert.assertEquals(List.class, TypeUtils.getRawType(foosFieldType, null)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 StringParameterizedChild.class)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 stringParentFieldType));
@Test [EOL]     public void testGetRawType() throws SecurityException, NoSuchFieldException { [EOL]         final Type stringParentFieldType = GenericTypeHolder.class.getDeclaredField("stringParent") [EOL]                 .getGenericType(); [EOL]         final Type integerParentFieldType = GenericTypeHolder.class.getDeclaredField("integerParent") [EOL]                 .getGenericType(); [EOL]         final Type foosFieldType = GenericTypeHolder.class.getDeclaredField("foos").getGenericType(); [EOL]         final Type genericParentT = GenericParent.class.getTypeParameters()[0]; [EOL]         Assert.assertEquals(GenericParent.class, TypeUtils.getRawType(stringParentFieldType, null)); [EOL]         Assert [EOL]                 .assertEquals(GenericParent.class, TypeUtils.getRawType(integerParentFieldType, [EOL]                         null)); [EOL]         Assert.assertEquals(List.class, TypeUtils.getRawType(foosFieldType, null)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 StringParameterizedChild.class)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 stringParentFieldType));
@Test [EOL]     public void testGetRawType() throws SecurityException, NoSuchFieldException { [EOL]         final Type stringParentFieldType = GenericTypeHolder.class.getDeclaredField("stringParent") [EOL]                 .getGenericType(); [EOL]         final Type integerParentFieldType = GenericTypeHolder.class.getDeclaredField("integerParent") [EOL]                 .getGenericType(); [EOL]         final Type foosFieldType = GenericTypeHolder.class.getDeclaredField("foos").getGenericType(); [EOL]         final Type genericParentT = GenericParent.class.getTypeParameters()[0]; [EOL]         Assert.assertEquals(GenericParent.class, TypeUtils.getRawType(stringParentFieldType, null)); [EOL]         Assert [EOL]                 .assertEquals(GenericParent.class, TypeUtils.getRawType(integerParentFieldType, [EOL]                         null)); [EOL]         Assert.assertEquals(List.class, TypeUtils.getRawType(foosFieldType, null)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 StringParameterizedChild.class)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 stringParentFieldType));
@Test [EOL]     public void testGetRawType() throws SecurityException, NoSuchFieldException { [EOL]         final Type stringParentFieldType = GenericTypeHolder.class.getDeclaredField("stringParent") [EOL]                 .getGenericType(); [EOL]         final Type integerParentFieldType = GenericTypeHolder.class.getDeclaredField("integerParent") [EOL]                 .getGenericType(); [EOL]         final Type foosFieldType = GenericTypeHolder.class.getDeclaredField("foos").getGenericType(); [EOL]         final Type genericParentT = GenericParent.class.getTypeParameters()[0]; [EOL]         Assert.assertEquals(GenericParent.class, TypeUtils.getRawType(stringParentFieldType, null)); [EOL]         Assert [EOL]                 .assertEquals(GenericParent.class, TypeUtils.getRawType(integerParentFieldType, [EOL]                         null)); [EOL]         Assert.assertEquals(List.class, TypeUtils.getRawType(foosFieldType, null)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 StringParameterizedChild.class)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 stringParentFieldType));
@Test [EOL]     public void testGetRawType() throws SecurityException, NoSuchFieldException { [EOL]         final Type stringParentFieldType = GenericTypeHolder.class.getDeclaredField("stringParent") [EOL]                 .getGenericType(); [EOL]         final Type integerParentFieldType = GenericTypeHolder.class.getDeclaredField("integerParent") [EOL]                 .getGenericType(); [EOL]         final Type foosFieldType = GenericTypeHolder.class.getDeclaredField("foos").getGenericType(); [EOL]         final Type genericParentT = GenericParent.class.getTypeParameters()[0]; [EOL]         Assert.assertEquals(GenericParent.class, TypeUtils.getRawType(stringParentFieldType, null)); [EOL]         Assert [EOL]                 .assertEquals(GenericParent.class, TypeUtils.getRawType(integerParentFieldType, [EOL]                         null)); [EOL]         Assert.assertEquals(List.class, TypeUtils.getRawType(foosFieldType, null)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 StringParameterizedChild.class)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 stringParentFieldType));
@Test [EOL]     public void testGetRawType() throws SecurityException, NoSuchFieldException { [EOL]         final Type stringParentFieldType = GenericTypeHolder.class.getDeclaredField("stringParent") [EOL]                 .getGenericType(); [EOL]         final Type integerParentFieldType = GenericTypeHolder.class.getDeclaredField("integerParent") [EOL]                 .getGenericType(); [EOL]         final Type foosFieldType = GenericTypeHolder.class.getDeclaredField("foos").getGenericType(); [EOL]         final Type genericParentT = GenericParent.class.getTypeParameters()[0]; [EOL]         Assert.assertEquals(GenericParent.class, TypeUtils.getRawType(stringParentFieldType, null)); [EOL]         Assert [EOL]                 .assertEquals(GenericParent.class, TypeUtils.getRawType(integerParentFieldType, [EOL]                         null)); [EOL]         Assert.assertEquals(List.class, TypeUtils.getRawType(foosFieldType, null)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 StringParameterizedChild.class)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 stringParentFieldType));
@Test [EOL]     public void testGetRawType() throws SecurityException, NoSuchFieldException { [EOL]         final Type stringParentFieldType = GenericTypeHolder.class.getDeclaredField("stringParent") [EOL]                 .getGenericType(); [EOL]         final Type integerParentFieldType = GenericTypeHolder.class.getDeclaredField("integerParent") [EOL]                 .getGenericType(); [EOL]         final Type foosFieldType = GenericTypeHolder.class.getDeclaredField("foos").getGenericType(); [EOL]         final Type genericParentT = GenericParent.class.getTypeParameters()[0]; [EOL]         Assert.assertEquals(GenericParent.class, TypeUtils.getRawType(stringParentFieldType, null)); [EOL]         Assert [EOL]                 .assertEquals(GenericParent.class, TypeUtils.getRawType(integerParentFieldType, [EOL]                         null)); [EOL]         Assert.assertEquals(List.class, TypeUtils.getRawType(foosFieldType, null)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 StringParameterizedChild.class)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 stringParentFieldType));
@Test [EOL]     public void testGetRawType() throws SecurityException, NoSuchFieldException { [EOL]         final Type stringParentFieldType = GenericTypeHolder.class.getDeclaredField("stringParent") [EOL]                 .getGenericType(); [EOL]         final Type integerParentFieldType = GenericTypeHolder.class.getDeclaredField("integerParent") [EOL]                 .getGenericType(); [EOL]         final Type foosFieldType = GenericTypeHolder.class.getDeclaredField("foos").getGenericType(); [EOL]         final Type genericParentT = GenericParent.class.getTypeParameters()[0]; [EOL]         Assert.assertEquals(GenericParent.class, TypeUtils.getRawType(stringParentFieldType, null)); [EOL]         Assert [EOL]                 .assertEquals(GenericParent.class, TypeUtils.getRawType(integerParentFieldType, [EOL]                         null)); [EOL]         Assert.assertEquals(List.class, TypeUtils.getRawType(foosFieldType, null)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 StringParameterizedChild.class)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 stringParentFieldType));
@Test [EOL]     public void testGetArrayComponentType() throws Exception { [EOL]         final Method method = getClass().getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [EOL]  [EOL]         final Type[] types = method.getGenericParameterTypes(); [EOL]  [EOL]         Assert.assertNull(TypeUtils.getArrayComponentType(types[0])); [EOL]         Assert.assertNull(TypeUtils.getArrayComponentType(types[1])); [EOL]         Assert.assertNull(TypeUtils.getArrayComponentType(types[2])); [EOL]         Assert.assertNull(TypeUtils.getArrayComponentType(types[3])); [EOL]         Assert.assertNull(TypeUtils.getArrayComponentType(types[4])); [EOL]         Assert.assertNull(TypeUtils.getArrayComponentType(types[5])); [EOL]         Assert.assertNull(TypeUtils.getArrayComponentType(types[6])); [EOL]         Assert.assertEquals(types[0], TypeUtils.getArrayComponentType(types[7])); [EOL]         Assert.assertEquals(types[1], TypeUtils.getArrayComponentType(types[8])); [EOL]         Assert.assert
@Test [EOL]     public void testOutOfBounds() { [EOL]         final NumericEntityUnescaper neu = new NumericEntityUnescaper(); [EOL]  [EOL]         assertEquals("Failed to ignore when last character is &", "Test &", neu.translate("Test &")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#", neu.translate("Test &#")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#x", neu.translate("Test &#x")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#X", neu.translate("Test &#X")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetSet() { [EOL]         assertFalse(new MutableInt(0).setValue()); [EOL]         assertEquals(0, new MutableInt(1).setValue()); [EOL]         assertEquals(1, new MutableInt(2).setValue()); [EOL]         assertEquals(1, new MutableIntValue()); [EOL]         assertEquals(1, new MutableIntValue()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetSet() { [EOL]         final MutableInt mutNum = new MutableInt(0); [EOL]         assertEquals(0, new MutableInt(0), new MutableInt(1)); [EOL]         assertEquals(0, new MutableInt(2).setValue()); [EOL]         assertEquals(1, mutNum.getLeft()); [EOL]         assertEquals(1, mutNum.getLeft().intValue()); [EOL]         assertEquals(0, mutNum.intValue()); [EOL]         assertEquals(1, mutNum.intValue()); [EOL]         assertEquals(2, mutNum.longValue()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testOutOfBounds() { [EOL]         final NumericEntityUnescaper neu = new NumericEntityUnescaper(); [EOL]  [EOL]         assertEquals("Failed to ignore when last character is &", "Test &", neu.translate("Test &")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#", neu.translate("Test &#")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#x", neu.translate("Test &#x")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#X", neu.translate("Test &#X")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testOutOfBounds() { [EOL]         final NumericEntityUnescaper neu = new NumericEntityUnescaper(); [EOL]  [EOL]         assertEquals("Failed to ignore when last character is &", "Test &", neu.translate("Test &")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#", neu.translate("Test &#")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#x", neu.translate("Test &#x")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#X", neu.translate("Test &#X")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testOutOfBounds() { [EOL]         final NumericEntityUnescaper neu = new NumericEntityUnescaper(); [EOL]  [EOL]         assertEquals("Failed to ignore when last character is &", "Test &", neu.translate("Test &")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#", neu.translate("Test &#")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#x", neu.translate("Test &#x")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#X", neu.translate("Test &#X")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testOutOfBounds() { [EOL]         final NumericEntityUnescaper neu = new NumericEntityUnescaper(); [EOL]  [EOL]         assertEquals("Failed to ignore when last character is &", "Test &", neu.translate("Test &")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#", neu.translate("Test &#")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#x", neu.translate("Test &#x")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#X", neu.translate("Test &#X")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testOutOfBounds() { [EOL]         final NumericEntityUnescaper neu = new NumericEntityUnescaper(); [EOL]  [EOL]         assertEquals("Failed to ignore when last character is &", "Test &", neu.translate("Test &")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#", neu.translate("Test &#")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#x", neu.translate("Test &#x")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#X", neu.translate("Test &#X")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testOutOfBounds() { [EOL]         final NumericEntityUnescaper neu = new NumericEntityUnescaper(); [EOL]  [EOL]         assertEquals("Failed to ignore when last character is &", "Test &", neu.translate("Test &")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#", neu.translate("Test &#")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#x", neu.translate("Test &#x")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#X", neu.translate("Test &#X")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testOutOfBounds() { [EOL]         final NumericEntityUnescaper neu = new NumericEntityUnescaper(); [EOL]  [EOL]         assertEquals("Failed to ignore when last character is &", "Test &", neu.translate("Test &")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#", neu.translate("Test &#")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#x", neu.translate("Test &#x")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#X", neu.translate("Test &#X")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testOutOfBounds() { [EOL]         final NumericEntityUnescaper neu = new NumericEntityUnescaper(); [EOL]  [EOL]         assertEquals("Failed to ignore when last character is &", "Test &", neu.translate("Test &")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#", neu.translate("Test &#")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#x", neu.translate("Test &#x")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#X", neu.translate("Test &#X")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testOutOfBounds() { [EOL]         final NumericEntityUnescaper neu = new NumericEntityUnescaper(); [EOL]  [EOL]         assertEquals("Failed to ignore when last character is &", "Test &", neu.translate("Test &")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#", neu.translate("Test &#")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#x", neu.translate("Test &#x")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#X", neu.translate("Test &#X")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testOutOfBounds() { [EOL]         final NumericEntityUnescaper neu = new NumericEntityUnescaper(); [EOL]  [EOL]         assertEquals("Failed to ignore when last character is &", "Test &", neu.translate("Test &")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#", neu.translate("Test &#")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#x", neu.translate("Test &#x")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#X", neu.translate("Test &#X")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testOutOfBounds() { [EOL]         final NumericEntityUnescaper neu = new NumericEntityUnescaper(); [EOL]  [EOL]         assertEquals("Failed to ignore when last character is &", "Test &", neu.translate("Test &")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#", neu.translate("Test &#")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#x", neu.translate("Test &#x")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#X", neu.translate("Test &#X")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testOutOfBounds() { [EOL]         final NumericEntityUnescaper neu = new NumericEntityUnescaper(); [EOL]  [EOL]         assertEquals("Failed to ignore when last character is &", "Test &", neu.translate("Test &")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#", neu.translate("Test &#")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#x", neu.translate("Test &#x")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#X", neu.translate("Test &#X")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testOutOfBounds() { [EOL]         final NumericEntityUnescaper neu = new NumericEntityUnescaper(); [EOL]  [EOL]         assertEquals("Failed to ignore when last character is &", "Test &", neu.translate("Test &")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#", neu.translate("Test &#")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#x", neu.translate("Test &#x")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#X", neu.translate("Test &#X")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testOutOfBounds() { [EOL]         final NumericEntityUnescaper neu = new NumericEntityUnescaper(); [EOL]  [EOL]         assertEquals("Failed to ignore when last character is &", "Test &", neu.translate("Test &")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#", neu.translate("Test &#")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#x", neu.translate("Test &#x")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#X", neu.translate("Test &#X")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testOutOfBounds() { [EOL]         final NumericEntityUnescaper neu = new NumericEntityUnescaper(); [EOL]  [EOL]         assertEquals("Failed to ignore when last character is &", "Test &", neu.translate("Test &")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#", neu.translate("Test &#")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#x", neu.translate("Test &#x")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#X", neu.translate("Test &#X")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testOutOfBounds() { [EOL]         final NumericEntityUnescaper neu = new NumericEntityUnescaper(); [EOL]  [EOL]         assertEquals("Failed to ignore when last character is &", "Test &", neu.translate("Test &")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#", neu.translate("Test &#")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#x", neu.translate("Test &#x")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#X", neu.translate("Test &#X")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testOutOfBounds() { [EOL]         final NumericEntityUnescaper neu = new NumericEntityUnescaper(); [EOL]  [EOL]         assertEquals("Failed to ignore when last character is &", "Test &", neu.translate("Test &")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#", neu.translate("Test &#")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#x", neu.translate("Test &#x")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#X", neu.translate("Test &#X")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testOutOfBounds() { [EOL]         final NumericEntityUnescaper neu = new NumericEntityUnescaper(); [EOL]  [EOL]         assertEquals("Failed to ignore when last character is &", "Test &", neu.translate("Test &")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#", neu.translate("Test &#")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#x", neu.translate("Test &#x")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#X", neu.translate("Test &#X")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testOutOfBounds() { [EOL]         final NumericEntityUnescaper neu = new NumericEntityUnescaper(); [EOL]  [EOL]         assertEquals("Failed to ignore when last character is &", "Test &", neu.translate("Test &")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#", neu.translate("Test &#")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#x", neu.translate("Test &#x")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#X", neu.translate("Test &#X")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testOutOfBounds() { [EOL]         final NumericEntityUnescaper neu = new NumericEntityUnescaper(); [EOL]  [EOL]         assertEquals("Failed to ignore when last character is &", "Test &", neu.translate("Test &")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#", neu.translate("Test &#")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#x", neu.translate("Test &#x")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#X", neu.translate("Test &#X")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testOutOfBounds() { [EOL]         final NumericEntityUnescaper neu = new NumericEntityUnescaper(); [EOL]  [EOL]         assertEquals("Failed to ignore when last character is &", "Test &", neu.translate("Test &")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#", neu.translate("Test &#")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#x", neu.translate("Test &#x")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#X", neu.translate("Test &#X")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testOutOfBounds() { [EOL]         final NumericEntityUnescaper neu = new NumericEntityUnescaper(); [EOL]  [EOL]         assertEquals("Failed to ignore when last character is &", "Test &", neu.translate("Test &")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#", neu.translate("Test &#")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#x", neu.translate("Test &#x")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#X", neu.translate("Test &#X")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testOutOfBounds() { [EOL]         final NumericEntityUnescaper neu = new NumericEntityUnescaper(); [EOL]  [EOL]         assertEquals("Failed to ignore when last character is &", "Test &", neu.translate("Test &")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#", neu.translate("Test &#")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#x", neu.translate("Test &#x")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#X", neu.translate("Test &#X")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testOutOfBounds() { [EOL]         final NumericEntityUnescaper neu = new NumericEntityUnescaper(); [EOL]  [EOL]         assertEquals("Failed to ignore when last character is &", "Test &", neu.translate("Test &")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#", neu.translate("Test &#")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#x", neu.translate("Test &#x")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#X", neu.translate("Test &#X")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testOutOfBounds() { [EOL]         final NumericEntityUnescaper neu = new NumericEntityUnescaper(); [EOL]  [EOL]         assertEquals("Failed to ignore when last character is &", "Test &", neu.translate("Test &")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#", neu.translate("Test &#")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#x", neu.translate("Test &#x")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#X", neu.translate("Test &#X")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testOutOfBounds() { [EOL]         final NumericEntityUnescaper neu = new NumericEntityUnescaper(); [EOL]  [EOL]         assertEquals("Failed to ignore when last character is &", "Test &", neu.translate("Test &")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#", neu.translate("Test &#")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#x", neu.translate("Test &#x")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#X", neu.translate("Test &#X")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testOutOfBounds() { [EOL]         final NumericEntityUnescaper neu = new NumericEntityUnescaper(); [EOL]  [EOL]         assertEquals("Failed to ignore when last character is &", "Test &", neu.translate("Test &")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#", neu.translate("Test &#")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#x", neu.translate("Test &#x")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#X", neu.translate("Test &#X")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testOutOfBounds() { [EOL]         final NumericEntityUnescaper neu = new NumericEntityUnescaper(); [EOL]  [EOL]         assertEquals("Failed to ignore when last character is &", "Test &", neu.translate("Test &")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#", neu.translate("Test &#")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#x", neu.translate("Test &#x")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#X", neu.translate("Test &#X")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testOutOfBounds() { [EOL]         final NumericEntityUnescaper neu = new NumericEntityUnescaper(); [EOL]  [EOL]         assertEquals("Failed to ignore when last character is &", "Test &", neu.translate("Test &")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#", neu.translate("Test &#")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#x", neu.translate("Test &#x")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#X", neu.translate("Test &#X")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGet() throws ConcurrentException { [EOL]         assertEquals("Wrong object", VALUE, init.get()); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests equals() if the expected result is true. [EOL]      */ [EOL]
@Test [EOL]     public void testGet() throws ConcurrentException { [EOL]         assertEquals("Wrong object", VALUE, init.get()); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests equals() if the expected result is true. [EOL]      */ [EOL]
@Test [EOL]     public void testGet() throws ConcurrentException { [EOL]         assertEquals("Wrong object", VALUE, init.get()); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests equals() if the expected result is true. [EOL]      */ [EOL]
@Test [EOL]     public void testGet() throws ConcurrentException { [EOL]         assertEquals("Wrong object", VALUE, init.get()); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests equals() if the expected result is true. [EOL]      */ [EOL]
@Test [EOL]     public void testGet() throws ConcurrentException { [EOL]         assertEquals("Wrong object", VALUE, init.get()); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests equals() if the expected result is true. [EOL]      */ [EOL]
@Test [EOL]     public void testGet() throws ConcurrentException { [EOL]         assertEquals("Wrong object", VALUE, init.get()); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests equals() if the expected result is true. [EOL]      */ [EOL]
@Test [EOL]     public void testUnescapeCsvString() throws Exception { [EOL]         assertEquals("foo.bar",          StringEscapeUtils.unescapeCsv("foo.bar")); [EOL]         assertEquals("foo,bar",      StringEscapeUtils.unescapeCsv("\"foo,bar\"")); [EOL]         assertEquals("foo\nbar",     StringEscapeUtils.unescapeCsv("\"foo\nbar\"")); [EOL]         assertEquals("foo\rbar",     StringEscapeUtils.unescapeCsv("\"foo\rbar\"")); [EOL]         assertEquals("foo\"bar",   StringEscapeUtils.unescapeCsv("\"foo\"\"bar\"")); [EOL]         assertEquals("",   StringEscapeUtils.unescapeCsv("")); [EOL]         assertEquals(null, StringEscapeUtils.unescapeCsv(null)); [EOL]  [EOL]         assertEquals("\"foo.bar\"",          StringEscapeUtils.unescapeCsv("\"foo.bar\"")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testChaining() { [EOL]         final StrBuilder sb = new StrBuilder(); [EOL]         assertSame(sb, sb.setNewLineText(null)); [EOL]         assertSame(sb, sb.setNullText(null)); [EOL]         assertSame(sb, sb.setLength(1)); [EOL]         assertSame(sb, sb.setCharAt(0, 'a')); [EOL]         assertSame(sb, sb.ensureCapacity(0)); [EOL]         assertSame(sb, sb.minimizeCapacity()); [EOL]         assertSame(sb, sb.clear()); [EOL]         assertSame(sb, sb.reverse()); [EOL]         assertSame(sb, sb.trim()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testToCharArray() { [EOL]         final StrBuilder sb = new StrBuilder(); [EOL]         assertEquals(ArrayUtils.EMPTY_CHAR_ARRAY, sb.toCharArray()); [EOL]  [EOL]         char[] a = sb.toCharArray(); [EOL]         assertNotNull("toCharArray() result is null", a); [EOL]         assertEquals("toCharArray() result is too large", 0, a.length); [EOL]  [EOL]         sb.append("junit"); [EOL]         a = sb.toCharArray(); [EOL]         assertEquals("toCharArray() result incorrect length", 5, a.length); [EOL]         assertTrue("toCharArray() result does not match", Arrays.equals("junit".toCharArray(), a)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testToCharArrayIntInt() { [EOL]         final StrBuilder sb = new StrBuilder(); [EOL]         assertEquals(ArrayUtils.EMPTY_CHAR_ARRAY, sb.toCharArray(0, 0)); [EOL]  [EOL]         sb.append("junit"); [EOL]         char[] a = sb.toCharArray(0, 20); // too large test [EOL]         assertEquals("toCharArray(int,int) result incorrect length", 5, a.length); [EOL]         assertTrue("toCharArray(int,int) result does not match", Arrays.equals("junit".toCharArray(), a)); [EOL]  [EOL]         a = sb.toCharArray(0, 4); [EOL]         assertEquals("toCharArray(int,int) result incorrect length", 4, a.length); [EOL]         assertTrue("toCharArray(int,int) result does not match", Arrays.equals("juni".toCharArray(), a)); [EOL]  [EOL]         a = sb.toCharArray(0, 4); [EOL]         assertEquals("toCharArray(int,int) result incorrect length", 4, a.length); [EOL]         assertTrue("toCharArray(int,int) result does not match", Arrays.equals("juni".toCharArray(), a)); [EOL]  [EOL]         a = sb.toCharArray(0, 1); [EOL]         assertNotNull("toCharArray(int,int) result is null", a); [EOL]  [EOL] 
@Test [EOL]     public void testAppendln_StringBuffer() { [EOL]         final int[] count = new int[2]; [EOL]         final StrBuilder sb = new StrBuilder() { [EOL]             @Override [EOL]             public StrBuilder append(final StringBuffer str) { [EOL]                 count[0]++; [EOL]                 return super.append(str); [EOL]             } [EOL]             @Override [EOL]             public StrBuilder appendNewLine() { [EOL]                 count[1]++; [EOL]                 return super.appendNewLine(); [EOL]             } [EOL]         }; [EOL]         sb.appendln(new StringBuffer("foo")); [EOL]         assertEquals("foo" + SEP, sb.toString()); [EOL]         assertEquals(1, count[0]); [EOL]         assertEquals(1, count[1]); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAppendln_StrBuilder_int_int() { [EOL]         final int[] count = new int[2]; [EOL]         final StrBuilder sb = new StrBuilder() { [EOL]             @Override [EOL]             public StrBuilder append(final StrBuilder str, final int startIndex, final int length) { [EOL]                 count[0]++; [EOL]                 return super.append(str, startIndex, length); [EOL]             } [EOL]             @Override [EOL]             public StrBuilder appendNewLine() { [EOL]                 count[1]++; [EOL]                 return super.appendNewLine(); [EOL]             } [EOL]         }; [EOL]         sb.appendln(new StrBuilder("foo"), 0, 3); [EOL]         assertEquals("foo" + SEP, sb.toString()); [EOL]         assertEquals(1, count[0]); [EOL]         assertEquals(1, count[1]); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAppendWithSeparators_Iterator() { [EOL]         final StrBuilder sb = new StrBuilder(); [EOL]         sb.appendWithSeparators((Iterator<?>) null, ","); [EOL]         assertEquals("", sb.toString()); [EOL]  [EOL]         sb.clear(); [EOL]         sb.appendWithSeparators(Collections.EMPTY_LIST.iterator(), ","); [EOL]         assertEquals("", sb.toString()); [EOL]  [EOL]         sb.clear(); [EOL]         sb.appendWithSeparators(Arrays.asList(new Object[]{"foo", "bar", "baz"}).iterator(), ","); [EOL]         assertEquals("foo,bar,baz", sb.toString()); [EOL]  [EOL]         sb.clear(); [EOL]         sb.appendWithSeparators(Arrays.asList(new Object[]{"foo", "bar", "baz"}).iterator(), null); [EOL]         assertEquals("foobarbaz", sb.toString()); [EOL]  [EOL]         sb.clear(); [EOL]         sb.appendWithSeparators(Arrays.asList(new Object[]{"foo", null, "baz"}).iterator(), ","); [EOL]         assertEquals("foo,,baz", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testLang412Right() { [EOL]         final StrBuilder sb = new StrBuilder(); [EOL]         sb.appendFixedWidthPadRight(null, 10, '*'); [EOL]         assertEquals( "Failed to invoke appendFixedWidthPadRight correctly", "**********", sb.toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testInsertWithNullText() { [EOL]         final StrBuilder sb = new StrBuilder(); [EOL]         sb.setNullText("null"); [EOL]         sb.append("barbaz"); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(-1, FOO); [EOL]             fail("insert(-1, Object) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(7, FOO); [EOL]             fail("insert(7, Object) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, (Object) null); [EOL]         assertEquals("nullbarbaz", sb.toString()); [EOL]  [EOL]         sb.insert(0, FOO); [EOL]         assertEquals("foonullbarbaz", sb.toString()); [EOL]  [EOL]
@Test [EOL]     public void testInsertWithNullText() { [EOL]         final StrBuilder sb = new StrBuilder(); [EOL]         sb.setNullText("null"); [EOL]         sb.append("barbaz"); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(-1, FOO); [EOL]             fail("insert(-1, Object) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(7, FOO); [EOL]             fail("insert(7, Object) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, (Object) null); [EOL]         assertEquals("nullbarbaz", sb.toString()); [EOL]  [EOL]         sb.insert(0, FOO); [EOL]         assertEquals("foonullbarbaz", sb.toString()); [EOL]  [EOL]
@Test [EOL]     public void testInsert() { [EOL]  [EOL]         final StrBuilder sb = new StrBuilder(); [EOL]         sb.append("barbaz"); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(-1, FOO); [EOL]             fail("insert(-1, Object) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(7, FOO); [EOL]             fail("insert(7, Object) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, (Object) null); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         sb.insert(0, FOO); [EOL]         assertEquals("foobarbaz", sb.toString()); [EOL]  [EOL]         sb.clear(); [EOL]     
@Test [EOL]     public void testInsert() { [EOL]  [EOL]         final StrBuilder sb = new StrBuilder(); [EOL]         sb.append("barbaz"); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(-1, FOO); [EOL]             fail("insert(-1, Object) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(7, FOO); [EOL]             fail("insert(7, Object) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, (Object) null); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         sb.insert(0, FOO); [EOL]         assertEquals("foobarbaz", sb.toString()); [EOL]  [EOL]         sb.clear(); [EOL]     
@Test [EOL]     public void testInsert() { [EOL]  [EOL]         final StrBuilder sb = new StrBuilder(); [EOL]         sb.append("barbaz"); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(-1, FOO); [EOL]             fail("insert(-1, Object) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(7, FOO); [EOL]             fail("insert(7, Object) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, (Object) null); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         sb.insert(0, FOO); [EOL]         assertEquals("foobarbaz", sb.toString()); [EOL]  [EOL]         sb.clear(); [EOL]     
@Test [EOL]     public void testInsert() { [EOL]  [EOL]         final StrBuilder sb = new StrBuilder(); [EOL]         sb.append("barbaz"); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(-1, FOO); [EOL]             fail("insert(-1, Object) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(7, FOO); [EOL]             fail("insert(7, Object) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, (Object) null); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         sb.insert(0, FOO); [EOL]         assertEquals("foobarbaz", sb.toString()); [EOL]  [EOL]         sb.clear(); [EOL]     
@Test [EOL]     public void testInsert() { [EOL]  [EOL]         final StrBuilder sb = new StrBuilder(); [EOL]         sb.append("barbaz"); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(-1, FOO); [EOL]             fail("insert(-1, Object) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(7, FOO); [EOL]             fail("insert(7, Object) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, (Object) null); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         sb.insert(0, FOO); [EOL]         assertEquals("foobarbaz", sb.toString()); [EOL]  [EOL]         sb.clear(); [EOL]     
@Test [EOL]     public void testInsert() { [EOL]  [EOL]         final StrBuilder sb = new StrBuilder(); [EOL]         sb.append("barbaz"); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(-1, FOO); [EOL]             fail("insert(-1, Object) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(7, FOO); [EOL]             fail("insert(7, Object) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, (Object) null); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         sb.insert(0, FOO); [EOL]         assertEquals("foobarbaz", sb.toString()); [EOL]  [EOL]         sb.clear(); [EOL]     
@Test [EOL]     public void testInsert() { [EOL]  [EOL]         final StrBuilder sb = new StrBuilder(); [EOL]         sb.append("barbaz"); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(-1, FOO); [EOL]             fail("insert(-1, Object) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(7, FOO); [EOL]             fail("insert(7, Object) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, (Object) null); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         sb.insert(0, FOO); [EOL]         assertEquals("foobarbaz", sb.toString()); [EOL]  [EOL]         sb.clear(); [EOL]     
@Test [EOL]     public void testInsert() { [EOL]  [EOL]         final StrBuilder sb = new StrBuilder(); [EOL]         sb.append("barbaz"); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(-1, FOO); [EOL]             fail("insert(-1, Object) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(7, FOO); [EOL]             fail("insert(7, Object) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, (Object) null); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         sb.insert(0, FOO); [EOL]         assertEquals("foobarbaz", sb.toString()); [EOL]  [EOL]         sb.clear(); [EOL]     
@Test [EOL]     public void testDeleteAll_char() { [EOL]         StrBuilder sb = new StrBuilder("abcbccba"); [EOL]         sb.deleteAll('X'); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.deleteAll('a'); [EOL]         assertEquals("bcbccb", sb.toString()); [EOL]         sb.deleteAll('c'); [EOL]         assertEquals("bbb", sb.toString()); [EOL]         sb.deleteAll('b'); [EOL]         assertEquals("", sb.toString()); [EOL]  [EOL]         sb = new StrBuilder(""); [EOL]         sb.deleteAll('b'); [EOL]         assertEquals("", sb.toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testDeleteAll_char() { [EOL]         StrBuilder sb = new StrBuilder("abcbccba"); [EOL]         sb.deleteAll('X'); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.deleteAll('a'); [EOL]         assertEquals("bcbccb", sb.toString()); [EOL]         sb.deleteAll('c'); [EOL]         assertEquals("bbb", sb.toString()); [EOL]         sb.deleteAll('b'); [EOL]         assertEquals("", sb.toString()); [EOL]  [EOL]         sb = new StrBuilder(""); [EOL]         sb.deleteAll('b'); [EOL]         assertEquals("", sb.toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testDeleteAll_char() { [EOL]         StrBuilder sb = new StrBuilder("abcbccba"); [EOL]         sb.deleteAll('X'); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.deleteAll('a'); [EOL]         assertEquals("bcbccb", sb.toString()); [EOL]         sb.deleteAll('c'); [EOL]         assertEquals("bbb", sb.toString()); [EOL]         sb.deleteAll('b'); [EOL]         assertEquals("", sb.toString()); [EOL]  [EOL]         sb = new StrBuilder(""); [EOL]         sb.deleteAll('b'); [EOL]         assertEquals("", sb.toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testDeleteAll_char() { [EOL]         StrBuilder sb = new StrBuilder("abcbccba"); [EOL]         sb.deleteAll('X'); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.deleteAll('a'); [EOL]         assertEquals("bcbccb", sb.toString()); [EOL]         sb.deleteAll('c'); [EOL]         assertEquals("bbb", sb.toString()); [EOL]         sb.deleteAll('b'); [EOL]         assertEquals("", sb.toString()); [EOL]  [EOL]         sb = new StrBuilder(""); [EOL]         sb.deleteAll('b'); [EOL]         assertEquals("", sb.toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testDeleteAll_char() { [EOL]         StrBuilder sb = new StrBuilder("abcbccba"); [EOL]         sb.deleteAll('X'); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.deleteAll('a'); [EOL]         assertEquals("bcbccb", sb.toString()); [EOL]         sb.deleteAll('c'); [EOL]         assertEquals("bbb", sb.toString()); [EOL]         sb.deleteAll('b'); [EOL]         assertEquals("", sb.toString()); [EOL]  [EOL]         sb = new StrBuilder(""); [EOL]         sb.deleteAll('b'); [EOL]         assertEquals("", sb.toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testDeleteAll_char() { [EOL]         StrBuilder sb = new StrBuilder("abcbccba"); [EOL]         sb.deleteAll('X'); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.deleteAll('a'); [EOL]         assertEquals("bcbccb", sb.toString()); [EOL]         sb.deleteAll('c'); [EOL]         assertEquals("bbb", sb.toString()); [EOL]         sb.deleteAll('b'); [EOL]         assertEquals("", sb.toString()); [EOL]  [EOL]         sb = new StrBuilder(""); [EOL]         sb.deleteAll('b'); [EOL]         assertEquals("", sb.toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testDeleteAll_char() { [EOL]         StrBuilder sb = new StrBuilder("abcbccba"); [EOL]         sb.deleteAll('X'); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.deleteAll('a'); [EOL]         assertEquals("bcbccb", sb.toString()); [EOL]         sb.deleteAll('c'); [EOL]         assertEquals("bbb", sb.toString()); [EOL]         sb.deleteAll('b'); [EOL]         assertEquals("", sb.toString()); [EOL]  [EOL]         sb = new StrBuilder(""); [EOL]         sb.deleteAll('b'); [EOL]         assertEquals("", sb.toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReplaceAll_char_char() { [EOL]         final StrBuilder sb = new StrBuilder("abcbccba"); [EOL]         sb.replaceAll('x', 'y'); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll('a', 'd'); [EOL]         assertEquals("dbcbccbd", sb.toString()); [EOL]         sb.replaceAll('b', 'e'); [EOL]         assertEquals("dececced", sb.toString()); [EOL]         sb.replaceAll('c', 'f'); [EOL]         assertEquals("defeffed", sb.toString()); [EOL]         sb.replaceAll('d', 'd'); [EOL]         assertEquals("defeffed", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testReplaceFirst_char_char() { [EOL]         final StrBuilder sb = new StrBuilder("abcbccba"); [EOL]         sb.replaceFirst('x', 'y'); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceFirst('a', 'd'); [EOL]         assertEquals("dbcbccba", sb.toString()); [EOL]         sb.replaceFirst('b', 'e'); [EOL]         assertEquals("decbccba", sb.toString()); [EOL]         sb.replaceFirst('c', 'f'); [EOL]         assertEquals("defbccba", sb.toString()); [EOL]         sb.replaceFirst('d', 'd'); [EOL]         assertEquals("defbccba", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testReplaceFirst_char_char() { [EOL]         final StrBuilder sb = new StrBuilder("abcbccba"); [EOL]         sb.replaceFirst('x', 'y'); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceFirst('a', 'd'); [EOL]         assertEquals("dbcbccba", sb.toString()); [EOL]         sb.replaceFirst('b', 'e'); [EOL]         assertEquals("decbccba", sb.toString()); [EOL]         sb.replaceFirst('c', 'f'); [EOL]         assertEquals("defbccba", sb.toString()); [EOL]         sb.replaceFirst('d', 'd'); [EOL]         assertEquals("defbccba", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testChaining() { [EOL]         final StrBuilder sb = new StrBuilder(); [EOL]         assertSame(sb, sb.setNewLineText(null)); [EOL]         assertSame(sb, sb.setNullText(null)); [EOL]         assertSame(sb, sb.setLength(1)); [EOL]         assertSame(sb, sb.setCharAt(0, 'a')); [EOL]         assertSame(sb, sb.ensureCapacity(0)); [EOL]         assertSame(sb, sb.minimizeCapacity()); [EOL]         assertSame(sb, sb.clear()); [EOL]         assertSame(sb, sb.reverse()); [EOL]         assertSame(sb, sb.trim()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testChaining() { [EOL]         final StrBuilder sb = new StrBuilder(); [EOL]         assertSame(sb, sb.setNewLineText(null)); [EOL]         assertSame(sb, sb.setNullText(null)); [EOL]         assertSame(sb, sb.setLength(1)); [EOL]         assertSame(sb, sb.setCharAt(0, 'a')); [EOL]         assertSame(sb, sb.ensureCapacity(0)); [EOL]         assertSame(sb, sb.minimizeCapacity()); [EOL]         assertSame(sb, sb.clear()); [EOL]         assertSame(sb, sb.reverse()); [EOL]         assertSame(sb, sb.trim()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testStartsWith() { [EOL]         final StrBuilder sb = new StrBuilder(); [EOL]         assertFalse(sb.startsWith("a")); [EOL]         assertFalse(sb.startsWith(null)); [EOL]         assertTrue(sb.startsWith("")); [EOL]         sb.append("abc"); [EOL]         assertTrue(sb.startsWith("a")); [EOL]         assertTrue(sb.startsWith("ab")); [EOL]         assertTrue(sb.startsWith("abc")); [EOL]         assertFalse(sb.startsWith("cba")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEndsWithAny() { [EOL]         assertFalse("StringUtils.endsWithAny(null, null)", StringUtils.endsWithAny(null, (String)null)); [EOL]         assertFalse("StringUtils.endsWithAny(null, new String[] {abc})", StringUtils.endsWithAny(null, new String[] {"abc"})); [EOL]         assertFalse("StringUtils.endsWithAny(abcxyz, null)", StringUtils.endsWithAny("abcxyz", (String)null)); [EOL]         assertTrue("StringUtils.endsWithAny(abcxyz, new String[] {\"\"})", StringUtils.endsWithAny("abcxyz", new String[] {""})); [EOL]         assertTrue("StringUtils.endsWithAny(abcxyz, new String[] {xyz})", StringUtils.endsWithAny("abcxyz", new String[] {"xyz"})); [EOL]         assertTrue("StringUtils.endsWithAny(abcxyz, new String[] {null, xyz, abc})", StringUtils.endsWithAny("abcxyz", new String[] {null, "xyz", "abc"})); [EOL]         assertFalse("StringUtils.endsWithAny(defg, new String[] {null, xyz, abc})", StringUtils.endsWithAny("defg", new String[] {null, "xyz", "abc"})); [EOL]  [EOL]         assertTrue("StringUtils.endsWithAny(abcxyz, StringBuilder(abc), StringBuffer(xyz))", StringUtils.endsWithAny("abcxyz", new StringBuilder("abc"), new StringBuffer("xyz"))); [EOL]         assertTrue("StringUtils.endsWithAny( StrBuilder(abcxyz), StringBuilder(
@Test [EOL]     public void testEndsWithAny() { [EOL]         assertFalse("StringUtils.endsWithAny(null, null)", StringUtils.endsWithAny(null, (String)null)); [EOL]         assertFalse("StringUtils.endsWithAny(null, new String[] {abc})", StringUtils.endsWithAny(null, new String[] {"abc"})); [EOL]         assertFalse("StringUtils.endsWithAny(abcxyz, null)", StringUtils.endsWithAny("abcxyz", (String)null)); [EOL]         assertTrue("StringUtils.endsWithAny(abcxyz, new String[] {\"\"})", StringUtils.endsWithAny("abcxyz", new String[] {""})); [EOL]         assertTrue("StringUtils.endsWithAny(abcxyz, new String[] {xyz})", StringUtils.endsWithAny("abcxyz", new String[] {"xyz"})); [EOL]         assertTrue("StringUtils.endsWithAny(abcxyz, new String[] {null, xyz, abc})", StringUtils.endsWithAny("abcxyz", new String[] {null, "xyz", "abc"})); [EOL]         assertFalse("StringUtils.endsWithAny(defg, new String[] {null, xyz, abc})", StringUtils.endsWithAny("defg", new String[] {null, "xyz", "abc"})); [EOL]  [EOL]         assertTrue("StringUtils.endsWithAny(abcxyz, StringBuilder(abc), StringBuffer(xyz))", StringUtils.endsWithAny("abcxyz", new StringBuilder("abc"), new StringBuffer("xyz"))); [EOL]         assertTrue("StringUtils.endsWithAny( StrBuilder(abcxyz), StringBuilder(
@Test [EOL]     public void testEndsWithAny() { [EOL]         assertFalse("StringUtils.endsWithAny(null, null)", StringUtils.endsWithAny(null, (String)null)); [EOL]         assertFalse("StringUtils.endsWithAny(null, new String[] {abc})", StringUtils.endsWithAny(null, new String[] {"abc"})); [EOL]         assertFalse("StringUtils.endsWithAny(abcxyz, null)", StringUtils.endsWithAny("abcxyz", (String)null)); [EOL]         assertTrue("StringUtils.endsWithAny(abcxyz, new String[] {\"\"})", StringUtils.endsWithAny("abcxyz", new String[] {""})); [EOL]         assertTrue("StringUtils.endsWithAny(abcxyz, new String[] {xyz})", StringUtils.endsWithAny("abcxyz", new String[] {"xyz"})); [EOL]         assertTrue("StringUtils.endsWithAny(abcxyz, new String[] {null, xyz, abc})", StringUtils.endsWithAny("abcxyz", new String[] {null, "xyz", "abc"})); [EOL]         assertFalse("StringUtils.endsWithAny(defg, new String[] {null, xyz, abc})", StringUtils.endsWithAny("defg", new String[] {null, "xyz", "abc"})); [EOL]  [EOL]         assertTrue("StringUtils.endsWithAny(abcxyz, StringBuilder(abc), StringBuffer(xyz))", StringUtils.endsWithAny("abcxyz", new StringBuilder("abc"), new StringBuffer("xyz"))); [EOL]         assertTrue("StringUtils.endsWithAny( StrBuilder(abcxyz), StringBuilder(
@Test [EOL]     public void testEndsWithAny() { [EOL]         assertFalse("StringUtils.endsWithAny(null, null)", StringUtils.endsWithAny(null, (String)null)); [EOL]         assertFalse("StringUtils.endsWithAny(null, new String[] {abc})", StringUtils.endsWithAny(null, new String[] {"abc"})); [EOL]         assertFalse("StringUtils.endsWithAny(abcxyz, null)", StringUtils.endsWithAny("abcxyz", (String)null)); [EOL]         assertTrue("StringUtils.endsWithAny(abcxyz, new String[] {\"\"})", StringUtils.endsWithAny("abcxyz", new String[] {""})); [EOL]         assertTrue("StringUtils.endsWithAny(abcxyz, new String[] {xyz})", StringUtils.endsWithAny("abcxyz", new String[] {"xyz"})); [EOL]         assertTrue("StringUtils.endsWithAny(abcxyz, new String[] {null, xyz, abc})", StringUtils.endsWithAny("abcxyz", new String[] {null, "xyz", "abc"})); [EOL]         assertFalse("StringUtils.endsWithAny(defg, new String[] {null, xyz, abc})", StringUtils.endsWithAny("defg", new String[] {null, "xyz", "abc"})); [EOL]  [EOL]         assertTrue("StringUtils.endsWithAny(abcxyz, StringBuilder(abc), StringBuffer(xyz))", StringUtils.endsWithAny("abcxyz", new StringBuilder("abc"), new StringBuffer("xyz"))); [EOL]         assertTrue("StringUtils.endsWithAny( StrBuilder(abcxyz), StringBuilder(
@Test [EOL]     public void testEndsWithAny() { [EOL]         assertFalse("StringUtils.endsWithAny(null, null)", StringUtils.endsWithAny(null, (String)null)); [EOL]         assertFalse("StringUtils.endsWithAny(null, new String[] {abc})", StringUtils.endsWithAny(null, new String[] {"abc"})); [EOL]         assertFalse("StringUtils.endsWithAny(abcxyz, null)", StringUtils.endsWithAny("abcxyz", (String)null)); [EOL]         assertTrue("StringUtils.endsWithAny(abcxyz, new String[] {\"\"})", StringUtils.endsWithAny("abcxyz", new String[] {""})); [EOL]         assertTrue("StringUtils.endsWithAny(abcxyz, new String[] {xyz})", StringUtils.endsWithAny("abcxyz", new String[] {"xyz"})); [EOL]         assertTrue("StringUtils.endsWithAny(abcxyz, new String[] {null, xyz, abc})", StringUtils.endsWithAny("abcxyz", new String[] {null, "xyz", "abc"})); [EOL]         assertFalse("StringUtils.endsWithAny(defg, new String[] {null, xyz, abc})", StringUtils.endsWithAny("defg", new String[] {null, "xyz", "abc"})); [EOL]  [EOL]         assertTrue("StringUtils.endsWithAny(abcxyz, StringBuilder(abc), StringBuffer(xyz))", StringUtils.endsWithAny("abcxyz", new StringBuilder("abc"), new StringBuffer("xyz"))); [EOL]         assertTrue("StringUtils.endsWithAny( StrBuilder(abcxyz), StringBuilder(
@Test [EOL]     public void testEndsWithAny() { [EOL]         assertFalse("StringUtils.endsWithAny(null, null)", StringUtils.endsWithAny(null, (String)null)); [EOL]         assertFalse("StringUtils.endsWithAny(null, new String[] {abc})", StringUtils.endsWithAny(null, new String[] {"abc"})); [EOL]         assertFalse("StringUtils.endsWithAny(abcxyz, null)", StringUtils.endsWithAny("abcxyz", (String)null)); [EOL]         assertTrue("StringUtils.endsWithAny(abcxyz, new String[] {\"\"})", StringUtils.endsWithAny("abcxyz", new String[] {""})); [EOL]         assertTrue("StringUtils.endsWithAny(abcxyz, new String[] {xyz})", StringUtils.endsWithAny("abcxyz", new String[] {"xyz"})); [EOL]         assertTrue("StringUtils.endsWithAny(abcxyz, new String[] {null, xyz, abc})", StringUtils.endsWithAny("abcxyz", new String[] {null, "xyz", "abc"})); [EOL]         assertFalse("StringUtils.endsWithAny(defg, new String[] {null, xyz, abc})", StringUtils.endsWithAny("defg", new String[] {null, "xyz", "abc"})); [EOL]  [EOL]         assertTrue("StringUtils.endsWithAny(abcxyz, StringBuilder(abc), StringBuffer(xyz))", StringUtils.endsWithAny("abcxyz", new StringBuilder("abc"), new StringBuffer("xyz"))); [EOL]         assertTrue("StringUtils.endsWithAny( StrBuilder(abcxyz), StringBuilder(
@Test [EOL]     public void testEndsWithAny() { [EOL]         assertFalse("StringUtils.endsWithAny(null, null)", StringUtils.endsWithAny(null, (String)null)); [EOL]         assertFalse("StringUtils.endsWithAny(null, new String[] {abc})", StringUtils.endsWithAny(null, new String[] {"abc"})); [EOL]         assertFalse("StringUtils.endsWithAny(abcxyz, null)", StringUtils.endsWithAny("abcxyz", (String)null)); [EOL]         assertTrue("StringUtils.endsWithAny(abcxyz, new String[] {\"\"})", StringUtils.endsWithAny("abcxyz", new String[] {""})); [EOL]         assertTrue("StringUtils.endsWithAny(abcxyz, new String[] {xyz})", StringUtils.endsWithAny("abcxyz", new String[] {"xyz"})); [EOL]         assertTrue("StringUtils.endsWithAny(abcxyz, new String[] {null, xyz, abc})", StringUtils.endsWithAny("abcxyz", new String[] {null, "xyz", "abc"})); [EOL]         assertFalse("StringUtils.endsWithAny(defg, new String[] {null, xyz, abc})", StringUtils.endsWithAny("defg", new String[] {null, "xyz", "abc"})); [EOL]  [EOL]         assertTrue("StringUtils.endsWithAny(abcxyz, StringBuilder(abc), StringBuffer(xyz))", StringUtils.endsWithAny("abcxyz", new StringBuilder("abc"), new StringBuffer("xyz"))); [EOL]         assertTrue("StringUtils.endsWithAny( StrBuilder(abcxyz), StringBuilder(
@Test [EOL]     public void testEndsWithAny() { [EOL]         assertFalse("StringUtils.endsWithAny(null, null)", StringUtils.endsWithAny(null, (String)null)); [EOL]         assertFalse("StringUtils.endsWithAny(null, new String[] {abc})", StringUtils.endsWithAny(null, new String[] {"abc"})); [EOL]         assertFalse("StringUtils.endsWithAny(abcxyz, null)", StringUtils.endsWithAny("abcxyz", (String)null)); [EOL]         assertTrue("StringUtils.endsWithAny(abcxyz, new String[] {\"\"})", StringUtils.endsWithAny("abcxyz", new String[] {""})); [EOL]         assertTrue("StringUtils.endsWithAny(abcxyz, new String[] {xyz})", StringUtils.endsWithAny("abcxyz", new String[] {"xyz"})); [EOL]         assertTrue("StringUtils.endsWithAny(abcxyz, new String[] {null, xyz, abc})", StringUtils.endsWithAny("abcxyz", new String[] {null, "xyz", "abc"})); [EOL]         assertFalse("StringUtils.endsWithAny(defg, new String[] {null, xyz, abc})", StringUtils.endsWithAny("defg", new String[] {null, "xyz", "abc"})); [EOL]  [EOL]         assertTrue("StringUtils.endsWithAny(abcxyz, StringBuilder(abc), StringBuffer(xyz))", StringUtils.endsWithAny("abcxyz", new StringBuilder("abc"), new StringBuffer("xyz"))); [EOL]         assertTrue("StringUtils.endsWithAny( StrBuilder(abcxyz), StringBuilder(
@Test [EOL]     public void testEndsWithAny() { [EOL]         assertFalse("StringUtils.endsWithAny(null, null)", StringUtils.endsWithAny(null, (String)null)); [EOL]         assertFalse("StringUtils.endsWithAny(null, new String[] {abc})", StringUtils.endsWithAny(null, new String[] {"abc"})); [EOL]         assertFalse("StringUtils.endsWithAny(abcxyz, null)", StringUtils.endsWithAny("abcxyz", (String)null)); [EOL]         assertTrue("StringUtils.endsWithAny(abcxyz, new String[] {\"\"})", StringUtils.endsWithAny("abcxyz", new String[] {""})); [EOL]         assertTrue("StringUtils.endsWithAny(abcxyz, new String[] {xyz})", StringUtils.endsWithAny("abcxyz", new String[] {"xyz"})); [EOL]         assertTrue("StringUtils.endsWithAny(abcxyz, new String[] {null, xyz, abc})", StringUtils.endsWithAny("abcxyz", new String[] {null, "xyz", "abc"})); [EOL]         assertFalse("StringUtils.endsWithAny(defg, new String[] {null, xyz, abc})", StringUtils.endsWithAny("defg", new String[] {null, "xyz", "abc"})); [EOL]  [EOL]         assertTrue("StringUtils.endsWithAny(abcxyz, StringBuilder(abc), StringBuffer(xyz))", StringUtils.endsWithAny("abcxyz", new StringBuilder("abc"), new StringBuffer("xyz"))); [EOL]         assertTrue("StringUtils.endsWithAny( StrBuilder(abcxyz), StringBuilder(
@Test [EOL]     public void testEndsWithAny() { [EOL]         assertFalse("StringUtils.endsWithAny(null, null)", StringUtils.endsWithAny(null, (String)null)); [EOL]         assertFalse("StringUtils.endsWithAny(null, new String[] {abc})", StringUtils.endsWithAny(null, new String[] {"abc"})); [EOL]         assertFalse("StringUtils.endsWithAny(abcxyz, null)", StringUtils.endsWithAny("abcxyz", (String)null)); [EOL]         assertTrue("StringUtils.endsWithAny(abcxyz, new String[] {\"\"})", StringUtils.endsWithAny("abcxyz", new String[] {""})); [EOL]         assertTrue("StringUtils.endsWithAny(abcxyz, new String[] {xyz})", StringUtils.endsWithAny("abcxyz", new String[] {"xyz"})); [EOL]         assertTrue("StringUtils.endsWithAny(abcxyz, new String[] {null, xyz, abc})", StringUtils.endsWithAny("abcxyz", new String[] {null, "xyz", "abc"})); [EOL]         assertFalse("StringUtils.endsWithAny(defg, new String[] {null, xyz, abc})", StringUtils.endsWithAny("defg", new String[] {null, "xyz", "abc"})); [EOL]  [EOL]         assertTrue("StringUtils.endsWithAny(abcxyz, StringBuilder(abc), StringBuffer(xyz))", StringUtils.endsWithAny("abcxyz", new StringBuilder("abc"), new StringBuffer("xyz"))); [EOL]         assertTrue("StringUtils.endsWithAny( StrBuilder(abcxyz), StringBuilder(
@Test [EOL]     public void testEndsWithAny() { [EOL]         assertFalse("StringUtils.endsWithAny(null, null)", StringUtils.endsWithAny(null, (String)null)); [EOL]         assertFalse("StringUtils.endsWithAny(null, new String[] {abc})", StringUtils.endsWithAny(null, new String[] {"abc"})); [EOL]         assertFalse("StringUtils.endsWithAny(abcxyz, null)", StringUtils.endsWithAny("abcxyz", (String)null)); [EOL]         assertTrue("StringUtils.endsWithAny(abcxyz, new String[] {\"\"})", StringUtils.endsWithAny("abcxyz", new String[] {""})); [EOL]         assertTrue("StringUtils.endsWithAny(abcxyz, new String[] {xyz})", StringUtils.endsWithAny("abcxyz", new String[] {"xyz"})); [EOL]         assertTrue("StringUtils.endsWithAny(abcxyz, new String[] {null, xyz, abc})", StringUtils.endsWithAny("abcxyz", new String[] {null, "xyz", "abc"})); [EOL]         assertFalse("StringUtils.endsWithAny(defg, new String[] {null, xyz, abc})", StringUtils.endsWithAny("defg", new String[] {null, "xyz", "abc"})); [EOL]  [EOL]         assertTrue("StringUtils.endsWithAny(abcxyz, StringBuilder(abc), StringBuffer(xyz))", StringUtils.endsWithAny("abcxyz", new StringBuilder("abc"), new StringBuffer("xyz"))); [EOL]         assertTrue("StringUtils.endsWithAny( StrBuilder(abcxyz), StringBuilder(
@Test [EOL]     public void testEndsWithAny() { [EOL]         assertFalse("StringUtils.endsWithAny(null, null)", StringUtils.endsWithAny(null, (String)null)); [EOL]         assertFalse("StringUtils.endsWithAny(null, new String[] {abc})", StringUtils.endsWithAny(null, new String[] {"abc"})); [EOL]         assertFalse("StringUtils.endsWithAny(abcxyz, null)", StringUtils.endsWithAny("abcxyz", (String)null)); [EOL]         assertTrue("StringUtils.endsWithAny(abcxyz, new String[] {\"\"})", StringUtils.endsWithAny("abcxyz", new String[] {""})); [EOL]         assertTrue("StringUtils.endsWithAny(abcxyz, new String[] {xyz})", StringUtils.endsWithAny("abcxyz", new String[] {"xyz"})); [EOL]         assertTrue("StringUtils.endsWithAny(abcxyz, new String[] {null, xyz, abc})", StringUtils.endsWithAny("abcxyz", new String[] {null, "xyz", "abc"})); [EOL]         assertFalse("StringUtils.endsWithAny(defg, new String[] {null, xyz, abc})", StringUtils.endsWithAny("defg", new String[] {null, "xyz", "abc"})); [EOL]  [EOL]         assertTrue("StringUtils.endsWithAny(abcxyz, StringBuilder(abc), StringBuffer(xyz))", StringUtils.endsWithAny("abcxyz", new StringBuilder("abc"), new StringBuffer("xyz"))); [EOL]         assertTrue("StringUtils.endsWithAny( StrBuilder(abcxyz), StringBuilder(
@Test [EOL]     public void testEndsWithAny() { [EOL]         assertFalse("StringUtils.endsWithAny(null, null)", StringUtils.endsWithAny(null, (String)null)); [EOL]         assertFalse("StringUtils.endsWithAny(null, new String[] {abc})", StringUtils.endsWithAny(null, new String[] {"abc"})); [EOL]         assertFalse("StringUtils.endsWithAny(abcxyz, null)", StringUtils.endsWithAny("abcxyz", (String)null)); [EOL]         assertTrue("StringUtils.endsWithAny(abcxyz, new String[] {\"\"})", StringUtils.endsWithAny("abcxyz", new String[] {""})); [EOL]         assertTrue("StringUtils.endsWithAny(abcxyz, new String[] {xyz})", StringUtils.endsWithAny("abcxyz", new String[] {"xyz"})); [EOL]         assertTrue("StringUtils.endsWithAny(abcxyz, new String[] {null, xyz, abc})", StringUtils.endsWithAny("abcxyz", new String[] {null, "xyz", "abc"})); [EOL]         assertFalse("StringUtils.endsWithAny(defg, new String[] {null, xyz, abc})", StringUtils.endsWithAny("defg", new String[] {null, "xyz", "abc"})); [EOL]  [EOL]         assertTrue("StringUtils.endsWithAny(abcxyz, StringBuilder(abc), StringBuffer(xyz))", StringUtils.endsWithAny("abcxyz", new StringBuilder("abc"), new StringBuffer("xyz"))); [EOL]         assertTrue("StringUtils.endsWithAny( StrBuilder(abcxyz), StringBuilder(
@Test [EOL]     public void testMidString() { [EOL]         final StrBuilder sb = new StrBuilder("hello goodbye hello"); [EOL]         assertEquals("goodbye", sb.midString(6, 7)); [EOL]         assertEquals("hello", sb.midString(0, 5)); [EOL]         assertEquals("hello", sb.midString(-5, 5)); [EOL]         assertEquals("", sb.midString(0, -1)); [EOL]         assertEquals("", sb.midString(20, 2)); [EOL]         assertEquals("hello", sb.midString(14, 22)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReplaceAll_String_String() { [EOL]         StrBuilder sb = new StrBuilder("abcbccba"); [EOL]         sb.replaceAll((String) null, null); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll((String) null, "anything"); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll("", null); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll("", "anything"); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]          [EOL]         sb.replaceAll("x", "y"); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll("a", "d"); [EOL]         assertEquals("dbcbccbd", sb.toString()); [EOL]         sb.replaceAll("d", null); [EOL]         assertEquals("bcbccb", sb.toString()); [EOL]         sb.replaceAll("cb", "-"); [EOL]         assertEquals("b-c-", sb.toString()); [EOL]          [EOL]         sb = new StrBuilder("abcba"); [EOL]
@Test [EOL]     public void testLastIndexOf_String() { [EOL]         final StrBuilder sb = new StrBuilder("abab"); [EOL]          [EOL]         assertEquals(2, sb.lastIndexOf("a")); [EOL]         //should work like String#lastIndexOf [EOL]         assertEquals("abab".lastIndexOf("a"), sb.lastIndexOf("a")); [EOL]          [EOL]         assertEquals(2, sb.lastIndexOf("ab")); [EOL]         //should work like String#lastIndexOf [EOL]         assertEquals("abab".lastIndexOf("ab"), sb.lastIndexOf("ab")); [EOL]          [EOL]         assertEquals(3, sb.lastIndexOf("b")); [EOL]         assertEquals("abab".lastIndexOf("b"), sb.lastIndexOf("b")); [EOL]          [EOL]         assertEquals(1, sb.lastIndexOf("ba")); [EOL]         assertEquals("abab".lastIndexOf("ba"), sb.lastIndexOf("ba")); [EOL]          [EOL]         assertEquals(-1, sb.lastIndexOf("z")); [EOL]          [EOL]         assertEquals(-1, sb.lastIndexOf((String) null)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEqualsIgnoreCase() { [EOL]         final StrBuilder sb1 = new StrBuilder(); [EOL]         final StrBuilder sb2 = new StrBuilder(); [EOL]         assertTrue(sb1.equalsIgnoreCase(sb1)); [EOL]         assertTrue(sb1.equalsIgnoreCase(sb2)); [EOL]         assertTrue(sb2.equalsIgnoreCase(sb2)); [EOL]          [EOL]         sb1.append("abc"); [EOL]         assertFalse(sb1.equalsIgnoreCase(sb2)); [EOL]          [EOL]         sb2.append("ABC"); [EOL]         assertTrue(sb1.equalsIgnoreCase(sb2)); [EOL]          [EOL]         sb2.clear().append("abc"); [EOL]         assertTrue(sb1.equalsIgnoreCase(sb2)); [EOL]         assertTrue(sb1.equalsIgnoreCase(sb1)); [EOL]         assertTrue(sb2.equalsIgnoreCase(sb2)); [EOL]          [EOL]         sb2.clear().append("aBc"); [EOL]         assertTrue(sb1.equalsIgnoreCase(sb2)); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testEqualsIgnoreCase() { [EOL]         final StrBuilder sb1 = new StrBuilder(); [EOL]         final StrBuilder sb2 = new StrBuilder(); [EOL]         assertTrue(sb1.equalsIgnoreCase(sb1)); [EOL]         assertTrue(sb1.equalsIgnoreCase(sb2)); [EOL]         assertTrue(sb2.equalsIgnoreCase(sb2)); [EOL]          [EOL]         sb1.append("abc"); [EOL]         assertFalse(sb1.equalsIgnoreCase(sb2)); [EOL]          [EOL]         sb2.append("ABC"); [EOL]         assertTrue(sb1.equalsIgnoreCase(sb2)); [EOL]          [EOL]         sb2.clear().append("abc"); [EOL]         assertTrue(sb1.equalsIgnoreCase(sb2)); [EOL]         assertTrue(sb1.equalsIgnoreCase(sb1)); [EOL]         assertTrue(sb2.equalsIgnoreCase(sb2)); [EOL]          [EOL]         sb2.clear().append("aBc"); [EOL]         assertTrue(sb1.equalsIgnoreCase(sb2)); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testEqualsIgnoreCase() { [EOL]         final StrBuilder sb1 = new StrBuilder(); [EOL]         final StrBuilder sb2 = new StrBuilder(); [EOL]         assertTrue(sb1.equalsIgnoreCase(sb1)); [EOL]         assertTrue(sb1.equalsIgnoreCase(sb2)); [EOL]         assertTrue(sb2.equalsIgnoreCase(sb2)); [EOL]          [EOL]         sb1.append("abc"); [EOL]         assertFalse(sb1.equalsIgnoreCase(sb2)); [EOL]          [EOL]         sb2.append("ABC"); [EOL]         assertTrue(sb1.equalsIgnoreCase(sb2)); [EOL]          [EOL]         sb2.clear().append("abc"); [EOL]         assertTrue(sb1.equalsIgnoreCase(sb2)); [EOL]         assertTrue(sb1.equalsIgnoreCase(sb1)); [EOL]         assertTrue(sb2.equalsIgnoreCase(sb2)); [EOL]          [EOL]         sb2.clear().append("aBc"); [EOL]         assertTrue(sb1.equalsIgnoreCase(sb2)); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testEqualsIgnoreCase() { [EOL]         final StrBuilder sb1 = new StrBuilder(); [EOL]         final StrBuilder sb2 = new StrBuilder(); [EOL]         assertTrue(sb1.equalsIgnoreCase(sb1)); [EOL]         assertTrue(sb1.equalsIgnoreCase(sb2)); [EOL]         assertTrue(sb2.equalsIgnoreCase(sb2)); [EOL]          [EOL]         sb1.append("abc"); [EOL]         assertFalse(sb1.equalsIgnoreCase(sb2)); [EOL]          [EOL]         sb2.append("ABC"); [EOL]         assertTrue(sb1.equalsIgnoreCase(sb2)); [EOL]          [EOL]         sb2.clear().append("abc"); [EOL]         assertTrue(sb1.equalsIgnoreCase(sb2)); [EOL]         assertTrue(sb1.equalsIgnoreCase(sb1)); [EOL]         assertTrue(sb2.equalsIgnoreCase(sb2)); [EOL]          [EOL]         sb2.clear().append("aBc"); [EOL]         assertTrue(sb1.equalsIgnoreCase(sb2)); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testEqualsIgnoreCase() { [EOL]         final StrBuilder sb1 = new StrBuilder(); [EOL]         final StrBuilder sb2 = new StrBuilder(); [EOL]         assertTrue(sb1.equalsIgnoreCase(sb1)); [EOL]         assertTrue(sb1.equalsIgnoreCase(sb2)); [EOL]         assertTrue(sb2.equalsIgnoreCase(sb2)); [EOL]          [EOL]         sb1.append("abc"); [EOL]         assertFalse(sb1.equalsIgnoreCase(sb2)); [EOL]          [EOL]         sb2.append("ABC"); [EOL]         assertTrue(sb1.equalsIgnoreCase(sb2)); [EOL]          [EOL]         sb2.clear().append("abc"); [EOL]         assertTrue(sb1.equalsIgnoreCase(sb2)); [EOL]         assertTrue(sb1.equalsIgnoreCase(sb1)); [EOL]         assertTrue(sb2.equalsIgnoreCase(sb2)); [EOL]          [EOL]         sb2.clear().append("aBc"); [EOL]         assertTrue(sb1.equalsIgnoreCase(sb2)); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final StrBuilder sb1 = new StrBuilder(); [EOL]         final StrBuilder sb2 = new StrBuilder(); [EOL]         assertTrue(sb1.equals(sb2)); [EOL]         assertTrue(sb1.equals(sb1)); [EOL]         assertTrue(sb2.equals(sb2)); [EOL]         assertTrue(sb1.equals((Object) sb2)); [EOL]          [EOL]         sb1.append("abc"); [EOL]         assertFalse(sb1.equals(sb2)); [EOL]         assertFalse(sb1.equals((Object) sb2)); [EOL]          [EOL]         sb2.append("ABC"); [EOL]         assertFalse(sb1.equals(sb2)); [EOL]         assertFalse(sb1.equals((Object) sb2)); [EOL]          [EOL]         sb2.clear().append("abc"); [EOL]         assertTrue(sb1.equals(sb2)); [EOL]         assertTrue(sb1.equals((Object) sb2)); [EOL]          [EOL]         assertFalse(sb1.equals(Integer.valueOf(1))); [EOL]         assertFalse(sb1.equals("abc")); [EOL]     } [EOL]  [E
@Test [EOL]     public void testEquals() { [EOL]         final StrBuilder sb1 = new StrBuilder(); [EOL]         final StrBuilder sb2 = new StrBuilder(); [EOL]         assertTrue(sb1.equals(sb2)); [EOL]         assertTrue(sb1.equals(sb1)); [EOL]         assertTrue(sb2.equals(sb2)); [EOL]         assertTrue(sb1.equals((Object) sb2)); [EOL]          [EOL]         sb1.append("abc"); [EOL]         assertFalse(sb1.equals(sb2)); [EOL]         assertFalse(sb1.equals((Object) sb2)); [EOL]          [EOL]         sb2.append("ABC"); [EOL]         assertFalse(sb1.equals(sb2)); [EOL]         assertFalse(sb1.equals((Object) sb2)); [EOL]          [EOL]         sb2.clear().append("abc"); [EOL]         assertTrue(sb1.equals(sb2)); [EOL]         assertTrue(sb1.equals((Object) sb2)); [EOL]          [EOL]         assertFalse(sb1.equals(Integer.valueOf(1))); [EOL]         assertFalse(sb1.equals("abc")); [EOL]     } [EOL]  [E
@Test [EOL]     public void testAsReader() throws Exception { [EOL]         final StrBuilder sb = new StrBuilder("some text"); [EOL]         Reader reader = sb.asReader(); [EOL]         assertTrue(reader.ready()); [EOL]         final char[] buf = new char[40]; [EOL]         assertEquals(9, reader.read(buf)); [EOL]         assertEquals("some text", new String(buf, 0, 9)); [EOL]          [EOL]         assertEquals(-1, reader.read()); [EOL]         assertFalse(reader.ready()); [EOL]         assertEquals(0, reader.skip(2)); [EOL]         assertEquals(0, reader.skip(-1)); [EOL]          [EOL]         assertTrue(reader.markSupported()); [EOL]         reader = sb.asReader(); [EOL]         assertEquals('s', reader.read()); [EOL]         reader.mark(-1); [EOL]         char[] array = new char[3]; [EOL]         assertEquals(3, reader.read(array, 0, 3)); [EOL]         assertEquals('o', array[0]); [EOL]         assertEquals('m', array[1]); [EOL]         assertEquals('e', array[2]); [EOL]         reader.reset(); [EOL]         assertEqu
@Test [EOL]     public void testAsReader() throws Exception { [EOL]         final StrBuilder sb = new StrBuilder("some text"); [EOL]         Reader reader = sb.asReader(); [EOL]         assertTrue(reader.ready()); [EOL]         final char[] buf = new char[40]; [EOL]         assertEquals(9, reader.read(buf)); [EOL]         assertEquals("some text", new String(buf, 0, 9)); [EOL]          [EOL]         assertEquals(-1, reader.read()); [EOL]         assertFalse(reader.ready()); [EOL]         assertEquals(0, reader.skip(2)); [EOL]         assertEquals(0, reader.skip(-1)); [EOL]          [EOL]         assertTrue(reader.markSupported()); [EOL]         reader = sb.asReader(); [EOL]         assertEquals('s', reader.read()); [EOL]         reader.mark(-1); [EOL]         char[] array = new char[3]; [EOL]         assertEquals(3, reader.read(array, 0, 3)); [EOL]         assertEquals('o', array[0]); [EOL]         assertEquals('m', array[1]); [EOL]         assertEquals('e', array[2]); [EOL]         reader.reset(); [EOL]         assertEqu
@Test [EOL]     public void testReplaceEmptyKeys() { [EOL]         doTestReplace("The ${} jumps over the lazy dog.", "The ${} jumps over the ${target}.", true); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests replace creates output same as input. [EOL]      */ [EOL]
@Test [EOL]     public void testReplaceEmptyKeys() { [EOL]         doTestReplace("The ${} jumps over the lazy dog.", "The ${} jumps over the ${target}.", true); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests replace creates output same as input. [EOL]      */ [EOL]
@Test [EOL]     public void testResolveVariable() { [EOL]         final StrBuilder builder = new StrBuilder("Hi ${name}!"); [EOL]         final Map<String, String> map = new HashMap<String, String>(); [EOL]         map.put("name", "commons"); [EOL]         final StrSubstitutor sub = new StrSubstitutor(map) { [EOL]             @Override [EOL]             protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos) { [EOL]                 assertEquals("name", variableName); [EOL]                 assertSame(builder, buf); [EOL]                 assertEquals(3, startPos); [EOL]                 assertEquals(10, endPos); [EOL]                 return "jakarta"; [EOL]             } [EOL]         }; [EOL]         sub.replaceIn(builder); [EOL]         assertEquals("Hi jakarta!", builder.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]     /** [EOL]      * Tests constructor. [EOL]      */ [EOL]
@Test [EOL]     public void testResolveVariable() { [EOL]         final StrBuilder builder = new StrBuilder("Hi ${name}!"); [EOL]         final Map<String, String> map = new HashMap<String, String>(); [EOL]         map.put("name", "commons"); [EOL]         final StrSubstitutor sub = new StrSubstitutor(map) { [EOL]             @Override [EOL]             protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos) { [EOL]                 assertEquals("name", variableName); [EOL]                 assertSame(builder, buf); [EOL]                 assertEquals(3, startPos); [EOL]                 assertEquals(10, endPos); [EOL]                 return "jakarta"; [EOL]             } [EOL]         }; [EOL]         sub.replaceIn(builder); [EOL]         assertEquals("Hi jakarta!", builder.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]     /** [EOL]      * Tests constructor. [EOL]      */ [EOL]
@Test [EOL]     public void testResolveVariable() { [EOL]         final StrBuilder builder = new StrBuilder("Hi ${name}!"); [EOL]         final Map<String, String> map = new HashMap<String, String>(); [EOL]         map.put("name", "commons"); [EOL]         final StrSubstitutor sub = new StrSubstitutor(map) { [EOL]             @Override [EOL]             protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos) { [EOL]                 assertEquals("name", variableName); [EOL]                 assertSame(builder, buf); [EOL]                 assertEquals(3, startPos); [EOL]                 assertEquals(10, endPos); [EOL]                 return "jakarta"; [EOL]             } [EOL]         }; [EOL]         sub.replaceIn(builder); [EOL]         assertEquals("Hi jakarta!", builder.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]     /** [EOL]      * Tests constructor. [EOL]      */ [EOL]
@Test [EOL]     public void testResolveVariable() { [EOL]         final StrBuilder builder = new StrBuilder("Hi ${name}!"); [EOL]         final Map<String, String> map = new HashMap<String, String>(); [EOL]         map.put("name", "commons"); [EOL]         final StrSubstitutor sub = new StrSubstitutor(map) { [EOL]             @Override [EOL]             protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos) { [EOL]                 assertEquals("name", variableName); [EOL]                 assertSame(builder, buf); [EOL]                 assertEquals(3, startPos); [EOL]                 assertEquals(10, endPos); [EOL]                 return "jakarta"; [EOL]             } [EOL]         }; [EOL]         sub.replaceIn(builder); [EOL]         assertEquals("Hi jakarta!", builder.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]     /** [EOL]      * Tests constructor. [EOL]      */ [EOL]
@Test [EOL]     public void testResolveVariable() { [EOL]         final StrBuilder builder = new StrBuilder("Hi ${name}!"); [EOL]         final Map<String, String> map = new HashMap<String, String>(); [EOL]         map.put("name", "commons"); [EOL]         final StrSubstitutor sub = new StrSubstitutor(map) { [EOL]             @Override [EOL]             protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos) { [EOL]                 assertEquals("name", variableName); [EOL]                 assertSame(builder, buf); [EOL]                 assertEquals(3, startPos); [EOL]                 assertEquals(10, endPos); [EOL]                 return "jakarta"; [EOL]             } [EOL]         }; [EOL]         sub.replaceIn(builder); [EOL]         assertEquals("Hi jakarta!", builder.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]     /** [EOL]      * Tests constructor. [EOL]      */ [EOL]
@Test [EOL]     public void testResolveVariable() { [EOL]         final StrBuilder builder = new StrBuilder("Hi ${name}!"); [EOL]         final Map<String, String> map = new HashMap<String, String>(); [EOL]         map.put("name", "commons"); [EOL]         final StrSubstitutor sub = new StrSubstitutor(map) { [EOL]             @Override [EOL]             protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos) { [EOL]                 assertEquals("name", variableName); [EOL]                 assertSame(builder, buf); [EOL]                 assertEquals(3, startPos); [EOL]                 assertEquals(10, endPos); [EOL]                 return "jakarta"; [EOL]             } [EOL]         }; [EOL]         sub.replaceIn(builder); [EOL]         assertEquals("Hi jakarta!", builder.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]     /** [EOL]      * Tests constructor. [EOL]      */ [EOL]
@Test [EOL]     public void testResolveVariable() { [EOL]         final StrBuilder builder = new StrBuilder("Hi ${name}!"); [EOL]         final Map<String, String> map = new HashMap<String, String>(); [EOL]         map.put("name", "commons"); [EOL]         final StrSubstitutor sub = new StrSubstitutor(map) { [EOL]             @Override [EOL]             protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos) { [EOL]                 assertEquals("name", variableName); [EOL]                 assertSame(builder, buf); [EOL]                 assertEquals(3, startPos); [EOL]                 assertEquals(10, endPos); [EOL]                 return "jakarta"; [EOL]             } [EOL]         }; [EOL]         sub.replaceIn(builder); [EOL]         assertEquals("Hi jakarta!", builder.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]     /** [EOL]      * Tests constructor. [EOL]      */ [EOL]
@Test [EOL]     public void testResolveVariable() { [EOL]         final StrBuilder builder = new StrBuilder("Hi ${name}!"); [EOL]         final Map<String, String> map = new HashMap<String, String>(); [EOL]         map.put("name", "commons"); [EOL]         final StrSubstitutor sub = new StrSubstitutor(map) { [EOL]             @Override [EOL]             protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos) { [EOL]                 assertEquals("name", variableName); [EOL]                 assertSame(builder, buf); [EOL]                 assertEquals(3, startPos); [EOL]                 assertEquals(10, endPos); [EOL]                 return "jakarta"; [EOL]             } [EOL]         }; [EOL]         sub.replaceIn(builder); [EOL]         assertEquals("Hi jakarta!", builder.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]     /** [EOL]      * Tests constructor. [EOL]      */ [EOL]
@Test [EOL]     public void testResolveVariable() { [EOL]         final StrBuilder builder = new StrBuilder("Hi ${name}!"); [EOL]         final Map<String, String> map = new HashMap<String, String>(); [EOL]         map.put("name", "commons"); [EOL]         final StrSubstitutor sub = new StrSubstitutor(map) { [EOL]             @Override [EOL]             protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos) { [EOL]                 assertEquals("name", variableName); [EOL]                 assertSame(builder, buf); [EOL]                 assertEquals(3, startPos); [EOL]                 assertEquals(10, endPos); [EOL]                 return "jakarta"; [EOL]             } [EOL]         }; [EOL]         sub.replaceIn(builder); [EOL]         assertEquals("Hi jakarta!", builder.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]     /** [EOL]      * Tests constructor. [EOL]      */ [EOL]
@Test [EOL]     public void testResolveVariable() { [EOL]         final StrBuilder builder = new StrBuilder("Hi ${name}!"); [EOL]         final Map<String, String> map = new HashMap<String, String>(); [EOL]         map.put("name", "commons"); [EOL]         final StrSubstitutor sub = new StrSubstitutor(map) { [EOL]             @Override [EOL]             protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos) { [EOL]                 assertEquals("name", variableName); [EOL]                 assertSame(builder, buf); [EOL]                 assertEquals(3, startPos); [EOL]                 assertEquals(10, endPos); [EOL]                 return "jakarta"; [EOL]             } [EOL]         }; [EOL]         sub.replaceIn(builder); [EOL]         assertEquals("Hi jakarta!", builder.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]     /** [EOL]      * Tests constructor. [EOL]      */ [EOL]
@Test [EOL]     public void testResolveVariable() { [EOL]         final StrBuilder builder = new StrBuilder("Hi ${name}!"); [EOL]         final Map<String, String> map = new HashMap<String, String>(); [EOL]         map.put("name", "commons"); [EOL]         final StrSubstitutor sub = new StrSubstitutor(map) { [EOL]             @Override [EOL]             protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos) { [EOL]                 assertEquals("name", variableName); [EOL]                 assertSame(builder, buf); [EOL]                 assertEquals(3, startPos); [EOL]                 assertEquals(10, endPos); [EOL]                 return "jakarta"; [EOL]             } [EOL]         }; [EOL]         sub.replaceIn(builder); [EOL]         assertEquals("Hi jakarta!", builder.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]     /** [EOL]      * Tests constructor. [EOL]      */ [EOL]
@Test [EOL]     public void testGetSetSuffix() { [EOL]         final StrSubstitutor sub = new StrSubstitutor(); [EOL]         assertTrue(sub.getVariableSuffixMatcher() instanceof StrMatcher.StringMatcher); [EOL]         sub.setVariableSuffix('<'); [EOL]         assertTrue(sub.getVariableSuffixMatcher() instanceof StrMatcher.CharMatcher); [EOL]  [EOL]         sub.setVariableSuffix("<<"); [EOL]         assertTrue(sub.getVariableSuffixMatcher() instanceof StrMatcher.StringMatcher); [EOL]         try { [EOL]             sub.setVariableSuffix((String) null); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) { [EOL]             // expected [EOL]         } [EOL]         assertTrue(sub.getVariableSuffixMatcher() instanceof StrMatcher.StringMatcher); [EOL]  [EOL]         final StrMatcher matcher = StrMatcher.commaMatcher(); [EOL]         sub.setVariableSuffixMatcher(matcher); [EOL]         assertSame(matcher, sub.getVariableSuffixMatcher()); [EOL]         try { [EOL]             sub.setVariableSuffixMatcher((StrMatcher) null); [EOL]            
@Test [EOL]     public void testMultiLongArray() { [EOL]         final long[][] array1 = new long[2][2]; [EOL]         final long[][] array2 = new long[2][2]; [EOL]         final long[][] array3 = new long[2][3]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]                 array3[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         array3[1][2] = 100; [EOL]         array3[1][2] = 100; [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(array3,
@Test [EOL]     public void testMultiLongArray() { [EOL]         final long[][] array1 = new long[2][2]; [EOL]         final long[][] array2 = new long[2][2]; [EOL]         final long[][] array3 = new long[2][3]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]                 array3[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         array3[1][2] = 100; [EOL]         array3[1][2] = 100; [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(array3,
@Test [EOL]     public void testMultiDoubleArray() { [EOL]         final double[][] array1 = new double[2][2]; [EOL]         final double[][] array2 = new double[2][2]; [EOL]         final double[][] array3 = new double[2][3]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]                 array3[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         array3[1][2] = 100; [EOL]         array3[1][2] = 100; [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(array3,
@Test [EOL]     public void testMultiLongArray() { [EOL]         final long[][] array1 = new long[2][2]; [EOL]         final long[][] array2 = new long[2][2]; [EOL]         final long[][] array3 = new long[2][3]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]                 array3[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         array3[1][2] = 100; [EOL]         array3[1][2] = 100; [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(array3,
@Test [EOL]     public void testMultiLongArray() { [EOL]         final long[][] array1 = new long[2][2]; [EOL]         final long[][] array2 = new long[2][2]; [EOL]         final long[][] array3 = new long[2][3]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]                 array3[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         array3[1][2] = 100; [EOL]         array3[1][2] = 100; [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(array3,
@Test [EOL]     public void testMultiDoubleArray() { [EOL]         final double[][] array1 = new double[2][2]; [EOL]         final double[][] array2 = new double[2][2]; [EOL]         final double[][] array3 = new double[2][3]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]                 array3[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         array3[1][2] = 100; [EOL]         array3[1][2] = 100; [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(array3,
@Test [EOL]     public void testMultiDoubleArray() { [EOL]         final double[][] array1 = new double[2][2]; [EOL]         final double[][] array2 = new double[2][2]; [EOL]         final double[][] array3 = new double[2][3]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]                 array3[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         array3[1][2] = 100; [EOL]         array3[1][2] = 100; [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(array3,
@Test [EOL]     public void testMultiFloatArray() { [EOL]         final float[][] array1 = new float[2][2]; [EOL]         final float[][] array2 = new float[2][2]; [EOL]         final float[][] array3 = new float[2][3]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]                 array3[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         array3[1][2] = 100; [EOL]         array3[1][2] = 100; [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(array3,
@Test [EOL]     public void testMultiFloatArray() { [EOL]         final float[][] array1 = new float[2][2]; [EOL]         final float[][] array2 = new float[2][2]; [EOL]         final float[][] array3 = new float[2][3]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]                 array3[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         array3[1][2] = 100; [EOL]         array3[1][2] = 100; [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(array3,
@Test [EOL]     public void testMultiLongArray() { [EOL]         final long[][] array1 = new long[2][2]; [EOL]         final long[][] array2 = new long[2][2]; [EOL]         final long[][] array3 = new long[2][3]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]                 array3[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         array3[1][2] = 100; [EOL]         array3[1][2] = 100; [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(array3,
@Test [EOL]     public void testMultiLongArray() { [EOL]         final long[][] array1 = new long[2][2]; [EOL]         final long[][] array2 = new long[2][2]; [EOL]         final long[][] array3 = new long[2][3]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]                 array3[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         array3[1][2] = 100; [EOL]         array3[1][2] = 100; [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(array3,
@Test [EOL]     public void testMultiLongArray() { [EOL]         final long[][] array1 = new long[2][2]; [EOL]         final long[][] array2 = new long[2][2]; [EOL]         final long[][] array3 = new long[2][3]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]                 array3[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         array3[1][2] = 100; [EOL]         array3[1][2] = 100; [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(array3,
@Test [EOL]     public void testMultiLongArray() { [EOL]         final long[][] array1 = new long[2][2]; [EOL]         final long[][] array2 = new long[2][2]; [EOL]         final long[][] array3 = new long[2][3]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]                 array3[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         array3[1][2] = 100; [EOL]         array3[1][2] = 100; [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(array3,
@Test [EOL]     public void testMultiLongArray() { [EOL]         final long[][] array1 = new long[2][2]; [EOL]         final long[][] array2 = new long[2][2]; [EOL]         final long[][] array3 = new long[2][3]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]                 array3[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         array3[1][2] = 100; [EOL]         array3[1][2] = 100; [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(array3,
@Test [EOL]     public void testLongArray() { [EOL]         final long[] obj1 = new long[2]; [EOL]         obj1[0] = 5L; [EOL]         obj1[1] = 6L; [EOL]         final long[] obj2 = new long[2]; [EOL]         obj2[0] = 5L; [EOL]         obj2[1] = 6L; [EOL]         final long[] obj3 = new long[3]; [EOL]         obj3[0] = 5L; [EOL]         obj3[1] = 6L; [EOL]         obj3[2] = 7L; [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]  [EOL]         obj1[1] = 7; [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]  [EOL]        
@Test [EOL]     public void testLongArray() { [EOL]         final long[] obj1 = new long[2]; [EOL]         obj1[0] = 5L; [EOL]         obj1[1] = 6L; [EOL]         final long[] obj2 = new long[2]; [EOL]         obj2[0] = 5L; [EOL]         obj2[1] = 6L; [EOL]         final long[] obj3 = new long[3]; [EOL]         obj3[0] = 5L; [EOL]         obj3[1] = 6L; [EOL]         obj3[2] = 7L; [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]  [EOL]         obj1[1] = 7; [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]  [EOL]        
@Test [EOL]     public void testLongArray() { [EOL]         final long[] obj1 = new long[2]; [EOL]         obj1[0] = 5L; [EOL]         obj1[1] = 6L; [EOL]         final long[] obj2 = new long[2]; [EOL]         obj2[0] = 5L; [EOL]         obj2[1] = 6L; [EOL]         final long[] obj3 = new long[3]; [EOL]         obj3[0] = 5L; [EOL]         obj3[1] = 6L; [EOL]         obj3[2] = 7L; [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]  [EOL]         obj1[1] = 7; [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]  [EOL]        
@Test [EOL]     public void testLongArray() { [EOL]         final long[] obj1 = new long[2]; [EOL]         obj1[0] = 5L; [EOL]         obj1[1] = 6L; [EOL]         final long[] obj2 = new long[2]; [EOL]         obj2[0] = 5L; [EOL]         obj2[1] = 6L; [EOL]         final long[] obj3 = new long[3]; [EOL]         obj3[0] = 5L; [EOL]         obj3[1] = 6L; [EOL]         obj3[2] = 7L; [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]  [EOL]         obj1[1] = 7; [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]  [EOL]        
@Test [EOL]     public void testIntArray() { [EOL]         final int[] obj1 = new int[2]; [EOL]         obj1[0] = 5; [EOL]         obj1[1] = 6; [EOL]         final int[] obj2 = new int[2]; [EOL]         obj2[0] = 5; [EOL]         obj2[1] = 6; [EOL]         final int[] obj3 = new int[3]; [EOL]         obj3[0] = 5; [EOL]         obj3[1] = 6; [EOL]         obj3[2] = 7; [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]  [EOL]         obj1[1] = 7; [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, null).
@Test [EOL]     public void testIntArray() { [EOL]         final int[] obj1 = new int[2]; [EOL]         obj1[0] = 5; [EOL]         obj1[1] = 6; [EOL]         final int[] obj2 = new int[2]; [EOL]         obj2[0] = 5; [EOL]         obj2[1] = 6; [EOL]         final int[] obj3 = new int[3]; [EOL]         obj3[0] = 5; [EOL]         obj3[1] = 6; [EOL]         obj3[2] = 7; [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]  [EOL]         obj1[1] = 7; [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, null).
@Test [EOL]     public void testMultiIntArray() { [EOL]         final int[][] array1 = new int[2][2]; [EOL]         final int[][] array2 = new int[2][2]; [EOL]         final int[][] array3 = new int[2][3]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]                 array3[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         array3[1][2] = 100; [EOL]         array3[1][2] = 100; [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(array3,
@Test [EOL]     public void testMultiIntArray() { [EOL]         final int[][] array1 = new int[2][2]; [EOL]         final int[][] array2 = new int[2][2]; [EOL]         final int[][] array3 = new int[2][3]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]                 array3[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         array3[1][2] = 100; [EOL]         array3[1][2] = 100; [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(array3,
@Test [EOL]     public void testIntArray() { [EOL]         final int[] obj1 = new int[2]; [EOL]         obj1[0] = 5; [EOL]         obj1[1] = 6; [EOL]         final int[] obj2 = new int[2]; [EOL]         obj2[0] = 5; [EOL]         obj2[1] = 6; [EOL]         final int[] obj3 = new int[3]; [EOL]         obj3[0] = 5; [EOL]         obj3[1] = 6; [EOL]         obj3[2] = 7; [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]  [EOL]         obj1[1] = 7; [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, null).
@Test [EOL]     public void testMultiShortArray() { [EOL]         final short[][] array1 = new short[2][2]; [EOL]         final short[][] array2 = new short[2][2]; [EOL]         final short[][] array3 = new short[2][3]; [EOL]         for (short i = 0; i < array1.length; ++i) { [EOL]             for (short j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (short)((i + 1) * (j + 1)); [EOL]                 array2[i][j] = (short)((i + 1) * (j + 1)); [EOL]                 array3[i][j] = (short)((i + 1) * (j + 1)); [EOL]             } [EOL]         } [EOL]         array3[1][2] = 100; [EOL]         array3[1][2] = 100; [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0); [EOL]         assertTrue(new
@Test [EOL]     public void testMultiShortArray() { [EOL]         final short[][] array1 = new short[2][2]; [EOL]         final short[][] array2 = new short[2][2]; [EOL]         final short[][] array3 = new short[2][3]; [EOL]         for (short i = 0; i < array1.length; ++i) { [EOL]             for (short j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (short)((i + 1) * (j + 1)); [EOL]                 array2[i][j] = (short)((i + 1) * (j + 1)); [EOL]                 array3[i][j] = (short)((i + 1) * (j + 1)); [EOL]             } [EOL]         } [EOL]         array3[1][2] = 100; [EOL]         array3[1][2] = 100; [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0); [EOL]         assertTrue(new
@Test [EOL]     public void testCharArray() { [EOL]         final char[] obj1 = new char[2]; [EOL]         obj1[0] = 5; [EOL]         obj1[1] = 6; [EOL]         final char[] obj2 = new char[2]; [EOL]         obj2[0] = 5; [EOL]         obj2[1] = 6; [EOL]         final char[] obj3 = new char[3]; [EOL]         obj3[0] = 5; [EOL]         obj3[1] = 6; [EOL]         obj3[2] = 7; [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]  [EOL]         obj1[1] = 7; [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, null).
@Test [EOL]     public void testCharArray() { [EOL]         final char[] obj1 = new char[2]; [EOL]         obj1[0] = 5; [EOL]         obj1[1] = 6; [EOL]         final char[] obj2 = new char[2]; [EOL]         obj2[0] = 5; [EOL]         obj2[1] = 6; [EOL]         final char[] obj3 = new char[3]; [EOL]         obj3[0] = 5; [EOL]         obj3[1] = 6; [EOL]         obj3[2] = 7; [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]  [EOL]         obj1[1] = 7; [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, null).
@Test [EOL]     public void testCharArray() { [EOL]         final char[] obj1 = new char[2]; [EOL]         obj1[0] = 5; [EOL]         obj1[1] = 6; [EOL]         final char[] obj2 = new char[2]; [EOL]         obj2[0] = 5; [EOL]         obj2[1] = 6; [EOL]         final char[] obj3 = new char[3]; [EOL]         obj3[0] = 5; [EOL]         obj3[1] = 6; [EOL]         obj3[2] = 7; [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]  [EOL]         obj1[1] = 7; [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, null).
@Test [EOL]     public void testCharArray() { [EOL]         final char[] obj1 = new char[2]; [EOL]         obj1[0] = 5; [EOL]         obj1[1] = 6; [EOL]         final char[] obj2 = new char[2]; [EOL]         obj2[0] = 5; [EOL]         obj2[1] = 6; [EOL]         final char[] obj3 = new char[3]; [EOL]         obj3[0] = 5; [EOL]         obj3[1] = 6; [EOL]         obj3[2] = 7; [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]  [EOL]         obj1[1] = 7; [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, null).
@Test [EOL]     public void testByteArray() { [EOL]         final byte[] obj1 = new byte[2]; [EOL]         obj1[0] = 5; [EOL]         obj1[1] = 6; [EOL]         final byte[] obj2 = new byte[2]; [EOL]         obj2[0] = 5; [EOL]         obj2[1] = 6; [EOL]         final byte[] obj3 = new byte[3]; [EOL]         obj3[0] = 5; [EOL]         obj3[1] = 6; [EOL]         obj3[2] = 7; [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]  [EOL]         obj1[1] = 7; [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, null).
@Test [EOL]     public void testByteArray() { [EOL]         final byte[] obj1 = new byte[2]; [EOL]         obj1[0] = 5; [EOL]         obj1[1] = 6; [EOL]         final byte[] obj2 = new byte[2]; [EOL]         obj2[0] = 5; [EOL]         obj2[1] = 6; [EOL]         final byte[] obj3 = new byte[3]; [EOL]         obj3[0] = 5; [EOL]         obj3[1] = 6; [EOL]         obj3[2] = 7; [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]  [EOL]         obj1[1] = 7; [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, null).
@Test [EOL]     public void testByteArray() { [EOL]         final byte[] obj1 = new byte[2]; [EOL]         obj1[0] = 5; [EOL]         obj1[1] = 6; [EOL]         final byte[] obj2 = new byte[2]; [EOL]         obj2[0] = 5; [EOL]         obj2[1] = 6; [EOL]         final byte[] obj3 = new byte[3]; [EOL]         obj3[0] = 5; [EOL]         obj3[1] = 6; [EOL]         obj3[2] = 7; [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]  [EOL]         obj1[1] = 7; [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, null).
@Test [EOL]     public void testByteArray() { [EOL]         final byte[] obj1 = new byte[2]; [EOL]         obj1[0] = 5; [EOL]         obj1[1] = 6; [EOL]         final byte[] obj2 = new byte[2]; [EOL]         obj2[0] = 5; [EOL]         obj2[1] = 6; [EOL]         final byte[] obj3 = new byte[3]; [EOL]         obj3[0] = 5; [EOL]         obj3[1] = 6; [EOL]         obj3[2] = 7; [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]  [EOL]         obj1[1] = 7; [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, null).
@Test [EOL]     public void testDoubleArray() { [EOL]         final double[] obj1 = new double[2]; [EOL]         obj1[0] = 5; [EOL]         obj1[1] = 6; [EOL]         final double[] obj2 = new double[2]; [EOL]         obj2[0] = 5; [EOL]         obj2[1] = 6; [EOL]         final double[] obj3 = new double[3]; [EOL]         obj3[0] = 5; [EOL]         obj3[1] = 6; [EOL]         obj3[2] = 7; [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]  [EOL]         obj1[1] = 7; [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, null).
@Test [EOL]     public void testDoubleArray() { [EOL]         final double[] obj1 = new double[2]; [EOL]         obj1[0] = 5; [EOL]         obj1[1] = 6; [EOL]         final double[] obj2 = new double[2]; [EOL]         obj2[0] = 5; [EOL]         obj2[1] = 6; [EOL]         final double[] obj3 = new double[3]; [EOL]         obj3[0] = 5; [EOL]         obj3[1] = 6; [EOL]         obj3[2] = 7; [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]  [EOL]         obj1[1] = 7; [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, null).
@Test [EOL]     public void testDoubleArray() { [EOL]         final double[] obj1 = new double[2]; [EOL]         obj1[0] = 5; [EOL]         obj1[1] = 6; [EOL]         final double[] obj2 = new double[2]; [EOL]         obj2[0] = 5; [EOL]         obj2[1] = 6; [EOL]         final double[] obj3 = new double[3]; [EOL]         obj3[0] = 5; [EOL]         obj3[1] = 6; [EOL]         obj3[2] = 7; [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]  [EOL]         obj1[1] = 7; [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, null).
@Test [EOL]     public void testFloatArray() { [EOL]         final float[] obj1 = new float[2]; [EOL]         obj1[0] = 5; [EOL]         obj1[1] = 6; [EOL]         final float[] obj2 = new float[2]; [EOL]         obj2[0] = 5; [EOL]         obj2[1] = 6; [EOL]         final float[] obj3 = new float[3]; [EOL]         obj3[0] = 5; [EOL]         obj3[1] = 6; [EOL]         obj3[2] = 7; [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]  [EOL]         obj1[1] = 7; [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, null).
@Test [EOL]     public void testFloatArray() { [EOL]         final float[] obj1 = new float[2]; [EOL]         obj1[0] = 5; [EOL]         obj1[1] = 6; [EOL]         final float[] obj2 = new float[2]; [EOL]         obj2[0] = 5; [EOL]         obj2[1] = 6; [EOL]         final float[] obj3 = new float[3]; [EOL]         obj3[0] = 5; [EOL]         obj3[1] = 6; [EOL]         obj3[2] = 7; [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]  [EOL]         obj1[1] = 7; [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, null).
@Test [EOL]     public void testFloatArray() { [EOL]         final float[] obj1 = new float[2]; [EOL]         obj1[0] = 5; [EOL]         obj1[1] = 6; [EOL]         final float[] obj2 = new float[2]; [EOL]         obj2[0] = 5; [EOL]         obj2[1] = 6; [EOL]         final float[] obj3 = new float[3]; [EOL]         obj3[0] = 5; [EOL]         obj3[1] = 6; [EOL]         obj3[2] = 7; [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]  [EOL]         obj1[1] = 7; [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, null).
@Test [EOL]     public void testFloatArray() { [EOL]         final float[] obj1 = new float[2]; [EOL]         obj1[0] = 5; [EOL]         obj1[1] = 6; [EOL]         final float[] obj2 = new float[2]; [EOL]         obj2[0] = 5; [EOL]         obj2[1] = 6; [EOL]         final float[] obj3 = new float[3]; [EOL]         obj3[0] = 5; [EOL]         obj3[1] = 6; [EOL]         obj3[2] = 7; [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]  [EOL]         obj1[1] = 7; [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, null).
@Test [EOL]     public void testFloatArray() { [EOL]         final float[] obj1 = new float[2]; [EOL]         obj1[0] = 5; [EOL]         obj1[1] = 6; [EOL]         final float[] obj2 = new float[2]; [EOL]         obj2[0] = 5; [EOL]         obj2[1] = 6; [EOL]         final float[] obj3 = new float[3]; [EOL]         obj3[0] = 5; [EOL]         obj3[1] = 6; [EOL]         obj3[2] = 7; [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]  [EOL]         obj1[1] = 7; [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, null).
@Test [EOL]     public void testBooleanArray() { [EOL]         final boolean[] obj1 = new boolean[2]; [EOL]         obj1[0] = true; [EOL]         obj1[1] = false; [EOL]         final boolean[] obj2 = new boolean[2]; [EOL]         obj2[0] = true; [EOL]         obj2[1] = false; [EOL]         final boolean[] obj3 = new boolean[3]; [EOL]         obj3[0] = true; [EOL]         obj3[1] = false; [EOL]         obj3[2] = true; [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]  [EOL]         obj1[1] = true; [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, null
@Test [EOL]     public void testBooleanArray() { [EOL]         final boolean[] obj1 = new boolean[2]; [EOL]         obj1[0] = true; [EOL]         obj1[1] = false; [EOL]         final boolean[] obj2 = new boolean[2]; [EOL]         obj2[0] = true; [EOL]         obj2[1] = false; [EOL]         final boolean[] obj3 = new boolean[3]; [EOL]         obj3[0] = true; [EOL]         obj3[1] = false; [EOL]         obj3[2] = true; [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]  [EOL]         obj1[1] = true; [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, null
@Test [EOL]     public void testBooleanArray() { [EOL]         final boolean[] obj1 = new boolean[2]; [EOL]         obj1[0] = true; [EOL]         obj1[1] = false; [EOL]         final boolean[] obj2 = new boolean[2]; [EOL]         obj2[0] = true; [EOL]         obj2[1] = false; [EOL]         final boolean[] obj3 = new boolean[3]; [EOL]         obj3[0] = true; [EOL]         obj3[1] = false; [EOL]         obj3[2] = true; [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]  [EOL]         obj1[1] = true; [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, null
@Test [EOL]     public void testBooleanArray() { [EOL]         final boolean[] obj1 = new boolean[2]; [EOL]         obj1[0] = true; [EOL]         obj1[1] = false; [EOL]         final boolean[] obj2 = new boolean[2]; [EOL]         obj2[0] = true; [EOL]         obj2[1] = false; [EOL]         final boolean[] obj3 = new boolean[3]; [EOL]         obj3[0] = true; [EOL]         obj3[1] = false; [EOL]         obj3[2] = true; [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]  [EOL]         obj1[1] = true; [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, null
@Test [EOL]     public void testBooleanArray() { [EOL]         final boolean[] obj1 = new boolean[2]; [EOL]         obj1[0] = true; [EOL]         obj1[1] = false; [EOL]         final boolean[] obj2 = new boolean[2]; [EOL]         obj2[0] = true; [EOL]         obj2[1] = false; [EOL]         final boolean[] obj3 = new boolean[3]; [EOL]         obj3[0] = true; [EOL]         obj3[1] = false; [EOL]         obj3[2] = true; [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]  [EOL]         obj1[1] = true; [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, null
@Test(expected = NoSuchElementException.class) [EOL]     public void testResultGetInitializerUnknown() throws ConcurrentException { [EOL]         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize(); [EOL]         res.getInitializer("unknown"); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tries to query the results of an unknown child initializer from the [EOL]      * results object. This should cause an exception. [EOL]      */ [EOL]
@Test(expected = NoSuchElementException.class) [EOL]     public void testResultGetInitializerUnknown() throws ConcurrentException { [EOL]         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize(); [EOL]         res.getInitializer("unknown"); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tries to query the results of an unknown child initializer from the [EOL]      * results object. This should cause an exception. [EOL]      */ [EOL]
@Test(expected = NoSuchElementException.class) [EOL]     public void testResultGetInitializerUnknown() throws ConcurrentException { [EOL]         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize(); [EOL]         res.getInitializer("unknown"); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tries to query the results of an unknown child initializer from the [EOL]      * results object. This should cause an exception. [EOL]      */ [EOL]
@Test(expected = NoSuchElementException.class) [EOL]     public void testResultGetInitializerUnknown() throws ConcurrentException { [EOL]         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize(); [EOL]         res.getInitializer("unknown"); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tries to query the results of an unknown child initializer from the [EOL]      * results object. This should cause an exception. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapeSurrogatePairs() throws Exception { [EOL]         assertEquals("\uD83D\uDE30", StringEscapeUtils.escapeCsv("\uD83D\uDE30")); [EOL]         // Examples from https://en.wikipedia.org/wiki/UTF-16 [EOL]         assertEquals("\uD800\uDC00", StringEscapeUtils.escapeCsv("\uD800\uDC00")); [EOL]         assertEquals("\uD834\uDD1E", StringEscapeUtils.escapeCsv("\uD834\uDD1E")); [EOL]         assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeCsv("\uDBFF\uDFFD")); [EOL]         assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeHtml3("\uDBFF\uDFFD")); [EOL]         assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeHtml4("\uDBFF\uDFFD")); [EOL]         assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeXml("\uDBFF\uDFFD")); [EOL]     } [EOL]      [EOL]     /** [EOL]      * Tests LANG-858. [EOL]      *  [EOL]      * @throws Exception [EOL]      */ [EOL]
@Test [EOL]     public void testEscapeSurrogatePairs() throws Exception { [EOL]         assertEquals("\uD83D\uDE30", StringEscapeUtils.escapeCsv("\uD83D\uDE30")); [EOL]         // Examples from https://en.wikipedia.org/wiki/UTF-16 [EOL]         assertEquals("\uD800\uDC00", StringEscapeUtils.escapeCsv("\uD800\uDC00")); [EOL]         assertEquals("\uD834\uDD1E", StringEscapeUtils.escapeCsv("\uD834\uDD1E")); [EOL]         assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeCsv("\uDBFF\uDFFD")); [EOL]         assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeHtml3("\uDBFF\uDFFD")); [EOL]         assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeHtml4("\uDBFF\uDFFD")); [EOL]         assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeXml("\uDBFF\uDFFD")); [EOL]     } [EOL]      [EOL]     /** [EOL]      * Tests LANG-858. [EOL]      *  [EOL]      * @throws Exception [EOL]      */ [EOL]
@Test [EOL]     public void testEscapeSurrogatePairs() throws Exception { [EOL]         assertEquals("\uD83D\uDE30", StringEscapeUtils.escapeCsv("\uD83D\uDE30")); [EOL]         // Examples from https://en.wikipedia.org/wiki/UTF-16 [EOL]         assertEquals("\uD800\uDC00", StringEscapeUtils.escapeCsv("\uD800\uDC00")); [EOL]         assertEquals("\uD834\uDD1E", StringEscapeUtils.escapeCsv("\uD834\uDD1E")); [EOL]         assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeCsv("\uDBFF\uDFFD")); [EOL]         assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeHtml3("\uDBFF\uDFFD")); [EOL]         assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeHtml4("\uDBFF\uDFFD")); [EOL]         assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeXml("\uDBFF\uDFFD")); [EOL]     } [EOL]      [EOL]     /** [EOL]      * Tests LANG-858. [EOL]      *  [EOL]      * @throws Exception [EOL]      */ [EOL]
@Test [EOL]     public void testEscapeSurrogatePairs() throws Exception { [EOL]         assertEquals("\uD83D\uDE30", StringEscapeUtils.escapeCsv("\uD83D\uDE30")); [EOL]         // Examples from https://en.wikipedia.org/wiki/UTF-16 [EOL]         assertEquals("\uD800\uDC00", StringEscapeUtils.escapeCsv("\uD800\uDC00")); [EOL]         assertEquals("\uD834\uDD1E", StringEscapeUtils.escapeCsv("\uD834\uDD1E")); [EOL]         assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeCsv("\uDBFF\uDFFD")); [EOL]         assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeHtml3("\uDBFF\uDFFD")); [EOL]         assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeHtml4("\uDBFF\uDFFD")); [EOL]         assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeXml("\uDBFF\uDFFD")); [EOL]     } [EOL]      [EOL]     /** [EOL]      * Tests LANG-858. [EOL]      *  [EOL]      * @throws Exception [EOL]      */ [EOL]
@Test [EOL]     public void testEscapeSurrogatePairs() throws Exception { [EOL]         assertEquals("\uD83D\uDE30", StringEscapeUtils.escapeCsv("\uD83D\uDE30")); [EOL]         // Examples from https://en.wikipedia.org/wiki/UTF-16 [EOL]         assertEquals("\uD800\uDC00", StringEscapeUtils.escapeCsv("\uD800\uDC00")); [EOL]         assertEquals("\uD834\uDD1E", StringEscapeUtils.escapeCsv("\uD834\uDD1E")); [EOL]         assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeCsv("\uDBFF\uDFFD")); [EOL]         assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeHtml3("\uDBFF\uDFFD")); [EOL]         assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeHtml4("\uDBFF\uDFFD")); [EOL]         assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeXml("\uDBFF\uDFFD")); [EOL]     } [EOL]      [EOL]     /** [EOL]      * Tests LANG-858. [EOL]      *  [EOL]      * @throws Exception [EOL]      */ [EOL]
@Test [EOL]     public void testEscapeSurrogatePairs() throws Exception { [EOL]         assertEquals("\uD83D\uDE30", StringEscapeUtils.escapeCsv("\uD83D\uDE30")); [EOL]         // Examples from https://en.wikipedia.org/wiki/UTF-16 [EOL]         assertEquals("\uD800\uDC00", StringEscapeUtils.escapeCsv("\uD800\uDC00")); [EOL]         assertEquals("\uD834\uDD1E", StringEscapeUtils.escapeCsv("\uD834\uDD1E")); [EOL]         assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeCsv("\uDBFF\uDFFD")); [EOL]         assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeHtml3("\uDBFF\uDFFD")); [EOL]         assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeHtml4("\uDBFF\uDFFD")); [EOL]         assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeXml("\uDBFF\uDFFD")); [EOL]     } [EOL]      [EOL]     /** [EOL]      * Tests LANG-858. [EOL]      *  [EOL]      * @throws Exception [EOL]      */ [EOL]
@Test [EOL]     public void testEscapeSurrogatePairs() throws Exception { [EOL]         assertEquals("\uD83D\uDE30", StringEscapeUtils.escapeCsv("\uD83D\uDE30")); [EOL]         // Examples from https://en.wikipedia.org/wiki/UTF-16 [EOL]         assertEquals("\uD800\uDC00", StringEscapeUtils.escapeCsv("\uD800\uDC00")); [EOL]         assertEquals("\uD834\uDD1E", StringEscapeUtils.escapeCsv("\uD834\uDD1E")); [EOL]         assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeCsv("\uDBFF\uDFFD")); [EOL]         assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeHtml3("\uDBFF\uDFFD")); [EOL]         assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeHtml4("\uDBFF\uDFFD")); [EOL]         assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeXml("\uDBFF\uDFFD")); [EOL]     } [EOL]      [EOL]     /** [EOL]      * Tests LANG-858. [EOL]      *  [EOL]      * @throws Exception [EOL]      */ [EOL]
@Test [EOL]     public void testEscapeSurrogatePairs() throws Exception { [EOL]         assertEquals("\uD83D\uDE30", StringEscapeUtils.escapeCsv("\uD83D\uDE30")); [EOL]         // Examples from https://en.wikipedia.org/wiki/UTF-16 [EOL]         assertEquals("\uD800\uDC00", StringEscapeUtils.escapeCsv("\uD800\uDC00")); [EOL]         assertEquals("\uD834\uDD1E", StringEscapeUtils.escapeCsv("\uD834\uDD1E")); [EOL]         assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeCsv("\uDBFF\uDFFD")); [EOL]         assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeHtml3("\uDBFF\uDFFD")); [EOL]         assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeHtml4("\uDBFF\uDFFD")); [EOL]         assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeXml("\uDBFF\uDFFD")); [EOL]     } [EOL]      [EOL]     /** [EOL]      * Tests LANG-858. [EOL]      *  [EOL]      * @throws Exception [EOL]      */ [EOL]
@Test [EOL]     public void testAbove() { [EOL]         final UnicodeEscaper ue = UnicodeEscaper.above('F'); [EOL]  [EOL]         final String input = "ADFGZ"; [EOL]         final String result = ue.translate(input); [EOL]         assertEquals("Failed to escape Unicode characters via the above method", "ADF\\u0047\\u005A", result); [EOL]     } [EOL] } [EOL]
@Test [EOL]     public void testAbove() { [EOL]         final UnicodeEscaper ue = UnicodeEscaper.above('F'); [EOL]  [EOL]         final String input = "ADFGZ"; [EOL]         final String result = ue.translate(input); [EOL]         assertEquals("Failed to escape Unicode characters via the above method", "ADF\\u0047\\u005A", result); [EOL]     } [EOL] } [EOL]
@Test [EOL]     public void testAbove() { [EOL]         final UnicodeEscaper ue = UnicodeEscaper.above('F'); [EOL]  [EOL]         final String input = "ADFGZ"; [EOL]         final String result = ue.translate(input); [EOL]         assertEquals("Failed to escape Unicode characters via the above method", "ADF\\u0047\\u005A", result); [EOL]     } [EOL] } [EOL]
@Test [EOL]     public void testAbove() { [EOL]         final UnicodeEscaper ue = UnicodeEscaper.above('F'); [EOL]  [EOL]         final String input = "ADFGZ"; [EOL]         final String result = ue.translate(input); [EOL]         assertEquals("Failed to escape Unicode characters via the above method", "ADF\\u0047\\u005A", result); [EOL]     } [EOL] } [EOL]
@Test [EOL]     public void testAbove() { [EOL]         final UnicodeEscaper ue = UnicodeEscaper.above('F'); [EOL]  [EOL]         final String input = "ADFGZ"; [EOL]         final String result = ue.translate(input); [EOL]         assertEquals("Failed to escape Unicode characters via the above method", "ADF\\u0047\\u005A", result); [EOL]     } [EOL] } [EOL]
@Test [EOL]     public void testAbove() { [EOL]         final UnicodeEscaper ue = UnicodeEscaper.above('F'); [EOL]  [EOL]         final String input = "ADFGZ"; [EOL]         final String result = ue.translate(input); [EOL]         assertEquals("Failed to escape Unicode characters via the above method", "ADF\\u0047\\u005A", result); [EOL]     } [EOL] } [EOL]
@Test [EOL]     public void testAbove() { [EOL]         final UnicodeEscaper ue = UnicodeEscaper.above('F'); [EOL]  [EOL]         final String input = "ADFGZ"; [EOL]         final String result = ue.translate(input); [EOL]         assertEquals("Failed to escape Unicode characters via the above method", "ADF\\u0047\\u005A", result); [EOL]     } [EOL] } [EOL]
@Test [EOL]     public void testAbove() { [EOL]         final UnicodeEscaper ue = UnicodeEscaper.above('F'); [EOL]  [EOL]         final String input = "ADFGZ"; [EOL]         final String result = ue.translate(input); [EOL]         assertEquals("Failed to escape Unicode characters via the above method", "ADF\\u0047\\u005A", result); [EOL]     } [EOL] } [EOL]
@Test [EOL]     public void testAbove() { [EOL]         final UnicodeEscaper ue = UnicodeEscaper.above('F'); [EOL]  [EOL]         final String input = "ADFGZ"; [EOL]         final String result = ue.translate(input); [EOL]         assertEquals("Failed to escape Unicode characters via the above method", "ADF\\u0047\\u005A", result); [EOL]     } [EOL] } [EOL]
@Test [EOL]     public void testAbove() { [EOL]         final UnicodeEscaper ue = UnicodeEscaper.above('F'); [EOL]  [EOL]         final String input = "ADFGZ"; [EOL]         final String result = ue.translate(input); [EOL]         assertEquals("Failed to escape Unicode characters via the above method", "ADF\\u0047\\u005A", result); [EOL]     } [EOL] } [EOL]
@Test [EOL]     public void testAbove() { [EOL]         final UnicodeEscaper ue = UnicodeEscaper.above('F'); [EOL]  [EOL]         final String input = "ADFGZ"; [EOL]         final String result = ue.translate(input); [EOL]         assertEquals("Failed to escape Unicode characters via the above method", "ADF\\u0047\\u005A", result); [EOL]     } [EOL] } [EOL]
@Test [EOL]     public void testAbove() { [EOL]         final UnicodeEscaper ue = UnicodeEscaper.above('F'); [EOL]  [EOL]         final String input = "ADFGZ"; [EOL]         final String result = ue.translate(input); [EOL]         assertEquals("Failed to escape Unicode characters via the above method", "ADF\\u0047\\u005A", result); [EOL]     } [EOL] } [EOL]
@Test [EOL]     public void testLang381() { [EOL]         assertEquals(1.2, IEEE754rUtils.min(1.2, 2.5, Double.NaN), 0.01); [EOL]         assertEquals(2.5, IEEE754rUtils.max(1.2, 2.5, Double.NaN), 0.01); [EOL]         assertTrue(Double.isNaN(IEEE754rUtils.max(Double.NaN, Double.NaN, Double.NaN))); [EOL]         assertEquals(1.2f, IEEE754rUtils.min(1.2f, 2.5f, Float.NaN), 0.01); [EOL]         assertEquals(2.5f, IEEE754rUtils.max(1.2f, 2.5f, Float.NaN), 0.01); [EOL]         assertTrue(Float.isNaN(IEEE754rUtils.max(Float.NaN, Float.NaN, Float.NaN))); [EOL]  [EOL]         final double[] a = new double[] { 1.2, Double.NaN, 3.7, 27.0, 42.0, Double.NaN }; [EOL]         assertEquals(42.0, IEEE754rUtils.max(a), 0.01); [EOL]         assertEquals(1.2, IEEE754rUtils.min(a), 0.01); [EOL]  [EOL]         final double[] b = new double[] { Double.NaN, 1.2, Double.NaN, 3.7, 27.0, 42.0, Double.NaN }; [EOL]         assertEquals(42.0, IEEE754rUtils
@Test [EOL]     public void testLang381() { [EOL]         assertEquals(1.2, IEEE754rUtils.min(1.2, 2.5, Double.NaN), 0.01); [EOL]         assertEquals(2.5, IEEE754rUtils.max(1.2, 2.5, Double.NaN), 0.01); [EOL]         assertTrue(Double.isNaN(IEEE754rUtils.max(Double.NaN, Double.NaN, Double.NaN))); [EOL]         assertEquals(1.2f, IEEE754rUtils.min(1.2f, 2.5f, Float.NaN), 0.01); [EOL]         assertEquals(2.5f, IEEE754rUtils.max(1.2f, 2.5f, Float.NaN), 0.01); [EOL]         assertTrue(Float.isNaN(IEEE754rUtils.max(Float.NaN, Float.NaN, Float.NaN))); [EOL]  [EOL]         final double[] a = new double[] { 1.2, Double.NaN, 3.7, 27.0, 42.0, Double.NaN }; [EOL]         assertEquals(42.0, IEEE754rUtils.max(a), 0.01); [EOL]         assertEquals(1.2, IEEE754rUtils.min(a), 0.01); [EOL]  [EOL]         final double[] b = new double[] { Double.NaN, 1.2, Double.NaN, 3.7, 27.0, 42.0, Double.NaN }; [EOL]         assertEquals(42.0, IEEE754rUtils
@Test [EOL]     public void testLang381() { [EOL]         assertEquals(1.2, IEEE754rUtils.min(1.2, 2.5, Double.NaN), 0.01); [EOL]         assertEquals(2.5, IEEE754rUtils.max(1.2, 2.5, Double.NaN), 0.01); [EOL]         assertTrue(Double.isNaN(IEEE754rUtils.max(Double.NaN, Double.NaN, Double.NaN))); [EOL]         assertEquals(1.2f, IEEE754rUtils.min(1.2f, 2.5f, Float.NaN), 0.01); [EOL]         assertEquals(2.5f, IEEE754rUtils.max(1.2f, 2.5f, Float.NaN), 0.01); [EOL]         assertTrue(Float.isNaN(IEEE754rUtils.max(Float.NaN, Float.NaN, Float.NaN))); [EOL]  [EOL]         final double[] a = new double[] { 1.2, Double.NaN, 3.7, 27.0, 42.0, Double.NaN }; [EOL]         assertEquals(42.0, IEEE754rUtils.max(a), 0.01); [EOL]         assertEquals(1.2, IEEE754rUtils.min(a), 0.01); [EOL]  [EOL]         final double[] b = new double[] { Double.NaN, 1.2, Double.NaN, 3.7, 27.0, 42.0, Double.NaN }; [EOL]         assertEquals(42.0, IEEE754rUtils
@Test [EOL]     public void testLang381() { [EOL]         assertEquals(1.2, IEEE754rUtils.min(1.2, 2.5, Double.NaN), 0.01); [EOL]         assertEquals(2.5, IEEE754rUtils.max(1.2, 2.5, Double.NaN), 0.01); [EOL]         assertTrue(Double.isNaN(IEEE754rUtils.max(Double.NaN, Double.NaN, Double.NaN))); [EOL]         assertEquals(1.2f, IEEE754rUtils.min(1.2f, 2.5f, Float.NaN), 0.01); [EOL]         assertEquals(2.5f, IEEE754rUtils.max(1.2f, 2.5f, Float.NaN), 0.01); [EOL]         assertTrue(Float.isNaN(IEEE754rUtils.max(Float.NaN, Float.NaN, Float.NaN))); [EOL]  [EOL]         final double[] a = new double[] { 1.2, Double.NaN, 3.7, 27.0, 42.0, Double.NaN }; [EOL]         assertEquals(42.0, IEEE754rUtils.max(a), 0.01); [EOL]         assertEquals(1.2, IEEE754rUtils.min(a), 0.01); [EOL]  [EOL]         final double[] b = new double[] { Double.NaN, 1.2, Double.NaN, 3.7, 27.0, 42.0, Double.NaN }; [EOL]         assertEquals(42.0, IEEE754rUtils
@Test [EOL]     public void testLang381() { [EOL]         assertEquals(1.2, IEEE754rUtils.min(1.2, 2.5, Double.NaN), 0.01); [EOL]         assertEquals(2.5, IEEE754rUtils.max(1.2, 2.5, Double.NaN), 0.01); [EOL]         assertTrue(Double.isNaN(IEEE754rUtils.max(Double.NaN, Double.NaN, Double.NaN))); [EOL]         assertEquals(1.2f, IEEE754rUtils.min(1.2f, 2.5f, Float.NaN), 0.01); [EOL]         assertEquals(2.5f, IEEE754rUtils.max(1.2f, 2.5f, Float.NaN), 0.01); [EOL]         assertTrue(Float.isNaN(IEEE754rUtils.max(Float.NaN, Float.NaN, Float.NaN))); [EOL]  [EOL]         final double[] a = new double[] { 1.2, Double.NaN, 3.7, 27.0, 42.0, Double.NaN }; [EOL]         assertEquals(42.0, IEEE754rUtils.max(a), 0.01); [EOL]         assertEquals(1.2, IEEE754rUtils.min(a), 0.01); [EOL]  [EOL]         final double[] b = new double[] { Double.NaN, 1.2, Double.NaN, 3.7, 27.0, 42.0, Double.NaN }; [EOL]         assertEquals(42.0, IEEE754rUtils
@Test [EOL]     public void testLang381() { [EOL]         assertEquals(1.2, IEEE754rUtils.min(1.2, 2.5, Double.NaN), 0.01); [EOL]         assertEquals(2.5, IEEE754rUtils.max(1.2, 2.5, Double.NaN), 0.01); [EOL]         assertTrue(Double.isNaN(IEEE754rUtils.max(Double.NaN, Double.NaN, Double.NaN))); [EOL]         assertEquals(1.2f, IEEE754rUtils.min(1.2f, 2.5f, Float.NaN), 0.01); [EOL]         assertEquals(2.5f, IEEE754rUtils.max(1.2f, 2.5f, Float.NaN), 0.01); [EOL]         assertTrue(Float.isNaN(IEEE754rUtils.max(Float.NaN, Float.NaN, Float.NaN))); [EOL]  [EOL]         final double[] a = new double[] { 1.2, Double.NaN, 3.7, 27.0, 42.0, Double.NaN }; [EOL]         assertEquals(42.0, IEEE754rUtils.max(a), 0.01); [EOL]         assertEquals(1.2, IEEE754rUtils.min(a), 0.01); [EOL]  [EOL]         final double[] b = new double[] { Double.NaN, 1.2, Double.NaN, 3.7, 27.0, 42.0, Double.NaN }; [EOL]         assertEquals(42.0, IEEE754rUtils
@Test [EOL]     public void testLang381() { [EOL]         assertEquals(1.2, IEEE754rUtils.min(1.2, 2.5, Double.NaN), 0.01); [EOL]         assertEquals(2.5, IEEE754rUtils.max(1.2, 2.5, Double.NaN), 0.01); [EOL]         assertTrue(Double.isNaN(IEEE754rUtils.max(Double.NaN, Double.NaN, Double.NaN))); [EOL]         assertEquals(1.2f, IEEE754rUtils.min(1.2f, 2.5f, Float.NaN), 0.01); [EOL]         assertEquals(2.5f, IEEE754rUtils.max(1.2f, 2.5f, Float.NaN), 0.01); [EOL]         assertTrue(Float.isNaN(IEEE754rUtils.max(Float.NaN, Float.NaN, Float.NaN))); [EOL]  [EOL]         final double[] a = new double[] { 1.2, Double.NaN, 3.7, 27.0, 42.0, Double.NaN }; [EOL]         assertEquals(42.0, IEEE754rUtils.max(a), 0.01); [EOL]         assertEquals(1.2, IEEE754rUtils.min(a), 0.01); [EOL]  [EOL]         final double[] b = new double[] { Double.NaN, 1.2, Double.NaN, 3.7, 27.0, 42.0, Double.NaN }; [EOL]         assertEquals(42.0, IEEE754rUtils
@Test [EOL]     public void testLang381() { [EOL]         assertEquals(1.2, IEEE754rUtils.min(1.2, 2.5, Double.NaN), 0.01); [EOL]         assertEquals(2.5, IEEE754rUtils.max(1.2, 2.5, Double.NaN), 0.01); [EOL]         assertTrue(Double.isNaN(IEEE754rUtils.max(Double.NaN, Double.NaN, Double.NaN))); [EOL]         assertEquals(1.2f, IEEE754rUtils.min(1.2f, 2.5f, Float.NaN), 0.01); [EOL]         assertEquals(2.5f, IEEE754rUtils.max(1.2f, 2.5f, Float.NaN), 0.01); [EOL]         assertTrue(Float.isNaN(IEEE754rUtils.max(Float.NaN, Float.NaN, Float.NaN))); [EOL]  [EOL]         final double[] a = new double[] { 1.2, Double.NaN, 3.7, 27.0, 42.0, Double.NaN }; [EOL]         assertEquals(42.0, IEEE754rUtils.max(a), 0.01); [EOL]         assertEquals(1.2, IEEE754rUtils.min(a), 0.01); [EOL]  [EOL]         final double[] b = new double[] { Double.NaN, 1.2, Double.NaN, 3.7, 27.0, 42.0, Double.NaN }; [EOL]         assertEquals(42.0, IEEE754rUtils
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessage
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessage
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessage
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessage
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessage
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessage
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessage
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessage
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessage
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessage
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessage
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessage
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessage
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessage
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessage
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessage
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessage
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessage
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessage
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessage
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessage
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessage
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessage
@Test [EOL]     public void testExtendedAndBuiltInFormats() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23, 18, 33, 05); [EOL]         final Object[] args = new Object[] {"John Doe", cal.getTime(), Double.valueOf("12345.67")}; [EOL]         final String builtinsPattern = "DOB: {1,date,short} Salary: {2,number,currency}"; [EOL]         final String extendedPattern = "Name: {0,upper} "; [EOL]         final String pattern = extendedPattern + builtinsPattern; [EOL]  [EOL]         final HashSet<Locale> testLocales = new HashSet<Locale>(); [EOL]         testLocales.addAll(Arrays.asList(DateFormat.getAvailableLocales())); [EOL]         testLocales.retainAll(Arrays.asList(NumberFormat.getAvailableLocales())); [EOL]         testLocales.add(null); [EOL]  [EOL]         for (final Locale locale : testLocales) { [EOL]             final MessageFormat builtins = createMessageFormat(builtinsPattern, locale); [EOL]             final String expectedPattern = extendedPattern + builtins.toPattern(); [EOL]             DateFormat df = null; [EOL]             NumberFormat nf = null; [EOL]             ExtendedMessageFormat emf = null; [EOL]    
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessage
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessage
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessage
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessage
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessage
@Test [EOL]     public void testExtendedAndBuiltInFormats() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23, 18, 33, 05); [EOL]         final Object[] args = new Object[] {"John Doe", cal.getTime(), Double.valueOf("12345.67")}; [EOL]         final String builtinsPattern = "DOB: {1,date,short} Salary: {2,number,currency}"; [EOL]         final String extendedPattern = "Name: {0,upper} "; [EOL]         final String pattern = extendedPattern + builtinsPattern; [EOL]  [EOL]         final HashSet<Locale> testLocales = new HashSet<Locale>(); [EOL]         testLocales.addAll(Arrays.asList(DateFormat.getAvailableLocales())); [EOL]         testLocales.retainAll(Arrays.asList(NumberFormat.getAvailableLocales())); [EOL]         testLocales.add(null); [EOL]  [EOL]         for (final Locale locale : testLocales) { [EOL]             final MessageFormat builtins = createMessageFormat(builtinsPattern, locale); [EOL]             final String expectedPattern = extendedPattern + builtins.toPattern(); [EOL]             DateFormat df = null; [EOL]             NumberFormat nf = null; [EOL]             ExtendedMessageFormat emf = null; [EOL]    
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessage
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessage
@Test [EOL]     public void testExtendedAndBuiltInFormats() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23, 18, 33, 05); [EOL]         final Object[] args = new Object[] {"John Doe", cal.getTime(), Double.valueOf("12345.67")}; [EOL]         final String builtinsPattern = "DOB: {1,date,short} Salary: {2,number,currency}"; [EOL]         final String extendedPattern = "Name: {0,upper} "; [EOL]         final String pattern = extendedPattern + builtinsPattern; [EOL]  [EOL]         final HashSet<Locale> testLocales = new HashSet<Locale>(); [EOL]         testLocales.addAll(Arrays.asList(DateFormat.getAvailableLocales())); [EOL]         testLocales.retainAll(Arrays.asList(NumberFormat.getAvailableLocales())); [EOL]         testLocales.add(null); [EOL]  [EOL]         for (final Locale locale : testLocales) { [EOL]             final MessageFormat builtins = createMessageFormat(builtinsPattern, locale); [EOL]             final String expectedPattern = extendedPattern + builtins.toPattern(); [EOL]             DateFormat df = null; [EOL]             NumberFormat nf = null; [EOL]             ExtendedMessageFormat emf = null; [EOL]    
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessage
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessage
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessage
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessage
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessage
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessage
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessage
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessage
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessage
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessage
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessage
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessage
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessage
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessage
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessage
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessage
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessage
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessage
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessage
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessage
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessage
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessage
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessage
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessage
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessage
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessage
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessage
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessage
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessage
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessage
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessage
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessage
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessage
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessage
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessage
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessage
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessage
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessage
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessage
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessage
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessage
@Test [EOL]     public void test_getShortClassName_String() { [EOL]         assertEquals("ClassUtils", ClassUtils.getShortClassName(ClassUtils.class.getName())); [EOL]         assertEquals("Map.Entry", ClassUtils.getShortClassName(Map.Entry.class.getName())); [EOL]         assertEquals("", ClassUtils.getShortClassName((String) null)); [EOL]         assertEquals("", ClassUtils.getShortClassName("")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void test_getShortClassName_String() { [EOL]         assertEquals("ClassUtils", ClassUtils.getShortClassName(ClassUtils.class.getName())); [EOL]         assertEquals("Map.Entry", ClassUtils.getShortClassName(Map.Entry.class.getName())); [EOL]         assertEquals("", ClassUtils.getShortClassName((String) null)); [EOL]         assertEquals("", ClassUtils.getShortClassName("")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void test_getSimpleName_Object() { [EOL]         assertEquals("ClassUtils", ClassUtils.getSimpleName(new ClassUtils(), "<null>")); [EOL]         assertEquals("Inner", ClassUtils.getSimpleName(new Inner(), "<null>")); [EOL]         assertEquals("String", ClassUtils.getSimpleName("hello", "<null>")); [EOL]         assertEquals("<null>", ClassUtils.getSimpleName(null, "<null>")); [EOL]     } [EOL]  [EOL]     // ------------------------------------------------------------------------- [EOL]
@Test [EOL]     public void test_getPackageName_Class() { [EOL]         assertEquals("java.lang", ClassUtils.getPackageName(String.class)); [EOL]         assertEquals("java.util", ClassUtils.getPackageName(Map.Entry.class)); [EOL]         assertEquals("", ClassUtils.getPackageName((Class<?>)null)); [EOL]  [EOL]         // LANG-535 [EOL]         assertEquals("java.lang", ClassUtils.getPackageName(String[].class)); [EOL]  [EOL]         // Primitive Arrays [EOL]         assertEquals("", ClassUtils.getPackageName(boolean[].class)); [EOL]         assertEquals("", ClassUtils.getPackageName(byte[].class)); [EOL]         assertEquals("", ClassUtils.getPackageName(char[].class)); [EOL]         assertEquals("", ClassUtils.getPackageName(short[].class)); [EOL]         assertEquals("", ClassUtils.getPackageName(int[].class)); [EOL]         assertEquals("", ClassUtils.getPackageName(long[].class)); [EOL]         assertEquals("", ClassUtils.getPackageName(float[].class)); [EOL]         assertEquals("", ClassUtils.getPackageName(double[].class)); [EOL]  [EOL]         // Arrays of arrays of ... [EOL]         assertEquals("java.lang", ClassUtils.getPackageName(String[][].class)); [EOL] 
@Test [EOL]     public void test_getPackageName_Class() { [EOL]         assertEquals("java.lang", ClassUtils.getPackageName(String.class)); [EOL]         assertEquals("java.util", ClassUtils.getPackageName(Map.Entry.class)); [EOL]         assertEquals("", ClassUtils.getPackageName((Class<?>)null)); [EOL]  [EOL]         // LANG-535 [EOL]         assertEquals("java.lang", ClassUtils.getPackageName(String[].class)); [EOL]  [EOL]         // Primitive Arrays [EOL]         assertEquals("", ClassUtils.getPackageName(boolean[].class)); [EOL]         assertEquals("", ClassUtils.getPackageName(byte[].class)); [EOL]         assertEquals("", ClassUtils.getPackageName(char[].class)); [EOL]         assertEquals("", ClassUtils.getPackageName(short[].class)); [EOL]         assertEquals("", ClassUtils.getPackageName(int[].class)); [EOL]         assertEquals("", ClassUtils.getPackageName(long[].class)); [EOL]         assertEquals("", ClassUtils.getPackageName(float[].class)); [EOL]         assertEquals("", ClassUtils.getPackageName(double[].class)); [EOL]  [EOL]         // Arrays of arrays of ... [EOL]         assertEquals("java.lang", ClassUtils.getPackageName(String[][].class)); [EOL] 
@Test [EOL]     public void test_convertClassesToClassNames_List() { [EOL]         final List<Class<?>> list = new ArrayList<Class<?>>(); [EOL]         List<String> result = ClassUtils.convertClassesToClassNames(list); [EOL]         assertEquals(0, result.size()); [EOL]  [EOL]         list.add(String.class); [EOL]         list.add(null); [EOL]         list.add(Object.class); [EOL]         result = ClassUtils.convertClassesToClassNames(list); [EOL]         assertEquals(3, result.size()); [EOL]         assertEquals("java.lang.String", result.get(0)); [EOL]         assertEquals(null, result.get(1)); [EOL]         assertEquals("java.lang.Object", result.get(2)); [EOL]  [EOL]         @SuppressWarnings("unchecked") // test what happens when non-generic code adds wrong type of element [EOL]         final [EOL]         List<Object> olist = (List<Object>)(List<?>)list; [EOL]         olist.add(new Object()); [EOL]         try { [EOL]             ClassUtils.convertClassesToClassNames(list); [EOL]             fail("Should not have been able to convert list"); [EOL]         } catch (final ClassCastException expected) {} [
@Test [EOL]     public void test_isAssignable_DefaultUnboxing_Widening() throws Exception { [EOL]         final boolean autoboxing = SystemUtils.isJavaVersionAtLeast(JAVA_1_5); [EOL]  [EOL]         // test byte conversions [EOL]         assertFalse("byte -> char", ClassUtils.isAssignable(Byte.class, Character.TYPE)); [EOL]         assertEquals("byte -> byte", autoboxing, ClassUtils.isAssignable(Byte.class, Byte.TYPE)); [EOL]         assertEquals("byte -> short", autoboxing, ClassUtils.isAssignable(Byte.class, Short.TYPE)); [EOL]         assertEquals("byte -> int", autoboxing, ClassUtils.isAssignable(Byte.class, Integer.TYPE)); [EOL]         assertEquals("byte -> long", autoboxing, ClassUtils.isAssignable(Byte.class, Long.TYPE)); [EOL]         assertEquals("byte -> float", autoboxing, ClassUtils.isAssignable(Byte.class, Float.TYPE)); [EOL]         assertEquals("byte -> double", autoboxing, ClassUtils.isAssignable(Byte.class, Double.TYPE)); [EOL]         assertFalse("byte -> boolean", ClassUtils.isAssignable(Byte.class, Boolean.TYPE)); [EOL]  [EOL]         // test short conversions [EOL]         assertFalse("short -> char", ClassUtils.isAssignable(Short.class, Character.TYPE)); [EOL]         assertFalse("short -> byte", ClassUtils.isAssignable(
@Test [EOL]     public void test_isAssignable_DefaultUnboxing_Widening() throws Exception { [EOL]         final boolean autoboxing = SystemUtils.isJavaVersionAtLeast(JAVA_1_5); [EOL]  [EOL]         // test byte conversions [EOL]         assertFalse("byte -> char", ClassUtils.isAssignable(Byte.class, Character.TYPE)); [EOL]         assertEquals("byte -> byte", autoboxing, ClassUtils.isAssignable(Byte.class, Byte.TYPE)); [EOL]         assertEquals("byte -> short", autoboxing, ClassUtils.isAssignable(Byte.class, Short.TYPE)); [EOL]         assertEquals("byte -> int", autoboxing, ClassUtils.isAssignable(Byte.class, Integer.TYPE)); [EOL]         assertEquals("byte -> long", autoboxing, ClassUtils.isAssignable(Byte.class, Long.TYPE)); [EOL]         assertEquals("byte -> float", autoboxing, ClassUtils.isAssignable(Byte.class, Float.TYPE)); [EOL]         assertEquals("byte -> double", autoboxing, ClassUtils.isAssignable(Byte.class, Double.TYPE)); [EOL]         assertFalse("byte -> boolean", ClassUtils.isAssignable(Byte.class, Boolean.TYPE)); [EOL]  [EOL]         // test short conversions [EOL]         assertFalse("short -> char", ClassUtils.isAssignable(Short.class, Character.TYPE)); [EOL]         assertFalse("short -> byte", ClassUtils.isAssignable(
@Test [EOL]     public void test_isAssignable_DefaultUnboxing_Widening() throws Exception { [EOL]         final boolean autoboxing = SystemUtils.isJavaVersionAtLeast(JAVA_1_5); [EOL]  [EOL]         // test byte conversions [EOL]         assertFalse("byte -> char", ClassUtils.isAssignable(Byte.class, Character.TYPE)); [EOL]         assertEquals("byte -> byte", autoboxing, ClassUtils.isAssignable(Byte.class, Byte.TYPE)); [EOL]         assertEquals("byte -> short", autoboxing, ClassUtils.isAssignable(Byte.class, Short.TYPE)); [EOL]         assertEquals("byte -> int", autoboxing, ClassUtils.isAssignable(Byte.class, Integer.TYPE)); [EOL]         assertEquals("byte -> long", autoboxing, ClassUtils.isAssignable(Byte.class, Long.TYPE)); [EOL]         assertEquals("byte -> float", autoboxing, ClassUtils.isAssignable(Byte.class, Float.TYPE)); [EOL]         assertEquals("byte -> double", autoboxing, ClassUtils.isAssignable(Byte.class, Double.TYPE)); [EOL]         assertFalse("byte -> boolean", ClassUtils.isAssignable(Byte.class, Boolean.TYPE)); [EOL]  [EOL]         // test short conversions [EOL]         assertFalse("short -> char", ClassUtils.isAssignable(Short.class, Character.TYPE)); [EOL]         assertFalse("short -> byte", ClassUtils.isAssignable(
@Test [EOL]     public void test_isAssignable_DefaultUnboxing_Widening() throws Exception { [EOL]         final boolean autoboxing = SystemUtils.isJavaVersionAtLeast(JAVA_1_5); [EOL]  [EOL]         // test byte conversions [EOL]         assertFalse("byte -> char", ClassUtils.isAssignable(Byte.class, Character.TYPE)); [EOL]         assertEquals("byte -> byte", autoboxing, ClassUtils.isAssignable(Byte.class, Byte.TYPE)); [EOL]         assertEquals("byte -> short", autoboxing, ClassUtils.isAssignable(Byte.class, Short.TYPE)); [EOL]         assertEquals("byte -> int", autoboxing, ClassUtils.isAssignable(Byte.class, Integer.TYPE)); [EOL]         assertEquals("byte -> long", autoboxing, ClassUtils.isAssignable(Byte.class, Long.TYPE)); [EOL]         assertEquals("byte -> float", autoboxing, ClassUtils.isAssignable(Byte.class, Float.TYPE)); [EOL]         assertEquals("byte -> double", autoboxing, ClassUtils.isAssignable(Byte.class, Double.TYPE)); [EOL]         assertFalse("byte -> boolean", ClassUtils.isAssignable(Byte.class, Boolean.TYPE)); [EOL]  [EOL]         // test short conversions [EOL]         assertFalse("short -> char", ClassUtils.isAssignable(Short.class, Character.TYPE)); [EOL]         assertFalse("short -> byte", ClassUtils.isAssignable(
@Test [EOL]     public void test_isAssignable_DefaultUnboxing_Widening() throws Exception { [EOL]         final boolean autoboxing = SystemUtils.isJavaVersionAtLeast(JAVA_1_5); [EOL]  [EOL]         // test byte conversions [EOL]         assertFalse("byte -> char", ClassUtils.isAssignable(Byte.class, Character.TYPE)); [EOL]         assertEquals("byte -> byte", autoboxing, ClassUtils.isAssignable(Byte.class, Byte.TYPE)); [EOL]         assertEquals("byte -> short", autoboxing, ClassUtils.isAssignable(Byte.class, Short.TYPE)); [EOL]         assertEquals("byte -> int", autoboxing, ClassUtils.isAssignable(Byte.class, Integer.TYPE)); [EOL]         assertEquals("byte -> long", autoboxing, ClassUtils.isAssignable(Byte.class, Long.TYPE)); [EOL]         assertEquals("byte -> float", autoboxing, ClassUtils.isAssignable(Byte.class, Float.TYPE)); [EOL]         assertEquals("byte -> double", autoboxing, ClassUtils.isAssignable(Byte.class, Double.TYPE)); [EOL]         assertFalse("byte -> boolean", ClassUtils.isAssignable(Byte.class, Boolean.TYPE)); [EOL]  [EOL]         // test short conversions [EOL]         assertFalse("short -> char", ClassUtils.isAssignable(Short.class, Character.TYPE)); [EOL]         assertFalse("short -> byte", ClassUtils.isAssignable(
@Test [EOL]     public void test_isAssignable_DefaultUnboxing_Widening() throws Exception { [EOL]         final boolean autoboxing = SystemUtils.isJavaVersionAtLeast(JAVA_1_5); [EOL]  [EOL]         // test byte conversions [EOL]         assertFalse("byte -> char", ClassUtils.isAssignable(Byte.class, Character.TYPE)); [EOL]         assertEquals("byte -> byte", autoboxing, ClassUtils.isAssignable(Byte.class, Byte.TYPE)); [EOL]         assertEquals("byte -> short", autoboxing, ClassUtils.isAssignable(Byte.class, Short.TYPE)); [EOL]         assertEquals("byte -> int", autoboxing, ClassUtils.isAssignable(Byte.class, Integer.TYPE)); [EOL]         assertEquals("byte -> long", autoboxing, ClassUtils.isAssignable(Byte.class, Long.TYPE)); [EOL]         assertEquals("byte -> float", autoboxing, ClassUtils.isAssignable(Byte.class, Float.TYPE)); [EOL]         assertEquals("byte -> double", autoboxing, ClassUtils.isAssignable(Byte.class, Double.TYPE)); [EOL]         assertFalse("byte -> boolean", ClassUtils.isAssignable(Byte.class, Boolean.TYPE)); [EOL]  [EOL]         // test short conversions [EOL]         assertFalse("short -> char", ClassUtils.isAssignable(Short.class, Character.TYPE)); [EOL]         assertFalse("short -> byte", ClassUtils.isAssignable(
@Test [EOL]     public void test_isAssignable_DefaultUnboxing_Widening() throws Exception { [EOL]         final boolean autoboxing = SystemUtils.isJavaVersionAtLeast(JAVA_1_5); [EOL]  [EOL]         // test byte conversions [EOL]         assertFalse("byte -> char", ClassUtils.isAssignable(Byte.class, Character.TYPE)); [EOL]         assertEquals("byte -> byte", autoboxing, ClassUtils.isAssignable(Byte.class, Byte.TYPE)); [EOL]         assertEquals("byte -> short", autoboxing, ClassUtils.isAssignable(Byte.class, Short.TYPE)); [EOL]         assertEquals("byte -> int", autoboxing, ClassUtils.isAssignable(Byte.class, Integer.TYPE)); [EOL]         assertEquals("byte -> long", autoboxing, ClassUtils.isAssignable(Byte.class, Long.TYPE)); [EOL]         assertEquals("byte -> float", autoboxing, ClassUtils.isAssignable(Byte.class, Float.TYPE)); [EOL]         assertEquals("byte -> double", autoboxing, ClassUtils.isAssignable(Byte.class, Double.TYPE)); [EOL]         assertFalse("byte -> boolean", ClassUtils.isAssignable(Byte.class, Boolean.TYPE)); [EOL]  [EOL]         // test short conversions [EOL]         assertFalse("short -> char", ClassUtils.isAssignable(Short.class, Character.TYPE)); [EOL]         assertFalse("short -> byte", ClassUtils.isAssignable(
@Test [EOL]     public void test_isAssignable_DefaultUnboxing_Widening() throws Exception { [EOL]         final boolean autoboxing = SystemUtils.isJavaVersionAtLeast(JAVA_1_5); [EOL]  [EOL]         // test byte conversions [EOL]         assertFalse("byte -> char", ClassUtils.isAssignable(Byte.class, Character.TYPE)); [EOL]         assertEquals("byte -> byte", autoboxing, ClassUtils.isAssignable(Byte.class, Byte.TYPE)); [EOL]         assertEquals("byte -> short", autoboxing, ClassUtils.isAssignable(Byte.class, Short.TYPE)); [EOL]         assertEquals("byte -> int", autoboxing, ClassUtils.isAssignable(Byte.class, Integer.TYPE)); [EOL]         assertEquals("byte -> long", autoboxing, ClassUtils.isAssignable(Byte.class, Long.TYPE)); [EOL]         assertEquals("byte -> float", autoboxing, ClassUtils.isAssignable(Byte.class, Float.TYPE)); [EOL]         assertEquals("byte -> double", autoboxing, ClassUtils.isAssignable(Byte.class, Double.TYPE)); [EOL]         assertFalse("byte -> boolean", ClassUtils.isAssignable(Byte.class, Boolean.TYPE)); [EOL]  [EOL]         // test short conversions [EOL]         assertFalse("short -> char", ClassUtils.isAssignable(Short.class, Character.TYPE)); [EOL]         assertFalse("short -> byte", ClassUtils.isAssignable(
@Test [EOL]     public void test_isAssignable_DefaultUnboxing_Widening() throws Exception { [EOL]         final boolean autoboxing = SystemUtils.isJavaVersionAtLeast(JAVA_1_5); [EOL]  [EOL]         // test byte conversions [EOL]         assertFalse("byte -> char", ClassUtils.isAssignable(Byte.class, Character.TYPE)); [EOL]         assertEquals("byte -> byte", autoboxing, ClassUtils.isAssignable(Byte.class, Byte.TYPE)); [EOL]         assertEquals("byte -> short", autoboxing, ClassUtils.isAssignable(Byte.class, Short.TYPE)); [EOL]         assertEquals("byte -> int", autoboxing, ClassUtils.isAssignable(Byte.class, Integer.TYPE)); [EOL]         assertEquals("byte -> long", autoboxing, ClassUtils.isAssignable(Byte.class, Long.TYPE)); [EOL]         assertEquals("byte -> float", autoboxing, ClassUtils.isAssignable(Byte.class, Float.TYPE)); [EOL]         assertEquals("byte -> double", autoboxing, ClassUtils.isAssignable(Byte.class, Double.TYPE)); [EOL]         assertFalse("byte -> boolean", ClassUtils.isAssignable(Byte.class, Boolean.TYPE)); [EOL]  [EOL]         // test short conversions [EOL]         assertFalse("short -> char", ClassUtils.isAssignable(Short.class, Character.TYPE)); [EOL]         assertFalse("short -> byte", ClassUtils.isAssignable(
@Test [EOL]     public void test_isAssignable_DefaultUnboxing_Widening() throws Exception { [EOL]         final boolean autoboxing = SystemUtils.isJavaVersionAtLeast(JAVA_1_5); [EOL]  [EOL]         // test byte conversions [EOL]         assertFalse("byte -> char", ClassUtils.isAssignable(Byte.class, Character.TYPE)); [EOL]         assertEquals("byte -> byte", autoboxing, ClassUtils.isAssignable(Byte.class, Byte.TYPE)); [EOL]         assertEquals("byte -> short", autoboxing, ClassUtils.isAssignable(Byte.class, Short.TYPE)); [EOL]         assertEquals("byte -> int", autoboxing, ClassUtils.isAssignable(Byte.class, Integer.TYPE)); [EOL]         assertEquals("byte -> long", autoboxing, ClassUtils.isAssignable(Byte.class, Long.TYPE)); [EOL]         assertEquals("byte -> float", autoboxing, ClassUtils.isAssignable(Byte.class, Float.TYPE)); [EOL]         assertEquals("byte -> double", autoboxing, ClassUtils.isAssignable(Byte.class, Double.TYPE)); [EOL]         assertFalse("byte -> boolean", ClassUtils.isAssignable(Byte.class, Boolean.TYPE)); [EOL]  [EOL]         // test short conversions [EOL]         assertFalse("short -> char", ClassUtils.isAssignable(Short.class, Character.TYPE)); [EOL]         assertFalse("short -> byte", ClassUtils.isAssignable(
@Test [EOL]     public void test_isAssignable_DefaultUnboxing_Widening() throws Exception { [EOL]         final boolean autoboxing = SystemUtils.isJavaVersionAtLeast(JAVA_1_5); [EOL]  [EOL]         // test byte conversions [EOL]         assertFalse("byte -> char", ClassUtils.isAssignable(Byte.class, Character.TYPE)); [EOL]         assertEquals("byte -> byte", autoboxing, ClassUtils.isAssignable(Byte.class, Byte.TYPE)); [EOL]         assertEquals("byte -> short", autoboxing, ClassUtils.isAssignable(Byte.class, Short.TYPE)); [EOL]         assertEquals("byte -> int", autoboxing, ClassUtils.isAssignable(Byte.class, Integer.TYPE)); [EOL]         assertEquals("byte -> long", autoboxing, ClassUtils.isAssignable(Byte.class, Long.TYPE)); [EOL]         assertEquals("byte -> float", autoboxing, ClassUtils.isAssignable(Byte.class, Float.TYPE)); [EOL]         assertEquals("byte -> double", autoboxing, ClassUtils.isAssignable(Byte.class, Double.TYPE)); [EOL]         assertFalse("byte -> boolean", ClassUtils.isAssignable(Byte.class, Boolean.TYPE)); [EOL]  [EOL]         // test short conversions [EOL]         assertFalse("short -> char", ClassUtils.isAssignable(Short.class, Character.TYPE)); [EOL]         assertFalse("short -> byte", ClassUtils.isAssignable(
@Test [EOL]     public void test_isAssignable_DefaultUnboxing_Widening() throws Exception { [EOL]         final boolean autoboxing = SystemUtils.isJavaVersionAtLeast(JAVA_1_5); [EOL]  [EOL]         // test byte conversions [EOL]         assertFalse("byte -> char", ClassUtils.isAssignable(Byte.class, Character.TYPE)); [EOL]         assertEquals("byte -> byte", autoboxing, ClassUtils.isAssignable(Byte.class, Byte.TYPE)); [EOL]         assertEquals("byte -> short", autoboxing, ClassUtils.isAssignable(Byte.class, Short.TYPE)); [EOL]         assertEquals("byte -> int", autoboxing, ClassUtils.isAssignable(Byte.class, Integer.TYPE)); [EOL]         assertEquals("byte -> long", autoboxing, ClassUtils.isAssignable(Byte.class, Long.TYPE)); [EOL]         assertEquals("byte -> float", autoboxing, ClassUtils.isAssignable(Byte.class, Float.TYPE)); [EOL]         assertEquals("byte -> double", autoboxing, ClassUtils.isAssignable(Byte.class, Double.TYPE)); [EOL]         assertFalse("byte -> boolean", ClassUtils.isAssignable(Byte.class, Boolean.TYPE)); [EOL]  [EOL]         // test short conversions [EOL]         assertFalse("short -> char", ClassUtils.isAssignable(Short.class, Character.TYPE)); [EOL]         assertFalse("short -> byte", ClassUtils.isAssignable(
@Test [EOL]     public void test_isAssignable_DefaultUnboxing_Widening() throws Exception { [EOL]         final boolean autoboxing = SystemUtils.isJavaVersionAtLeast(JAVA_1_5); [EOL]  [EOL]         // test byte conversions [EOL]         assertFalse("byte -> char", ClassUtils.isAssignable(Byte.class, Character.TYPE)); [EOL]         assertEquals("byte -> byte", autoboxing, ClassUtils.isAssignable(Byte.class, Byte.TYPE)); [EOL]         assertEquals("byte -> short", autoboxing, ClassUtils.isAssignable(Byte.class, Short.TYPE)); [EOL]         assertEquals("byte -> int", autoboxing, ClassUtils.isAssignable(Byte.class, Integer.TYPE)); [EOL]         assertEquals("byte -> long", autoboxing, ClassUtils.isAssignable(Byte.class, Long.TYPE)); [EOL]         assertEquals("byte -> float", autoboxing, ClassUtils.isAssignable(Byte.class, Float.TYPE)); [EOL]         assertEquals("byte -> double", autoboxing, ClassUtils.isAssignable(Byte.class, Double.TYPE)); [EOL]         assertFalse("byte -> boolean", ClassUtils.isAssignable(Byte.class, Boolean.TYPE)); [EOL]  [EOL]         // test short conversions [EOL]         assertFalse("short -> char", ClassUtils.isAssignable(Short.class, Character.TYPE)); [EOL]         assertFalse("short -> byte", ClassUtils.isAssignable(
@Test [EOL]     public void test_isAssignable_DefaultUnboxing_Widening() throws Exception { [EOL]         final boolean autoboxing = SystemUtils.isJavaVersionAtLeast(JAVA_1_5); [EOL]  [EOL]         // test byte conversions [EOL]         assertFalse("byte -> char", ClassUtils.isAssignable(Byte.class, Character.TYPE)); [EOL]         assertEquals("byte -> byte", autoboxing, ClassUtils.isAssignable(Byte.class, Byte.TYPE)); [EOL]         assertEquals("byte -> short", autoboxing, ClassUtils.isAssignable(Byte.class, Short.TYPE)); [EOL]         assertEquals("byte -> int", autoboxing, ClassUtils.isAssignable(Byte.class, Integer.TYPE)); [EOL]         assertEquals("byte -> long", autoboxing, ClassUtils.isAssignable(Byte.class, Long.TYPE)); [EOL]         assertEquals("byte -> float", autoboxing, ClassUtils.isAssignable(Byte.class, Float.TYPE)); [EOL]         assertEquals("byte -> double", autoboxing, ClassUtils.isAssignable(Byte.class, Double.TYPE)); [EOL]         assertFalse("byte -> boolean", ClassUtils.isAssignable(Byte.class, Boolean.TYPE)); [EOL]  [EOL]         // test short conversions [EOL]         assertFalse("short -> char", ClassUtils.isAssignable(Short.class, Character.TYPE)); [EOL]         assertFalse("short -> byte", ClassUtils.isAssignable(
@Test [EOL]     public void test_isAssignable_DefaultUnboxing_Widening() throws Exception { [EOL]         final boolean autoboxing = SystemUtils.isJavaVersionAtLeast(JAVA_1_5); [EOL]  [EOL]         // test byte conversions [EOL]         assertFalse("byte -> char", ClassUtils.isAssignable(Byte.class, Character.TYPE)); [EOL]         assertEquals("byte -> byte", autoboxing, ClassUtils.isAssignable(Byte.class, Byte.TYPE)); [EOL]         assertEquals("byte -> short", autoboxing, ClassUtils.isAssignable(Byte.class, Short.TYPE)); [EOL]         assertEquals("byte -> int", autoboxing, ClassUtils.isAssignable(Byte.class, Integer.TYPE)); [EOL]         assertEquals("byte -> long", autoboxing, ClassUtils.isAssignable(Byte.class, Long.TYPE)); [EOL]         assertEquals("byte -> float", autoboxing, ClassUtils.isAssignable(Byte.class, Float.TYPE)); [EOL]         assertEquals("byte -> double", autoboxing, ClassUtils.isAssignable(Byte.class, Double.TYPE)); [EOL]         assertFalse("byte -> boolean", ClassUtils.isAssignable(Byte.class, Boolean.TYPE)); [EOL]  [EOL]         // test short conversions [EOL]         assertFalse("short -> char", ClassUtils.isAssignable(Short.class, Character.TYPE)); [EOL]         assertFalse("short -> byte", ClassUtils.isAssignable(
@Test [EOL]     public void test_isAssignable_DefaultUnboxing_Widening() throws Exception { [EOL]         final boolean autoboxing = SystemUtils.isJavaVersionAtLeast(JAVA_1_5); [EOL]  [EOL]         // test byte conversions [EOL]         assertFalse("byte -> char", ClassUtils.isAssignable(Byte.class, Character.TYPE)); [EOL]         assertEquals("byte -> byte", autoboxing, ClassUtils.isAssignable(Byte.class, Byte.TYPE)); [EOL]         assertEquals("byte -> short", autoboxing, ClassUtils.isAssignable(Byte.class, Short.TYPE)); [EOL]         assertEquals("byte -> int", autoboxing, ClassUtils.isAssignable(Byte.class, Integer.TYPE)); [EOL]         assertEquals("byte -> long", autoboxing, ClassUtils.isAssignable(Byte.class, Long.TYPE)); [EOL]         assertEquals("byte -> float", autoboxing, ClassUtils.isAssignable(Byte.class, Float.TYPE)); [EOL]         assertEquals("byte -> double", autoboxing, ClassUtils.isAssignable(Byte.class, Double.TYPE)); [EOL]         assertFalse("byte -> boolean", ClassUtils.isAssignable(Byte.class, Boolean.TYPE)); [EOL]  [EOL]         // test short conversions [EOL]         assertFalse("short -> char", ClassUtils.isAssignable(Short.class, Character.TYPE)); [EOL]         assertFalse("short -> byte", ClassUtils.isAssignable(
@Test [EOL]     public void testGetPublicMethod() throws Exception { [EOL]         // Tests with Collections$UnmodifiableSet [EOL]         final Set<?> set = Collections.unmodifiableSet(new HashSet<Object>()); [EOL]         final Method isEmptyMethod = ClassUtils.getPublicMethod(set.getClass(), "isEmpty",  new Class[0]); [EOL]             assertTrue(Modifier.isPublic(isEmptyMethod.getDeclaringClass().getModifiers())); [EOL]  [EOL]         try { [EOL]             isEmptyMethod.invoke(set, new Object[0]); [EOL]         } catch(final java.lang.IllegalAccessException iae) { [EOL]             fail("Should not have thrown IllegalAccessException"); [EOL]         } [EOL]  [EOL]         // Tests with a public Class [EOL]         final Method toStringMethod = ClassUtils.getPublicMethod(Object.class, "toString",  new Class[0]); [EOL]             assertEquals(Object.class.getMethod("toString", new Class[0]), toStringMethod); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetPublicMethod() throws Exception { [EOL]         // Tests with Collections$UnmodifiableSet [EOL]         final Set<?> set = Collections.unmodifiableSet(new HashSet<Object>()); [EOL]         final Method isEmptyMethod = ClassUtils.getPublicMethod(set.getClass(), "isEmpty",  new Class[0]); [EOL]             assertTrue(Modifier.isPublic(isEmptyMethod.getDeclaringClass().getModifiers())); [EOL]  [EOL]         try { [EOL]             isEmptyMethod.invoke(set, new Object[0]); [EOL]         } catch(final java.lang.IllegalAccessException iae) { [EOL]             fail("Should not have thrown IllegalAccessException"); [EOL]         } [EOL]  [EOL]         // Tests with a public Class [EOL]         final Method toStringMethod = ClassUtils.getPublicMethod(Object.class, "toString",  new Class[0]); [EOL]             assertEquals(Object.class.getMethod("toString", new Class[0]), toStringMethod); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetPublicMethod() throws Exception { [EOL]         // Tests with Collections$UnmodifiableSet [EOL]         final Set<?> set = Collections.unmodifiableSet(new HashSet<Object>()); [EOL]         final Method isEmptyMethod = ClassUtils.getPublicMethod(set.getClass(), "isEmpty",  new Class[0]); [EOL]             assertTrue(Modifier.isPublic(isEmptyMethod.getDeclaringClass().getModifiers())); [EOL]  [EOL]         try { [EOL]             isEmptyMethod.invoke(set, new Object[0]); [EOL]         } catch(final java.lang.IllegalAccessException iae) { [EOL]             fail("Should not have thrown IllegalAccessException"); [EOL]         } [EOL]  [EOL]         // Tests with a public Class [EOL]         final Method toStringMethod = ClassUtils.getPublicMethod(Object.class, "toString",  new Class[0]); [EOL]             assertEquals(Object.class.getMethod("toString", new Class[0]), toStringMethod); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetPublicMethod() throws Exception { [EOL]         // Tests with Collections$UnmodifiableSet [EOL]         final Set<?> set = Collections.unmodifiableSet(new HashSet<Object>()); [EOL]         final Method isEmptyMethod = ClassUtils.getPublicMethod(set.getClass(), "isEmpty",  new Class[0]); [EOL]             assertTrue(Modifier.isPublic(isEmptyMethod.getDeclaringClass().getModifiers())); [EOL]  [EOL]         try { [EOL]             isEmptyMethod.invoke(set, new Object[0]); [EOL]         } catch(final java.lang.IllegalAccessException iae) { [EOL]             fail("Should not have thrown IllegalAccessException"); [EOL]         } [EOL]  [EOL]         // Tests with a public Class [EOL]         final Method toStringMethod = ClassUtils.getPublicMethod(Object.class, "toString",  new Class[0]); [EOL]             assertEquals(Object.class.getMethod("toString", new Class[0]), toStringMethod); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetPublicMethod() throws Exception { [EOL]         // Tests with Collections$UnmodifiableSet [EOL]         final Set<?> set = Collections.unmodifiableSet(new HashSet<Object>()); [EOL]         final Method isEmptyMethod = ClassUtils.getPublicMethod(set.getClass(), "isEmpty",  new Class[0]); [EOL]             assertTrue(Modifier.isPublic(isEmptyMethod.getDeclaringClass().getModifiers())); [EOL]  [EOL]         try { [EOL]             isEmptyMethod.invoke(set, new Object[0]); [EOL]         } catch(final java.lang.IllegalAccessException iae) { [EOL]             fail("Should not have thrown IllegalAccessException"); [EOL]         } [EOL]  [EOL]         // Tests with a public Class [EOL]         final Method toStringMethod = ClassUtils.getPublicMethod(Object.class, "toString",  new Class[0]); [EOL]             assertEquals(Object.class.getMethod("toString", new Class[0]), toStringMethod); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetPublicMethod() throws Exception { [EOL]         // Tests with Collections$UnmodifiableSet [EOL]         final Set<?> set = Collections.unmodifiableSet(new HashSet<Object>()); [EOL]         final Method isEmptyMethod = ClassUtils.getPublicMethod(set.getClass(), "isEmpty",  new Class[0]); [EOL]             assertTrue(Modifier.isPublic(isEmptyMethod.getDeclaringClass().getModifiers())); [EOL]  [EOL]         try { [EOL]             isEmptyMethod.invoke(set, new Object[0]); [EOL]         } catch(final java.lang.IllegalAccessException iae) { [EOL]             fail("Should not have thrown IllegalAccessException"); [EOL]         } [EOL]  [EOL]         // Tests with a public Class [EOL]         final Method toStringMethod = ClassUtils.getPublicMethod(Object.class, "toString",  new Class[0]); [EOL]             assertEquals(Object.class.getMethod("toString", new Class[0]), toStringMethod); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetPublicMethod() throws Exception { [EOL]         // Tests with Collections$UnmodifiableSet [EOL]         final Set<?> set = Collections.unmodifiableSet(new HashSet<Object>()); [EOL]         final Method isEmptyMethod = ClassUtils.getPublicMethod(set.getClass(), "isEmpty",  new Class[0]); [EOL]             assertTrue(Modifier.isPublic(isEmptyMethod.getDeclaringClass().getModifiers())); [EOL]  [EOL]         try { [EOL]             isEmptyMethod.invoke(set, new Object[0]); [EOL]         } catch(final java.lang.IllegalAccessException iae) { [EOL]             fail("Should not have thrown IllegalAccessException"); [EOL]         } [EOL]  [EOL]         // Tests with a public Class [EOL]         final Method toStringMethod = ClassUtils.getPublicMethod(Object.class, "toString",  new Class[0]); [EOL]             assertEquals(Object.class.getMethod("toString", new Class[0]), toStringMethod); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetPublicMethod() throws Exception { [EOL]         // Tests with Collections$UnmodifiableSet [EOL]         final Set<?> set = Collections.unmodifiableSet(new HashSet<Object>()); [EOL]         final Method isEmptyMethod = ClassUtils.getPublicMethod(set.getClass(), "isEmpty",  new Class[0]); [EOL]             assertTrue(Modifier.isPublic(isEmptyMethod.getDeclaringClass().getModifiers())); [EOL]  [EOL]         try { [EOL]             isEmptyMethod.invoke(set, new Object[0]); [EOL]         } catch(final java.lang.IllegalAccessException iae) { [EOL]             fail("Should not have thrown IllegalAccessException"); [EOL]         } [EOL]  [EOL]         // Tests with a public Class [EOL]         final Method toStringMethod = ClassUtils.getPublicMethod(Object.class, "toString",  new Class[0]); [EOL]             assertEquals(Object.class.getMethod("toString", new Class[0]), toStringMethod); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetPublicMethod() throws Exception { [EOL]         // Tests with Collections$UnmodifiableSet [EOL]         final Set<?> set = Collections.unmodifiableSet(new HashSet<Object>()); [EOL]         final Method isEmptyMethod = ClassUtils.getPublicMethod(set.getClass(), "isEmpty",  new Class[0]); [EOL]             assertTrue(Modifier.isPublic(isEmptyMethod.getDeclaringClass().getModifiers())); [EOL]  [EOL]         try { [EOL]             isEmptyMethod.invoke(set, new Object[0]); [EOL]         } catch(final java.lang.IllegalAccessException iae) { [EOL]             fail("Should not have thrown IllegalAccessException"); [EOL]         } [EOL]  [EOL]         // Tests with a public Class [EOL]         final Method toStringMethod = ClassUtils.getPublicMethod(Object.class, "toString",  new Class[0]); [EOL]             assertEquals(Object.class.getMethod("toString", new Class[0]), toStringMethod); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetPublicMethod() throws Exception { [EOL]         // Tests with Collections$UnmodifiableSet [EOL]         final Set<?> set = Collections.unmodifiableSet(new HashSet<Object>()); [EOL]         final Method isEmptyMethod = ClassUtils.getPublicMethod(set.getClass(), "isEmpty",  new Class[0]); [EOL]             assertTrue(Modifier.isPublic(isEmptyMethod.getDeclaringClass().getModifiers())); [EOL]  [EOL]         try { [EOL]             isEmptyMethod.invoke(set, new Object[0]); [EOL]         } catch(final java.lang.IllegalAccessException iae) { [EOL]             fail("Should not have thrown IllegalAccessException"); [EOL]         } [EOL]  [EOL]         // Tests with a public Class [EOL]         final Method toStringMethod = ClassUtils.getPublicMethod(Object.class, "toString",  new Class[0]); [EOL]             assertEquals(Object.class.getMethod("toString", new Class[0]), toStringMethod); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetPublicMethod() throws Exception { [EOL]         // Tests with Collections$UnmodifiableSet [EOL]         final Set<?> set = Collections.unmodifiableSet(new HashSet<Object>()); [EOL]         final Method isEmptyMethod = ClassUtils.getPublicMethod(set.getClass(), "isEmpty",  new Class[0]); [EOL]             assertTrue(Modifier.isPublic(isEmptyMethod.getDeclaringClass().getModifiers())); [EOL]  [EOL]         try { [EOL]             isEmptyMethod.invoke(set, new Object[0]); [EOL]         } catch(final java.lang.IllegalAccessException iae) { [EOL]             fail("Should not have thrown IllegalAccessException"); [EOL]         } [EOL]  [EOL]         // Tests with a public Class [EOL]         final Method toStringMethod = ClassUtils.getPublicMethod(Object.class, "toString",  new Class[0]); [EOL]             assertEquals(Object.class.getMethod("toString", new Class[0]), toStringMethod); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetPublicMethod() throws Exception { [EOL]         // Tests with Collections$UnmodifiableSet [EOL]         final Set<?> set = Collections.unmodifiableSet(new HashSet<Object>()); [EOL]         final Method isEmptyMethod = ClassUtils.getPublicMethod(set.getClass(), "isEmpty",  new Class[0]); [EOL]             assertTrue(Modifier.isPublic(isEmptyMethod.getDeclaringClass().getModifiers())); [EOL]  [EOL]         try { [EOL]             isEmptyMethod.invoke(set, new Object[0]); [EOL]         } catch(final java.lang.IllegalAccessException iae) { [EOL]             fail("Should not have thrown IllegalAccessException"); [EOL]         } [EOL]  [EOL]         // Tests with a public Class [EOL]         final Method toStringMethod = ClassUtils.getPublicMethod(Object.class, "toString",  new Class[0]); [EOL]             assertEquals(Object.class.getMethod("toString", new Class[0]), toStringMethod); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetClassByNormalNameArrays2D() throws ClassNotFoundException { [EOL]         assertEquals( int[][].class, ClassUtils.getClass( "int[][]" ) ); [EOL]         assertEquals( long[][].class, ClassUtils.getClass( "long[][]" ) ); [EOL]         assertEquals( short[][].class, ClassUtils.getClass( "short[][]" ) ); [EOL]         assertEquals( byte[][].class, ClassUtils.getClass( "byte[][]" ) ); [EOL]         assertEquals( char[][].class, ClassUtils.getClass( "char[][]" ) ); [EOL]         assertEquals( float[][].class, ClassUtils.getClass( "float[][]" ) ); [EOL]         assertEquals( double[][].class, ClassUtils.getClass( "double[][]" ) ); [EOL]         assertEquals( boolean[][].class, ClassUtils.getClass( "boolean[][]" ) ); [EOL]         assertEquals( String[][].class, ClassUtils.getClass( "java.lang.String[][]" ) ); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void test_getShortCanonicalName_String() { [EOL]         assertEquals("ClassUtils", ClassUtils.getShortCanonicalName("org.apache.commons.lang3.ClassUtils")); [EOL]         assertEquals("ClassUtils[]", ClassUtils.getShortCanonicalName("[Lorg.apache.commons.lang3.ClassUtils;")); [EOL]         assertEquals("ClassUtils[][]", ClassUtils.getShortCanonicalName("[[Lorg.apache.commons.lang3.ClassUtils;")); [EOL]         assertEquals("ClassUtils[]", ClassUtils.getShortCanonicalName("org.apache.commons.lang3.ClassUtils[]")); [EOL]         assertEquals("ClassUtils[][]", ClassUtils.getShortCanonicalName("org.apache.commons.lang3.ClassUtils[][]")); [EOL]         assertEquals("int[]", ClassUtils.getShortCanonicalName("[I")); [EOL]         assertEquals("int[][]", ClassUtils.getShortCanonicalName("[[I")); [EOL]         assertEquals("int[]", ClassUtils.getShortCanonicalName("int[]")); [EOL]         assertEquals("int[][]", ClassUtils.getShortCanonicalName("int[][]")); [EOL]          [EOL]         // Inner types [EOL]         assertEquals("ClassUtilsTest.6", ClassUtils.getShortCanonicalName("org.apache.commons.lang3.ClassUtilsTest$6")); [EOL]
@Test [EOL]     public void test_getShortCanonicalName_String() { [EOL]         assertEquals("ClassUtils", ClassUtils.getShortCanonicalName("org.apache.commons.lang3.ClassUtils")); [EOL]         assertEquals("ClassUtils[]", ClassUtils.getShortCanonicalName("[Lorg.apache.commons.lang3.ClassUtils;")); [EOL]         assertEquals("ClassUtils[][]", ClassUtils.getShortCanonicalName("[[Lorg.apache.commons.lang3.ClassUtils;")); [EOL]         assertEquals("ClassUtils[]", ClassUtils.getShortCanonicalName("org.apache.commons.lang3.ClassUtils[]")); [EOL]         assertEquals("ClassUtils[][]", ClassUtils.getShortCanonicalName("org.apache.commons.lang3.ClassUtils[][]")); [EOL]         assertEquals("int[]", ClassUtils.getShortCanonicalName("[I")); [EOL]         assertEquals("int[][]", ClassUtils.getShortCanonicalName("[[I")); [EOL]         assertEquals("int[]", ClassUtils.getShortCanonicalName("int[]")); [EOL]         assertEquals("int[][]", ClassUtils.getShortCanonicalName("int[][]")); [EOL]          [EOL]         // Inner types [EOL]         assertEquals("ClassUtilsTest.6", ClassUtils.getShortCanonicalName("org.apache.commons.lang3.ClassUtilsTest$6")); [EOL]
@Test [EOL]     public void test_getShortCanonicalName_String() { [EOL]         assertEquals("ClassUtils", ClassUtils.getShortCanonicalName("org.apache.commons.lang3.ClassUtils")); [EOL]         assertEquals("ClassUtils[]", ClassUtils.getShortCanonicalName("[Lorg.apache.commons.lang3.ClassUtils;")); [EOL]         assertEquals("ClassUtils[][]", ClassUtils.getShortCanonicalName("[[Lorg.apache.commons.lang3.ClassUtils;")); [EOL]         assertEquals("ClassUtils[]", ClassUtils.getShortCanonicalName("org.apache.commons.lang3.ClassUtils[]")); [EOL]         assertEquals("ClassUtils[][]", ClassUtils.getShortCanonicalName("org.apache.commons.lang3.ClassUtils[][]")); [EOL]         assertEquals("int[]", ClassUtils.getShortCanonicalName("[I")); [EOL]         assertEquals("int[][]", ClassUtils.getShortCanonicalName("[[I")); [EOL]         assertEquals("int[]", ClassUtils.getShortCanonicalName("int[]")); [EOL]         assertEquals("int[][]", ClassUtils.getShortCanonicalName("int[][]")); [EOL]          [EOL]         // Inner types [EOL]         assertEquals("ClassUtilsTest.6", ClassUtils.getShortCanonicalName("org.apache.commons.lang3.ClassUtilsTest$6")); [EOL]
@Test [EOL]     public void test_getShortCanonicalName_String() { [EOL]         assertEquals("ClassUtils", ClassUtils.getShortCanonicalName("org.apache.commons.lang3.ClassUtils")); [EOL]         assertEquals("ClassUtils[]", ClassUtils.getShortCanonicalName("[Lorg.apache.commons.lang3.ClassUtils;")); [EOL]         assertEquals("ClassUtils[][]", ClassUtils.getShortCanonicalName("[[Lorg.apache.commons.lang3.ClassUtils;")); [EOL]         assertEquals("ClassUtils[]", ClassUtils.getShortCanonicalName("org.apache.commons.lang3.ClassUtils[]")); [EOL]         assertEquals("ClassUtils[][]", ClassUtils.getShortCanonicalName("org.apache.commons.lang3.ClassUtils[][]")); [EOL]         assertEquals("int[]", ClassUtils.getShortCanonicalName("[I")); [EOL]         assertEquals("int[][]", ClassUtils.getShortCanonicalName("[[I")); [EOL]         assertEquals("int[]", ClassUtils.getShortCanonicalName("int[]")); [EOL]         assertEquals("int[][]", ClassUtils.getShortCanonicalName("int[][]")); [EOL]          [EOL]         // Inner types [EOL]         assertEquals("ClassUtilsTest.6", ClassUtils.getShortCanonicalName("org.apache.commons.lang3.ClassUtilsTest$6")); [EOL]
@Test [EOL]     public void test_getShortCanonicalName_String() { [EOL]         assertEquals("ClassUtils", ClassUtils.getShortCanonicalName("org.apache.commons.lang3.ClassUtils")); [EOL]         assertEquals("ClassUtils[]", ClassUtils.getShortCanonicalName("[Lorg.apache.commons.lang3.ClassUtils;")); [EOL]         assertEquals("ClassUtils[][]", ClassUtils.getShortCanonicalName("[[Lorg.apache.commons.lang3.ClassUtils;")); [EOL]         assertEquals("ClassUtils[]", ClassUtils.getShortCanonicalName("org.apache.commons.lang3.ClassUtils[]")); [EOL]         assertEquals("ClassUtils[][]", ClassUtils.getShortCanonicalName("org.apache.commons.lang3.ClassUtils[][]")); [EOL]         assertEquals("int[]", ClassUtils.getShortCanonicalName("[I")); [EOL]         assertEquals("int[][]", ClassUtils.getShortCanonicalName("[[I")); [EOL]         assertEquals("int[]", ClassUtils.getShortCanonicalName("int[]")); [EOL]         assertEquals("int[][]", ClassUtils.getShortCanonicalName("int[][]")); [EOL]          [EOL]         // Inner types [EOL]         assertEquals("ClassUtilsTest.6", ClassUtils.getShortCanonicalName("org.apache.commons.lang3.ClassUtilsTest$6")); [EOL]
@Test [EOL]     public void test_toBooleanObject_String() { [EOL]         assertEquals(null, BooleanUtils.toBooleanObject((String) null)); [EOL]         assertEquals(null, BooleanUtils.toBooleanObject("")); [EOL]         assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject("false")); [EOL]         assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject("no")); [EOL]         assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject("off")); [EOL]         assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject("FALSE")); [EOL]         assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject("NO")); [EOL]         assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject("OFF")); [EOL]         assertEquals(null, BooleanUtils.toBooleanObject("oof")); [EOL]         assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject("true")); [EOL]         assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject("yes")); [EOL]         assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject("on")); [EOL]         assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject("TRUE")); [EOL]         assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject("ON")); [EOL]      
@Test [EOL]     public void test_toBooleanObject_String() { [EOL]         assertEquals(null, BooleanUtils.toBooleanObject((String) null)); [EOL]         assertEquals(null, BooleanUtils.toBooleanObject("")); [EOL]         assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject("false")); [EOL]         assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject("no")); [EOL]         assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject("off")); [EOL]         assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject("FALSE")); [EOL]         assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject("NO")); [EOL]         assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject("OFF")); [EOL]         assertEquals(null, BooleanUtils.toBooleanObject("oof")); [EOL]         assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject("true")); [EOL]         assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject("yes")); [EOL]         assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject("on")); [EOL]         assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject("TRUE")); [EOL]         assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject("ON")); [EOL]      
@Test [EOL]     public void test_toBoolean_String_String_String() { [EOL]         assertTrue(BooleanUtils.toBoolean((String) null, null, "N")); [EOL]         assertFalse(BooleanUtils.toBoolean((String) null, "Y", null)); [EOL]         assertTrue(BooleanUtils.toBoolean("Y", "Y", "N")); [EOL]         assertTrue(BooleanUtils.toBoolean("Y", new String("Y"), new String("N"))); [EOL]         assertFalse(BooleanUtils.toBoolean("N", "Y", "N")); [EOL]         assertFalse(BooleanUtils.toBoolean("N", new String("Y"), new String("N"))); [EOL]         assertTrue(BooleanUtils.toBoolean((String) null, null, null)); [EOL]         assertTrue(BooleanUtils.toBoolean("Y", "Y", "Y")); [EOL]         assertTrue(BooleanUtils.toBoolean("Y", new String("Y"), new String("Y"))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void test_toBoolean_String_String_String() { [EOL]         assertTrue(BooleanUtils.toBoolean((String) null, null, "N")); [EOL]         assertFalse(BooleanUtils.toBoolean((String) null, "Y", null)); [EOL]         assertTrue(BooleanUtils.toBoolean("Y", "Y", "N")); [EOL]         assertTrue(BooleanUtils.toBoolean("Y", new String("Y"), new String("N"))); [EOL]         assertFalse(BooleanUtils.toBoolean("N", "Y", "N")); [EOL]         assertFalse(BooleanUtils.toBoolean("N", new String("Y"), new String("N"))); [EOL]         assertTrue(BooleanUtils.toBoolean((String) null, null, null)); [EOL]         assertTrue(BooleanUtils.toBoolean("Y", "Y", "Y")); [EOL]         assertTrue(BooleanUtils.toBoolean("Y", new String("Y"), new String("Y"))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSerialization() throws IOException, ClassNotFoundException, PropertyVetoException { [EOL]         final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); [EOL]         listenerSupport.addListener(new VetoableChangeListener() { [EOL]              [EOL]             @Override [EOL]             public void vetoableChange(final PropertyChangeEvent e) { [EOL]             } [EOL]         }); [EOL]         listenerSupport.addListener(EasyMock.createNiceMock(VetoableChangeListener.class)); [EOL]  [EOL]         //serialize: [EOL]         final ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); [EOL]         final ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream); [EOL]  [EOL]         objectOutputStream.writeObject(listenerSupport); [EOL]         objectOutputStream.close(); [EOL]  [EOL]         //deserialize: [EOL]         @SuppressWarnings("unchecked") [EOL]         final [EOL]         EventListenerSupport<VetoableChangeListener> deserializedListenerSupport = (EventListenerSupport<VetoableChangeListener>) new ObjectInputStream( [EOL]                 new ByteArrayInputStream(outputStream.toByteArray())).readObject(); [EOL]  [EOL]     
@Test [EOL]     public void testSerialization() throws IOException, ClassNotFoundException, PropertyVetoException { [EOL]         final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); [EOL]         listenerSupport.addListener(new VetoableChangeListener() { [EOL]              [EOL]             @Override [EOL]             public void vetoableChange(final PropertyChangeEvent e) { [EOL]             } [EOL]         }); [EOL]         listenerSupport.addListener(EasyMock.createNiceMock(VetoableChangeListener.class)); [EOL]  [EOL]         //serialize: [EOL]         final ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); [EOL]         final ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream); [EOL]  [EOL]         objectOutputStream.writeObject(listenerSupport); [EOL]         objectOutputStream.close(); [EOL]  [EOL]         //deserialize: [EOL]         @SuppressWarnings("unchecked") [EOL]         final [EOL]         EventListenerSupport<VetoableChangeListener> deserializedListenerSupport = (EventListenerSupport<VetoableChangeListener>) new ObjectInputStream( [EOL]                 new ByteArrayInputStream(outputStream.toByteArray())).readObject(); [EOL]  [EOL]     
@Test [EOL]     public void testSerialization() throws IOException, ClassNotFoundException, PropertyVetoException { [EOL]         final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); [EOL]         listenerSupport.addListener(new VetoableChangeListener() { [EOL]              [EOL]             @Override [EOL]             public void vetoableChange(final PropertyChangeEvent e) { [EOL]             } [EOL]         }); [EOL]         listenerSupport.addListener(EasyMock.createNiceMock(VetoableChangeListener.class)); [EOL]  [EOL]         //serialize: [EOL]         final ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); [EOL]         final ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream); [EOL]  [EOL]         objectOutputStream.writeObject(listenerSupport); [EOL]         objectOutputStream.close(); [EOL]  [EOL]         //deserialize: [EOL]         @SuppressWarnings("unchecked") [EOL]         final [EOL]         EventListenerSupport<VetoableChangeListener> deserializedListenerSupport = (EventListenerSupport<VetoableChangeListener>) new ObjectInputStream( [EOL]                 new ByteArrayInputStream(outputStream.toByteArray())).readObject(); [EOL]  [EOL]     
@Test [EOL]     public void testAddEventListenerThrowsException() [EOL]     { [EOL]         final ExceptionEventSource src = new ExceptionEventSource(); [EOL]         try [EOL]         { [EOL]             EventUtils.addEventListener(src, PropertyChangeListener.class, new PropertyChangeListener() [EOL]             { [EOL]                 @Override [EOL]                 public void propertyChange(final PropertyChangeEvent e) [EOL]                 { [EOL]                     // Do nothing! [EOL]                 } [EOL]             }); [EOL]             fail("Add method should have thrown an exception, so method should fail."); [EOL]         } [EOL]         catch (final RuntimeException e) [EOL]         { [EOL]  [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testAddEventListenerThrowsException() [EOL]     { [EOL]         final ExceptionEventSource src = new ExceptionEventSource(); [EOL]         try [EOL]         { [EOL]             EventUtils.addEventListener(src, PropertyChangeListener.class, new PropertyChangeListener() [EOL]             { [EOL]                 @Override [EOL]                 public void propertyChange(final PropertyChangeEvent e) [EOL]                 { [EOL]                     // Do nothing! [EOL]                 } [EOL]             }); [EOL]             fail("Add method should have thrown an exception, so method should fail."); [EOL]         } [EOL]         catch (final RuntimeException e) [EOL]         { [EOL]  [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSerialization() throws IOException, ClassNotFoundException, PropertyVetoException { [EOL]         final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); [EOL]         listenerSupport.addListener(new VetoableChangeListener() { [EOL]              [EOL]             @Override [EOL]             public void vetoableChange(final PropertyChangeEvent e) { [EOL]             } [EOL]         }); [EOL]         listenerSupport.addListener(EasyMock.createNiceMock(VetoableChangeListener.class)); [EOL]  [EOL]         //serialize: [EOL]         final ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); [EOL]         final ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream); [EOL]  [EOL]         objectOutputStream.writeObject(listenerSupport); [EOL]         objectOutputStream.close(); [EOL]  [EOL]         //deserialize: [EOL]         @SuppressWarnings("unchecked") [EOL]         final [EOL]         EventListenerSupport<VetoableChangeListener> deserializedListenerSupport = (EventListenerSupport<VetoableChangeListener>) new ObjectInputStream( [EOL]                 new ByteArrayInputStream(outputStream.toByteArray())).readObject(); [EOL]  [EOL]     
@Test [EOL]     public void testSerialization() throws IOException, ClassNotFoundException, PropertyVetoException { [EOL]         final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); [EOL]         listenerSupport.addListener(new VetoableChangeListener() { [EOL]              [EOL]             @Override [EOL]             public void vetoableChange(final PropertyChangeEvent e) { [EOL]             } [EOL]         }); [EOL]         listenerSupport.addListener(EasyMock.createNiceMock(VetoableChangeListener.class)); [EOL]  [EOL]         //serialize: [EOL]         final ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); [EOL]         final ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream); [EOL]  [EOL]         objectOutputStream.writeObject(listenerSupport); [EOL]         objectOutputStream.close(); [EOL]  [EOL]         //deserialize: [EOL]         @SuppressWarnings("unchecked") [EOL]         final [EOL]         EventListenerSupport<VetoableChangeListener> deserializedListenerSupport = (EventListenerSupport<VetoableChangeListener>) new ObjectInputStream( [EOL]                 new ByteArrayInputStream(outputStream.toByteArray())).readObject(); [EOL]  [EOL]     
@Test [EOL]     public void testSerialization() throws IOException, ClassNotFoundException, PropertyVetoException { [EOL]         final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); [EOL]         listenerSupport.addListener(new VetoableChangeListener() { [EOL]              [EOL]             @Override [EOL]             public void vetoableChange(final PropertyChangeEvent e) { [EOL]             } [EOL]         }); [EOL]         listenerSupport.addListener(EasyMock.createNiceMock(VetoableChangeListener.class)); [EOL]  [EOL]         //serialize: [EOL]         final ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); [EOL]         final ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream); [EOL]  [EOL]         objectOutputStream.writeObject(listenerSupport); [EOL]         objectOutputStream.close(); [EOL]  [EOL]         //deserialize: [EOL]         @SuppressWarnings("unchecked") [EOL]         final [EOL]         EventListenerSupport<VetoableChangeListener> deserializedListenerSupport = (EventListenerSupport<VetoableChangeListener>) new ObjectInputStream( [EOL]                 new ByteArrayInputStream(outputStream.toByteArray())).readObject(); [EOL]  [EOL]     
@Test [EOL]     public void testSerialization() throws IOException, ClassNotFoundException, PropertyVetoException { [EOL]         final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); [EOL]         listenerSupport.addListener(new VetoableChangeListener() { [EOL]              [EOL]             @Override [EOL]             public void vetoableChange(final PropertyChangeEvent e) { [EOL]             } [EOL]         }); [EOL]         listenerSupport.addListener(EasyMock.createNiceMock(VetoableChangeListener.class)); [EOL]  [EOL]         //serialize: [EOL]         final ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); [EOL]         final ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream); [EOL]  [EOL]         objectOutputStream.writeObject(listenerSupport); [EOL]         objectOutputStream.close(); [EOL]  [EOL]         //deserialize: [EOL]         @SuppressWarnings("unchecked") [EOL]         final [EOL]         EventListenerSupport<VetoableChangeListener> deserializedListenerSupport = (EventListenerSupport<VetoableChangeListener>) new ObjectInputStream( [EOL]                 new ByteArrayInputStream(outputStream.toByteArray())).readObject(); [EOL]  [EOL]     
@Test [EOL]     public void testSerialization() throws IOException, ClassNotFoundException, PropertyVetoException { [EOL]         final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); [EOL]         listenerSupport.addListener(new VetoableChangeListener() { [EOL]              [EOL]             @Override [EOL]             public void vetoableChange(final PropertyChangeEvent e) { [EOL]             } [EOL]         }); [EOL]         listenerSupport.addListener(EasyMock.createNiceMock(VetoableChangeListener.class)); [EOL]  [EOL]         //serialize: [EOL]         final ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); [EOL]         final ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream); [EOL]  [EOL]         objectOutputStream.writeObject(listenerSupport); [EOL]         objectOutputStream.close(); [EOL]  [EOL]         //deserialize: [EOL]         @SuppressWarnings("unchecked") [EOL]         final [EOL]         EventListenerSupport<VetoableChangeListener> deserializedListenerSupport = (EventListenerSupport<VetoableChangeListener>) new ObjectInputStream( [EOL]                 new ByteArrayInputStream(outputStream.toByteArray())).readObject(); [EOL]  [EOL]     
@Test [EOL]     public void testSerialization() throws IOException, ClassNotFoundException, PropertyVetoException { [EOL]         final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); [EOL]         listenerSupport.addListener(new VetoableChangeListener() { [EOL]              [EOL]             @Override [EOL]             public void vetoableChange(final PropertyChangeEvent e) { [EOL]             } [EOL]         }); [EOL]         listenerSupport.addListener(EasyMock.createNiceMock(VetoableChangeListener.class)); [EOL]  [EOL]         //serialize: [EOL]         final ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); [EOL]         final ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream); [EOL]  [EOL]         objectOutputStream.writeObject(listenerSupport); [EOL]         objectOutputStream.close(); [EOL]  [EOL]         //deserialize: [EOL]         @SuppressWarnings("unchecked") [EOL]         final [EOL]         EventListenerSupport<VetoableChangeListener> deserializedListenerSupport = (EventListenerSupport<VetoableChangeListener>) new ObjectInputStream( [EOL]                 new ByteArrayInputStream(outputStream.toByteArray())).readObject(); [EOL]  [EOL]     
@Test [EOL]     public void testSerialization() throws IOException, ClassNotFoundException, PropertyVetoException { [EOL]         final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); [EOL]         listenerSupport.addListener(new VetoableChangeListener() { [EOL]              [EOL]             @Override [EOL]             public void vetoableChange(final PropertyChangeEvent e) { [EOL]             } [EOL]         }); [EOL]         listenerSupport.addListener(EasyMock.createNiceMock(VetoableChangeListener.class)); [EOL]  [EOL]         //serialize: [EOL]         final ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); [EOL]         final ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream); [EOL]  [EOL]         objectOutputStream.writeObject(listenerSupport); [EOL]         objectOutputStream.close(); [EOL]  [EOL]         //deserialize: [EOL]         @SuppressWarnings("unchecked") [EOL]         final [EOL]         EventListenerSupport<VetoableChangeListener> deserializedListenerSupport = (EventListenerSupport<VetoableChangeListener>) new ObjectInputStream( [EOL]                 new ByteArrayInputStream(outputStream.toByteArray())).readObject(); [EOL]  [EOL]     
@Test [EOL]     public void testSerialization() throws IOException, ClassNotFoundException, PropertyVetoException { [EOL]         final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); [EOL]         listenerSupport.addListener(new VetoableChangeListener() { [EOL]              [EOL]             @Override [EOL]             public void vetoableChange(final PropertyChangeEvent e) { [EOL]             } [EOL]         }); [EOL]         listenerSupport.addListener(EasyMock.createNiceMock(VetoableChangeListener.class)); [EOL]  [EOL]         //serialize: [EOL]         final ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); [EOL]         final ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream); [EOL]  [EOL]         objectOutputStream.writeObject(listenerSupport); [EOL]         objectOutputStream.close(); [EOL]  [EOL]         //deserialize: [EOL]         @SuppressWarnings("unchecked") [EOL]         final [EOL]         EventListenerSupport<VetoableChangeListener> deserializedListenerSupport = (EventListenerSupport<VetoableChangeListener>) new ObjectInputStream( [EOL]                 new ByteArrayInputStream(outputStream.toByteArray())).readObject(); [EOL]  [EOL]     
@Test [EOL]     public void testSerialization() throws IOException, ClassNotFoundException, PropertyVetoException { [EOL]         final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); [EOL]         listenerSupport.addListener(new VetoableChangeListener() { [EOL]              [EOL]             @Override [EOL]             public void vetoableChange(final PropertyChangeEvent e) { [EOL]             } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSerialization() throws IOException, ClassNotFoundException, PropertyVetoException { [EOL]         final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); [EOL]         listenerSupport.addListener(new VetoableChangeListener() { [EOL]              [EOL]             @Override [EOL]             public void vetoableChange(final PropertyChangeEvent e) { [EOL]             } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSerializeBytes() throws Exception { [EOL]         final byte[] testBytes = SerializationUtils.serialize(iMap); [EOL]  [EOL]         final ByteArrayOutputStream streamReal = new ByteArrayOutputStream(); [EOL]         final ObjectOutputStream oos = new ObjectOutputStream(streamReal); [EOL]         oos.writeObject(iMap); [EOL]         oos.flush(); [EOL]         oos.close(); [EOL]  [EOL]         final byte[] realBytes = streamReal.toByteArray(); [EOL]         assertEquals(testBytes.length, realBytes.length); [EOL]         for (int i = 0; i < realBytes.length; i++) { [EOL]             assertEquals(realBytes[i], testBytes[i]); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSerializeBytes() throws Exception { [EOL]         final byte[] testBytes = SerializationUtils.serialize(iMap); [EOL]  [EOL]         final ByteArrayOutputStream streamReal = new ByteArrayOutputStream(); [EOL]         final ObjectOutputStream oos = new ObjectOutputStream(streamReal); [EOL]         oos.writeObject(iMap); [EOL]         oos.flush(); [EOL]         oos.close(); [EOL]  [EOL]         final byte[] realBytes = streamReal.toByteArray(); [EOL]         assertEquals(testBytes.length, realBytes.length); [EOL]         for (int i = 0; i < realBytes.length; i++) { [EOL]             assertEquals(realBytes[i], testBytes[i]); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSerializeBytes() throws Exception { [EOL]         final byte[] testBytes = SerializationUtils.serialize(iMap); [EOL]  [EOL]         final ByteArrayOutputStream streamReal = new ByteArrayOutputStream(); [EOL]         final ObjectOutputStream oos = new ObjectOutputStream(streamReal); [EOL]         oos.writeObject(iMap); [EOL]         oos.flush(); [EOL]         oos.close(); [EOL]  [EOL]         final byte[] realBytes = streamReal.toByteArray(); [EOL]         assertEquals(testBytes.length, realBytes.length); [EOL]         for (int i = 0; i < realBytes.length; i++) { [EOL]             assertEquals(realBytes[i], testBytes[i]); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSerializeBytes() throws Exception { [EOL]         final byte[] testBytes = SerializationUtils.serialize(iMap); [EOL]  [EOL]         final ByteArrayOutputStream streamReal = new ByteArrayOutputStream(); [EOL]         final ObjectOutputStream oos = new ObjectOutputStream(streamReal); [EOL]         oos.writeObject(iMap); [EOL]         oos.flush(); [EOL]         oos.close(); [EOL]  [EOL]         final byte[] realBytes = streamReal.toByteArray(); [EOL]         assertEquals(testBytes.length, realBytes.length); [EOL]         for (int i = 0; i < realBytes.length; i++) { [EOL]             assertEquals(realBytes[i], testBytes[i]); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSerializeBytes() throws Exception { [EOL]         final byte[] testBytes = SerializationUtils.serialize(iMap); [EOL]  [EOL]         final ByteArrayOutputStream streamReal = new ByteArrayOutputStream(); [EOL]         final ObjectOutputStream oos = new ObjectOutputStream(streamReal); [EOL]         oos.writeObject(iMap); [EOL]         oos.flush(); [EOL]         oos.close(); [EOL]  [EOL]         final byte[] realBytes = streamReal.toByteArray(); [EOL]         assertEquals(testBytes.length, realBytes.length); [EOL]         for (int i = 0; i < realBytes.length; i++) { [EOL]             assertEquals(realBytes[i], testBytes[i]); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSerializeBytes() throws Exception { [EOL]         final byte[] testBytes = SerializationUtils.serialize(iMap); [EOL]  [EOL]         final ByteArrayOutputStream streamReal = new ByteArrayOutputStream(); [EOL]         final ObjectOutputStream oos = new ObjectOutputStream(streamReal); [EOL]         oos.writeObject(iMap); [EOL]         oos.flush(); [EOL]         oos.close(); [EOL]  [EOL]         final byte[] realBytes = streamReal.toByteArray(); [EOL]         assertEquals(testBytes.length, realBytes.length); [EOL]         for (int i = 0; i < realBytes.length; i++) { [EOL]             assertEquals(realBytes[i], testBytes[i]); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSerializeBytes() throws Exception { [EOL]         final byte[] testBytes = SerializationUtils.serialize(iMap); [EOL]  [EOL]         final ByteArrayOutputStream streamReal = new ByteArrayOutputStream(); [EOL]         final ObjectOutputStream oos = new ObjectOutputStream(streamReal); [EOL]         oos.writeObject(iMap); [EOL]         oos.flush(); [EOL]         oos.close(); [EOL]  [EOL]         final byte[] realBytes = streamReal.toByteArray(); [EOL]         assertEquals(testBytes.length, realBytes.length); [EOL]         for (int i = 0; i < realBytes.length; i++) { [EOL]             assertEquals(realBytes[i], testBytes[i]); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSerializeBytes() throws Exception { [EOL]         final byte[] testBytes = SerializationUtils.serialize(iMap); [EOL]  [EOL]         final ByteArrayOutputStream streamReal = new ByteArrayOutputStream(); [EOL]         final ObjectOutputStream oos = new ObjectOutputStream(streamReal); [EOL]         oos.writeObject(iMap); [EOL]         oos.flush(); [EOL]         oos.close(); [EOL]  [EOL]         final byte[] realBytes = streamReal.toByteArray(); [EOL]         assertEquals(testBytes.length, realBytes.length); [EOL]         for (int i = 0; i < realBytes.length; i++) { [EOL]             assertEquals(realBytes[i], testBytes[i]); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSerializeBytes() throws Exception { [EOL]         final byte[] testBytes = SerializationUtils.serialize(iMap); [EOL]  [EOL]         final ByteArrayOutputStream streamReal = new ByteArrayOutputStream(); [EOL]         final ObjectOutputStream oos = new ObjectOutputStream(streamReal); [EOL]         oos.writeObject(iMap); [EOL]         oos.flush(); [EOL]         oos.close(); [EOL]  [EOL]         final byte[] realBytes = streamReal.toByteArray(); [EOL]         assertEquals(testBytes.length, realBytes.length); [EOL]         for (int i = 0; i < realBytes.length; i++) { [EOL]             assertEquals(realBytes[i], testBytes[i]); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testClone() throws Exception { [EOL]         final Object test = SerializationUtils.clone(iMap); [EOL]         assertNotNull(test); [EOL]         assertTrue(test instanceof HashMap<?,?>); [EOL]         assertTrue(test != iMap); [EOL]         final HashMap<?, ?> testMap = (HashMap<?, ?>) test; [EOL]         assertEquals(iString, testMap.get("FOO")); [EOL]         assertTrue(iString != testMap.get("FOO")); [EOL]         assertEquals(iInteger, testMap.get("BAR")); [EOL]         assertTrue(iInteger != testMap.get("BAR")); [EOL]         assertEquals(iMap, testMap); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testDeserializeBytesOfNull() throws Exception { [EOL]         final ByteArrayOutputStream streamReal = new ByteArrayOutputStream(); [EOL]         final ObjectOutputStream oos = new ObjectOutputStream(streamReal); [EOL]         oos.writeObject(null); [EOL]         oos.flush(); [EOL]         oos.close(); [EOL]  [EOL]         final Object test = SerializationUtils.deserialize(streamReal.toByteArray()); [EOL]         assertNull(test); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testClone() throws Exception { [EOL]         final Object test = SerializationUtils.clone(iMap); [EOL]         assertNotNull(test); [EOL]         assertTrue(test instanceof HashMap<?,?>); [EOL]         assertTrue(test != iMap); [EOL]         final HashMap<?, ?> testMap = (HashMap<?, ?>) test; [EOL]         assertEquals(iString, testMap.get("FOO")); [EOL]         assertTrue(iString != testMap.get("FOO")); [EOL]         assertEquals(iInteger, testMap.get("BAR")); [EOL]         assertTrue(iInteger != testMap.get("BAR")); [EOL]         assertEquals(iMap, testMap); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testDeserializeBytesOfNull() throws Exception { [EOL]         final ByteArrayOutputStream streamReal = new ByteArrayOutputStream(); [EOL]         final ObjectOutputStream oos = new ObjectOutputStream(streamReal); [EOL]         oos.writeObject(null); [EOL]         oos.flush(); [EOL]         oos.close(); [EOL]  [EOL]         final Object test = SerializationUtils.deserialize(streamReal.toByteArray()); [EOL]         assertNull(test); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testClone() throws Exception { [EOL]         final Object test = SerializationUtils.clone(iMap); [EOL]         assertNotNull(test); [EOL]         assertTrue(test instanceof HashMap<?,?>); [EOL]         assertTrue(test != iMap); [EOL]         final HashMap<?, ?> testMap = (HashMap<?, ?>) test; [EOL]         assertEquals(iString, testMap.get("FOO")); [EOL]         assertTrue(iString != testMap.get("FOO")); [EOL]         assertEquals(iInteger, testMap.get("BAR")); [EOL]         assertTrue(iInteger != testMap.get("BAR")); [EOL]         assertEquals(iMap, testMap); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSerialization() throws IOException, ClassNotFoundException, PropertyVetoException { [EOL]         final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); [EOL]         listenerSupport.addListener(new VetoableChangeListener() { [EOL]              [EOL]             @Override [EOL]             public void vetoableChange(final PropertyChangeEvent e) { [EOL]             } [EOL]         }); [EOL]         listenerSupport.addListener(EasyMock.createNiceMock(VetoableChangeListener.class)); [EOL]  [EOL]         //serialize: [EOL]         final ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); [EOL]         final ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream); [EOL]  [EOL]         objectOutputStream.writeObject(listenerSupport); [EOL]         objectOutputStream.close(); [EOL]  [EOL]         //deserialize: [EOL]         @SuppressWarnings("unchecked") [EOL]         final [EOL]         EventListenerSupport<VetoableChangeListener> deserializedListenerSupport = (EventListenerSupport<VetoableChangeListener>) new ObjectInputStream( [EOL]                 new ByteArrayInputStream(outputStream.toByteArray())).readObject(); [EOL]  [EOL]     
@Test [EOL]     public void testDeserializeBytesOfNull() throws Exception { [EOL]         final ByteArrayOutputStream streamReal = new ByteArrayOutputStream(); [EOL]         final ObjectOutputStream oos = new ObjectOutputStream(streamReal); [EOL]         oos.writeObject(null); [EOL]         oos.flush(); [EOL]         oos.close(); [EOL]  [EOL]         final Object test = SerializationUtils.deserialize(streamReal.toByteArray()); [EOL]         assertNull(test); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testDeserializeBytesOfNull() throws Exception { [EOL]         final ByteArrayOutputStream streamReal = new ByteArrayOutputStream(); [EOL]         final ObjectOutputStream oos = new ObjectOutputStream(streamReal); [EOL]         oos.writeObject(null); [EOL]         oos.flush(); [EOL]         oos.close(); [EOL]  [EOL]         final Object test = SerializationUtils.deserialize(streamReal.toByteArray()); [EOL]         assertNull(test); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSerialization() throws IOException, ClassNotFoundException, PropertyVetoException { [EOL]         final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); [EOL]         listenerSupport.addListener(new VetoableChangeListener() { [EOL]              [EOL]             @Override [EOL]             public void vetoableChange(final PropertyChangeEvent e) { [EOL]             } [EOL]         }); [EOL]         listenerSupport.addListener(EasyMock.createNiceMock(VetoableChangeListener.class)); [EOL]  [EOL]         //serialize: [EOL]         final ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); [EOL]         final ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream); [EOL]  [EOL]         objectOutputStream.writeObject(listenerSupport); [EOL]         objectOutputStream.close(); [EOL]  [EOL]         //deserialize: [EOL]         @SuppressWarnings("unchecked") [EOL]         final [EOL]         EventListenerSupport<VetoableChangeListener> deserializedListenerSupport = (EventListenerSupport<VetoableChangeListener>) new ObjectInputStream( [EOL]                 new ByteArrayInputStream(outputStream.toByteArray())).readObject(); [EOL]  [EOL]     
@Test [EOL]     public void testSerialization() throws IOException, ClassNotFoundException, PropertyVetoException { [EOL]         final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); [EOL]         listenerSupport.addListener(new VetoableChangeListener() { [EOL]              [EOL]             @Override [EOL]             public void vetoableChange(final PropertyChangeEvent e) { [EOL]             } [EOL]         }); [EOL]         listenerSupport.addListener(EasyMock.createNiceMock(VetoableChangeListener.class)); [EOL]  [EOL]         //serialize: [EOL]         final ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); [EOL]         final ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream); [EOL]  [EOL]         objectOutputStream.writeObject(listenerSupport); [EOL]         objectOutputStream.close(); [EOL]  [EOL]         //deserialize: [EOL]         @SuppressWarnings("unchecked") [EOL]         final [EOL]         EventListenerSupport<VetoableChangeListener> deserializedListenerSupport = (EventListenerSupport<VetoableChangeListener>) new ObjectInputStream( [EOL]                 new ByteArrayInputStream(outputStream.toByteArray())).readObject(); [EOL]  [EOL]     
@Test [EOL]     public void testSerialization() throws IOException, ClassNotFoundException, PropertyVetoException { [EOL]         final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); [EOL]         listenerSupport.addListener(new VetoableChangeListener() { [EOL]              [EOL]             @Override [EOL]             public void vetoableChange(final PropertyChangeEvent e) { [EOL]             } [EOL]         }); [EOL]         listenerSupport.addListener(EasyMock.createNiceMock(VetoableChangeListener.class)); [EOL]  [EOL]         //serialize: [EOL]         final ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); [EOL]         final ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream); [EOL]  [EOL]         objectOutputStream.writeObject(listenerSupport); [EOL]         objectOutputStream.close(); [EOL]  [EOL]         //deserialize: [EOL]         @SuppressWarnings("unchecked") [EOL]         final [EOL]         EventListenerSupport<VetoableChangeListener> deserializedListenerSupport = (EventListenerSupport<VetoableChangeListener>) new ObjectInputStream( [EOL]                 new ByteArrayInputStream(outputStream.toByteArray())).readObject(); [EOL]  [EOL]     
@Test [EOL]     public void testInvokeMethod() throws Exception { [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 (Object[]) ArrayUtils.EMPTY_CLASS_ARRAY)); [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 (Object[]) null)); [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo",  [EOL]                 (Object[]) null, (Class<?>[]) null)); [EOL]         assertEquals("foo(String)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 "")); [EOL]         assertEquals("foo(Object)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 new Object())); [EOL]         assertEquals("foo(Object)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 Boolean.TRUE)); [EOL]         assertEquals("foo(Integer)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.INTEGER_ONE)); [EOL]         assertEquals("foo(int)", MethodUtils.invokeMethod(testBean, "foo", [EOL]       
@Test [EOL]     public void testInvokeMethod() throws Exception { [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 (Object[]) ArrayUtils.EMPTY_CLASS_ARRAY)); [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 (Object[]) null)); [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo",  [EOL]                 (Object[]) null, (Class<?>[]) null)); [EOL]         assertEquals("foo(String)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 "")); [EOL]         assertEquals("foo(Object)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 new Object())); [EOL]         assertEquals("foo(Object)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 Boolean.TRUE)); [EOL]         assertEquals("foo(Integer)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.INTEGER_ONE)); [EOL]         assertEquals("foo(int)", MethodUtils.invokeMethod(testBean, "foo", [EOL]       
@Test [EOL]     public void testAddEventListenerThrowsException() [EOL]     { [EOL]         final ExceptionEventSource src = new ExceptionEventSource(); [EOL]         try [EOL]         { [EOL]             EventUtils.addEventListener(src, PropertyChangeListener.class, new PropertyChangeListener() [EOL]             { [EOL]                 @Override [EOL]                 public void propertyChange(final PropertyChangeEvent e) [EOL]                 { [EOL]                     // Do nothing! [EOL]                 } [EOL]             }); [EOL]             fail("Add method should have thrown an exception, so method should fail."); [EOL]         } [EOL]         catch (final RuntimeException e) [EOL]         { [EOL]  [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testAddEventListenerThrowsException() [EOL]     { [EOL]         final ExceptionEventSource src = new ExceptionEventSource(); [EOL]         try [EOL]         { [EOL]             EventUtils.addEventListener(src, PropertyChangeListener.class, new PropertyChangeListener() [EOL]             { [EOL]                 @Override [EOL]                 public void propertyChange(final PropertyChangeEvent e) [EOL]                 { [EOL]                     // Do nothing! [EOL]                 } [EOL]             }); [EOL]             fail("Add method should have thrown an exception, so method should fail."); [EOL]         } [EOL]         catch (final RuntimeException e) [EOL]         { [EOL]  [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testAddEventListenerWithNoAddMethod() [EOL]     { [EOL]         final PropertyChangeSource src = new PropertyChangeSource(); [EOL]         final EventCountingInvociationHandler handler = new EventCountingInvociationHandler(); [EOL]         final ObjectChangeListener listener = handler.createListener(ObjectChangeListener.class); [EOL]         try [EOL]         { [EOL]             EventUtils.addEventListener(src, ObjectChangeListener.class, listener); [EOL]             fail("Should not be allowed to add a listener to an object that doesn't support it."); [EOL]         } [EOL]         catch (final IllegalArgumentException e) [EOL]         { [EOL]             assertEquals("Class " + src.getClass().getName() + " does not have a public add" + ObjectChangeListener.class.getSimpleName() + " method which takes a parameter of type " + ObjectChangeListener.class.getName() + ".", e.getMessage()); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testAddEventListenerThrowsException() [EOL]     { [EOL]         final ExceptionEventSource src = new ExceptionEventSource(); [EOL]         try [EOL]         { [EOL]             EventUtils.addEventListener(src, PropertyChangeListener.class, new PropertyChangeListener() [EOL]             { [EOL]                 @Override [EOL]                 public void propertyChange(final PropertyChangeEvent e) [EOL]                 { [EOL]                     // Do nothing! [EOL]                 } [EOL]             }); [EOL]             fail("Add method should have thrown an exception, so method should fail."); [EOL]         } [EOL]         catch (final RuntimeException e) [EOL]         { [EOL]  [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsNumber() { [EOL]         String val = "12345"; [EOL]         assertTrue("isNumber(String) 1 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 1 failed", checkCreateNumber(val)); [EOL]         val = "1234.5"; [EOL]         assertTrue("isNumber(String) 2 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 2 failed", checkCreateNumber(val)); [EOL]         val = ".12345"; [EOL]         assertTrue("isNumber(String) 3 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 3 failed", checkCreateNumber(val)); [EOL]         val = "1234E5"; [EOL]         assertTrue("isNumber(String) 4 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 4 failed", checkCreateNumber(val)); [EOL]         val = "1234E+5"; [EOL]         assertTrue("isNumber(String) 5 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 5 failed", checkCreateNumber(val)); [EOL]         val = "1234E-5"; [EOL]         assertTrue("isNumber(String) 6 failed", NumberUtils.isNumber(val));
@Test [EOL]     public void testCreateNumberMagnitude() { [EOL]         // Test Float.MAX_VALUE, and same with +1 in final digit to check conversion changes to next Number type [EOL]         assertEquals(Float.valueOf(Float.MAX_VALUE),  NumberUtils.createNumber("3.4028235e+38")); [EOL]         assertEquals(Double.valueOf(3.4028236e+38),   NumberUtils.createNumber("3.4028236e+38")); [EOL]  [EOL]         // Test Double.MAX_VALUE [EOL]         assertEquals(Double.valueOf(Double.MAX_VALUE),          NumberUtils.createNumber("1.7976931348623157e+308")); [EOL]         // Test with +2 in final digit (+1 does not cause roll-over to BigDecimal) [EOL]         assertEquals(new BigDecimal("1.7976931348623159e+308"), NumberUtils.createNumber("1.7976931348623159e+308")); [EOL]  [EOL]         assertEquals(Integer.valueOf(0x12345678), NumberUtils.createNumber("0x12345678")); [EOL]         assertEquals(Long.valueOf(0x123456789L),  NumberUtils.createNumber("0x123456789")); [EOL]  [EOL]         assertEquals(Long.valueOf(0x7fffffffffffffffL),      NumberUtils.createNumber("0x7fffffffffffffff")); [EOL]         // Does not appear to be a way to create a literal BigInteger of this magnitude [EOL]   
@Test [EOL]     public void testIsNumber() { [EOL]         String val = "12345"; [EOL]         assertTrue("isNumber(String) 1 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 1 failed", checkCreateNumber(val)); [EOL]         val = "1234.5"; [EOL]         assertTrue("isNumber(String) 2 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 2 failed", checkCreateNumber(val)); [EOL]         val = ".12345"; [EOL]         assertTrue("isNumber(String) 3 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 3 failed", checkCreateNumber(val)); [EOL]         val = "1234E5"; [EOL]         assertTrue("isNumber(String) 4 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 4 failed", checkCreateNumber(val)); [EOL]         val = "1234E+5"; [EOL]         assertTrue("isNumber(String) 5 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 5 failed", checkCreateNumber(val)); [EOL]         val = "1234E-5"; [EOL]         assertTrue("isNumber(String) 6 failed", NumberUtils.isNumber(val));
@Test [EOL]     public void testIsNumber() { [EOL]         String val = "12345"; [EOL]         assertTrue("isNumber(String) 1 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 1 failed", checkCreateNumber(val)); [EOL]         val = "1234.5"; [EOL]         assertTrue("isNumber(String) 2 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 2 failed", checkCreateNumber(val)); [EOL]         val = ".12345"; [EOL]         assertTrue("isNumber(String) 3 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 3 failed", checkCreateNumber(val)); [EOL]         val = "1234E5"; [EOL]         assertTrue("isNumber(String) 4 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 4 failed", checkCreateNumber(val)); [EOL]         val = "1234E+5"; [EOL]         assertTrue("isNumber(String) 5 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 5 failed", checkCreateNumber(val)); [EOL]         val = "1234E-5"; [EOL]         assertTrue("isNumber(String) 6 failed", NumberUtils.isNumber(val));
@Test [EOL]     public void testIsNumber() { [EOL]         String val = "12345"; [EOL]         assertTrue("isNumber(String) 1 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 1 failed", checkCreateNumber(val)); [EOL]         val = "1234.5"; [EOL]         assertTrue("isNumber(String) 2 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 2 failed", checkCreateNumber(val)); [EOL]         val = ".12345"; [EOL]         assertTrue("isNumber(String) 3 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 3 failed", checkCreateNumber(val)); [EOL]         val = "1234E5"; [EOL]         assertTrue("isNumber(String) 4 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 4 failed", checkCreateNumber(val)); [EOL]         val = "1234E+5"; [EOL]         assertTrue("isNumber(String) 5 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 5 failed", checkCreateNumber(val)); [EOL]         val = "1234E-5"; [EOL]         assertTrue("isNumber(String) 6 failed", NumberUtils.isNumber(val));
@Test [EOL]     public void testIsNumber() { [EOL]         String val = "12345"; [EOL]         assertTrue("isNumber(String) 1 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 1 failed", checkCreateNumber(val)); [EOL]         val = "1234.5"; [EOL]         assertTrue("isNumber(String) 2 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 2 failed", checkCreateNumber(val)); [EOL]         val = ".12345"; [EOL]         assertTrue("isNumber(String) 3 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 3 failed", checkCreateNumber(val)); [EOL]         val = "1234E5"; [EOL]         assertTrue("isNumber(String) 4 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 4 failed", checkCreateNumber(val)); [EOL]         val = "1234E+5"; [EOL]         assertTrue("isNumber(String) 5 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 5 failed", checkCreateNumber(val)); [EOL]         val = "1234E-5"; [EOL]         assertTrue("isNumber(String) 6 failed", NumberUtils.isNumber(val));
@Test [EOL]     public void testCreateNumberMagnitude() { [EOL]         // Test Float.MAX_VALUE, and same with +1 in final digit to check conversion changes to next Number type [EOL]         assertEquals(Float.valueOf(Float.MAX_VALUE),  NumberUtils.createNumber("3.4028235e+38")); [EOL]         assertEquals(Double.valueOf(3.4028236e+38),   NumberUtils.createNumber("3.4028236e+38")); [EOL]  [EOL]         // Test Double.MAX_VALUE [EOL]         assertEquals(Double.valueOf(Double.MAX_VALUE),          NumberUtils.createNumber("1.7976931348623157e+308")); [EOL]         // Test with +2 in final digit (+1 does not cause roll-over to BigDecimal) [EOL]         assertEquals(new BigDecimal("1.7976931348623159e+308"), NumberUtils.createNumber("1.7976931348623159e+308")); [EOL]  [EOL]         assertEquals(Integer.valueOf(0x12345678), NumberUtils.createNumber("0x12345678")); [EOL]         assertEquals(Long.valueOf(0x123456789L),  NumberUtils.createNumber("0x123456789")); [EOL]  [EOL]         assertEquals(Long.valueOf(0x7fffffffffffffffL),      NumberUtils.createNumber("0x7fffffffffffffff")); [EOL]         // Does not appear to be a way to create a literal BigInteger of this magnitude [EOL]   
@Test [EOL]     public void testIsNumber() { [EOL]         String val = "12345"; [EOL]         assertTrue("isNumber(String) 1 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 1 failed", checkCreateNumber(val)); [EOL]         val = "1234.5"; [EOL]         assertTrue("isNumber(String) 2 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 2 failed", checkCreateNumber(val)); [EOL]         val = ".12345"; [EOL]         assertTrue("isNumber(String) 3 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 3 failed", checkCreateNumber(val)); [EOL]         val = "1234E5"; [EOL]         assertTrue("isNumber(String) 4 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 4 failed", checkCreateNumber(val)); [EOL]         val = "1234E+5"; [EOL]         assertTrue("isNumber(String) 5 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 5 failed", checkCreateNumber(val)); [EOL]         val = "1234E-5"; [EOL]         assertTrue("isNumber(String) 6 failed", NumberUtils.isNumber(val));
@Test [EOL]     public void testIsNumber() { [EOL]         String val = "12345"; [EOL]         assertTrue("isNumber(String) 1 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 1 failed", checkCreateNumber(val)); [EOL]         val = "1234.5"; [EOL]         assertTrue("isNumber(String) 2 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 2 failed", checkCreateNumber(val)); [EOL]         val = ".12345"; [EOL]         assertTrue("isNumber(String) 3 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 3 failed", checkCreateNumber(val)); [EOL]         val = "1234E5"; [EOL]         assertTrue("isNumber(String) 4 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 4 failed", checkCreateNumber(val)); [EOL]         val = "1234E+5"; [EOL]         assertTrue("isNumber(String) 5 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 5 failed", checkCreateNumber(val)); [EOL]         val = "1234E-5"; [EOL]         assertTrue("isNumber(String) 6 failed", NumberUtils.isNumber(val));
@Test [EOL]     public void testStringCreateNumberEnsureNoPrecisionLoss(){ [EOL]         String shouldBeFloat = "1.23"; [EOL]         String shouldBeDouble = "3.40282354e+38"; [EOL]         String shouldBeBigDecimal = "1.797693134862315759e+308"; [EOL]          [EOL]         assertTrue(NumberUtils.createNumber(shouldBeFloat) instanceof Float); [EOL]         assertTrue(NumberUtils.createNumber(shouldBeDouble) instanceof Double); [EOL]         assertTrue(NumberUtils.createNumber(shouldBeBigDecimal) instanceof BigDecimal); [EOL]     } [EOL]     /** [EOL]      * Test for {@link NumberUtils#toDouble(String)}. [EOL]      */ [EOL]
@Test [EOL]     public void testIsNumber() { [EOL]         String val = "12345"; [EOL]         assertTrue("isNumber(String) 1 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 1 failed", checkCreateNumber(val)); [EOL]         val = "1234.5"; [EOL]         assertTrue("isNumber(String) 2 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 2 failed", checkCreateNumber(val)); [EOL]         val = ".12345"; [EOL]         assertTrue("isNumber(String) 3 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 3 failed", checkCreateNumber(val)); [EOL]         val = "1234E5"; [EOL]         assertTrue("isNumber(String) 4 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 4 failed", checkCreateNumber(val)); [EOL]         val = "1234E+5"; [EOL]         assertTrue("isNumber(String) 5 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 5 failed", checkCreateNumber(val)); [EOL]         val = "1234E-5"; [EOL]         assertTrue("isNumber(String) 6 failed", NumberUtils.isNumber(val));
@Test [EOL]     public void testIsNumber() { [EOL]         String val = "12345"; [EOL]         assertTrue("isNumber(String) 1 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 1 failed", checkCreateNumber(val)); [EOL]         val = "1234.5"; [EOL]         assertTrue("isNumber(String) 2 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 2 failed", checkCreateNumber(val)); [EOL]         val = ".12345"; [EOL]         assertTrue("isNumber(String) 3 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 3 failed", checkCreateNumber(val)); [EOL]         val = "1234E5"; [EOL]         assertTrue("isNumber(String) 4 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 4 failed", checkCreateNumber(val)); [EOL]         val = "1234E+5"; [EOL]         assertTrue("isNumber(String) 5 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 5 failed", checkCreateNumber(val)); [EOL]         val = "1234E-5"; [EOL]         assertTrue("isNumber(String) 6 failed", NumberUtils.isNumber(val));
@Test [EOL]     public void testStringCreateNumberEnsureNoPrecisionLoss(){ [EOL]         String shouldBeFloat = "1.23"; [EOL]         String shouldBeDouble = "3.40282354e+38"; [EOL]         String shouldBeBigDecimal = "1.797693134862315759e+308"; [EOL]          [EOL]         assertTrue(NumberUtils.createNumber(shouldBeFloat) instanceof Float); [EOL]         assertTrue(NumberUtils.createNumber(shouldBeDouble) instanceof Double); [EOL]         assertTrue(NumberUtils.createNumber(shouldBeBigDecimal) instanceof BigDecimal); [EOL]     } [EOL]     /** [EOL]      * Test for {@link NumberUtils#toDouble(String)}. [EOL]      */ [EOL]
@Test [EOL]     public void testIsNumber() { [EOL]         String val = "12345"; [EOL]         assertTrue("isNumber(String) 1 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 1 failed", checkCreateNumber(val)); [EOL]         val = "1234.5"; [EOL]         assertTrue("isNumber(String) 2 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 2 failed", checkCreateNumber(val)); [EOL]         val = ".12345"; [EOL]         assertTrue("isNumber(String) 3 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 3 failed", checkCreateNumber(val)); [EOL]         val = "1234E5"; [EOL]         assertTrue("isNumber(String) 4 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 4 failed", checkCreateNumber(val)); [EOL]         val = "1234E+5"; [EOL]         assertTrue("isNumber(String) 5 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 5 failed", checkCreateNumber(val)); [EOL]         val = "1234E-5"; [EOL]         assertTrue("isNumber(String) 6 failed", NumberUtils.isNumber(val));
@Test [EOL]     public void testStringCreateNumberEnsureNoPrecisionLoss(){ [EOL]         String shouldBeFloat = "1.23"; [EOL]         String shouldBeDouble = "3.40282354e+38"; [EOL]         String shouldBeBigDecimal = "1.797693134862315759e+308"; [EOL]          [EOL]         assertTrue(NumberUtils.createNumber(shouldBeFloat) instanceof Float); [EOL]         assertTrue(NumberUtils.createNumber(shouldBeDouble) instanceof Double); [EOL]         assertTrue(NumberUtils.createNumber(shouldBeBigDecimal) instanceof BigDecimal); [EOL]     } [EOL]     /** [EOL]      * Test for {@link NumberUtils#toDouble(String)}. [EOL]      */ [EOL]
@Test [EOL]     public void testIsNumber() { [EOL]         String val = "12345"; [EOL]         assertTrue("isNumber(String) 1 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 1 failed", checkCreateNumber(val)); [EOL]         val = "1234.5"; [EOL]         assertTrue("isNumber(String) 2 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 2 failed", checkCreateNumber(val)); [EOL]         val = ".12345"; [EOL]         assertTrue("isNumber(String) 3 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 3 failed", checkCreateNumber(val)); [EOL]         val = "1234E5"; [EOL]         assertTrue("isNumber(String) 4 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 4 failed", checkCreateNumber(val)); [EOL]         val = "1234E+5"; [EOL]         assertTrue("isNumber(String) 5 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 5 failed", checkCreateNumber(val)); [EOL]         val = "1234E-5"; [EOL]         assertTrue("isNumber(String) 6 failed", NumberUtils.isNumber(val));
@Test [EOL]     public void testCreateNumberMagnitude() { [EOL]         // Test Float.MAX_VALUE, and same with +1 in final digit to check conversion changes to next Number type [EOL]         assertEquals(Float.valueOf(Float.MAX_VALUE),  NumberUtils.createNumber("3.4028235e+38")); [EOL]         assertEquals(Double.valueOf(3.4028236e+38),   NumberUtils.createNumber("3.4028236e+38")); [EOL]  [EOL]         // Test Double.MAX_VALUE [EOL]         assertEquals(Double.valueOf(Double.MAX_VALUE),          NumberUtils.createNumber("1.7976931348623157e+308")); [EOL]         // Test with +2 in final digit (+1 does not cause roll-over to BigDecimal) [EOL]         assertEquals(new BigDecimal("1.7976931348623159e+308"), NumberUtils.createNumber("1.7976931348623159e+308")); [EOL]  [EOL]         assertEquals(Integer.valueOf(0x12345678), NumberUtils.createNumber("0x12345678")); [EOL]         assertEquals(Long.valueOf(0x123456789L),  NumberUtils.createNumber("0x123456789")); [EOL]  [EOL]         assertEquals(Long.valueOf(0x7fffffffffffffffL),      NumberUtils.createNumber("0x7fffffffffffffff")); [EOL]         // Does not appear to be a way to create a literal BigInteger of this magnitude [EOL]   
@Test [EOL]     public void testCreateNumberMagnitude() { [EOL]         // Test Float.MAX_VALUE, and same with +1 in final digit to check conversion changes to next Number type [EOL]         assertEquals(Float.valueOf(Float.MAX_VALUE),  NumberUtils.createNumber("3.4028235e+38")); [EOL]         assertEquals(Double.valueOf(3.4028236e+38),   NumberUtils.createNumber("3.4028236e+38")); [EOL]  [EOL]         // Test Double.MAX_VALUE [EOL]         assertEquals(Double.valueOf(Double.MAX_VALUE),          NumberUtils.createNumber("1.7976931348623157e+308")); [EOL]         // Test with +2 in final digit (+1 does not cause roll-over to BigDecimal) [EOL]         assertEquals(new BigDecimal("1.7976931348623159e+308"), NumberUtils.createNumber("1.7976931348623159e+308")); [EOL]  [EOL]         assertEquals(Integer.valueOf(0x12345678), NumberUtils.createNumber("0x12345678")); [EOL]         assertEquals(Long.valueOf(0x123456789L),  NumberUtils.createNumber("0x123456789")); [EOL]  [EOL]         assertEquals(Long.valueOf(0x7fffffffffffffffL),      NumberUtils.createNumber("0x7fffffffffffffff")); [EOL]         // Does not appear to be a way to create a literal BigInteger of this magnitude [EOL]   
@Test [EOL]     public void testStringCreateNumberEnsureNoPrecisionLoss(){ [EOL]         String shouldBeFloat = "1.23"; [EOL]         String shouldBeDouble = "3.40282354e+38"; [EOL]         String shouldBeBigDecimal = "1.797693134862315759e+308"; [EOL]          [EOL]         assertTrue(NumberUtils.createNumber(shouldBeFloat) instanceof Float); [EOL]         assertTrue(NumberUtils.createNumber(shouldBeDouble) instanceof Double); [EOL]         assertTrue(NumberUtils.createNumber(shouldBeBigDecimal) instanceof BigDecimal); [EOL]     } [EOL]     /** [EOL]      * Test for {@link NumberUtils#toDouble(String)}. [EOL]      */ [EOL]
@Test [EOL]     public void testStringCreateNumberEnsureNoPrecisionLoss(){ [EOL]         String shouldBeFloat = "1.23"; [EOL]         String shouldBeDouble = "3.40282354e+38"; [EOL]         String shouldBeBigDecimal = "1.797693134862315759e+308"; [EOL]          [EOL]         assertTrue(NumberUtils.createNumber(shouldBeFloat) instanceof Float); [EOL]         assertTrue(NumberUtils.createNumber(shouldBeDouble) instanceof Double); [EOL]         assertTrue(NumberUtils.createNumber(shouldBeBigDecimal) instanceof BigDecimal); [EOL]     } [EOL]     /** [EOL]      * Test for {@link NumberUtils#toDouble(String)}. [EOL]      */ [EOL]
@Test [EOL]     public void testIsNumber() { [EOL]         String val = "12345"; [EOL]         assertTrue("isNumber(String) 1 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 1 failed", checkCreateNumber(val)); [EOL]         val = "1234.5"; [EOL]         assertTrue("isNumber(String) 2 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 2 failed", checkCreateNumber(val)); [EOL]         val = ".12345"; [EOL]         assertTrue("isNumber(String) 3 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 3 failed", checkCreateNumber(val)); [EOL]         val = "1234E5"; [EOL]         assertTrue("isNumber(String) 4 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 4 failed", checkCreateNumber(val)); [EOL]         val = "1234E+5"; [EOL]         assertTrue("isNumber(String) 5 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 5 failed", checkCreateNumber(val)); [EOL]         val = "1234E-5"; [EOL]         assertTrue("isNumber(String) 6 failed", NumberUtils.isNumber(val));
@Test [EOL]     public void testStringCreateNumberEnsureNoPrecisionLoss(){ [EOL]         String shouldBeFloat = "1.23"; [EOL]         String shouldBeDouble = "3.40282354e+38"; [EOL]         String shouldBeBigDecimal = "1.797693134862315759e+308"; [EOL]          [EOL]         assertTrue(NumberUtils.createNumber(shouldBeFloat) instanceof Float); [EOL]         assertTrue(NumberUtils.createNumber(shouldBeDouble) instanceof Double); [EOL]         assertTrue(NumberUtils.createNumber(shouldBeBigDecimal) instanceof BigDecimal); [EOL]     } [EOL]     /** [EOL]      * Test for {@link NumberUtils#toDouble(String)}. [EOL]      */ [EOL]
@Test [EOL]     public void testIsNumber() { [EOL]         String val = "12345"; [EOL]         assertTrue("isNumber(String) 1 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 1 failed", checkCreateNumber(val)); [EOL]         val = "1234.5"; [EOL]         assertTrue("isNumber(String) 2 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 2 failed", checkCreateNumber(val)); [EOL]         val = ".12345"; [EOL]         assertTrue("isNumber(String) 3 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 3 failed", checkCreateNumber(val)); [EOL]         val = "1234E5"; [EOL]         assertTrue("isNumber(String) 4 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 4 failed", checkCreateNumber(val)); [EOL]         val = "1234E+5"; [EOL]         assertTrue("isNumber(String) 5 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 5 failed", checkCreateNumber(val)); [EOL]         val = "1234E-5"; [EOL]         assertTrue("isNumber(String) 6 failed", NumberUtils.isNumber(val));
@Test [EOL]     public void testStringCreateNumberEnsureNoPrecisionLoss(){ [EOL]         String shouldBeFloat = "1.23"; [EOL]         String shouldBeDouble = "3.40282354e+38"; [EOL]         String shouldBeBigDecimal = "1.797693134862315759e+308"; [EOL]          [EOL]         assertTrue(NumberUtils.createNumber(shouldBeFloat) instanceof Float); [EOL]         assertTrue(NumberUtils.createNumber(shouldBeDouble) instanceof Double); [EOL]         assertTrue(NumberUtils.createNumber(shouldBeBigDecimal) instanceof BigDecimal); [EOL]     } [EOL]     /** [EOL]      * Test for {@link NumberUtils#toDouble(String)}. [EOL]      */ [EOL]
@Test [EOL]     public void testIsDigits() { [EOL]         assertFalse("isDigits(null) failed", NumberUtils.isDigits(null)); [EOL]         assertFalse("isDigits('') failed", NumberUtils.isDigits("")); [EOL]         assertTrue("isDigits(String) failed", NumberUtils.isDigits("12345")); [EOL]         assertFalse("isDigits(String) neg 1 failed", NumberUtils.isDigits("1234.5")); [EOL]         assertFalse("isDigits(String) neg 3 failed", NumberUtils.isDigits("1ab")); [EOL]         assertFalse("isDigits(String) neg 4 failed", NumberUtils.isDigits("abc")); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests isNumber(String) and tests that createNumber(String) returns [EOL]      * a valid number iff isNumber(String) returns false. [EOL]      */ [EOL]
@Test [EOL]     public void testIsNumber() { [EOL]         String val = "12345"; [EOL]         assertTrue("isNumber(String) 1 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 1 failed", checkCreateNumber(val)); [EOL]         val = "1234.5"; [EOL]         assertTrue("isNumber(String) 2 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 2 failed", checkCreateNumber(val)); [EOL]         val = ".12345"; [EOL]         assertTrue("isNumber(String) 3 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 3 failed", checkCreateNumber(val)); [EOL]         val = "1234E5"; [EOL]         assertTrue("isNumber(String) 4 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 4 failed", checkCreateNumber(val)); [EOL]         val = "1234E+5"; [EOL]         assertTrue("isNumber(String) 5 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 5 failed", checkCreateNumber(val)); [EOL]         val = "1234E-5"; [EOL]         assertTrue("isNumber(String) 6 failed", NumberUtils.isNumber(val));
@Test [EOL]     public void testIsNumber() { [EOL]         String val = "12345"; [EOL]         assertTrue("isNumber(String) 1 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 1 failed", checkCreateNumber(val)); [EOL]         val = "1234.5"; [EOL]         assertTrue("isNumber(String) 2 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 2 failed", checkCreateNumber(val)); [EOL]         val = ".12345"; [EOL]         assertTrue("isNumber(String) 3 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 3 failed", checkCreateNumber(val)); [EOL]         val = "1234E5"; [EOL]         assertTrue("isNumber(String) 4 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 4 failed", checkCreateNumber(val)); [EOL]         val = "1234E+5"; [EOL]         assertTrue("isNumber(String) 5 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 5 failed", checkCreateNumber(val)); [EOL]         val = "1234E-5"; [EOL]         assertTrue("isNumber(String) 6 failed", NumberUtils.isNumber(val));
@Test [EOL]     public void testIsNumber() { [EOL]         String val = "12345"; [EOL]         assertTrue("isNumber(String) 1 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 1 failed", checkCreateNumber(val)); [EOL]         val = "1234.5"; [EOL]         assertTrue("isNumber(String) 2 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 2 failed", checkCreateNumber(val)); [EOL]         val = ".12345"; [EOL]         assertTrue("isNumber(String) 3 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 3 failed", checkCreateNumber(val)); [EOL]         val = "1234E5"; [EOL]         assertTrue("isNumber(String) 4 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 4 failed", checkCreateNumber(val)); [EOL]         val = "1234E+5"; [EOL]         assertTrue("isNumber(String) 5 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 5 failed", checkCreateNumber(val)); [EOL]         val = "1234E-5"; [EOL]         assertTrue("isNumber(String) 6 failed", NumberUtils.isNumber(val));
@Test [EOL]     public void testIsNumber() { [EOL]         String val = "12345"; [EOL]         assertTrue("isNumber(String) 1 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 1 failed", checkCreateNumber(val)); [EOL]         val = "1234.5"; [EOL]         assertTrue("isNumber(String) 2 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 2 failed", checkCreateNumber(val)); [EOL]         val = ".12345"; [EOL]         assertTrue("isNumber(String) 3 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 3 failed", checkCreateNumber(val)); [EOL]         val = "1234E5"; [EOL]         assertTrue("isNumber(String) 4 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 4 failed", checkCreateNumber(val)); [EOL]         val = "1234E+5"; [EOL]         assertTrue("isNumber(String) 5 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 5 failed", checkCreateNumber(val)); [EOL]         val = "1234E-5"; [EOL]         assertTrue("isNumber(String) 6 failed", NumberUtils.isNumber(val));
@Test [EOL]     public void testIsNumber() { [EOL]         String val = "12345"; [EOL]         assertTrue("isNumber(String) 1 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 1 failed", checkCreateNumber(val)); [EOL]         val = "1234.5"; [EOL]         assertTrue("isNumber(String) 2 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 2 failed", checkCreateNumber(val)); [EOL]         val = ".12345"; [EOL]         assertTrue("isNumber(String) 3 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 3 failed", checkCreateNumber(val)); [EOL]         val = "1234E5"; [EOL]         assertTrue("isNumber(String) 4 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 4 failed", checkCreateNumber(val)); [EOL]         val = "1234E+5"; [EOL]         assertTrue("isNumber(String) 5 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 5 failed", checkCreateNumber(val)); [EOL]         val = "1234E-5"; [EOL]         assertTrue("isNumber(String) 6 failed", NumberUtils.isNumber(val));
@Test [EOL]     public void testIsNumber() { [EOL]         String val = "12345"; [EOL]         assertTrue("isNumber(String) 1 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 1 failed", checkCreateNumber(val)); [EOL]         val = "1234.5"; [EOL]         assertTrue("isNumber(String) 2 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 2 failed", checkCreateNumber(val)); [EOL]         val = ".12345"; [EOL]         assertTrue("isNumber(String) 3 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 3 failed", checkCreateNumber(val)); [EOL]         val = "1234E5"; [EOL]         assertTrue("isNumber(String) 4 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 4 failed", checkCreateNumber(val)); [EOL]         val = "1234E+5"; [EOL]         assertTrue("isNumber(String) 5 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 5 failed", checkCreateNumber(val)); [EOL]         val = "1234E-5"; [EOL]         assertTrue("isNumber(String) 6 failed", NumberUtils.isNumber(val));
@Test [EOL]     public void testIsNumber() { [EOL]         String val = "12345"; [EOL]         assertTrue("isNumber(String) 1 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 1 failed", checkCreateNumber(val)); [EOL]         val = "1234.5"; [EOL]         assertTrue("isNumber(String) 2 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 2 failed", checkCreateNumber(val)); [EOL]         val = ".12345"; [EOL]         assertTrue("isNumber(String) 3 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 3 failed", checkCreateNumber(val)); [EOL]         val = "1234E5"; [EOL]         assertTrue("isNumber(String) 4 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 4 failed", checkCreateNumber(val)); [EOL]         val = "1234E+5"; [EOL]         assertTrue("isNumber(String) 5 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 5 failed", checkCreateNumber(val)); [EOL]         val = "1234E-5"; [EOL]         assertTrue("isNumber(String) 6 failed", NumberUtils.isNumber(val));
@Test [EOL]     public void testCreateNumberMagnitude() { [EOL]         // Test Float.MAX_VALUE, and same with +1 in final digit to check conversion changes to next Number type [EOL]         assertEquals(Float.valueOf(Float.MAX_VALUE),  NumberUtils.createNumber("3.4028235e+38")); [EOL]         assertEquals(Double.valueOf(3.4028236e+38),   NumberUtils.createNumber("3.4028236e+38")); [EOL]  [EOL]         // Test Double.MAX_VALUE [EOL]         assertEquals(Double.valueOf(Double.MAX_VALUE),          NumberUtils.createNumber("1.7976931348623157e+308")); [EOL]         // Test with +2 in final digit (+1 does not cause roll-over to BigDecimal) [EOL]         assertEquals(new BigDecimal("1.7976931348623159e+308"), NumberUtils.createNumber("1.7976931348623159e+308")); [EOL]  [EOL]         assertEquals(Integer.valueOf(0x12345678), NumberUtils.createNumber("0x12345678")); [EOL]         assertEquals(Long.valueOf(0x123456789L),  NumberUtils.createNumber("0x123456789")); [EOL]  [EOL]         assertEquals(Long.valueOf(0x7fffffffffffffffL),      NumberUtils.createNumber("0x7fffffffffffffff")); [EOL]         // Does not appear to be a way to create a literal BigInteger of this magnitude [EOL]   
@Test [EOL]     public void testIsNumber() { [EOL]         String val = "12345"; [EOL]         assertTrue("isNumber(String) 1 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 1 failed", checkCreateNumber(val)); [EOL]         val = "1234.5"; [EOL]         assertTrue("isNumber(String) 2 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 2 failed", checkCreateNumber(val)); [EOL]         val = ".12345"; [EOL]         assertTrue("isNumber(String) 3 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 3 failed", checkCreateNumber(val)); [EOL]         val = "1234E5"; [EOL]         assertTrue("isNumber(String) 4 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 4 failed", checkCreateNumber(val)); [EOL]         val = "1234E+5"; [EOL]         assertTrue("isNumber(String) 5 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 5 failed", checkCreateNumber(val)); [EOL]         val = "1234E-5"; [EOL]         assertTrue("isNumber(String) 6 failed", NumberUtils.isNumber(val));
@Test [EOL]     public void testIsNumber() { [EOL]         String val = "12345"; [EOL]         assertTrue("isNumber(String) 1 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 1 failed", checkCreateNumber(val)); [EOL]         val = "1234.5"; [EOL]         assertTrue("isNumber(String) 2 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 2 failed", checkCreateNumber(val)); [EOL]         val = ".12345"; [EOL]         assertTrue("isNumber(String) 3 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 3 failed", checkCreateNumber(val)); [EOL]         val = "1234E5"; [EOL]         assertTrue("isNumber(String) 4 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 4 failed", checkCreateNumber(val)); [EOL]         val = "1234E+5"; [EOL]         assertTrue("isNumber(String) 5 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 5 failed", checkCreateNumber(val)); [EOL]         val = "1234E-5"; [EOL]         assertTrue("isNumber(String) 6 failed", NumberUtils.isNumber(val));
@Test [EOL]     public void testIsNumber() { [EOL]         String val = "12345"; [EOL]         assertTrue("isNumber(String) 1 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 1 failed", checkCreateNumber(val)); [EOL]         val = "1234.5"; [EOL]         assertTrue("isNumber(String) 2 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 2 failed", checkCreateNumber(val)); [EOL]         val = ".12345"; [EOL]         assertTrue("isNumber(String) 3 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 3 failed", checkCreateNumber(val)); [EOL]         val = "1234E5"; [EOL]         assertTrue("isNumber(String) 4 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 4 failed", checkCreateNumber(val)); [EOL]         val = "1234E+5"; [EOL]         assertTrue("isNumber(String) 5 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 5 failed", checkCreateNumber(val)); [EOL]         val = "1234E-5"; [EOL]         assertTrue("isNumber(String) 6 failed", NumberUtils.isNumber(val));
@Test [EOL]     public void testIsNumber() { [EOL]         String val = "12345"; [EOL]         assertTrue("isNumber(String) 1 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 1 failed", checkCreateNumber(val)); [EOL]         val = "1234.5"; [EOL]         assertTrue("isNumber(String) 2 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 2 failed", checkCreateNumber(val)); [EOL]         val = ".12345"; [EOL]         assertTrue("isNumber(String) 3 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 3 failed", checkCreateNumber(val)); [EOL]         val = "1234E5"; [EOL]         assertTrue("isNumber(String) 4 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 4 failed", checkCreateNumber(val)); [EOL]         val = "1234E+5"; [EOL]         assertTrue("isNumber(String) 5 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 5 failed", checkCreateNumber(val)); [EOL]         val = "1234E-5"; [EOL]         assertTrue("isNumber(String) 6 failed", NumberUtils.isNumber(val));
@Test [EOL]     public void testIsNumber() { [EOL]         String val = "12345"; [EOL]         assertTrue("isNumber(String) 1 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 1 failed", checkCreateNumber(val)); [EOL]         val = "1234.5"; [EOL]         assertTrue("isNumber(String) 2 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 2 failed", checkCreateNumber(val)); [EOL]         val = ".12345"; [EOL]         assertTrue("isNumber(String) 3 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 3 failed", checkCreateNumber(val)); [EOL]         val = "1234E5"; [EOL]         assertTrue("isNumber(String) 4 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 4 failed", checkCreateNumber(val)); [EOL]         val = "1234E+5"; [EOL]         assertTrue("isNumber(String) 5 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 5 failed", checkCreateNumber(val)); [EOL]         val = "1234E-5"; [EOL]         assertTrue("isNumber(String) 6 failed", NumberUtils.isNumber(val));
@Test [EOL]     public void testStripToNull_String() { [EOL]         assertEquals(null, StringUtils.stripToNull(null)); [EOL]         assertEquals(null, StringUtils.stripToNull("")); [EOL]         assertEquals(null, StringUtils.stripToNull("        ")); [EOL]         assertEquals(null, StringUtils.stripToNull(StringUtilsTest.WHITESPACE)); [EOL]         assertEquals("ab c", StringUtils.stripToNull("  ab c  ")); [EOL]         assertEquals(StringUtilsTest.NON_WHITESPACE,  [EOL]             StringUtils.stripToNull(StringUtilsTest.WHITESPACE + StringUtilsTest.NON_WHITESPACE + StringUtilsTest.WHITESPACE)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testStripAccents() { [EOL]         final String cue = "\u00C7\u00FA\u00EA"; [EOL]         assertEquals( "Failed to strip accents from " + cue, "Cue", StringUtils.stripAccents(cue)); [EOL]  [EOL]         final String lots = "\u00C0\u00C1\u00C2\u00C3\u00C4\u00C5\u00C7\u00C8\u00C9" +  [EOL]                       "\u00CA\u00CB\u00CC\u00CD\u00CE\u00CF\u00D1\u00D2\u00D3" +  [EOL]                       "\u00D4\u00D5\u00D6\u00D9\u00DA\u00DB\u00DC\u00DD"; [EOL]         assertEquals( "Failed to strip accents from " + lots,  [EOL]                       "AAAAAACEEEEIIIINOOOOOUUUUY",  [EOL]                       StringUtils.stripAccents(lots)); [EOL]  [EOL]         assertNull( "Failed null safety", StringUtils.stripAccents(null) ); [EOL]         assertEquals( "Failed empty String", "", StringUtils.stripAccents("") ); [EOL]         assertEquals( "Failed to handle non-accented text", "control", String
@Test [EOL]     public void testEquals() { [EOL]         final CharSequence fooCs = FOO, barCs = BAR, foobarCs = FOOBAR; [EOL]         assertTrue(StringUtils.equals(null, null)); [EOL]         assertTrue(StringUtils.equals(fooCs, fooCs)); [EOL]         assertTrue(StringUtils.equals(fooCs, new StringBuilder(FOO))); [EOL]         assertTrue(StringUtils.equals(fooCs, new String(new char[] { 'f', 'o', 'o' }))); [EOL]         assertTrue(StringUtils.equals(fooCs, new CustomCharSequence(FOO))); [EOL]         assertTrue(StringUtils.equals(new CustomCharSequence(FOO), fooCs)); [EOL]         assertFalse(StringUtils.equals(fooCs, new String(new char[] { 'f', 'O', 'O' }))); [EOL]         assertFalse(StringUtils.equals(fooCs, barCs)); [EOL]         assertFalse(StringUtils.equals(fooCs, null)); [EOL]         assertFalse(StringUtils.equals(null, fooCs)); [EOL]         assertFalse(StringUtils.equals(fooCs, foobarCs)); [EOL]         assertFalse(StringUtils.equals(foobarCs, fooCs)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEqualsIgnoreCase() { [EOL]         assertTrue(StringUtils.equalsIgnoreCase(null, null)); [EOL]         assertTrue(StringUtils.equalsIgnoreCase(FOO, FOO)); [EOL]         assertTrue(StringUtils.equalsIgnoreCase(FOO, new String(new char[] { 'f', 'o', 'o' }))); [EOL]         assertTrue(StringUtils.equalsIgnoreCase(FOO, new String(new char[] { 'f', 'O', 'O' }))); [EOL]         assertFalse(StringUtils.equalsIgnoreCase(FOO, BAR)); [EOL]         assertFalse(StringUtils.equalsIgnoreCase(FOO, null)); [EOL]         assertFalse(StringUtils.equalsIgnoreCase(null, FOO)); [EOL]         assertTrue(StringUtils.equalsIgnoreCase("","")); [EOL]         assertFalse(StringUtils.equalsIgnoreCase("abcd","abcd ")); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testIndexOf_String() { [EOL]         assertEquals(-1, StringUtils.indexOf(null, null)); [EOL]         assertEquals(-1, StringUtils.indexOf("", null)); [EOL]         assertEquals(0, StringUtils.indexOf("", "")); [EOL]         assertEquals(0, StringUtils.indexOf("aabaabaa", "a")); [EOL]         assertEquals(2, StringUtils.indexOf("aabaabaa", "b")); [EOL]         assertEquals(1, StringUtils.indexOf("aabaabaa", "ab")); [EOL]         assertEquals(0, StringUtils.indexOf("aabaabaa", "")); [EOL]  [EOL]         assertEquals(2, StringUtils.indexOf(new StringBuilder("aabaabaa"), "b")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testOrdinalIndexOf() { [EOL]         assertEquals(-1, StringUtils.ordinalIndexOf(null, null, Integer.MIN_VALUE)); [EOL]         assertEquals(-1, StringUtils.ordinalIndexOf("", null, Integer.MIN_VALUE)); [EOL]         assertEquals(-1, StringUtils.ordinalIndexOf("", "", Integer.MIN_VALUE)); [EOL]         assertEquals(-1, StringUtils.ordinalIndexOf("aabaabaa", "a", Integer.MIN_VALUE)); [EOL]         assertEquals(-1, StringUtils.ordinalIndexOf("aabaabaa", "b", Integer.MIN_VALUE)); [EOL]         assertEquals(-1, StringUtils.ordinalIndexOf("aabaabaa", "ab", Integer.MIN_VALUE)); [EOL]         assertEquals(-1, StringUtils.ordinalIndexOf("aabaabaa", "", Integer.MIN_VALUE)); [EOL]  [EOL]         assertEquals(-1, StringUtils.ordinalIndexOf(null, null, -1)); [EOL]         assertEquals(-1, StringUtils.ordinalIndexOf("", null, -1)); [EOL]         assertEquals(-1, StringUtils.ordinalIndexOf("", "", -1)); [EOL]         assertEquals(-1, StringUtils.ordinalIndexOf("aabaabaa", "a", -1)); [EOL]         assertEquals(-1, StringUtils.ordinalIndexOf("aabaabaa", "b", -1)); [EOL]         assertEquals(-1, StringUtils.ordinalIndexOf
@Test [EOL]     public void testIndexOfIgnoreCase_StringInt() { [EOL]         assertEquals(1, StringUtils.indexOfIgnoreCase("aabaabaa", "AB", -1)); [EOL]         assertEquals(1, StringUtils.indexOfIgnoreCase("aabaabaa", "AB", 0)); [EOL]         assertEquals(1, StringUtils.indexOfIgnoreCase("aabaabaa", "AB", 1)); [EOL]         assertEquals(4, StringUtils.indexOfIgnoreCase("aabaabaa", "AB", 2)); [EOL]         assertEquals(4, StringUtils.indexOfIgnoreCase("aabaabaa", "AB", 3)); [EOL]         assertEquals(4, StringUtils.indexOfIgnoreCase("aabaabaa", "AB", 4)); [EOL]         assertEquals(-1, StringUtils.indexOfIgnoreCase("aabaabaa", "AB", 5)); [EOL]         assertEquals(-1, StringUtils.indexOfIgnoreCase("aabaabaa", "AB", 6)); [EOL]         assertEquals(-1, StringUtils.indexOfIgnoreCase("aabaabaa", "AB", 7)); [EOL]         assertEquals(-1, StringUtils.indexOfIgnoreCase("aabaabaa", "AB", 8)); [EOL]         assertEquals(1, StringUtils.indexOfIgnoreCase("aab", "AB", 1)); [EOL]         assertEquals(5, StringUtils.indexOfIgnoreCase("aabaabaa", "", 5)); [EOL]         assertEquals(-1, StringUtils
@Test [EOL]     public void testLastIndexOf_StringInt() { [EOL]         assertEquals(-1, StringUtils.lastIndexOf(null, null, 0)); [EOL]         assertEquals(-1, StringUtils.lastIndexOf(null, null, -1)); [EOL]         assertEquals(-1, StringUtils.lastIndexOf(null, "", 0)); [EOL]         assertEquals(-1, StringUtils.lastIndexOf(null, "", -1)); [EOL]         assertEquals(-1, StringUtils.lastIndexOf("", null, 0)); [EOL]         assertEquals(-1, StringUtils.lastIndexOf("", null, -1)); [EOL]         assertEquals(0, StringUtils.lastIndexOf("", "", 0)); [EOL]         assertEquals(-1, StringUtils.lastIndexOf("", "", -1)); [EOL]         assertEquals(0, StringUtils.lastIndexOf("", "", 9)); [EOL]         assertEquals(0, StringUtils.lastIndexOf("abc", "", 0)); [EOL]         assertEquals(-1, StringUtils.lastIndexOf("abc", "", -1)); [EOL]         assertEquals(3, StringUtils.lastIndexOf("abc", "", 9)); [EOL]         assertEquals(7, StringUtils.lastIndexOf("aabaabaa", "a", 8)); [EOL]         assertEquals(5, StringUtils.lastIndexOf("aabaabaa", "b", 8)); [EOL]         assertEquals(4, StringUtils
@Test [EOL]     public void testLastIndexOfIgnoreCase_StringInt() { [EOL]         assertEquals(-1, StringUtils.lastIndexOfIgnoreCase(null, null, 0)); [EOL]         assertEquals(-1, StringUtils.lastIndexOfIgnoreCase(null, null, -1)); [EOL]         assertEquals(-1, StringUtils.lastIndexOfIgnoreCase(null, "", 0)); [EOL]         assertEquals(-1, StringUtils.lastIndexOfIgnoreCase(null, "", -1)); [EOL]         assertEquals(-1, StringUtils.lastIndexOfIgnoreCase("", null, 0)); [EOL]         assertEquals(-1, StringUtils.lastIndexOfIgnoreCase("", null, -1)); [EOL]         assertEquals(0, StringUtils.lastIndexOfIgnoreCase("", "", 0)); [EOL]         assertEquals(-1, StringUtils.lastIndexOfIgnoreCase("", "", -1)); [EOL]         assertEquals(0, StringUtils.lastIndexOfIgnoreCase("", "", 9)); [EOL]         assertEquals(0, StringUtils.lastIndexOfIgnoreCase("abc", "", 0)); [EOL]         assertEquals(-1, StringUtils.lastIndexOfIgnoreCase("abc", "", -1)); [EOL]         assertEquals(3, StringUtils.lastIndexOfIgnoreCase("abc", "", 9)); [EOL]         assertEquals(7, StringUtils.lastIndexOfIgnoreCase("aabaabaa", "A", 8)); [EOL]         assertEquals
@Test [EOL]     public void testIndexOfAny_StringStringWithSupplementaryChars() { [EOL]         assertEquals(0, StringUtils.indexOfAny(CharU20000 + CharU20001, CharU20000)); [EOL]         assertEquals(2, StringUtils.indexOfAny(CharU20000 + CharU20001, CharU20001)); [EOL]         assertEquals(0, StringUtils.indexOfAny(CharU20000, CharU20000)); [EOL]         assertEquals(-1, StringUtils.indexOfAny(CharU20000, CharU20001)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIndexOfAny_StringStringWithSupplementaryChars() { [EOL]         assertEquals(0, StringUtils.indexOfAny(CharU20000 + CharU20001, CharU20000)); [EOL]         assertEquals(2, StringUtils.indexOfAny(CharU20000 + CharU20001, CharU20001)); [EOL]         assertEquals(0, StringUtils.indexOfAny(CharU20000, CharU20000)); [EOL]         assertEquals(-1, StringUtils.indexOfAny(CharU20000, CharU20001)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testContainsAny_StringCharArrayWithSupplementaryChars() { [EOL]         assertTrue(StringUtils.containsAny(CharU20000 + CharU20001, CharU20000.toCharArray())); [EOL]         assertTrue(StringUtils.containsAny("a" + CharU20000 + CharU20001, "a".toCharArray())); [EOL]         assertTrue(StringUtils.containsAny(CharU20000 + "a" + CharU20001, "a".toCharArray())); [EOL]         assertTrue(StringUtils.containsAny(CharU20000 + CharU20001 + "a", "a".toCharArray())); [EOL]         assertTrue(StringUtils.containsAny(CharU20000 + CharU20001, CharU20001.toCharArray())); [EOL]         assertTrue(StringUtils.containsAny(CharU20000, CharU20000.toCharArray())); [EOL]         // Sanity check: [EOL]         assertEquals(-1, CharU20000.indexOf(CharU20001)); [EOL]         assertEquals(0, CharU20000.indexOf(CharU20001.charAt(0))); [EOL]         assertEquals(-1, CharU20000.indexOf(CharU20001.charAt(1))); [EOL]         // Test: [EOL]         assertFalse(StringUtils.containsAny(CharU20000, CharU20001.toCharArray())); [EOL]         assertFalse(StringUtils.containsAny(CharU20001, CharU20000.toCharArray())); [
@Test [EOL]     public void testContainsAny_StringCharArrayWithSupplementaryChars() { [EOL]         assertTrue(StringUtils.containsAny(CharU20000 + CharU20001, CharU20000.toCharArray())); [EOL]         assertTrue(StringUtils.containsAny("a" + CharU20000 + CharU20001, "a".toCharArray())); [EOL]         assertTrue(StringUtils.containsAny(CharU20000 + "a" + CharU20001, "a".toCharArray())); [EOL]         assertTrue(StringUtils.containsAny(CharU20000 + CharU20001 + "a", "a".toCharArray())); [EOL]         assertTrue(StringUtils.containsAny(CharU20000 + CharU20001, CharU20001.toCharArray())); [EOL]         assertTrue(StringUtils.containsAny(CharU20000, CharU20000.toCharArray())); [EOL]         // Sanity check: [EOL]         assertEquals(-1, CharU20000.indexOf(CharU20001)); [EOL]         assertEquals(0, CharU20000.indexOf(CharU20001.charAt(0))); [EOL]         assertEquals(-1, CharU20000.indexOf(CharU20001.charAt(1))); [EOL]         // Test: [EOL]         assertFalse(StringUtils.containsAny(CharU20000, CharU20001.toCharArray())); [EOL]         assertFalse(StringUtils.containsAny(CharU20001, CharU20000.toCharArray())); [
@Test [EOL]     public void testContainsAny_StringCharArrayWithSupplementaryChars() { [EOL]         assertTrue(StringUtils.containsAny(CharU20000 + CharU20001, CharU20000.toCharArray())); [EOL]         assertTrue(StringUtils.containsAny("a" + CharU20000 + CharU20001, "a".toCharArray())); [EOL]         assertTrue(StringUtils.containsAny(CharU20000 + "a" + CharU20001, "a".toCharArray())); [EOL]         assertTrue(StringUtils.containsAny(CharU20000 + CharU20001 + "a", "a".toCharArray())); [EOL]         assertTrue(StringUtils.containsAny(CharU20000 + CharU20001, CharU20001.toCharArray())); [EOL]         assertTrue(StringUtils.containsAny(CharU20000, CharU20000.toCharArray())); [EOL]         // Sanity check: [EOL]         assertEquals(-1, CharU20000.indexOf(CharU20001)); [EOL]         assertEquals(0, CharU20000.indexOf(CharU20001.charAt(0))); [EOL]         assertEquals(-1, CharU20000.indexOf(CharU20001.charAt(1))); [EOL]         // Test: [EOL]         assertFalse(StringUtils.containsAny(CharU20000, CharU20001.toCharArray())); [EOL]         assertFalse(StringUtils.containsAny(CharU20001, CharU20000.toCharArray())); [
@Test [EOL]     public void testContainsAny_StringCharArrayWithSupplementaryChars() { [EOL]         assertTrue(StringUtils.containsAny(CharU20000 + CharU20001, CharU20000.toCharArray())); [EOL]         assertTrue(StringUtils.containsAny("a" + CharU20000 + CharU20001, "a".toCharArray())); [EOL]         assertTrue(StringUtils.containsAny(CharU20000 + "a" + CharU20001, "a".toCharArray())); [EOL]         assertTrue(StringUtils.containsAny(CharU20000 + CharU20001 + "a", "a".toCharArray())); [EOL]         assertTrue(StringUtils.containsAny(CharU20000 + CharU20001, CharU20001.toCharArray())); [EOL]         assertTrue(StringUtils.containsAny(CharU20000, CharU20000.toCharArray())); [EOL]         // Sanity check: [EOL]         assertEquals(-1, CharU20000.indexOf(CharU20001)); [EOL]         assertEquals(0, CharU20000.indexOf(CharU20001.charAt(0))); [EOL]         assertEquals(-1, CharU20000.indexOf(CharU20001.charAt(1))); [EOL]         // Test: [EOL]         assertFalse(StringUtils.containsAny(CharU20000, CharU20001.toCharArray())); [EOL]         assertFalse(StringUtils.containsAny(CharU20001, CharU20000.toCharArray())); [
@Test [EOL]     public void testRepeat_StringInt() { [EOL]         assertEquals(null, StringUtils.repeat(null, 2)); [EOL]         assertEquals("", StringUtils.repeat("ab", 0)); [EOL]         assertEquals("", StringUtils.repeat("", 3)); [EOL]         assertEquals("aaa", StringUtils.repeat("a", 3)); [EOL]         assertEquals("ababab", StringUtils.repeat("ab", 3)); [EOL]         assertEquals("abcabcabc", StringUtils.repeat("abc", 3)); [EOL]         final String str = StringUtils.repeat("a", 10000);  // bigger than pad limit [EOL]         assertEquals(10000, str.length()); [EOL]         assertTrue(StringUtils.containsOnly(str, new char[] {'a'})); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testRepeat_StringInt() { [EOL]         assertEquals(null, StringUtils.repeat(null, 2)); [EOL]         assertEquals("", StringUtils.repeat("ab", 0)); [EOL]         assertEquals("", StringUtils.repeat("", 3)); [EOL]         assertEquals("aaa", StringUtils.repeat("a", 3)); [EOL]         assertEquals("ababab", StringUtils.repeat("ab", 3)); [EOL]         assertEquals("abcabcabc", StringUtils.repeat("abc", 3)); [EOL]         final String str = StringUtils.repeat("a", 10000);  // bigger than pad limit [EOL]         assertEquals(10000, str.length()); [EOL]         assertTrue(StringUtils.containsOnly(str, new char[] {'a'})); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testRepeat_StringInt() { [EOL]         assertEquals(null, StringUtils.repeat(null, 2)); [EOL]         assertEquals("", StringUtils.repeat("ab", 0)); [EOL]         assertEquals("", StringUtils.repeat("", 3)); [EOL]         assertEquals("aaa", StringUtils.repeat("a", 3)); [EOL]         assertEquals("ababab", StringUtils.repeat("ab", 3)); [EOL]         assertEquals("abcabcabc", StringUtils.repeat("abc", 3)); [EOL]         final String str = StringUtils.repeat("a", 10000);  // bigger than pad limit [EOL]         assertEquals(10000, str.length()); [EOL]         assertTrue(StringUtils.containsOnly(str, new char[] {'a'})); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testRepeat_StringInt() { [EOL]         assertEquals(null, StringUtils.repeat(null, 2)); [EOL]         assertEquals("", StringUtils.repeat("ab", 0)); [EOL]         assertEquals("", StringUtils.repeat("", 3)); [EOL]         assertEquals("aaa", StringUtils.repeat("a", 3)); [EOL]         assertEquals("ababab", StringUtils.repeat("ab", 3)); [EOL]         assertEquals("abcabcabc", StringUtils.repeat("abc", 3)); [EOL]         final String str = StringUtils.repeat("a", 10000);  // bigger than pad limit [EOL]         assertEquals(10000, str.length()); [EOL]         assertTrue(StringUtils.containsOnly(str, new char[] {'a'})); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testRepeat_StringInt() { [EOL]         assertEquals(null, StringUtils.repeat(null, 2)); [EOL]         assertEquals("", StringUtils.repeat("ab", 0)); [EOL]         assertEquals("", StringUtils.repeat("", 3)); [EOL]         assertEquals("aaa", StringUtils.repeat("a", 3)); [EOL]         assertEquals("ababab", StringUtils.repeat("ab", 3)); [EOL]         assertEquals("abcabcabc", StringUtils.repeat("abc", 3)); [EOL]         final String str = StringUtils.repeat("a", 10000);  // bigger than pad limit [EOL]         assertEquals(10000, str.length()); [EOL]         assertTrue(StringUtils.containsOnly(str, new char[] {'a'})); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIndexOfAnyBut_StringStringWithSupplementaryChars() { [EOL]         assertEquals(2, StringUtils.indexOfAnyBut(CharU20000 + CharU20001, CharU20000)); [EOL]         assertEquals(0, StringUtils.indexOfAnyBut(CharU20000 + CharU20001, CharU20001)); [EOL]         assertEquals(-1, StringUtils.indexOfAnyBut(CharU20000, CharU20000)); [EOL]         assertEquals(0, StringUtils.indexOfAnyBut(CharU20000, CharU20001)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIndexOfAnyBut_StringStringWithSupplementaryChars() { [EOL]         assertEquals(2, StringUtils.indexOfAnyBut(CharU20000 + CharU20001, CharU20000)); [EOL]         assertEquals(0, StringUtils.indexOfAnyBut(CharU20000 + CharU20001, CharU20001)); [EOL]         assertEquals(-1, StringUtils.indexOfAnyBut(CharU20000, CharU20000)); [EOL]         assertEquals(0, StringUtils.indexOfAnyBut(CharU20000, CharU20001)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIndexOfAnyBut_StringStringWithSupplementaryChars() { [EOL]         assertEquals(2, StringUtils.indexOfAnyBut(CharU20000 + CharU20001, CharU20000)); [EOL]         assertEquals(0, StringUtils.indexOfAnyBut(CharU20000 + CharU20001, CharU20001)); [EOL]         assertEquals(-1, StringUtils.indexOfAnyBut(CharU20000, CharU20000)); [EOL]         assertEquals(0, StringUtils.indexOfAnyBut(CharU20000, CharU20001)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIndexOfAnyBut_StringStringWithSupplementaryChars() { [EOL]         assertEquals(2, StringUtils.indexOfAnyBut(CharU20000 + CharU20001, CharU20000)); [EOL]         assertEquals(0, StringUtils.indexOfAnyBut(CharU20000 + CharU20001, CharU20001)); [EOL]         assertEquals(-1, StringUtils.indexOfAnyBut(CharU20000, CharU20000)); [EOL]         assertEquals(0, StringUtils.indexOfAnyBut(CharU20000, CharU20001)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testRepeat_StringInt() { [EOL]         assertEquals(null, StringUtils.repeat(null, 2)); [EOL]         assertEquals("", StringUtils.repeat("ab", 0)); [EOL]         assertEquals("", StringUtils.repeat("", 3)); [EOL]         assertEquals("aaa", StringUtils.repeat("a", 3)); [EOL]         assertEquals("ababab", StringUtils.repeat("ab", 3)); [EOL]         assertEquals("abcabcabc", StringUtils.repeat("abc", 3)); [EOL]         final String str = StringUtils.repeat("a", 10000);  // bigger than pad limit [EOL]         assertEquals(10000, str.length()); [EOL]         assertTrue(StringUtils.containsOnly(str, new char[] {'a'})); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testRepeat_StringInt() { [EOL]         assertEquals(null, StringUtils.repeat(null, 2)); [EOL]         assertEquals("", StringUtils.repeat("ab", 0)); [EOL]         assertEquals("", StringUtils.repeat("", 3)); [EOL]         assertEquals("aaa", StringUtils.repeat("a", 3)); [EOL]         assertEquals("ababab", StringUtils.repeat("ab", 3)); [EOL]         assertEquals("abcabcabc", StringUtils.repeat("abc", 3)); [EOL]         final String str = StringUtils.repeat("a", 10000);  // bigger than pad limit [EOL]         assertEquals(10000, str.length()); [EOL]         assertTrue(StringUtils.containsOnly(str, new char[] {'a'})); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testContainsOnly_String() { [EOL]         final String str1 = "a"; [EOL]         final String str2 = "b"; [EOL]         final String str3 = "ab"; [EOL]         final String chars1= "b"; [EOL]         final String chars2= "a"; [EOL]         final String chars3= "ab"; [EOL]         assertFalse(StringUtils.containsOnly(null, (String) null)); [EOL]         assertFalse(StringUtils.containsOnly("", (String) null)); [EOL]         assertFalse(StringUtils.containsOnly(null, "")); [EOL]         assertFalse(StringUtils.containsOnly(str1, "")); [EOL]         assertTrue(StringUtils.containsOnly("", "")); [EOL]         assertTrue(StringUtils.containsOnly("", chars1)); [EOL]         assertFalse(StringUtils.containsOnly(str1, chars1)); [EOL]         assertTrue(StringUtils.containsOnly(str1, chars2)); [EOL]         assertTrue(StringUtils.containsOnly(str1, chars3)); [EOL]         assertTrue(StringUtils.containsOnly(str2, chars1)); [EOL]         assertFalse(StringUtils.containsOnly(str2, chars2)); [EOL]         assertTrue(StringUtils.containsOnly(str2, chars3)); [EOL]         assertFalse
@Test [EOL]     public void testContainsNone_StringWithSupplementaryChars() { [EOL]         assertFalse(StringUtils.containsNone(CharU20000 + CharU20001, CharU20000)); [EOL]         assertFalse(StringUtils.containsNone(CharU20000 + CharU20001, CharU20001)); [EOL]         assertFalse(StringUtils.containsNone(CharU20000, CharU20000)); [EOL]         // Sanity check: [EOL]         assertEquals(-1, CharU20000.indexOf(CharU20001)); [EOL]         assertEquals(0, CharU20000.indexOf(CharU20001.charAt(0))); [EOL]         assertEquals(-1, CharU20000.indexOf(CharU20001.charAt(1))); [EOL]         // Test: [EOL]         assertTrue(StringUtils.containsNone(CharU20000, CharU20001)); [EOL]         assertTrue(StringUtils.containsNone(CharU20001, CharU20000)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testContainsNone_StringWithSupplementaryChars() { [EOL]         assertFalse(StringUtils.containsNone(CharU20000 + CharU20001, CharU20000)); [EOL]         assertFalse(StringUtils.containsNone(CharU20000 + CharU20001, CharU20001)); [EOL]         assertFalse(StringUtils.containsNone(CharU20000, CharU20000)); [EOL]         // Sanity check: [EOL]         assertEquals(-1, CharU20000.indexOf(CharU20001)); [EOL]         assertEquals(0, CharU20000.indexOf(CharU20001.charAt(0))); [EOL]         assertEquals(-1, CharU20000.indexOf(CharU20001.charAt(1))); [EOL]         // Test: [EOL]         assertTrue(StringUtils.containsNone(CharU20000, CharU20001)); [EOL]         assertTrue(StringUtils.containsNone(CharU20001, CharU20000)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testContainsNone_StringWithSupplementaryChars() { [EOL]         assertFalse(StringUtils.containsNone(CharU20000 + CharU20001, CharU20000)); [EOL]         assertFalse(StringUtils.containsNone(CharU20000 + CharU20001, CharU20001)); [EOL]         assertFalse(StringUtils.containsNone(CharU20000, CharU20000)); [EOL]         // Sanity check: [EOL]         assertEquals(-1, CharU20000.indexOf(CharU20001)); [EOL]         assertEquals(0, CharU20000.indexOf(CharU20001.charAt(0))); [EOL]         assertEquals(-1, CharU20000.indexOf(CharU20001.charAt(1))); [EOL]         // Test: [EOL]         assertTrue(StringUtils.containsNone(CharU20000, CharU20001)); [EOL]         assertTrue(StringUtils.containsNone(CharU20001, CharU20000)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testContainsNone_StringWithSupplementaryChars() { [EOL]         assertFalse(StringUtils.containsNone(CharU20000 + CharU20001, CharU20000)); [EOL]         assertFalse(StringUtils.containsNone(CharU20000 + CharU20001, CharU20001)); [EOL]         assertFalse(StringUtils.containsNone(CharU20000, CharU20000)); [EOL]         // Sanity check: [EOL]         assertEquals(-1, CharU20000.indexOf(CharU20001)); [EOL]         assertEquals(0, CharU20000.indexOf(CharU20001.charAt(0))); [EOL]         assertEquals(-1, CharU20000.indexOf(CharU20001.charAt(1))); [EOL]         // Test: [EOL]         assertTrue(StringUtils.containsNone(CharU20000, CharU20001)); [EOL]         assertTrue(StringUtils.containsNone(CharU20001, CharU20000)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMid_String() { [EOL]         assertSame(null, StringUtils.mid(null, -1, 0)); [EOL]         assertSame(null, StringUtils.mid(null, 0, -1)); [EOL]         assertSame(null, StringUtils.mid(null, 3, 0)); [EOL]         assertSame(null, StringUtils.mid(null, 3, 2)); [EOL]          [EOL]         assertEquals("", StringUtils.mid("", 0, -1)); [EOL]         assertEquals("", StringUtils.mid("", 0, 0)); [EOL]         assertEquals("", StringUtils.mid("", 0, 2)); [EOL]          [EOL]         assertEquals("", StringUtils.mid(FOOBAR, 3, -1)); [EOL]         assertEquals("", StringUtils.mid(FOOBAR, 3, 0)); [EOL]         assertEquals("b", StringUtils.mid(FOOBAR, 3, 1)); [EOL]         assertEquals(FOO, StringUtils.mid(FOOBAR, 0, 3)); [EOL]         assertEquals(BAR, StringUtils.mid(FOOBAR, 3, 3)); [EOL]         assertEquals(FOOBAR, StringUtils.mid(FOOBAR, 0, 80)); [EOL]         assertEquals(BAR, StringUtils.mid(FOOBAR, 3, 80)); [EOL]         assertEquals("", StringUtils.mid(
@Test [EOL]     public void testMid_String() { [EOL]         assertSame(null, StringUtils.mid(null, -1, 0)); [EOL]         assertSame(null, StringUtils.mid(null, 0, -1)); [EOL]         assertSame(null, StringUtils.mid(null, 3, 0)); [EOL]         assertSame(null, StringUtils.mid(null, 3, 2)); [EOL]          [EOL]         assertEquals("", StringUtils.mid("", 0, -1)); [EOL]         assertEquals("", StringUtils.mid("", 0, 0)); [EOL]         assertEquals("", StringUtils.mid("", 0, 2)); [EOL]          [EOL]         assertEquals("", StringUtils.mid(FOOBAR, 3, -1)); [EOL]         assertEquals("", StringUtils.mid(FOOBAR, 3, 0)); [EOL]         assertEquals("b", StringUtils.mid(FOOBAR, 3, 1)); [EOL]         assertEquals(FOO, StringUtils.mid(FOOBAR, 0, 3)); [EOL]         assertEquals(BAR, StringUtils.mid(FOOBAR, 3, 3)); [EOL]         assertEquals(FOOBAR, StringUtils.mid(FOOBAR, 0, 80)); [EOL]         assertEquals(BAR, StringUtils.mid(FOOBAR, 3, 80)); [EOL]         assertEquals("", StringUtils.mid(
@Test [EOL]     public void testMid_String() { [EOL]         assertSame(null, StringUtils.mid(null, -1, 0)); [EOL]         assertSame(null, StringUtils.mid(null, 0, -1)); [EOL]         assertSame(null, StringUtils.mid(null, 3, 0)); [EOL]         assertSame(null, StringUtils.mid(null, 3, 2)); [EOL]          [EOL]         assertEquals("", StringUtils.mid("", 0, -1)); [EOL]         assertEquals("", StringUtils.mid("", 0, 0)); [EOL]         assertEquals("", StringUtils.mid("", 0, 2)); [EOL]          [EOL]         assertEquals("", StringUtils.mid(FOOBAR, 3, -1)); [EOL]         assertEquals("", StringUtils.mid(FOOBAR, 3, 0)); [EOL]         assertEquals("b", StringUtils.mid(FOOBAR, 3, 1)); [EOL]         assertEquals(FOO, StringUtils.mid(FOOBAR, 0, 3)); [EOL]         assertEquals(BAR, StringUtils.mid(FOOBAR, 3, 3)); [EOL]         assertEquals(FOOBAR, StringUtils.mid(FOOBAR, 0, 80)); [EOL]         assertEquals(BAR, StringUtils.mid(FOOBAR, 3, 80)); [EOL]         assertEquals("", StringUtils.mid(
@Test [EOL]     public void testSubstringAfter_StringString() { [EOL]         assertEquals("barXXbaz", StringUtils.substringAfter("fooXXbarXXbaz", "XX")); [EOL]          [EOL]         assertEquals(null, StringUtils.substringAfter(null, null)); [EOL]         assertEquals(null, StringUtils.substringAfter(null, "")); [EOL]         assertEquals(null, StringUtils.substringAfter(null, "XX")); [EOL]         assertEquals("", StringUtils.substringAfter("", null)); [EOL]         assertEquals("", StringUtils.substringAfter("", "")); [EOL]         assertEquals("", StringUtils.substringAfter("", "XX")); [EOL]          [EOL]         assertEquals("", StringUtils.substringAfter("foo", null)); [EOL]         assertEquals("ot", StringUtils.substringAfter("foot", "o")); [EOL]         assertEquals("bc", StringUtils.substringAfter("abc", "a")); [EOL]         assertEquals("cba", StringUtils.substringAfter("abcba", "b")); [EOL]         assertEquals("", StringUtils.substringAfter("abc", "c")); [EOL]         assertEquals("abc", StringUtils.substringAfter("abc", "")); [EOL]         assertEquals("", StringUtils.substringAfter("abc", "d")); [EOL]     } [E
@Test [EOL]     public void testSubstringAfterLast_StringString() { [EOL]         assertEquals("baz", StringUtils.substringAfterLast("fooXXbarXXbaz", "XX")); [EOL]  [EOL]         assertEquals(null, StringUtils.substringAfterLast(null, null)); [EOL]         assertEquals(null, StringUtils.substringAfterLast(null, "")); [EOL]         assertEquals(null, StringUtils.substringAfterLast(null, "XX")); [EOL]         assertEquals("", StringUtils.substringAfterLast("", null)); [EOL]         assertEquals("", StringUtils.substringAfterLast("", "")); [EOL]         assertEquals("", StringUtils.substringAfterLast("", "a")); [EOL]  [EOL]         assertEquals("", StringUtils.substringAfterLast("foo", null)); [EOL]         assertEquals("", StringUtils.substringAfterLast("foo", "b")); [EOL]         assertEquals("t", StringUtils.substringAfterLast("foot", "o")); [EOL]         assertEquals("bc", StringUtils.substringAfterLast("abc", "a")); [EOL]         assertEquals("a", StringUtils.substringAfterLast("abcba", "b")); [EOL]         assertEquals("", StringUtils.substringAfterLast("abc", "c")); [EOL]         assertEquals("", StringUtils.substringAfterLast("", "d")); [EOL]         assertEquals("
@Test [EOL]     public void testSubstringAfterLast_StringString() { [EOL]         assertEquals("baz", StringUtils.substringAfterLast("fooXXbarXXbaz", "XX")); [EOL]  [EOL]         assertEquals(null, StringUtils.substringAfterLast(null, null)); [EOL]         assertEquals(null, StringUtils.substringAfterLast(null, "")); [EOL]         assertEquals(null, StringUtils.substringAfterLast(null, "XX")); [EOL]         assertEquals("", StringUtils.substringAfterLast("", null)); [EOL]         assertEquals("", StringUtils.substringAfterLast("", "")); [EOL]         assertEquals("", StringUtils.substringAfterLast("", "a")); [EOL]  [EOL]         assertEquals("", StringUtils.substringAfterLast("foo", null)); [EOL]         assertEquals("", StringUtils.substringAfterLast("foo", "b")); [EOL]         assertEquals("t", StringUtils.substringAfterLast("foot", "o")); [EOL]         assertEquals("bc", StringUtils.substringAfterLast("abc", "a")); [EOL]         assertEquals("a", StringUtils.substringAfterLast("abcba", "b")); [EOL]         assertEquals("", StringUtils.substringAfterLast("abc", "c")); [EOL]         assertEquals("", StringUtils.substringAfterLast("", "d")); [EOL]         assertEquals("
@Test [EOL]     public void testSubstringsBetween_StringStringString() { [EOL]  [EOL]         String[] results = StringUtils.substringsBetween("[one], [two], [three]", "[", "]"); [EOL]         assertEquals(3, results.length); [EOL]         assertEquals("one", results[0]); [EOL]         assertEquals("two", results[1]); [EOL]         assertEquals("three", results[2]); [EOL]  [EOL]         results = StringUtils.substringsBetween("[one], [two], three", "[", "]"); [EOL]         assertEquals(2, results.length); [EOL]         assertEquals("one", results[0]); [EOL]         assertEquals("two", results[1]); [EOL]  [EOL]         results = StringUtils.substringsBetween("[one], [two], three]", "[", "]"); [EOL]         assertEquals(2, results.length); [EOL]         assertEquals("one", results[0]); [EOL]         assertEquals("two", results[1]); [EOL]  [EOL]         results = StringUtils.substringsBetween("[one], two], three]", "[", "]"); [EOL]         assertEquals(1, results.length); [EOL]         assertEquals("one", results[0]); [EOL]  [EOL]         results = StringUtils.substringsBetween("one], two], [three]", "[", "]"); [EOL]   
@Test [EOL]     public void testSubstringsBetween_StringStringString() { [EOL]  [EOL]         String[] results = StringUtils.substringsBetween("[one], [two], [three]", "[", "]"); [EOL]         assertEquals(3, results.length); [EOL]         assertEquals("one", results[0]); [EOL]         assertEquals("two", results[1]); [EOL]         assertEquals("three", results[2]); [EOL]  [EOL]         results = StringUtils.substringsBetween("[one], [two], three", "[", "]"); [EOL]         assertEquals(2, results.length); [EOL]         assertEquals("one", results[0]); [EOL]         assertEquals("two", results[1]); [EOL]  [EOL]         results = StringUtils.substringsBetween("[one], [two], three]", "[", "]"); [EOL]         assertEquals(2, results.length); [EOL]         assertEquals("one", results[0]); [EOL]         assertEquals("two", results[1]); [EOL]  [EOL]         results = StringUtils.substringsBetween("[one], two], three]", "[", "]"); [EOL]         assertEquals(1, results.length); [EOL]         assertEquals("one", results[0]); [EOL]  [EOL]         results = StringUtils.substringsBetween("one], two], [three]", "[", "]"); [EOL]   
@Test [EOL]     public void testSubstringsBetween_StringStringString() { [EOL]  [EOL]         String[] results = StringUtils.substringsBetween("[one], [two], [three]", "[", "]"); [EOL]         assertEquals(3, results.length); [EOL]         assertEquals("one", results[0]); [EOL]         assertEquals("two", results[1]); [EOL]         assertEquals("three", results[2]); [EOL]  [EOL]         results = StringUtils.substringsBetween("[one], [two], three", "[", "]"); [EOL]         assertEquals(2, results.length); [EOL]         assertEquals("one", results[0]); [EOL]         assertEquals("two", results[1]); [EOL]  [EOL]         results = StringUtils.substringsBetween("[one], [two], three]", "[", "]"); [EOL]         assertEquals(2, results.length); [EOL]         assertEquals("one", results[0]); [EOL]         assertEquals("two", results[1]); [EOL]  [EOL]         results = StringUtils.substringsBetween("[one], two], three]", "[", "]"); [EOL]         assertEquals(1, results.length); [EOL]         assertEquals("one", results[0]); [EOL]  [EOL]         results = StringUtils.substringsBetween("one], two], [three]", "[", "]"); [EOL]   
@Test [EOL]     public void testSubstringsBetween_StringStringString() { [EOL]  [EOL]         String[] results = StringUtils.substringsBetween("[one], [two], [three]", "[", "]"); [EOL]         assertEquals(3, results.length); [EOL]         assertEquals("one", results[0]); [EOL]         assertEquals("two", results[1]); [EOL]         assertEquals("three", results[2]); [EOL]  [EOL]         results = StringUtils.substringsBetween("[one], [two], three", "[", "]"); [EOL]         assertEquals(2, results.length); [EOL]         assertEquals("one", results[0]); [EOL]         assertEquals("two", results[1]); [EOL]  [EOL]         results = StringUtils.substringsBetween("[one], [two], three]", "[", "]"); [EOL]         assertEquals(2, results.length); [EOL]         assertEquals("one", results[0]); [EOL]         assertEquals("two", results[1]); [EOL]  [EOL]         results = StringUtils.substringsBetween("[one], two], three]", "[", "]"); [EOL]         assertEquals(1, results.length); [EOL]         assertEquals("one", results[0]); [EOL]  [EOL]         results = StringUtils.substringsBetween("one], two], [three]", "[", "]"); [EOL]   
@Test [EOL]     public void testSubstringsBetween_StringStringString() { [EOL]  [EOL]         String[] results = StringUtils.substringsBetween("[one], [two], [three]", "[", "]"); [EOL]         assertEquals(3, results.length); [EOL]         assertEquals("one", results[0]); [EOL]         assertEquals("two", results[1]); [EOL]         assertEquals("three", results[2]); [EOL]  [EOL]         results = StringUtils.substringsBetween("[one], [two], three", "[", "]"); [EOL]         assertEquals(2, results.length); [EOL]         assertEquals("one", results[0]); [EOL]         assertEquals("two", results[1]); [EOL]  [EOL]         results = StringUtils.substringsBetween("[one], [two], three]", "[", "]"); [EOL]         assertEquals(2, results.length); [EOL]         assertEquals("one", results[0]); [EOL]         assertEquals("two", results[1]); [EOL]  [EOL]         results = StringUtils.substringsBetween("[one], two], three]", "[", "]"); [EOL]         assertEquals(1, results.length); [EOL]         assertEquals("one", results[0]); [EOL]  [EOL]         results = StringUtils.substringsBetween("one], two], [three]", "[", "]"); [EOL]   
@Test [EOL]     public void testSubstringsBetween_StringStringString() { [EOL]  [EOL]         String[] results = StringUtils.substringsBetween("[one], [two], [three]", "[", "]"); [EOL]         assertEquals(3, results.length); [EOL]         assertEquals("one", results[0]); [EOL]         assertEquals("two", results[1]); [EOL]         assertEquals("three", results[2]); [EOL]  [EOL]         results = StringUtils.substringsBetween("[one], [two], three", "[", "]"); [EOL]         assertEquals(2, results.length); [EOL]         assertEquals("one", results[0]); [EOL]         assertEquals("two", results[1]); [EOL]  [EOL]         results = StringUtils.substringsBetween("[one], [two], three]", "[", "]"); [EOL]         assertEquals(2, results.length); [EOL]         assertEquals("one", results[0]); [EOL]         assertEquals("two", results[1]); [EOL]  [EOL]         results = StringUtils.substringsBetween("[one], two], three]", "[", "]"); [EOL]         assertEquals(1, results.length); [EOL]         assertEquals("one", results[0]); [EOL]  [EOL]         results = StringUtils.substringsBetween("one], two], [three]", "[", "]"); [EOL]   
@Test [EOL]     public void testSubstringsBetween_StringStringString() { [EOL]  [EOL]         String[] results = StringUtils.substringsBetween("[one], [two], [three]", "[", "]"); [EOL]         assertEquals(3, results.length); [EOL]         assertEquals("one", results[0]); [EOL]         assertEquals("two", results[1]); [EOL]         assertEquals("three", results[2]); [EOL]  [EOL]         results = StringUtils.substringsBetween("[one], [two], three", "[", "]"); [EOL]         assertEquals(2, results.length); [EOL]         assertEquals("one", results[0]); [EOL]         assertEquals("two", results[1]); [EOL]  [EOL]         results = StringUtils.substringsBetween("[one], [two], three]", "[", "]"); [EOL]         assertEquals(2, results.length); [EOL]         assertEquals("one", results[0]); [EOL]         assertEquals("two", results[1]); [EOL]  [EOL]         results = StringUtils.substringsBetween("[one], two], three]", "[", "]"); [EOL]         assertEquals(1, results.length); [EOL]         assertEquals("one", results[0]); [EOL]  [EOL]         results = StringUtils.substringsBetween("one], two], [three]", "[", "]"); [EOL]   
@Test [EOL]     public void testSubstringsBetween_StringStringString() { [EOL]  [EOL]         String[] results = StringUtils.substringsBetween("[one], [two], [three]", "[", "]"); [EOL]         assertEquals(3, results.length); [EOL]         assertEquals("one", results[0]); [EOL]         assertEquals("two", results[1]); [EOL]         assertEquals("three", results[2]); [EOL]  [EOL]         results = StringUtils.substringsBetween("[one], [two], three", "[", "]"); [EOL]         assertEquals(2, results.length); [EOL]         assertEquals("one", results[0]); [EOL]         assertEquals("two", results[1]); [EOL]  [EOL]         results = StringUtils.substringsBetween("[one], [two], three]", "[", "]"); [EOL]         assertEquals(2, results.length); [EOL]         assertEquals("one", results[0]); [EOL]         assertEquals("two", results[1]); [EOL]  [EOL]         results = StringUtils.substringsBetween("[one], two], three]", "[", "]"); [EOL]         assertEquals(1, results.length); [EOL]         assertEquals("one", results[0]); [EOL]  [EOL]         results = StringUtils.substringsBetween("one], two], [three]", "[", "]"); [EOL]   
@Test [EOL]     public void testSplitByWholeString_StringStringBoolean() { [EOL]         assertArrayEquals( null, StringUtils.splitByWholeSeparator( null, "." ) ) ; [EOL]  [EOL]         assertEquals( 0, StringUtils.splitByWholeSeparator( "", "." ).length ) ; [EOL]  [EOL]         final String stringToSplitOnNulls = "ab   de fg" ; [EOL]         final String[] splitOnNullExpectedResults = { "ab", "de", "fg" } ; [EOL]  [EOL]         final String[] splitOnNullResults = StringUtils.splitByWholeSeparator( stringToSplitOnNulls, null ) ; [EOL]         assertEquals( splitOnNullExpectedResults.length, splitOnNullResults.length ) ; [EOL]         for ( int i = 0 ; i < splitOnNullExpectedResults.length ; i+= 1 ) { [EOL]             assertEquals( splitOnNullExpectedResults[i], splitOnNullResults[i] ) ; [EOL]         } [EOL]  [EOL]         final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiously" ; [EOL]  [EOL]         final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" } ; [EOL]         final String[] splitOnStringResults = StringUtils.splitByWholeSeparator( stringToSplitOnCharactersAndString, "aeiouy" ) ; [EOL]         assertEquals( splitOnStringExpectedResults.length, splitOnStringResults
@Test [EOL]     public void testSplitByWholeString_StringStringBoolean() { [EOL]         assertArrayEquals( null, StringUtils.splitByWholeSeparator( null, "." ) ) ; [EOL]  [EOL]         assertEquals( 0, StringUtils.splitByWholeSeparator( "", "." ).length ) ; [EOL]  [EOL]         final String stringToSplitOnNulls = "ab   de fg" ; [EOL]         final String[] splitOnNullExpectedResults = { "ab", "de", "fg" } ; [EOL]  [EOL]         final String[] splitOnNullResults = StringUtils.splitByWholeSeparator( stringToSplitOnNulls, null ) ; [EOL]         assertEquals( splitOnNullExpectedResults.length, splitOnNullResults.length ) ; [EOL]         for ( int i = 0 ; i < splitOnNullExpectedResults.length ; i+= 1 ) { [EOL]             assertEquals( splitOnNullExpectedResults[i], splitOnNullResults[i] ) ; [EOL]         } [EOL]  [EOL]         final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiously" ; [EOL]  [EOL]         final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" } ; [EOL]         final String[] splitOnStringResults = StringUtils.splitByWholeSeparator( stringToSplitOnCharactersAndString, "aeiouy" ) ; [EOL]         assertEquals( splitOnStringExpectedResults.length, splitOnStringResults
@Test [EOL]     public void testSplitByWholeString_StringStringBoolean() { [EOL]         assertArrayEquals( null, StringUtils.splitByWholeSeparator( null, "." ) ) ; [EOL]  [EOL]         assertEquals( 0, StringUtils.splitByWholeSeparator( "", "." ).length ) ; [EOL]  [EOL]         final String stringToSplitOnNulls = "ab   de fg" ; [EOL]         final String[] splitOnNullExpectedResults = { "ab", "de", "fg" } ; [EOL]  [EOL]         final String[] splitOnNullResults = StringUtils.splitByWholeSeparator( stringToSplitOnNulls, null ) ; [EOL]         assertEquals( splitOnNullExpectedResults.length, splitOnNullResults.length ) ; [EOL]         for ( int i = 0 ; i < splitOnNullExpectedResults.length ; i+= 1 ) { [EOL]             assertEquals( splitOnNullExpectedResults[i], splitOnNullResults[i] ) ; [EOL]         } [EOL]  [EOL]         final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiously" ; [EOL]  [EOL]         final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" } ; [EOL]         final String[] splitOnStringResults = StringUtils.splitByWholeSeparator( stringToSplitOnCharactersAndString, "aeiouy" ) ; [EOL]         assertEquals( splitOnStringExpectedResults.length, splitOnStringResults
@Test [EOL]     public void testSplitByWholeString_StringStringBoolean() { [EOL]         assertArrayEquals( null, StringUtils.splitByWholeSeparator( null, "." ) ) ; [EOL]  [EOL]         assertEquals( 0, StringUtils.splitByWholeSeparator( "", "." ).length ) ; [EOL]  [EOL]         final String stringToSplitOnNulls = "ab   de fg" ; [EOL]         final String[] splitOnNullExpectedResults = { "ab", "de", "fg" } ; [EOL]  [EOL]         final String[] splitOnNullResults = StringUtils.splitByWholeSeparator( stringToSplitOnNulls, null ) ; [EOL]         assertEquals( splitOnNullExpectedResults.length, splitOnNullResults.length ) ; [EOL]         for ( int i = 0 ; i < splitOnNullExpectedResults.length ; i+= 1 ) { [EOL]             assertEquals( splitOnNullExpectedResults[i], splitOnNullResults[i] ) ; [EOL]         } [EOL]  [EOL]         final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiously" ; [EOL]  [EOL]         final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" } ; [EOL]         final String[] splitOnStringResults = StringUtils.splitByWholeSeparator( stringToSplitOnCharactersAndString, "aeiouy" ) ; [EOL]         assertEquals( splitOnStringExpectedResults.length, splitOnStringResults
@Test [EOL]     public void testSplitByWholeString_StringStringBoolean() { [EOL]         assertArrayEquals( null, StringUtils.splitByWholeSeparator( null, "." ) ) ; [EOL]  [EOL]         assertEquals( 0, StringUtils.splitByWholeSeparator( "", "." ).length ) ; [EOL]  [EOL]         final String stringToSplitOnNulls = "ab   de fg" ; [EOL]         final String[] splitOnNullExpectedResults = { "ab", "de", "fg" } ; [EOL]  [EOL]         final String[] splitOnNullResults = StringUtils.splitByWholeSeparator( stringToSplitOnNulls, null ) ; [EOL]         assertEquals( splitOnNullExpectedResults.length, splitOnNullResults.length ) ; [EOL]         for ( int i = 0 ; i < splitOnNullExpectedResults.length ; i+= 1 ) { [EOL]             assertEquals( splitOnNullExpectedResults[i], splitOnNullResults[i] ) ; [EOL]         } [EOL]  [EOL]         final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiously" ; [EOL]  [EOL]         final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" } ; [EOL]         final String[] splitOnStringResults = StringUtils.splitByWholeSeparator( stringToSplitOnCharactersAndString, "aeiouy" ) ; [EOL]         assertEquals( splitOnStringExpectedResults.length, splitOnStringResults
@Test [EOL]     public void testSplitByWholeString_StringStringBoolean() { [EOL]         assertArrayEquals( null, StringUtils.splitByWholeSeparator( null, "." ) ) ; [EOL]  [EOL]         assertEquals( 0, StringUtils.splitByWholeSeparator( "", "." ).length ) ; [EOL]  [EOL]         final String stringToSplitOnNulls = "ab   de fg" ; [EOL]         final String[] splitOnNullExpectedResults = { "ab", "de", "fg" } ; [EOL]  [EOL]         final String[] splitOnNullResults = StringUtils.splitByWholeSeparator( stringToSplitOnNulls, null ) ; [EOL]         assertEquals( splitOnNullExpectedResults.length, splitOnNullResults.length ) ; [EOL]         for ( int i = 0 ; i < splitOnNullExpectedResults.length ; i+= 1 ) { [EOL]             assertEquals( splitOnNullExpectedResults[i], splitOnNullResults[i] ) ; [EOL]         } [EOL]  [EOL]         final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiously" ; [EOL]  [EOL]         final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" } ; [EOL]         final String[] splitOnStringResults = StringUtils.splitByWholeSeparator( stringToSplitOnCharactersAndString, "aeiouy" ) ; [EOL]         assertEquals( splitOnStringExpectedResults.length, splitOnStringResults
@Test [EOL]     public void testSplitByWholeString_StringStringBoolean() { [EOL]         assertArrayEquals( null, StringUtils.splitByWholeSeparator( null, "." ) ) ; [EOL]  [EOL]         assertEquals( 0, StringUtils.splitByWholeSeparator( "", "." ).length ) ; [EOL]  [EOL]         final String stringToSplitOnNulls = "ab   de fg" ; [EOL]         final String[] splitOnNullExpectedResults = { "ab", "de", "fg" } ; [EOL]  [EOL]         final String[] splitOnNullResults = StringUtils.splitByWholeSeparator( stringToSplitOnNulls, null ) ; [EOL]         assertEquals( splitOnNullExpectedResults.length, splitOnNullResults.length ) ; [EOL]         for ( int i = 0 ; i < splitOnNullExpectedResults.length ; i+= 1 ) { [EOL]             assertEquals( splitOnNullExpectedResults[i], splitOnNullResults[i] ) ; [EOL]         } [EOL]  [EOL]         final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiously" ; [EOL]  [EOL]         final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" } ; [EOL]         final String[] splitOnStringResults = StringUtils.splitByWholeSeparator( stringToSplitOnCharactersAndString, "aeiouy" ) ; [EOL]         assertEquals( splitOnStringExpectedResults.length, splitOnStringResults
@Test [EOL]     public void testSplitByWholeString_StringStringBoolean() { [EOL]         assertArrayEquals( null, StringUtils.splitByWholeSeparator( null, "." ) ) ; [EOL]  [EOL]         assertEquals( 0, StringUtils.splitByWholeSeparator( "", "." ).length ) ; [EOL]  [EOL]         final String stringToSplitOnNulls = "ab   de fg" ; [EOL]         final String[] splitOnNullExpectedResults = { "ab", "de", "fg" } ; [EOL]  [EOL]         final String[] splitOnNullResults = StringUtils.splitByWholeSeparator( stringToSplitOnNulls, null ) ; [EOL]         assertEquals( splitOnNullExpectedResults.length, splitOnNullResults.length ) ; [EOL]         for ( int i = 0 ; i < splitOnNullExpectedResults.length ; i+= 1 ) { [EOL]             assertEquals( splitOnNullExpectedResults[i], splitOnNullResults[i] ) ; [EOL]         } [EOL]  [EOL]         final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiously" ; [EOL]  [EOL]         final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" } ; [EOL]         final String[] splitOnStringResults = StringUtils.splitByWholeSeparator( stringToSplitOnCharactersAndString, "aeiouy" ) ; [EOL]         assertEquals( splitOnStringExpectedResults.length, splitOnStringResults
@Test [EOL]     public void testSplitByWholeString_StringStringBoolean() { [EOL]         assertArrayEquals( null, StringUtils.splitByWholeSeparator( null, "." ) ) ; [EOL]  [EOL]         assertEquals( 0, StringUtils.splitByWholeSeparator( "", "." ).length ) ; [EOL]  [EOL]         final String stringToSplitOnNulls = "ab   de fg" ; [EOL]         final String[] splitOnNullExpectedResults = { "ab", "de", "fg" } ; [EOL]  [EOL]         final String[] splitOnNullResults = StringUtils.splitByWholeSeparator( stringToSplitOnNulls, null ) ; [EOL]         assertEquals( splitOnNullExpectedResults.length, splitOnNullResults.length ) ; [EOL]         for ( int i = 0 ; i < splitOnNullExpectedResults.length ; i+= 1 ) { [EOL]             assertEquals( splitOnNullExpectedResults[i], splitOnNullResults[i] ) ; [EOL]         } [EOL]  [EOL]         final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiously" ; [EOL]  [EOL]         final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" } ; [EOL]         final String[] splitOnStringResults = StringUtils.splitByWholeSeparator( stringToSplitOnCharactersAndString, "aeiouy" ) ; [EOL]         assertEquals( splitOnStringExpectedResults.length, splitOnStringResults
@Test [EOL]     public void testSplitByWholeString_StringStringBoolean() { [EOL]         assertArrayEquals( null, StringUtils.splitByWholeSeparator( null, "." ) ) ; [EOL]  [EOL]         assertEquals( 0, StringUtils.splitByWholeSeparator( "", "." ).length ) ; [EOL]  [EOL]         final String stringToSplitOnNulls = "ab   de fg" ; [EOL]         final String[] splitOnNullExpectedResults = { "ab", "de", "fg" } ; [EOL]  [EOL]         final String[] splitOnNullResults = StringUtils.splitByWholeSeparator( stringToSplitOnNulls, null ) ; [EOL]         assertEquals( splitOnNullExpectedResults.length, splitOnNullResults.length ) ; [EOL]         for ( int i = 0 ; i < splitOnNullExpectedResults.length ; i+= 1 ) { [EOL]             assertEquals( splitOnNullExpectedResults[i], splitOnNullResults[i] ) ; [EOL]         } [EOL]  [EOL]         final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiously" ; [EOL]  [EOL]         final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" } ; [EOL]         final String[] splitOnStringResults = StringUtils.splitByWholeSeparator( stringToSplitOnCharactersAndString, "aeiouy" ) ; [EOL]         assertEquals( splitOnStringExpectedResults.length, splitOnStringResults
@Test [EOL]     public void testSplitByWholeString_StringStringBoolean() { [EOL]         assertArrayEquals( null, StringUtils.splitByWholeSeparator( null, "." ) ) ; [EOL]  [EOL]         assertEquals( 0, StringUtils.splitByWholeSeparator( "", "." ).length ) ; [EOL]  [EOL]         final String stringToSplitOnNulls = "ab   de fg" ; [EOL]         final String[] splitOnNullExpectedResults = { "ab", "de", "fg" } ; [EOL]  [EOL]         final String[] splitOnNullResults = StringUtils.splitByWholeSeparator( stringToSplitOnNulls, null ) ; [EOL]         assertEquals( splitOnNullExpectedResults.length, splitOnNullResults.length ) ; [EOL]         for ( int i = 0 ; i < splitOnNullExpectedResults.length ; i+= 1 ) { [EOL]             assertEquals( splitOnNullExpectedResults[i], splitOnNullResults[i] ) ; [EOL]         } [EOL]  [EOL]         final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiously" ; [EOL]  [EOL]         final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" } ; [EOL]         final String[] splitOnStringResults = StringUtils.splitByWholeSeparator( stringToSplitOnCharactersAndString, "aeiouy" ) ; [EOL]         assertEquals( splitOnStringExpectedResults.length, splitOnStringResults
@Test [EOL]     public void testSplitByWholeString_StringStringBoolean() { [EOL]         assertArrayEquals( null, StringUtils.splitByWholeSeparator( null, "." ) ) ; [EOL]  [EOL]         assertEquals( 0, StringUtils.splitByWholeSeparator( "", "." ).length ) ; [EOL]  [EOL]         final String stringToSplitOnNulls = "ab   de fg" ; [EOL]         final String[] splitOnNullExpectedResults = { "ab", "de", "fg" } ; [EOL]  [EOL]         final String[] splitOnNullResults = StringUtils.splitByWholeSeparator( stringToSplitOnNulls, null ) ; [EOL]         assertEquals( splitOnNullExpectedResults.length, splitOnNullResults.length ) ; [EOL]         for ( int i = 0 ; i < splitOnNullExpectedResults.length ; i+= 1 ) { [EOL]             assertEquals( splitOnNullExpectedResults[i], splitOnNullResults[i] ) ; [EOL]         } [EOL]  [EOL]         final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiously" ; [EOL]  [EOL]         final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" } ; [EOL]         final String[] splitOnStringResults = StringUtils.splitByWholeSeparator( stringToSplitOnCharactersAndString, "aeiouy" ) ; [EOL]         assertEquals( splitOnStringExpectedResults.length, splitOnStringResults
@Test [EOL]     public void testSplitByWholeString_StringStringBoolean() { [EOL]         assertArrayEquals( null, StringUtils.splitByWholeSeparator( null, "." ) ) ; [EOL]  [EOL]         assertEquals( 0, StringUtils.splitByWholeSeparator( "", "." ).length ) ; [EOL]  [EOL]         final String stringToSplitOnNulls = "ab   de fg" ; [EOL]         final String[] splitOnNullExpectedResults = { "ab", "de", "fg" } ; [EOL]  [EOL]         final String[] splitOnNullResults = StringUtils.splitByWholeSeparator( stringToSplitOnNulls, null ) ; [EOL]         assertEquals( splitOnNullExpectedResults.length, splitOnNullResults.length ) ; [EOL]         for ( int i = 0 ; i < splitOnNullExpectedResults.length ; i+= 1 ) { [EOL]             assertEquals( splitOnNullExpectedResults[i], splitOnNullResults[i] ) ; [EOL]         } [EOL]  [EOL]         final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiously" ; [EOL]  [EOL]         final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" } ; [EOL]         final String[] splitOnStringResults = StringUtils.splitByWholeSeparator( stringToSplitOnCharactersAndString, "aeiouy" ) ; [EOL]         assertEquals( splitOnStringExpectedResults.length, splitOnStringResults
@Test [EOL]     public void testSplitByWholeString_StringStringBoolean() { [EOL]         assertArrayEquals( null, StringUtils.splitByWholeSeparator( null, "." ) ) ; [EOL]  [EOL]         assertEquals( 0, StringUtils.splitByWholeSeparator( "", "." ).length ) ; [EOL]  [EOL]         final String stringToSplitOnNulls = "ab   de fg" ; [EOL]         final String[] splitOnNullExpectedResults = { "ab", "de", "fg" } ; [EOL]  [EOL]         final String[] splitOnNullResults = StringUtils.splitByWholeSeparator( stringToSplitOnNulls, null ) ; [EOL]         assertEquals( splitOnNullExpectedResults.length, splitOnNullResults.length ) ; [EOL]         for ( int i = 0 ; i < splitOnNullExpectedResults.length ; i+= 1 ) { [EOL]             assertEquals( splitOnNullExpectedResults[i], splitOnNullResults[i] ) ; [EOL]         } [EOL]  [EOL]         final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiously" ; [EOL]  [EOL]         final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" } ; [EOL]         final String[] splitOnStringResults = StringUtils.splitByWholeSeparator( stringToSplitOnCharactersAndString, "aeiouy" ) ; [EOL]         assertEquals( splitOnStringExpectedResults.length, splitOnStringResults
@Test [EOL]     public void testSplitByWholeString_StringStringBoolean() { [EOL]         assertArrayEquals( null, StringUtils.splitByWholeSeparator( null, "." ) ) ; [EOL]  [EOL]         assertEquals( 0, StringUtils.splitByWholeSeparator( "", "." ).length ) ; [EOL]  [EOL]         final String stringToSplitOnNulls = "ab   de fg" ; [EOL]         final String[] splitOnNullExpectedResults = { "ab", "de", "fg" } ; [EOL]  [EOL]         final String[] splitOnNullResults = StringUtils.splitByWholeSeparator( stringToSplitOnNulls, null ) ; [EOL]         assertEquals( splitOnNullExpectedResults.length, splitOnNullResults.length ) ; [EOL]         for ( int i = 0 ; i < splitOnNullExpectedResults.length ; i+= 1 ) { [EOL]             assertEquals( splitOnNullExpectedResults[i], splitOnNullResults[i] ) ; [EOL]         } [EOL]  [EOL]         final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiously" ; [EOL]  [EOL]         final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" } ; [EOL]         final String[] splitOnStringResults = StringUtils.splitByWholeSeparator( stringToSplitOnCharactersAndString, "aeiouy" ) ; [EOL]         assertEquals( splitOnStringExpectedResults.length, splitOnStringResults
@Test [EOL]     public void testSplitByWholeString_StringStringBoolean() { [EOL]         assertArrayEquals( null, StringUtils.splitByWholeSeparator( null, "." ) ) ; [EOL]  [EOL]         assertEquals( 0, StringUtils.splitByWholeSeparator( "", "." ).length ) ; [EOL]  [EOL]         final String stringToSplitOnNulls = "ab   de fg" ; [EOL]         final String[] splitOnNullExpectedResults = { "ab", "de", "fg" } ; [EOL]  [EOL]         final String[] splitOnNullResults = StringUtils.splitByWholeSeparator( stringToSplitOnNulls, null ) ; [EOL]         assertEquals( splitOnNullExpectedResults.length, splitOnNullResults.length ) ; [EOL]         for ( int i = 0 ; i < splitOnNullExpectedResults.length ; i+= 1 ) { [EOL]             assertEquals( splitOnNullExpectedResults[i], splitOnNullResults[i] ) ; [EOL]         } [EOL]  [EOL]         final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiously" ; [EOL]  [EOL]         final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" } ; [EOL]         final String[] splitOnStringResults = StringUtils.splitByWholeSeparator( stringToSplitOnCharactersAndString, "aeiouy" ) ; [EOL]         assertEquals( splitOnStringExpectedResults.length, splitOnStringResults
@Test [EOL]     public void testSplitByWholeString_StringStringBoolean() { [EOL]         assertArrayEquals( null, StringUtils.splitByWholeSeparator( null, "." ) ) ; [EOL]  [EOL]         assertEquals( 0, StringUtils.splitByWholeSeparator( "", "." ).length ) ; [EOL]  [EOL]         final String stringToSplitOnNulls = "ab   de fg" ; [EOL]         final String[] splitOnNullExpectedResults = { "ab", "de", "fg" } ; [EOL]  [EOL]         final String[] splitOnNullResults = StringUtils.splitByWholeSeparator( stringToSplitOnNulls, null ) ; [EOL]         assertEquals( splitOnNullExpectedResults.length, splitOnNullResults.length ) ; [EOL]         for ( int i = 0 ; i < splitOnNullExpectedResults.length ; i+= 1 ) { [EOL]             assertEquals( splitOnNullExpectedResults[i], splitOnNullResults[i] ) ; [EOL]         } [EOL]  [EOL]         final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiously" ; [EOL]  [EOL]         final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" } ; [EOL]         final String[] splitOnStringResults = StringUtils.splitByWholeSeparator( stringToSplitOnCharactersAndString, "aeiouy" ) ; [EOL]         assertEquals( splitOnStringExpectedResults.length, splitOnStringResults
@Test [EOL]     public void testSplitByWholeString_StringStringBoolean() { [EOL]         assertArrayEquals( null, StringUtils.splitByWholeSeparator( null, "." ) ) ; [EOL]  [EOL]         assertEquals( 0, StringUtils.splitByWholeSeparator( "", "." ).length ) ; [EOL]  [EOL]         final String stringToSplitOnNulls = "ab   de fg" ; [EOL]         final String[] splitOnNullExpectedResults = { "ab", "de", "fg" } ; [EOL]  [EOL]         final String[] splitOnNullResults = StringUtils.splitByWholeSeparator( stringToSplitOnNulls, null ) ; [EOL]         assertEquals( splitOnNullExpectedResults.length, splitOnNullResults.length ) ; [EOL]         for ( int i = 0 ; i < splitOnNullExpectedResults.length ; i+= 1 ) { [EOL]             assertEquals( splitOnNullExpectedResults[i], splitOnNullResults[i] ) ; [EOL]         } [EOL]  [EOL]         final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiously" ; [EOL]  [EOL]         final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" } ; [EOL]         final String[] splitOnStringResults = StringUtils.splitByWholeSeparator( stringToSplitOnCharactersAndString, "aeiouy" ) ; [EOL]         assertEquals( splitOnStringExpectedResults.length, splitOnStringResults
@Test [EOL]     public void testSplitByWholeString_StringStringBoolean() { [EOL]         assertArrayEquals( null, StringUtils.splitByWholeSeparator( null, "." ) ) ; [EOL]  [EOL]         assertEquals( 0, StringUtils.splitByWholeSeparator( "", "." ).length ) ; [EOL]  [EOL]         final String stringToSplitOnNulls = "ab   de fg" ; [EOL]         final String[] splitOnNullExpectedResults = { "ab", "de", "fg" } ; [EOL]  [EOL]         final String[] splitOnNullResults = StringUtils.splitByWholeSeparator( stringToSplitOnNulls, null ) ; [EOL]         assertEquals( splitOnNullExpectedResults.length, splitOnNullResults.length ) ; [EOL]         for ( int i = 0 ; i < splitOnNullExpectedResults.length ; i+= 1 ) { [EOL]             assertEquals( splitOnNullExpectedResults[i], splitOnNullResults[i] ) ; [EOL]         } [EOL]  [EOL]         final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiously" ; [EOL]  [EOL]         final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" } ; [EOL]         final String[] splitOnStringResults = StringUtils.splitByWholeSeparator( stringToSplitOnCharactersAndString, "aeiouy" ) ; [EOL]         assertEquals( splitOnStringExpectedResults.length, splitOnStringResults
@Test [EOL]     public void testSplitByWholeString_StringStringBoolean() { [EOL]         assertArrayEquals( null, StringUtils.splitByWholeSeparator( null, "." ) ) ; [EOL]  [EOL]         assertEquals( 0, StringUtils.splitByWholeSeparator( "", "." ).length ) ; [EOL]  [EOL]         final String stringToSplitOnNulls = "ab   de fg" ; [EOL]         final String[] splitOnNullExpectedResults = { "ab", "de", "fg" } ; [EOL]  [EOL]         final String[] splitOnNullResults = StringUtils.splitByWholeSeparator( stringToSplitOnNulls, null ) ; [EOL]         assertEquals( splitOnNullExpectedResults.length, splitOnNullResults.length ) ; [EOL]         for ( int i = 0 ; i < splitOnNullExpectedResults.length ; i+= 1 ) { [EOL]             assertEquals( splitOnNullExpectedResults[i], splitOnNullResults[i] ) ; [EOL]         } [EOL]  [EOL]         final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiously" ; [EOL]  [EOL]         final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" } ; [EOL]         final String[] splitOnStringResults = StringUtils.splitByWholeSeparator( stringToSplitOnCharactersAndString, "aeiouy" ) ; [EOL]         assertEquals( splitOnStringExpectedResults.length, splitOnStringResults
@Test [EOL]     public void testSplitByWholeString_StringStringBoolean() { [EOL]         assertArrayEquals( null, StringUtils.splitByWholeSeparator( null, "." ) ) ; [EOL]  [EOL]         assertEquals( 0, StringUtils.splitByWholeSeparator( "", "." ).length ) ; [EOL]  [EOL]         final String stringToSplitOnNulls = "ab   de fg" ; [EOL]         final String[] splitOnNullExpectedResults = { "ab", "de", "fg" } ; [EOL]  [EOL]         final String[] splitOnNullResults = StringUtils.splitByWholeSeparator( stringToSplitOnNulls, null ) ; [EOL]         assertEquals( splitOnNullExpectedResults.length, splitOnNullResults.length ) ; [EOL]         for ( int i = 0 ; i < splitOnNullExpectedResults.length ; i+= 1 ) { [EOL]             assertEquals( splitOnNullExpectedResults[i], splitOnNullResults[i] ) ; [EOL]         } [EOL]  [EOL]         final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiously" ; [EOL]  [EOL]         final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" } ; [EOL]         final String[] splitOnStringResults = StringUtils.splitByWholeSeparator( stringToSplitOnCharactersAndString, "aeiouy" ) ; [EOL]         assertEquals( splitOnStringExpectedResults.length, splitOnStringResults
@Test [EOL]     public void testSplitByWholeString_StringStringBoolean() { [EOL]         assertArrayEquals( null, StringUtils.splitByWholeSeparator( null, "." ) ) ; [EOL]  [EOL]         assertEquals( 0, StringUtils.splitByWholeSeparator( "", "." ).length ) ; [EOL]  [EOL]         final String stringToSplitOnNulls = "ab   de fg" ; [EOL]         final String[] splitOnNullExpectedResults = { "ab", "de", "fg" } ; [EOL]  [EOL]         final String[] splitOnNullResults = StringUtils.splitByWholeSeparator( stringToSplitOnNulls, null ) ; [EOL]         assertEquals( splitOnNullExpectedResults.length, splitOnNullResults.length ) ; [EOL]         for ( int i = 0 ; i < splitOnNullExpectedResults.length ; i+= 1 ) { [EOL]             assertEquals( splitOnNullExpectedResults[i], splitOnNullResults[i] ) ; [EOL]         } [EOL]  [EOL]         final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiously" ; [EOL]  [EOL]         final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" } ; [EOL]         final String[] splitOnStringResults = StringUtils.splitByWholeSeparator( stringToSplitOnCharactersAndString, "aeiouy" ) ; [EOL]         assertEquals( splitOnStringExpectedResults.length, splitOnStringResults
@Test [EOL]     public void testSplitByWholeString_StringStringBoolean() { [EOL]         assertArrayEquals( null, StringUtils.splitByWholeSeparator( null, "." ) ) ; [EOL]  [EOL]         assertEquals( 0, StringUtils.splitByWholeSeparator( "", "." ).length ) ; [EOL]  [EOL]         final String stringToSplitOnNulls = "ab   de fg" ; [EOL]         final String[] splitOnNullExpectedResults = { "ab", "de", "fg" } ; [EOL]  [EOL]         final String[] splitOnNullResults = StringUtils.splitByWholeSeparator( stringToSplitOnNulls, null ) ; [EOL]         assertEquals( splitOnNullExpectedResults.length, splitOnNullResults.length ) ; [EOL]         for ( int i = 0 ; i < splitOnNullExpectedResults.length ; i+= 1 ) { [EOL]             assertEquals( splitOnNullExpectedResults[i], splitOnNullResults[i] ) ; [EOL]         } [EOL]  [EOL]         final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiously" ; [EOL]  [EOL]         final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" } ; [EOL]         final String[] splitOnStringResults = StringUtils.splitByWholeSeparator( stringToSplitOnCharactersAndString, "aeiouy" ) ; [EOL]         assertEquals( splitOnStringExpectedResults.length, splitOnStringResults
@Test [EOL]     public void testSplitByWholeString_StringStringBoolean() { [EOL]         assertArrayEquals( null, StringUtils.splitByWholeSeparator( null, "." ) ) ; [EOL]  [EOL]         assertEquals( 0, StringUtils.splitByWholeSeparator( "", "." ).length ) ; [EOL]  [EOL]         final String stringToSplitOnNulls = "ab   de fg" ; [EOL]         final String[] splitOnNullExpectedResults = { "ab", "de", "fg" } ; [EOL]  [EOL]         final String[] splitOnNullResults = StringUtils.splitByWholeSeparator( stringToSplitOnNulls, null ) ; [EOL]         assertEquals( splitOnNullExpectedResults.length, splitOnNullResults.length ) ; [EOL]         for ( int i = 0 ; i < splitOnNullExpectedResults.length ; i+= 1 ) { [EOL]             assertEquals( splitOnNullExpectedResults[i], splitOnNullResults[i] ) ; [EOL]         } [EOL]  [EOL]         final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiously" ; [EOL]  [EOL]         final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" } ; [EOL]         final String[] splitOnStringResults = StringUtils.splitByWholeSeparator( stringToSplitOnCharactersAndString, "aeiouy" ) ; [EOL]         assertEquals( splitOnStringExpectedResults.length, splitOnStringResults
@Test [EOL]     public void testSplitByWholeString_StringStringBoolean() { [EOL]         assertArrayEquals( null, StringUtils.splitByWholeSeparator( null, "." ) ) ; [EOL]  [EOL]         assertEquals( 0, StringUtils.splitByWholeSeparator( "", "." ).length ) ; [EOL]  [EOL]         final String stringToSplitOnNulls = "ab   de fg" ; [EOL]         final String[] splitOnNullExpectedResults = { "ab", "de", "fg" } ; [EOL]  [EOL]         final String[] splitOnNullResults = StringUtils.splitByWholeSeparator( stringToSplitOnNulls, null ) ; [EOL]         assertEquals( splitOnNullExpectedResults.length, splitOnNullResults.length ) ; [EOL]         for ( int i = 0 ; i < splitOnNullExpectedResults.length ; i+= 1 ) { [EOL]             assertEquals( splitOnNullExpectedResults[i], splitOnNullResults[i] ) ; [EOL]         } [EOL]  [EOL]         final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiously" ; [EOL]  [EOL]         final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" } ; [EOL]         final String[] splitOnStringResults = StringUtils.splitByWholeSeparator( stringToSplitOnCharactersAndString, "aeiouy" ) ; [EOL]         assertEquals( splitOnStringExpectedResults.length, splitOnStringResults
@Test [EOL]     public void testJoin_ArrayOfFloats() { [EOL]         assertEquals(null, StringUtils.join((float[]) null, ',')); [EOL]         assertEquals("1.0;2.0", StringUtils.join(FLOAT_PRIM_LIST, SEPARATOR_CHAR)); [EOL]         assertEquals("2.0", StringUtils.join(FLOAT_PRIM_LIST, SEPARATOR_CHAR, 1, 2)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testJoin_ArrayOfDoubles() { [EOL]         assertEquals(null, StringUtils.join((double[]) null, ',')); [EOL]         assertEquals("1.0;2.0", StringUtils.join(DOUBLE_PRIM_LIST, SEPARATOR_CHAR)); [EOL]         assertEquals("2.0", StringUtils.join(DOUBLE_PRIM_LIST, SEPARATOR_CHAR, 1, 2)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testJoin_IteratorChar() { [EOL]         assertEquals(null, StringUtils.join((Iterator<?>) null, ',')); [EOL]         assertEquals(TEXT_LIST_CHAR, StringUtils.join(Arrays.asList(ARRAY_LIST).iterator(), SEPARATOR_CHAR)); [EOL]         assertEquals("", StringUtils.join(Arrays.asList(NULL_ARRAY_LIST).iterator(), SEPARATOR_CHAR)); [EOL]         assertEquals("", StringUtils.join(Arrays.asList(EMPTY_ARRAY_LIST).iterator(), SEPARATOR_CHAR)); [EOL]         assertEquals("foo", StringUtils.join(Collections.singleton("foo").iterator(), 'x')); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testReplace_StringStringStringInt() { [EOL]         assertEquals(null, StringUtils.replace(null, null, null, 2)); [EOL]         assertEquals(null, StringUtils.replace(null, null, "any", 2)); [EOL]         assertEquals(null, StringUtils.replace(null, "any", null, 2)); [EOL]         assertEquals(null, StringUtils.replace(null, "any", "any", 2)); [EOL]  [EOL]         assertEquals("", StringUtils.replace("", null, null, 2)); [EOL]         assertEquals("", StringUtils.replace("", null, "any", 2)); [EOL]         assertEquals("", StringUtils.replace("", "any", null, 2)); [EOL]         assertEquals("", StringUtils.replace("", "any", "any", 2)); [EOL]          [EOL]         final String str = new String(new char[] {'o', 'o', 'f', 'o', 'o'}); [EOL]         assertSame(str, StringUtils.replace(str, "x", "", -1)); [EOL]          [EOL]         assertEquals("f", StringUtils.replace("oofoo", "o", "", -1)); [EOL]         assertEquals("oofoo", StringUtils.replace("oofoo", "o", "", 0)); [EOL]         assertEquals("ofoo", StringUtils.replace("oofoo", "o", "", 1)); [EOL]        
@Test [EOL]     public void testAddObjectAtIndex() { [EOL]         Object[] newArray; [EOL]         newArray = ArrayUtils.add((int[])null, 0, "a"); [EOL]         assertTrue(Arrays.equals(new String[]{"a"}, newArray)); [EOL]         assertTrue(Arrays.equals(new Object[]{"a"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         final String[] stringArray1 = new String[]{"a", "b", "c"}; [EOL]         newArray = ArrayUtils.add(stringArray1, 0, null); [EOL]         assertTrue(Arrays.equals(new String[]{null, "a", "b", "c"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.add(stringArray1, 1, null); [EOL]         assertTrue(Arrays.equals(new String[]{"a", null, "b", "c"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.add(stringArray1, 3, null); [EOL]         assertTrue(Arrays.equals(new String[]{"a", "b", "c", null}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUt
@Test [EOL]     public void testReplace_StringStringArrayStringArray() { [EOL]         //JAVADOC TESTS START [EOL]         assertNull(StringUtils.replaceEach(null, new String[]{"a"}, new String[]{"b"})); [EOL]         assertEquals(StringUtils.replaceEach("", new String[]{"a"}, new String[]{"b"}),""); [EOL]         assertEquals(StringUtils.replaceEach("aba", null, null),"aba"); [EOL]         assertEquals(StringUtils.replaceEach("aba", new String[0], null),"aba"); [EOL]         assertEquals(StringUtils.replaceEach("aba", null, new String[0]),"aba"); [EOL]         assertEquals(StringUtils.replaceEach("aba", new String[]{"a"}, null),"aba"); [EOL]  [EOL]         assertEquals(StringUtils.replaceEach("aba", new String[]{"a"}, new String[]{""}),"b"); [EOL]         assertEquals(StringUtils.replaceEach("aba", new String[]{null}, new String[]{"a"}),"aba"); [EOL]         assertEquals(StringUtils.replaceEach("abcde", new String[]{"ab", "d"}, new String[]{"w", "t"}),"wcte"); [EOL]         assertEquals(StringUtils.replaceEach("abcde", new String[]{"ab", "d"}, new String[]{"d", "t"}),"dcte"); [EOL]         //JAVADOC TESTS END [EOL]  [EOL]         assertEquals("bcc", StringUtils.replaceEach("abc", new String[]{"a", "b
@Test [EOL]     public void testReplace_StringStringArrayStringArray() { [EOL]         //JAVADOC TESTS START [EOL]         assertNull(StringUtils.replaceEach(null, new String[]{"a"}, new String[]{"b"})); [EOL]         assertEquals(StringUtils.replaceEach("", new String[]{"a"}, new String[]{"b"}),""); [EOL]         assertEquals(StringUtils.replaceEach("aba", null, null),"aba"); [EOL]         assertEquals(StringUtils.replaceEach("aba", new String[0], null),"aba"); [EOL]         assertEquals(StringUtils.replaceEach("aba", null, new String[0]),"aba"); [EOL]         assertEquals(StringUtils.replaceEach("aba", new String[]{"a"}, null),"aba"); [EOL]  [EOL]         assertEquals(StringUtils.replaceEach("aba", new String[]{"a"}, new String[]{""}),"b"); [EOL]         assertEquals(StringUtils.replaceEach("aba", new String[]{null}, new String[]{"a"}),"aba"); [EOL]         assertEquals(StringUtils.replaceEach("abcde", new String[]{"ab", "d"}, new String[]{"w", "t"}),"wcte"); [EOL]         assertEquals(StringUtils.replaceEach("abcde", new String[]{"ab", "d"}, new String[]{"d", "t"}),"dcte"); [EOL]         //JAVADOC TESTS END [EOL]  [EOL]         assertEquals("bcc", StringUtils.replaceEach("abc", new String[]{"a", "b
@Test [EOL]     public void testReplace_StringStringArrayStringArray() { [EOL]         //JAVADOC TESTS START [EOL]         assertNull(StringUtils.replaceEach(null, new String[]{"a"}, new String[]{"b"})); [EOL]         assertEquals(StringUtils.replaceEach("", new String[]{"a"}, new String[]{"b"}),""); [EOL]         assertEquals(StringUtils.replaceEach("aba", null, null),"aba"); [EOL]         assertEquals(StringUtils.replaceEach("aba", new String[0], null),"aba"); [EOL]         assertEquals(StringUtils.replaceEach("aba", null, new String[0]),"aba"); [EOL]         assertEquals(StringUtils.replaceEach("aba", new String[]{"a"}, null),"aba"); [EOL]  [EOL]         assertEquals(StringUtils.replaceEach("aba", new String[]{"a"}, new String[]{""}),"b"); [EOL]         assertEquals(StringUtils.replaceEach("aba", new String[]{null}, new String[]{"a"}),"aba"); [EOL]         assertEquals(StringUtils.replaceEach("abcde", new String[]{"ab", "d"}, new String[]{"w", "t"}),"wcte"); [EOL]         assertEquals(StringUtils.replaceEach("abcde", new String[]{"ab", "d"}, new String[]{"d", "t"}),"dcte"); [EOL]         //JAVADOC TESTS END [EOL]  [EOL]         assertEquals("bcc", StringUtils.replaceEach("abc", new String[]{"a", "b
@Test [EOL]     public void testReplace_StringStringArrayStringArray() { [EOL]         //JAVADOC TESTS START [EOL]         assertNull(StringUtils.replaceEach(null, new String[]{"a"}, new String[]{"b"})); [EOL]         assertEquals(StringUtils.replaceEach("", new String[]{"a"}, new String[]{"b"}),""); [EOL]         assertEquals(StringUtils.replaceEach("aba", null, null),"aba"); [EOL]         assertEquals(StringUtils.replaceEach("aba", new String[0], null),"aba"); [EOL]         assertEquals(StringUtils.replaceEach("aba", null, new String[0]),"aba"); [EOL]         assertEquals(StringUtils.replaceEach("aba", new String[]{"a"}, null),"aba"); [EOL]  [EOL]         assertEquals(StringUtils.replaceEach("aba", new String[]{"a"}, new String[]{""}),"b"); [EOL]         assertEquals(StringUtils.replaceEach("aba", new String[]{null}, new String[]{"a"}),"aba"); [EOL]         assertEquals(StringUtils.replaceEach("abcde", new String[]{"ab", "d"}, new String[]{"w", "t"}),"wcte"); [EOL]         assertEquals(StringUtils.replaceEach("abcde", new String[]{"ab", "d"}, new String[]{"d", "t"}),"dcte"); [EOL]         //JAVADOC TESTS END [EOL]  [EOL]         assertEquals("bcc", StringUtils.replaceEach("abc", new String[]{"a", "b
@Test [EOL]     public void testReplace_StringStringArrayStringArray() { [EOL]         //JAVADOC TESTS START [EOL]         assertNull(StringUtils.replaceEach(null, new String[]{"a"}, new String[]{"b"})); [EOL]         assertEquals(StringUtils.replaceEach("", new String[]{"a"}, new String[]{"b"}),""); [EOL]         assertEquals(StringUtils.replaceEach("aba", null, null),"aba"); [EOL]         assertEquals(StringUtils.replaceEach("aba", new String[0], null),"aba"); [EOL]         assertEquals(StringUtils.replaceEach("aba", null, new String[0]),"aba"); [EOL]         assertEquals(StringUtils.replaceEach("aba", new String[]{"a"}, null),"aba"); [EOL]  [EOL]         assertEquals(StringUtils.replaceEach("aba", new String[]{"a"}, new String[]{""}),"b"); [EOL]         assertEquals(StringUtils.replaceEach("aba", new String[]{null}, new String[]{"a"}),"aba"); [EOL]         assertEquals(StringUtils.replaceEach("abcde", new String[]{"ab", "d"}, new String[]{"w", "t"}),"wcte"); [EOL]         assertEquals(StringUtils.replaceEach("abcde", new String[]{"ab", "d"}, new String[]{"d", "t"}),"dcte"); [EOL]         //JAVADOC TESTS END [EOL]  [EOL]         assertEquals("bcc", StringUtils.replaceEach("abc", new String[]{"a", "b
@Test [EOL]     public void testReplaceChars_StringStringString() { [EOL]         assertEquals(null, StringUtils.replaceChars(null, null, null)); [EOL]         assertEquals(null, StringUtils.replaceChars(null, "", null)); [EOL]         assertEquals(null, StringUtils.replaceChars(null, "a", null)); [EOL]         assertEquals(null, StringUtils.replaceChars(null, null, "")); [EOL]         assertEquals(null, StringUtils.replaceChars(null, null, "x")); [EOL]          [EOL]         assertEquals("", StringUtils.replaceChars("", null, null)); [EOL]         assertEquals("", StringUtils.replaceChars("", "", null)); [EOL]         assertEquals("", StringUtils.replaceChars("", "a", null)); [EOL]         assertEquals("", StringUtils.replaceChars("", null, "")); [EOL]         assertEquals("", StringUtils.replaceChars("", null, "x")); [EOL]  [EOL]         assertEquals("abc", StringUtils.replaceChars("abc", null, null)); [EOL]         assertEquals("abc", StringUtils.replaceChars("abc", null, "")); [EOL]         assertEquals("abc", StringUtils.replaceChars("abc", null, "x")); [EOL]          [EOL]         assertEquals("abc", StringUtils.replaceChars("abc
@Test [EOL]     public void testReplaceChars_StringStringString() { [EOL]         assertEquals(null, StringUtils.replaceChars(null, null, null)); [EOL]         assertEquals(null, StringUtils.replaceChars(null, "", null)); [EOL]         assertEquals(null, StringUtils.replaceChars(null, "a", null)); [EOL]         assertEquals(null, StringUtils.replaceChars(null, null, "")); [EOL]         assertEquals(null, StringUtils.replaceChars(null, null, "x")); [EOL]          [EOL]         assertEquals("", StringUtils.replaceChars("", null, null)); [EOL]         assertEquals("", StringUtils.replaceChars("", "", null)); [EOL]         assertEquals("", StringUtils.replaceChars("", "a", null)); [EOL]         assertEquals("", StringUtils.replaceChars("", null, "")); [EOL]         assertEquals("", StringUtils.replaceChars("", null, "x")); [EOL]  [EOL]         assertEquals("abc", StringUtils.replaceChars("abc", null, null)); [EOL]         assertEquals("abc", StringUtils.replaceChars("abc", null, "")); [EOL]         assertEquals("abc", StringUtils.replaceChars("abc", null, "x")); [EOL]          [EOL]         assertEquals("abc", StringUtils.replaceChars("abc
@Test [EOL]     public void testChomp() { [EOL]  [EOL]         final String[][] chompCases = { [EOL]             { FOO_UNCAP + "\r\n", FOO_UNCAP }, [EOL]             { FOO_UNCAP + "\n" , FOO_UNCAP }, [EOL]             { FOO_UNCAP + "\r", FOO_UNCAP }, [EOL]             { FOO_UNCAP + " \r", FOO_UNCAP + " " }, [EOL]             { FOO_UNCAP, FOO_UNCAP }, [EOL]             { FOO_UNCAP + "\n\n", FOO_UNCAP + "\n"}, [EOL]             { FOO_UNCAP + "\r\n\r\n", FOO_UNCAP + "\r\n" }, [EOL]             { "foo\nfoo", "foo\nfoo" }, [EOL]             { "foo\n\rfoo", "foo\n\rfoo" }, [EOL]             { "\n", "" }, [EOL]             { "\r", "" }, [EOL]             { "a", "a" }, [EOL]             { "\r\n", "" }, [EOL]             { "", "" }, [EOL]             { null, null }, [EOL]      
@Test [EOL]     public void testChomp() { [EOL]  [EOL]         final String[][] chompCases = { [EOL]             { FOO_UNCAP + "\r\n", FOO_UNCAP }, [EOL]             { FOO_UNCAP + "\n" , FOO_UNCAP }, [EOL]             { FOO_UNCAP + "\r", FOO_UNCAP }, [EOL]             { FOO_UNCAP + " \r", FOO_UNCAP + " " }, [EOL]             { FOO_UNCAP, FOO_UNCAP }, [EOL]             { FOO_UNCAP + "\n\n", FOO_UNCAP + "\n"}, [EOL]             { FOO_UNCAP + "\r\n\r\n", FOO_UNCAP + "\r\n" }, [EOL]             { "foo\nfoo", "foo\nfoo" }, [EOL]             { "foo\n\rfoo", "foo\n\rfoo" }, [EOL]             { "\n", "" }, [EOL]             { "\r", "" }, [EOL]             { "a", "a" }, [EOL]             { "\r\n", "" }, [EOL]             { "", "" }, [EOL]             { null, null }, [EOL]      
@Test [EOL]     public void testChomp() { [EOL]  [EOL]         final String[][] chompCases = { [EOL]             { FOO_UNCAP + "\r\n", FOO_UNCAP }, [EOL]             { FOO_UNCAP + "\n" , FOO_UNCAP }, [EOL]             { FOO_UNCAP + "\r", FOO_UNCAP }, [EOL]             { FOO_UNCAP + " \r", FOO_UNCAP + " " }, [EOL]             { FOO_UNCAP, FOO_UNCAP }, [EOL]             { FOO_UNCAP + "\n\n", FOO_UNCAP + "\n"}, [EOL]             { FOO_UNCAP + "\r\n\r\n", FOO_UNCAP + "\r\n" }, [EOL]             { "foo\nfoo", "foo\nfoo" }, [EOL]             { "foo\n\rfoo", "foo\n\rfoo" }, [EOL]             { "\n", "" }, [EOL]             { "\r", "" }, [EOL]             { "a", "a" }, [EOL]             { "\r\n", "" }, [EOL]             { "", "" }, [EOL]             { null, null }, [EOL]      
@Test [EOL]     public void testChomp() { [EOL]  [EOL]         final String[][] chompCases = { [EOL]             { FOO_UNCAP + "\r\n", FOO_UNCAP }, [EOL]             { FOO_UNCAP + "\n" , FOO_UNCAP }, [EOL]             { FOO_UNCAP + "\r", FOO_UNCAP }, [EOL]             { FOO_UNCAP + " \r", FOO_UNCAP + " " }, [EOL]             { FOO_UNCAP, FOO_UNCAP }, [EOL]             { FOO_UNCAP + "\n\n", FOO_UNCAP + "\n"}, [EOL]             { FOO_UNCAP + "\r\n\r\n", FOO_UNCAP + "\r\n" }, [EOL]             { "foo\nfoo", "foo\nfoo" }, [EOL]             { "foo\n\rfoo", "foo\n\rfoo" }, [EOL]             { "\n", "" }, [EOL]             { "\r", "" }, [EOL]             { "a", "a" }, [EOL]             { "\r\n", "" }, [EOL]             { "", "" }, [EOL]             { null, null }, [EOL]      
@Test [EOL]     public void testChomp() { [EOL]  [EOL]         final String[][] chompCases = { [EOL]             { FOO_UNCAP + "\r\n", FOO_UNCAP }, [EOL]             { FOO_UNCAP + "\n" , FOO_UNCAP }, [EOL]             { FOO_UNCAP + "\r", FOO_UNCAP }, [EOL]             { FOO_UNCAP + " \r", FOO_UNCAP + " " }, [EOL]             { FOO_UNCAP, FOO_UNCAP }, [EOL]             { FOO_UNCAP + "\n\n", FOO_UNCAP + "\n"}, [EOL]             { FOO_UNCAP + "\r\n\r\n", FOO_UNCAP + "\r\n" }, [EOL]             { "foo\nfoo", "foo\nfoo" }, [EOL]             { "foo\n\rfoo", "foo\n\rfoo" }, [EOL]             { "\n", "" }, [EOL]             { "\r", "" }, [EOL]             { "a", "a" }, [EOL]             { "\r\n", "" }, [EOL]             { "", "" }, [EOL]             { null, null }, [EOL]      
@Test [EOL]     public void testChomp() { [EOL]  [EOL]         final String[][] chompCases = { [EOL]             { FOO_UNCAP + "\r\n", FOO_UNCAP }, [EOL]             { FOO_UNCAP + "\n" , FOO_UNCAP }, [EOL]             { FOO_UNCAP + "\r", FOO_UNCAP }, [EOL]             { FOO_UNCAP + " \r", FOO_UNCAP + " " }, [EOL]             { FOO_UNCAP, FOO_UNCAP }, [EOL]             { FOO_UNCAP + "\n\n", FOO_UNCAP + "\n"}, [EOL]             { FOO_UNCAP + "\r\n\r\n", FOO_UNCAP + "\r\n" }, [EOL]             { "foo\nfoo", "foo\nfoo" }, [EOL]             { "foo\n\rfoo", "foo\n\rfoo" }, [EOL]             { "\n", "" }, [EOL]             { "\r", "" }, [EOL]             { "a", "a" }, [EOL]             { "\r\n", "" }, [EOL]             { "", "" }, [EOL]             { null, null }, [EOL]      
@Test [EOL]     public void testChop() { [EOL]  [EOL]         final String[][] chopCases = { [EOL]             { FOO_UNCAP + "\r\n", FOO_UNCAP } , [EOL]             { FOO_UNCAP + "\n" , FOO_UNCAP } , [EOL]             { FOO_UNCAP + "\r", FOO_UNCAP }, [EOL]             { FOO_UNCAP + " \r", FOO_UNCAP + " " }, [EOL]             { "foo", "fo"}, [EOL]             { "foo\nfoo", "foo\nfo" }, [EOL]             { "\n", "" }, [EOL]             { "\r", "" }, [EOL]             { "\r\n", "" }, [EOL]             { null, null }, [EOL]             { "", "" }, [EOL]             { "a", "" }, [EOL]         }; [EOL]         for (final String[] chopCase : chopCases) { [EOL]             final String original = chopCase[0]; [EOL]             final String expectedResult = chopCase[1]; [EOL]             assertEquals("chop(String) failed", [EOL]            
@Test [EOL]     public void testRepeat_StringInt() { [EOL]         assertEquals(null, StringUtils.repeat(null, 2)); [EOL]         assertEquals("", StringUtils.repeat("ab", 0)); [EOL]         assertEquals("", StringUtils.repeat("", 3)); [EOL]         assertEquals("aaa", StringUtils.repeat("a", 3)); [EOL]         assertEquals("ababab", StringUtils.repeat("ab", 3)); [EOL]         assertEquals("abcabcabc", StringUtils.repeat("abc", 3)); [EOL]         final String str = StringUtils.repeat("a", 10000);  // bigger than pad limit [EOL]         assertEquals(10000, str.length()); [EOL]         assertTrue(StringUtils.containsOnly(str, new char[] {'a'})); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testRepeat_StringInt() { [EOL]         assertEquals(null, StringUtils.repeat(null, 2)); [EOL]         assertEquals("", StringUtils.repeat("ab", 0)); [EOL]         assertEquals("", StringUtils.repeat("", 3)); [EOL]         assertEquals("aaa", StringUtils.repeat("a", 3)); [EOL]         assertEquals("ababab", StringUtils.repeat("ab", 3)); [EOL]         assertEquals("abcabcabc", StringUtils.repeat("abc", 3)); [EOL]         final String str = StringUtils.repeat("a", 10000);  // bigger than pad limit [EOL]         assertEquals(10000, str.length()); [EOL]         assertTrue(StringUtils.containsOnly(str, new char[] {'a'})); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testRepeat_StringInt() { [EOL]         assertEquals(null, StringUtils.repeat(null, 2)); [EOL]         assertEquals("", StringUtils.repeat("ab", 0)); [EOL]         assertEquals("", StringUtils.repeat("", 3)); [EOL]         assertEquals("aaa", StringUtils.repeat("a", 3)); [EOL]         assertEquals("ababab", StringUtils.repeat("ab", 3)); [EOL]         assertEquals("abcabcabc", StringUtils.repeat("abc", 3)); [EOL]         final String str = StringUtils.repeat("a", 10000);  // bigger than pad limit [EOL]         assertEquals(10000, str.length()); [EOL]         assertTrue(StringUtils.containsOnly(str, new char[] {'a'})); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testCenter_StringIntChar() { [EOL]         assertEquals(null, StringUtils.center(null, -1, ' ')); [EOL]         assertEquals(null, StringUtils.center(null, 4, ' ')); [EOL]         assertEquals("    ", StringUtils.center("", 4, ' ')); [EOL]         assertEquals("ab", StringUtils.center("ab", 0, ' ')); [EOL]         assertEquals("ab", StringUtils.center("ab", -1, ' ')); [EOL]         assertEquals("ab", StringUtils.center("ab", 1, ' ')); [EOL]         assertEquals("    ", StringUtils.center("", 4, ' ')); [EOL]         assertEquals(" ab ", StringUtils.center("ab", 4, ' ')); [EOL]         assertEquals("abcd", StringUtils.center("abcd", 2, ' ')); [EOL]         assertEquals(" a  ", StringUtils.center("a", 4, ' ')); [EOL]         assertEquals("  a  ", StringUtils.center("a", 5, ' ')); [EOL]         assertEquals("xxaxx", StringUtils.center("a", 5, 'x')); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testCenter_StringIntString() { [EOL]         assertEquals(null, StringUtils.center(null, 4, null)); [EOL]         assertEquals(null, StringUtils.center(null, -1, " ")); [EOL]         assertEquals(null, StringUtils.center(null, 4, " ")); [EOL]         assertEquals("    ", StringUtils.center("", 4, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 0, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", -1, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 1, " ")); [EOL]         assertEquals("    ", StringUtils.center("", 4, " ")); [EOL]         assertEquals(" ab ", StringUtils.center("ab", 4, " ")); [EOL]         assertEquals("abcd", StringUtils.center("abcd", 2, " ")); [EOL]         assertEquals(" a  ", StringUtils.center("a", 4, " ")); [EOL]         assertEquals("yayz", StringUtils.center("a", 4, "yz")); [EOL]         assertEquals("yzyayzy", StringUtils.center("a", 7, "yz")); [EOL]         assertEquals("  abc  ", StringUtils.center("abc", 7, null)); [EOL]         assertEquals("  abc  ", StringUtils.center("abc",
@Test [EOL]     public void testCenter_StringIntString() { [EOL]         assertEquals(null, StringUtils.center(null, 4, null)); [EOL]         assertEquals(null, StringUtils.center(null, -1, " ")); [EOL]         assertEquals(null, StringUtils.center(null, 4, " ")); [EOL]         assertEquals("    ", StringUtils.center("", 4, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 0, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", -1, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 1, " ")); [EOL]         assertEquals("    ", StringUtils.center("", 4, " ")); [EOL]         assertEquals(" ab ", StringUtils.center("ab", 4, " ")); [EOL]         assertEquals("abcd", StringUtils.center("abcd", 2, " ")); [EOL]         assertEquals(" a  ", StringUtils.center("a", 4, " ")); [EOL]         assertEquals("yayz", StringUtils.center("a", 4, "yz")); [EOL]         assertEquals("yzyayzy", StringUtils.center("a", 7, "yz")); [EOL]         assertEquals("  abc  ", StringUtils.center("abc", 7, null)); [EOL]         assertEquals("  abc  ", StringUtils.center("abc",
@Test [EOL]     public void testCenter_StringIntChar() { [EOL]         assertEquals(null, StringUtils.center(null, -1, ' ')); [EOL]         assertEquals(null, StringUtils.center(null, 4, ' ')); [EOL]         assertEquals("    ", StringUtils.center("", 4, ' ')); [EOL]         assertEquals("ab", StringUtils.center("ab", 0, ' ')); [EOL]         assertEquals("ab", StringUtils.center("ab", -1, ' ')); [EOL]         assertEquals("ab", StringUtils.center("ab", 1, ' ')); [EOL]         assertEquals("    ", StringUtils.center("", 4, ' ')); [EOL]         assertEquals(" ab ", StringUtils.center("ab", 4, ' ')); [EOL]         assertEquals("abcd", StringUtils.center("abcd", 2, ' ')); [EOL]         assertEquals(" a  ", StringUtils.center("a", 4, ' ')); [EOL]         assertEquals("  a  ", StringUtils.center("a", 5, ' ')); [EOL]         assertEquals("xxaxx", StringUtils.center("a", 5, 'x')); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testCenter_StringIntString() { [EOL]         assertEquals(null, StringUtils.center(null, 4, null)); [EOL]         assertEquals(null, StringUtils.center(null, -1, " ")); [EOL]         assertEquals(null, StringUtils.center(null, 4, " ")); [EOL]         assertEquals("    ", StringUtils.center("", 4, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 0, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", -1, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 1, " ")); [EOL]         assertEquals("    ", StringUtils.center("", 4, " ")); [EOL]         assertEquals(" ab ", StringUtils.center("ab", 4, " ")); [EOL]         assertEquals("abcd", StringUtils.center("abcd", 2, " ")); [EOL]         assertEquals(" a  ", StringUtils.center("a", 4, " ")); [EOL]         assertEquals("yayz", StringUtils.center("a", 4, "yz")); [EOL]         assertEquals("yzyayzy", StringUtils.center("a", 7, "yz")); [EOL]         assertEquals("  abc  ", StringUtils.center("abc", 7, null)); [EOL]         assertEquals("  abc  ", StringUtils.center("abc",
@Test [EOL]     public void testCenter_StringIntString() { [EOL]         assertEquals(null, StringUtils.center(null, 4, null)); [EOL]         assertEquals(null, StringUtils.center(null, -1, " ")); [EOL]         assertEquals(null, StringUtils.center(null, 4, " ")); [EOL]         assertEquals("    ", StringUtils.center("", 4, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 0, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", -1, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 1, " ")); [EOL]         assertEquals("    ", StringUtils.center("", 4, " ")); [EOL]         assertEquals(" ab ", StringUtils.center("ab", 4, " ")); [EOL]         assertEquals("abcd", StringUtils.center("abcd", 2, " ")); [EOL]         assertEquals(" a  ", StringUtils.center("a", 4, " ")); [EOL]         assertEquals("yayz", StringUtils.center("a", 4, "yz")); [EOL]         assertEquals("yzyayzy", StringUtils.center("a", 7, "yz")); [EOL]         assertEquals("  abc  ", StringUtils.center("abc", 7, null)); [EOL]         assertEquals("  abc  ", StringUtils.center("abc",
@Test [EOL]     public void testIsAlpha() { [EOL]         assertFalse(StringUtils.isAlpha(null)); [EOL]         assertFalse(StringUtils.isAlpha("")); [EOL]         assertFalse(StringUtils.isAlpha(" ")); [EOL]         assertTrue(StringUtils.isAlpha("a")); [EOL]         assertTrue(StringUtils.isAlpha("A")); [EOL]         assertTrue(StringUtils.isAlpha("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); [EOL]         assertFalse(StringUtils.isAlpha("ham kso")); [EOL]         assertFalse(StringUtils.isAlpha("1")); [EOL]         assertFalse(StringUtils.isAlpha("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); [EOL]         assertFalse(StringUtils.isAlpha("_")); [EOL]         assertFalse(StringUtils.isAlpha("hkHKHik*khbkuh")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsAlphaspace() { [EOL]         assertFalse(StringUtils.isAlphaSpace(null)); [EOL]         assertTrue(StringUtils.isAlphaSpace("")); [EOL]         assertTrue(StringUtils.isAlphaSpace(" ")); [EOL]         assertTrue(StringUtils.isAlphaSpace("a")); [EOL]         assertTrue(StringUtils.isAlphaSpace("A")); [EOL]         assertTrue(StringUtils.isAlphaSpace("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); [EOL]         assertTrue(StringUtils.isAlphaSpace("ham kso")); [EOL]         assertFalse(StringUtils.isAlphaSpace("1")); [EOL]         assertFalse(StringUtils.isAlphaSpace("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); [EOL]         assertFalse(StringUtils.isAlphaSpace("_")); [EOL]         assertFalse(StringUtils.isAlphaSpace("hkHKHik*khbkuh")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsAlphanumeric() { [EOL]         assertFalse(StringUtils.isAlphanumeric(null)); [EOL]         assertFalse(StringUtils.isAlphanumeric("")); [EOL]         assertFalse(StringUtils.isAlphanumeric(" ")); [EOL]         assertTrue(StringUtils.isAlphanumeric("a")); [EOL]         assertTrue(StringUtils.isAlphanumeric("A")); [EOL]         assertTrue(StringUtils.isAlphanumeric("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); [EOL]         assertFalse(StringUtils.isAlphanumeric("ham kso")); [EOL]         assertTrue(StringUtils.isAlphanumeric("1")); [EOL]         assertTrue(StringUtils.isAlphanumeric("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); [EOL]         assertFalse(StringUtils.isAlphanumeric("_")); [EOL]         assertFalse(StringUtils.isAlphanumeric("hkHKHik*khbkuh")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsAsciiPrintable_String() { [EOL]         assertFalse(StringUtils.isAsciiPrintable(null)); [EOL]         assertTrue(StringUtils.isAsciiPrintable("")); [EOL]         assertTrue(StringUtils.isAsciiPrintable(" ")); [EOL]         assertTrue(StringUtils.isAsciiPrintable("a")); [EOL]         assertTrue(StringUtils.isAsciiPrintable("A")); [EOL]         assertTrue(StringUtils.isAsciiPrintable("1")); [EOL]         assertTrue(StringUtils.isAsciiPrintable("Ceki")); [EOL]         assertTrue(StringUtils.isAsciiPrintable("!ab2c~")); [EOL]         assertTrue(StringUtils.isAsciiPrintable("1000")); [EOL]         assertTrue(StringUtils.isAsciiPrintable("10 00")); [EOL]         assertFalse(StringUtils.isAsciiPrintable("10\t00")); [EOL]         assertTrue(StringUtils.isAsciiPrintable("10.00")); [EOL]         assertTrue(StringUtils.isAsciiPrintable("10,00")); [EOL]         assertTrue(StringUtils.isAsciiPrintable("!ab-c~")); [EOL]         assertTrue(StringUtils.isAsciiPrintable("hkHK=Hik6i?UGH_KJgU7.tUJgKJ*GI87GI,k
@Test [EOL]     public void testIsNumeric() { [EOL]         assertFalse(StringUtils.isNumeric(null)); [EOL]         assertFalse(StringUtils.isNumeric("")); [EOL]         assertFalse(StringUtils.isNumeric(" ")); [EOL]         assertFalse(StringUtils.isNumeric("a")); [EOL]         assertFalse(StringUtils.isNumeric("A")); [EOL]         assertFalse(StringUtils.isNumeric("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); [EOL]         assertFalse(StringUtils.isNumeric("ham kso")); [EOL]         assertTrue(StringUtils.isNumeric("1")); [EOL]         assertTrue(StringUtils.isNumeric("1000")); [EOL]         assertFalse(StringUtils.isNumeric("2.3")); [EOL]         assertFalse(StringUtils.isNumeric("10 00")); [EOL]         assertFalse(StringUtils.isNumeric("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); [EOL]         assertFalse(StringUtils.isNumeric("_")); [EOL]         assertFalse(StringUtils.isNumeric("hkHKHik*khbkuh")); [EOL]         assertFalse(StringUtils.isNumeric("+123")); [EOL]         assertFalse(StringUtils.isNumeric("-123")); [EOL] 
@Test [EOL]     public void testIsAllLowerCase() { [EOL]         assertFalse(StringUtils.isAllLowerCase(null)); [EOL]         assertFalse(StringUtils.isAllLowerCase(StringUtils.EMPTY)); [EOL]         assertTrue(StringUtils.isAllLowerCase("abc")); [EOL]         assertFalse(StringUtils.isAllLowerCase("abc ")); [EOL]         assertFalse(StringUtils.isAllLowerCase("abC")); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test for {@link StringUtils#isAllUpperCase(CharSequence)}. [EOL]      */ [EOL]
@Test [EOL]     public void testIsAllUpperCase() { [EOL]         assertFalse(StringUtils.isAllUpperCase(null)); [EOL]         assertFalse(StringUtils.isAllUpperCase(StringUtils.EMPTY)); [EOL]         assertTrue(StringUtils.isAllUpperCase("ABC")); [EOL]         assertFalse(StringUtils.isAllUpperCase("ABC ")); [EOL]         assertFalse(StringUtils.isAllUpperCase("aBC")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testAbbreviate_StringIntInt() { [EOL]         assertEquals(null, StringUtils.abbreviate(null, 10, 12)); [EOL]         assertEquals("", StringUtils.abbreviate("", 0, 10)); [EOL]         assertEquals("", StringUtils.abbreviate("", 2, 10)); [EOL]          [EOL]         try { [EOL]             @SuppressWarnings("unused") [EOL]             final [EOL]             String res = StringUtils.abbreviate("abcdefghij", 0, 3); [EOL]             fail("StringUtils.abbreviate expecting IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException ex) { [EOL]                 // empty [EOL]         }       [EOL]         try { [EOL]             @SuppressWarnings("unused") [EOL]             final [EOL]             String res = StringUtils.abbreviate("abcdefghij", 5, 6); [EOL]             fail("StringUtils.abbreviate expecting IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException ex) { [EOL]                 // empty [EOL]  
@Test [EOL]     public void testAbbreviateMiddle() { [EOL]         // javadoc examples [EOL]         assertNull( StringUtils.abbreviateMiddle(null, null, 0) ); [EOL]         assertEquals( "abc", StringUtils.abbreviateMiddle("abc", null, 0) ); [EOL]         assertEquals( "abc", StringUtils.abbreviateMiddle("abc", ".", 0) ); [EOL]         assertEquals( "abc", StringUtils.abbreviateMiddle("abc", ".", 3) ); [EOL]         assertEquals( "ab.f", StringUtils.abbreviateMiddle("abcdef", ".", 4) ); [EOL]  [EOL]         // JIRA issue (LANG-405) example (slightly different than actual expected result) [EOL]         assertEquals(  [EOL]             "A very long text with un...f the text is complete.", [EOL]             StringUtils.abbreviateMiddle( [EOL]                 "A very long text with unimportant stuff in the middle but interesting start and " + [EOL]                 "end to see if the text is complete.", "...", 50) ); [EOL]  [EOL]         // Test a much longer text :) [EOL]         final String longText = "Start text" + StringUtils.repeat("x", 10000) + "Close text"; [EOL]         assertEquals(  [EOL]             "Start
@Test [EOL]     public void testAbbreviateMiddle() { [EOL]         // javadoc examples [EOL]         assertNull( StringUtils.abbreviateMiddle(null, null, 0) ); [EOL]         assertEquals( "abc", StringUtils.abbreviateMiddle("abc", null, 0) ); [EOL]         assertEquals( "abc", StringUtils.abbreviateMiddle("abc", ".", 0) ); [EOL]         assertEquals( "abc", StringUtils.abbreviateMiddle("abc", ".", 3) ); [EOL]         assertEquals( "ab.f", StringUtils.abbreviateMiddle("abcdef", ".", 4) ); [EOL]  [EOL]         // JIRA issue (LANG-405) example (slightly different than actual expected result) [EOL]         assertEquals(  [EOL]             "A very long text with un...f the text is complete.", [EOL]             StringUtils.abbreviateMiddle( [EOL]                 "A very long text with unimportant stuff in the middle but interesting start and " + [EOL]                 "end to see if the text is complete.", "...", 50) ); [EOL]  [EOL]         // Test a much longer text :) [EOL]         final String longText = "Start text" + StringUtils.repeat("x", 10000) + "Close text"; [EOL]         assertEquals(  [EOL]             "Start
@Test [EOL]     public void testAbbreviateMiddle() { [EOL]         // javadoc examples [EOL]         assertNull( StringUtils.abbreviateMiddle(null, null, 0) ); [EOL]         assertEquals( "abc", StringUtils.abbreviateMiddle("abc", null, 0) ); [EOL]         assertEquals( "abc", StringUtils.abbreviateMiddle("abc", ".", 0) ); [EOL]         assertEquals( "abc", StringUtils.abbreviateMiddle("abc", ".", 3) ); [EOL]         assertEquals( "ab.f", StringUtils.abbreviateMiddle("abcdef", ".", 4) ); [EOL]  [EOL]         // JIRA issue (LANG-405) example (slightly different than actual expected result) [EOL]         assertEquals(  [EOL]             "A very long text with un...f the text is complete.", [EOL]             StringUtils.abbreviateMiddle( [EOL]                 "A very long text with unimportant stuff in the middle but interesting start and " + [EOL]                 "end to see if the text is complete.", "...", 50) ); [EOL]  [EOL]         // Test a much longer text :) [EOL]         final String longText = "Start text" + StringUtils.repeat("x", 10000) + "Close text"; [EOL]         assertEquals(  [EOL]             "Start
@Test [EOL]     public void testAbbreviateMiddle() { [EOL]         // javadoc examples [EOL]         assertNull( StringUtils.abbreviateMiddle(null, null, 0) ); [EOL]         assertEquals( "abc", StringUtils.abbreviateMiddle("abc", null, 0) ); [EOL]         assertEquals( "abc", StringUtils.abbreviateMiddle("abc", ".", 0) ); [EOL]         assertEquals( "abc", StringUtils.abbreviateMiddle("abc", ".", 3) ); [EOL]         assertEquals( "ab.f", StringUtils.abbreviateMiddle("abcdef", ".", 4) ); [EOL]  [EOL]         // JIRA issue (LANG-405) example (slightly different than actual expected result) [EOL]         assertEquals(  [EOL]             "A very long text with un...f the text is complete.", [EOL]             StringUtils.abbreviateMiddle( [EOL]                 "A very long text with unimportant stuff in the middle but interesting start and " + [EOL]                 "end to see if the text is complete.", "...", 50) ); [EOL]  [EOL]         // Test a much longer text :) [EOL]         final String longText = "Start text" + StringUtils.repeat("x", 10000) + "Close text"; [EOL]         assertEquals(  [EOL]             "Start
@Test [EOL]     public void testAbbreviateMiddle() { [EOL]         // javadoc examples [EOL]         assertNull( StringUtils.abbreviateMiddle(null, null, 0) ); [EOL]         assertEquals( "abc", StringUtils.abbreviateMiddle("abc", null, 0) ); [EOL]         assertEquals( "abc", StringUtils.abbreviateMiddle("abc", ".", 0) ); [EOL]         assertEquals( "abc", StringUtils.abbreviateMiddle("abc", ".", 3) ); [EOL]         assertEquals( "ab.f", StringUtils.abbreviateMiddle("abcdef", ".", 4) ); [EOL]  [EOL]         // JIRA issue (LANG-405) example (slightly different than actual expected result) [EOL]         assertEquals(  [EOL]             "A very long text with un...f the text is complete.", [EOL]             StringUtils.abbreviateMiddle( [EOL]                 "A very long text with unimportant stuff in the middle but interesting start and " + [EOL]                 "end to see if the text is complete.", "...", 50) ); [EOL]  [EOL]         // Test a much longer text :) [EOL]         final String longText = "Start text" + StringUtils.repeat("x", 10000) + "Close text"; [EOL]         assertEquals(  [EOL]             "Start
@Test [EOL]     public void testAbbreviateMiddle() { [EOL]         // javadoc examples [EOL]         assertNull( StringUtils.abbreviateMiddle(null, null, 0) ); [EOL]         assertEquals( "abc", StringUtils.abbreviateMiddle("abc", null, 0) ); [EOL]         assertEquals( "abc", StringUtils.abbreviateMiddle("abc", ".", 0) ); [EOL]         assertEquals( "abc", StringUtils.abbreviateMiddle("abc", ".", 3) ); [EOL]         assertEquals( "ab.f", StringUtils.abbreviateMiddle("abcdef", ".", 4) ); [EOL]  [EOL]         // JIRA issue (LANG-405) example (slightly different than actual expected result) [EOL]         assertEquals(  [EOL]             "A very long text with un...f the text is complete.", [EOL]             StringUtils.abbreviateMiddle( [EOL]                 "A very long text with unimportant stuff in the middle but interesting start and " + [EOL]                 "end to see if the text is complete.", "...", 50) ); [EOL]  [EOL]         // Test a much longer text :) [EOL]         final String longText = "Start text" + StringUtils.repeat("x", 10000) + "Close text"; [EOL]         assertEquals(  [EOL]             "Start
@Test [EOL]     public void testAbbreviateMiddle() { [EOL]         // javadoc examples [EOL]         assertNull( StringUtils.abbreviateMiddle(null, null, 0) ); [EOL]         assertEquals( "abc", StringUtils.abbreviateMiddle("abc", null, 0) ); [EOL]         assertEquals( "abc", StringUtils.abbreviateMiddle("abc", ".", 0) ); [EOL]         assertEquals( "abc", StringUtils.abbreviateMiddle("abc", ".", 3) ); [EOL]         assertEquals( "ab.f", StringUtils.abbreviateMiddle("abcdef", ".", 4) ); [EOL]  [EOL]         // JIRA issue (LANG-405) example (slightly different than actual expected result) [EOL]         assertEquals(  [EOL]             "A very long text with un...f the text is complete.", [EOL]             StringUtils.abbreviateMiddle( [EOL]                 "A very long text with unimportant stuff in the middle but interesting start and " + [EOL]                 "end to see if the text is complete.", "...", 50) ); [EOL]  [EOL]         // Test a much longer text :) [EOL]         final String longText = "Start text" + StringUtils.repeat("x", 10000) + "Close text"; [EOL]         assertEquals(  [EOL]             "Start
@Test [EOL]     public void testAbbreviateMiddle() { [EOL]         // javadoc examples [EOL]         assertNull( StringUtils.abbreviateMiddle(null, null, 0) ); [EOL]         assertEquals( "abc", StringUtils.abbreviateMiddle("abc", null, 0) ); [EOL]         assertEquals( "abc", StringUtils.abbreviateMiddle("abc", ".", 0) ); [EOL]         assertEquals( "abc", StringUtils.abbreviateMiddle("abc", ".", 3) ); [EOL]         assertEquals( "ab.f", StringUtils.abbreviateMiddle("abcdef", ".", 4) ); [EOL]  [EOL]         // JIRA issue (LANG-405) example (slightly different than actual expected result) [EOL]         assertEquals(  [EOL]             "A very long text with un...f the text is complete.", [EOL]             StringUtils.abbreviateMiddle( [EOL]                 "A very long text with unimportant stuff in the middle but interesting start and " + [EOL]                 "end to see if the text is complete.", "...", 50) ); [EOL]  [EOL]         // Test a much longer text :) [EOL]         final String longText = "Start text" + StringUtils.repeat("x", 10000) + "Close text"; [EOL]         assertEquals(  [EOL]             "Start
@Test [EOL]     public void testDifference_StringString() { [EOL]         assertEquals(null, StringUtils.difference(null, null)); [EOL]         assertEquals("", StringUtils.difference("", "")); [EOL]         assertEquals("abc", StringUtils.difference("", "abc")); [EOL]         assertEquals("", StringUtils.difference("abc", "")); [EOL]         assertEquals("i am a robot", StringUtils.difference(null, "i am a robot")); [EOL]         assertEquals("i am a machine", StringUtils.difference("i am a machine", null)); [EOL]         assertEquals("robot", StringUtils.difference("i am a machine", "i am a robot")); [EOL]         assertEquals("", StringUtils.difference("abc", "abc")); [EOL]         assertEquals("you are a robot", StringUtils.difference("i am a robot", "you are a robot")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetCommonPrefix_StringArray() { [EOL]         assertEquals("", StringUtils.getCommonPrefix((String[])null)); [EOL]         assertEquals("", StringUtils.getCommonPrefix()); [EOL]         assertEquals("abc", StringUtils.getCommonPrefix("abc")); [EOL]         assertEquals("", StringUtils.getCommonPrefix(null, null)); [EOL]         assertEquals("", StringUtils.getCommonPrefix("", "")); [EOL]         assertEquals("", StringUtils.getCommonPrefix("", null)); [EOL]         assertEquals("", StringUtils.getCommonPrefix("abc", null, null)); [EOL]         assertEquals("", StringUtils.getCommonPrefix(null, null, "abc")); [EOL]         assertEquals("", StringUtils.getCommonPrefix("", "abc")); [EOL]         assertEquals("", StringUtils.getCommonPrefix("abc", "")); [EOL]         assertEquals("abc", StringUtils.getCommonPrefix("abc", "abc")); [EOL]         assertEquals("a", StringUtils.getCommonPrefix("abc", "a")); [EOL]         assertEquals("ab", StringUtils.getCommonPrefix("ab", "abxyz")); [EOL]         assertEquals("ab", StringUtils.getCommonPrefix("abcde", "abxyz")); [EOL]         assertEquals("", StringUtils.getCommonPrefix("abcde", "xyz")); [
@Test [EOL]     public void testGetCommonPrefix_StringArray() { [EOL]         assertEquals("", StringUtils.getCommonPrefix((String[])null)); [EOL]         assertEquals("", StringUtils.getCommonPrefix()); [EOL]         assertEquals("abc", StringUtils.getCommonPrefix("abc")); [EOL]         assertEquals("", StringUtils.getCommonPrefix(null, null)); [EOL]         assertEquals("", StringUtils.getCommonPrefix("", "")); [EOL]         assertEquals("", StringUtils.getCommonPrefix("", null)); [EOL]         assertEquals("", StringUtils.getCommonPrefix("abc", null, null)); [EOL]         assertEquals("", StringUtils.getCommonPrefix(null, null, "abc")); [EOL]         assertEquals("", StringUtils.getCommonPrefix("", "abc")); [EOL]         assertEquals("", StringUtils.getCommonPrefix("abc", "")); [EOL]         assertEquals("abc", StringUtils.getCommonPrefix("abc", "abc")); [EOL]         assertEquals("a", StringUtils.getCommonPrefix("abc", "a")); [EOL]         assertEquals("ab", StringUtils.getCommonPrefix("ab", "abxyz")); [EOL]         assertEquals("ab", StringUtils.getCommonPrefix("abcde", "abxyz")); [EOL]         assertEquals("", StringUtils.getCommonPrefix("abcde", "xyz")); [
@Test [EOL]     public void testGetCommonPrefix_StringArray() { [EOL]         assertEquals("", StringUtils.getCommonPrefix((String[])null)); [EOL]         assertEquals("", StringUtils.getCommonPrefix()); [EOL]         assertEquals("abc", StringUtils.getCommonPrefix("abc")); [EOL]         assertEquals("", StringUtils.getCommonPrefix(null, null)); [EOL]         assertEquals("", StringUtils.getCommonPrefix("", "")); [EOL]         assertEquals("", StringUtils.getCommonPrefix("", null)); [EOL]         assertEquals("", StringUtils.getCommonPrefix("abc", null, null)); [EOL]         assertEquals("", StringUtils.getCommonPrefix(null, null, "abc")); [EOL]         assertEquals("", StringUtils.getCommonPrefix("", "abc")); [EOL]         assertEquals("", StringUtils.getCommonPrefix("abc", "")); [EOL]         assertEquals("abc", StringUtils.getCommonPrefix("abc", "abc")); [EOL]         assertEquals("a", StringUtils.getCommonPrefix("abc", "a")); [EOL]         assertEquals("ab", StringUtils.getCommonPrefix("ab", "abxyz")); [EOL]         assertEquals("ab", StringUtils.getCommonPrefix("abcde", "abxyz")); [EOL]         assertEquals("", StringUtils.getCommonPrefix("abcde", "xyz")); [
@Test [EOL]     public void testGetLevenshteinDistance_StringString() { [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("", "") ); [EOL]         assertEquals(1, StringUtils.getLevenshteinDistance("", "a") ); [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "") ); [EOL]         assertEquals(1, StringUtils.getLevenshteinDistance("frog", "fog") ); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("fly", "ant") ); [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("elephant", "hippo") ); [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("hippo", "elephant") ); [EOL]         assertEquals(8, StringUtils.getLevenshteinDistance("hippo", "zzzzzzzz") ); [EOL]         assertEquals(8, StringUtils.getLevenshteinDistance("zzzzzzzz", "hippo") ); [EOL]         assertEquals(1, StringUtils.getLevenshteinDistance("hello", "hallo") ); [EOL]         try { [EOL]             @SuppressWarnings("unused") [EOL]             final [EOL]             int d = StringUtils.getLevenshteinDistance("a", null); [EOL]             fail
@Test [EOL]     public void testGetLevenshteinDistance_StringStringInt() { [EOL]         // empty strings [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("", "", 0)); [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "", 8)); [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "", 7)); [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("aaapppp", "", 6)); [EOL]  [EOL]         // unequal strings, zero threshold [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("b", "a", 0)); [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("a", "b", 0)); [EOL]      [EOL]         // equal strings [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("aa", "aa", 0)); [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("aa", "aa", 2)); [EOL]  [EOL]         // same length [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("aaa", "bbb", 2)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("aaa", "bbb", 3)); [EOL]      [EOL]         // big stripe [EOL]
@Test [EOL]     public void testStartsWithAny() { [EOL]         assertFalse(StringUtils.startsWithAny(null, (String[])null)); [EOL]         assertFalse(StringUtils.startsWithAny(null, "abc")); [EOL]         assertFalse(StringUtils.startsWithAny("abcxyz", (String[])null)); [EOL]         assertFalse(StringUtils.startsWithAny("abcxyz")); [EOL]         assertTrue(StringUtils.startsWithAny("abcxyz", "abc")); [EOL]         assertTrue(StringUtils.startsWithAny("abcxyz", null, "xyz", "abc")); [EOL]         assertFalse(StringUtils.startsWithAny("abcxyz", null, "xyz", "abcd")); [EOL]  [EOL]         assertTrue("StringUtils.startsWithAny(abcxyz, StringBuilder(xyz), StringBuffer(abc))", StringUtils.startsWithAny("abcxyz", new StringBuilder("xyz"), new StringBuffer("abc"))); [EOL]         assertTrue("StringUtils.startsWithAny( StrBuilder(abcxyz), StringBuilder(xyz), StringBuffer(abc))", StringUtils.startsWithAny( new StrBuilder("abcxyz"), new StringBuilder("xyz"), new StringBuffer("abc"))); [EOL]     } [EOL]   [EOL]  [EOL]     /** [EOL]      * Test StringUtils.endsWith() [EOL]      */ [EOL]
@Test [EOL]     public void testNormalizeSpace() { [EOL]         assertEquals(null, StringUtils.normalizeSpace(null)); [EOL]         assertEquals("", StringUtils.normalizeSpace("")); [EOL]         assertEquals("", StringUtils.normalizeSpace(" ")); [EOL]         assertEquals("", StringUtils.normalizeSpace("\t")); [EOL]         assertEquals("", StringUtils.normalizeSpace("\n"));         [EOL]         assertEquals("", StringUtils.normalizeSpace("\u0009")); [EOL]         assertEquals("", StringUtils.normalizeSpace("\u000B")); [EOL]         assertEquals("", StringUtils.normalizeSpace("\u000C")); [EOL]         assertEquals("", StringUtils.normalizeSpace("\u001C")); [EOL]         assertEquals("", StringUtils.normalizeSpace("\u001D")); [EOL]         assertEquals("", StringUtils.normalizeSpace("\u001E")); [EOL]         assertEquals("", StringUtils.normalizeSpace("\u001F")); [EOL]         assertEquals("", StringUtils.normalizeSpace("\f")); [EOL]         assertEquals("", StringUtils.normalizeSpace("\r")); [EOL]         assertEquals("a", StringUtils.normalizeSpace("  a  ")); [EOL]         assertEquals("a b c", StringUtils.normalize
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [
@Test [EOL]     public void testParseSync() throws InterruptedException { [EOL]         final String pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS Z"; [EOL]         final FastDateFormat formatter= FastDateFormat.getInstance(pattern); [EOL]          [EOL]         final long sdfTime= measureTime(formatter, new SimpleDateFormat(pattern) { [EOL]                         private static final long serialVersionUID = 1L;  // because SimpleDateFormat is serializable [EOL]  [EOL]                         @Override [EOL]                         public Object parseObject(final String formattedDate) throws ParseException { [EOL]                             synchronized(this) { [EOL]                                 return super.parse(formattedDate); [EOL]                             } [EOL]                         } [EOL]         }); [EOL]          [EOL]         final long fdfTime= measureTime(formatter, FastDateFormat.getInstance(pattern)); [EOL]          [EOL]         final String times= ">>FastDateFormatTest: FastDate
@Test [EOL]     public void testClone() throws Exception { [EOL]         final Object test = SerializationUtils.clone(iMap); [EOL]         assertNotNull(test); [EOL]         assertTrue(test instanceof HashMap<?,?>); [EOL]         assertTrue(test != iMap); [EOL]         final HashMap<?, ?> testMap = (HashMap<?, ?>) test; [EOL]         assertEquals(iString, testMap.get("FOO")); [EOL]         assertTrue(iString != testMap.get("FOO")); [EOL]         assertEquals(iInteger, testMap.get("BAR")); [EOL]         assertTrue(iInteger != testMap.get("BAR")); [EOL]         assertEquals(iMap, testMap); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testClone() throws Exception { [EOL]         final Object test = SerializationUtils.clone(iMap); [EOL]         assertNotNull(test); [EOL]         assertTrue(test instanceof HashMap<?,?>); [EOL]         assertTrue(test != iMap); [EOL]         final HashMap<?, ?> testMap = (HashMap<?, ?>) test; [EOL]         assertEquals(iString, testMap.get("FOO")); [EOL]         assertTrue(iString != testMap.get("FOO")); [EOL]         assertEquals(iInteger, testMap.get("BAR")); [EOL]         assertTrue(iInteger != testMap.get("BAR")); [EOL]         assertEquals(iMap, testMap); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testClone() throws Exception { [EOL]         final Object test = SerializationUtils.clone(iMap); [EOL]         assertNotNull(test); [EOL]         assertTrue(test instanceof HashMap<?,?>); [EOL]         assertTrue(test != iMap); [EOL]         final HashMap<?, ?> testMap = (HashMap<?, ?>) test; [EOL]         assertEquals(iString, testMap.get("FOO")); [EOL]         assertTrue(iString != testMap.get("FOO")); [EOL]         assertEquals(iInteger, testMap.get("BAR")); [EOL]         assertTrue(iInteger != testMap.get("BAR")); [EOL]         assertEquals(iMap, testMap); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testShortDateStyleWithLocales() { [EOL]         final Locale usLocale = Locale.US; [EOL]         final Locale swedishLocale = new Locale("sv", "SE"); [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2004, 1, 3); [EOL]         DatePrinter fdf = getDateInstance(FastDateFormat.SHORT, usLocale); [EOL]         assertEquals("2/3/04", fdf.format(cal)); [EOL]  [EOL]         fdf = getDateInstance(FastDateFormat.SHORT, swedishLocale); [EOL]         assertEquals("2004-02-03", fdf.format(cal)); [EOL]  [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests that pre-1000AD years get padded with yyyy [EOL]      */ [EOL]
@Test [EOL]     public void testLang303() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2004, 11, 31); [EOL]  [EOL]         DatePrinter format = getInstance(YYYY_MM_DD); [EOL]         final String output = format.format(cal); [EOL]  [EOL]         format = SerializationUtils.deserialize(SerializationUtils.serialize((Serializable) format)); [EOL]         assertEquals(output, format.format(cal)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLang303() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2004, 11, 31); [EOL]  [EOL]         DatePrinter format = getInstance(YYYY_MM_DD); [EOL]         final String output = format.format(cal); [EOL]  [EOL]         format = SerializationUtils.deserialize(SerializationUtils.serialize((Serializable) format)); [EOL]         assertEquals(output, format.format(cal)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLang303() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2004, 11, 31); [EOL]  [EOL]         DatePrinter format = getInstance(YYYY_MM_DD); [EOL]         final String output = format.format(cal); [EOL]  [EOL]         format = SerializationUtils.deserialize(SerializationUtils.serialize((Serializable) format)); [EOL]         assertEquals(output, format.format(cal)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLang303() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2004, 11, 31); [EOL]  [EOL]         DatePrinter format = getInstance(YYYY_MM_DD); [EOL]         final String output = format.format(cal); [EOL]  [EOL]         format = SerializationUtils.deserialize(SerializationUtils.serialize((Serializable) format)); [EOL]         assertEquals(output, format.format(cal)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLang303() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2004, 11, 31); [EOL]  [EOL]         DatePrinter format = getInstance(YYYY_MM_DD); [EOL]         final String output = format.format(cal); [EOL]  [EOL]         format = SerializationUtils.deserialize(SerializationUtils.serialize((Serializable) format)); [EOL]         assertEquals(output, format.format(cal)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [
@Test [EOL]     public void testFactory_int_int_int() { [EOL]         Fraction f = null; [EOL]          [EOL]         // zero [EOL]         f = Fraction.getFraction(0, 0, 2); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(2, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(2, 0, 2); [EOL]         assertEquals(4, f.getNumerator()); [EOL]         assertEquals(2, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(0, 1, 2); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(2, f.getDenominator()); [EOL]          [EOL]         // normal [EOL]         f = Fraction.getFraction(1, 1, 2); [EOL]         assertEquals(3, f.getNumerator()); [EOL]         assertEquals(2, f.getDenominator()); [EOL]          [EOL]         // negatives [EOL]         try { [EOL]             f = Fraction.getFraction(1, -6
@Test [EOL]     public void testFactory_String_double() { [EOL]         Fraction f = null; [EOL]          [EOL]         f = Fraction.getFraction("0.0"); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction("0.2"); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(5, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction("0.5"); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(2, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction("0.66666"); [EOL]         assertEquals(2, f.getNumerator()); [EOL]         assertEquals(3, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction("7/3"); [EOL]         assertEquals(7, f.getNumerator()); [EOL]         assertEquals(3, f.getDenominator()); [EOL]          [EOL]  
@Test [EOL]     public void testInvert() { [EOL]         Fraction f = null; [EOL]          [EOL]         f = Fraction.getFraction(50, 75); [EOL]         f = f.invert(); [EOL]         assertEquals(75, f.getNumerator()); [EOL]         assertEquals(50, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(4, 3); [EOL]         f = f.invert(); [EOL]         assertEquals(3, f.getNumerator()); [EOL]         assertEquals(4, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(-15, 47); [EOL]         f = f.invert(); [EOL]         assertEquals(-47, f.getNumerator()); [EOL]         assertEquals(15, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(0, 3); [EOL]         try { [EOL]             f = f.invert(); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         // large values [
@Test [EOL]     public void testSubtract() { [EOL]         Fraction f = null; [EOL]         Fraction f1 = null; [EOL]         Fraction f2 = null; [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(1, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(2, f.getNumerator()); [EOL]         assertEquals(5, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(7, 5); [EOL]         f2 = Fraction.getFraction(2, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(3, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]   
@Test [EOL]     public void testAdd() { [EOL]         Fraction f = null; [EOL]         Fraction f1 = null; [EOL]         Fraction f2 = null; [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(1, 5); [EOL]         f = f1.add(f2); [EOL]         assertEquals(4, f.getNumerator()); [EOL]         assertEquals(5, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(2, 5); [EOL]         f = f1.add(f2); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(3, 5); [EOL]         f = f1.add(f2); [EOL]         assertEquals(6, f.getNumerator()); [EOL]         assertEquals(5, f.getDenominator()); [EOL]          [E
@Test [EOL]     public void testSubtract() { [EOL]         Fraction f = null; [EOL]         Fraction f1 = null; [EOL]         Fraction f2 = null; [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(1, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(2, f.getNumerator()); [EOL]         assertEquals(5, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(7, 5); [EOL]         f2 = Fraction.getFraction(2, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(3, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]   
@Test [EOL]     public void testSubtract() { [EOL]         Fraction f = null; [EOL]         Fraction f1 = null; [EOL]         Fraction f2 = null; [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(1, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(2, f.getNumerator()); [EOL]         assertEquals(5, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(7, 5); [EOL]         f2 = Fraction.getFraction(2, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(3, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]   
@Test [EOL]     public void testToProperString() { [EOL]         Fraction f = null; [EOL]  [EOL]         f = Fraction.getFraction(3, 5); [EOL]         final String str = f.toProperString(); [EOL]         assertEquals("3/5", str); [EOL]         assertSame(str, f.toProperString()); [EOL]          [EOL]         f = Fraction.getFraction(7, 5); [EOL]         assertEquals("1 2/5", f.toProperString());         [EOL]          [EOL]         f = Fraction.getFraction(14, 10); [EOL]         assertEquals("1 4/10", f.toProperString());         [EOL]          [EOL]         f = Fraction.getFraction(4, 2); [EOL]         assertEquals("2", f.toProperString());         [EOL]          [EOL]         f = Fraction.getFraction(0, 2); [EOL]         assertEquals("0", f.toProperString());         [EOL]          [EOL]         f = Fraction.getFraction(2, 2); [EOL]         assertEquals("1", f.toProperString());         [
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals(0x0, Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals(0x8, Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals(0x4, Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals(0xC, Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals(0x2, Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals(0xA, Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals(0x6, Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals(0xE, Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals(0x1, Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals(0x9, Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('a')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('b
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals(0x0, Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals(0x8, Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals(0x4, Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals(0xC, Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals(0x2, Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals(0xA, Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals(0x6, Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals(0xE, Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals(0x1, Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals(0x9, Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('a')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('b
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals(0x0, Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals(0x8, Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals(0x4, Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals(0xC, Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals(0x2, Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals(0xA, Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals(0x6, Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals(0xE, Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals(0x1, Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals(0x9, Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('a')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('b
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals(0x0, Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals(0x8, Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals(0x4, Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals(0xC, Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals(0x2, Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals(0xA, Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals(0x6, Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals(0xE, Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals(0x1, Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals(0x9, Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('a')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('b
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals(0x0, Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals(0x8, Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals(0x4, Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals(0xC, Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals(0x2, Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals(0xA, Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals(0x6, Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals(0xE, Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals(0x1, Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals(0x9, Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('a')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('b
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals(0x0, Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals(0x8, Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals(0x4, Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals(0xC, Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals(0x2, Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals(0xA, Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals(0x6, Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals(0xE, Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals(0x1, Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals(0x9, Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('a')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('b
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals(0x0, Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals(0x8, Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals(0x4, Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals(0xC, Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals(0x2, Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals(0xA, Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals(0x6, Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals(0xE, Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals(0x1, Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals(0x9, Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('a')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('b
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals(0x0, Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals(0x8, Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals(0x4, Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals(0xC, Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals(0x2, Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals(0xA, Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals(0x6, Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals(0xE, Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals(0x1, Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals(0x9, Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('a')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('b
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals(0x0, Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals(0x8, Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals(0x4, Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals(0xC, Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals(0x2, Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals(0xA, Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals(0x6, Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals(0xE, Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals(0x1, Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals(0x9, Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('a')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('b
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals(0x0, Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals(0x8, Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals(0x4, Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals(0xC, Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals(0x2, Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals(0xA, Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals(0x6, Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals(0xE, Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals(0x1, Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals(0x9, Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('a')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('b
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals(0x0, Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals(0x8, Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals(0x4, Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals(0xC, Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals(0x2, Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals(0xA, Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals(0x6, Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals(0xE, Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals(0x1, Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals(0x9, Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('a')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('b
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals(0x0, Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals(0x8, Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals(0x4, Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals(0xC, Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals(0x2, Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals(0xA, Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals(0x6, Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals(0xE, Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals(0x1, Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals(0x9, Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('a')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('b
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals(0x0, Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals(0x8, Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals(0x4, Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals(0xC, Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals(0x2, Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals(0xA, Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals(0x6, Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals(0xE, Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals(0x1, Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals(0x9, Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('a')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('b
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals(0x0, Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals(0x8, Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals(0x4, Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals(0xC, Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals(0x2, Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals(0xA, Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals(0x6, Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals(0xE, Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals(0x1, Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals(0x9, Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('a')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('b
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals(0x0, Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals(0x8, Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals(0x4, Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals(0xC, Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals(0x2, Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals(0xA, Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals(0x6, Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals(0xE, Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals(0x1, Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals(0x9, Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('a')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('b
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals(0x0, Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals(0x8, Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals(0x4, Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals(0xC, Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals(0x2, Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals(0xA, Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals(0x6, Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals(0xE, Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals(0x1, Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals(0x9, Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('a')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('b
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true},
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals(0x0, Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals(0x8, Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals(0x4, Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals(0xC, Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals(0x2, Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals(0xA, Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals(0x6, Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals(0xE, Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals(0x1, Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals(0x9, Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('a')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('b
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals(0x0, Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals(0x8, Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals(0x4, Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals(0xC, Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals(0x2, Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals(0xA, Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals(0x6, Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals(0xE, Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals(0x1, Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals(0x9, Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('a')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('b
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals(0x0, Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals(0x8, Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals(0x4, Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals(0xC, Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals(0x2, Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals(0xA, Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals(0x6, Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals(0xE, Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals(0x1, Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals(0x9, Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('a')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('b
@Test [EOL]     public void testDayOf() throws ParseException { [EOL]         final Calendar cal= Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal.clear(); [EOL]         cal.set(2003, 1, 10); [EOL]  [EOL]         final DateParser fdf = getInstance("W w F D y", NEW_YORK, Locale.US); [EOL]         assertEquals(cal.getTime(), fdf.parse("3 7 2 41 03")); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test case for {@link FastDateParser#FastDateParser(String, TimeZone, Locale)}. [EOL]      * @throws ParseException [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals(0x0, Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals(0x8, Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals(0x4, Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals(0xC, Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals(0x2, Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals(0xA, Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals(0x6, Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals(0xE, Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals(0x1, Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals(0x9, Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('a')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('b
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals(0x0, Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals(0x8, Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals(0x4, Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals(0xC, Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals(0x2, Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals(0xA, Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals(0x6, Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals(0xE, Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals(0x1, Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals(0x9, Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('a')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('b
@Test [EOL]     public void testHexDigitToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitToBinary('7')); [EOL]        
@Test [EOL]     public void testHexDigitToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitToBinary('7')); [EOL]        
@Test [EOL]     public void testHexDigitToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitToBinary('7')); [EOL]        
@Test [EOL]     public void testHexDigitToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitToBinary('7')); [EOL]        
@Test [EOL]     public void testHexDigitToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitToBinary('7')); [EOL]        
@Test [EOL]     public void testHexDigitToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitToBinary('7')); [EOL]        
@Test [EOL]     public void testHexDigitToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitToBinary('7')); [EOL]        
@Test [EOL]     public void testHexDigitToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitToBinary('7')); [EOL]        
@Test [EOL]     public void testHexDigitToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitToBinary('7')); [EOL]        
@Test [EOL]     public void testHexDigitToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitToBinary('7')); [EOL]        
@Test [EOL]     public void testHexDigitToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitToBinary('7')); [EOL]        
@Test [EOL]     public void testHexDigitToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitToBinary('7')); [EOL]        
@Test [EOL]     public void testHexDigitToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitToBinary('7')); [EOL]        
@Test [EOL]     public void testHexDigitToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitToBinary('7')); [EOL]        
@Test [EOL]     public void testHexDigitToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitToBinary('7')); [EOL]        
@Test [EOL]     public void testHexDigitToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitToBinary('7')); [EOL]        
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [
@Test [EOL]     public void testHexDigitToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitToBinary('7')); [EOL]        
@Test [EOL]     public void testHexDigitToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitToBinary('7')); [EOL]        
@Test [EOL]     public void testHexDigitToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitToBinary('7')); [EOL]        
@Test [EOL]     public void testHexDigitToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitToBinary('7')); [EOL]        
@Test [EOL]     public void testTimeZoneMatches() { [EOL]         final DatePrinter printer= getInstance(YYYY_MM_DD, NEW_YORK); [EOL]         assertEquals(NEW_YORK, printer.getTimeZone()); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testHexDigitToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitToBinary('7')); [EOL]        
@Test [EOL]     public void testHexDigitToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitToBinary('7')); [EOL]        
@Test [EOL]     public void testHexDigitToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitToBinary('7')); [EOL]        
@Test [EOL]     public void testDayOf() throws ParseException { [EOL]         final Calendar cal= Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal.clear(); [EOL]         cal.set(2003, 1, 10); [EOL]  [EOL]         final DateParser fdf = getInstance("W w F D y", NEW_YORK, Locale.US); [EOL]         assertEquals(cal.getTime(), fdf.parse("3 7 2 41 03")); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test case for {@link FastDateParser#FastDateParser(String, TimeZone, Locale)}. [EOL]      * @throws ParseException [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitToBinary('7')); [EOL]        
@Test [EOL]     public void testHexDigitToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitToBinary('7')); [EOL]        
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true},
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true},
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true},
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true},
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true},
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true},
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true},
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true},
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true},
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true},
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true},
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true},
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true},
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true},
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true},
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true},
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true},
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true},
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true},
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true},
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true},
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true},
@Test [EOL]     public void testTimeZoneMatches() { [EOL]         final DatePrinter printer= getInstance(YYYY_MM_DD, NEW_YORK); [EOL]         assertEquals(NEW_YORK, printer.getTimeZone()); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true},
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true},
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true},
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true},
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true},
@Test [EOL]     public void testDayOf() throws ParseException { [EOL]         final Calendar cal= Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal.clear(); [EOL]         cal.set(2003, 1, 10); [EOL]  [EOL]         final DateParser fdf = getInstance("W w F D y", NEW_YORK, Locale.US); [EOL]         assertEquals(cal.getTime(), fdf.parse("3 7 2 41 03")); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test case for {@link FastDateParser#FastDateParser(String, TimeZone, Locale)}. [EOL]      * @throws ParseException [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true},
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true},
@Test [EOL]     public void testBinaryToHexDigitMsb0_4bits_2args() { [EOL]         // boolean[] shortArray = new boolean[]{true,true,false}; [EOL]         // assertEquals('6', Conversion.BinaryToHexDigitMsb0(shortArray,0)); [EOL]         // assertEquals('3', Conversion.BinaryToHexDigitMsb0(shortArray,1)); [EOL]         // assertEquals('1', Conversion.BinaryToHexDigitMsb0(shortArray,2)); [EOL]         final boolean[] shortArray = new boolean[]{true, true, false, true}; [EOL]         assertEquals('d', Conversion.binaryToHexDigitMsb0_4bits(shortArray, 0)); [EOL]         final boolean[] longArray = new boolean[]{true, false, true, false, false, true, true}; [EOL]         assertEquals('a', Conversion.binaryToHexDigitMsb0_4bits(longArray, 0)); [EOL]         assertEquals('4', Conversion.binaryToHexDigitMsb0_4bits(longArray, 1)); [EOL]         assertEquals('9', Conversion.binaryToHexDigitMsb0_4bits(longArray, 2)); [EOL]         assertEquals('3', Conversion.binaryToHexDigitMsb0_4bits(longArray, 3)); [EOL]         // assertEquals('6', Conversion.BinaryToHexDigitMsb0(longArray,4)); [EOL]         // assertEquals('3', Conversion.BinaryToHexDigitMsb0(longArray,
@Test [EOL]     public void testBinaryBeMsb0ToHexDigit() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, true, false, true})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryBeMsb0ToHex
@Test [EOL]     public void testBinaryBeMsb0ToHexDigit() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, true, false, true})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryBeMsb0ToHex
@Test [EOL]     public void testBinaryBeMsb0ToHexDigit() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, true, false, true})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryBeMsb0ToHex
@Test [EOL]     public void testBinaryBeMsb0ToHexDigit() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, true, false, true})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryBeMsb0ToHex
@Test [EOL]     public void testBinaryBeMsb0ToHexDigit() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, true, false, true})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryBeMsb0ToHex
@Test [EOL]     public void testIntToHexDigitMsb0() { [EOL]         assertEquals('0', Conversion.intToHexDigitMsb0(0)); [EOL]         assertEquals('8', Conversion.intToHexDigitMsb0(1)); [EOL]         assertEquals('4', Conversion.intToHexDigitMsb0(2)); [EOL]         assertEquals('c', Conversion.intToHexDigitMsb0(3)); [EOL]         assertEquals('2', Conversion.intToHexDigitMsb0(4)); [EOL]         assertEquals('a', Conversion.intToHexDigitMsb0(5)); [EOL]         assertEquals('6', Conversion.intToHexDigitMsb0(6)); [EOL]         assertEquals('e', Conversion.intToHexDigitMsb0(7)); [EOL]         assertEquals('1', Conversion.intToHexDigitMsb0(8)); [EOL]         assertEquals('9', Conversion.intToHexDigitMsb0(9)); [EOL]         assertEquals('5', Conversion.intToHexDigitMsb0(10)); [EOL]         assertEquals('d', Conversion.intToHexDigitMsb0(11)); [EOL]         assertEquals('3', Conversion.intToHexDigitMsb0(12)); [EOL]         assertEquals('b', Conversion.intToHexDigitMsb0(13)); [EOL]         assertEquals('7', Conversion.intToHexDigit
@Test [EOL]     public void testIntToHexDigitMsb0() { [EOL]         assertEquals('0', Conversion.intToHexDigitMsb0(0)); [EOL]         assertEquals('8', Conversion.intToHexDigitMsb0(1)); [EOL]         assertEquals('4', Conversion.intToHexDigitMsb0(2)); [EOL]         assertEquals('c', Conversion.intToHexDigitMsb0(3)); [EOL]         assertEquals('2', Conversion.intToHexDigitMsb0(4)); [EOL]         assertEquals('a', Conversion.intToHexDigitMsb0(5)); [EOL]         assertEquals('6', Conversion.intToHexDigitMsb0(6)); [EOL]         assertEquals('e', Conversion.intToHexDigitMsb0(7)); [EOL]         assertEquals('1', Conversion.intToHexDigitMsb0(8)); [EOL]         assertEquals('9', Conversion.intToHexDigitMsb0(9)); [EOL]         assertEquals('5', Conversion.intToHexDigitMsb0(10)); [EOL]         assertEquals('d', Conversion.intToHexDigitMsb0(11)); [EOL]         assertEquals('3', Conversion.intToHexDigitMsb0(12)); [EOL]         assertEquals('b', Conversion.intToHexDigitMsb0(13)); [EOL]         assertEquals('7', Conversion.intToHexDigit
@Test [EOL]     public void testIntToHexDigitMsb0() { [EOL]         assertEquals('0', Conversion.intToHexDigitMsb0(0)); [EOL]         assertEquals('8', Conversion.intToHexDigitMsb0(1)); [EOL]         assertEquals('4', Conversion.intToHexDigitMsb0(2)); [EOL]         assertEquals('c', Conversion.intToHexDigitMsb0(3)); [EOL]         assertEquals('2', Conversion.intToHexDigitMsb0(4)); [EOL]         assertEquals('a', Conversion.intToHexDigitMsb0(5)); [EOL]         assertEquals('6', Conversion.intToHexDigitMsb0(6)); [EOL]         assertEquals('e', Conversion.intToHexDigitMsb0(7)); [EOL]         assertEquals('1', Conversion.intToHexDigitMsb0(8)); [EOL]         assertEquals('9', Conversion.intToHexDigitMsb0(9)); [EOL]         assertEquals('5', Conversion.intToHexDigitMsb0(10)); [EOL]         assertEquals('d', Conversion.intToHexDigitMsb0(11)); [EOL]         assertEquals('3', Conversion.intToHexDigitMsb0(12)); [EOL]         assertEquals('b', Conversion.intToHexDigitMsb0(13)); [EOL]         assertEquals('7', Conversion.intToHexDigit
@Test [EOL]     public void testIntToHexDigitMsb0() { [EOL]         assertEquals('0', Conversion.intToHexDigitMsb0(0)); [EOL]         assertEquals('8', Conversion.intToHexDigitMsb0(1)); [EOL]         assertEquals('4', Conversion.intToHexDigitMsb0(2)); [EOL]         assertEquals('c', Conversion.intToHexDigitMsb0(3)); [EOL]         assertEquals('2', Conversion.intToHexDigitMsb0(4)); [EOL]         assertEquals('a', Conversion.intToHexDigitMsb0(5)); [EOL]         assertEquals('6', Conversion.intToHexDigitMsb0(6)); [EOL]         assertEquals('e', Conversion.intToHexDigitMsb0(7)); [EOL]         assertEquals('1', Conversion.intToHexDigitMsb0(8)); [EOL]         assertEquals('9', Conversion.intToHexDigitMsb0(9)); [EOL]         assertEquals('5', Conversion.intToHexDigitMsb0(10)); [EOL]         assertEquals('d', Conversion.intToHexDigitMsb0(11)); [EOL]         assertEquals('3', Conversion.intToHexDigitMsb0(12)); [EOL]         assertEquals('b', Conversion.intToHexDigitMsb0(13)); [EOL]         assertEquals('7', Conversion.intToHexDigit
@Test [EOL]     public void testIntToHexDigitMsb0() { [EOL]         assertEquals('0', Conversion.intToHexDigitMsb0(0)); [EOL]         assertEquals('8', Conversion.intToHexDigitMsb0(1)); [EOL]         assertEquals('4', Conversion.intToHexDigitMsb0(2)); [EOL]         assertEquals('c', Conversion.intToHexDigitMsb0(3)); [EOL]         assertEquals('2', Conversion.intToHexDigitMsb0(4)); [EOL]         assertEquals('a', Conversion.intToHexDigitMsb0(5)); [EOL]         assertEquals('6', Conversion.intToHexDigitMsb0(6)); [EOL]         assertEquals('e', Conversion.intToHexDigitMsb0(7)); [EOL]         assertEquals('1', Conversion.intToHexDigitMsb0(8)); [EOL]         assertEquals('9', Conversion.intToHexDigitMsb0(9)); [EOL]         assertEquals('5', Conversion.intToHexDigitMsb0(10)); [EOL]         assertEquals('d', Conversion.intToHexDigitMsb0(11)); [EOL]         assertEquals('3', Conversion.intToHexDigitMsb0(12)); [EOL]         assertEquals('b', Conversion.intToHexDigitMsb0(13)); [EOL]         assertEquals('7', Conversion.intToHexDigit
@Test [EOL]     public void testIntToHexDigitMsb0() { [EOL]         assertEquals('0', Conversion.intToHexDigitMsb0(0)); [EOL]         assertEquals('8', Conversion.intToHexDigitMsb0(1)); [EOL]         assertEquals('4', Conversion.intToHexDigitMsb0(2)); [EOL]         assertEquals('c', Conversion.intToHexDigitMsb0(3)); [EOL]         assertEquals('2', Conversion.intToHexDigitMsb0(4)); [EOL]         assertEquals('a', Conversion.intToHexDigitMsb0(5)); [EOL]         assertEquals('6', Conversion.intToHexDigitMsb0(6)); [EOL]         assertEquals('e', Conversion.intToHexDigitMsb0(7)); [EOL]         assertEquals('1', Conversion.intToHexDigitMsb0(8)); [EOL]         assertEquals('9', Conversion.intToHexDigitMsb0(9)); [EOL]         assertEquals('5', Conversion.intToHexDigitMsb0(10)); [EOL]         assertEquals('d', Conversion.intToHexDigitMsb0(11)); [EOL]         assertEquals('3', Conversion.intToHexDigitMsb0(12)); [EOL]         assertEquals('b', Conversion.intToHexDigitMsb0(13)); [EOL]         assertEquals('7', Conversion.intToHexDigit
@Test [EOL]     public void testIntToHexDigitMsb0() { [EOL]         assertEquals('0', Conversion.intToHexDigitMsb0(0)); [EOL]         assertEquals('8', Conversion.intToHexDigitMsb0(1)); [EOL]         assertEquals('4', Conversion.intToHexDigitMsb0(2)); [EOL]         assertEquals('c', Conversion.intToHexDigitMsb0(3)); [EOL]         assertEquals('2', Conversion.intToHexDigitMsb0(4)); [EOL]         assertEquals('a', Conversion.intToHexDigitMsb0(5)); [EOL]         assertEquals('6', Conversion.intToHexDigitMsb0(6)); [EOL]         assertEquals('e', Conversion.intToHexDigitMsb0(7)); [EOL]         assertEquals('1', Conversion.intToHexDigitMsb0(8)); [EOL]         assertEquals('9', Conversion.intToHexDigitMsb0(9)); [EOL]         assertEquals('5', Conversion.intToHexDigitMsb0(10)); [EOL]         assertEquals('d', Conversion.intToHexDigitMsb0(11)); [EOL]         assertEquals('3', Conversion.intToHexDigitMsb0(12)); [EOL]         assertEquals('b', Conversion.intToHexDigitMsb0(13)); [EOL]         assertEquals('7', Conversion.intToHexDigit
@Test [EOL]     public void testIntToHexDigitMsb0() { [EOL]         assertEquals('0', Conversion.intToHexDigitMsb0(0)); [EOL]         assertEquals('8', Conversion.intToHexDigitMsb0(1)); [EOL]         assertEquals('4', Conversion.intToHexDigitMsb0(2)); [EOL]         assertEquals('c', Conversion.intToHexDigitMsb0(3)); [EOL]         assertEquals('2', Conversion.intToHexDigitMsb0(4)); [EOL]         assertEquals('a', Conversion.intToHexDigitMsb0(5)); [EOL]         assertEquals('6', Conversion.intToHexDigitMsb0(6)); [EOL]         assertEquals('e', Conversion.intToHexDigitMsb0(7)); [EOL]         assertEquals('1', Conversion.intToHexDigitMsb0(8)); [EOL]         assertEquals('9', Conversion.intToHexDigitMsb0(9)); [EOL]         assertEquals('5', Conversion.intToHexDigitMsb0(10)); [EOL]         assertEquals('d', Conversion.intToHexDigitMsb0(11)); [EOL]         assertEquals('3', Conversion.intToHexDigitMsb0(12)); [EOL]         assertEquals('b', Conversion.intToHexDigitMsb0(13)); [EOL]         assertEquals('7', Conversion.intToHexDigit
@Test [EOL]     public void testIntToHexDigitMsb0() { [EOL]         assertEquals('0', Conversion.intToHexDigitMsb0(0)); [EOL]         assertEquals('8', Conversion.intToHexDigitMsb0(1)); [EOL]         assertEquals('4', Conversion.intToHexDigitMsb0(2)); [EOL]         assertEquals('c', Conversion.intToHexDigitMsb0(3)); [EOL]         assertEquals('2', Conversion.intToHexDigitMsb0(4)); [EOL]         assertEquals('a', Conversion.intToHexDigitMsb0(5)); [EOL]         assertEquals('6', Conversion.intToHexDigitMsb0(6)); [EOL]         assertEquals('e', Conversion.intToHexDigitMsb0(7)); [EOL]         assertEquals('1', Conversion.intToHexDigitMsb0(8)); [EOL]         assertEquals('9', Conversion.intToHexDigitMsb0(9)); [EOL]         assertEquals('5', Conversion.intToHexDigitMsb0(10)); [EOL]         assertEquals('d', Conversion.intToHexDigitMsb0(11)); [EOL]         assertEquals('3', Conversion.intToHexDigitMsb0(12)); [EOL]         assertEquals('b', Conversion.intToHexDigitMsb0(13)); [EOL]         assertEquals('7', Conversion.intToHexDigit
@Test [EOL]     public void testIntToHexDigitMsb0() { [EOL]         assertEquals('0', Conversion.intToHexDigitMsb0(0)); [EOL]         assertEquals('8', Conversion.intToHexDigitMsb0(1)); [EOL]         assertEquals('4', Conversion.intToHexDigitMsb0(2)); [EOL]         assertEquals('c', Conversion.intToHexDigitMsb0(3)); [EOL]         assertEquals('2', Conversion.intToHexDigitMsb0(4)); [EOL]         assertEquals('a', Conversion.intToHexDigitMsb0(5)); [EOL]         assertEquals('6', Conversion.intToHexDigitMsb0(6)); [EOL]         assertEquals('e', Conversion.intToHexDigitMsb0(7)); [EOL]         assertEquals('1', Conversion.intToHexDigitMsb0(8)); [EOL]         assertEquals('9', Conversion.intToHexDigitMsb0(9)); [EOL]         assertEquals('5', Conversion.intToHexDigitMsb0(10)); [EOL]         assertEquals('d', Conversion.intToHexDigitMsb0(11)); [EOL]         assertEquals('3', Conversion.intToHexDigitMsb0(12)); [EOL]         assertEquals('b', Conversion.intToHexDigitMsb0(13)); [EOL]         assertEquals('7', Conversion.intToHexDigit
@Test [EOL]     public void testIntToHexDigitMsb0() { [EOL]         assertEquals('0', Conversion.intToHexDigitMsb0(0)); [EOL]         assertEquals('8', Conversion.intToHexDigitMsb0(1)); [EOL]         assertEquals('4', Conversion.intToHexDigitMsb0(2)); [EOL]         assertEquals('c', Conversion.intToHexDigitMsb0(3)); [EOL]         assertEquals('2', Conversion.intToHexDigitMsb0(4)); [EOL]         assertEquals('a', Conversion.intToHexDigitMsb0(5)); [EOL]         assertEquals('6', Conversion.intToHexDigitMsb0(6)); [EOL]         assertEquals('e', Conversion.intToHexDigitMsb0(7)); [EOL]         assertEquals('1', Conversion.intToHexDigitMsb0(8)); [EOL]         assertEquals('9', Conversion.intToHexDigitMsb0(9)); [EOL]         assertEquals('5', Conversion.intToHexDigitMsb0(10)); [EOL]         assertEquals('d', Conversion.intToHexDigitMsb0(11)); [EOL]         assertEquals('3', Conversion.intToHexDigitMsb0(12)); [EOL]         assertEquals('b', Conversion.intToHexDigitMsb0(13)); [EOL]         assertEquals('7', Conversion.intToHexDigit
@Test [EOL]     public void testIntToHexDigitMsb0() { [EOL]         assertEquals('0', Conversion.intToHexDigitMsb0(0)); [EOL]         assertEquals('8', Conversion.intToHexDigitMsb0(1)); [EOL]         assertEquals('4', Conversion.intToHexDigitMsb0(2)); [EOL]         assertEquals('c', Conversion.intToHexDigitMsb0(3)); [EOL]         assertEquals('2', Conversion.intToHexDigitMsb0(4)); [EOL]         assertEquals('a', Conversion.intToHexDigitMsb0(5)); [EOL]         assertEquals('6', Conversion.intToHexDigitMsb0(6)); [EOL]         assertEquals('e', Conversion.intToHexDigitMsb0(7)); [EOL]         assertEquals('1', Conversion.intToHexDigitMsb0(8)); [EOL]         assertEquals('9', Conversion.intToHexDigitMsb0(9)); [EOL]         assertEquals('5', Conversion.intToHexDigitMsb0(10)); [EOL]         assertEquals('d', Conversion.intToHexDigitMsb0(11)); [EOL]         assertEquals('3', Conversion.intToHexDigitMsb0(12)); [EOL]         assertEquals('b', Conversion.intToHexDigitMsb0(13)); [EOL]         assertEquals('7', Conversion.intToHexDigit
@Test [EOL]     public void testIntToHexDigitMsb0() { [EOL]         assertEquals('0', Conversion.intToHexDigitMsb0(0)); [EOL]         assertEquals('8', Conversion.intToHexDigitMsb0(1)); [EOL]         assertEquals('4', Conversion.intToHexDigitMsb0(2)); [EOL]         assertEquals('c', Conversion.intToHexDigitMsb0(3)); [EOL]         assertEquals('2', Conversion.intToHexDigitMsb0(4)); [EOL]         assertEquals('a', Conversion.intToHexDigitMsb0(5)); [EOL]         assertEquals('6', Conversion.intToHexDigitMsb0(6)); [EOL]         assertEquals('e', Conversion.intToHexDigitMsb0(7)); [EOL]         assertEquals('1', Conversion.intToHexDigitMsb0(8)); [EOL]         assertEquals('9', Conversion.intToHexDigitMsb0(9)); [EOL]         assertEquals('5', Conversion.intToHexDigitMsb0(10)); [EOL]         assertEquals('d', Conversion.intToHexDigitMsb0(11)); [EOL]         assertEquals('3', Conversion.intToHexDigitMsb0(12)); [EOL]         assertEquals('b', Conversion.intToHexDigitMsb0(13)); [EOL]         assertEquals('7', Conversion.intToHexDigit
@Test [EOL]     public void testIntToHexDigitMsb0() { [EOL]         assertEquals('0', Conversion.intToHexDigitMsb0(0)); [EOL]         assertEquals('8', Conversion.intToHexDigitMsb0(1)); [EOL]         assertEquals('4', Conversion.intToHexDigitMsb0(2)); [EOL]         assertEquals('c', Conversion.intToHexDigitMsb0(3)); [EOL]         assertEquals('2', Conversion.intToHexDigitMsb0(4)); [EOL]         assertEquals('a', Conversion.intToHexDigitMsb0(5)); [EOL]         assertEquals('6', Conversion.intToHexDigitMsb0(6)); [EOL]         assertEquals('e', Conversion.intToHexDigitMsb0(7)); [EOL]         assertEquals('1', Conversion.intToHexDigitMsb0(8)); [EOL]         assertEquals('9', Conversion.intToHexDigitMsb0(9)); [EOL]         assertEquals('5', Conversion.intToHexDigitMsb0(10)); [EOL]         assertEquals('d', Conversion.intToHexDigitMsb0(11)); [EOL]         assertEquals('3', Conversion.intToHexDigitMsb0(12)); [EOL]         assertEquals('b', Conversion.intToHexDigitMsb0(13)); [EOL]         assertEquals('7', Conversion.intToHexDigit
@Test [EOL]     public void testIntToHexDigitMsb0() { [EOL]         assertEquals('0', Conversion.intToHexDigitMsb0(0)); [EOL]         assertEquals('8', Conversion.intToHexDigitMsb0(1)); [EOL]         assertEquals('4', Conversion.intToHexDigitMsb0(2)); [EOL]         assertEquals('c', Conversion.intToHexDigitMsb0(3)); [EOL]         assertEquals('2', Conversion.intToHexDigitMsb0(4)); [EOL]         assertEquals('a', Conversion.intToHexDigitMsb0(5)); [EOL]         assertEquals('6', Conversion.intToHexDigitMsb0(6)); [EOL]         assertEquals('e', Conversion.intToHexDigitMsb0(7)); [EOL]         assertEquals('1', Conversion.intToHexDigitMsb0(8)); [EOL]         assertEquals('9', Conversion.intToHexDigitMsb0(9)); [EOL]         assertEquals('5', Conversion.intToHexDigitMsb0(10)); [EOL]         assertEquals('d', Conversion.intToHexDigitMsb0(11)); [EOL]         assertEquals('3', Conversion.intToHexDigitMsb0(12)); [EOL]         assertEquals('b', Conversion.intToHexDigitMsb0(13)); [EOL]         assertEquals('7', Conversion.intToHexDigit
@Test [EOL]     public void testIntToHexDigitMsb0() { [EOL]         assertEquals('0', Conversion.intToHexDigitMsb0(0)); [EOL]         assertEquals('8', Conversion.intToHexDigitMsb0(1)); [EOL]         assertEquals('4', Conversion.intToHexDigitMsb0(2)); [EOL]         assertEquals('c', Conversion.intToHexDigitMsb0(3)); [EOL]         assertEquals('2', Conversion.intToHexDigitMsb0(4)); [EOL]         assertEquals('a', Conversion.intToHexDigitMsb0(5)); [EOL]         assertEquals('6', Conversion.intToHexDigitMsb0(6)); [EOL]         assertEquals('e', Conversion.intToHexDigitMsb0(7)); [EOL]         assertEquals('1', Conversion.intToHexDigitMsb0(8)); [EOL]         assertEquals('9', Conversion.intToHexDigitMsb0(9)); [EOL]         assertEquals('5', Conversion.intToHexDigitMsb0(10)); [EOL]         assertEquals('d', Conversion.intToHexDigitMsb0(11)); [EOL]         assertEquals('3', Conversion.intToHexDigitMsb0(12)); [EOL]         assertEquals('b', Conversion.intToHexDigitMsb0(13)); [EOL]         assertEquals('7', Conversion.intToHexDigit
@Test [EOL]     public void testIntToHexDigitMsb0() { [EOL]         assertEquals('0', Conversion.intToHexDigitMsb0(0)); [EOL]         assertEquals('8', Conversion.intToHexDigitMsb0(1)); [EOL]         assertEquals('4', Conversion.intToHexDigitMsb0(2)); [EOL]         assertEquals('c', Conversion.intToHexDigitMsb0(3)); [EOL]         assertEquals('2', Conversion.intToHexDigitMsb0(4)); [EOL]         assertEquals('a', Conversion.intToHexDigitMsb0(5)); [EOL]         assertEquals('6', Conversion.intToHexDigitMsb0(6)); [EOL]         assertEquals('e', Conversion.intToHexDigitMsb0(7)); [EOL]         assertEquals('1', Conversion.intToHexDigitMsb0(8)); [EOL]         assertEquals('9', Conversion.intToHexDigitMsb0(9)); [EOL]         assertEquals('5', Conversion.intToHexDigitMsb0(10)); [EOL]         assertEquals('d', Conversion.intToHexDigitMsb0(11)); [EOL]         assertEquals('3', Conversion.intToHexDigitMsb0(12)); [EOL]         assertEquals('b', Conversion.intToHexDigitMsb0(13)); [EOL]         assertEquals('7', Conversion.intToHexDigit
@Test [EOL]     public void testIntToHexDigitMsb0() { [EOL]         assertEquals('0', Conversion.intToHexDigitMsb0(0)); [EOL]         assertEquals('8', Conversion.intToHexDigitMsb0(1)); [EOL]         assertEquals('4', Conversion.intToHexDigitMsb0(2)); [EOL]         assertEquals('c', Conversion.intToHexDigitMsb0(3)); [EOL]         assertEquals('2', Conversion.intToHexDigitMsb0(4)); [EOL]         assertEquals('a', Conversion.intToHexDigitMsb0(5)); [EOL]         assertEquals('6', Conversion.intToHexDigitMsb0(6)); [EOL]         assertEquals('e', Conversion.intToHexDigitMsb0(7)); [EOL]         assertEquals('1', Conversion.intToHexDigitMsb0(8)); [EOL]         assertEquals('9', Conversion.intToHexDigitMsb0(9)); [EOL]         assertEquals('5', Conversion.intToHexDigitMsb0(10)); [EOL]         assertEquals('d', Conversion.intToHexDigitMsb0(11)); [EOL]         assertEquals('3', Conversion.intToHexDigitMsb0(12)); [EOL]         assertEquals('b', Conversion.intToHexDigitMsb0(13)); [EOL]         assertEquals('7', Conversion.intToHexDigit
@Test [EOL]     public void testIntToHexDigitMsb0() { [EOL]         assertEquals('0', Conversion.intToHexDigitMsb0(0)); [EOL]         assertEquals('8', Conversion.intToHexDigitMsb0(1)); [EOL]         assertEquals('4', Conversion.intToHexDigitMsb0(2)); [EOL]         assertEquals('c', Conversion.intToHexDigitMsb0(3)); [EOL]         assertEquals('2', Conversion.intToHexDigitMsb0(4)); [EOL]         assertEquals('a', Conversion.intToHexDigitMsb0(5)); [EOL]         assertEquals('6', Conversion.intToHexDigitMsb0(6)); [EOL]         assertEquals('e', Conversion.intToHexDigitMsb0(7)); [EOL]         assertEquals('1', Conversion.intToHexDigitMsb0(8)); [EOL]         assertEquals('9', Conversion.intToHexDigitMsb0(9)); [EOL]         assertEquals('5', Conversion.intToHexDigitMsb0(10)); [EOL]         assertEquals('d', Conversion.intToHexDigitMsb0(11)); [EOL]         assertEquals('3', Conversion.intToHexDigitMsb0(12)); [EOL]         assertEquals('b', Conversion.intToHexDigitMsb0(13)); [EOL]         assertEquals('7', Conversion.intToHexDigit
@Test [EOL]     public void testIntToHexDigitMsb0() { [EOL]         assertEquals('0', Conversion.intToHexDigitMsb0(0)); [EOL]         assertEquals('8', Conversion.intToHexDigitMsb0(1)); [EOL]         assertEquals('4', Conversion.intToHexDigitMsb0(2)); [EOL]         assertEquals('c', Conversion.intToHexDigitMsb0(3)); [EOL]         assertEquals('2', Conversion.intToHexDigitMsb0(4)); [EOL]         assertEquals('a', Conversion.intToHexDigitMsb0(5)); [EOL]         assertEquals('6', Conversion.intToHexDigitMsb0(6)); [EOL]         assertEquals('e', Conversion.intToHexDigitMsb0(7)); [EOL]         assertEquals('1', Conversion.intToHexDigitMsb0(8)); [EOL]         assertEquals('9', Conversion.intToHexDigitMsb0(9)); [EOL]         assertEquals('5', Conversion.intToHexDigitMsb0(10)); [EOL]         assertEquals('d', Conversion.intToHexDigitMsb0(11)); [EOL]         assertEquals('3', Conversion.intToHexDigitMsb0(12)); [EOL]         assertEquals('b', Conversion.intToHexDigitMsb0(13)); [EOL]         assertEquals('7', Conversion.intToHexDigit
@Test [EOL]     public void testIntArrayToLong() { [EOL]         final int[] src = new int[]{0xCDF1F12345678, 0x123456, 0, 0x78000000}; [EOL]         assertEquals(0x0000000000000000L, Conversion.intArrayToLong(src, 0, 0L, 0, 0)); [EOL]         assertEquals(0x0000000000000000L, Conversion.intArrayToLong(src, 1, 0L, 0, 0)); [EOL]         assertEquals(0x00000000CDF1F0C1L, Conversion.intArrayToLong(src, 0, 0L, 0, 1)); [EOL]         assertEquals(0x0F123456CDF1F0C1L, Conversion.intArrayToLong(src, 0, 0L, 0, 2)); [EOL]         assertEquals(0x000000000F123456L, Conversion.intArrayToLong(src, 1, 0L, 0, 1)); [EOL]         assertEquals( [EOL]             0x123456789ABCDEF0L, Conversion.intArrayToLong(src, 0, 0x123456789ABCDEF0L, 0, 0)); [EOL]         assertEquals( [EOL]             0x1234567878000000L, Conversion.intArrayToLong(src, 2, 0x123456789ABCDEF0L, 0, 1)); [EOL]         // assertEquals(0x0F12345678000000L,Conversion.intsToLong(src,1,0x123456789ABCDEF0L,32,2)); [EOL]     } [EOL]  [EOL]     /** [EOL]    
@Test [EOL]     public void testIntArrayToLong() { [EOL]         final int[] src = new int[]{0xCDF1F12345678, 0x123456, 0, 0x78000000}; [EOL]         assertEquals(0x0000000000000000L, Conversion.intArrayToLong(src, 0, 0L, 0, 0)); [EOL]         assertEquals(0x0000000000000000L, Conversion.intArrayToLong(src, 1, 0L, 0, 0)); [EOL]         assertEquals(0x00000000CDF1F0C1L, Conversion.intArrayToLong(src, 0, 0L, 0, 1)); [EOL]         assertEquals(0x0F123456CDF1F0C1L, Conversion.intArrayToLong(src, 0, 0L, 0, 2)); [EOL]         assertEquals(0x000000000F123456L, Conversion.intArrayToLong(src, 1, 0L, 0, 1)); [EOL]         assertEquals( [EOL]             0x123456789ABCDEF0L, Conversion.intArrayToLong(src, 0, 0x123456789ABCDEF0L, 0, 0)); [EOL]         assertEquals( [EOL]             0x1234567878000000L, Conversion.intArrayToLong(src, 2, 0x123456789ABCDEF0L, 0, 1)); [EOL]         // assertEquals(0x0F12345678000000L,Conversion.intsToLong(src,1,0x123456789ABCDEF0L,32,2)); [EOL]     } [EOL]  [EOL]     /** [EOL]    
@Test [EOL]     public void testShortArrayToLong() { [EOL]         final short[] src = new short[]{ [EOL]             (short)0xCDF1, (short)0xF0C1, (short)0x0F12, (short)0x3456, (short)0x7800}; [EOL]         assertEquals(0x0000000000000000L, Conversion.shortArrayToLong(src, 0, 0L, 0, 0)); [EOL]         assertEquals(0x000000000000CDF1L, Conversion.shortArrayToLong(src, 0, 0L, 0, 1)); [EOL]         assertEquals(0x00000000F0C1CDF1L, Conversion.shortArrayToLong(src, 0, 0L, 0, 2)); [EOL]         assertEquals(0x780034560F12F0C1L, Conversion.shortArrayToLong(src, 1, 0L, 0, 4)); [EOL]         assertEquals( [EOL]             0x123456789ABCDEF0L, Conversion.shortArrayToLong(src, 0, 0x123456789ABCDEF0L, 0, 0)); [EOL]         assertEquals( [EOL]             0x123456CDF1BCDEF0L, [EOL]             Conversion.shortArrayToLong(src, 0, 0x123456789ABCDEF0L, 24, 1)); [EOL]         assertEquals( [EOL]             0x123478003456DEF0L, [EOL]             Conversion.shortArrayToLong(src
@Test [EOL]     public void testShortArrayToLong() { [EOL]         final short[] src = new short[]{ [EOL]             (short)0xCDF1, (short)0xF0C1, (short)0x0F12, (short)0x3456, (short)0x7800}; [EOL]         assertEquals(0x0000000000000000L, Conversion.shortArrayToLong(src, 0, 0L, 0, 0)); [EOL]         assertEquals(0x000000000000CDF1L, Conversion.shortArrayToLong(src, 0, 0L, 0, 1)); [EOL]         assertEquals(0x00000000F0C1CDF1L, Conversion.shortArrayToLong(src, 0, 0L, 0, 2)); [EOL]         assertEquals(0x780034560F12F0C1L, Conversion.shortArrayToLong(src, 1, 0L, 0, 4)); [EOL]         assertEquals( [EOL]             0x123456789ABCDEF0L, Conversion.shortArrayToLong(src, 0, 0x123456789ABCDEF0L, 0, 0)); [EOL]         assertEquals( [EOL]             0x123456CDF1BCDEF0L, [EOL]             Conversion.shortArrayToLong(src, 0, 0x123456789ABCDEF0L, 24, 1)); [EOL]         assertEquals( [EOL]             0x123478003456DEF0L, [EOL]             Conversion.shortArrayToLong(src
@Test [EOL]     public void testShortArrayToInt() { [EOL]         final short[] src = new short[]{ [EOL]             (short)0xCDF1, (short)0xF0C1, (short)0x0F12, (short)0x3456, (short)0x7800}; [EOL]         assertEquals(0x00000000, Conversion.shortArrayToInt(src, 0, 0, 0, 0)); [EOL]         assertEquals(0x0000CDF1, Conversion.shortArrayToInt(src, 0, 0, 0, 1)); [EOL]         assertEquals(0xF0C1CDF1, Conversion.shortArrayToInt(src, 0, 0, 0, 2)); [EOL]         assertEquals(0x0F12F0C1, Conversion.shortArrayToInt(src, 1, 0, 0, 2)); [EOL]         assertEquals(0x12345678, Conversion.shortArrayToInt(src, 0, 0x12345678, 0, 0)); [EOL]         assertEquals(0xCDF15678, Conversion.shortArrayToInt(src, 0, 0x12345678, 16, 1)); [EOL]         // assertEquals(0x34567800,Conversion.ShortArrayToInt(src, 3, 0x12345678, 16, 2)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#byteArrayToInt(byte[], int, int, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testShortArrayToInt() { [EOL]         final short[] src = new short[]{ [EOL]             (short)0xCDF1, (short)0xF0C1, (short)0x0F12, (short)0x3456, (short)0x7800}; [EOL]         assertEquals(0x00000000, Conversion.shortArrayToInt(src, 0, 0, 0, 0)); [EOL]         assertEquals(0x0000CDF1, Conversion.shortArrayToInt(src, 0, 0, 0, 1)); [EOL]         assertEquals(0xF0C1CDF1, Conversion.shortArrayToInt(src, 0, 0, 0, 2)); [EOL]         assertEquals(0x0F12F0C1, Conversion.shortArrayToInt(src, 1, 0, 0, 2)); [EOL]         assertEquals(0x12345678, Conversion.shortArrayToInt(src, 0, 0x12345678, 0, 0)); [EOL]         assertEquals(0xCDF15678, Conversion.shortArrayToInt(src, 0, 0x12345678, 16, 1)); [EOL]         // assertEquals(0x34567800,Conversion.ShortArrayToInt(src, 3, 0x12345678, 16, 2)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#byteArrayToInt(byte[], int, int, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testShortArrayToInt() { [EOL]         final short[] src = new short[]{ [EOL]             (short)0xCDF1, (short)0xF0C1, (short)0x0F12, (short)0x3456, (short)0x7800}; [EOL]         assertEquals(0x00000000, Conversion.shortArrayToInt(src, 0, 0, 0, 0)); [EOL]         assertEquals(0x0000CDF1, Conversion.shortArrayToInt(src, 0, 0, 0, 1)); [EOL]         assertEquals(0xF0C1CDF1, Conversion.shortArrayToInt(src, 0, 0, 0, 2)); [EOL]         assertEquals(0x0F12F0C1, Conversion.shortArrayToInt(src, 1, 0, 0, 2)); [EOL]         assertEquals(0x12345678, Conversion.shortArrayToInt(src, 0, 0x12345678, 0, 0)); [EOL]         assertEquals(0xCDF15678, Conversion.shortArrayToInt(src, 0, 0x12345678, 16, 1)); [EOL]         // assertEquals(0x34567800,Conversion.ShortArrayToInt(src, 3, 0x12345678, 16, 2)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#byteArrayToInt(byte[], int, int, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testShortArrayToInt() { [EOL]         final short[] src = new short[]{ [EOL]             (short)0xCDF1, (short)0xF0C1, (short)0x0F12, (short)0x3456, (short)0x7800}; [EOL]         assertEquals(0x00000000, Conversion.shortArrayToInt(src, 0, 0, 0, 0)); [EOL]         assertEquals(0x0000CDF1, Conversion.shortArrayToInt(src, 0, 0, 0, 1)); [EOL]         assertEquals(0xF0C1CDF1, Conversion.shortArrayToInt(src, 0, 0, 0, 2)); [EOL]         assertEquals(0x0F12F0C1, Conversion.shortArrayToInt(src, 1, 0, 0, 2)); [EOL]         assertEquals(0x12345678, Conversion.shortArrayToInt(src, 0, 0x12345678, 0, 0)); [EOL]         assertEquals(0xCDF15678, Conversion.shortArrayToInt(src, 0, 0x12345678, 16, 1)); [EOL]         // assertEquals(0x34567800,Conversion.ShortArrayToInt(src, 3, 0x12345678, 16, 2)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#byteArrayToInt(byte[], int, int, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testByteArrayToLong() { [EOL]         final byte[] src = new byte[]{ [EOL]             (byte)0xCD, (byte)0xF1, (byte)0xF0, (byte)0xC1, (byte)0x0F, (byte)0x12, (byte)0x34, [EOL]             (byte)0x56, (byte)0x78}; [EOL]         assertEquals(0x0000000000000000L, Conversion.byteArrayToLong(src, 0, 0L, 0, 0)); [EOL]         assertEquals(0x00000000000000CDL, Conversion.byteArrayToLong(src, 0, 0L, 0, 1)); [EOL]         assertEquals(0x00000000C1F0F1CDL, Conversion.byteArrayToLong(src, 0, 0L, 0, 4)); [EOL]         assertEquals(0x000000000FC1F0F1L, Conversion.byteArrayToLong(src, 1, 0L, 0, 4)); [EOL]         assertEquals( [EOL]             0x123456789ABCDEF0L, Conversion.byteArrayToLong(src, 0, 0x123456789ABCDEF0L, 0, 0)); [EOL]         assertEquals( [EOL]             0x12345678CDBCDEF0L, Conversion.byteArrayToLong(src, 0, 0x123456789ABCDEF0L, 24, 1)); [EOL]         assertEquals( [EOL]             0x123456789A7856F0L, Conversion.byteArray
@Test [EOL]     public void testByteArrayToLong() { [EOL]         final byte[] src = new byte[]{ [EOL]             (byte)0xCD, (byte)0xF1, (byte)0xF0, (byte)0xC1, (byte)0x0F, (byte)0x12, (byte)0x34, [EOL]             (byte)0x56, (byte)0x78}; [EOL]         assertEquals(0x0000000000000000L, Conversion.byteArrayToLong(src, 0, 0L, 0, 0)); [EOL]         assertEquals(0x00000000000000CDL, Conversion.byteArrayToLong(src, 0, 0L, 0, 1)); [EOL]         assertEquals(0x00000000C1F0F1CDL, Conversion.byteArrayToLong(src, 0, 0L, 0, 4)); [EOL]         assertEquals(0x000000000FC1F0F1L, Conversion.byteArrayToLong(src, 1, 0L, 0, 4)); [EOL]         assertEquals( [EOL]             0x123456789ABCDEF0L, Conversion.byteArrayToLong(src, 0, 0x123456789ABCDEF0L, 0, 0)); [EOL]         assertEquals( [EOL]             0x12345678CDBCDEF0L, Conversion.byteArrayToLong(src, 0, 0x123456789ABCDEF0L, 24, 1)); [EOL]         assertEquals( [EOL]             0x123456789A7856F0L, Conversion.byteArray
@Test [EOL]     public void testByteArrayToInt() { [EOL]         final byte[] src = new byte[]{ [EOL]             (byte)0xCD, (byte)0xF1, (byte)0xF0, (byte)0xC1, (byte)0x0F, (byte)0x12, (byte)0x34, [EOL]             (byte)0x56, (byte)0x78}; [EOL]         assertEquals(0x00000000, Conversion.byteArrayToInt(src, 0, 0, 0, 0)); [EOL]         assertEquals(0x000000CD, Conversion.byteArrayToInt(src, 0, 0, 0, 1)); [EOL]         assertEquals(0xC1F0F1CD, Conversion.byteArrayToInt(src, 0, 0, 0, 4)); [EOL]         assertEquals(0x0FC1F0F1, Conversion.byteArrayToInt(src, 1, 0, 0, 4)); [EOL]         assertEquals(0x12345678, Conversion.byteArrayToInt(src, 0, 0x12345678, 0, 0)); [EOL]         assertEquals(0xCD345678, Conversion.byteArrayToInt(src, 0, 0x12345678, 24, 1)); [EOL]         // assertEquals(0x56341278,Conversion.ByteArrayToInt(src, 5, 0x01234567, 8, 4)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#byteArrayToShort(byte[], int, short, int, int)}. [EOL]     
@Test [EOL]     public void testByteArrayToInt() { [EOL]         final byte[] src = new byte[]{ [EOL]             (byte)0xCD, (byte)0xF1, (byte)0xF0, (byte)0xC1, (byte)0x0F, (byte)0x12, (byte)0x34, [EOL]             (byte)0x56, (byte)0x78}; [EOL]         assertEquals(0x00000000, Conversion.byteArrayToInt(src, 0, 0, 0, 0)); [EOL]         assertEquals(0x000000CD, Conversion.byteArrayToInt(src, 0, 0, 0, 1)); [EOL]         assertEquals(0xC1F0F1CD, Conversion.byteArrayToInt(src, 0, 0, 0, 4)); [EOL]         assertEquals(0x0FC1F0F1, Conversion.byteArrayToInt(src, 1, 0, 0, 4)); [EOL]         assertEquals(0x12345678, Conversion.byteArrayToInt(src, 0, 0x12345678, 0, 0)); [EOL]         assertEquals(0xCD345678, Conversion.byteArrayToInt(src, 0, 0x12345678, 24, 1)); [EOL]         // assertEquals(0x56341278,Conversion.ByteArrayToInt(src, 5, 0x01234567, 8, 4)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#byteArrayToShort(byte[], int, short, int, int)}. [EOL]     
@Test [EOL]     public void testByteArrayToShort() { [EOL]         final byte[] src = new byte[]{ [EOL]             (byte)0xCD, (byte)0xF1, (byte)0xF0, (byte)0xC1, (byte)0x0F, (byte)0x12, (byte)0x34, [EOL]             (byte)0x56, (byte)0x78}; [EOL]         assertEquals((short)0x0000, Conversion.byteArrayToShort(src, 0, (short)0, 0, 0)); [EOL]         assertEquals((short)0x00CD, Conversion.byteArrayToShort(src, 0, (short)0, 0, 1)); [EOL]         assertEquals((short)0xF1CD, Conversion.byteArrayToShort(src, 0, (short)0, 0, 2)); [EOL]         assertEquals((short)0xF0F1, Conversion.byteArrayToShort(src, 1, (short)0, 0, 2)); [EOL]         assertEquals((short)0x1234, Conversion.byteArrayToShort(src, 0, (short)0x1234, 0, 0)); [EOL]         assertEquals((short)0xCD34, Conversion.byteArrayToShort(src, 0, (short)0x1234, 8, 1)); [EOL]         // assertEquals((short)0x5678,Conversion.ByteArrayToShort(src, 7, (short) 0x0123, 8, [EOL]         // 2)); [EOL]     } [EOL]  [EOL]     /** [EOL]     
@Test [EOL]     public void testByteArrayToShort() { [EOL]         final byte[] src = new byte[]{ [EOL]             (byte)0xCD, (byte)0xF1, (byte)0xF0, (byte)0xC1, (byte)0x0F, (byte)0x12, (byte)0x34, [EOL]             (byte)0x56, (byte)0x78}; [EOL]         assertEquals((short)0x0000, Conversion.byteArrayToShort(src, 0, (short)0, 0, 0)); [EOL]         assertEquals((short)0x00CD, Conversion.byteArrayToShort(src, 0, (short)0, 0, 1)); [EOL]         assertEquals((short)0xF1CD, Conversion.byteArrayToShort(src, 0, (short)0, 0, 2)); [EOL]         assertEquals((short)0xF0F1, Conversion.byteArrayToShort(src, 1, (short)0, 0, 2)); [EOL]         assertEquals((short)0x1234, Conversion.byteArrayToShort(src, 0, (short)0x1234, 0, 0)); [EOL]         assertEquals((short)0xCD34, Conversion.byteArrayToShort(src, 0, (short)0x1234, 8, 1)); [EOL]         // assertEquals((short)0x5678,Conversion.ByteArrayToShort(src, 7, (short) 0x0123, 8, [EOL]         // 2)); [EOL]     } [EOL]  [EOL]     /** [EOL]     
@Test [EOL]     public void testHexToLong() { [EOL]         final String src = "CDF1F0C10F12345678"; [EOL]         assertEquals(0x0000000000000000L, Conversion.hexToLong(src, 0, 0L, 0, 0)); [EOL]         assertEquals(0x000000000000000CL, Conversion.hexToLong(src, 0, 0L, 0, 1)); [EOL]         assertEquals(0x000000001C0F1FDCL, Conversion.hexToLong(src, 0, 0L, 0, 8)); [EOL]         assertEquals(0x0000000001C0F1FDL, Conversion.hexToLong(src, 1, 0L, 0, 8)); [EOL]         assertEquals( [EOL]             0x123456798ABCDEF0L, Conversion.hexToLong(src, 0, 0x123456798ABCDEF0L, 0, 0)); [EOL]         assertEquals( [EOL]             0x1234567876BCDEF0L, Conversion.hexToLong(src, 15, 0x123456798ABCDEF0L, 24, 3)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#hexToInt(String, int, int, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexToLong() { [EOL]         final String src = "CDF1F0C10F12345678"; [EOL]         assertEquals(0x0000000000000000L, Conversion.hexToLong(src, 0, 0L, 0, 0)); [EOL]         assertEquals(0x000000000000000CL, Conversion.hexToLong(src, 0, 0L, 0, 1)); [EOL]         assertEquals(0x000000001C0F1FDCL, Conversion.hexToLong(src, 0, 0L, 0, 8)); [EOL]         assertEquals(0x0000000001C0F1FDL, Conversion.hexToLong(src, 1, 0L, 0, 8)); [EOL]         assertEquals( [EOL]             0x123456798ABCDEF0L, Conversion.hexToLong(src, 0, 0x123456798ABCDEF0L, 0, 0)); [EOL]         assertEquals( [EOL]             0x1234567876BCDEF0L, Conversion.hexToLong(src, 15, 0x123456798ABCDEF0L, 24, 3)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#hexToInt(String, int, int, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexToInt() { [EOL]         final String src = "CDF1F0C10F12345678"; [EOL]         assertEquals(0x00000000, Conversion.hexToInt(src, 0, 0, 0, 0)); [EOL]         assertEquals(0x0000000C, Conversion.hexToInt(src, 0, 0, 0, 1)); [EOL]         assertEquals(0x1C0F1FDC, Conversion.hexToInt(src, 0, 0, 0, 8)); [EOL]         assertEquals(0x01C0F1FD, Conversion.hexToInt(src, 1, 0, 0, 8)); [EOL]         assertEquals(0x12345679, Conversion.hexToInt(src, 0, 0x12345679, 0, 0)); [EOL]         assertEquals(0x87645679, Conversion.hexToInt(src, 15, 0x12345679, 20, 3)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#hexToShort(String, int, short, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexToInt() { [EOL]         final String src = "CDF1F0C10F12345678"; [EOL]         assertEquals(0x00000000, Conversion.hexToInt(src, 0, 0, 0, 0)); [EOL]         assertEquals(0x0000000C, Conversion.hexToInt(src, 0, 0, 0, 1)); [EOL]         assertEquals(0x1C0F1FDC, Conversion.hexToInt(src, 0, 0, 0, 8)); [EOL]         assertEquals(0x01C0F1FD, Conversion.hexToInt(src, 1, 0, 0, 8)); [EOL]         assertEquals(0x12345679, Conversion.hexToInt(src, 0, 0x12345679, 0, 0)); [EOL]         assertEquals(0x87645679, Conversion.hexToInt(src, 15, 0x12345679, 20, 3)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#hexToShort(String, int, short, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexToShort() { [EOL]         final String src = "CDF1F0C10F12345678"; [EOL]         assertEquals((short)0x0000, Conversion.hexToShort(src, 0, (short)0, 0, 0)); [EOL]         assertEquals((short)0x000C, Conversion.hexToShort(src, 0, (short)0, 0, 1)); [EOL]         assertEquals((short)0x1FDC, Conversion.hexToShort(src, 0, (short)0, 0, 4)); [EOL]         assertEquals((short)0xF1FD, Conversion.hexToShort(src, 1, (short)0, 0, 4)); [EOL]         assertEquals((short)0x1234, Conversion.hexToShort(src, 0, (short)0x1234, 0, 0)); [EOL]         assertEquals((short)0x8764, Conversion.hexToShort(src, 15, (short)0x1234, 4, 3)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#hexToByte(String, int, byte, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexToShort() { [EOL]         final String src = "CDF1F0C10F12345678"; [EOL]         assertEquals((short)0x0000, Conversion.hexToShort(src, 0, (short)0, 0, 0)); [EOL]         assertEquals((short)0x000C, Conversion.hexToShort(src, 0, (short)0, 0, 1)); [EOL]         assertEquals((short)0x1FDC, Conversion.hexToShort(src, 0, (short)0, 0, 4)); [EOL]         assertEquals((short)0xF1FD, Conversion.hexToShort(src, 1, (short)0, 0, 4)); [EOL]         assertEquals((short)0x1234, Conversion.hexToShort(src, 0, (short)0x1234, 0, 0)); [EOL]         assertEquals((short)0x8764, Conversion.hexToShort(src, 15, (short)0x1234, 4, 3)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#hexToByte(String, int, byte, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexToByte() { [EOL]         final String src = "CDF1F0C10F12345678"; [EOL]         assertEquals((byte)0x00, Conversion.hexToByte(src, 0, (byte)0, 0, 0)); [EOL]         assertEquals((byte)0x0C, Conversion.hexToByte(src, 0, (byte)0, 0, 1)); [EOL]         assertEquals((byte)0xDC, Conversion.hexToByte(src, 0, (byte)0, 0, 2)); [EOL]         assertEquals((byte)0xFD, Conversion.hexToByte(src, 1, (byte)0, 0, 2)); [EOL]         assertEquals((byte)0x34, Conversion.hexToByte(src, 0, (byte)0x34, 0, 0)); [EOL]         assertEquals((byte)0x84, Conversion.hexToByte(src, 17, (byte)0x34, 4, 1)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#binaryToLong(boolean[], int, long, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexToByte() { [EOL]         final String src = "CDF1F0C10F12345678"; [EOL]         assertEquals((byte)0x00, Conversion.hexToByte(src, 0, (byte)0, 0, 0)); [EOL]         assertEquals((byte)0x0C, Conversion.hexToByte(src, 0, (byte)0, 0, 1)); [EOL]         assertEquals((byte)0xDC, Conversion.hexToByte(src, 0, (byte)0, 0, 2)); [EOL]         assertEquals((byte)0xFD, Conversion.hexToByte(src, 1, (byte)0, 0, 2)); [EOL]         assertEquals((byte)0x34, Conversion.hexToByte(src, 0, (byte)0x34, 0, 0)); [EOL]         assertEquals((byte)0x84, Conversion.hexToByte(src, 17, (byte)0x34, 4, 1)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#binaryToLong(boolean[], int, long, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testBinaryToLong() { [EOL]         final boolean[] src = new boolean[]{ [EOL]             false, false, true, true, true, false, true, true, true, true, true, true, true, [EOL]             false, false, false, true, true, true, true, false, false, false, false, false, [EOL]             false, true, true, true, false, false, false, false, false, false, false, true, [EOL]             true, true, true, true, false, false, false, false, true, false, false, true, true, [EOL]             false, false, false, false, true, false, true, false, true, false, false, true, [EOL]             true, false, true, true, true, false, false, false, false, true}; [EOL]         // conversion of "CDF1F0C10F12345678" by HexToBinary [EOL]         assertEquals(0x0000000000000000L, Conversion.binaryToLong(src, 0, 0L, 0, 0)); [EOL]         assertEquals(0x000000000000000CL, Conversion.binaryToLong(src, 0, 0L, 0, 1 * 4)); [EOL]         assertEquals(0x000000001C0F1FDCL, Conversion.binaryToLong(src, 0, 0L, 0, 8 * 4)); [EOL]         assertEquals(0x0000000001C0F1FDL, Conversion.binaryToLong(src, 1 * 4, 0L, 0, 8 * 4)); [EOL]        
@Test [EOL]     public void testBinaryToLong() { [EOL]         final boolean[] src = new boolean[]{ [EOL]             false, false, true, true, true, false, true, true, true, true, true, true, true, [EOL]             false, false, false, true, true, true, true, false, false, false, false, false, [EOL]             false, true, true, true, false, false, false, false, false, false, false, true, [EOL]             true, true, true, true, false, false, false, false, true, false, false, true, true, [EOL]             false, false, false, false, true, false, true, false, true, false, false, true, [EOL]             true, false, true, true, true, false, false, false, false, true}; [EOL]         // conversion of "CDF1F0C10F12345678" by HexToBinary [EOL]         assertEquals(0x0000000000000000L, Conversion.binaryToLong(src, 0, 0L, 0, 0)); [EOL]         assertEquals(0x000000000000000CL, Conversion.binaryToLong(src, 0, 0L, 0, 1 * 4)); [EOL]         assertEquals(0x000000001C0F1FDCL, Conversion.binaryToLong(src, 0, 0L, 0, 8 * 4)); [EOL]         assertEquals(0x0000000001C0F1FDL, Conversion.binaryToLong(src, 1 * 4, 0L, 0, 8 * 4)); [EOL]        
@Test [EOL]     public void testLongToIntArray() { [EOL]         assertArrayEquals( [EOL]             new int[]{}, Conversion.longToIntArray(0x0000000000000000L, 0, new int[]{}, 0, 0)); [EOL]         assertArrayEquals( [EOL]             new int[]{}, Conversion.longToIntArray(0x0000000000000000L, 100, new int[]{}, 0, 0)); [EOL]         assertArrayEquals( [EOL]             new int[]{}, Conversion.longToIntArray(0x0000000000000000L, 0, new int[]{}, 100, 0)); [EOL]         assertArrayEquals( [EOL]             new int[]{0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF}, [EOL]             Conversion.longToIntArray(0x1234567890ABCDEFL, 0, new int[]{-1, -1, -1, -1}, 0, 0)); [EOL]         assertArrayEquals( [EOL]             new int[]{0x90ABCDEF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF}, [EOL]             Conversion.longToIntArray(0x1234567890ABCDEFL, 0, new int[]{-1, -1, -1, -1}, 0, 1)); [EOL]         assertArrayEquals( [EOL]             new int[]{0x90ABCDEF, 0x12345678, 0xFFFFFFFF, 0xFFFFFFFF}, [EOL]        
@Test [EOL]     public void testLongToIntArray() { [EOL]         assertArrayEquals( [EOL]             new int[]{}, Conversion.longToIntArray(0x0000000000000000L, 0, new int[]{}, 0, 0)); [EOL]         assertArrayEquals( [EOL]             new int[]{}, Conversion.longToIntArray(0x0000000000000000L, 100, new int[]{}, 0, 0)); [EOL]         assertArrayEquals( [EOL]             new int[]{}, Conversion.longToIntArray(0x0000000000000000L, 0, new int[]{}, 100, 0)); [EOL]         assertArrayEquals( [EOL]             new int[]{0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF}, [EOL]             Conversion.longToIntArray(0x1234567890ABCDEFL, 0, new int[]{-1, -1, -1, -1}, 0, 0)); [EOL]         assertArrayEquals( [EOL]             new int[]{0x90ABCDEF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF}, [EOL]             Conversion.longToIntArray(0x1234567890ABCDEFL, 0, new int[]{-1, -1, -1, -1}, 0, 1)); [EOL]         assertArrayEquals( [EOL]             new int[]{0x90ABCDEF, 0x12345678, 0xFFFFFFFF, 0xFFFFFFFF}, [EOL]        
@Test [EOL]     public void testLongToHex() { [EOL]         assertEquals("", Conversion.longToHex(0x0000000000000000L, 0, "", 0, 0)); [EOL]         assertEquals("", Conversion.longToHex(0x0000000000000000L, 100, "", 0, 0)); [EOL]         assertEquals("", Conversion.longToHex(0x0000000000000000L, 0, "", 100, 0)); [EOL]         assertEquals( [EOL]             "ffffffffffffffffffffffff", [EOL]             Conversion.longToHex(0x1234567890ABCDEFL, 0, "ffffffffffffffffffffffff", 0, 0)); [EOL]         assertEquals( [EOL]             "3fffffffffffffffffffffff", [EOL]             Conversion.longToHex(0x1234567890ABCDE3L, 0, "ffffffffffffffffffffffff", 0, 1)); [EOL]         assertEquals( [EOL]             "feffffffffffffffffffffff", [EOL]             Conversion.longToHex(0x1234567890ABCDEFL, 0, "ffffffffffffffffffffffff", 0, 2)); [EOL]         assertEquals( [EOL]             "fedcffffffffffffffffffff", [EOL]             Conversion.longToHex(0x1234567890ABCDEFL, 0, "ffffffffffffffffffffffff", 0, 4)); [EOL]         assertEquals( [
@Test [EOL]     public void testLongToHex() { [EOL]         assertEquals("", Conversion.longToHex(0x0000000000000000L, 0, "", 0, 0)); [EOL]         assertEquals("", Conversion.longToHex(0x0000000000000000L, 100, "", 0, 0)); [EOL]         assertEquals("", Conversion.longToHex(0x0000000000000000L, 0, "", 100, 0)); [EOL]         assertEquals( [EOL]             "ffffffffffffffffffffffff", [EOL]             Conversion.longToHex(0x1234567890ABCDEFL, 0, "ffffffffffffffffffffffff", 0, 0)); [EOL]         assertEquals( [EOL]             "3fffffffffffffffffffffff", [EOL]             Conversion.longToHex(0x1234567890ABCDE3L, 0, "ffffffffffffffffffffffff", 0, 1)); [EOL]         assertEquals( [EOL]             "feffffffffffffffffffffff", [EOL]             Conversion.longToHex(0x1234567890ABCDEFL, 0, "ffffffffffffffffffffffff", 0, 2)); [EOL]         assertEquals( [EOL]             "fedcffffffffffffffffffff", [EOL]             Conversion.longToHex(0x1234567890ABCDEFL, 0, "ffffffffffffffffffffffff", 0, 4)); [EOL]         assertEquals( [
@Test [EOL]     public void testIntToHex() { [EOL]         assertEquals("", Conversion.intToHex(0x00000000, 0, "", 0, 0)); [EOL]         assertEquals("", Conversion.intToHex(0x00000000, 100, "", 0, 0)); [EOL]         assertEquals("", Conversion.intToHex(0x00000000, 0, "", 100, 0)); [EOL]         assertEquals( [EOL]             "ffffffffffffffffffffffff", [EOL]             Conversion.intToHex(0x90ABCDEF, 0, "ffffffffffffffffffffffff", 0, 0)); [EOL]         assertEquals( [EOL]             "3fffffffffffffffffffffff", [EOL]             Conversion.intToHex(0x90ABCDE3, 0, "ffffffffffffffffffffffff", 0, 1)); [EOL]         assertEquals( [EOL]             "feffffffffffffffffffffff", [EOL]             Conversion.intToHex(0x90ABCDEF, 0, "ffffffffffffffffffffffff", 0, 2)); [EOL]         assertEquals( [EOL]             "fedcffffffffffffffffffff", [EOL]             Conversion.intToHex(0x90ABCDEF, 0, "ffffffffffffffffffffffff", 0, 4)); [EOL]         assertEquals( [EOL]             "fedcba
@Test [EOL]     public void testIntToHex() { [EOL]         assertEquals("", Conversion.intToHex(0x00000000, 0, "", 0, 0)); [EOL]         assertEquals("", Conversion.intToHex(0x00000000, 100, "", 0, 0)); [EOL]         assertEquals("", Conversion.intToHex(0x00000000, 0, "", 100, 0)); [EOL]         assertEquals( [EOL]             "ffffffffffffffffffffffff", [EOL]             Conversion.intToHex(0x90ABCDEF, 0, "ffffffffffffffffffffffff", 0, 0)); [EOL]         assertEquals( [EOL]             "3fffffffffffffffffffffff", [EOL]             Conversion.intToHex(0x90ABCDE3, 0, "ffffffffffffffffffffffff", 0, 1)); [EOL]         assertEquals( [EOL]             "feffffffffffffffffffffff", [EOL]             Conversion.intToHex(0x90ABCDEF, 0, "ffffffffffffffffffffffff", 0, 2)); [EOL]         assertEquals( [EOL]             "fedcffffffffffffffffffff", [EOL]             Conversion.intToHex(0x90ABCDEF, 0, "ffffffffffffffffffffffff", 0, 4)); [EOL]         assertEquals( [EOL]             "fedcba
@Test [EOL]     public void testShortToHex() { [EOL]         assertEquals("", Conversion.shortToHex((short)0x0000, 0, "", 0, 0)); [EOL]         assertEquals("", Conversion.shortToHex((short)0x0000, 100, "", 0, 0)); [EOL]         assertEquals("", Conversion.shortToHex((short)0x0000, 0, "", 100, 0)); [EOL]         assertEquals( [EOL]             "ffffffffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDEF, 0, "ffffffffffffffffffffffff", 0, 0)); [EOL]         assertEquals( [EOL]             "3fffffffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDE3, 0, "ffffffffffffffffffffffff", 0, 1)); [EOL]         assertEquals( [EOL]             "feffffffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDEF, 0, "ffffffffffffffffffffffff", 0, 2)); [EOL]         assertEquals( [EOL]             "fedfffffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDEF, 0, "ffffffffffffffffffffffff", 0, 3)); [EOL]         assertEquals( [EOL]     
@Test [EOL]     public void testShortToHex() { [EOL]         assertEquals("", Conversion.shortToHex((short)0x0000, 0, "", 0, 0)); [EOL]         assertEquals("", Conversion.shortToHex((short)0x0000, 100, "", 0, 0)); [EOL]         assertEquals("", Conversion.shortToHex((short)0x0000, 0, "", 100, 0)); [EOL]         assertEquals( [EOL]             "ffffffffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDEF, 0, "ffffffffffffffffffffffff", 0, 0)); [EOL]         assertEquals( [EOL]             "3fffffffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDE3, 0, "ffffffffffffffffffffffff", 0, 1)); [EOL]         assertEquals( [EOL]             "feffffffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDEF, 0, "ffffffffffffffffffffffff", 0, 2)); [EOL]         assertEquals( [EOL]             "fedfffffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDEF, 0, "ffffffffffffffffffffffff", 0, 3)); [EOL]         assertEquals( [EOL]     
@Test [EOL]     public void testShortToHex() { [EOL]         assertEquals("", Conversion.shortToHex((short)0x0000, 0, "", 0, 0)); [EOL]         assertEquals("", Conversion.shortToHex((short)0x0000, 100, "", 0, 0)); [EOL]         assertEquals("", Conversion.shortToHex((short)0x0000, 0, "", 100, 0)); [EOL]         assertEquals( [EOL]             "ffffffffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDEF, 0, "ffffffffffffffffffffffff", 0, 0)); [EOL]         assertEquals( [EOL]             "3fffffffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDE3, 0, "ffffffffffffffffffffffff", 0, 1)); [EOL]         assertEquals( [EOL]             "feffffffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDEF, 0, "ffffffffffffffffffffffff", 0, 2)); [EOL]         assertEquals( [EOL]             "fedfffffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDEF, 0, "ffffffffffffffffffffffff", 0, 3)); [EOL]         assertEquals( [EOL]     
@Test [EOL]     public void testShortToHex() { [EOL]         assertEquals("", Conversion.shortToHex((short)0x0000, 0, "", 0, 0)); [EOL]         assertEquals("", Conversion.shortToHex((short)0x0000, 100, "", 0, 0)); [EOL]         assertEquals("", Conversion.shortToHex((short)0x0000, 0, "", 100, 0)); [EOL]         assertEquals( [EOL]             "ffffffffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDEF, 0, "ffffffffffffffffffffffff", 0, 0)); [EOL]         assertEquals( [EOL]             "3fffffffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDE3, 0, "ffffffffffffffffffffffff", 0, 1)); [EOL]         assertEquals( [EOL]             "feffffffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDEF, 0, "ffffffffffffffffffffffff", 0, 2)); [EOL]         assertEquals( [EOL]             "fedfffffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDEF, 0, "ffffffffffffffffffffffff", 0, 3)); [EOL]         assertEquals( [EOL]     
@Test [EOL]     public void testShortToHex() { [EOL]         assertEquals("", Conversion.shortToHex((short)0x0000, 0, "", 0, 0)); [EOL]         assertEquals("", Conversion.shortToHex((short)0x0000, 100, "", 0, 0)); [EOL]         assertEquals("", Conversion.shortToHex((short)0x0000, 0, "", 100, 0)); [EOL]         assertEquals( [EOL]             "ffffffffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDEF, 0, "ffffffffffffffffffffffff", 0, 0)); [EOL]         assertEquals( [EOL]             "3fffffffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDE3, 0, "ffffffffffffffffffffffff", 0, 1)); [EOL]         assertEquals( [EOL]             "feffffffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDEF, 0, "ffffffffffffffffffffffff", 0, 2)); [EOL]         assertEquals( [EOL]             "fedfffffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDEF, 0, "ffffffffffffffffffffffff", 0, 3)); [EOL]         assertEquals( [EOL]     
@Test [EOL]     public void testShortToHex() { [EOL]         assertEquals("", Conversion.shortToHex((short)0x0000, 0, "", 0, 0)); [EOL]         assertEquals("", Conversion.shortToHex((short)0x0000, 100, "", 0, 0)); [EOL]         assertEquals("", Conversion.shortToHex((short)0x0000, 0, "", 100, 0)); [EOL]         assertEquals( [EOL]             "ffffffffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDEF, 0, "ffffffffffffffffffffffff", 0, 0)); [EOL]         assertEquals( [EOL]             "3fffffffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDE3, 0, "ffffffffffffffffffffffff", 0, 1)); [EOL]         assertEquals( [EOL]             "feffffffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDEF, 0, "ffffffffffffffffffffffff", 0, 2)); [EOL]         assertEquals( [EOL]             "fedfffffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDEF, 0, "ffffffffffffffffffffffff", 0, 3)); [EOL]         assertEquals( [EOL]     
@Test [EOL]     public void testByteToHex() { [EOL]         assertEquals("", Conversion.byteToHex((byte)0x00, 0, "", 0, 0)); [EOL]         assertEquals("", Conversion.byteToHex((byte)0x00, 100, "", 0, 0)); [EOL]         assertEquals("", Conversion.byteToHex((byte)0x00, 0, "", 100, 0)); [EOL]         assertEquals("00000", Conversion.byteToHex((byte)0xEF, 0, "00000", 0, 0)); [EOL]         assertEquals("f0000", Conversion.byteToHex((byte)0xEF, 0, "00000", 0, 1)); [EOL]         assertEquals("fe000", Conversion.byteToHex((byte)0xEF, 0, "00000", 0, 2)); [EOL]         assertEquals("000f0", Conversion.byteToHex((byte)0xEF, 0, "00000", 3, 1)); [EOL]         assertEquals("000fe", Conversion.byteToHex((byte)0xEF, 0, "00000", 3, 2)); [EOL]         assertEquals("70000", Conversion.byteToHex((byte)0xEF, 1, "00000", 0, 1)); [EOL]         assertEquals("b0000", Conversion.byteToHex((byte)0xEF, 2, "00000", 0, 1)); [EOL]         assertEquals("000df", Conversion.byteToHex((byte)0xEF, 3, "00000", 3, 2)); [EOL]         // assertEquals("00000",Conversion.byteToHex((byte)0xEF, 4,"00000",
@Test [EOL]     public void testByteToHex() { [EOL]         assertEquals("", Conversion.byteToHex((byte)0x00, 0, "", 0, 0)); [EOL]         assertEquals("", Conversion.byteToHex((byte)0x00, 100, "", 0, 0)); [EOL]         assertEquals("", Conversion.byteToHex((byte)0x00, 0, "", 100, 0)); [EOL]         assertEquals("00000", Conversion.byteToHex((byte)0xEF, 0, "00000", 0, 0)); [EOL]         assertEquals("f0000", Conversion.byteToHex((byte)0xEF, 0, "00000", 0, 1)); [EOL]         assertEquals("fe000", Conversion.byteToHex((byte)0xEF, 0, "00000", 0, 2)); [EOL]         assertEquals("000f0", Conversion.byteToHex((byte)0xEF, 0, "00000", 3, 1)); [EOL]         assertEquals("000fe", Conversion.byteToHex((byte)0xEF, 0, "00000", 3, 2)); [EOL]         assertEquals("70000", Conversion.byteToHex((byte)0xEF, 1, "00000", 0, 1)); [EOL]         assertEquals("b0000", Conversion.byteToHex((byte)0xEF, 2, "00000", 0, 1)); [EOL]         assertEquals("000df", Conversion.byteToHex((byte)0xEF, 3, "00000", 3, 2)); [EOL]         // assertEquals("00000",Conversion.byteToHex((byte)0xEF, 4,"00000",
@Test [EOL]     public void testShortToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{}, Conversion.shortToBinary((short)0x0000, 0, new boolean[]{}, 0, 0)); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{}, [EOL]             Conversion.shortToBinary((short)0x0000, 100, new boolean[]{}, 0, 0)); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{}, [EOL]             Conversion.shortToBinary((short)0x0000, 0, new boolean[]{}, 100, 0)); [EOL]         assertBinaryEquals( [EOL]             new boolean[69], Conversion.shortToBinary((short)0xCDEF, 0, new boolean[69], 0, 0)); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{ [EOL]                 true, false, false, false, false, false, false, false, false, false, false, [EOL]                 false, false, false, false, false, false, false, false, false, false}, [EOL]             Conversion.shortToBinary((short)0xCDEF, 0, new boolean[21], 0, 1)); [EOL]         assertBinaryEquals( [EOL]           
@Test [EOL]     public void testByteToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{}, Conversion.byteToBinary((byte)0x00, 0, new boolean[]{}, 0, 0)); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{}, Conversion.byteToBinary((byte)0x00, 100, new boolean[]{}, 0, 0)); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{}, Conversion.byteToBinary((byte)0x00, 0, new boolean[]{}, 100, 0)); [EOL]         assertBinaryEquals( [EOL]             new boolean[69], Conversion.byteToBinary((byte)0xEF, 0, new boolean[69], 0, 0)); [EOL]         assertBinaryEquals(new boolean[]{ [EOL]             true, false, false, false, false, false, false, false, false, false, false, false, [EOL]             false}, Conversion.byteToBinary((byte)0x95, 0, new boolean[13], 0, 1)); [EOL]         assertBinaryEquals(new boolean[]{ [EOL]             true, false, false, false, false, false, false, false, false, false, false, false, [EOL]             false}, Conversion.byteToBinary((byte)0x95, 0, new boolean[13], 0, 2)); [EOL]         assertBinaryEquals(new
@Test [EOL]     public void testByteToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{}, Conversion.byteToBinary((byte)0x00, 0, new boolean[]{}, 0, 0)); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{}, Conversion.byteToBinary((byte)0x00, 100, new boolean[]{}, 0, 0)); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{}, Conversion.byteToBinary((byte)0x00, 0, new boolean[]{}, 100, 0)); [EOL]         assertBinaryEquals( [EOL]             new boolean[69], Conversion.byteToBinary((byte)0xEF, 0, new boolean[69], 0, 0)); [EOL]         assertBinaryEquals(new boolean[]{ [EOL]             true, false, false, false, false, false, false, false, false, false, false, false, [EOL]             false}, Conversion.byteToBinary((byte)0x95, 0, new boolean[13], 0, 1)); [EOL]         assertBinaryEquals(new boolean[]{ [EOL]             true, false, false, false, false, false, false, false, false, false, false, false, [EOL]             false}, Conversion.byteToBinary((byte)0x95, 0, new boolean[13], 0, 2)); [EOL]         assertBinaryEquals(new
@Test [EOL]     public void testUuidToByteArray() { [EOL]         assertArrayEquals(new byte[]{ [EOL]             (byte)0xff, (byte)0xff, (byte)0xff, (byte)0xff, (byte)0xff, (byte)0xff, (byte)0xff, [EOL]             (byte)0xff, (byte)0xff, (byte)0xff, (byte)0xff, (byte)0xff, (byte)0xff, (byte)0xff, [EOL]             (byte)0xff, (byte)0xff}, Conversion.uuidToByteArray(new UUID( [EOL]             0xFFFFFFFFFFFFFFFFL, 0xFFFFFFFFFFFFFFFFL), new byte[16], 0, 16)); [EOL]         assertArrayEquals(new byte[]{ [EOL]             (byte)0x88, (byte)0x99, (byte)0xaa, (byte)0xbb, (byte)0xcc, (byte)0xdd, (byte)0xee, [EOL]             (byte)0xff, (byte)0x00, (byte)0x11, (byte)0x22, (byte)0x33, (byte)0x44, (byte)0x55, [EOL]             (byte)0x66, (byte)0x77}, Conversion.uuidToByteArray(new UUID( [EOL]             0xFFEEDDCCBBAA9988L, 0x7766554433221100L), new byte[16], 0, 16)); [EOL]         assertArrayEquals(new
@Test [EOL]     public void testBetween() { [EOL]         final UnicodeEscaper ue = UnicodeEscaper.between('F', 'L'); [EOL]  [EOL]         final String input = "ADFGZ"; [EOL]         final String result = ue.translate(input); [EOL]         assertEquals("Failed to escape Unicode characters via the between method", "AD\\u0046\\u0047Z", result); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testBetween() { [EOL]         final UnicodeEscaper ue = UnicodeEscaper.between('F', 'L'); [EOL]  [EOL]         final String input = "ADFGZ"; [EOL]         final String result = ue.translate(input); [EOL]         assertEquals("Failed to escape Unicode characters via the between method", "AD\\u0046\\u0047Z", result); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testBetween() { [EOL]         final UnicodeEscaper ue = UnicodeEscaper.between('F', 'L'); [EOL]  [EOL]         final String input = "ADFGZ"; [EOL]         final String result = ue.translate(input); [EOL]         assertEquals("Failed to escape Unicode characters via the between method", "AD\\u0046\\u0047Z", result); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testBetween() { [EOL]         final UnicodeEscaper ue = UnicodeEscaper.between('F', 'L'); [EOL]  [EOL]         final String input = "ADFGZ"; [EOL]         final String result = ue.translate(input); [EOL]         assertEquals("Failed to escape Unicode characters via the between method", "AD\\u0046\\u0047Z", result); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testOutOfBounds() { [EOL]         final NumericEntityUnescaper neu = new NumericEntityUnescaper(); [EOL]  [EOL]         assertEquals("Failed to ignore when last character is &", "Test &", neu.translate("Test &")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#", neu.translate("Test &#")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#x", neu.translate("Test &#x")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#X", neu.translate("Test &#X")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testOutOfBounds() { [EOL]         final NumericEntityUnescaper neu = new NumericEntityUnescaper(); [EOL]  [EOL]         assertEquals("Failed to ignore when last character is &", "Test &", neu.translate("Test &")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#", neu.translate("Test &#")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#x", neu.translate("Test &#x")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#X", neu.translate("Test &#X")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testOutOfBounds() { [EOL]         final NumericEntityUnescaper neu = new NumericEntityUnescaper(); [EOL]  [EOL]         assertEquals("Failed to ignore when last character is &", "Test &", neu.translate("Test &")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#", neu.translate("Test &#")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#x", neu.translate("Test &#x")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#X", neu.translate("Test &#X")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testOutOfBounds() { [EOL]         final NumericEntityUnescaper neu = new NumericEntityUnescaper(); [EOL]  [EOL]         assertEquals("Failed to ignore when last character is &", "Test &", neu.translate("Test &")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#", neu.translate("Test &#")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#x", neu.translate("Test &#x")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#X", neu.translate("Test &#X")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEscapeSurrogatePairs() throws Exception { [EOL]         assertEquals("\uD83D\uDE30", StringEscapeUtils.escapeCsv("\uD83D\uDE30")); [EOL]         // Examples from https://en.wikipedia.org/wiki/UTF-16 [EOL]         assertEquals("\uD800\uDC00", StringEscapeUtils.escapeCsv("\uD800\uDC00")); [EOL]         assertEquals("\uD834\uDD1E", StringEscapeUtils.escapeCsv("\uD834\uDD1E")); [EOL]         assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeCsv("\uDBFF\uDFFD")); [EOL]         assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeHtml3("\uDBFF\uDFFD")); [EOL]         assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeHtml4("\uDBFF\uDFFD")); [EOL]         assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeXml("\uDBFF\uDFFD")); [EOL]     } [EOL]      [EOL]     /** [EOL]      * Tests LANG-858. [EOL]      *  [EOL]      * @throws Exception [EOL]      */ [EOL]
@Test [EOL]     public void testEscapeSurrogatePairs() throws Exception { [EOL]         assertEquals("\uD83D\uDE30", StringEscapeUtils.escapeCsv("\uD83D\uDE30")); [EOL]         // Examples from https://en.wikipedia.org/wiki/UTF-16 [EOL]         assertEquals("\uD800\uDC00", StringEscapeUtils.escapeCsv("\uD800\uDC00")); [EOL]         assertEquals("\uD834\uDD1E", StringEscapeUtils.escapeCsv("\uD834\uDD1E")); [EOL]         assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeCsv("\uDBFF\uDFFD")); [EOL]         assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeHtml3("\uDBFF\uDFFD")); [EOL]         assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeHtml4("\uDBFF\uDFFD")); [EOL]         assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeXml("\uDBFF\uDFFD")); [EOL]     } [EOL]      [EOL]     /** [EOL]      * Tests LANG-858. [EOL]      *  [EOL]      * @throws Exception [EOL]      */ [EOL]
@Test [EOL]     public void testEscapeSurrogatePairs() throws Exception { [EOL]         assertEquals("\uD83D\uDE30", StringEscapeUtils.escapeCsv("\uD83D\uDE30")); [EOL]         // Examples from https://en.wikipedia.org/wiki/UTF-16 [EOL]         assertEquals("\uD800\uDC00", StringEscapeUtils.escapeCsv("\uD800\uDC00")); [EOL]         assertEquals("\uD834\uDD1E", StringEscapeUtils.escapeCsv("\uD834\uDD1E")); [EOL]         assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeCsv("\uDBFF\uDFFD")); [EOL]         assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeHtml3("\uDBFF\uDFFD")); [EOL]         assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeHtml4("\uDBFF\uDFFD")); [EOL]         assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeXml("\uDBFF\uDFFD")); [EOL]     } [EOL]      [EOL]     /** [EOL]      * Tests LANG-858. [EOL]      *  [EOL]      * @throws Exception [EOL]      */ [EOL]
@Test [EOL]     public void testEscapeSurrogatePairs() throws Exception { [EOL]         assertEquals("\uD83D\uDE30", StringEscapeUtils.escapeCsv("\uD83D\uDE30")); [EOL]         // Examples from https://en.wikipedia.org/wiki/UTF-16 [EOL]         assertEquals("\uD800\uDC00", StringEscapeUtils.escapeCsv("\uD800\uDC00")); [EOL]         assertEquals("\uD834\uDD1E", StringEscapeUtils.escapeCsv("\uD834\uDD1E")); [EOL]         assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeCsv("\uDBFF\uDFFD")); [EOL]         assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeHtml3("\uDBFF\uDFFD")); [EOL]         assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeHtml4("\uDBFF\uDFFD")); [EOL]         assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeXml("\uDBFF\uDFFD")); [EOL]     } [EOL]      [EOL]     /** [EOL]      * Tests LANG-858. [EOL]      *  [EOL]      * @throws Exception [EOL]      */ [EOL]
@Test [EOL]     public void testEscapeSurrogatePairs() throws Exception { [EOL]         assertEquals("\uD83D\uDE30", StringEscapeUtils.escapeCsv("\uD83D\uDE30")); [EOL]         // Examples from https://en.wikipedia.org/wiki/UTF-16 [EOL]         assertEquals("\uD800\uDC00", StringEscapeUtils.escapeCsv("\uD800\uDC00")); [EOL]         assertEquals("\uD834\uDD1E", StringEscapeUtils.escapeCsv("\uD834\uDD1E")); [EOL]         assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeCsv("\uDBFF\uDFFD")); [EOL]         assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeHtml3("\uDBFF\uDFFD")); [EOL]         assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeHtml4("\uDBFF\uDFFD")); [EOL]         assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeXml("\uDBFF\uDFFD")); [EOL]     } [EOL]      [EOL]     /** [EOL]      * Tests LANG-858. [EOL]      *  [EOL]      * @throws Exception [EOL]      */ [EOL]
@Test [EOL]     public void testEscapeSurrogatePairs() throws Exception { [EOL]         assertEquals("\uD83D\uDE30", StringEscapeUtils.escapeCsv("\uD83D\uDE30")); [EOL]         // Examples from https://en.wikipedia.org/wiki/UTF-16 [EOL]         assertEquals("\uD800\uDC00", StringEscapeUtils.escapeCsv("\uD800\uDC00")); [EOL]         assertEquals("\uD834\uDD1E", StringEscapeUtils.escapeCsv("\uD834\uDD1E")); [EOL]         assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeCsv("\uDBFF\uDFFD")); [EOL]         assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeHtml3("\uDBFF\uDFFD")); [EOL]         assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeHtml4("\uDBFF\uDFFD")); [EOL]         assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeXml("\uDBFF\uDFFD")); [EOL]     } [EOL]      [EOL]     /** [EOL]      * Tests LANG-858. [EOL]      *  [EOL]      * @throws Exception [EOL]      */ [EOL]
@Test [EOL]     public void testAbove() { [EOL]         final UnicodeEscaper ue = UnicodeEscaper.above('F'); [EOL]  [EOL]         final String input = "ADFGZ"; [EOL]         final String result = ue.translate(input); [EOL]         assertEquals("Failed to escape Unicode characters via the above method", "ADF\\u0047\\u005A", result); [EOL]     } [EOL] } [EOL]
@Test [EOL]     public void testBetween() { [EOL]         final UnicodeEscaper ue = UnicodeEscaper.between('F', 'L'); [EOL]  [EOL]         final String input = "ADFGZ"; [EOL]         final String result = ue.translate(input); [EOL]         assertEquals("Failed to escape Unicode characters via the between method", "AD\\u0046\\u0047Z", result); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testAbove() { [EOL]         final UnicodeEscaper ue = UnicodeEscaper.above('F'); [EOL]  [EOL]         final String input = "ADFGZ"; [EOL]         final String result = ue.translate(input); [EOL]         assertEquals("Failed to escape Unicode characters via the above method", "ADF\\u0047\\u005A", result); [EOL]     } [EOL] } [EOL]
@Test [EOL]     public void testAbove() { [EOL]         final UnicodeEscaper ue = UnicodeEscaper.above('F'); [EOL]  [EOL]         final String input = "ADFGZ"; [EOL]         final String result = ue.translate(input); [EOL]         assertEquals("Failed to escape Unicode characters via the above method", "ADF\\u0047\\u005A", result); [EOL]     } [EOL] } [EOL]
@Test [EOL]     public void testAbove() { [EOL]         final UnicodeEscaper ue = UnicodeEscaper.above('F'); [EOL]  [EOL]         final String input = "ADFGZ"; [EOL]         final String result = ue.translate(input); [EOL]         assertEquals("Failed to escape Unicode characters via the above method", "ADF\\u0047\\u005A", result); [EOL]     } [EOL] } [EOL]
@Test [EOL]     public void testAbove() { [EOL]         final UnicodeEscaper ue = UnicodeEscaper.above('F'); [EOL]  [EOL]         final String input = "ADFGZ"; [EOL]         final String result = ue.translate(input); [EOL]         assertEquals("Failed to escape Unicode characters via the above method", "ADF\\u0047\\u005A", result); [EOL]     } [EOL] } [EOL]
@Test [EOL]     public void testAbove() { [EOL]         final UnicodeEscaper ue = UnicodeEscaper.above('F'); [EOL]  [EOL]         final String input = "ADFGZ"; [EOL]         final String result = ue.translate(input); [EOL]         assertEquals("Failed to escape Unicode characters via the above method", "ADF\\u0047\\u005A", result); [EOL]     } [EOL] } [EOL]
@Test [EOL]     public void testAbove() { [EOL]         final UnicodeEscaper ue = UnicodeEscaper.above('F'); [EOL]  [EOL]         final String input = "ADFGZ"; [EOL]         final String result = ue.translate(input); [EOL]         assertEquals("Failed to escape Unicode characters via the above method", "ADF\\u0047\\u005A", result); [EOL]     } [EOL] } [EOL]
@Test [EOL]     public void testAbove() { [EOL]         final UnicodeEscaper ue = UnicodeEscaper.above('F'); [EOL]  [EOL]         final String input = "ADFGZ"; [EOL]         final String result = ue.translate(input); [EOL]         assertEquals("Failed to escape Unicode characters via the above method", "ADF\\u0047\\u005A", result); [EOL]     } [EOL] } [EOL]
@Test [EOL]     public void testAbove() { [EOL]         final UnicodeEscaper ue = UnicodeEscaper.above('F'); [EOL]  [EOL]         final String input = "ADFGZ"; [EOL]         final String result = ue.translate(input); [EOL]         assertEquals("Failed to escape Unicode characters via the above method", "ADF\\u0047\\u005A", result); [EOL]     } [EOL] } [EOL]
@Test [EOL]     public void testIdentityToStringAppendable() { [EOL]         final Integer i = Integer.valueOf(121); [EOL]         final String expected = "java.lang.Integer@" + Integer.toHexString(System.identityHashCode(i)); [EOL]  [EOL]         try { [EOL]             final Appendable appendable = new StringBuilder(); [EOL]             ObjectUtils.identityToString(appendable, i); [EOL]             assertEquals(expected, appendable.toString()); [EOL]         } catch(IOException ex) { [EOL]             fail("IOException unexpected"); [EOL]         } [EOL]          [EOL]         try { [EOL]             ObjectUtils.identityToString((Appendable)null, "tmp"); [EOL]             fail("NullPointerException expected"); [EOL]         } catch(final NullPointerException npe) { [EOL]         } catch (IOException ex) { [EOL]         } [EOL]          [EOL]         try { [EOL]             ObjectUtils.identityToString((Appendable)(new StringBuilder()), null); [EOL]             fail("NullPointerException expected"); [EOL]         } catch(final NullPointerException npe) {
@Test [EOL]     public void testIdentityToStringStringBuilder() { [EOL]         assertEquals(null, ObjectUtils.identityToString(null)); [EOL]         assertEquals( [EOL]             "java.lang.String@" + Integer.toHexString(System.identityHashCode(FOO)), [EOL]             ObjectUtils.identityToString(FOO)); [EOL]         final Integer i = Integer.valueOf(90); [EOL]         final String expected = "java.lang.Integer@" + Integer.toHexString(System.identityHashCode(i)); [EOL]          [EOL]         assertEquals(expected, ObjectUtils.identityToString(i)); [EOL]          [EOL]         final StringBuilder builder = new StringBuilder(); [EOL]         ObjectUtils.identityToString(builder, i); [EOL]         assertEquals(expected, builder.toString()); [EOL]  [EOL]         try { [EOL]             ObjectUtils.identityToString((StringBuilder)null, "tmp"); [EOL]             fail("NullPointerException expected"); [EOL]         } catch(final NullPointerException npe) { [EOL]         } [EOL]          [EOL]         try { [EOL]             ObjectUtils.identityToString(new StringBuilder(), null); [EOL
@Test [EOL]     public void testMin() { [EOL]         final Calendar calendar = Calendar.getInstance(); [EOL]         final Date nonNullComparable1 = calendar.getTime(); [EOL]         final Date nonNullComparable2 = calendar.getTime(); [EOL]         final String[] nullAray = null; [EOL]          [EOL]         calendar.set( Calendar.YEAR, calendar.get( Calendar.YEAR ) -1 ); [EOL]         final Date minComparable = calendar.getTime(); [EOL]          [EOL]         assertNotSame( nonNullComparable1, nonNullComparable2 ); [EOL]          [EOL]         assertNull(ObjectUtils.min( (String) null ) ); [EOL]         assertNull(ObjectUtils.min( nullAray ) ); [EOL]         assertSame( nonNullComparable1, ObjectUtils.min( null, nonNullComparable1 ) ); [EOL]         assertSame( nonNullComparable1, ObjectUtils.min( nonNullComparable1, null ) ); [EOL]         assertSame( nonNullComparable1, ObjectUtils.min( null, nonNullComparable1, null ) ); [EOL]         assertSame( nonNullComparable1, ObjectUtils.min( nonNullComparable1, nonNullComparable2 ) ); [EOL]         assertSame( nonNullComparable2, ObjectUtils.min( nonNullComparable2, nonNullComparable1 ) ); [EOL]         assertSame( minComparable, ObjectUtils.min
@Test [EOL]     public void testMax() { [EOL]         final Calendar calendar = Calendar.getInstance(); [EOL]         final Date nonNullComparable1 = calendar.getTime(); [EOL]         final Date nonNullComparable2 = calendar.getTime(); [EOL]         final String[] nullAray = null; [EOL]          [EOL]         calendar.set( Calendar.YEAR, calendar.get( Calendar.YEAR ) -1 ); [EOL]         final Date minComparable = calendar.getTime(); [EOL]          [EOL]         assertNotSame( nonNullComparable1, nonNullComparable2 ); [EOL]          [EOL]         assertNull(ObjectUtils.max( (String) null ) ); [EOL]         assertNull(ObjectUtils.max( nullAray ) ); [EOL]         assertSame( nonNullComparable1, ObjectUtils.max( null, nonNullComparable1 ) ); [EOL]         assertSame( nonNullComparable1, ObjectUtils.max( nonNullComparable1, null ) ); [EOL]         assertSame( nonNullComparable1, ObjectUtils.max( null, nonNullComparable1, null ) ); [EOL]         assertSame( nonNullComparable1, ObjectUtils.max( nonNullComparable1, nonNullComparable2 ) ); [EOL]         assertSame( nonNullComparable2, ObjectUtils.max( nonNullComparable2, nonNullComparable1 ) ); [EOL]         assertSame( nonNullComparable1, ObjectUtils
@Test(expected = NoSuchMethodException.class) [EOL]     public void testPossibleCloneOfUncloneable() throws Throwable { [EOL]         final UncloneableString string = new UncloneableString("apache"); [EOL]         try { [EOL]             ObjectUtils.cloneIfPossible(string); [EOL]             fail("Thrown " + CloneFailedException.class.getName() + " expected"); [EOL]         } catch (final CloneFailedException e) { [EOL]             throw e.getCause(); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test(expected = NoSuchMethodException.class) [EOL]     public void testPossibleCloneOfUncloneable() throws Throwable { [EOL]         final UncloneableString string = new UncloneableString("apache"); [EOL]         try { [EOL]             ObjectUtils.cloneIfPossible(string); [EOL]             fail("Thrown " + CloneFailedException.class.getName() + " expected"); [EOL]         } catch (final CloneFailedException e) { [EOL]             throw e.getCause(); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test(expected = NoSuchMethodException.class) [EOL]     public void testPossibleCloneOfUncloneable() throws Throwable { [EOL]         final UncloneableString string = new UncloneableString("apache"); [EOL]         try { [EOL]             ObjectUtils.cloneIfPossible(string); [EOL]             fail("Thrown " + CloneFailedException.class.getName() + " expected"); [EOL]         } catch (final CloneFailedException e) { [EOL]             throw e.getCause(); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test(expected = NoSuchMethodException.class) [EOL]     public void testPossibleCloneOfUncloneable() throws Throwable { [EOL]         final UncloneableString string = new UncloneableString("apache"); [EOL]         try { [EOL]             ObjectUtils.cloneIfPossible(string); [EOL]             fail("Thrown " + CloneFailedException.class.getName() + " expected"); [EOL]         } catch (final CloneFailedException e) { [EOL]             throw e.getCause(); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test(expected = NoSuchMethodException.class) [EOL]     public void testPossibleCloneOfUncloneable() throws Throwable { [EOL]         final UncloneableString string = new UncloneableString("apache"); [EOL]         try { [EOL]             ObjectUtils.cloneIfPossible(string); [EOL]             fail("Thrown " + CloneFailedException.class.getName() + " expected"); [EOL]         } catch (final CloneFailedException e) { [EOL]             throw e.getCause(); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test(expected = NoSuchMethodException.class) [EOL]     public void testPossibleCloneOfUncloneable() throws Throwable { [EOL]         final UncloneableString string = new UncloneableString("apache"); [EOL]         try { [EOL]             ObjectUtils.cloneIfPossible(string); [EOL]             fail("Thrown " + CloneFailedException.class.getName() + " expected"); [EOL]         } catch (final CloneFailedException e) { [EOL]             throw e.getCause(); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test(expected = NoSuchMethodException.class) [EOL]     public void testPossibleCloneOfUncloneable() throws Throwable { [EOL]         final UncloneableString string = new UncloneableString("apache"); [EOL]         try { [EOL]             ObjectUtils.cloneIfPossible(string); [EOL]             fail("Thrown " + CloneFailedException.class.getName() + " expected"); [EOL]         } catch (final CloneFailedException e) { [EOL]             throw e.getCause(); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test(expected = NoSuchMethodException.class) [EOL]     public void testPossibleCloneOfUncloneable() throws Throwable { [EOL]         final UncloneableString string = new UncloneableString("apache"); [EOL]         try { [EOL]             ObjectUtils.cloneIfPossible(string); [EOL]             fail("Thrown " + CloneFailedException.class.getName() + " expected"); [EOL]         } catch (final CloneFailedException e) { [EOL]             throw e.getCause(); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReplaceEmptyKeys() { [EOL]         doTestReplace("The ${} jumps over the lazy dog.", "The ${} jumps over the ${target}.", true); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests replace creates output same as input. [EOL]      */ [EOL]
@Test [EOL]     public void testReplaceNull() { [EOL]         doTestNoReplace(null); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests replace with null. [EOL]      */ [EOL]
@Test [EOL]     public void testPrintRootCauseStackTrace_ThrowableWriter() throws Exception { [EOL]         StringWriter writer = new StringWriter(1024); [EOL]         ExceptionUtils.printRootCauseStackTrace(null, (PrintWriter) null); [EOL]         ExceptionUtils.printRootCauseStackTrace(null, new PrintWriter(writer)); [EOL]         assertEquals(0, writer.getBuffer().length()); [EOL]          [EOL]         writer = new StringWriter(1024); [EOL]         try { [EOL]             ExceptionUtils.printRootCauseStackTrace(withCause, (PrintWriter) null); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) { [EOL]         } [EOL]          [EOL]         writer = new StringWriter(1024); [EOL]         final Throwable withCause = createExceptionWithCause(); [EOL]         ExceptionUtils.printRootCauseStackTrace(withCause, new PrintWriter(writer)); [EOL]         String stackTrace = writer.toString(); [EOL]         assertTrue(stackTrace.indexOf(ExceptionUtils.WRAPPED_MARKER) != -1); [EOL]          [EOL]         writer = new StringWriter(1024); [EOL]         ExceptionUtils.printRootCauseStackTrace(withoutCause, new PrintWriter(writer)); [EOL]        
@Test [EOL]     public void testPrintRootCauseStackTrace_ThrowableWriter() throws Exception { [EOL]         StringWriter writer = new StringWriter(1024); [EOL]         ExceptionUtils.printRootCauseStackTrace(null, (PrintWriter) null); [EOL]         ExceptionUtils.printRootCauseStackTrace(null, new PrintWriter(writer)); [EOL]         assertEquals(0, writer.getBuffer().length()); [EOL]          [EOL]         writer = new StringWriter(1024); [EOL]         try { [EOL]             ExceptionUtils.printRootCauseStackTrace(withCause, (PrintWriter) null); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) { [EOL]         } [EOL]          [EOL]         writer = new StringWriter(1024); [EOL]         final Throwable withCause = createExceptionWithCause(); [EOL]         ExceptionUtils.printRootCauseStackTrace(withCause, new PrintWriter(writer)); [EOL]         String stackTrace = writer.toString(); [EOL]         assertTrue(stackTrace.indexOf(ExceptionUtils.WRAPPED_MARKER) != -1); [EOL]          [EOL]         writer = new StringWriter(1024); [EOL]         ExceptionUtils.printRootCauseStackTrace(withoutCause, new PrintWriter(writer)); [EOL]        
@Test [EOL]     public void testPrintRootCauseStackTrace_ThrowableWriter() throws Exception { [EOL]         StringWriter writer = new StringWriter(1024); [EOL]         ExceptionUtils.printRootCauseStackTrace(null, (PrintWriter) null); [EOL]         ExceptionUtils.printRootCauseStackTrace(null, new PrintWriter(writer)); [EOL]         assertEquals(0, writer.getBuffer().length()); [EOL]          [EOL]         writer = new StringWriter(1024); [EOL]         try { [EOL]             ExceptionUtils.printRootCauseStackTrace(withCause, (PrintWriter) null); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) { [EOL]         } [EOL]          [EOL]         writer = new StringWriter(1024); [EOL]         final Throwable withCause = createExceptionWithCause(); [EOL]         ExceptionUtils.printRootCauseStackTrace(withCause, new PrintWriter(writer)); [EOL]         String stackTrace = writer.toString(); [EOL]         assertTrue(stackTrace.indexOf(ExceptionUtils.WRAPPED_MARKER) != -1); [EOL]          [EOL]         writer = new StringWriter(1024); [EOL]         ExceptionUtils.printRootCauseStackTrace(withoutCause, new PrintWriter(writer)); [EOL]        
@Test [EOL]     public void testPrintRootCauseStackTrace_ThrowableWriter() throws Exception { [EOL]         StringWriter writer = new StringWriter(1024); [EOL]         ExceptionUtils.printRootCauseStackTrace(null, (PrintWriter) null); [EOL]         ExceptionUtils.printRootCauseStackTrace(null, new PrintWriter(writer)); [EOL]         assertEquals(0, writer.getBuffer().length()); [EOL]          [EOL]         writer = new StringWriter(1024); [EOL]         try { [EOL]             ExceptionUtils.printRootCauseStackTrace(withCause, (PrintWriter) null); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) { [EOL]         } [EOL]          [EOL]         writer = new StringWriter(1024); [EOL]         final Throwable withCause = createExceptionWithCause(); [EOL]         ExceptionUtils.printRootCauseStackTrace(withCause, new PrintWriter(writer)); [EOL]         String stackTrace = writer.toString(); [EOL]         assertTrue(stackTrace.indexOf(ExceptionUtils.WRAPPED_MARKER) != -1); [EOL]          [EOL]         writer = new StringWriter(1024); [EOL]         ExceptionUtils.printRootCauseStackTrace(withoutCause, new PrintWriter(writer)); [EOL]        
@Test [EOL]     public void testEscapeSurrogatePairs() throws Exception { [EOL]         assertEquals("\uD83D\uDE30", StringEscapeUtils.escapeCsv("\uD83D\uDE30")); [EOL]         // Examples from https://en.wikipedia.org/wiki/UTF-16 [EOL]         assertEquals("\uD800\uDC00", StringEscapeUtils.escapeCsv("\uD800\uDC00")); [EOL]         assertEquals("\uD834\uDD1E", StringEscapeUtils.escapeCsv("\uD834\uDD1E")); [EOL]         assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeCsv("\uDBFF\uDFFD")); [EOL]         assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeHtml3("\uDBFF\uDFFD")); [EOL]         assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeHtml4("\uDBFF\uDFFD")); [EOL]         assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeXml("\uDBFF\uDFFD")); [EOL]     } [EOL]      [EOL]     /** [EOL]      * Tests LANG-858. [EOL]      *  [EOL]      * @throws Exception [EOL]      */ [EOL]
@Test [EOL]     public void testEscapeSurrogatePairs() throws Exception { [EOL]         assertEquals("\uD83D\uDE30", StringEscapeUtils.escapeCsv("\uD83D\uDE30")); [EOL]         // Examples from https://en.wikipedia.org/wiki/UTF-16 [EOL]         assertEquals("\uD800\uDC00", StringEscapeUtils.escapeCsv("\uD800\uDC00")); [EOL]         assertEquals("\uD834\uDD1E", StringEscapeUtils.escapeCsv("\uD834\uDD1E")); [EOL]         assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeCsv("\uDBFF\uDFFD")); [EOL]         assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeHtml3("\uDBFF\uDFFD")); [EOL]         assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeHtml4("\uDBFF\uDFFD")); [EOL]         assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeXml("\uDBFF\uDFFD")); [EOL]     } [EOL]      [EOL]     /** [EOL]      * Tests LANG-858. [EOL]      *  [EOL]      * @throws Exception [EOL]      */ [EOL]
@Test [EOL]     public void testEscapeSurrogatePairs() throws Exception { [EOL]         assertEquals("\uD83D\uDE30", StringEscapeUtils.escapeCsv("\uD83D\uDE30")); [EOL]         // Examples from https://en.wikipedia.org/wiki/UTF-16 [EOL]         assertEquals("\uD800\uDC00", StringEscapeUtils.escapeCsv("\uD800\uDC00")); [EOL]         assertEquals("\uD834\uDD1E", StringEscapeUtils.escapeCsv("\uD834\uDD1E")); [EOL]         assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeCsv("\uDBFF\uDFFD")); [EOL]         assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeHtml3("\uDBFF\uDFFD")); [EOL]         assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeHtml4("\uDBFF\uDFFD")); [EOL]         assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeXml("\uDBFF\uDFFD")); [EOL]     } [EOL]      [EOL]     /** [EOL]      * Tests LANG-858. [EOL]      *  [EOL]      * @throws Exception [EOL]      */ [EOL]
@Test [EOL]     public void test_changeDefault_Locale_DateInstance() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             final FastDateFormat format1 = FastDateFormat.getDateInstance(FastDateFormat.FULL, Locale.GERMANY); [EOL]             final FastDateFormat format2 = FastDateFormat.getDateInstance(FastDateFormat.FULL); [EOL]             Locale.setDefault(Locale.GERMANY); [EOL]             final FastDateFormat format3 = FastDateFormat.getDateInstance(FastDateFormat.FULL); [EOL]  [EOL]             assertSame(Locale.GERMANY, format1.getLocale()); [EOL]             assertSame(Locale.US, format2.getLocale()); [EOL]             assertSame(Locale.GERMANY, format3.getLocale()); [EOL]             assertTrue(format1 != format2); // -- junit 3.8 version -- assertFalse(format1 == format2); [EOL]             assertTrue(format2 != format3); [EOL]  [EOL]         } finally { [EOL]             Locale.setDefault(realDefaultLocale); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void test_changeDefault_Locale_DateInstance() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             final FastDateFormat format1 = FastDateFormat.getDateInstance(FastDateFormat.FULL, Locale.GERMANY); [EOL]             final FastDateFormat format2 = FastDateFormat.getDateInstance(FastDateFormat.FULL); [EOL]             Locale.setDefault(Locale.GERMANY); [EOL]             final FastDateFormat format3 = FastDateFormat.getDateInstance(FastDateFormat.FULL); [EOL]  [EOL]             assertSame(Locale.GERMANY, format1.getLocale()); [EOL]             assertSame(Locale.US, format2.getLocale()); [EOL]             assertSame(Locale.GERMANY, format3.getLocale()); [EOL]             assertTrue(format1 != format2); // -- junit 3.8 version -- assertFalse(format1 == format2); [EOL]             assertTrue(format2 != format3); [EOL]  [EOL]         } finally { [EOL]             Locale.setDefault(realDefaultLocale); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DatePrinter printer1= getInstance(YYYY_MM_DD); [EOL]         final DatePrinter printer2= getInstance(YYYY_MM_DD); [EOL]  [EOL]         assertEquals(printer1, printer2); [EOL]         assertEquals(printer1.hashCode(), printer2.hashCode());         [EOL]  [EOL]         assertFalse(printer1.equals(new Object())); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DatePrinter printer1= getInstance(YYYY_MM_DD); [EOL]         final DatePrinter printer2= getInstance(YYYY_MM_DD); [EOL]  [EOL]         assertEquals(printer1, printer2); [EOL]         assertEquals(printer1.hashCode(), printer2.hashCode());         [EOL]  [EOL]         assertFalse(printer1.equals(new Object())); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DatePrinter printer1= getInstance(YYYY_MM_DD); [EOL]         final DatePrinter printer2= getInstance(YYYY_MM_DD); [EOL]  [EOL]         assertEquals(printer1, printer2); [EOL]         assertEquals(printer1.hashCode(), printer2.hashCode());         [EOL]  [EOL]         assertFalse(printer1.equals(new Object())); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DatePrinter printer1= getInstance(YYYY_MM_DD); [EOL]         final DatePrinter printer2= getInstance(YYYY_MM_DD); [EOL]  [EOL]         assertEquals(printer1, printer2); [EOL]         assertEquals(printer1.hashCode(), printer2.hashCode());         [EOL]  [EOL]         assertFalse(printer1.equals(new Object())); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DatePrinter printer1= getInstance(YYYY_MM_DD); [EOL]         final DatePrinter printer2= getInstance(YYYY_MM_DD); [EOL]  [EOL]         assertEquals(printer1, printer2); [EOL]         assertEquals(printer1.hashCode(), printer2.hashCode());         [EOL]  [EOL]         assertFalse(printer1.equals(new Object())); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DatePrinter printer1= getInstance(YYYY_MM_DD); [EOL]         final DatePrinter printer2= getInstance(YYYY_MM_DD); [EOL]  [EOL]         assertEquals(printer1, printer2); [EOL]         assertEquals(printer1.hashCode(), printer2.hashCode());         [EOL]  [EOL]         assertFalse(printer1.equals(new Object())); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void test_changeDefault_Locale_DateInstance() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             final FastDateFormat format1 = FastDateFormat.getDateInstance(FastDateFormat.FULL, Locale.GERMANY); [EOL]             final FastDateFormat format2 = FastDateFormat.getDateInstance(FastDateFormat.FULL); [EOL]             Locale.setDefault(Locale.GERMANY); [EOL]             final FastDateFormat format3 = FastDateFormat.getDateInstance(FastDateFormat.FULL); [EOL]  [EOL]             assertSame(Locale.GERMANY, format1.getLocale()); [EOL]             assertSame(Locale.US, format2.getLocale()); [EOL]             assertSame(Locale.GERMANY, format3.getLocale()); [EOL]             assertTrue(format1 != format2); // -- junit 3.8 version -- assertFalse(format1 == format2); [EOL]             assertTrue(format2 != format3); [EOL]  [EOL]         } finally { [EOL]             Locale.setDefault(realDefaultLocale); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testClone() throws Exception { [EOL]         final Object test = SerializationUtils.clone(iMap); [EOL]         assertNotNull(test); [EOL]         assertTrue(test instanceof HashMap<?,?>); [EOL]         assertTrue(test != iMap); [EOL]         final HashMap<?, ?> testMap = (HashMap<?, ?>) test; [EOL]         assertEquals(iString, testMap.get("FOO")); [EOL]         assertTrue(iString != testMap.get("FOO")); [EOL]         assertEquals(iInteger, testMap.get("BAR")); [EOL]         assertTrue(iInteger != testMap.get("BAR")); [EOL]         assertEquals(iMap, testMap); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testClone() throws Exception { [EOL]         final Object test = SerializationUtils.clone(iMap); [EOL]         assertNotNull(test); [EOL]         assertTrue(test instanceof HashMap<?,?>); [EOL]         assertTrue(test != iMap); [EOL]         final HashMap<?, ?> testMap = (HashMap<?, ?>) test; [EOL]         assertEquals(iString, testMap.get("FOO")); [EOL]         assertTrue(iString != testMap.get("FOO")); [EOL]         assertEquals(iInteger, testMap.get("BAR")); [EOL]         assertTrue(iInteger != testMap.get("BAR")); [EOL]         assertEquals(iMap, testMap); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testClone() throws Exception { [EOL]         final Object test = SerializationUtils.clone(iMap); [EOL]         assertNotNull(test); [EOL]         assertTrue(test instanceof HashMap<?,?>); [EOL]         assertTrue(test != iMap); [EOL]         final HashMap<?, ?> testMap = (HashMap<?, ?>) test; [EOL]         assertEquals(iString, testMap.get("FOO")); [EOL]         assertTrue(iString != testMap.get("FOO")); [EOL]         assertEquals(iInteger, testMap.get("BAR")); [EOL]         assertTrue(iInteger != testMap.get("BAR")); [EOL]         assertEquals(iMap, testMap); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLocales_ShortNoEra_AD() throws Exception { [EOL]         testLocales(SHORT_FORMAT_NOERA, false); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testToString() { [EOL]         assertEquals("0", CharUtils.toString(null)); [EOL]         assertEquals("", CharUtils.toString(null)); [EOL]         assertEquals("", CharUtils.toString(null)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLocales_ShortNoEra_AD() throws Exception { [EOL]         testLocales(SHORT_FORMAT_NOERA, false); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLocales_ShortNoEra_AD() throws Exception { [EOL]         testLocales(SHORT_FORMAT_NOERA, false); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLocales_ShortNoEra_AD() throws Exception { [EOL]         testLocales(SHORT_FORMAT_NOERA, false); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLocales_ShortNoEra_AD() throws Exception { [EOL]         testLocales(SHORT_FORMAT_NOERA, false); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLocales_ShortNoEra_AD() throws Exception { [EOL]         testLocales(SHORT_FORMAT_NOERA, false); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLocales_ShortNoEra_AD() throws Exception { [EOL]         testLocales(SHORT_FORMAT_NOERA, false); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLocales_ShortNoEra_AD() throws Exception { [EOL]         testLocales(SHORT_FORMAT_NOERA, false); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLocales_ShortNoEra_AD() throws Exception { [EOL]         testLocales(SHORT_FORMAT_NOERA, false); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLocales_ShortNoEra_AD() throws Exception { [EOL]         testLocales(SHORT_FORMAT_NOERA, false); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLocales_ShortNoEra_AD() throws Exception { [EOL]         testLocales(SHORT_FORMAT_NOERA, false); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLocales_ShortNoEra_AD() throws Exception { [EOL]         testLocales(SHORT_FORMAT_NOERA, false); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLocales_ShortNoEra_AD() throws Exception { [EOL]         testLocales(SHORT_FORMAT_NOERA, false); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLocales_ShortNoEra_AD() throws Exception { [EOL]         testLocales(SHORT_FORMAT_NOERA, false); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLocales_ShortNoEra_AD() throws Exception { [EOL]         testLocales(SHORT_FORMAT_NOERA, false); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLocales_ShortNoEra_AD() throws Exception { [EOL]         testLocales(SHORT_FORMAT_NOERA, false); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLocales_ShortNoEra_AD() throws Exception { [EOL]         testLocales(SHORT_FORMAT_NOERA, false); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNullExceptionPassing() { [EOL]         exceptionContext = new ContextedRuntimeException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE), null) [EOL]         .addContextValue("test1", null) [EOL]         .addContextValue("test2", "some value") [EOL]         .addContextValue("test Date", new Date()) [EOL]         .addContextValue("test Nbr", Integer.valueOf(5)) [EOL]         .addContextValue("test Poorly written obj", new ObjectWithFaultyToString()); [EOL]          [EOL]         final String message = exceptionContext.getMessage(); [EOL]         assertTrue(message != null); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLessThanFour() { [EOL]         final UnicodeUnescaper uu = new UnicodeUnescaper(); [EOL]  [EOL]         final String input = "\\0047\\u006"; [EOL]         try { [EOL]             uu.translate(input); [EOL]             fail("A lack of digits in a Unicode escape sequence failed to throw an exception"); [EOL]         } catch(final IllegalArgumentException iae) { [EOL]             // expected [EOL]         } [EOL]     } [EOL] } [EOL]
@Test [EOL]     public void testLessThanFour() { [EOL]         final UnicodeUnescaper uu = new UnicodeUnescaper(); [EOL]  [EOL]         final String input = "\\0047\\u006"; [EOL]         try { [EOL]             uu.translate(input); [EOL]             fail("A lack of digits in a Unicode escape sequence failed to throw an exception"); [EOL]         } catch(final IllegalArgumentException iae) { [EOL]             // expected [EOL]         } [EOL]     } [EOL] } [EOL]
@Test [EOL]     public void testLessThanFour() { [EOL]         final UnicodeUnescaper uu = new UnicodeUnescaper(); [EOL]  [EOL]         final String input = "\\0047\\u006"; [EOL]         try { [EOL]             uu.translate(input); [EOL]             fail("A lack of digits in a Unicode escape sequence failed to throw an exception"); [EOL]         } catch(final IllegalArgumentException iae) { [EOL]             // expected [EOL]         } [EOL]     } [EOL] } [EOL]
@Test [EOL]     public void testLessThanFour() { [EOL]         final UnicodeUnescaper uu = new UnicodeUnescaper(); [EOL]  [EOL]         final String input = "\\0047\\u006"; [EOL]         try { [EOL]             uu.translate(input); [EOL]             fail("A lack of digits in a Unicode escape sequence failed to throw an exception"); [EOL]         } catch(final IllegalArgumentException iae) { [EOL]             // expected [EOL]         } [EOL]     } [EOL] } [EOL]
@Test [EOL]     public void testLessThanFour() { [EOL]         final UnicodeUnescaper uu = new UnicodeUnescaper(); [EOL]  [EOL]         final String input = "\\0047\\u006"; [EOL]         try { [EOL]             uu.translate(input); [EOL]             fail("A lack of digits in a Unicode escape sequence failed to throw an exception"); [EOL]         } catch(final IllegalArgumentException iae) { [EOL]             // expected [EOL]         } [EOL]     } [EOL] } [EOL]
@Test [EOL]     public void testLessThanFour() { [EOL]         final UnicodeUnescaper uu = new UnicodeUnescaper(); [EOL]  [EOL]         final String input = "\\0047\\u006"; [EOL]         try { [EOL]             uu.translate(input); [EOL]             fail("A lack of digits in a Unicode escape sequence failed to throw an exception"); [EOL]         } catch(final IllegalArgumentException iae) { [EOL]             // expected [EOL]         } [EOL]     } [EOL] } [EOL]
@Test [EOL]     public void testLessThanFour() { [EOL]         final UnicodeUnescaper uu = new UnicodeUnescaper(); [EOL]  [EOL]         final String input = "\\0047\\u006"; [EOL]         try { [EOL]             uu.translate(input); [EOL]             fail("A lack of digits in a Unicode escape sequence failed to throw an exception"); [EOL]         } catch(final IllegalArgumentException iae) { [EOL]             // expected [EOL]         } [EOL]     } [EOL] } [EOL]
@Test [EOL]     public void testLessThanFour() { [EOL]         final UnicodeUnescaper uu = new UnicodeUnescaper(); [EOL]  [EOL]         final String input = "\\0047\\u006"; [EOL]         try { [EOL]             uu.translate(input); [EOL]             fail("A lack of digits in a Unicode escape sequence failed to throw an exception"); [EOL]         } catch(final IllegalArgumentException iae) { [EOL]             // expected [EOL]         } [EOL]     } [EOL] } [EOL]
@Test [EOL]     public void testCharArrayAsObject() { [EOL]         final char[] obj = new char[2]; [EOL]         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]         obj[0] = (char) 5; [EOL]         assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]         obj[1] = (char) 6; [EOL]         assertEquals((17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testCharArrayAsObject() { [EOL]         final char[] obj = new char[2]; [EOL]         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]         obj[0] = (char) 5; [EOL]         assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]         obj[1] = (char) 6; [EOL]         assertEquals((17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testCharArrayAsObject() { [EOL]         final char[] obj = new char[2]; [EOL]         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]         obj[0] = (char) 5; [EOL]         assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]         obj[1] = (char) 6; [EOL]         assertEquals((17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testCharArrayAsObject() { [EOL]         final char[] obj = new char[2]; [EOL]         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]         obj[0] = (char) 5; [EOL]         assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]         obj[1] = (char) 6; [EOL]         assertEquals((17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testCharArrayAsObject() { [EOL]         final char[] obj = new char[2]; [EOL]         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]         obj[0] = (char) 5; [EOL]         assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]         obj[1] = (char) 6; [EOL]         assertEquals((17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testCharArrayAsObject() { [EOL]         final char[] obj = new char[2]; [EOL]         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]         obj[0] = (char) 5; [EOL]         assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]         obj[1] = (char) 6; [EOL]         assertEquals((17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testCharArrayAsObject() { [EOL]         final char[] obj = new char[2]; [EOL]         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]         obj[0] = (char) 5; [EOL]         assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]         obj[1] = (char) 6; [EOL]         assertEquals((17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testCharArrayAsObject() { [EOL]         final char[] obj = new char[2]; [EOL]         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]         obj[0] = (char) 5; [EOL]         assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]         obj[1] = (char) 6; [EOL]         assertEquals((17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testCharArrayAsObject() { [EOL]         final char[] obj = new char[2]; [EOL]         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]         obj[0] = (char) 5; [EOL]         assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]         obj[1] = (char) 6; [EOL]         assertEquals((17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testCharArrayAsObject() { [EOL]         final char[] obj = new char[2]; [EOL]         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]         obj[0] = (char) 5; [EOL]         assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]         obj[1] = (char) 6; [EOL]         assertEquals((17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testCharArrayAsObject() { [EOL]         final char[] obj = new char[2]; [EOL]         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]         obj[0] = (char) 5; [EOL]         assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]         obj[1] = (char) 6; [EOL]         assertEquals((17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testCharArrayAsObject() { [EOL]         final char[] obj = new char[2]; [EOL]         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]         obj[0] = (char) 5; [EOL]         assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]         obj[1] = (char) 6; [EOL]         assertEquals((17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testBetween() { [EOL]         final OctalUnescaper oue = new OctalUnescaper();   //.between("1", "377"); [EOL]  [EOL]         String input = "\\45"; [EOL]         String result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\45", result); [EOL]  [EOL]         input = "\\377"; [EOL]         result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\377", result); [EOL]  [EOL]         input = "\\377 and"; [EOL]         result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\377 and", result); [EOL]  [EOL]         input = "\\378 and"; [EOL]         result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\378 and", result); [EOL]  [EOL]         input = "\\378"; [EOL]         result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\378", result); [EOL]  [EOL]         input = "\\1"; [EOL]         result = oue.
@Test [EOL]     public void testBetween() { [EOL]         final OctalUnescaper oue = new OctalUnescaper();   //.between("1", "377"); [EOL]  [EOL]         String input = "\\45"; [EOL]         String result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\45", result); [EOL]  [EOL]         input = "\\377"; [EOL]         result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\377", result); [EOL]  [EOL]         input = "\\377 and"; [EOL]         result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\377 and", result); [EOL]  [EOL]         input = "\\378 and"; [EOL]         result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\378 and", result); [EOL]  [EOL]         input = "\\378"; [EOL]         result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\378", result); [EOL]  [EOL]         input = "\\1"; [EOL]         result = oue.
@Test [EOL]     public void testBetween() { [EOL]         final OctalUnescaper oue = new OctalUnescaper();   //.between("1", "377"); [EOL]  [EOL]         String input = "\\45"; [EOL]         String result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\45", result); [EOL]  [EOL]         input = "\\377"; [EOL]         result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\377", result); [EOL]  [EOL]         input = "\\377 and"; [EOL]         result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\377 and", result); [EOL]  [EOL]         input = "\\378 and"; [EOL]         result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\378 and", result); [EOL]  [EOL]         input = "\\378"; [EOL]         result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\378", result); [EOL]  [EOL]         input = "\\1"; [EOL]         result = oue.
@Test [EOL]     public void testBetween() { [EOL]         final OctalUnescaper oue = new OctalUnescaper();   //.between("1", "377"); [EOL]  [EOL]         String input = "\\45"; [EOL]         String result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\45", result); [EOL]  [EOL]         input = "\\377"; [EOL]         result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\377", result); [EOL]  [EOL]         input = "\\377 and"; [EOL]         result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\377 and", result); [EOL]  [EOL]         input = "\\378 and"; [EOL]         result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\378 and", result); [EOL]  [EOL]         input = "\\378"; [EOL]         result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\378", result); [EOL]  [EOL]         input = "\\1"; [EOL]         result = oue.
@Test [EOL]     public void testBetween() { [EOL]         final OctalUnescaper oue = new OctalUnescaper();   //.between("1", "377"); [EOL]  [EOL]         String input = "\\45"; [EOL]         String result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\45", result); [EOL]  [EOL]         input = "\\377"; [EOL]         result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\377", result); [EOL]  [EOL]         input = "\\377 and"; [EOL]         result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\377 and", result); [EOL]  [EOL]         input = "\\378 and"; [EOL]         result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\378 and", result); [EOL]  [EOL]         input = "\\378"; [EOL]         result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\378", result); [EOL]  [EOL]         input = "\\1"; [EOL]         result = oue.
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testBetween() { [EOL]         final OctalUnescaper oue = new OctalUnescaper();   //.between("1", "377"); [EOL]  [EOL]         String input = "\\45"; [EOL]         String result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\45", result); [EOL]  [EOL]         input = "\\377"; [EOL]         result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\377", result); [EOL]  [EOL]         input = "\\377 and"; [EOL]         result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\377 and", result); [EOL]  [EOL]         input = "\\378 and"; [EOL]         result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\378 and", result); [EOL]  [EOL]         input = "\\378"; [EOL]         result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\378", result); [EOL]  [EOL]         input = "\\1"; [EOL]         result = oue.
@Test [EOL]     public void testBetween() { [EOL]         final OctalUnescaper oue = new OctalUnescaper();   //.between("1", "377"); [EOL]  [EOL]         String input = "\\45"; [EOL]         String result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\45", result); [EOL]  [EOL]         input = "\\377"; [EOL]         result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\377", result); [EOL]  [EOL]         input = "\\377 and"; [EOL]         result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\377 and", result); [EOL]  [EOL]         input = "\\378 and"; [EOL]         result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\378 and", result); [EOL]  [EOL]         input = "\\378"; [EOL]         result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\378", result); [EOL]  [EOL]         input = "\\1"; [EOL]         result = oue.
@Test [EOL]     public void testBetween() { [EOL]         final OctalUnescaper oue = new OctalUnescaper();   //.between("1", "377"); [EOL]  [EOL]         String input = "\\45"; [EOL]         String result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\45", result); [EOL]  [EOL]         input = "\\377"; [EOL]         result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\377", result); [EOL]  [EOL]         input = "\\377 and"; [EOL]         result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\377 and", result); [EOL]  [EOL]         input = "\\378 and"; [EOL]         result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\378 and", result); [EOL]  [EOL]         input = "\\378"; [EOL]         result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\378", result); [EOL]  [EOL]         input = "\\1"; [EOL]         result = oue.
@Test [EOL]     public void testEscapeJson() { [EOL]         assertEquals(null, StringEscapeUtils.escapeJson(null)); [EOL]         try { [EOL]             StringEscapeUtils.ESCAPE_JSON.translate(null, null); [EOL]             fail(); [EOL]         } catch (final IOException ex) { [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) { [EOL]         } [EOL]         try { [EOL]             StringEscapeUtils.ESCAPE_JSON.translate("", null); [EOL]             fail(); [EOL]         } catch (final IOException ex) { [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) { [EOL]         } [EOL]  [EOL]         assertEquals("He didn't say, \\\"stop!\\\"", StringEscapeUtils.escapeJson("He didn't say, \"stop!\"")); [EOL]  [EOL]         String expected = "\\\"foo\\\" isn't \\\"bar\\\". specials: \\b\\r\\n\\f\\t\\\\\\/"; [EOL]         String input ="\"foo\" isn't \"bar\". specials: \b\r\n\f\t\\/"; [EOL]  [EOL]         assertEquals
@Test [EOL]     public void testEscapeJson() { [EOL]         assertEquals(null, StringEscapeUtils.escapeJson(null)); [EOL]         try { [EOL]             StringEscapeUtils.ESCAPE_JSON.translate(null, null); [EOL]             fail(); [EOL]         } catch (final IOException ex) { [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) { [EOL]         } [EOL]         try { [EOL]             StringEscapeUtils.ESCAPE_JSON.translate("", null); [EOL]             fail(); [EOL]         } catch (final IOException ex) { [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) { [EOL]         } [EOL]  [EOL]         assertEquals("He didn't say, \\\"stop!\\\"", StringEscapeUtils.escapeJson("He didn't say, \"stop!\"")); [EOL]  [EOL]         String expected = "\\\"foo\\\" isn't \\\"bar\\\". specials: \\b\\r\\n\\f\\t\\\\\\/"; [EOL]         String input ="\"foo\" isn't \"bar\". specials: \b\r\n\f\t\\/"; [EOL]  [EOL]         assertEquals
@Test [EOL]     public void testToHexDigit() { [EOL]         assertEquals(null, StringUtils.hexDigit(null)); [EOL]         assertEquals("", StringUtils.hexDigit("")); [EOL]         assertEquals(" ")); [EOL]         } [EOL]     } [EOL]
@Test [EOL]     public void testToHex_String() { [EOL]         assertEquals(null, StringUtils.toString(null)); [EOL]         assertEquals("", StringUtils.toString(null)); [EOL]         assertEquals("A", StringUtils.toString(new StringBuilder("A")); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testFormatDurationWords() { [EOL]         String text = null; [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, true, false); [EOL]         assertEquals("50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, true, false); [EOL]         assertEquals("1 minute 5 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(120 * 1000, true, false); [EOL]         assertEquals("2 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(121 * 1000, true, false); [EOL]         assertEquals("2 minutes 1 second", text); [EOL]         text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false); [EOL]         assertEquals("1 hour 12 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false); [EOL]         assertEquals("1 day 0 hours 0 minutes 0 seconds", text); [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, true, true); [EOL]         assertEquals("50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, true, true); [EOL]         assertEquals("1 minute 5 seconds", text); [EOL]         text
@Test [EOL]     public void testFormatDurationWords() { [EOL]         String text = null; [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, true, false); [EOL]         assertEquals("50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, true, false); [EOL]         assertEquals("1 minute 5 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(120 * 1000, true, false); [EOL]         assertEquals("2 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(121 * 1000, true, false); [EOL]         assertEquals("2 minutes 1 second", text); [EOL]         text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false); [EOL]         assertEquals("1 hour 12 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false); [EOL]         assertEquals("1 day 0 hours 0 minutes 0 seconds", text); [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, true, true); [EOL]         assertEquals("50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, true, true); [EOL]         assertEquals("1 minute 5 seconds", text); [EOL]         text
@Test [EOL]     public void testFormatDurationWords() { [EOL]         String text = null; [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, true, false); [EOL]         assertEquals("50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, true, false); [EOL]         assertEquals("1 minute 5 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(120 * 1000, true, false); [EOL]         assertEquals("2 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(121 * 1000, true, false); [EOL]         assertEquals("2 minutes 1 second", text); [EOL]         text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false); [EOL]         assertEquals("1 hour 12 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false); [EOL]         assertEquals("1 day 0 hours 0 minutes 0 seconds", text); [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, true, true); [EOL]         assertEquals("50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, true, true); [EOL]         assertEquals("1 minute 5 seconds", text); [EOL]         text
@Test [EOL]     public void testFormatDurationWords() { [EOL]         String text = null; [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, true, false); [EOL]         assertEquals("50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, true, false); [EOL]         assertEquals("1 minute 5 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(120 * 1000, true, false); [EOL]         assertEquals("2 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(121 * 1000, true, false); [EOL]         assertEquals("2 minutes 1 second", text); [EOL]         text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false); [EOL]         assertEquals("1 hour 12 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false); [EOL]         assertEquals("1 day 0 hours 0 minutes 0 seconds", text); [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, true, true); [EOL]         assertEquals("50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, true, true); [EOL]         assertEquals("1 minute 5 seconds", text); [EOL]         text
@Test [EOL]     public void testFormatDurationWords() { [EOL]         String text = null; [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, true, false); [EOL]         assertEquals("50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, true, false); [EOL]         assertEquals("1 minute 5 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(120 * 1000, true, false); [EOL]         assertEquals("2 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(121 * 1000, true, false); [EOL]         assertEquals("2 minutes 1 second", text); [EOL]         text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false); [EOL]         assertEquals("1 hour 12 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false); [EOL]         assertEquals("1 day 0 hours 0 minutes 0 seconds", text); [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, true, true); [EOL]         assertEquals("50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, true, true); [EOL]         assertEquals("1 minute 5 seconds", text); [EOL]         text
@Test [EOL]     public void testFormatDurationWords() { [EOL]         String text = null; [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, true, false); [EOL]         assertEquals("50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, true, false); [EOL]         assertEquals("1 minute 5 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(120 * 1000, true, false); [EOL]         assertEquals("2 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(121 * 1000, true, false); [EOL]         assertEquals("2 minutes 1 second", text); [EOL]         text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false); [EOL]         assertEquals("1 hour 12 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false); [EOL]         assertEquals("1 day 0 hours 0 minutes 0 seconds", text); [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, true, true); [EOL]         assertEquals("50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, true, true); [EOL]         assertEquals("1 minute 5 seconds", text); [EOL]         text
@Test [EOL]     public void testFormatDurationWords() { [EOL]         String text = null; [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, true, false); [EOL]         assertEquals("50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, true, false); [EOL]         assertEquals("1 minute 5 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(120 * 1000, true, false); [EOL]         assertEquals("2 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(121 * 1000, true, false); [EOL]         assertEquals("2 minutes 1 second", text); [EOL]         text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false); [EOL]         assertEquals("1 hour 12 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false); [EOL]         assertEquals("1 day 0 hours 0 minutes 0 seconds", text); [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, true, true); [EOL]         assertEquals("50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, true, true); [EOL]         assertEquals("1 minute 5 seconds", text); [EOL]         text
@Test [EOL]     public void testFormatDurationWords() { [EOL]         String text = null; [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, true, false); [EOL]         assertEquals("50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, true, false); [EOL]         assertEquals("1 minute 5 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(120 * 1000, true, false); [EOL]         assertEquals("2 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(121 * 1000, true, false); [EOL]         assertEquals("2 minutes 1 second", text); [EOL]         text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false); [EOL]         assertEquals("1 hour 12 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false); [EOL]         assertEquals("1 day 0 hours 0 minutes 0 seconds", text); [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, true, true); [EOL]         assertEquals("50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, true, true); [EOL]         assertEquals("1 minute 5 seconds", text); [EOL]         text
@Test [EOL]     public void testFormatDurationWords() { [EOL]         String text = null; [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, true, false); [EOL]         assertEquals("50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, true, false); [EOL]         assertEquals("1 minute 5 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(120 * 1000, true, false); [EOL]         assertEquals("2 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(121 * 1000, true, false); [EOL]         assertEquals("2 minutes 1 second", text); [EOL]         text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false); [EOL]         assertEquals("1 hour 12 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false); [EOL]         assertEquals("1 day 0 hours 0 minutes 0 seconds", text); [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, true, true); [EOL]         assertEquals("50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, true, true); [EOL]         assertEquals("1 minute 5 seconds", text); [EOL]         text
@Test [EOL]     public void testFormatDurationWords() { [EOL]         String text = null; [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, true, false); [EOL]         assertEquals("50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, true, false); [EOL]         assertEquals("1 minute 5 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(120 * 1000, true, false); [EOL]         assertEquals("2 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(121 * 1000, true, false); [EOL]         assertEquals("2 minutes 1 second", text); [EOL]         text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false); [EOL]         assertEquals("1 hour 12 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false); [EOL]         assertEquals("1 day 0 hours 0 minutes 0 seconds", text); [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, true, true); [EOL]         assertEquals("50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, true, true); [EOL]         assertEquals("1 minute 5 seconds", text); [EOL]         text
@Test [EOL]     public void testFormatDurationWords() { [EOL]         String text = null; [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, true, false); [EOL]         assertEquals("50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, true, false); [EOL]         assertEquals("1 minute 5 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(120 * 1000, true, false); [EOL]         assertEquals("2 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(121 * 1000, true, false); [EOL]         assertEquals("2 minutes 1 second", text); [EOL]         text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false); [EOL]         assertEquals("1 hour 12 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false); [EOL]         assertEquals("1 day 0 hours 0 minutes 0 seconds", text); [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, true, true); [EOL]         assertEquals("50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, true, true); [EOL]         assertEquals("1 minute 5 seconds", text); [EOL]         text
@Test [EOL]     public void testFormatDurationWords() { [EOL]         String text = null; [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, true, false); [EOL]         assertEquals("50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, true, false); [EOL]         assertEquals("1 minute 5 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(120 * 1000, true, false); [EOL]         assertEquals("2 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(121 * 1000, true, false); [EOL]         assertEquals("2 minutes 1 second", text); [EOL]         text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false); [EOL]         assertEquals("1 hour 12 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false); [EOL]         assertEquals("1 day 0 hours 0 minutes 0 seconds", text); [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, true, true); [EOL]         assertEquals("50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, true, true); [EOL]         assertEquals("1 minute 5 seconds", text); [EOL]         text
@Test [EOL]     public void testFormatDurationWords() { [EOL]         String text = null; [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, true, false); [EOL]         assertEquals("50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, true, false); [EOL]         assertEquals("1 minute 5 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(120 * 1000, true, false); [EOL]         assertEquals("2 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(121 * 1000, true, false); [EOL]         assertEquals("2 minutes 1 second", text); [EOL]         text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false); [EOL]         assertEquals("1 hour 12 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false); [EOL]         assertEquals("1 day 0 hours 0 minutes 0 seconds", text); [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, true, true); [EOL]         assertEquals("50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, true, true); [EOL]         assertEquals("1 minute 5 seconds", text); [EOL]         text
@Test [EOL]     public void testFormatDurationWords() { [EOL]         String text = null; [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, true, false); [EOL]         assertEquals("50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, true, false); [EOL]         assertEquals("1 minute 5 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(120 * 1000, true, false); [EOL]         assertEquals("2 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(121 * 1000, true, false); [EOL]         assertEquals("2 minutes 1 second", text); [EOL]         text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false); [EOL]         assertEquals("1 hour 12 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false); [EOL]         assertEquals("1 day 0 hours 0 minutes 0 seconds", text); [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, true, true); [EOL]         assertEquals("50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, true, true); [EOL]         assertEquals("1 minute 5 seconds", text); [EOL]         text
@Test [EOL]     public void testDurationsByBruteForce() { [EOL]         bruteForce(2006, 0, 1, "d", Calendar.DAY_OF_MONTH); [EOL]         bruteForce(2006, 0, 2, "d", Calendar.DAY_OF_MONTH); [EOL]         bruteForce(2007, 1, 2, "d", Calendar.DAY_OF_MONTH); [EOL]         bruteForce(2004, 1, 29, "d", Calendar.DAY_OF_MONTH); [EOL]         bruteForce(1996, 1, 29, "d", Calendar.DAY_OF_MONTH); [EOL]  [EOL]         bruteForce(1969, 1, 28, "M", Calendar.MONTH);  // tests for 48 years [EOL]         //bruteForce(1996, 1, 29, "M", Calendar.MONTH);  // this will fail [EOL]     } [EOL]      [EOL]     private static final int FOUR_YEARS = 365 * 3 + 366; [EOL]      [EOL]     // Takes a minute to run, so generally turned off [EOL] //    public void testBrutally() { [EOL] //        Calendar c = Calendar.getInstance(); [EOL] //        c.set(2004, 0, 1, 0, 0, 0); [EOL] //        for (int i=0; i < FOUR_YEARS; i++) { [EOL] //            bruteForce(c.get(Calendar.YEAR), c.get(Calendar.MONTH), c.get(Calendar.DAY_OF_MONTH), "d", Calendar.DAY_OF_MONTH ); [EOL] //
@Test [EOL]     public void testDurationsByBruteForce() { [EOL]         bruteForce(2006, 0, 1, "d", Calendar.DAY_OF_MONTH); [EOL]         bruteForce(2006, 0, 2, "d", Calendar.DAY_OF_MONTH); [EOL]         bruteForce(2007, 1, 2, "d", Calendar.DAY_OF_MONTH); [EOL]         bruteForce(2004, 1, 29, "d", Calendar.DAY_OF_MONTH); [EOL]         bruteForce(1996, 1, 29, "d", Calendar.DAY_OF_MONTH); [EOL]  [EOL]         bruteForce(1969, 1, 28, "M", Calendar.MONTH);  // tests for 48 years [EOL]         //bruteForce(1996, 1, 29, "M", Calendar.MONTH);  // this will fail [EOL]     } [EOL]      [EOL]     private static final int FOUR_YEARS = 365 * 3 + 366; [EOL]      [EOL]     // Takes a minute to run, so generally turned off [EOL] //    public void testBrutally() { [EOL] //        Calendar c = Calendar.getInstance(); [EOL] //        c.set(2004, 0, 1, 0, 0, 0); [EOL] //        for (int i=0; i < FOUR_YEARS; i++) { [EOL] //            bruteForce(c.get(Calendar.YEAR), c.get(Calendar.MONTH), c.get(Calendar.DAY_OF_MONTH), "d", Calendar.DAY_OF_MONTH ); [EOL] //
@Test [EOL]     public void testDurationsByBruteForce() { [EOL]         bruteForce(2006, 0, 1, "d", Calendar.DAY_OF_MONTH); [EOL]         bruteForce(2006, 0, 2, "d", Calendar.DAY_OF_MONTH); [EOL]         bruteForce(2007, 1, 2, "d", Calendar.DAY_OF_MONTH); [EOL]         bruteForce(2004, 1, 29, "d", Calendar.DAY_OF_MONTH); [EOL]         bruteForce(1996, 1, 29, "d", Calendar.DAY_OF_MONTH); [EOL]  [EOL]         bruteForce(1969, 1, 28, "M", Calendar.MONTH);  // tests for 48 years [EOL]         //bruteForce(1996, 1, 29, "M", Calendar.MONTH);  // this will fail [EOL]     } [EOL]      [EOL]     private static final int FOUR_YEARS = 365 * 3 + 366; [EOL]      [EOL]     // Takes a minute to run, so generally turned off [EOL] //    public void testBrutally() { [EOL] //        Calendar c = Calendar.getInstance(); [EOL] //        c.set(2004, 0, 1, 0, 0, 0); [EOL] //        for (int i=0; i < FOUR_YEARS; i++) { [EOL] //            bruteForce(c.get(Calendar.YEAR), c.get(Calendar.MONTH), c.get(Calendar.DAY_OF_MONTH), "d", Calendar.DAY_OF_MONTH ); [EOL] //
@Test [EOL]     public void testDurationsByBruteForce() { [EOL]         bruteForce(2006, 0, 1, "d", Calendar.DAY_OF_MONTH); [EOL]         bruteForce(2006, 0, 2, "d", Calendar.DAY_OF_MONTH); [EOL]         bruteForce(2007, 1, 2, "d", Calendar.DAY_OF_MONTH); [EOL]         bruteForce(2004, 1, 29, "d", Calendar.DAY_OF_MONTH); [EOL]         bruteForce(1996, 1, 29, "d", Calendar.DAY_OF_MONTH); [EOL]  [EOL]         bruteForce(1969, 1, 28, "M", Calendar.MONTH);  // tests for 48 years [EOL]         //bruteForce(1996, 1, 29, "M", Calendar.MONTH);  // this will fail [EOL]     } [EOL]      [EOL]     private static final int FOUR_YEARS = 365 * 3 + 366; [EOL]      [EOL]     // Takes a minute to run, so generally turned off [EOL] //    public void testBrutally() { [EOL] //        Calendar c = Calendar.getInstance(); [EOL] //        c.set(2004, 0, 1, 0, 0, 0); [EOL] //        for (int i=0; i < FOUR_YEARS; i++) { [EOL] //            bruteForce(c.get(Calendar.YEAR), c.get(Calendar.MONTH), c.get(Calendar.DAY_OF_MONTH), "d", Calendar.DAY_OF_MONTH ); [EOL] //
@Test [EOL]     public void testLexx() { [EOL]         // tests each constant [EOL]         assertArrayEquals(new DurationFormatUtils.Token[]{ [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.y, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.M, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.d, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.H, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.m, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.s, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.S, 1)}, DurationFormatUtils.lexx("yMdHmsS")); [EOL]  [EOL]         // tests the ISO8601-like [EOL]         assertArrayEquals(new DurationFormatUtils.Token[]{ [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.H, 1), [EOL]             new DurationFormatUtils.Token(new StringBuilder(":"), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.m, 2), [EOL]             new DurationFormatUtils.Token(new StringBuilder(":"), 1), [EOL]      
@Test [EOL]     public void testLexx() { [EOL]         // tests each constant [EOL]         assertArrayEquals(new DurationFormatUtils.Token[]{ [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.y, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.M, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.d, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.H, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.m, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.s, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.S, 1)}, DurationFormatUtils.lexx("yMdHmsS")); [EOL]  [EOL]         // tests the ISO8601-like [EOL]         assertArrayEquals(new DurationFormatUtils.Token[]{ [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.H, 1), [EOL]             new DurationFormatUtils.Token(new StringBuilder(":"), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.m, 2), [EOL]             new DurationFormatUtils.Token(new StringBuilder(":"), 1), [EOL]      
@Test(expected = UnsupportedOperationException.class) [EOL]     public void testResultInitializerNamesModify() throws ConcurrentException { [EOL]         checkInitialize(); [EOL]         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer [EOL]                 .get(); [EOL]         final Iterator<String> it = res.initializerNames().iterator(); [EOL]         it.next(); [EOL]         it.remove(); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the behavior of the initializer if one of the child initializers [EOL]      * throws a runtime exception. [EOL]      */ [EOL]
@Test(expected = UnsupportedOperationException.class) [EOL]     public void testResultInitializerNamesModify() throws ConcurrentException { [EOL]         checkInitialize(); [EOL]         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer [EOL]                 .get(); [EOL]         final Iterator<String> it = res.initializerNames().iterator(); [EOL]         it.next(); [EOL]         it.remove(); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the behavior of the initializer if one of the child initializers [EOL]      * throws a runtime exception. [EOL]      */ [EOL]
@Test(expected = UnsupportedOperationException.class) [EOL]     public void testResultInitializerNamesModify() throws ConcurrentException { [EOL]         checkInitialize(); [EOL]         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer [EOL]                 .get(); [EOL]         final Iterator<String> it = res.initializerNames().iterator(); [EOL]         it.next(); [EOL]         it.remove(); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the behavior of the initializer if one of the child initializers [EOL]      * throws a runtime exception. [EOL]      */ [EOL]
@Test [EOL]     public void testConstructor() { [EOL]         assertNotNull(new RandomStringUtils()); [EOL]         final Constructor<?>[] cons = Validate.class.getDeclaredConstructors(); [EOL]         assertEquals(1, cons.length); [EOL]         assertTrue(Modifier.isPublic(cons[0].getModifiers())); [EOL]         assertTrue(Modifier.isPublic(WordUtils.class.getModifiers())); [EOL]         assertFalse(Modifier.isFinal(WordUtils.class.getModifiers())); [EOL]     } [EOL]      [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testConstructor() { [EOL]         assertNotNull(new RandomStringUtils()); [EOL]         final Constructor<?>[] cons = Validate.class.getDeclaredConstructors(); [EOL]         assertEquals(1, cons.length); [EOL]         assertTrue(Modifier.isPublic(cons[0].getModifiers())); [EOL]         assertTrue(Modifier.isPublic(WordUtils.class.getModifiers())); [EOL]         assertFalse(Modifier.isFinal(WordUtils.class.getModifiers())); [EOL]     } [EOL]      [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testGetAccessibleInterfaceMethodFromDescription() [EOL]             throws Exception { [EOL]         final Class<?>[][] p = { ArrayUtils.EMPTY_CLASS_ARRAY, null }; [EOL]         for (final Class<?>[] element : p) { [EOL]             final Method accessibleMethod = MethodUtils.getAccessibleMethod( [EOL]                     TestMutable.class, "getValue", element); [EOL]             assertSame(Mutable.class, accessibleMethod.getDeclaringClass()); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAccessibleInterfaceMethodFromDescription() [EOL]             throws Exception { [EOL]         final Class<?>[][] p = { ArrayUtils.EMPTY_CLASS_ARRAY, null }; [EOL]         for (final Class<?>[] element : p) { [EOL]             final Method accessibleMethod = MethodUtils.getAccessibleMethod( [EOL]                     TestMutable.class, "getValue", element); [EOL]             assertSame(Mutable.class, accessibleMethod.getDeclaringClass()); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAccessibleInterfaceMethodFromDescription() [EOL]             throws Exception { [EOL]         final Class<?>[][] p = { ArrayUtils.EMPTY_CLASS_ARRAY, null }; [EOL]         for (final Class<?>[] element : p) { [EOL]             final Method accessibleMethod = MethodUtils.getAccessibleMethod( [EOL]                     TestMutable.class, "getValue", element); [EOL]             assertSame(Mutable.class, accessibleMethod.getDeclaringClass()); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAccessibleInterfaceMethodFromDescription() [EOL]             throws Exception { [EOL]         final Class<?>[][] p = { ArrayUtils.EMPTY_CLASS_ARRAY, null }; [EOL]         for (final Class<?>[] element : p) { [EOL]             final Method accessibleMethod = MethodUtils.getAccessibleMethod( [EOL]                     TestMutable.class, "getValue", element); [EOL]             assertSame(Mutable.class, accessibleMethod.getDeclaringClass()); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetFieldForceAccess() { [EOL]         assertEquals(PublicChild.class, FieldUtils.getField(PublicChild.class, "VALUE", true).getDeclaringClass()); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "s", true).getDeclaringClass()); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "b", true).getDeclaringClass()); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "i", true).getDeclaringClass()); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "d", true).getDeclaringClass()); [EOL]         assertEquals(Foo.class, FieldUtils.getField(PubliclyShadowedChild.class, "VALUE", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "s", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "b", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "i", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "d", true).getDeclaringClass()); [EOL]         assertEquals(Foo.class, FieldUtils.getField(Privately
@Test [EOL]     public void testGetFieldForceAccess() { [EOL]         assertEquals(PublicChild.class, FieldUtils.getField(PublicChild.class, "VALUE", true).getDeclaringClass()); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "s", true).getDeclaringClass()); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "b", true).getDeclaringClass()); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "i", true).getDeclaringClass()); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "d", true).getDeclaringClass()); [EOL]         assertEquals(Foo.class, FieldUtils.getField(PubliclyShadowedChild.class, "VALUE", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "s", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "b", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "i", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "d", true).getDeclaringClass()); [EOL]         assertEquals(Foo.class, FieldUtils.getField(Privately
@Test [EOL]     public void testGetFieldForceAccess() { [EOL]         assertEquals(PublicChild.class, FieldUtils.getField(PublicChild.class, "VALUE", true).getDeclaringClass()); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "s", true).getDeclaringClass()); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "b", true).getDeclaringClass()); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "i", true).getDeclaringClass()); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "d", true).getDeclaringClass()); [EOL]         assertEquals(Foo.class, FieldUtils.getField(PubliclyShadowedChild.class, "VALUE", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "s", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "b", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "i", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "d", true).getDeclaringClass()); [EOL]         assertEquals(Foo.class, FieldUtils.getField(Privately
@Test [EOL]     public void testGetFieldForceAccess() { [EOL]         assertEquals(PublicChild.class, FieldUtils.getField(PublicChild.class, "VALUE", true).getDeclaringClass()); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "s", true).getDeclaringClass()); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "b", true).getDeclaringClass()); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "i", true).getDeclaringClass()); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "d", true).getDeclaringClass()); [EOL]         assertEquals(Foo.class, FieldUtils.getField(PubliclyShadowedChild.class, "VALUE", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "s", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "b", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "i", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "d", true).getDeclaringClass()); [EOL]         assertEquals(Foo.class, FieldUtils.getField(Privately
@Test [EOL]     public void testGetFieldForceAccess() { [EOL]         assertEquals(PublicChild.class, FieldUtils.getField(PublicChild.class, "VALUE", true).getDeclaringClass()); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "s", true).getDeclaringClass()); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "b", true).getDeclaringClass()); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "i", true).getDeclaringClass()); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "d", true).getDeclaringClass()); [EOL]         assertEquals(Foo.class, FieldUtils.getField(PubliclyShadowedChild.class, "VALUE", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "s", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "b", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "i", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "d", true).getDeclaringClass()); [EOL]         assertEquals(Foo.class, FieldUtils.getField(Privately
@Test [EOL]     public void testGetFieldForceAccess() { [EOL]         assertEquals(PublicChild.class, FieldUtils.getField(PublicChild.class, "VALUE", true).getDeclaringClass()); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "s", true).getDeclaringClass()); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "b", true).getDeclaringClass()); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "i", true).getDeclaringClass()); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "d", true).getDeclaringClass()); [EOL]         assertEquals(Foo.class, FieldUtils.getField(PubliclyShadowedChild.class, "VALUE", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "s", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "b", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "i", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "d", true).getDeclaringClass()); [EOL]         assertEquals(Foo.class, FieldUtils.getField(Privately
@Test [EOL]     public void testGetFieldForceAccess() { [EOL]         assertEquals(PublicChild.class, FieldUtils.getField(PublicChild.class, "VALUE", true).getDeclaringClass()); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "s", true).getDeclaringClass()); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "b", true).getDeclaringClass()); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "i", true).getDeclaringClass()); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "d", true).getDeclaringClass()); [EOL]         assertEquals(Foo.class, FieldUtils.getField(PubliclyShadowedChild.class, "VALUE", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "s", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "b", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "i", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "d", true).getDeclaringClass()); [EOL]         assertEquals(Foo.class, FieldUtils.getField(Privately
@Test [EOL]     public void testGetFieldForceAccess() { [EOL]         assertEquals(PublicChild.class, FieldUtils.getField(PublicChild.class, "VALUE", true).getDeclaringClass()); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "s", true).getDeclaringClass()); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "b", true).getDeclaringClass()); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "i", true).getDeclaringClass()); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "d", true).getDeclaringClass()); [EOL]         assertEquals(Foo.class, FieldUtils.getField(PubliclyShadowedChild.class, "VALUE", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "s", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "b", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "i", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "d", true).getDeclaringClass()); [EOL]         assertEquals(Foo.class, FieldUtils.getField(Privately
@Test [EOL]     public void testGetFieldForceAccess() { [EOL]         assertEquals(PublicChild.class, FieldUtils.getField(PublicChild.class, "VALUE", true).getDeclaringClass()); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "s", true).getDeclaringClass()); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "b", true).getDeclaringClass()); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "i", true).getDeclaringClass()); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "d", true).getDeclaringClass()); [EOL]         assertEquals(Foo.class, FieldUtils.getField(PubliclyShadowedChild.class, "VALUE", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "s", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "b", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "i", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "d", true).getDeclaringClass()); [EOL]         assertEquals(Foo.class, FieldUtils.getField(Privately
@Test [EOL]     public void testGetFieldForceAccess() { [EOL]         assertEquals(PublicChild.class, FieldUtils.getField(PublicChild.class, "VALUE", true).getDeclaringClass()); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "s", true).getDeclaringClass()); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "b", true).getDeclaringClass()); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "i", true).getDeclaringClass()); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "d", true).getDeclaringClass()); [EOL]         assertEquals(Foo.class, FieldUtils.getField(PubliclyShadowedChild.class, "VALUE", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "s", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "b", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "i", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "d", true).getDeclaringClass()); [EOL]         assertEquals(Foo.class, FieldUtils.getField(Privately
@Test [EOL]     public void testGetAccessibleInterfaceMethodFromDescription() [EOL]             throws Exception { [EOL]         final Class<?>[][] p = { ArrayUtils.EMPTY_CLASS_ARRAY, null }; [EOL]         for (final Class<?>[] element : p) { [EOL]             final Method accessibleMethod = MethodUtils.getAccessibleMethod( [EOL]                     Test.class, "getDeclaringClass", element); [EOL]             assertSame(Mutable.class, accessibleMethod.getDeclaringClass()); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAccessibleInterfaceMethodFromDescription() [EOL]             throws Exception { [EOL]         final Class<?>[][] p = { ArrayUtils.EMPTY_CLASS_ARRAY, null }; [EOL]         for (final Class<?>[] element : p) { [EOL]             final Method accessibleMethod = MethodUtils.getAccessibleMethod( [EOL]                     Test.class, "getDeclaringClass", element); [EOL]             assertSame(Mutable.class, accessibleMethod.getDeclaringClass()); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAccessibleInterfaceMethodFromDescription() [EOL]             throws Exception { [EOL]         final Class<?>[][] p = { ArrayUtils.EMPTY_CLASS_ARRAY, null }; [EOL]         for (final Class<?>[] element : p) { [EOL]             final Method accessibleMethod = MethodUtils.getAccessibleMethod( [EOL]                     TestMutable.class, "getValue", element); [EOL]             assertSame(Mutable.class, accessibleMethod.getDeclaringClass()); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAccessibleInterfaceMethodFromDescription() [EOL]             throws Exception { [EOL]         final Class<?>[][] p = { ArrayUtils.EMPTY_CLASS_ARRAY, null }; [EOL]         for (final Class<?>[] element : p) { [EOL]             final Method accessibleMethod = MethodUtils.getAccessibleMethod( [EOL]                     TestMutable.class, "getValue", element); [EOL]             assertSame(Mutable.class, accessibleMethod.getDeclaringClass()); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetFieldForceAccess() { [EOL]         try { [EOL]             FieldUtils.getField(PublicChild.class, "VALUE"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch(final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]         try { [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAccessibleInterfaceMethodFromDescription() [EOL]             throws Exception { [EOL]         final Class<?>[][] p = { ArrayUtils.EMPTY_CLASS_ARRAY, null }; [EOL]         for (final Class<?>[] element : p) { [EOL]             final Method accessibleMethod = MethodUtils.getAccessibleMethod( [EOL]                     TestMutable.class, "getValue", element); [EOL]             assertSame(Mutable.class, accessibleMethod.getDeclaringClass()); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetFieldForceAccess() { [EOL]         try { [EOL]             FieldUtils.getField(PublicChild.class, "VALUE"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch(final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]         try { [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAccessibleInterfaceMethodFromDescription() [EOL]             throws Exception { [EOL]         final Class<?>[][] p = { ArrayUtils.EMPTY_CLASS_ARRAY, null }; [EOL]         for (final Class<?>[] element : p) { [EOL]             final Method accessibleMethod = MethodUtils.getAccessibleMethod( [EOL]                     TestMutable.class, "getValue", element); [EOL]             assertSame(Mutable.class, accessibleMethod.getDeclaringClass()); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAccessibleInterfaceMethodFromDescription() [EOL]             throws Exception { [EOL]         final Class<?>[][] p = { ArrayUtils.EMPTY_CLASS_ARRAY, null }; [EOL]         for (final Class<?>[] element : p) { [EOL]             final Method accessibleMethod = MethodUtils.getAccessibleMethod( [EOL]                     TestMutable.class, "getValue", element); [EOL]             assertSame(Mutable.class, accessibleMethod.getDeclaringClass()); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAccessibleInterfaceMethodFromDescription() [EOL]             throws Exception { [EOL]         final Class<?>[][] p = { ArrayUtils.EMPTY_CLASS_ARRAY, null }; [EOL]         for (final Class<?>[] element : p) { [EOL]             final Method accessibleMethod = MethodUtils.getAccessibleMethod( [EOL]                     TestMutable.class, "getValue", element); [EOL]             assertSame(Mutable.class, accessibleMethod.getDeclaringClass()); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAccessibleInterfaceMethodFromDescription() [EOL]             throws Exception { [EOL]         final Class<?>[][] p = { ArrayUtils.EMPTY_CLASS_ARRAY, null }; [EOL]         for (final Class<?>[] element : p) { [EOL]             final Method accessibleMethod = MethodUtils.getAccessibleMethod( [EOL]                     TestMutable.class, "getValue", element); [EOL]             assertSame(Mutable.class, accessibleMethod.getDeclaringClass()); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAccessibleInterfaceMethodFromDescription() [EOL]             throws Exception { [EOL]         final Class<?>[][] p = { ArrayUtils.EMPTY_CLASS_ARRAY, null }; [EOL]         for (final Class<?>[] element : p) { [EOL]             final Method accessibleMethod = MethodUtils.getAccessibleMethod( [EOL]                     TestMutable.class, "getValue", element); [EOL]             assertSame(Mutable.class, accessibleMethod.getDeclaringClass()); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAccessibleInterfaceMethodFromDescription() [EOL]             throws Exception { [EOL]         final Class<?>[][] p = { ArrayUtils.EMPTY_CLASS_ARRAY, null }; [EOL]         for (final Class<?>[] element : p) { [EOL]             final Method accessibleMethod = MethodUtils.getAccessibleMethod( [EOL]                     TestMutable.class, "getValue", element); [EOL]             assertSame(Mutable.class, accessibleMethod.getDeclaringClass()); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAccessibleInterfaceMethodFromDescription() [EOL]             throws Exception { [EOL]         final Class<?>[][] p = { ArrayUtils.EMPTY_CLASS_ARRAY, null }; [EOL]         for (final Class<?>[] element : p) { [EOL]             final Method accessibleMethod = MethodUtils.getAccessibleMethod( [EOL]                     TestMutable.class, "getValue", element); [EOL]             assertSame(Mutable.class, accessibleMethod.getDeclaringClass()); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAccessibleInterfaceMethodFromDescription() [EOL]             throws Exception { [EOL]         final Class<?>[][] p = { ArrayUtils.EMPTY_CLASS_ARRAY, null }; [EOL]         for (final Class<?>[] element : p) { [EOL]             final Method accessibleMethod = MethodUtils.getAccessibleMethod( [EOL]                     TestMutable.class, "getValue", element); [EOL]             assertSame(Mutable.class, accessibleMethod.getDeclaringClass()); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void test_toStringExclude() { [EOL]         final String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), SECRET_FIELD); [EOL]         this.validateSecretFieldAbsent(toString); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void test_toStringExclude() { [EOL]         final String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), SECRET_FIELD); [EOL]         this.validateSecretFieldAbsent(toString); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void test_toStringExclude() { [EOL]         final String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), SECRET_FIELD); [EOL]         this.validateSecretFieldAbsent(toString); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetPublicMethod() throws Exception { [EOL]         // Tests with Collections$UnmodifiableSet [EOL]         final Set<?> set = Collections.unmodifiableSet(new HashSet<Object>()); [EOL]         final Method isEmptyMethod = ClassUtils.getPublicMethod(set.getClass(), "isEmpty",  new Class[0]); [EOL]             assertTrue(Modifier.isPublic(isEmptyMethod.getDeclaringClass().getModifiers())); [EOL]  [EOL]         try { [EOL]             isEmptyMethod.invoke(set, new Object[0]); [EOL]         } catch(final java.lang.IllegalAccessException iae) { [EOL]             fail("Should not have thrown IllegalAccessException"); [EOL]         } [EOL]  [EOL]         // Tests with a public Class [EOL]         final Method toStringMethod = ClassUtils.getPublicMethod(Object.class, "toString",  new Class[0]); [EOL]             assertEquals(Object.class.getMethod("toString", new Class[0]), toStringMethod); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetPublicMethod() throws Exception { [EOL]         // Tests with Collections$UnmodifiableSet [EOL]         final Set<?> set = Collections.unmodifiableSet(new HashSet<Object>()); [EOL]         final Method isEmptyMethod = ClassUtils.getPublicMethod(set.getClass(), "isEmpty",  new Class[0]); [EOL]             assertTrue(Modifier.isPublic(isEmptyMethod.getDeclaringClass().getModifiers())); [EOL]  [EOL]         try { [EOL]             isEmptyMethod.invoke(set, new Object[0]); [EOL]         } catch(final java.lang.IllegalAccessException iae) { [EOL]             fail("Should not have thrown IllegalAccessException"); [EOL]         } [EOL]  [EOL]         // Tests with a public Class [EOL]         final Method toStringMethod = ClassUtils.getPublicMethod(Object.class, "toString",  new Class[0]); [EOL]             assertEquals(Object.class.getMethod("toString", new Class[0]), toStringMethod); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetPublicMethod() throws Exception { [EOL]         // Tests with Collections$UnmodifiableSet [EOL]         final Set<?> set = Collections.unmodifiableSet(new HashSet<Object>()); [EOL]         final Method isEmptyMethod = ClassUtils.getPublicMethod(set.getClass(), "isEmpty",  new Class[0]); [EOL]             assertTrue(Modifier.isPublic(isEmptyMethod.getDeclaringClass().getModifiers())); [EOL]  [EOL]         try { [EOL]             isEmptyMethod.invoke(set, new Object[0]); [EOL]         } catch(final java.lang.IllegalAccessException iae) { [EOL]             fail("Should not have thrown IllegalAccessException"); [EOL]         } [EOL]  [EOL]         // Tests with a public Class [EOL]         final Method toStringMethod = ClassUtils.getPublicMethod(Object.class, "toString",  new Class[0]); [EOL]             assertEquals(Object.class.getMethod("toString", new Class[0]), toStringMethod); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetPublicMethod() throws Exception { [EOL]         // Tests with Collections$UnmodifiableSet [EOL]         final Set<?> set = Collections.unmodifiableSet(new HashSet<Object>()); [EOL]         final Method isEmptyMethod = ClassUtils.getPublicMethod(set.getClass(), "isEmpty",  new Class[0]); [EOL]             assertTrue(Modifier.isPublic(isEmptyMethod.getDeclaringClass().getModifiers())); [EOL]  [EOL]         try { [EOL]             isEmptyMethod.invoke(set, new Object[0]); [EOL]         } catch(final java.lang.IllegalAccessException iae) { [EOL]             fail("Should not have thrown IllegalAccessException"); [EOL]         } [EOL]  [EOL]         // Tests with a public Class [EOL]         final Method toStringMethod = ClassUtils.getPublicMethod(Object.class, "toString",  new Class[0]); [EOL]             assertEquals(Object.class.getMethod("toString", new Class[0]), toStringMethod); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetPublicMethod() throws Exception { [EOL]         // Tests with Collections$UnmodifiableSet [EOL]         final Set<?> set = Collections.unmodifiableSet(new HashSet<Object>()); [EOL]         final Method isEmptyMethod = ClassUtils.getPublicMethod(set.getClass(), "isEmpty",  new Class[0]); [EOL]             assertTrue(Modifier.isPublic(isEmptyMethod.getDeclaringClass().getModifiers())); [EOL]  [EOL]         try { [EOL]             isEmptyMethod.invoke(set, new Object[0]); [EOL]         } catch(final java.lang.IllegalAccessException iae) { [EOL]             fail("Should not have thrown IllegalAccessException"); [EOL]         } [EOL]  [EOL]         // Tests with a public Class [EOL]         final Method toStringMethod = ClassUtils.getPublicMethod(Object.class, "toString",  new Class[0]); [EOL]             assertEquals(Object.class.getMethod("toString", new Class[0]), toStringMethod); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetPublicMethod() throws Exception { [EOL]         // Tests with Collections$UnmodifiableSet [EOL]         final Set<?> set = Collections.unmodifiableSet(new HashSet<Object>()); [EOL]         final Method isEmptyMethod = ClassUtils.getPublicMethod(set.getClass(), "isEmpty",  new Class[0]); [EOL]             assertTrue(Modifier.isPublic(isEmptyMethod.getDeclaringClass().getModifiers())); [EOL]  [EOL]         try { [EOL]             isEmptyMethod.invoke(set, new Object[0]); [EOL]         } catch(final java.lang.IllegalAccessException iae) { [EOL]             fail("Should not have thrown IllegalAccessException"); [EOL]         } [EOL]  [EOL]         // Tests with a public Class [EOL]         final Method toStringMethod = ClassUtils.getPublicMethod(Object.class, "toString",  new Class[0]); [EOL]             assertEquals(Object.class.getMethod("toString", new Class[0]), toStringMethod); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetPublicMethod() throws Exception { [EOL]         // Tests with Collections$UnmodifiableSet [EOL]         final Set<?> set = Collections.unmodifiableSet(new HashSet<Object>()); [EOL]         final Method isEmptyMethod = ClassUtils.getPublicMethod(set.getClass(), "isEmpty",  new Class[0]); [EOL]             assertTrue(Modifier.isPublic(isEmptyMethod.getDeclaringClass().getModifiers())); [EOL]  [EOL]         try { [EOL]             isEmptyMethod.invoke(set, new Object[0]); [EOL]         } catch(final java.lang.IllegalAccessException iae) { [EOL]             fail("Should not have thrown IllegalAccessException"); [EOL]         } [EOL]  [EOL]         // Tests with a public Class [EOL]         final Method toStringMethod = ClassUtils.getPublicMethod(Object.class, "toString",  new Class[0]); [EOL]             assertEquals(Object.class.getMethod("toString", new Class[0]), toStringMethod); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetPublicMethod() throws Exception { [EOL]         // Tests with Collections$UnmodifiableSet [EOL]         final Set<?> set = Collections.unmodifiableSet(new HashSet<Object>()); [EOL]         final Method isEmptyMethod = ClassUtils.getPublicMethod(set.getClass(), "isEmpty",  new Class[0]); [EOL]             assertTrue(Modifier.isPublic(isEmptyMethod.getDeclaringClass().getModifiers())); [EOL]  [EOL]         try { [EOL]             isEmptyMethod.invoke(set, new Object[0]); [EOL]         } catch(final java.lang.IllegalAccessException iae) { [EOL]             fail("Should not have thrown IllegalAccessException"); [EOL]         } [EOL]  [EOL]         // Tests with a public Class [EOL]         final Method toStringMethod = ClassUtils.getPublicMethod(Object.class, "toString",  new Class[0]); [EOL]             assertEquals(Object.class.getMethod("toString", new Class[0]), toStringMethod); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetPublicMethod() throws Exception { [EOL]         // Tests with Collections$UnmodifiableSet [EOL]         final Set<?> set = Collections.unmodifiableSet(new HashSet<Object>()); [EOL]         final Method isEmptyMethod = ClassUtils.getPublicMethod(set.getClass(), "isEmpty",  new Class[0]); [EOL]             assertTrue(Modifier.isPublic(isEmptyMethod.getDeclaringClass().getModifiers())); [EOL]  [EOL]         try { [EOL]             isEmptyMethod.invoke(set, new Object[0]); [EOL]         } catch(final java.lang.IllegalAccessException iae) { [EOL]             fail("Should not have thrown IllegalAccessException"); [EOL]         } [EOL]  [EOL]         // Tests with a public Class [EOL]         final Method toStringMethod = ClassUtils.getPublicMethod(Object.class, "toString",  new Class[0]); [EOL]             assertEquals(Object.class.getMethod("toString", new Class[0]), toStringMethod); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetPublicMethod() throws Exception { [EOL]         // Tests with Collections$UnmodifiableSet [EOL]         final Set<?> set = Collections.unmodifiableSet(new HashSet<Object>()); [EOL]         final Method isEmptyMethod = ClassUtils.getPublicMethod(set.getClass(), "isEmpty",  new Class[0]); [EOL]             assertTrue(Modifier.isPublic(isEmptyMethod.getDeclaringClass().getModifiers())); [EOL]  [EOL]         try { [EOL]             isEmptyMethod.invoke(set, new Object[0]); [EOL]         } catch(final java.lang.IllegalAccessException iae) { [EOL]             fail("Should not have thrown IllegalAccessException"); [EOL]         } [EOL]  [EOL]         // Tests with a public Class [EOL]         final Method toStringMethod = ClassUtils.getPublicMethod(Object.class, "toString",  new Class[0]); [EOL]             assertEquals(Object.class.getMethod("toString", new Class[0]), toStringMethod); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testWriteNamedStaticField() throws Exception { [EOL]         FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePublic", "new"); [EOL]         assertEquals("new", StaticContainer.mutablePublic); [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutableProtected", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePackage", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePrivate", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]     
@Test [EOL]     public void testWriteNamedStaticField() throws Exception { [EOL]         FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePublic", "new"); [EOL]         assertEquals("new", StaticContainer.mutablePublic); [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutableProtected", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePackage", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePrivate", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]     
@Test [EOL]     public void testWriteNamedStaticField() throws Exception { [EOL]         FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePublic", "new"); [EOL]         assertEquals("new", StaticContainer.mutablePublic); [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutableProtected", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePackage", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePrivate", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]     
@Test [EOL]     public void testWriteNamedStaticField() throws Exception { [EOL]         FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePublic", "new"); [EOL]         assertEquals("new", StaticContainer.mutablePublic); [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutableProtected", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePackage", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePrivate", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]     
@Test [EOL]     public void testWriteNamedStaticField() throws Exception { [EOL]         FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePublic", "new"); [EOL]         assertEquals("new", StaticContainer.mutablePublic); [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutableProtected", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePackage", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePrivate", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]     
@Test [EOL]     public void testWriteNamedStaticField() throws Exception { [EOL]         FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePublic", "new"); [EOL]         assertEquals("new", StaticContainer.mutablePublic); [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutableProtected", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePackage", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePrivate", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]     
@Test [EOL]     public void testWriteNamedStaticField() throws Exception { [EOL]         FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePublic", "new"); [EOL]         assertEquals("new", StaticContainer.mutablePublic); [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutableProtected", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePackage", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePrivate", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]     
@Test [EOL]     public void testWriteNamedStaticField() throws Exception { [EOL]         FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePublic", "new"); [EOL]         assertEquals("new", StaticContainer.mutablePublic); [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutableProtected", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePackage", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePrivate", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]     
@Test [EOL]     public void testWriteNamedStaticField() throws Exception { [EOL]         FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePublic", "new"); [EOL]         assertEquals("new", StaticContainer.mutablePublic); [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutableProtected", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePackage", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePrivate", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]     
@Test [EOL]     public void testWriteNamedStaticField() throws Exception { [EOL]         FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePublic", "new"); [EOL]         assertEquals("new", StaticContainer.mutablePublic); [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutableProtected", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePackage", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePrivate", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]     
@Test [EOL]     public void testWriteNamedStaticField() throws Exception { [EOL]         FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePublic", "new"); [EOL]         assertEquals("new", StaticContainer.mutablePublic); [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutableProtected", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePackage", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePrivate", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]     
@Test [EOL]     public void testWriteNamedStaticField() throws Exception { [EOL]         FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePublic", "new"); [EOL]         assertEquals("new", StaticContainer.mutablePublic); [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutableProtected", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePackage", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePrivate", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]     
@Test [EOL]     public void testWriteNamedStaticField() throws Exception { [EOL]         FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePublic", "new"); [EOL]         assertEquals("new", StaticContainer.mutablePublic); [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutableProtected", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePackage", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePrivate", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]     
@Test [EOL]     public void testWriteNamedStaticField() throws Exception { [EOL]         FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePublic", "new"); [EOL]         assertEquals("new", StaticContainer.mutablePublic); [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutableProtected", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePackage", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePrivate", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]     
@Test [EOL]     public void testWriteNamedStaticField() throws Exception { [EOL]         FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePublic", "new"); [EOL]         assertEquals("new", StaticContainer.mutablePublic); [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutableProtected", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePackage", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePrivate", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]     
@Test [EOL]     public void testWriteNamedStaticField() throws Exception { [EOL]         FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePublic", "new"); [EOL]         assertEquals("new", StaticContainer.mutablePublic); [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutableProtected", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.readStaticField(StaticContainerChild.class, "mutablePackage", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.readStaticField(StaticContainerChild.class, "mutablePrivate", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]     
@Test [EOL]     public void testGetAccessibleInterfaceMethodFromDescription() [EOL]             throws Exception { [EOL]         final Class<?>[][] p = { ArrayUtils.EMPTY_CLASS_ARRAY, null }; [EOL]         for (final Class<?>[] element : p) { [EOL]             final Method accessibleMethod = MethodUtils.getAccessibleMethod( [EOL]                     TestMutable.class, "getValue", element); [EOL]             assertSame(Mutable.class, accessibleMethod.getDeclaringClass()); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testWriteNamedStaticField() throws Exception { [EOL]         FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePublic", "new"); [EOL]         assertEquals("new", StaticContainer.mutablePublic); [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutableProtected", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePackage", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePrivate", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]     
@Test [EOL]     public void testWriteNamedStaticField() throws Exception { [EOL]         FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePublic", "new"); [EOL]         assertEquals("new", StaticContainer.mutablePublic); [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutableProtected", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePackage", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePrivate", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]     
@Test [EOL]     public void testWriteNamedStaticField() throws Exception { [EOL]         FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePublic", "new"); [EOL]         assertEquals("new", StaticContainer.mutablePublic); [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutableProtected", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.readStaticField(StaticContainerChild.class, "mutablePackage", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.readStaticField(StaticContainerChild.class, "mutablePrivate", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]     
@Test [EOL]     public void testWriteNamedStaticField() throws Exception { [EOL]         FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePublic", "new"); [EOL]         assertEquals("new", StaticContainer.mutablePublic); [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutableProtected", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePackage", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePrivate", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]     
@Test [EOL]     public void testWriteNamedStaticField() throws Exception { [EOL]         FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePublic", "new"); [EOL]         assertEquals("new", StaticContainer.mutablePublic); [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutableProtected", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.readStaticField(StaticContainerChild.class, "mutablePackage", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.readStaticField(StaticContainerChild.class, "mutablePrivate", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]     
@Test [EOL]     public void test_toStringExclude() { [EOL]         final String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), SECRET_FIELD); [EOL]         this.validateSecretFieldAbsent(toString); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void test_toStringExclude() { [EOL]         final String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), SECRET_FIELD); [EOL]         this.validateSecretFieldAbsent(toString); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReadNamedStaticField() throws Exception { [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(Foo.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PubliclyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PrivatelyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PublicChild.class, "VALUE")); [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(null, "none"); [EOL]             fail("null class should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(Foo.class, null); [EOL]             fail("null field name should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(Foo.class, "does_not_exist");
@Test [EOL]     public void testReadNamedStaticField() throws Exception { [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(Foo.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PubliclyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PrivatelyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PublicChild.class, "VALUE")); [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(null, "none"); [EOL]             fail("null class should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(Foo.class, null); [EOL]             fail("null field name should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(Foo.class, "does_not_exist");
@Test [EOL]     public void testReadNamedStaticField() throws Exception { [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(Foo.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PubliclyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PrivatelyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PublicChild.class, "VALUE")); [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(null, "none"); [EOL]             fail("null class should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(Foo.class, null); [EOL]             fail("null field name should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(Foo.class, "does_not_exist");
@Test [EOL]     public void testReadNamedStaticField() throws Exception { [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(Foo.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PubliclyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PrivatelyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PublicChild.class, "VALUE")); [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(null, "none"); [EOL]             fail("null class should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(Foo.class, null); [EOL]             fail("null field name should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(Foo.class, "does_not_exist");
@Test [EOL]     public void testReadNamedStaticField() throws Exception { [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(Foo.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PubliclyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PrivatelyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PublicChild.class, "VALUE")); [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(null, "none"); [EOL]             fail("null class should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(Foo.class, null); [EOL]             fail("null field name should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(Foo.class, "does_not_exist");
@Test [EOL]     public void testReadNamedStaticField() throws Exception { [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(Foo.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PubliclyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PrivatelyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PublicChild.class, "VALUE")); [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(null, "none"); [EOL]             fail("null class should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(Foo.class, null); [EOL]             fail("null field name should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(Foo.class, "does_not_exist");
@Test [EOL]     public void testReadNamedStaticField() throws Exception { [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(Foo.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PubliclyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PrivatelyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PublicChild.class, "VALUE")); [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(null, "none"); [EOL]             fail("null class should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(Foo.class, null); [EOL]             fail("null field name should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(Foo.class, "does_not_exist");
@Test [EOL]     public void testReadNamedStaticField() throws Exception { [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(Foo.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PubliclyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PrivatelyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PublicChild.class, "VALUE")); [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(null, "none"); [EOL]             fail("NullPointerException expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReadNamedStaticField() throws Exception { [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(Foo.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PubliclyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PrivatelyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PublicChild.class, "VALUE")); [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(null, "none"); [EOL]             fail("NullPointerException expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReadNamedStaticField() throws Exception { [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(Foo.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PubliclyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PrivatelyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PublicChild.class, "VALUE")); [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(null, "none"); [EOL]             fail("NullPointerException expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetFieldForceAccess() { [EOL]         assertEquals(PublicChild.class, FieldUtils.getField(PublicChild.class, "VALUE")); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "VALUE")); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "VALUE")); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "VALUE")); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "VALUE")); [EOL]         assertEquals(parentClass, FieldUtils.getField(PubliclyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Byte.class, FieldUtils.getField(PubliclyShadowedChild.class, "")); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "s", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "b", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "i", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "d", true).getDeclaringClass()); [EOL]         assertEquals(Foo.class, FieldUtils.getField(Privately
@Test [EOL]     public void testGetFieldForceAccess() { [EOL]         try { [EOL]             FieldUtils.getField(PublicChild.class, "Should"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]         try { [EOL]             assertEquals("Expected IllegalArgumentException", e.getMessage()); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetFieldForceAccess() { [EOL]         assertEquals(PublicChild.class, FieldUtils.getField(PublicChild.class, "VALUE")); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "i")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.getField(PubliclyShadowedChild.class, "VALUE")); [EOL]         assertEquals(0, FieldUtils.getField(PubliclyShadowedChild.class, "VALUE")); [EOL]         assertEquals(1, FieldUtils.getField(PublicChild.class, "VALUE")); [EOL]         assertEquals(2, FieldUtils.getField(PublicChild.class, "VALUE")); [EOL]         assertEquals(Foo.class, FieldUtils.getField(PubliclyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Foo.class, FieldUtils.getField(PubliclyShadowedChild.class, "s", true)); [EOL]         assertEquals(Foo.class, FieldUtils.getField(PubliclyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Foo.class, FieldUtils.getField(PubliclyShadowedChild.class, "VALUE")); [EOL]         try { [EOL]             FieldUtils.readStaticField(PubliclyShadowedChild.class, "d", true)); [EOL]             fail("Expecting IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [E
@Test [EOL]     public void testGetFieldForceAccess() { [EOL]         assertEquals(PublicChild.class, FieldUtils.getField(PublicChild.class, "VALUE")); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "VALUE")); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "VALUE")); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "VALUE")); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "VALUE")); [EOL]         assertEquals(parentClass, FieldUtils.getField(PubliclyShadowedChild.class, "VALUE")); [EOL]         assertEquals(3, FieldUtils.getField(PubliclyShadowedChild.class, "class, ")); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "s", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "b", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "i", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "d", true).getDeclaringClass()); [EOL]         assertEquals(Foo.class, FieldUtils.getField(Privately
@Test [EOL]     public void testGetFieldForceAccess() { [EOL]         assertEquals(PublicChild.class, FieldUtils.getField(PublicChild.class, "VALUE")); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "VALUE")); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "VALUE")); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "VALUE")); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "VALUE")); [EOL]         assertEquals(parentClass, FieldUtils.getField(PubliclyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Byte.class, FieldUtils.getField(PubliclyShadowedChild.class, "")); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "s", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "b", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "i", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "d", true).getDeclaringClass()); [EOL]         assertEquals(Foo.class, FieldUtils.getField(Privately
@Test [EOL]     public void testGetFieldForceAccess() { [EOL]         try { [EOL]             FieldUtils.getField(PublicChild.class, "VALUE"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]         try { [EOL]             assertEquals("Expected IllegalArgumentException e) [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetFieldForceAccess() { [EOL]         assertEquals(PublicChild.class, FieldUtils.getField(PublicChild.class, "VALUE")); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "VALUE")); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "VALUE")); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "VALUE")); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "VALUE")); [EOL]         assertEquals(parentClass, FieldUtils.getField(PubliclyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Byte.class, FieldUtils.getField(PubliclyShadowedChild.class, "VALUE")); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "s", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "i", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "i", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "d", true).getDeclaringClass()); [EOL]         assertEquals(Foo.class, FieldUtils.getField(Priv
@Test [EOL]     public void testReadNamedStaticField() throws Exception { [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(Foo.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PubliclyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PrivatelyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PublicChild.class, "VALUE")); [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(null, "none"); [EOL]             fail("null class should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(Foo.class, null); [EOL]             fail("null field name should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(Foo.class, "does_not_exist");
@Test [EOL]     public void testReadNamedStaticField() throws Exception { [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(Foo.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PubliclyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PrivatelyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PublicChild.class, "VALUE")); [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(null, "none"); [EOL]             fail("null class should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(Foo.class, null); [EOL]             fail("null field name should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(Foo.class, "does_not_exist");
@Test [EOL]     public void testReadNamedStaticField() throws Exception { [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(Foo.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PubliclyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PrivatelyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PublicChild.class, "VALUE")); [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(null, "none"); [EOL]             fail("null class should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(Foo.class, null); [EOL]             fail("null field name should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(Foo.class, "does_not_exist");
@Test [EOL]     public void testGetAccessibleInterfaceMethodFromDescription() [EOL]             throws Exception { [EOL]         final Class<?>[][] p = { ArrayUtils.EMPTY_CLASS_ARRAY, null }; [EOL]         for (final Class<?>[] element : p) { [EOL]             final Method accessibleMethod = MethodUtils.getAccessibleMethod( [EOL]                     TestMutable.class, "getValue", element); [EOL]             assertSame(Mutable.class, accessibleMethod.getDeclaringClass()); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReadNamedStaticField() throws Exception { [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(Foo.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PubliclyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PrivatelyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PublicChild.class, "VALUE")); [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(null, "none"); [EOL]             fail("NullPointerException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAccessibleInterfaceMethodFromDescription() [EOL]             throws Exception { [EOL]         final Class<?>[][] p = { ArrayUtils.EMPTY_CLASS_ARRAY, null }; [EOL]         for (final Class<?>[] element : p) { [EOL]             final Method accessibleMethod = MethodUtils.getAccessibleMethod( [EOL]                     TestMutable.class, "getValue", element); [EOL]             assertSame(Mutable.class, accessibleMethod.getDeclaringClass()); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAccessibleInterfaceMethodFromDescription() [EOL]             throws Exception { [EOL]         final Class<?>[][] p = { ArrayUtils.EMPTY_CLASS_ARRAY, null }; [EOL]         for (final Class<?>[] element : p) { [EOL]             final Method accessibleMethod = MethodUtils.getAccessibleMethod( [EOL]                     TestMutable.class, "getValue", element); [EOL]             assertSame(Mutable.class, accessibleMethod.getDeclaringClass()); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAccessibleInterfaceMethodFromDescription() [EOL]             throws Exception { [EOL]         final Class<?>[][] p = { ArrayUtils.EMPTY_CLASS_ARRAY, null }; [EOL]         for (final Class<?>[] element : p) { [EOL]             final Method accessibleMethod = MethodUtils.getAccessibleMethod( [EOL]                     TestMutable.class, "getValue", element); [EOL]             assertSame(Mutable.class, accessibleMethod.getDeclaringClass()); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReadNamedStaticField() throws Exception { [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(Foo.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PubliclyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PrivatelyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PublicChild.class, "VALUE")); [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(null, "none"); [EOL]             fail("null class should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(Foo.class, null); [EOL]             fail("null field name should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(Foo.class, "does_not_exist");
@Test [EOL]     public void testGetAccessibleInterfaceMethodFromDescription() [EOL]             throws Exception { [EOL]         final Class<?>[][] p = { ArrayUtils.EMPTY_CLASS_ARRAY, null }; [EOL]         for (final Class<?>[] element : p) { [EOL]             final Method accessibleMethod = MethodUtils.getAccessibleMethod( [EOL]                     TestMutable.class, "getValue", element); [EOL]             assertSame(Mutable.class, accessibleMethod.getDeclaringClass()); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testWriteNamedStaticField() throws Exception { [EOL]         FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePublic", "new"); [EOL]         assertEquals("new", StaticContainer.mutablePublic); [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutableProtected", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePackage", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePrivate", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]     
@Test [EOL]     public void testWriteNamedStaticField() throws Exception { [EOL]         FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePublic", "new"); [EOL]         assertEquals("new", StaticContainer.mutablePublic); [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutableProtected", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePackage", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePrivate", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]     
@Test [EOL]     public void testWriteNamedStaticField() throws Exception { [EOL]         FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePublic", "new"); [EOL]         assertEquals("new", StaticContainer.mutablePublic); [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutableProtected", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePackage", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePrivate", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]     
@Test [EOL]     public void testWriteNamedStaticField() throws Exception { [EOL]         FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePublic", "new"); [EOL]         assertEquals("new", StaticContainer.mutablePublic); [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutableProtected", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePackage", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePrivate", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]     
@Test [EOL]     public void testWriteNamedStaticField() throws Exception { [EOL]         FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePublic", "new"); [EOL]         assertEquals("new", StaticContainer.mutablePublic); [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutableProtected", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePackage", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePrivate", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]     
@Test [EOL]     public void testWriteNamedStaticField() throws Exception { [EOL]         FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePublic", "new"); [EOL]         assertEquals("new", StaticContainer.mutablePublic); [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutableProtected", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePackage", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePrivate", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]     
@Test [EOL]     public void testWriteNamedStaticField() throws Exception { [EOL]         FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePublic", "new"); [EOL]         assertEquals("new", StaticContainer.mutablePublic); [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutableProtected", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePackage", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePrivate", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]     
@Test [EOL]     public void testWriteNamedStaticField() throws Exception { [EOL]         FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePublic", "new"); [EOL]         assertEquals("new", StaticContainer.mutablePublic); [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutableProtected", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePackage", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePrivate", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]     
@Test [EOL]     public void testWriteNamedStaticField() throws Exception { [EOL]         FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePublic", "new"); [EOL]         assertEquals("new", StaticContainer.mutablePublic); [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutableProtected", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePackage", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePrivate", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]     
@Test [EOL]     public void testWriteNamedStaticField() throws Exception { [EOL]         FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePublic", "new"); [EOL]         assertEquals("new", StaticContainer.mutablePublic); [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutableProtected", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePackage", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePrivate", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]     
@Test [EOL]     public void testWriteNamedStaticField() throws Exception { [EOL]         FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePublic", "new"); [EOL]         assertEquals("new", StaticContainer.mutablePublic); [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutableProtected", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePackage", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePrivate", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]     
@Test [EOL]     public void testWriteNamedStaticField() throws Exception { [EOL]         FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePublic", "new"); [EOL]         assertEquals("new", StaticContainer.mutablePublic); [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutableProtected", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePackage", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePrivate", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]     
@Test [EOL]     public void testWriteNamedStaticField() throws Exception { [EOL]         FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePublic", "new"); [EOL]         assertEquals("new", StaticContainer.mutablePublic); [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutableProtected", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePackage", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePrivate", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]     
@Test [EOL]     public void testWriteNamedStaticField() throws Exception { [EOL]         FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePublic", "new"); [EOL]         assertEquals("new", StaticContainer.mutablePublic); [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutableProtected", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePackage", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePrivate", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]     
@Test [EOL]     public void testWriteNamedStaticField() throws Exception { [EOL]         FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePublic", "new"); [EOL]         assertEquals("new", StaticContainer.mutablePublic); [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutableProtected", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePackage", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePrivate", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]     
@Test [EOL]     public void testWriteNamedStaticField() throws Exception { [EOL]         FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePublic", "new"); [EOL]         assertEquals("new", StaticContainer.mutablePublic); [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutableProtected", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePackage", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePrivate", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]     
@Test [EOL]     public void testWriteNamedStaticField() throws Exception { [EOL]         FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePublic", "new"); [EOL]         assertEquals("new", StaticContainer.mutablePublic); [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutableProtected", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePackage", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePrivate", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]     
@Test [EOL]     public void testWriteNamedStaticField() throws Exception { [EOL]         FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePublic", "new"); [EOL]         assertEquals("new", StaticContainer.mutablePublic); [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutableProtected", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePackage", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.readStaticField(StaticContainerChild.class, "mutablePrivate", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]     
@Test [EOL]     public void testWriteNamedStaticField() throws Exception { [EOL]         FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePublic", "new"); [EOL]         assertEquals("new", StaticContainer.mutablePublic); [EOL]         try { [EOL]             FieldUtils.readStaticField(StaticContainerChild.class, "mutableProtected", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.readStaticField(StaticContainerChild.class, "mutablePackage", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.readStaticField(StaticContainerChild.class, "mutablePrivate", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]     
@Test [EOL]     public void testReadNamedStaticField() throws Exception { [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(Foo.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PubliclyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PrivatelyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PublicChild.class, "VALUE")); [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(null, "none"); [EOL]             fail("null class should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(Foo.class, null); [EOL]             fail("null field name should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(Foo.class, "does_not_exist");
@Test [EOL]     public void testReadNamedStaticField() throws Exception { [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(Foo.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PubliclyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PrivatelyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PublicChild.class, "VALUE")); [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(null, "none"); [EOL]             fail("null class should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(Foo.class, null); [EOL]             fail("null field name should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(Foo.class, "does_not_exist");
@Test [EOL]     public void testWriteNamedStaticField() throws Exception { [EOL]         FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePublic", "new"); [EOL]         assertEquals("new", StaticContainer.mutablePublic); [EOL]         try { [EOL]             FieldUtils.readStaticField(StaticContainerChild.class, "mutableProtected", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]         try { [EOL]             FieldUtils.readStaticField(StaticContainerChild, "mutablePackage", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]         try { [EOL]             FieldUtils.readStaticField(StaticContainerChild.class, "mutablePrivate", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]       
@Test [EOL]     public void testWriteNamedStaticField() throws Exception { [EOL]         FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePublic", "new"); [EOL]         assertEquals("new", StaticContainer.mutablePublic); [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutableProtected", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePackage", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePrivate", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]     
@Test [EOL]     public void testWriteNamedStaticField() throws Exception { [EOL]         FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePublic", "new"); [EOL]         assertEquals("new", StaticContainer.mutablePublic); [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutableProtected", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePackage", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePrivate", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]     
@Test [EOL]     public void testWriteNamedStaticField() throws Exception { [EOL]         FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePublic", "new"); [EOL]         assertEquals("new", StaticContainer.mutablePublic); [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutableProtected", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePackage", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePrivate", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]     
@Test [EOL]     public void testWriteNamedStaticField() throws Exception { [EOL]         FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePublic", "new"); [EOL]         assertEquals("new", StaticContainer.mutablePublic); [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutableProtected", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePackage", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePrivate", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]     
@Test [EOL]     public void testWriteNamedStaticField() throws Exception { [EOL]         FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePublic", "new"); [EOL]         assertEquals("new", StaticContainer.mutablePublic); [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutableProtected", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePackage", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePrivate", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]     
@Test [EOL]     public void testWriteNamedStaticField() throws Exception { [EOL]         FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePublic", "new"); [EOL]         assertEquals("new", StaticContainer.mutablePublic); [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutableProtected", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePackage", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePrivate", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]     
@Test [EOL]     public void testWriteNamedStaticField() throws Exception { [EOL]         FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePublic", "new"); [EOL]         assertEquals("new", StaticContainer.mutablePublic); [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutableProtected", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePackage", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePrivate", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]     
@Test [EOL]     public void testWriteNamedStaticField() throws Exception { [EOL]         FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePublic", "new"); [EOL]         assertEquals("new", StaticContainer.mutablePublic); [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutableProtected", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePackage", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePrivate", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]     
@Test [EOL]     public void testWriteNamedStaticField() throws Exception { [EOL]         FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePublic", "new"); [EOL]         assertEquals("new", StaticContainer.mutablePublic); [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutableProtected", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePackage", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePrivate", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]     
@Test [EOL]     public void testWriteNamedStaticField() throws Exception { [EOL]         FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePublic", "new"); [EOL]         assertEquals("new", StaticContainer.mutablePublic); [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutableProtected", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePackage", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePrivate", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]     
@Test [EOL]     public void testWriteNamedStaticField() throws Exception { [EOL]         FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePublic", "new"); [EOL]         assertEquals("new", StaticContainer.mutablePublic); [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutableProtected", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePackage", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePrivate", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]     
@Test [EOL]     public void testWriteNamedStaticField() throws Exception { [EOL]         FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePublic", "new"); [EOL]         assertEquals("new", StaticContainer.mutablePublic); [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutableProtected", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePackage", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePrivate", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]     
@Test [EOL]     public void testWriteNamedStaticField() throws Exception { [EOL]         FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePublic", "new"); [EOL]         assertEquals("new", StaticContainer.mutablePublic); [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutableProtected", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePackage", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePrivate", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]     
@Test [EOL]     public void testWriteNamedStaticField() throws Exception { [EOL]         FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePublic", "new"); [EOL]         assertEquals("new", StaticContainer.mutablePublic); [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutableProtected", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePackage", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePrivate", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]     
@Test [EOL]     public void testWriteNamedStaticField() throws Exception { [EOL]         FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePublic", "new"); [EOL]         assertEquals("new", StaticContainer.mutablePublic); [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutableProtected", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePackage", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePrivate", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]     
@Test [EOL]     public void testWriteNamedStaticField() throws Exception { [EOL]         FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePublic", "new"); [EOL]         assertEquals("new", StaticContainer.mutablePublic); [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutableProtected", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePackage", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePrivate", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]     
@Test [EOL]     public void testWriteNamedStaticField() throws Exception { [EOL]         FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePublic", "new"); [EOL]         assertEquals("new", StaticContainer.mutablePublic); [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutableProtected", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePackage", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePrivate", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]     
@Test [EOL]     public void testWriteNamedStaticField() throws Exception { [EOL]         FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePublic", "new"); [EOL]         assertEquals("new", StaticContainer.mutablePublic); [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutableProtected", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePackage", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePrivate", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]     
@Test [EOL]     public void testSwapCase_String() { [EOL]         assertEquals(null, WordUtils.swapCase(null)); [EOL]         assertEquals("", WordUtils.swapCase("")); [EOL]         assertEquals("  ", WordUtils.swapCase("  ")); [EOL]          [EOL]         assertEquals("i", WordUtils.swapCase("I") ); [EOL]         assertEquals("I", WordUtils.swapCase("i") ); [EOL]         assertEquals("I AM HERE 123", WordUtils.swapCase("i am here 123") ); [EOL]         assertEquals("i aM hERE 123", WordUtils.swapCase("I Am Here 123") ); [EOL]         assertEquals("I AM here 123", WordUtils.swapCase("i am HERE 123") ); [EOL]         assertEquals("i am here 123", WordUtils.swapCase("I AM HERE 123") ); [EOL]  [EOL]         final String test = "This String contains a TitleCase character: \u01C8"; [EOL]         final String expect = "tHIS sTRING CONTAINS A tITLEcASE CHARACTER: \u01C9"; [EOL]         assertEquals(expect, WordUtils.swapCase(test)); [EOL]     } [EOL]  [EOL] } [EOL]
@Test [EOL]     public void testSwapCase_String() { [EOL]         assertEquals(null, WordUtils.swapCase(null)); [EOL]         assertEquals("", WordUtils.swapCase("")); [EOL]         assertEquals("  ", WordUtils.swapCase("  ")); [EOL]          [EOL]         assertEquals("i", WordUtils.swapCase("I") ); [EOL]         assertEquals("I", WordUtils.swapCase("i") ); [EOL]         assertEquals("I AM HERE 123", WordUtils.swapCase("i am here 123") ); [EOL]         assertEquals("i aM hERE 123", WordUtils.swapCase("I Am Here 123") ); [EOL]         assertEquals("I AM here 123", WordUtils.swapCase("i am HERE 123") ); [EOL]         assertEquals("i am here 123", WordUtils.swapCase("I AM HERE 123") ); [EOL]  [EOL]         final String test = "This String contains a TitleCase character: \u01C8"; [EOL]         final String expect = "tHIS sTRING CONTAINS A tITLEcASE CHARACTER: \u01C9"; [EOL]         assertEquals(expect, WordUtils.swapCase(test)); [EOL]     } [EOL]  [EOL] } [EOL]
@Test [EOL]     public void testIsSameInstant_Cal() { [EOL]         final GregorianCalendar cal1 = new GregorianCalendar(TimeZone.getTimeZone("GMT+1")); [EOL]         final GregorianCalendar cal2 = new GregorianCalendar(TimeZone.getTimeZone("GMT-1")); [EOL]         cal1.set(2004, 6, 9, 13, 45, 0); [EOL]         cal1.set(Calendar.MILLISECOND, 0); [EOL]         cal2.set(2004, 6, 9, 13, 45, 0); [EOL]         cal2.set(Calendar.MILLISECOND, 0); [EOL]         assertFalse(DateUtils.isSameInstant(cal1, cal2)); [EOL]          [EOL]         cal2.set(2004, 6, 9, 11, 45, 0); [EOL]         assertTrue(DateUtils.isSameInstant(cal1, cal2)); [EOL]         try { [EOL]             DateUtils.isSameInstant((Calendar) null, (Calendar) null); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]     } [EOL]      [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testRoundMonth() throws Exception { [EOL]         final int calendarField = Calendar.MONTH; [EOL]         Date roundedUpDate, roundedDownDate, lastRoundedDownDate; [EOL]         Date minDate, maxDate; [EOL]          [EOL]         //month with 28 days [EOL]         roundedUpDate = dateTimeParser.parse("March 1, 2007 0:00:00.000"); [EOL]         roundedDownDate = dateTimeParser.parse("February 1, 2007 0:00:00.000"); [EOL]         lastRoundedDownDate = dateTimeParser.parse("February 14, 2007 23:59:59.999"); [EOL]         baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate,  calendarField); [EOL]  [EOL]         //month with 29 days [EOL]         roundedUpDate = dateTimeParser.parse("March 1, 2008 0:00:00.000"); [EOL]         roundedDownDate = dateTimeParser.parse("February 1, 2008 0:00:00.000"); [EOL]         lastRoundedDownDate = dateTimeParser.parse("February 15, 2008 23:59:59.999"); [EOL]         baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate,  calendarField); [EOL]          [EOL]         //month with 30 days [EOL]         roundedUpDate = dateTimeParser.parse("May 1, 2008 0:00:00.000"); [EOL]         roundedDownDate = dateTimeParser
@Test [EOL]     public void testCeil() throws Exception { [EOL]         // test javadoc [EOL]         assertEquals("ceiling javadoc-1 failed", [EOL]                 dateTimeParser.parse("March 28, 2002 14:00:00.000"), [EOL]                 DateUtils.ceiling( [EOL]                     dateTimeParser.parse("March 28, 2002 13:45:01.231"), [EOL]                 Calendar.HOUR)); [EOL]         assertEquals("ceiling javadoc-2 failed", [EOL]                 dateTimeParser.parse("April 1, 2002 00:00:00.000"), [EOL]                 DateUtils.ceiling( [EOL]                     dateTimeParser.parse("March 28, 2002 13:45:01.231"), [EOL]                 Calendar.MONTH)); [EOL]  [EOL]         // tests public static Date ceiling(Date date, int field) [EOL]         assertEquals("ceiling year-1 failed", [EOL]                 dateParser.parse("January 1, 2003"), [EOL]                 DateUtils.ceiling(date1, Calendar.YEAR)); [EOL]         assertEquals("ceiling year-2 failed", [EOL
@Test [EOL]     public void testTruncateSemiMonth() throws Exception { [EOL]         final int calendarField = DateUtils.SEMI_MONTH; [EOL]         Date truncatedDate, lastTruncateDate; [EOL]          [EOL]         //month with 28 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 1, 2007 0:00:00.000"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 15, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 28 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 16, 2007 0:00:00.000"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 28, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 29 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 1, 2008 0:00:00.000"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 15, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 29 days (2) [EOL]      
@Test [EOL]     public void testTruncateSemiMonth() throws Exception { [EOL]         final int calendarField = DateUtils.SEMI_MONTH; [EOL]         Date truncatedDate, lastTruncateDate; [EOL]          [EOL]         //month with 28 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 1, 2007 0:00:00.000"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 15, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 28 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 16, 2007 0:00:00.000"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 28, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 29 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 1, 2008 0:00:00.000"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 15, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 29 days (2) [EOL]      
@Test [EOL]     public void testTruncateSemiMonth() throws Exception { [EOL]         final int calendarField = DateUtils.SEMI_MONTH; [EOL]         Date truncatedDate, lastTruncateDate; [EOL]          [EOL]         //month with 28 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 1, 2007 0:00:00.000"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 15, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 28 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 16, 2007 0:00:00.000"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 28, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 29 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 1, 2008 0:00:00.000"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 15, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 29 days (2) [EOL]      
@Test [EOL]     public void testTruncateSemiMonth() throws Exception { [EOL]         final int calendarField = DateUtils.SEMI_MONTH; [EOL]         Date truncatedDate, lastTruncateDate; [EOL]          [EOL]         //month with 28 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 1, 2007 0:00:00.000"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 15, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 28 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 16, 2007 0:00:00.000"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 28, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 29 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 1, 2008 0:00:00.000"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 15, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 29 days (2) [EOL]      
@Test [EOL]     public void testTruncateSemiMonth() throws Exception { [EOL]         final int calendarField = DateUtils.SEMI_MONTH; [EOL]         Date truncatedDate, lastTruncateDate; [EOL]          [EOL]         //month with 28 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 1, 2007 0:00:00.000"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 15, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 28 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 16, 2007 0:00:00.000"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 28, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 29 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 1, 2008 0:00:00.000"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 15, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 29 days (2) [EOL]      
@Test [EOL]     public void testTruncateSemiMonth() throws Exception { [EOL]         final int calendarField = DateUtils.SEMI_MONTH; [EOL]         Date truncatedDate, lastTruncateDate; [EOL]          [EOL]         //month with 28 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 1, 2007 0:00:00.000"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 15, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 28 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 16, 2007 0:00:00.000"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 28, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 29 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 1, 2008 0:00:00.000"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 15, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 29 days (2) [EOL]      
@Test [EOL]     public void testTruncateSemiMonth() throws Exception { [EOL]         final int calendarField = DateUtils.SEMI_MONTH; [EOL]         Date truncatedDate, lastTruncateDate; [EOL]          [EOL]         //month with 28 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 1, 2007 0:00:00.000"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 15, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 28 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 16, 2007 0:00:00.000"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 28, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 29 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 1, 2008 0:00:00.000"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 15, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 29 days (2) [EOL]      
@Test [EOL]     public void testIteratorEx() throws Exception { [EOL]         try { [EOL]             DateUtils.iterator(Calendar.getInstance(), -9999); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             DateUtils.iterator((Date) null, DateUtils.RANGE_WEEK_CENTER); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             DateUtils.iterator((Calendar) null, DateUtils.RANGE_WEEK_CENTER); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             DateUtils.iterator((Object) null, DateUtils.RANGE_WEEK_CENTER); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             DateUtils.iterator("", DateUtils.RANGE_WEEK_CENTER); [EOL]             fail(); [EOL]         } catch (final ClassCastException ex) {} [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the calendar iterator for
@Test [EOL]     public void testWeekIterator() throws Exception { [EOL]         final Calendar now = Calendar.getInstance(); [EOL]         for (int i = 0; i< 7; i++) { [EOL]             final Calendar today = DateUtils.truncate(now, Calendar.DATE); [EOL]             final Calendar sunday = DateUtils.truncate(now, Calendar.DATE); [EOL]             sunday.add(Calendar.DATE, 1 - sunday.get(Calendar.DAY_OF_WEEK)); [EOL]             final Calendar monday = DateUtils.truncate(now, Calendar.DATE); [EOL]             if (monday.get(Calendar.DAY_OF_WEEK) == 1) { [EOL]                 //This is sunday... roll back 6 days [EOL]                 monday.add(Calendar.DATE, -6); [EOL]             } else { [EOL]                 monday.add(Calendar.DATE, 2 - monday.get(Calendar.DAY_OF_WEEK)); [EOL]             } [EOL]             final Calendar centered = DateUtils.truncate(now, Calendar.DATE); [EOL]             centered.add(Calendar.DATE, -3); [EOL]              [EOL]           
@Test [EOL]     public void testWeekIterator() throws Exception { [EOL]         final Calendar now = Calendar.getInstance(); [EOL]         for (int i = 0; i< 7; i++) { [EOL]             final Calendar today = DateUtils.truncate(now, Calendar.DATE); [EOL]             final Calendar sunday = DateUtils.truncate(now, Calendar.DATE); [EOL]             sunday.add(Calendar.DATE, 1 - sunday.get(Calendar.DAY_OF_WEEK)); [EOL]             final Calendar monday = DateUtils.truncate(now, Calendar.DATE); [EOL]             if (monday.get(Calendar.DAY_OF_WEEK) == 1) { [EOL]                 //This is sunday... roll back 6 days [EOL]                 monday.add(Calendar.DATE, -6); [EOL]             } else { [EOL]                 monday.add(Calendar.DATE, 2 - monday.get(Calendar.DAY_OF_WEEK)); [EOL]             } [EOL]             final Calendar centered = DateUtils.truncate(now, Calendar.DATE); [EOL]             centered.add(Calendar.DATE, -3); [EOL]              [EOL]           
@Test [EOL]     public void testWeekIterator() throws Exception { [EOL]         final Calendar now = Calendar.getInstance(); [EOL]         for (int i = 0; i< 7; i++) { [EOL]             final Calendar today = DateUtils.truncate(now, Calendar.DATE); [EOL]             final Calendar sunday = DateUtils.truncate(now, Calendar.DATE); [EOL]             sunday.add(Calendar.DATE, 1 - sunday.get(Calendar.DAY_OF_WEEK)); [EOL]             final Calendar monday = DateUtils.truncate(now, Calendar.DATE); [EOL]             if (monday.get(Calendar.DAY_OF_WEEK) == 1) { [EOL]                 //This is sunday... roll back 6 days [EOL]                 monday.add(Calendar.DATE, -6); [EOL]             } else { [EOL]                 monday.add(Calendar.DATE, 2 - monday.get(Calendar.DAY_OF_WEEK)); [EOL]             } [EOL]             final Calendar centered = DateUtils.truncate(now, Calendar.DATE); [EOL]             centered.add(Calendar.DATE, -3); [EOL]              [EOL]           
@Test [EOL]     public void testMonthIterator() throws Exception { [EOL]         Iterator<?> it = DateUtils.iterator(date1, DateUtils.RANGE_MONTH_SUNDAY); [EOL]         assertWeekIterator(it, [EOL]                 dateParser.parse("January 27, 2002"), [EOL]                 dateParser.parse("March 2, 2002")); [EOL]  [EOL]         it = DateUtils.iterator(date1, DateUtils.RANGE_MONTH_MONDAY); [EOL]         assertWeekIterator(it, [EOL]                 dateParser.parse("January 28, 2002"), [EOL]                 dateParser.parse("March 3, 2002")); [EOL]  [EOL]         it = DateUtils.iterator(date2, DateUtils.RANGE_MONTH_SUNDAY); [EOL]         assertWeekIterator(it, [EOL]                 dateParser.parse("October 28, 2001"), [EOL]                 dateParser.parse("December 1, 2001")); [EOL]  [EOL]         it = DateUtils.iterator(date2, DateUtils.RANGE_MONTH_MONDAY); [EOL]         assertWeekIterator(it, [EOL]                 dateParser.parse("October 29, 2001"), [EOL]                 dateParser.parse("December 2
@Test [EOL]     public void testMonthIterator() throws Exception { [EOL]         Iterator<?> it = DateUtils.iterator(date1, DateUtils.RANGE_MONTH_SUNDAY); [EOL]         assertWeekIterator(it, [EOL]                 dateParser.parse("January 27, 2002"), [EOL]                 dateParser.parse("March 2, 2002")); [EOL]  [EOL]         it = DateUtils.iterator(date1, DateUtils.RANGE_MONTH_MONDAY); [EOL]         assertWeekIterator(it, [EOL]                 dateParser.parse("January 28, 2002"), [EOL]                 dateParser.parse("March 3, 2002")); [EOL]  [EOL]         it = DateUtils.iterator(date2, DateUtils.RANGE_MONTH_SUNDAY); [EOL]         assertWeekIterator(it, [EOL]                 dateParser.parse("October 28, 2001"), [EOL]                 dateParser.parse("December 1, 2001")); [EOL]  [EOL]         it = DateUtils.iterator(date2, DateUtils.RANGE_MONTH_MONDAY); [EOL]         assertWeekIterator(it, [EOL]                 dateParser.parse("October 29, 2001"), [EOL]                 dateParser.parse("December 2
@Test [EOL]     public void testMonthIterator() throws Exception { [EOL]         Iterator<?> it = DateUtils.iterator(date1, DateUtils.RANGE_MONTH_SUNDAY); [EOL]         assertWeekIterator(it, [EOL]                 dateParser.parse("January 27, 2002"), [EOL]                 dateParser.parse("March 2, 2002")); [EOL]  [EOL]         it = DateUtils.iterator(date1, DateUtils.RANGE_MONTH_MONDAY); [EOL]         assertWeekIterator(it, [EOL]                 dateParser.parse("January 28, 2002"), [EOL]                 dateParser.parse("March 3, 2002")); [EOL]  [EOL]         it = DateUtils.iterator(date2, DateUtils.RANGE_MONTH_SUNDAY); [EOL]         assertWeekIterator(it, [EOL]                 dateParser.parse("October 28, 2001"), [EOL]                 dateParser.parse("December 1, 2001")); [EOL]  [EOL]         it = DateUtils.iterator(date2, DateUtils.RANGE_MONTH_MONDAY); [EOL]         assertWeekIterator(it, [EOL]                 dateParser.parse("October 29, 2001"), [EOL]                 dateParser.parse("December 2
@Test [EOL]     public void testWeekIterator() throws Exception { [EOL]         final Calendar now = Calendar.getInstance(); [EOL]         for (int i = 0; i< 7; i++) { [EOL]             final Calendar today = DateUtils.truncate(now, Calendar.DATE); [EOL]             final Calendar sunday = DateUtils.truncate(now, Calendar.DATE); [EOL]             sunday.add(Calendar.DATE, 1 - sunday.get(Calendar.DAY_OF_WEEK)); [EOL]             final Calendar monday = DateUtils.truncate(now, Calendar.DATE); [EOL]             if (monday.get(Calendar.DAY_OF_WEEK) == 1) { [EOL]                 //This is sunday... roll back 6 days [EOL]                 monday.add(Calendar.DATE, -6); [EOL]             } else { [EOL]                 monday.add(Calendar.DATE, 2 - monday.get(Calendar.DAY_OF_WEEK)); [EOL]             } [EOL]             final Calendar centered = DateUtils.truncate(now, Calendar.DATE); [EOL]             centered.add(Calendar.DATE, -3); [EOL]              [EOL]           
@Test [EOL]     public void testMonthIterator() throws Exception { [EOL]         Iterator<?> it = DateUtils.iterator(date1, DateUtils.RANGE_MONTH_SUNDAY); [EOL]         assertWeekIterator(it, [EOL]                 dateParser.parse("January 27, 2002"), [EOL]                 dateParser.parse("March 2, 2002")); [EOL]  [EOL]         it = DateUtils.iterator(date1, DateUtils.RANGE_MONTH_MONDAY); [EOL]         assertWeekIterator(it, [EOL]                 dateParser.parse("January 28, 2002"), [EOL]                 dateParser.parse("March 3, 2002")); [EOL]  [EOL]         it = DateUtils.iterator(date2, DateUtils.RANGE_MONTH_SUNDAY); [EOL]         assertWeekIterator(it, [EOL]                 dateParser.parse("October 28, 2001"), [EOL]                 dateParser.parse("December 1, 2001")); [EOL]  [EOL]         it = DateUtils.iterator(date2, DateUtils.RANGE_MONTH_MONDAY); [EOL]         assertWeekIterator(it, [EOL]                 dateParser.parse("October 29, 2001"), [EOL]                 dateParser.parse("December 2
@Test [EOL]     public void testMonthIterator() throws Exception { [EOL]         Iterator<?> it = DateUtils.iterator(date1, DateUtils.RANGE_MONTH_SUNDAY); [EOL]         assertWeekIterator(it, [EOL]                 dateParser.parse("January 27, 2002"), [EOL]                 dateParser.parse("March 2, 2002")); [EOL]  [EOL]         it = DateUtils.iterator(date1, DateUtils.RANGE_MONTH_MONDAY); [EOL]         assertWeekIterator(it, [EOL]                 dateParser.parse("January 28, 2002"), [EOL]                 dateParser.parse("March 3, 2002")); [EOL]  [EOL]         it = DateUtils.iterator(date2, DateUtils.RANGE_MONTH_SUNDAY); [EOL]         assertWeekIterator(it, [EOL]                 dateParser.parse("October 28, 2001"), [EOL]                 dateParser.parse("December 1, 2001")); [EOL]  [EOL]         it = DateUtils.iterator(date2, DateUtils.RANGE_MONTH_MONDAY); [EOL]         assertWeekIterator(it, [EOL]                 dateParser.parse("October 29, 2001"), [EOL]                 dateParser.parse("December 2
@Test [EOL]     public void testMonthIterator() throws Exception { [EOL]         Iterator<?> it = DateUtils.iterator(date1, DateUtils.RANGE_MONTH_SUNDAY); [EOL]         assertWeekIterator(it, [EOL]                 dateParser.parse("January 27, 2002"), [EOL]                 dateParser.parse("March 2, 2002")); [EOL]  [EOL]         it = DateUtils.iterator(date1, DateUtils.RANGE_MONTH_MONDAY); [EOL]         assertWeekIterator(it, [EOL]                 dateParser.parse("January 28, 2002"), [EOL]                 dateParser.parse("March 3, 2002")); [EOL]  [EOL]         it = DateUtils.iterator(date2, DateUtils.RANGE_MONTH_SUNDAY); [EOL]         assertWeekIterator(it, [EOL]                 dateParser.parse("October 28, 2001"), [EOL]                 dateParser.parse("December 1, 2001")); [EOL]  [EOL]         it = DateUtils.iterator(date2, DateUtils.RANGE_MONTH_MONDAY); [EOL]         assertWeekIterator(it, [EOL]                 dateParser.parse("October 29, 2001"), [EOL]                 dateParser.parse("December 2
@Test [EOL]     public void testMonthIterator() throws Exception { [EOL]         Iterator<?> it = DateUtils.iterator(date1, DateUtils.RANGE_MONTH_SUNDAY); [EOL]         assertWeekIterator(it, [EOL]                 dateParser.parse("January 27, 2002"), [EOL]                 dateParser.parse("March 2, 2002")); [EOL]  [EOL]         it = DateUtils.iterator(date1, DateUtils.RANGE_MONTH_MONDAY); [EOL]         assertWeekIterator(it, [EOL]                 dateParser.parse("January 28, 2002"), [EOL]                 dateParser.parse("March 3, 2002")); [EOL]  [EOL]         it = DateUtils.iterator(date2, DateUtils.RANGE_MONTH_SUNDAY); [EOL]         assertWeekIterator(it, [EOL]                 dateParser.parse("October 28, 2001"), [EOL]                 dateParser.parse("December 1, 2001")); [EOL]  [EOL]         it = DateUtils.iterator(date2, DateUtils.RANGE_MONTH_MONDAY); [EOL]         assertWeekIterator(it, [EOL]                 dateParser.parse("October 29, 2001"), [EOL]                 dateParser.parse("December 2
@Test [EOL]     public void testMonthIterator() throws Exception { [EOL]         Iterator<?> it = DateUtils.iterator(date1, DateUtils.RANGE_MONTH_SUNDAY); [EOL]         assertWeekIterator(it, [EOL]                 dateParser.parse("January 27, 2002"), [EOL]                 dateParser.parse("March 2, 2002")); [EOL]  [EOL]         it = DateUtils.iterator(date1, DateUtils.RANGE_MONTH_MONDAY); [EOL]         assertWeekIterator(it, [EOL]                 dateParser.parse("January 28, 2002"), [EOL]                 dateParser.parse("March 3, 2002")); [EOL]  [EOL]         it = DateUtils.iterator(date2, DateUtils.RANGE_MONTH_SUNDAY); [EOL]         assertWeekIterator(it, [EOL]                 dateParser.parse("October 28, 2001"), [EOL]                 dateParser.parse("December 1, 2001")); [EOL]  [EOL]         it = DateUtils.iterator(date2, DateUtils.RANGE_MONTH_MONDAY); [EOL]         assertWeekIterator(it, [EOL]                 dateParser.parse("October 29, 2001"), [EOL]                 dateParser.parse("December 2
@Test [EOL]     public void testWeekIterator() throws Exception { [EOL]         final Calendar now = Calendar.getInstance(); [EOL]         for (int i = 0; i< 7; i++) { [EOL]             final Calendar today = DateUtils.truncate(now, Calendar.DATE); [EOL]             final Calendar sunday = DateUtils.truncate(now, Calendar.DATE); [EOL]             sunday.add(Calendar.DATE, 1 - sunday.get(Calendar.DAY_OF_WEEK)); [EOL]             final Calendar monday = DateUtils.truncate(now, Calendar.DATE); [EOL]             if (monday.get(Calendar.DAY_OF_WEEK) == 1) { [EOL]                 //This is sunday... roll back 6 days [EOL]                 monday.add(Calendar.DATE, -6); [EOL]             } else { [EOL]                 monday.add(Calendar.DATE, 2 - monday.get(Calendar.DAY_OF_WEEK)); [EOL]             } [EOL]             final Calendar centered = DateUtils.truncate(now, Calendar.DATE); [EOL]             centered.add(Calendar.DATE, -3); [EOL]              [EOL]           
@Test [EOL]     public void testMinutesOfDayWithDate() { [EOL]         long testResult = DateUtils.getFragmentInMinutes(aDate, Calendar.DATE); [EOL]         final long expectedValue = minutes + ((hours * DateUtils.MILLIS_PER_HOUR))/ DateUtils.MILLIS_PER_MINUTE;  [EOL]         assertEquals(expectedValue,testResult); [EOL]         testResult = DateUtils.getFragmentInMinutes(aDate, Calendar.DAY_OF_YEAR); [EOL]         assertEquals(expectedValue,testResult); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMinutesOfDayWithDate() { [EOL]         long testResult = DateUtils.getFragmentInMinutes(aDate, Calendar.DATE); [EOL]         final long expectedValue = minutes + ((hours * DateUtils.MILLIS_PER_HOUR))/ DateUtils.MILLIS_PER_MINUTE;  [EOL]         assertEquals(expectedValue,testResult); [EOL]         testResult = DateUtils.getFragmentInMinutes(aDate, Calendar.DAY_OF_YEAR); [EOL]         assertEquals(expectedValue,testResult); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMinutesOfDayWithDate() { [EOL]         long testResult = DateUtils.getFragmentInMinutes(aDate, Calendar.DATE); [EOL]         final long expectedValue = minutes + ((hours * DateUtils.MILLIS_PER_HOUR))/ DateUtils.MILLIS_PER_MINUTE;  [EOL]         assertEquals(expectedValue,testResult); [EOL]         testResult = DateUtils.getFragmentInMinutes(aDate, Calendar.DAY_OF_YEAR); [EOL]         assertEquals(expectedValue,testResult); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMinutesOfDayWithDate() { [EOL]         long testResult = DateUtils.getFragmentInMinutes(aDate, Calendar.DATE); [EOL]         final long expectedValue = minutes + ((hours * DateUtils.MILLIS_PER_HOUR))/ DateUtils.MILLIS_PER_MINUTE;  [EOL]         assertEquals(expectedValue,testResult); [EOL]         testResult = DateUtils.getFragmentInMinutes(aDate, Calendar.DAY_OF_YEAR); [EOL]         assertEquals(expectedValue,testResult); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSerialization() { [EOL]         CharRange range = CharRange.is('a'); [EOL]         assertEquals(range, SerializationUtils.clone(range));  [EOL]         range = CharRange.isIn('a', 'e'); [EOL]         assertEquals(range, SerializationUtils.clone(range));  [EOL]         range = CharRange.isNotIn('a', 'e'); [EOL]         assertEquals(range, SerializationUtils.clone(range));  [EOL]     } [EOL]  [EOL] } [EOL]
@Test [EOL]     public void testIterator() { [EOL]         final CharRange a = CharRange.is('a'); [EOL]         final CharRange ad = CharRange.isIn('a', 'd'); [EOL]         final CharRange nota = CharRange.isNot('a'); [EOL]         final CharRange emptySet = CharRange.isNotIn((char) 0, Character.MAX_VALUE); [EOL]         final CharRange notFirst = CharRange.isNotIn((char) 1, Character.MAX_VALUE); [EOL]         final CharRange notLast = CharRange.isNotIn((char) 0, (char) (Character.MAX_VALUE - 1)); [EOL]  [EOL]         final Iterator<Character> aIt = a.iterator(); [EOL]         assertNotNull(aIt); [EOL]         assertTrue(aIt.hasNext()); [EOL]         assertEquals(Character.valueOf('a'), aIt.next()); [EOL]         assertFalse(aIt.hasNext()); [EOL]  [EOL]         final Iterator<Character> adIt = ad.iterator(); [EOL]         assertNotNull(adIt); [EOL]         assertTrue(adIt.hasNext()); [EOL]         assertEquals(Character.valueOf('a'), adIt.next()); [EOL]         assertEquals(Character.valueOf('b'), adIt.next()); [EOL]         assertEquals(Character.valueOf('c'), adIt.next()); [EOL]         assertEquals(Character.valueOf
@Test [EOL]     public void testIterator() { [EOL]         final CharRange a = CharRange.is('a'); [EOL]         final CharRange ad = CharRange.isIn('a', 'd'); [EOL]         final CharRange nota = CharRange.isNot('a'); [EOL]         final CharRange emptySet = CharRange.isNotIn((char) 0, Character.MAX_VALUE); [EOL]         final CharRange notFirst = CharRange.isNotIn((char) 1, Character.MAX_VALUE); [EOL]         final CharRange notLast = CharRange.isNotIn((char) 0, (char) (Character.MAX_VALUE - 1)); [EOL]  [EOL]         final Iterator<Character> aIt = a.iterator(); [EOL]         assertNotNull(aIt); [EOL]         assertTrue(aIt.hasNext()); [EOL]         assertEquals(Character.valueOf('a'), aIt.next()); [EOL]         assertFalse(aIt.hasNext()); [EOL]  [EOL]         final Iterator<Character> adIt = ad.iterator(); [EOL]         assertNotNull(adIt); [EOL]         assertTrue(adIt.hasNext()); [EOL]         assertEquals(Character.valueOf('a'), adIt.next()); [EOL]         assertEquals(Character.valueOf('b'), adIt.next()); [EOL]         assertEquals(Character.valueOf('c'), adIt.next()); [EOL]         assertEquals(Character.valueOf
@Test [EOL]     public void testIterator() { [EOL]         final CharRange a = CharRange.is('a'); [EOL]         final CharRange ad = CharRange.isIn('a', 'd'); [EOL]         final CharRange nota = CharRange.isNot('a'); [EOL]         final CharRange emptySet = CharRange.isNotIn((char) 0, Character.MAX_VALUE); [EOL]         final CharRange notFirst = CharRange.isNotIn((char) 1, Character.MAX_VALUE); [EOL]         final CharRange notLast = CharRange.isNotIn((char) 0, (char) (Character.MAX_VALUE - 1)); [EOL]  [EOL]         final Iterator<Character> aIt = a.iterator(); [EOL]         assertNotNull(aIt); [EOL]         assertTrue(aIt.hasNext()); [EOL]         assertEquals(Character.valueOf('a'), aIt.next()); [EOL]         assertFalse(aIt.hasNext()); [EOL]  [EOL]         final Iterator<Character> adIt = ad.iterator(); [EOL]         assertNotNull(adIt); [EOL]         assertTrue(adIt.hasNext()); [EOL]         assertEquals(Character.valueOf('a'), adIt.next()); [EOL]         assertEquals(Character.valueOf('b'), adIt.next()); [EOL]         assertEquals(Character.valueOf('c'), adIt.next()); [EOL]         assertEquals(Character.valueOf
@Test [EOL]     public void testIterator() { [EOL]         final CharRange a = CharRange.is('a'); [EOL]         final CharRange ad = CharRange.isIn('a', 'd'); [EOL]         final CharRange nota = CharRange.isNot('a'); [EOL]         final CharRange emptySet = CharRange.isNotIn((char) 0, Character.MAX_VALUE); [EOL]         final CharRange notFirst = CharRange.isNotIn((char) 1, Character.MAX_VALUE); [EOL]         final CharRange notLast = CharRange.isNotIn((char) 0, (char) (Character.MAX_VALUE - 1)); [EOL]  [EOL]         final Iterator<Character> aIt = a.iterator(); [EOL]         assertNotNull(aIt); [EOL]         assertTrue(aIt.hasNext()); [EOL]         assertEquals(Character.valueOf('a'), aIt.next()); [EOL]         assertFalse(aIt.hasNext()); [EOL]  [EOL]         final Iterator<Character> adIt = ad.iterator(); [EOL]         assertNotNull(adIt); [EOL]         assertTrue(adIt.hasNext()); [EOL]         assertEquals(Character.valueOf('a'), adIt.next()); [EOL]         assertEquals(Character.valueOf('b'), adIt.next()); [EOL]         assertEquals(Character.valueOf('c'), adIt.next()); [EOL]         assertEquals(Character.valueOf
@Test [EOL]     public void testIterator() { [EOL]         final CharRange a = CharRange.is('a'); [EOL]         final CharRange ad = CharRange.isIn('a', 'd'); [EOL]         final CharRange nota = CharRange.isNot('a'); [EOL]         final CharRange emptySet = CharRange.isNotIn((char) 0, Character.MAX_VALUE); [EOL]         final CharRange notFirst = CharRange.isNotIn((char) 1, Character.MAX_VALUE); [EOL]         final CharRange notLast = CharRange.isNotIn((char) 0, (char) (Character.MAX_VALUE - 1)); [EOL]  [EOL]         final Iterator<Character> aIt = a.iterator(); [EOL]         assertNotNull(aIt); [EOL]         assertTrue(aIt.hasNext()); [EOL]         assertEquals(Character.valueOf('a'), aIt.next()); [EOL]         assertFalse(aIt.hasNext()); [EOL]  [EOL]         final Iterator<Character> adIt = ad.iterator(); [EOL]         assertNotNull(adIt); [EOL]         assertTrue(adIt.hasNext()); [EOL]         assertEquals(Character.valueOf('a'), adIt.next()); [EOL]         assertEquals(Character.valueOf('b'), adIt.next()); [EOL]         assertEquals(Character.valueOf('c'), adIt.next()); [EOL]         assertEquals(Character.valueOf
@Test [EOL]     public void testIterator() { [EOL]         final CharRange a = CharRange.is('a'); [EOL]         final CharRange ad = CharRange.isIn('a', 'd'); [EOL]         final CharRange nota = CharRange.isNot('a'); [EOL]         final CharRange emptySet = CharRange.isNotIn((char) 0, Character.MAX_VALUE); [EOL]         final CharRange notFirst = CharRange.isNotIn((char) 1, Character.MAX_VALUE); [EOL]         final CharRange notLast = CharRange.isNotIn((char) 0, (char) (Character.MAX_VALUE - 1)); [EOL]  [EOL]         final Iterator<Character> aIt = a.iterator(); [EOL]         assertNotNull(aIt); [EOL]         assertTrue(aIt.hasNext()); [EOL]         assertEquals(Character.valueOf('a'), aIt.next()); [EOL]         assertFalse(aIt.hasNext()); [EOL]  [EOL]         final Iterator<Character> adIt = ad.iterator(); [EOL]         assertNotNull(adIt); [EOL]         assertTrue(adIt.hasNext()); [EOL]         assertEquals(Character.valueOf('a'), adIt.next()); [EOL]         assertEquals(Character.valueOf('b'), adIt.next()); [EOL]         assertEquals(Character.valueOf('c'), adIt.next()); [EOL]         assertEquals(Character.valueOf
@Test [EOL]     public void testReadNamedStaticField() throws Exception { [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(Foo.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PubliclyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PrivatelyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PublicChild.class, "VALUE")); [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(null, "none"); [EOL]             fail("null class should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(Foo.class, null); [EOL]             fail("null field name should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(Foo.class, "does_not_exist");
@Test [EOL]     public void testReadNamedStaticField() throws Exception { [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(Foo.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PubliclyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PrivatelyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PublicChild.class, "VALUE")); [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(null, "none"); [EOL]             fail("null class should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(Foo.class, null); [EOL]             fail("null field name should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(Foo.class, "does_not_exist");
@Test [EOL]     public void testInvokeMethod() throws Exception { [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 (Object[]) ArrayUtils.EMPTY_CLASS_ARRAY)); [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 (Object[]) null)); [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo",  [EOL]                 (Object[]) null, (Class<?>[]) null)); [EOL]         assertEquals("foo(String)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 "")); [EOL]         assertEquals("foo(Object)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 new Object())); [EOL]         assertEquals("foo(Object)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 Boolean.TRUE)); [EOL]         assertEquals("foo(Integer)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.INTEGER_ONE)); [EOL]         assertEquals("foo(int)", MethodUtils.invokeMethod(testBean, "foo", [EOL]       
@Test [EOL]     public void testInvokeMethod() throws Exception { [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 (Object[]) ArrayUtils.EMPTY_CLASS_ARRAY)); [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 (Object[]) null)); [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo",  [EOL]                 (Object[]) null, (Class<?>[]) null)); [EOL]         assertEquals("foo(String)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 "")); [EOL]         assertEquals("foo(Object)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 new Object())); [EOL]         assertEquals("foo(Object)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 Boolean.TRUE)); [EOL]         assertEquals("foo(Integer)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.INTEGER_ONE)); [EOL]         assertEquals("foo(int)", MethodUtils.invokeMethod(testBean, "foo", [EOL]       
@Test [EOL]     public void testInvokeMethod() throws Exception { [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 (Object[]) ArrayUtils.EMPTY_CLASS_ARRAY)); [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 (Object[]) null)); [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo",  [EOL]                 (Object[]) null, (Class<?>[]) null)); [EOL]         assertEquals("foo(String)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 "")); [EOL]         assertEquals("foo(Object)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 new Object())); [EOL]         assertEquals("foo(Object)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 Boolean.TRUE)); [EOL]         assertEquals("foo(Integer)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.INTEGER_ONE)); [EOL]         assertEquals("foo(int)", MethodUtils.invokeMethod(testBean, "foo", [EOL]       
@Test [EOL]     public void testGetMatchingAccessibleMethod() throws Exception { [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 ArrayUtils.EMPTY_CLASS_ARRAY, ArrayUtils.EMPTY_CLASS_ARRAY); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, null, [EOL]                 ArrayUtils.EMPTY_CLASS_ARRAY); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 singletonArray(String.class), singletonArray(String.class)); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 singletonArray(Object.class), singletonArray(Object.class)); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 singletonArray(Boolean.class), singletonArray(Object.class)); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 singletonArray(Byte.class), singletonArray(Integer.TYPE)); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 singletonArray(Byte.TYPE), singletonArray(Integer.TYPE)); [EOL]         expectMatchingAccessibleConstructorParameter
@Test [EOL]     public void testGetMatchingAccessibleMethod() throws Exception { [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 ArrayUtils.EMPTY_CLASS_ARRAY, ArrayUtils.EMPTY_CLASS_ARRAY); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, null, [EOL]                 ArrayUtils.EMPTY_CLASS_ARRAY); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 singletonArray(String.class), singletonArray(String.class)); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 singletonArray(Object.class), singletonArray(Object.class)); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 singletonArray(Boolean.class), singletonArray(Object.class)); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 singletonArray(Byte.class), singletonArray(Integer.TYPE)); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 singletonArray(Byte.TYPE), singletonArray(Integer.TYPE)); [EOL]         expectMatchingAccessibleConstructorParameter
@Test [EOL]     public void testGetMatchingAccessibleMethod() throws Exception { [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 ArrayUtils.EMPTY_CLASS_ARRAY, ArrayUtils.EMPTY_CLASS_ARRAY); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, null, [EOL]                 ArrayUtils.EMPTY_CLASS_ARRAY); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 singletonArray(String.class), singletonArray(String.class)); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 singletonArray(Object.class), singletonArray(Object.class)); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 singletonArray(Boolean.class), singletonArray(Object.class)); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 singletonArray(Byte.class), singletonArray(Integer.TYPE)); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 singletonArray(Byte.TYPE), singletonArray(Integer.TYPE)); [EOL]         expectMatchingAccessibleConstructorParameter
@Test [EOL]     public void testGetMatchingAccessibleMethod() throws Exception { [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 ArrayUtils.EMPTY_CLASS_ARRAY, ArrayUtils.EMPTY_CLASS_ARRAY); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, null, [EOL]                 ArrayUtils.EMPTY_CLASS_ARRAY); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 singletonArray(String.class), singletonArray(String.class)); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 singletonArray(Object.class), singletonArray(Object.class)); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 singletonArray(Boolean.class), singletonArray(Object.class)); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 singletonArray(Byte.class), singletonArray(Integer.TYPE)); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 singletonArray(Byte.TYPE), singletonArray(Integer.TYPE)); [EOL]         expectMatchingAccessibleConstructorParameter
@Test [EOL]     public void testGetMatchingAccessibleMethod() throws Exception { [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 ArrayUtils.EMPTY_CLASS_ARRAY, ArrayUtils.EMPTY_CLASS_ARRAY); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, null, [EOL]                 ArrayUtils.EMPTY_CLASS_ARRAY); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 singletonArray(String.class), singletonArray(String.class)); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 singletonArray(Object.class), singletonArray(Object.class)); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 singletonArray(Boolean.class), singletonArray(Object.class)); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 singletonArray(Byte.class), singletonArray(Integer.TYPE)); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 singletonArray(Byte.TYPE), singletonArray(Integer.TYPE)); [EOL]         expectMatchingAccessibleConstructorParameter
@Test [EOL]     public void testGetMatchingAccessibleMethod() throws Exception { [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 ArrayUtils.EMPTY_CLASS_ARRAY, ArrayUtils.EMPTY_CLASS_ARRAY); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, null, [EOL]                 ArrayUtils.EMPTY_CLASS_ARRAY); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 singletonArray(String.class), singletonArray(String.class)); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 singletonArray(Object.class), singletonArray(Object.class)); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 singletonArray(Boolean.class), singletonArray(Object.class)); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 singletonArray(Byte.class), singletonArray(Integer.TYPE)); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 singletonArray(Byte.TYPE), singletonArray(Integer.TYPE)); [EOL]         expectMatchingAccessibleConstructorParameter
@Test [EOL]     public void testGetMatchingAccessibleMethod() throws Exception { [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 ArrayUtils.EMPTY_CLASS_ARRAY, ArrayUtils.EMPTY_CLASS_ARRAY); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, null, [EOL]                 ArrayUtils.EMPTY_CLASS_ARRAY); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 singletonArray(String.class), singletonArray(String.class)); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 singletonArray(Object.class), singletonArray(Object.class)); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 singletonArray(Boolean.class), singletonArray(Object.class)); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 singletonArray(Byte.class), singletonArray(Integer.TYPE)); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 singletonArray(Byte.TYPE), singletonArray(Integer.TYPE)); [EOL]         expectMatchingAccessibleConstructorParameter
@Test [EOL]     public void testGetMatchingAccessibleMethod() throws Exception { [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 ArrayUtils.EMPTY_CLASS_ARRAY, ArrayUtils.EMPTY_CLASS_ARRAY); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, null, [EOL]                 ArrayUtils.EMPTY_CLASS_ARRAY); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 singletonArray(String.class), singletonArray(String.class)); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 singletonArray(Object.class), singletonArray(Object.class)); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 singletonArray(Boolean.class), singletonArray(Object.class)); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 singletonArray(Byte.class), singletonArray(Integer.TYPE)); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 singletonArray(Byte.TYPE), singletonArray(Integer.TYPE)); [EOL]         expectMatchingAccessibleConstructorParameter
@Test [EOL]     public void testGetMatchingAccessibleMethod() throws Exception { [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 ArrayUtils.EMPTY_CLASS_ARRAY, ArrayUtils.EMPTY_CLASS_ARRAY); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, null, [EOL]                 ArrayUtils.EMPTY_CLASS_ARRAY); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 singletonArray(String.class), singletonArray(String.class)); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 singletonArray(Object.class), singletonArray(Object.class)); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 singletonArray(Boolean.class), singletonArray(Object.class)); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 singletonArray(Byte.class), singletonArray(Integer.TYPE)); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 singletonArray(Byte.TYPE), singletonArray(Integer.TYPE)); [EOL]         expectMatchingAccessibleConstructorParameter
@Test [EOL]     public void testGetMatchingAccessibleMethod() throws Exception { [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 ArrayUtils.EMPTY_CLASS_ARRAY, ArrayUtils.EMPTY_CLASS_ARRAY); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, null, [EOL]                 ArrayUtils.EMPTY_CLASS_ARRAY); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 singletonArray(String.class), singletonArray(String.class)); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 singletonArray(Object.class), singletonArray(Object.class)); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 singletonArray(Boolean.class), singletonArray(Object.class)); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 singletonArray(Byte.class), singletonArray(Integer.TYPE)); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 singletonArray(Byte.TYPE), singletonArray(Integer.TYPE)); [EOL]         expectMatchingAccessibleConstructorParameter
@Test [EOL]     public void testGetMatchingAccessibleMethod() throws Exception { [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 ArrayUtils.EMPTY_CLASS_ARRAY, ArrayUtils.EMPTY_CLASS_ARRAY); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, null, [EOL]                 ArrayUtils.EMPTY_CLASS_ARRAY); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 singletonArray(String.class), singletonArray(String.class)); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 singletonArray(Object.class), singletonArray(Object.class)); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 singletonArray(Boolean.class), singletonArray(Object.class)); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 singletonArray(Byte.class), singletonArray(Integer.TYPE)); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 singletonArray(Byte.TYPE), singletonArray(Integer.TYPE)); [EOL]         expectMatchingAccessibleConstructorParameter
@Test [EOL]     public void testGetMatchingAccessibleMethod() throws Exception { [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 ArrayUtils.EMPTY_CLASS_ARRAY, ArrayUtils.EMPTY_CLASS_ARRAY); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, null, [EOL]                 ArrayUtils.EMPTY_CLASS_ARRAY); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 singletonArray(String.class), singletonArray(String.class)); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 singletonArray(Object.class), singletonArray(Object.class)); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 singletonArray(Boolean.class), singletonArray(Object.class)); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 singletonArray(Byte.class), singletonArray(Integer.TYPE)); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 singletonArray(Byte.TYPE), singletonArray(Integer.TYPE)); [EOL]         expectMatchingAccessibleConstructorParameter
@Test [EOL]     public void testEscapeJson() { [EOL]         assertEquals(null, StringEscapeUtils.escapeJson(null)); [EOL]         try { [EOL]             StringEscapeUtils.ESCAPE_JSON.translate(null, null); [EOL]             fail(); [EOL]         } catch (final IOException ex) { [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) { [EOL]         } [EOL]         try { [EOL]             StringEscapeUtils.ESCAPE_JSON.translate("", null); [EOL]             fail(); [EOL]         } catch (final IOException ex) { [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) { [EOL]         } [EOL]  [EOL]         assertEquals("He didn't say, \\\"stop!\\\"", StringEscapeUtils.escapeJson("He didn't say, \"stop!\"")); [EOL]  [EOL]         String expected = "\\\"foo\\\" isn't \\\"bar\\\". specials: \\b\\r\\n\\f\\t\\\\\\/"; [EOL]         String input ="\"foo\" isn't \"bar\". specials: \b\r\n\f\t\\/"; [EOL]  [EOL]         assertEquals
@Test [EOL]     public void testDeserializeBytesOfNull() throws Exception { [EOL]         final ByteArrayOutputStream streamReal = new ByteArrayOutputStream(); [EOL]         final ObjectOutputStream oos = new ObjectOutputStream(streamReal); [EOL]         oos.writeObject(null); [EOL]         oos.flush(); [EOL]         oos.close(); [EOL]  [EOL]         final Object test = SerializationUtils.deserialize(streamReal.toByteArray()); [EOL]         assertNull(test); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testClone() throws Exception { [EOL]         final Object test = SerializationUtils.clone(iMap); [EOL]         assertNotNull(test); [EOL]         assertTrue(test instanceof HashMap<?,?>); [EOL]         assertTrue(test != iMap); [EOL]         final HashMap<?, ?> testMap = (HashMap<?, ?>) test; [EOL]         assertEquals(iString, testMap.get("FOO")); [EOL]         assertTrue(iString != testMap.get("FOO")); [EOL]         assertEquals(iInteger, testMap.get("BAR")); [EOL]         assertTrue(iInteger != testMap.get("BAR")); [EOL]         assertEquals(iMap, testMap); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testClone() throws Exception { [EOL]         final Object test = SerializationUtils.clone(iMap); [EOL]         assertNotNull(test); [EOL]         assertTrue(test instanceof HashMap<?,?>); [EOL]         assertTrue(test != iMap); [EOL]         final HashMap<?, ?> testMap = (HashMap<?, ?>) test; [EOL]         assertEquals(iString, testMap.get("FOO")); [EOL]         assertTrue(iString != testMap.get("FOO")); [EOL]         assertEquals(iInteger, testMap.get("BAR")); [EOL]         assertTrue(iInteger != testMap.get("BAR")); [EOL]         assertEquals(iMap, testMap); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testClone() throws Exception { [EOL]         final Object test = SerializationUtils.clone(iMap); [EOL]         assertNotNull(test); [EOL]         assertTrue(test instanceof HashMap<?,?>); [EOL]         assertTrue(test != iMap); [EOL]         final HashMap<?, ?> testMap = (HashMap<?, ?>) test; [EOL]         assertEquals(iString, testMap.get("FOO")); [EOL]         assertTrue(iString != testMap.get("FOO")); [EOL]         assertEquals(iInteger, testMap.get("BAR")); [EOL]         assertTrue(iInteger != testMap.get("BAR")); [EOL]         assertEquals(iMap, testMap); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testClone() throws Exception { [EOL]         final Object test = SerializationUtils.clone(iMap); [EOL]         assertNotNull(test); [EOL]         assertTrue(test instanceof HashMap<?,?>); [EOL]         assertTrue(test != iMap); [EOL]         final HashMap<?, ?> testMap = (HashMap<?, ?>) test; [EOL]         assertEquals(iString, testMap.get("FOO")); [EOL]         assertTrue(iString != testMap.get("FOO")); [EOL]         assertEquals(iInteger, testMap.get("BAR")); [EOL]         assertTrue(iInteger != testMap.get("BAR")); [EOL]         assertEquals(iMap, testMap); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testClone() throws Exception { [EOL]         final Object test = SerializationUtils.clone(iMap); [EOL]         assertNotNull(test); [EOL]         assertTrue(test instanceof HashMap<?,?>); [EOL]         assertTrue(test != iMap); [EOL]         final HashMap<?, ?> testMap = (HashMap<?, ?>) test; [EOL]         assertEquals(iString, testMap.get("FOO")); [EOL]         assertTrue(iString != testMap.get("FOO")); [EOL]         assertEquals(iInteger, testMap.get("BAR")); [EOL]         assertTrue(iInteger != testMap.get("BAR")); [EOL]         assertEquals(iMap, testMap); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void test_toStringExclude() { [EOL]         final String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), SECRET_FIELD); [EOL]         this.validateSecretFieldAbsent(toString); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void test_toStringExclude() { [EOL]         final String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), SECRET_FIELD); [EOL]         this.validateSecretFieldAbsent(toString); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void test_toStringExclude() { [EOL]         final String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), SECRET_FIELD); [EOL]         this.validateSecretFieldAbsent(toString); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void test_toStringExclude() { [EOL]         final String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), SECRET_FIELD); [EOL]         this.validateSecretFieldAbsent(toString); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReflectionFloatArray() { [EOL]         float[] array = new float[] { 1.0f, 2.9876f, -3.00001f, 4.3f }; [EOL]         final String baseStr = this.toBaseString(array); [EOL]         assertEquals(baseStr + "[{1.0,2.9876,-3.00001,4.3}]", ToStringBuilder.reflectionToString(array)); [EOL]         array = null; [EOL]         assertReflectionArray("<null>", array); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGet() throws ConcurrentException { [EOL]         assertEquals("Wrong object", VALUE, init.get()); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests equals() if the expected result is true. [EOL]      */ [EOL]
@Test [EOL]     public void testGet() throws ConcurrentException { [EOL]         assertEquals("Wrong object", VALUE, init.get()); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests equals() if the expected result is true. [EOL]      */ [EOL]
@Test [EOL]     public void testGet() throws ConcurrentException { [EOL]         assertEquals("Wrong object", VALUE, init.get()); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests equals() if the expected result is true. [EOL]      */ [EOL]
@Test [EOL]     public void testGet() throws ConcurrentException { [EOL]         assertEquals("Wrong object", VALUE, init.get()); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests equals() if the expected result is true. [EOL]      */ [EOL]
@Test [EOL]     public void testGet() throws ConcurrentException { [EOL]         assertEquals("Wrong object", VALUE, init.get()); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests equals() if the expected result is true. [EOL]      */ [EOL]
@Test [EOL]     public void testGet() throws ConcurrentException { [EOL]         assertEquals("Wrong object", VALUE, init.get()); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests equals() if the expected result is true. [EOL]      */ [EOL]
@Test [EOL]     public void testEquals() throws Exception { [EOL]         assertEquals(MutableTriple.of(null, "foo", "baz"), MutableTriple.of(null, "foo", "baz")); [EOL]         assertFalse(MutableTriple.of("foo", 0, Boolean.TRUE).equals(MutableTriple.of("foo", null, Boolean.TRUE))); [EOL]         assertFalse(MutableTriple.of("foo", "bar", "baz").equals(MutableTriple.of("xyz", "bar", "baz"))); [EOL]         assertFalse(MutableTriple.of("foo", "bar", "baz").equals(MutableTriple.of("foo", "bar", "blo"))); [EOL]  [EOL]         final MutableTriple<String, String, String> p = MutableTriple.of("foo", "bar", "baz"); [EOL]         assertTrue(p.equals(p)); [EOL]         assertFalse(p.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testToUnicodeEscaped_char() { [EOL]         assertEquals("\\u0041", CharUtils.unicodeEscaped('A')); [EOL]         [EOL]         for (int i = 0; i < 196; i++) { [EOL]             final String str = CharUtils.unicodeEscaped((char) i); [EOL]             assertEquals(6, str.length()); [EOL]             final int val = Integer.parseInt(str.substring(2), 16); [EOL]             assertEquals(i, val); [EOL]         } [EOL]         assertEquals("\\u0999", CharUtils.unicodeEscaped((char) 0x999)); [EOL]         assertEquals("\\u1001", CharUtils.unicodeEscaped((char) 0x1001)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testBasicQuotedTrimmed1() { [EOL]         final String input = "a: 'b' :"; [EOL]         final StrTokenizer tok = new StrTokenizer(input, ':', '\''); [EOL]         tok.setTrimmerMatcher(StrMatcher.trimMatcher()); [EOL]         tok.setIgnoreEmptyTokens(false); [EOL]         tok.setEmptyTokenAsNull(true); [EOL]         assertEquals("a", tok.next()); [EOL]         assertEquals("b", tok.next()); [EOL]         assertEquals(null, tok.next()); [EOL]         assertFalse(tok.hasNext()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testTSVEmpty() { [EOL]         this.testEmpty(StrTokenizer.getCSVInstance()); [EOL]         this.testEmpty(StrTokenizer.getCSVInstance("")); [EOL]     } [EOL]  [EOL]     void testXSVAbc(final StrTokenizer tokenizer) { [EOL]         this.checkClone(tokenizer); [EOL]         assertEquals(-1, tokenizer.previousIndex()); [EOL]         assertEquals(0, tokenizer.nextIndex()); [EOL]         assertEquals(null, tokenizer.previousToken()); [EOL]         assertEquals("A", tokenizer.nextToken()); [EOL]         assertEquals(1, tokenizer.nextIndex()); [EOL]         assertEquals("b", tokenizer.nextToken()); [EOL]         assertEquals(2, tokenizer.nextIndex()); [EOL]         assertEquals("c", tokenizer.nextToken()); [EOL]         assertEquals(3, tokenizer.nextIndex()); [EOL]         assertEquals(null, tokenizer.nextToken()); [EOL]         assertEquals(3, tokenizer.nextIndex()); [EOL]         assertEquals("c", tokenizer.previousToken()); [EOL]         assertEquals(2, tokenizer.nextIndex()); [EOL]         assertEquals("b", tokenizer.previousToken()); [EOL]         assertEquals(1, tokenizer.nextIndex()); [E
@Test [EOL]     public void testShutdownSharedExecutorTask() throws InterruptedException { [EOL]         final ScheduledExecutorService service = EasyMock [EOL]                 .createMock(ScheduledExecutorService.class); [EOL]         final ScheduledFuture<?> future = EasyMock.createMock(ScheduledFuture.class); [EOL]         prepareStartTimer(service, future); [EOL]         EasyMock.expect(Boolean.valueOf(future.cancel(false))).andReturn(Boolean.TRUE); [EOL]         EasyMock.replay(service, future); [EOL]         final TimedSemaphoreTestImpl semaphore = new TimedSemaphoreTestImpl(service, [EOL]                 PERIOD, UNIT, LIMIT); [EOL]         semaphore.acquire(); [EOL]         semaphore.shutdown(); [EOL]         assertTrue("Not shutdown", semaphore.isShutdown()); [EOL]         EasyMock.verify(service, future); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests multiple invocations of the shutdown() method. [EOL]      */ [EOL]
@Test [EOL]     public void testShutdownSharedExecutorTask() throws InterruptedException { [EOL]         final ScheduledExecutorService service = EasyMock [EOL]                 .createMock(ScheduledExecutorService.class); [EOL]         final ScheduledFuture<?> future = EasyMock.createMock(ScheduledFuture.class); [EOL]         prepareStartTimer(service, future); [EOL]         EasyMock.expect(Boolean.valueOf(future.cancel(false))).andReturn(Boolean.TRUE); [EOL]         EasyMock.replay(service, future); [EOL]         final TimedSemaphoreTestImpl semaphore = new TimedSemaphoreTestImpl(service, [EOL]                 PERIOD, UNIT, LIMIT); [EOL]         semaphore.acquire(); [EOL]         semaphore.shutdown(); [EOL]         assertTrue("Not shutdown", semaphore.isShutdown()); [EOL]         EasyMock.verify(service, future); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests multiple invocations of the shutdown() method. [EOL]      */ [EOL]
@Test [EOL]     public void testShutdownSharedExecutorTask() throws InterruptedException { [EOL]         final ScheduledExecutorService service = EasyMock [EOL]                 .createMock(ScheduledExecutorService.class); [EOL]         final ScheduledFuture<?> future = EasyMock.createMock(ScheduledFuture.class); [EOL]         prepareStartTimer(service, future); [EOL]         EasyMock.expect(Boolean.valueOf(future.cancel(false))).andReturn(Boolean.TRUE); [EOL]         EasyMock.replay(service, future); [EOL]         final TimedSemaphoreTestImpl semaphore = new TimedSemaphoreTestImpl(service, [EOL]                 PERIOD, UNIT, LIMIT); [EOL]         semaphore.acquire(); [EOL]         semaphore.shutdown(); [EOL]         assertTrue("Not shutdown", semaphore.isShutdown()); [EOL]         EasyMock.verify(service, future); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests multiple invocations of the shutdown() method. [EOL]      */ [EOL]
@Test [EOL]     public void testInitializeUncheckedNull() { [EOL]         assertNull("Got a result", ConcurrentUtils.initializeUnchecked(null)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests a successful initializeUnchecked() operation. [EOL]      */ [EOL]
@Test [EOL]     public void testCreateIfAbsentUncheckedException() [EOL]             throws ConcurrentException { [EOL]         @SuppressWarnings("unchecked") [EOL]         final [EOL]         ConcurrentInitializer<Integer> init = EasyMock [EOL]                 .createMock(ConcurrentInitializer.class); [EOL]         final Exception ex = new Exception(); [EOL]         EasyMock.expect(init.get()).andThrow(new ConcurrentException(ex)); [EOL]         EasyMock.replay(init); [EOL]         try { [EOL]             ConcurrentUtils.createIfAbsentUnchecked( [EOL]                     new ConcurrentHashMap<String, Integer>(), "test", init); [EOL]             fail("Exception not thrown!"); [EOL]         } catch (final ConcurrentRuntimeException crex) { [EOL]             assertEquals("Wrong cause", ex, crex.getCause()); [EOL]         } [EOL]         EasyMock.verify(init); [EOL]     } [EOL] } [EOL]
@Test [EOL]     public void testNonEquivalentAnnotationsOfSameType() { [EOL]         assertFalse(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field3.getAnnotation(TestAnnotation.class))); [EOL]         assertFalse(AnnotationUtils.equals(field3.getAnnotation(TestAnnotation.class), field1.getAnnotation(TestAnnotation.class))); [EOL]     } [EOL]  [EOL]
@Test(timeout = 666000) [EOL]     public void testHashCode() throws Exception { [EOL]         final Test test = getClass().getDeclaredMethod("testHashCode").getAnnotation(Test.class); [EOL]         assertEquals(test.hashCode(), AnnotationUtils.hashCode(test)); [EOL]         final TestAnnotation testAnnotation1 = field1.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation1.hashCode(), AnnotationUtils.hashCode(testAnnotation1)); [EOL]         final TestAnnotation testAnnotation3 = field3.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation3.hashCode(), AnnotationUtils.hashCode(testAnnotation3)); [EOL]     } [EOL]  [EOL]
@Test(timeout = 666000) [EOL]     public void testHashCode() throws Exception { [EOL]         final Test test = getClass().getDeclaredMethod("testHashCode").getAnnotation(Test.class); [EOL]         assertEquals(test.hashCode(), AnnotationUtils.hashCode(test)); [EOL]         final TestAnnotation testAnnotation1 = field1.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation1.hashCode(), AnnotationUtils.hashCode(testAnnotation1)); [EOL]         final TestAnnotation testAnnotation3 = field3.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation3.hashCode(), AnnotationUtils.hashCode(testAnnotation3)); [EOL]     } [EOL]  [EOL]
@Test(timeout = 666000) [EOL]     public void testHashCode() throws Exception { [EOL]         final Test test = getClass().getDeclaredMethod("testHashCode").getAnnotation(Test.class); [EOL]         assertEquals(test.hashCode(), AnnotationUtils.hashCode(test)); [EOL]         final TestAnnotation testAnnotation1 = field1.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation1.hashCode(), AnnotationUtils.hashCode(testAnnotation1)); [EOL]         final TestAnnotation testAnnotation3 = field3.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation3.hashCode(), AnnotationUtils.hashCode(testAnnotation3)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNonEquivalentAnnotationsOfSameType() { [EOL]         assertFalse(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field3.getAnnotation(TestAnnotation.class))); [EOL]         assertFalse(AnnotationUtils.equals(field3.getAnnotation(TestAnnotation.class), field1.getAnnotation(TestAnnotation.class))); [EOL]     } [EOL]  [EOL]
@Test(timeout = 666000) [EOL]     public void testHashCode() throws Exception { [EOL]         final Test test = getClass().getDeclaredMethod("testHashCode").getAnnotation(Test.class); [EOL]         assertEquals(test.hashCode(), AnnotationUtils.hashCode(test)); [EOL]         final TestAnnotation testAnnotation1 = field1.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation1.hashCode(), AnnotationUtils.hashCode(testAnnotation1)); [EOL]         final TestAnnotation testAnnotation3 = field3.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation3.hashCode(), AnnotationUtils.hashCode(testAnnotation3)); [EOL]     } [EOL]  [EOL]
@Test(timeout = 666000) [EOL]     public void testHashCode() throws Exception { [EOL]         final Test test = getClass().getDeclaredMethod("testHashCode").getAnnotation(Test.class); [EOL]         assertEquals(test.hashCode(), AnnotationUtils.hashCode(test)); [EOL]         final TestAnnotation testAnnotation1 = field1.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation1.hashCode(), AnnotationUtils.hashCode(testAnnotation1)); [EOL]         final TestAnnotation testAnnotation3 = field3.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation3.hashCode(), AnnotationUtils.hashCode(testAnnotation3)); [EOL]     } [EOL]  [EOL]
@Test(timeout = 666000) [EOL]     public void testHashCode() throws Exception { [EOL]         final Test test = getClass().getDeclaredMethod("testHashCode").getAnnotation(Test.class); [EOL]         assertEquals(test.hashCode(), AnnotationUtils.hashCode(test)); [EOL]         final TestAnnotation testAnnotation1 = field1.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation1.hashCode(), AnnotationUtils.hashCode(testAnnotation1)); [EOL]         final TestAnnotation testAnnotation3 = field3.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation3.hashCode(), AnnotationUtils.hashCode(testAnnotation3)); [EOL]     } [EOL]  [EOL]
@Test(timeout = 666000) [EOL]     public void testHashCode() throws Exception { [EOL]         final Test test = getClass().getDeclaredMethod("testHashCode").getAnnotation(Test.class); [EOL]         assertEquals(test.hashCode(), AnnotationUtils.hashCode(test)); [EOL]         final TestAnnotation testAnnotation1 = field1.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation1.hashCode(), AnnotationUtils.hashCode(testAnnotation1)); [EOL]         final TestAnnotation testAnnotation3 = field3.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation3.hashCode(), AnnotationUtils.hashCode(testAnnotation3)); [EOL]     } [EOL]  [EOL]
@Test(timeout = 666000) [EOL]     public void testHashCode() throws Exception { [EOL]         final Test test = getClass().getDeclaredMethod("testHashCode").getAnnotation(Test.class); [EOL]         assertEquals(test.hashCode(), AnnotationUtils.hashCode(test)); [EOL]         final TestAnnotation testAnnotation1 = field1.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation1.hashCode(), AnnotationUtils.hashCode(testAnnotation1)); [EOL]         final TestAnnotation testAnnotation3 = field3.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation3.hashCode(), AnnotationUtils.hashCode(testAnnotation3)); [EOL]     } [EOL]  [EOL]
@Test(timeout = 666000) [EOL]     public void testHashCode() throws Exception { [EOL]         final Test test = getClass().getDeclaredMethod("testHashCode").getAnnotation(Test.class); [EOL]         assertEquals(test.hashCode(), AnnotationUtils.hashCode(test)); [EOL]         final TestAnnotation testAnnotation1 = field1.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation1.hashCode(), AnnotationUtils.hashCode(testAnnotation1)); [EOL]         final TestAnnotation testAnnotation3 = field3.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation3.hashCode(), AnnotationUtils.hashCode(testAnnotation3)); [EOL]     } [EOL]  [EOL]
@Test(timeout = 666000) [EOL]     public void testHashCode() throws Exception { [EOL]         final Test test = getClass().getDeclaredMethod("testHashCode").getAnnotation(Test.class); [EOL]         assertEquals(test.hashCode(), AnnotationUtils.hashCode(test)); [EOL]         final TestAnnotation testAnnotation1 = field1.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation1.hashCode(), AnnotationUtils.hashCode(testAnnotation1)); [EOL]         final TestAnnotation testAnnotation3 = field3.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation3.hashCode(), AnnotationUtils.hashCode(testAnnotation3)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNonEquivalentAnnotationsOfSameType() { [EOL]         assertFalse(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field3.getAnnotation(TestAnnotation.class))); [EOL]         assertFalse(AnnotationUtils.equals(field3.getAnnotation(TestAnnotation.class), field1.getAnnotation(TestAnnotation.class))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNonEquivalentAnnotationsOfSameType() { [EOL]         assertFalse(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field3.getAnnotation(TestAnnotation.class))); [EOL]         assertFalse(AnnotationUtils.equals(field3.getAnnotation(TestAnnotation.class), field1.getAnnotation(TestAnnotation.class))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNonEquivalentAnnotationsOfSameType() { [EOL]         assertFalse(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field3.getAnnotation(TestAnnotation.class))); [EOL]         assertFalse(AnnotationUtils.equals(field3.getAnnotation(TestAnnotation.class), field1.getAnnotation(TestAnnotation.class))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNonEquivalentAnnotationsOfSameType() { [EOL]         assertFalse(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field3.getAnnotation(TestAnnotation.class))); [EOL]         assertFalse(AnnotationUtils.equals(field3.getAnnotation(TestAnnotation.class), field1.getAnnotation(TestAnnotation.class))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNonEquivalentAnnotationsOfSameType() { [EOL]         assertFalse(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field3.getAnnotation(TestAnnotation.class))); [EOL]         assertFalse(AnnotationUtils.equals(field3.getAnnotation(TestAnnotation.class), field1.getAnnotation(TestAnnotation.class))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNonEquivalentAnnotationsOfSameType() { [EOL]         assertFalse(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field3.getAnnotation(TestAnnotation.class))); [EOL]         assertFalse(AnnotationUtils.equals(field3.getAnnotation(TestAnnotation.class), field1.getAnnotation(TestAnnotation.class))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNonEquivalentAnnotationsOfSameType() { [EOL]         assertFalse(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field3.getAnnotation(TestAnnotation.class))); [EOL]         assertFalse(AnnotationUtils.equals(field3.getAnnotation(TestAnnotation.class), field1.getAnnotation(TestAnnotation.class))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNonEquivalentAnnotationsOfSameType() { [EOL]         assertFalse(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field3.getAnnotation(TestAnnotation.class))); [EOL]         assertFalse(AnnotationUtils.equals(field3.getAnnotation(TestAnnotation.class), field1.getAnnotation(TestAnnotation.class))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNonEquivalentAnnotationsOfSameType() { [EOL]         assertFalse(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field3.getAnnotation(TestAnnotation.class))); [EOL]         assertFalse(AnnotationUtils.equals(field3.getAnnotation(TestAnnotation.class), field1.getAnnotation(TestAnnotation.class))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNonEquivalentAnnotationsOfSameType() { [EOL]         assertFalse(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field3.getAnnotation(TestAnnotation.class))); [EOL]         assertFalse(AnnotationUtils.equals(field3.getAnnotation(TestAnnotation.class), field1.getAnnotation(TestAnnotation.class))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNonEquivalentAnnotationsOfSameType() { [EOL]         assertFalse(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field3.getAnnotation(TestAnnotation.class))); [EOL]         assertFalse(AnnotationUtils.equals(field3.getAnnotation(TestAnnotation.class), field1.getAnnotation(TestAnnotation.class))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNonEquivalentAnnotationsOfSameType() { [EOL]         assertFalse(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field3.getAnnotation(TestAnnotation.class))); [EOL]         assertFalse(AnnotationUtils.equals(field3.getAnnotation(TestAnnotation.class), field1.getAnnotation(TestAnnotation.class))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNonEquivalentAnnotationsOfSameType() { [EOL]         assertFalse(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field3.getAnnotation(TestAnnotation.class))); [EOL]         assertFalse(AnnotationUtils.equals(field3.getAnnotation(TestAnnotation.class), field1.getAnnotation(TestAnnotation.class))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNonEquivalentAnnotationsOfSameType() { [EOL]         assertFalse(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field3.getAnnotation(TestAnnotation.class))); [EOL]         assertFalse(AnnotationUtils.equals(field3.getAnnotation(TestAnnotation.class), field1.getAnnotation(TestAnnotation.class))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNonEquivalentAnnotationsOfSameType() { [EOL]         assertFalse(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field3.getAnnotation(TestAnnotation.class))); [EOL]         assertFalse(AnnotationUtils.equals(field3.getAnnotation(TestAnnotation.class), field1.getAnnotation(TestAnnotation.class))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNonEquivalentAnnotationsOfSameType() { [EOL]         assertFalse(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field3.getAnnotation(TestAnnotation.class))); [EOL]         assertFalse(AnnotationUtils.equals(field3.getAnnotation(TestAnnotation.class), field1.getAnnotation(TestAnnotation.class))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNonEquivalentAnnotationsOfSameType() { [EOL]         assertFalse(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field3.getAnnotation(TestAnnotation.class))); [EOL]         assertFalse(AnnotationUtils.equals(field3.getAnnotation(TestAnnotation.class), field1.getAnnotation(TestAnnotation.class))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNonEquivalentAnnotationsOfSameType() { [EOL]         assertFalse(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field3.getAnnotation(TestAnnotation.class))); [EOL]         assertFalse(AnnotationUtils.equals(field3.getAnnotation(TestAnnotation.class), field1.getAnnotation(TestAnnotation.class))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNonEquivalentAnnotationsOfSameType() { [EOL]         assertFalse(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field3.getAnnotation(TestAnnotation.class))); [EOL]         assertFalse(AnnotationUtils.equals(field3.getAnnotation(TestAnnotation.class), field1.getAnnotation(TestAnnotation.class))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNonEquivalentAnnotationsOfSameType() { [EOL]         assertFalse(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field3.getAnnotation(TestAnnotation.class))); [EOL]         assertFalse(AnnotationUtils.equals(field3.getAnnotation(TestAnnotation.class), field1.getAnnotation(TestAnnotation.class))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNonEquivalentAnnotationsOfSameType() { [EOL]         assertFalse(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field3.getAnnotation(TestAnnotation.class))); [EOL]         assertFalse(AnnotationUtils.equals(field3.getAnnotation(TestAnnotation.class), field1.getAnnotation(TestAnnotation.class))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNonEquivalentAnnotationsOfSameType() { [EOL]         assertFalse(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field3.getAnnotation(TestAnnotation.class))); [EOL]         assertFalse(AnnotationUtils.equals(field3.getAnnotation(TestAnnotation.class), field1.getAnnotation(TestAnnotation.class))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNonEquivalentAnnotationsOfSameType() { [EOL]         assertFalse(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field3.getAnnotation(TestAnnotation.class))); [EOL]         assertFalse(AnnotationUtils.equals(field3.getAnnotation(TestAnnotation.class), field1.getAnnotation(TestAnnotation.class))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNonEquivalentAnnotationsOfSameType() { [EOL]         assertFalse(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field3.getAnnotation(TestAnnotation.class))); [EOL]         assertFalse(AnnotationUtils.equals(field3.getAnnotation(TestAnnotation.class), field1.getAnnotation(TestAnnotation.class))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNonEquivalentAnnotationsOfSameType() { [EOL]         assertFalse(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field3.getAnnotation(TestAnnotation.class))); [EOL]         assertFalse(AnnotationUtils.equals(field3.getAnnotation(TestAnnotation.class), field1.getAnnotation(TestAnnotation.class))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNonEquivalentAnnotationsOfSameType() { [EOL]         assertFalse(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field3.getAnnotation(TestAnnotation.class))); [EOL]         assertFalse(AnnotationUtils.equals(field3.getAnnotation(TestAnnotation.class), field1.getAnnotation(TestAnnotation.class))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNonEquivalentAnnotationsOfSameType() { [EOL]         assertFalse(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field3.getAnnotation(TestAnnotation.class))); [EOL]         assertFalse(AnnotationUtils.equals(field3.getAnnotation(TestAnnotation.class), field1.getAnnotation(TestAnnotation.class))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNonEquivalentAnnotationsOfSameType() { [EOL]         assertFalse(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field3.getAnnotation(TestAnnotation.class))); [EOL]         assertFalse(AnnotationUtils.equals(field3.getAnnotation(TestAnnotation.class), field1.getAnnotation(TestAnnotation.class))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNonEquivalentAnnotationsOfSameType() { [EOL]         assertFalse(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field3.getAnnotation(TestAnnotation.class))); [EOL]         assertFalse(AnnotationUtils.equals(field3.getAnnotation(TestAnnotation.class), field1.getAnnotation(TestAnnotation.class))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testHashCodeMulti_multiple_emptyArray() { [EOL]         final Object[] array = new Object[0]; [EOL]         assertEquals(1, ObjectUtils.hashCodeMulti(array)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testHashCode() { [EOL]         assertEquals(0, ObjectUtils.hashCode(null)); [EOL]         assertEquals("a".hashCode(), ObjectUtils.hashCode("a")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testHashCode() { [EOL]         assertEquals(0, ObjectUtils.hashCode(null)); [EOL]         assertEquals("a".hashCode(), ObjectUtils.hashCode("a")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testHashCode() { [EOL]         assertEquals(0, ObjectUtils.hashCode(null)); [EOL]         assertEquals("a".hashCode(), ObjectUtils.hashCode("a")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testHashCode() { [EOL]         assertEquals(0, ObjectUtils.hashCode(null)); [EOL]         assertEquals("a".hashCode(), ObjectUtils.hashCode("a")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testHashCode() { [EOL]         assertEquals(0, ObjectUtils.hashCode(null)); [EOL]         assertEquals("a".hashCode(), ObjectUtils.hashCode("a")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testHashCode() { [EOL]         assertEquals(0, ObjectUtils.hashCode(null)); [EOL]         assertEquals("a".hashCode(), ObjectUtils.hashCode("a")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testHashCode() { [EOL]         assertEquals(0, ObjectUtils.hashCode(null)); [EOL]         assertEquals("a".hashCode(), ObjectUtils.hashCode("a")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testHashCode() { [EOL]         assertEquals(0, ObjectUtils.hashCode(null)); [EOL]         assertEquals("a".hashCode(), ObjectUtils.hashCode("a")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testHashCode() { [EOL]         assertEquals(0, ObjectUtils.hashCode(null)); [EOL]         assertEquals("a".hashCode(), ObjectUtils.hashCode("a")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testHashCode() { [EOL]         assertEquals(0, ObjectUtils.hashCode(null)); [EOL]         assertEquals("a".hashCode(), ObjectUtils.hashCode("a")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testHashCode() { [EOL]         assertEquals(0, ObjectUtils.hashCode(null)); [EOL]         assertEquals("a".hashCode(), ObjectUtils.hashCode("a")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testHashCode() { [EOL]         assertEquals(0, ObjectUtils.hashCode(null)); [EOL]         assertEquals("a".hashCode(), ObjectUtils.hashCode("a")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testHashCode() { [EOL]         assertEquals(0, ObjectUtils.hashCode(null)); [EOL]         assertEquals("a".hashCode(), ObjectUtils.hashCode("a")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testHashCode() { [EOL]         assertEquals(0, ObjectUtils.hashCode(null)); [EOL]         assertEquals("a".hashCode(), ObjectUtils.hashCode("a")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testHashCode() { [EOL]         assertEquals(0, ObjectUtils.hashCode(null)); [EOL]         assertEquals("a".hashCode(), ObjectUtils.hashCode("a")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testHashCode() { [EOL]         assertEquals(0, ObjectUtils.hashCode(null)); [EOL]         assertEquals("a".hashCode(), ObjectUtils.hashCode("a")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testHashCode() { [EOL]         assertEquals(0, ObjectUtils.hashCode(null)); [EOL]         assertEquals("a".hashCode(), ObjectUtils.hashCode("a")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testAddEventListenerWithNoAddMethod() [EOL]     { [EOL]         final PropertyChangeSource src = new PropertyChangeSource(); [EOL]         final EventCountingInvociationHandler handler = new EventCountingInvociationHandler(); [EOL]         final ObjectChangeListener listener = handler.createListener(ObjectChangeListener.class); [EOL]         try [EOL]         { [EOL]             EventUtils.addEventListener(src, ObjectChangeListener.class, listener); [EOL]             fail("Should not be allowed to add a listener to an object that doesn't support it."); [EOL]         } [EOL]         catch (final IllegalArgumentException e) [EOL]         { [EOL]             assertEquals("Class " + src.getClass().getName() + " does not have a public add" + ObjectChangeListener.class.getSimpleName() + " method which takes a parameter of type " + ObjectChangeListener.class.getName() + ".", e.getMessage()); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testBindFilteredEventsToMethod() [EOL]     { [EOL]         final MultipleEventSource src = new MultipleEventSource(); [EOL]         final EventCounter counter = new EventCounter(); [EOL]         EventUtils.bindEventsToMethod(counter, "eventOccurred", src, MultipleEventListener.class, "event1"); [EOL]         assertEquals(0, counter.getCount()); [EOL]         src.listeners.fire().event1(new PropertyChangeEvent(new Date(), "Day", Integer.valueOf(0), Integer.valueOf(1))); [EOL]         assertEquals(1, counter.getCount()); [EOL]         src.listeners.fire().event2(new PropertyChangeEvent(new Date(), "Day", Integer.valueOf(1), Integer.valueOf(2))); [EOL]         assertEquals(1, counter.getCount()); [EOL]     } [EOL]  [EOL]     public static interface MultipleEventListener [EOL]     { [EOL]         public void event1(PropertyChangeEvent e); [EOL]  [EOL]         public void event2(PropertyChangeEvent e); [EOL]     } [EOL]  [EOL]     public static class EventCounter [EOL]     { [EOL]         private int count; [EOL]  [EOL]         public void eventOccurred() [EOL]         { [EOL]             count++; [EOL]         } [EOL]  [EOL]      
@Test [EOL]     public void testInvokeMethod() throws Exception { [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 (Object[]) ArrayUtils.EMPTY_CLASS_ARRAY)); [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 (Object[]) null)); [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo",  [EOL]                 (Object[]) null, (Class<?>[]) null)); [EOL]         assertEquals("foo(String)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 "")); [EOL]         assertEquals("foo(Object)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 new Object())); [EOL]         assertEquals("foo(Object)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 Boolean.TRUE)); [EOL]         assertEquals("foo(Integer)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.INTEGER_ONE)); [EOL]         assertEquals("foo(int)", MethodUtils.invokeMethod(testBean, "foo", [EOL]       
@Test [EOL]     public void testBindFilteredEventsToMethod() [EOL]     { [EOL]         final MultipleEventSource src = new MultipleEventSource(); [EOL]         final EventCounter counter = new EventCounter(); [EOL]         EventUtils.bindEventsToMethod(counter, "eventOccurred", src, MultipleEventListener.class, "event1"); [EOL]         assertEquals(0, counter.getCount()); [EOL]         src.listeners.fire().event1(new PropertyChangeEvent(new Date(), "Day", Integer.valueOf(0), Integer.valueOf(1))); [EOL]         assertEquals(1, counter.getCount()); [EOL]         src.listeners.fire().event2(new PropertyChangeEvent(new Date(), "Day", Integer.valueOf(1), Integer.valueOf(2))); [EOL]         assertEquals(1, counter.getCount()); [EOL]     } [EOL]  [EOL]     public static interface MultipleEventListener [EOL]     { [EOL]         public void event1(PropertyChangeEvent e); [EOL]  [EOL]         public void event2(PropertyChangeEvent e); [EOL]     } [EOL]  [EOL]     public static class EventCounter [EOL]     { [EOL]         private int count; [EOL]  [EOL]         public void eventOccurred() [EOL]         { [EOL]             count++; [EOL]         } [EOL]  [EOL]      
@Test [EOL]     public void testInvokeMethod() throws Exception { [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 (Object[]) ArrayUtils.EMPTY_CLASS_ARRAY)); [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 (Object[]) null)); [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo",  [EOL]                 (Object[]) null, (Class<?>[]) null)); [EOL]         assertEquals("foo(String)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 "")); [EOL]         assertEquals("foo(Object)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 new Object())); [EOL]         assertEquals("foo(Object)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 Boolean.TRUE)); [EOL]         assertEquals("foo(Integer)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.INTEGER_ONE)); [EOL]         assertEquals("foo(int)", MethodUtils.invokeMethod(testBean, "foo", [EOL]       
@Test [EOL]     public void testInvokeMethod() throws Exception { [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 (Object[]) ArrayUtils.EMPTY_CLASS_ARRAY)); [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 (Object[]) null)); [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo",  [EOL]                 (Object[]) null, (Class<?>[]) null)); [EOL]         assertEquals("foo(String)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 "")); [EOL]         assertEquals("foo(Object)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 new Object())); [EOL]         assertEquals("foo(Object)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 Boolean.TRUE)); [EOL]         assertEquals("foo(Integer)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.INTEGER_ONE)); [EOL]         assertEquals("foo(int)", MethodUtils.invokeMethod(testBean, "foo", [EOL]       
@Test [EOL]     public void testInvokeMethod() throws Exception { [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 (Object[]) ArrayUtils.EMPTY_CLASS_ARRAY)); [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 (Object[]) null)); [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo",  [EOL]                 (Object[]) null, (Class<?>[]) null)); [EOL]         assertEquals("foo(String)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 "")); [EOL]         assertEquals("foo(Object)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 new Object())); [EOL]         assertEquals("foo(Object)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 Boolean.TRUE)); [EOL]         assertEquals("foo(Integer)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.INTEGER_ONE)); [EOL]         assertEquals("foo(int)", MethodUtils.invokeMethod(testBean, "foo", [EOL]       
@Test [EOL]     public void testInvokeMethod() throws Exception { [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 (Object[]) ArrayUtils.EMPTY_CLASS_ARRAY)); [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 (Object[]) null)); [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo",  [EOL]                 (Object[]) null, (Class<?>[]) null)); [EOL]         assertEquals("foo(String)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 "")); [EOL]         assertEquals("foo(Object)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 new Object())); [EOL]         assertEquals("foo(Object)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 Boolean.TRUE)); [EOL]         assertEquals("foo(Integer)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.INTEGER_ONE)); [EOL]         assertEquals("foo(int)", MethodUtils.invokeMethod(testBean, "foo", [EOL]       
@Test [EOL]     public void testInvokeMethod() throws Exception { [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 (Object[]) ArrayUtils.EMPTY_CLASS_ARRAY)); [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 (Object[]) null)); [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo",  [EOL]                 (Object[]) null, (Class<?>[]) null)); [EOL]         assertEquals("foo(String)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 "")); [EOL]         assertEquals("foo(Object)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 new Object())); [EOL]         assertEquals("foo(Object)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 Boolean.TRUE)); [EOL]         assertEquals("foo(Integer)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.INTEGER_ONE)); [EOL]         assertEquals("foo(int)", MethodUtils.invokeMethod(testBean, "foo", [EOL]       
@Test [EOL]     public void testInvokeMethod() throws Exception { [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 (Object[]) ArrayUtils.EMPTY_CLASS_ARRAY)); [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 (Object[]) null)); [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo",  [EOL]                 (Object[]) null, (Class<?>[]) null)); [EOL]         assertEquals("foo(String)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 "")); [EOL]         assertEquals("foo(Object)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 new Object())); [EOL]         assertEquals("foo(Object)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 Boolean.TRUE)); [EOL]         assertEquals("foo(Integer)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.INTEGER_ONE)); [EOL]         assertEquals("foo(int)", MethodUtils.invokeMethod(testBean, "foo", [EOL]       
@Test [EOL]     public void testToMap() { [EOL]         Map<?, ?> map = ArrayUtils.toMap(new String[][] {{"foo", "bar"}, {"hello", "world"}}); [EOL]          [EOL]         assertEquals("bar", map.get("foo")); [EOL]         assertEquals("world", map.get("hello")); [EOL]          [EOL]         assertEquals(null, ArrayUtils.toMap(null)); [EOL]         try { [EOL]             ArrayUtils.toMap(new String[][] {{"foo", "bar"}, {"short"}}); [EOL]             fail("exception expected"); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             ArrayUtils.toMap(new Object[] {new Object[] {"foo", "bar"}, "illegal type"}); [EOL]             fail("exception expected"); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             ArrayUtils.toMap(new Object[] {new Object[] {"foo", "bar"}, null}); [EOL]             fail("exception expected"); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]          [EOL]         map = ArrayUtils.toMap(new Object
@Test [EOL]     public void testToMap() { [EOL]         Map<?, ?> map = ArrayUtils.toMap(new String[][] {{"foo", "bar"}, {"hello", "world"}}); [EOL]          [EOL]         assertEquals("bar", map.get("foo")); [EOL]         assertEquals("world", map.get("hello")); [EOL]          [EOL]         assertEquals(null, ArrayUtils.toMap(null)); [EOL]         try { [EOL]             ArrayUtils.toMap(new String[][] {{"foo", "bar"}, {"short"}}); [EOL]             fail("exception expected"); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             ArrayUtils.toMap(new Object[] {new Object[] {"foo", "bar"}, "illegal type"}); [EOL]             fail("exception expected"); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             ArrayUtils.toMap(new Object[] {new Object[] {"foo", "bar"}, null}); [EOL]             fail("exception expected"); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]          [EOL]         map = ArrayUtils.toMap(new Object
@Test [EOL]     public void testToMap() { [EOL]         Map<?, ?> map = ArrayUtils.toMap(new String[][] {{"foo", "bar"}, {"hello", "world"}}); [EOL]          [EOL]         assertEquals("bar", map.get("foo")); [EOL]         assertEquals("world", map.get("hello")); [EOL]          [EOL]         assertEquals(null, ArrayUtils.toMap(null)); [EOL]         try { [EOL]             ArrayUtils.toMap(new String[][] {{"foo", "bar"}, {"short"}}); [EOL]             fail("exception expected"); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             ArrayUtils.toMap(new Object[] {new Object[] {"foo", "bar"}, "illegal type"}); [EOL]             fail("exception expected"); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             ArrayUtils.toMap(new Object[] {new Object[] {"foo", "bar"}, null}); [EOL]             fail("exception expected"); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]          [EOL]         map = ArrayUtils.toMap(new Object
@Test [EOL]     public void testToMap() { [EOL]         Map<?, ?> map = ArrayUtils.toMap(new String[][] {{"foo", "bar"}, {"hello", "world"}}); [EOL]          [EOL]         assertEquals("bar", map.get("foo")); [EOL]         assertEquals("world", map.get("hello")); [EOL]          [EOL]         assertEquals(null, ArrayUtils.toMap(null)); [EOL]         try { [EOL]             ArrayUtils.toMap(new String[][] {{"foo", "bar"}, {"short"}}); [EOL]             fail("exception expected"); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             ArrayUtils.toMap(new Object[] {new Object[] {"foo", "bar"}, "illegal type"}); [EOL]             fail("exception expected"); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             ArrayUtils.toMap(new Object[] {new Object[] {"foo", "bar"}, null}); [EOL]             fail("exception expected"); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]          [EOL]         map = ArrayUtils.toMap(new Object
@Test [EOL]     public void testToMap() { [EOL]         Map<?, ?> map = ArrayUtils.toMap(new String[][] {{"foo", "bar"}, {"hello", "world"}}); [EOL]          [EOL]         assertEquals("bar", map.get("foo")); [EOL]         assertEquals("world", map.get("hello")); [EOL]          [EOL]         assertEquals(null, ArrayUtils.toMap(null)); [EOL]         try { [EOL]             ArrayUtils.toMap(new String[][] {{"foo", "bar"}, {"short"}}); [EOL]             fail("exception expected"); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             ArrayUtils.toMap(new Object[] {new Object[] {"foo", "bar"}, "illegal type"}); [EOL]             fail("exception expected"); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             ArrayUtils.toMap(new Object[] {new Object[] {"foo", "bar"}, null}); [EOL]             fail("exception expected"); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]          [EOL]         map = ArrayUtils.toMap(new Object
@Test [EOL]     public void testToMap() { [EOL]         Map<?, ?> map = ArrayUtils.toMap(new String[][] {{"foo", "bar"}, {"hello", "world"}}); [EOL]          [EOL]         assertEquals("bar", map.get("foo")); [EOL]         assertEquals("world", map.get("hello")); [EOL]          [EOL]         assertEquals(null, ArrayUtils.toMap(null)); [EOL]         try { [EOL]             ArrayUtils.toMap(new String[][] {{"foo", "bar"}, {"short"}}); [EOL]             fail("exception expected"); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             ArrayUtils.toMap(new Object[] {new Object[] {"foo", "bar"}, "illegal type"}); [EOL]             fail("exception expected"); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             ArrayUtils.toMap(new Object[] {new Object[] {"foo", "bar"}, null}); [EOL]             fail("exception expected"); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]          [EOL]         map = ArrayUtils.toMap(new Object
@Test [EOL]     public void testToMap() { [EOL]         Map<?, ?> map = ArrayUtils.toMap(new String[][] {{"foo", "bar"}, {"hello", "world"}}); [EOL]          [EOL]         assertEquals("bar", map.get("foo")); [EOL]         assertEquals("world", map.get("hello")); [EOL]          [EOL]         assertEquals(null, ArrayUtils.toMap(null)); [EOL]         try { [EOL]             ArrayUtils.toMap(new String[][] {{"foo", "bar"}, {"short"}}); [EOL]             fail("exception expected"); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             ArrayUtils.toMap(new Object[] {new Object[] {"foo", "bar"}, "illegal type"}); [EOL]             fail("exception expected"); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             ArrayUtils.toMap(new Object[] {new Object[] {"foo", "bar"}, null}); [EOL]             fail("exception expected"); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]          [EOL]         map = ArrayUtils.toMap(new Object
@Test [EOL]     public void testToMap() { [EOL]         Map<?, ?> map = ArrayUtils.toMap(new String[][] {{"foo", "bar"}, {"hello", "world"}}); [EOL]          [EOL]         assertEquals("bar", map.get("foo")); [EOL]         assertEquals("world", map.get("hello")); [EOL]          [EOL]         assertEquals(null, ArrayUtils.toMap(null)); [EOL]         try { [EOL]             ArrayUtils.toMap(new String[][] {{"foo", "bar"}, {"short"}}); [EOL]             fail("exception expected"); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             ArrayUtils.toMap(new Object[] {new Object[] {"foo", "bar"}, "illegal type"}); [EOL]             fail("exception expected"); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             ArrayUtils.toMap(new Object[] {new Object[] {"foo", "bar"}, null}); [EOL]             fail("exception expected"); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]          [EOL]         map = ArrayUtils.toMap(new Object
@Test [EOL]     public void testToMap() { [EOL]         Map<?, ?> map = ArrayUtils.toMap(new String[][] {{"foo", "bar"}, {"hello", "world"}}); [EOL]          [EOL]         assertEquals("bar", map.get("foo")); [EOL]         assertEquals("world", map.get("hello")); [EOL]          [EOL]         assertEquals(null, ArrayUtils.toMap(null)); [EOL]         try { [EOL]             ArrayUtils.toMap(new String[][] {{"foo", "bar"}, {"short"}}); [EOL]             fail("exception expected"); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             ArrayUtils.toMap(new Object[] {new Object[] {"foo", "bar"}, "illegal type"}); [EOL]             fail("exception expected"); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             ArrayUtils.toMap(new Object[] {new Object[] {"foo", "bar"}, null}); [EOL]             fail("exception expected"); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]          [EOL]         map = ArrayUtils.toMap(new Object
@Test [EOL]     public void testToMap() { [EOL]         Map<?, ?> map = ArrayUtils.toMap(new String[][] {{"foo", "bar"}, {"hello", "world"}}); [EOL]          [EOL]         assertEquals("bar", map.get("foo")); [EOL]         assertEquals("world", map.get("hello")); [EOL]          [EOL]         assertEquals(null, ArrayUtils.toMap(null)); [EOL]         try { [EOL]             ArrayUtils.toMap(new String[][] {{"foo", "bar"}, {"short"}}); [EOL]             fail("exception expected"); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             ArrayUtils.toMap(new Object[] {new Object[] {"foo", "bar"}, "illegal type"}); [EOL]             fail("exception expected"); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             ArrayUtils.toMap(new Object[] {new Object[] {"foo", "bar"}, null}); [EOL]             fail("exception expected"); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]          [EOL]         map = ArrayUtils.toMap(new Object
@Test [EOL]     public void testToMap() { [EOL]         Map<?, ?> map = ArrayUtils.toMap(new String[][] {{"foo", "bar"}, {"hello", "world"}}); [EOL]          [EOL]         assertEquals("bar", map.get("foo")); [EOL]         assertEquals("world", map.get("hello")); [EOL]          [EOL]         assertEquals(null, ArrayUtils.toMap(null)); [EOL]         try { [EOL]             ArrayUtils.toMap(new String[][] {{"foo", "bar"}, {"short"}}); [EOL]             fail("exception expected"); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             ArrayUtils.toMap(new Object[] {new Object[] {"foo", "bar"}, "illegal type"}); [EOL]             fail("exception expected"); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             ArrayUtils.toMap(new Object[] {new Object[] {"foo", "bar"}, null}); [EOL]             fail("exception expected"); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]          [EOL]         map = ArrayUtils.toMap(new Object
@Test [EOL]     public void testRemoveElementBooleanArray() { [EOL]         boolean[] array; [EOL]         array = ArrayUtils.removeElement((boolean[]) null, true); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElement(ArrayUtils.EMPTY_BOOLEAN_ARRAY, true); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BOOLEAN_ARRAY, array)); [EOL]         assertEquals(Boolean.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElement(new boolean[] {true}, true); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BOOLEAN_ARRAY, array)); [EOL]         assertEquals(Boolean.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElement(new boolean[] {true, false}, true); [EOL]         assertTrue(Arrays.equals(new boolean[] {false}, array)); [EOL]         assertEquals(Boolean.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElement(new boolean[] {true, false, true}, true); [EOL]         assertTrue(Arrays.equals(new boolean[] {false, true}, array)); [EOL]         assertEquals(Boolean.TYPE, array.getClass().getComponentType()); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testNullToEmptyObject() { [EOL]         // Test null handling [EOL]         assertArrayEquals(ArrayUtils.EMPTY_OBJECT_ARRAY, ArrayUtils.nullToEmpty((Object[]) null)); [EOL]         // Test valid array handling [EOL]         final Object[] original = new Object[] {Boolean.TRUE, Boolean.FALSE}; [EOL]         assertArrayEquals(original, ArrayUtils.nullToEmpty(original)); [EOL]         // Test empty array handling [EOL]         final Object[] empty = new Object[]{}; [EOL]         final Object[] result = ArrayUtils.nullToEmpty(empty); [EOL]         assertArrayEquals(ArrayUtils.EMPTY_OBJECT_ARRAY, result); [EOL]         assertTrue(empty != result); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNullToEmptyString() { [EOL]         // Test null handling [EOL]         assertArrayEquals(ArrayUtils.EMPTY_STRING_ARRAY, ArrayUtils.nullToEmpty((String[]) null)); [EOL]         // Test valid array handling [EOL]         final String[] original = new String[] {"abc", "def"}; [EOL]         assertArrayEquals(original, ArrayUtils.nullToEmpty(original)); [EOL]         // Test empty array handling [EOL]         final String[] empty = new String[]{}; [EOL]         final String[] result = ArrayUtils.nullToEmpty(empty); [EOL]         assertArrayEquals(ArrayUtils.EMPTY_STRING_ARRAY, result); [EOL]         assertTrue(empty != result); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNullToEmptyInt() { [EOL]         // Test null handling [EOL]         assertEquals(ArrayUtils.EMPTY_INT_ARRAY, ArrayUtils.nullToEmpty((int[]) null)); [EOL]         // Test valid array handling [EOL]         final int[] original = new int[] {1, 2}; [EOL]         assertEquals(original, ArrayUtils.nullToEmpty(original)); [EOL]         // Test empty array handling [EOL]         final int[] empty = new int[]{}; [EOL]         final int[] result = ArrayUtils.nullToEmpty(empty); [EOL]         assertEquals(ArrayUtils.EMPTY_INT_ARRAY, result); [EOL]         assertTrue(empty != result); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testNullToEmptyByte() { [EOL]         // Test null handling [EOL]         assertEquals(ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.nullToEmpty((byte[]) null)); [EOL]         // Test valid array handling [EOL]         final byte[] original = new byte[] {0x0F, 0x0E}; [EOL]         assertEquals(original, ArrayUtils.nullToEmpty(original)); [EOL]         // Test empty array handling [EOL]         final byte[] empty = new byte[]{}; [EOL]         final byte[] result = ArrayUtils.nullToEmpty(empty); [EOL]         assertEquals(ArrayUtils.EMPTY_BYTE_ARRAY, result); [EOL]         assertTrue(empty != result); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testNullToEmptyIntObject() { [EOL]         // Test null handling [EOL]         assertArrayEquals(ArrayUtils.EMPTY_INTEGER_OBJECT_ARRAY, ArrayUtils.nullToEmpty((Integer[]) null)); [EOL]         // Test valid array handling [EOL]         final Integer[] original = new Integer[] {1, 2}; [EOL]         assertArrayEquals(original, ArrayUtils.nullToEmpty(original)); [EOL]         // Test empty array handling [EOL]         final Integer[] empty = new Integer[]{}; [EOL]         final Integer[] result = ArrayUtils.nullToEmpty(empty); [EOL]         assertArrayEquals(ArrayUtils.EMPTY_INTEGER_OBJECT_ARRAY, result); [EOL]         assertTrue(empty != result); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testNullToEmptyByteObject() { [EOL]         // Test null handling [EOL]         assertArrayEquals(ArrayUtils.EMPTY_BYTE_OBJECT_ARRAY, ArrayUtils.nullToEmpty((Byte[]) null)); [EOL]         // Test valid array handling [EOL]         final Byte[] original = new Byte[] {0x0F, 0x0E}; [EOL]         assertArrayEquals(original, ArrayUtils.nullToEmpty(original)); [EOL]         // Test empty array handling [EOL]         final Byte[] empty = new Byte[]{}; [EOL]         final Byte[] result = ArrayUtils.nullToEmpty(empty); [EOL]         assertArrayEquals(ArrayUtils.EMPTY_BYTE_OBJECT_ARRAY, result); [EOL]         assertTrue(empty != result); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testNullToEmptyDoubleObject() { [EOL]         // Test null handling [EOL]         assertArrayEquals(ArrayUtils.EMPTY_DOUBLE_OBJECT_ARRAY, ArrayUtils.nullToEmpty((Double[]) null)); [EOL]         // Test valid array handling [EOL]         final Double[] original = new Double[] {1D, 2D}; [EOL]         assertArrayEquals(original, ArrayUtils.nullToEmpty(original)); [EOL]         // Test empty array handling [EOL]         final Double[] empty = new Double[]{}; [EOL]         final Double[] result = ArrayUtils.nullToEmpty(empty); [EOL]         assertArrayEquals(ArrayUtils.EMPTY_DOUBLE_OBJECT_ARRAY, result); [EOL]         assertTrue(empty != result); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testSubarrayObject() { [EOL]         final Object[] nullArray = null; [EOL]         final Object[] objectArray = { "a", "b", "c", "d", "e", "f"}; [EOL]  [EOL]         assertEquals("0 start, mid end", "abcd", [EOL]             StringUtils.join(ArrayUtils.subarray(objectArray, 0, 4))); [EOL]         assertEquals("0 start, length end", "abcdef", [EOL]             StringUtils.join(ArrayUtils.subarray(objectArray, 0, objectArray.length))); [EOL]         assertEquals("mid start, mid end", "bcd", [EOL]             StringUtils.join(ArrayUtils.subarray(objectArray, 1, 4))); [EOL]         assertEquals("mid start, length end", "bcdef", [EOL]             StringUtils.join(ArrayUtils.subarray(objectArray, 1, objectArray.length))); [EOL]  [EOL]         assertNull("null input", ArrayUtils.subarray(nullArray, 0, 3)); [EOL]         assertEquals("empty array", "", [EOL]             StringUtils.join(ArrayUtils.subarray(ArrayUtils.EMPTY_OBJECT_ARRAY, 1, 2))); [EOL]         assertEquals("start > end", "", [EOL]             StringUtils.join(ArrayUtils.subarray(objectArray,
@Test [EOL]     public void testDeserializeBytesOfNull() throws Exception { [EOL]         final ByteArrayOutputStream streamReal = new ByteArrayOutputStream(); [EOL]         final ObjectOutputStream oos = new ObjectOutputStream(streamReal); [EOL]         oos.writeObject(null); [EOL]         oos.flush(); [EOL]         oos.close(); [EOL]  [EOL]         final Object test = SerializationUtils.deserialize(streamReal.toByteArray()); [EOL]         assertNull(test); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSubarrayObject() { [EOL]         final Object[] nullArray = null; [EOL]         final Object[] objectArray = { "a", "b", "c", "d", "e", "f"}; [EOL]  [EOL]         assertEquals("0 start, mid end", "abcd", [EOL]             StringUtils.join(ArrayUtils.subarray(objectArray, 0, 4))); [EOL]         assertEquals("0 start, length end", "abcdef", [EOL]             StringUtils.join(ArrayUtils.subarray(objectArray, 0, objectArray.length))); [EOL]         assertEquals("mid start, mid end", "bcd", [EOL]             StringUtils.join(ArrayUtils.subarray(objectArray, 1, 4))); [EOL]         assertEquals("mid start, length end", "bcdef", [EOL]             StringUtils.join(ArrayUtils.subarray(objectArray, 1, objectArray.length))); [EOL]  [EOL]         assertNull("null input", ArrayUtils.subarray(nullArray, 0, 3)); [EOL]         assertEquals("empty array", "", [EOL]             StringUtils.join(ArrayUtils.subarray(ArrayUtils.EMPTY_OBJECT_ARRAY, 1, 2))); [EOL]         assertEquals("start > end", "", [EOL]             StringUtils.join(ArrayUtils.subarray(objectArray,
@Test [EOL]     public void testSubarrayObject() { [EOL]         final Object[] nullArray = null; [EOL]         final Object[] objectArray = { "a", "b", "c", "d", "e", "f"}; [EOL]  [EOL]         assertEquals("0 start, mid end", "abcd", [EOL]             StringUtils.join(ArrayUtils.subarray(objectArray, 0, 4))); [EOL]         assertEquals("0 start, length end", "abcdef", [EOL]             StringUtils.join(ArrayUtils.subarray(objectArray, 0, objectArray.length))); [EOL]         assertEquals("mid start, mid end", "bcd", [EOL]             StringUtils.join(ArrayUtils.subarray(objectArray, 1, 4))); [EOL]         assertEquals("mid start, length end", "bcdef", [EOL]             StringUtils.join(ArrayUtils.subarray(objectArray, 1, objectArray.length))); [EOL]  [EOL]         assertNull("null input", ArrayUtils.subarray(nullArray, 0, 3)); [EOL]         assertEquals("empty array", "", [EOL]             StringUtils.join(ArrayUtils.subarray(ArrayUtils.EMPTY_OBJECT_ARRAY, 1, 2))); [EOL]         assertEquals("start > end", "", [EOL]             StringUtils.join(ArrayUtils.subarray(objectArray,
@Test [EOL]     public void testSubarrayLong() { [EOL]         final long[] nullArray = null; [EOL]         final long[] array = { 999910, 999911, 999912, 999913, 999914, 999915 }; [EOL]         final long[] leftSubarray     = { 999910, 999911, 999912, 999913 }; [EOL]         final long[] midSubarray      = { 999911, 999912, 999913, 999914 }; [EOL]         final long[] rightSubarray    = { 999912, 999913, 999914, 999915 }; [EOL]  [EOL]         assertTrue("0 start, mid end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, 0, 4))); [EOL]  [EOL]         assertTrue("0 start, length end", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, 0, array.length))); [EOL]  [EOL]         assertTrue("mid start, mid end", [EOL]             ArrayUtils.isEquals(midSubarray, [EOL]                 ArrayUtils.subarray(array, 1, 5))); [EOL]  [EOL]         assertTrue("mid start, length end", [EOL]    
@Test [EOL]     public void testSubarrayLong() { [EOL]         final long[] nullArray = null; [EOL]         final long[] array = { 999910, 999911, 999912, 999913, 999914, 999915 }; [EOL]         final long[] leftSubarray     = { 999910, 999911, 999912, 999913 }; [EOL]         final long[] midSubarray      = { 999911, 999912, 999913, 999914 }; [EOL]         final long[] rightSubarray    = { 999912, 999913, 999914, 999915 }; [EOL]  [EOL]         assertTrue("0 start, mid end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, 0, 4))); [EOL]  [EOL]         assertTrue("0 start, length end", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, 0, array.length))); [EOL]  [EOL]         assertTrue("mid start, mid end", [EOL]             ArrayUtils.isEquals(midSubarray, [EOL]                 ArrayUtils.subarray(array, 1, 5))); [EOL]  [EOL]         assertTrue("mid start, length end", [EOL]    
@Test [EOL]     public void testSubarrayLong() { [EOL]         final long[] nullArray = null; [EOL]         final long[] array = { 999910, 999911, 999912, 999913, 999914, 999915 }; [EOL]         final long[] leftSubarray     = { 999910, 999911, 999912, 999913 }; [EOL]         final long[] midSubarray      = { 999911, 999912, 999913, 999914 }; [EOL]         final long[] rightSubarray    = { 999912, 999913, 999914, 999915 }; [EOL]  [EOL]         assertTrue("0 start, mid end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, 0, 4))); [EOL]  [EOL]         assertTrue("0 start, length end", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, 0, array.length))); [EOL]  [EOL]         assertTrue("mid start, mid end", [EOL]             ArrayUtils.isEquals(midSubarray, [EOL]                 ArrayUtils.subarray(array, 1, 5))); [EOL]  [EOL]         assertTrue("mid start, length end", [EOL]    
@Test [EOL]     public void testSubarrayLong() { [EOL]         final long[] nullArray = null; [EOL]         final long[] array = { 999910, 999911, 999912, 999913, 999914, 999915 }; [EOL]         final long[] leftSubarray     = { 999910, 999911, 999912, 999913 }; [EOL]         final long[] midSubarray      = { 999911, 999912, 999913, 999914 }; [EOL]         final long[] rightSubarray    = { 999912, 999913, 999914, 999915 }; [EOL]  [EOL]         assertTrue("0 start, mid end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, 0, 4))); [EOL]  [EOL]         assertTrue("0 start, length end", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, 0, array.length))); [EOL]  [EOL]         assertTrue("mid start, mid end", [EOL]             ArrayUtils.isEquals(midSubarray, [EOL]                 ArrayUtils.subarray(array, 1, 5))); [EOL]  [EOL]         assertTrue("mid start, length end", [EOL]    
@Test [EOL]     public void testSubarrayShort() { [EOL]         final short[] nullArray = null; [EOL]         final short[] array = { 10, 11, 12, 13, 14, 15 }; [EOL]         final short[] leftSubarray    = { 10, 11, 12, 13 }; [EOL]         final short[] midSubarray     = { 11, 12, 13, 14 }; [EOL]         final short[] rightSubarray   = { 12, 13, 14, 15 }; [EOL]  [EOL]  [EOL]         assertTrue("0 start, mid end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, 0, 4))); [EOL]  [EOL]         assertTrue("0 start, length end", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, 0, array.length))); [EOL]  [EOL]         assertTrue("mid start, mid end", [EOL]             ArrayUtils.isEquals(midSubarray, [EOL]                 ArrayUtils.subarray(array, 1, 5))); [EOL]  [EOL]         assertTrue("mid start, length end", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]          
@Test [EOL]     public void testSubarrayShort() { [EOL]         final short[] nullArray = null; [EOL]         final short[] array = { 10, 11, 12, 13, 14, 15 }; [EOL]         final short[] leftSubarray    = { 10, 11, 12, 13 }; [EOL]         final short[] midSubarray     = { 11, 12, 13, 14 }; [EOL]         final short[] rightSubarray   = { 12, 13, 14, 15 }; [EOL]  [EOL]  [EOL]         assertTrue("0 start, mid end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, 0, 4))); [EOL]  [EOL]         assertTrue("0 start, length end", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, 0, array.length))); [EOL]  [EOL]         assertTrue("mid start, mid end", [EOL]             ArrayUtils.isEquals(midSubarray, [EOL]                 ArrayUtils.subarray(array, 1, 5))); [EOL]  [EOL]         assertTrue("mid start, length end", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]          
@Test [EOL]     public void testSubarrayShort() { [EOL]         final short[] nullArray = null; [EOL]         final short[] array = { 10, 11, 12, 13, 14, 15 }; [EOL]         final short[] leftSubarray    = { 10, 11, 12, 13 }; [EOL]         final short[] midSubarray     = { 11, 12, 13, 14 }; [EOL]         final short[] rightSubarray   = { 12, 13, 14, 15 }; [EOL]  [EOL]  [EOL]         assertTrue("0 start, mid end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, 0, 4))); [EOL]  [EOL]         assertTrue("0 start, length end", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, 0, array.length))); [EOL]  [EOL]         assertTrue("mid start, mid end", [EOL]             ArrayUtils.isEquals(midSubarray, [EOL]                 ArrayUtils.subarray(array, 1, 5))); [EOL]  [EOL]         assertTrue("mid start, length end", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]          
@Test [EOL]     public void testSubarrChar() { [EOL]         final char[] nullArray = null; [EOL]         final char[] array = { 'a', 'b', 'c', 'd', 'e', 'f' }; [EOL]         final char[] leftSubarray     = { 'a', 'b', 'c', 'd', }; [EOL]         final char[] midSubarray      = { 'b', 'c', 'd', 'e', }; [EOL]         final char[] rightSubarray    = { 'c', 'd', 'e', 'f', }; [EOL]  [EOL]  [EOL]         assertTrue("0 start, mid end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, 0, 4))); [EOL]  [EOL]         assertTrue("0 start, length end", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, 0, array.length))); [EOL]  [EOL]         assertTrue("mid start, mid end", [EOL]             ArrayUtils.isEquals(midSubarray, [EOL]                 ArrayUtils.subarray(array, 1, 5))); [EOL]  [EOL]         assertTrue("mid start, length end", [EOL]             Array
@Test [EOL]     public void testSubarrChar() { [EOL]         final char[] nullArray = null; [EOL]         final char[] array = { 'a', 'b', 'c', 'd', 'e', 'f' }; [EOL]         final char[] leftSubarray     = { 'a', 'b', 'c', 'd', }; [EOL]         final char[] midSubarray      = { 'b', 'c', 'd', 'e', }; [EOL]         final char[] rightSubarray    = { 'c', 'd', 'e', 'f', }; [EOL]  [EOL]  [EOL]         assertTrue("0 start, mid end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, 0, 4))); [EOL]  [EOL]         assertTrue("0 start, length end", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, 0, array.length))); [EOL]  [EOL]         assertTrue("mid start, mid end", [EOL]             ArrayUtils.isEquals(midSubarray, [EOL]                 ArrayUtils.subarray(array, 1, 5))); [EOL]  [EOL]         assertTrue("mid start, length end", [EOL]             Array
@Test [EOL]     public void testSubarrChar() { [EOL]         final char[] nullArray = null; [EOL]         final char[] array = { 'a', 'b', 'c', 'd', 'e', 'f' }; [EOL]         final char[] leftSubarray     = { 'a', 'b', 'c', 'd', }; [EOL]         final char[] midSubarray      = { 'b', 'c', 'd', 'e', }; [EOL]         final char[] rightSubarray    = { 'c', 'd', 'e', 'f', }; [EOL]  [EOL]  [EOL]         assertTrue("0 start, mid end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, 0, 4))); [EOL]  [EOL]         assertTrue("0 start, length end", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, 0, array.length))); [EOL]  [EOL]         assertTrue("mid start, mid end", [EOL]             ArrayUtils.isEquals(midSubarray, [EOL]                 ArrayUtils.subarray(array, 1, 5))); [EOL]  [EOL]         assertTrue("mid start, length end", [EOL]             Array
@Test [EOL]     public void testSubarrChar() { [EOL]         final char[] nullArray = null; [EOL]         final char[] array = { 'a', 'b', 'c', 'd', 'e', 'f' }; [EOL]         final char[] leftSubarray     = { 'a', 'b', 'c', 'd', }; [EOL]         final char[] midSubarray      = { 'b', 'c', 'd', 'e', }; [EOL]         final char[] rightSubarray    = { 'c', 'd', 'e', 'f', }; [EOL]  [EOL]  [EOL]         assertTrue("0 start, mid end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, 0, 4))); [EOL]  [EOL]         assertTrue("0 start, length end", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, 0, array.length))); [EOL]  [EOL]         assertTrue("mid start, mid end", [EOL]             ArrayUtils.isEquals(midSubarray, [EOL]                 ArrayUtils.subarray(array, 1, 5))); [EOL]  [EOL]         assertTrue("mid start, length end", [EOL]             Array
@Test [EOL]     public void testSubarrChar() { [EOL]         final char[] nullArray = null; [EOL]         final char[] array = { 'a', 'b', 'c', 'd', 'e', 'f' }; [EOL]         final char[] leftSubarray     = { 'a', 'b', 'c', 'd', }; [EOL]         final char[] midSubarray      = { 'b', 'c', 'd', 'e', }; [EOL]         final char[] rightSubarray    = { 'c', 'd', 'e', 'f', }; [EOL]  [EOL]  [EOL]         assertTrue("0 start, mid end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, 0, 4))); [EOL]  [EOL]         assertTrue("0 start, length end", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, 0, array.length))); [EOL]  [EOL]         assertTrue("mid start, mid end", [EOL]             ArrayUtils.isEquals(midSubarray, [EOL]                 ArrayUtils.subarray(array, 1, 5))); [EOL]  [EOL]         assertTrue("mid start, length end", [EOL]             Array
@Test [EOL]     public void testSubarrayByte() { [EOL]         final byte[] nullArray = null; [EOL]         final byte[] array = { 10, 11, 12, 13, 14, 15 }; [EOL]         final byte[] leftSubarray     = { 10, 11, 12, 13 }; [EOL]         final byte[] midSubarray      = { 11, 12, 13, 14 }; [EOL]         final byte[] rightSubarray = { 12, 13, 14, 15 }; [EOL]  [EOL]  [EOL]         assertTrue("0 start, mid end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, 0, 4))); [EOL]  [EOL]         assertTrue("0 start, length end", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, 0, array.length))); [EOL]  [EOL]         assertTrue("mid start, mid end", [EOL]             ArrayUtils.isEquals(midSubarray, [EOL]                 ArrayUtils.subarray(array, 1, 5))); [EOL]  [EOL]         assertTrue("mid start, length end", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]          
@Test [EOL]     public void testSubarrayByte() { [EOL]         final byte[] nullArray = null; [EOL]         final byte[] array = { 10, 11, 12, 13, 14, 15 }; [EOL]         final byte[] leftSubarray     = { 10, 11, 12, 13 }; [EOL]         final byte[] midSubarray      = { 11, 12, 13, 14 }; [EOL]         final byte[] rightSubarray = { 12, 13, 14, 15 }; [EOL]  [EOL]  [EOL]         assertTrue("0 start, mid end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, 0, 4))); [EOL]  [EOL]         assertTrue("0 start, length end", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, 0, array.length))); [EOL]  [EOL]         assertTrue("mid start, mid end", [EOL]             ArrayUtils.isEquals(midSubarray, [EOL]                 ArrayUtils.subarray(array, 1, 5))); [EOL]  [EOL]         assertTrue("mid start, length end", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]          
@Test [EOL]     public void testSubarrayByte() { [EOL]         final byte[] nullArray = null; [EOL]         final byte[] array = { 10, 11, 12, 13, 14, 15 }; [EOL]         final byte[] leftSubarray     = { 10, 11, 12, 13 }; [EOL]         final byte[] midSubarray      = { 11, 12, 13, 14 }; [EOL]         final byte[] rightSubarray = { 12, 13, 14, 15 }; [EOL]  [EOL]  [EOL]         assertTrue("0 start, mid end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, 0, 4))); [EOL]  [EOL]         assertTrue("0 start, length end", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, 0, array.length))); [EOL]  [EOL]         assertTrue("mid start, mid end", [EOL]             ArrayUtils.isEquals(midSubarray, [EOL]                 ArrayUtils.subarray(array, 1, 5))); [EOL]  [EOL]         assertTrue("mid start, length end", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]          
@Test [EOL]     public void testSubarrayByte() { [EOL]         final byte[] nullArray = null; [EOL]         final byte[] array = { 10, 11, 12, 13, 14, 15 }; [EOL]         final byte[] leftSubarray     = { 10, 11, 12, 13 }; [EOL]         final byte[] midSubarray      = { 11, 12, 13, 14 }; [EOL]         final byte[] rightSubarray = { 12, 13, 14, 15 }; [EOL]  [EOL]  [EOL]         assertTrue("0 start, mid end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, 0, 4))); [EOL]  [EOL]         assertTrue("0 start, length end", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, 0, array.length))); [EOL]  [EOL]         assertTrue("mid start, mid end", [EOL]             ArrayUtils.isEquals(midSubarray, [EOL]                 ArrayUtils.subarray(array, 1, 5))); [EOL]  [EOL]         assertTrue("mid start, length end", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]          
@Test [EOL]     public void testSubarrayFloat() { [EOL]         final float[] nullArray = null; [EOL]         final float[] array = { 10, 11, 12, 13, 14, 15 }; [EOL]         final float[] leftSubarray    = { 10, 11, 12, 13 }; [EOL]         final float[] midSubarray     = { 11, 12, 13, 14 }; [EOL]         final float[] rightSubarray   = { 12, 13, 14, 15 }; [EOL]  [EOL]  [EOL]         assertTrue("0 start, mid end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, 0, 4))); [EOL]  [EOL]         assertTrue("0 start, length end", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, 0, array.length))); [EOL]  [EOL]         assertTrue("mid start, mid end", [EOL]             ArrayUtils.isEquals(midSubarray, [EOL]                 ArrayUtils.subarray(array, 1, 5))); [EOL]  [EOL]         assertTrue("mid start, length end", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]          
@Test [EOL]     public void testSubarrayBoolean() { [EOL]         final boolean[] nullArray = null; [EOL]         final boolean[] array = { true, true, false, true, false, true }; [EOL]         final boolean[] leftSubarray  = { true, true, false, true  }; [EOL]         final boolean[] midSubarray   = { true, false, true, false }; [EOL]         final boolean[] rightSubarray = { false, true, false, true }; [EOL]  [EOL]  [EOL]         assertTrue("0 start, mid end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, 0, 4))); [EOL]  [EOL]         assertTrue("0 start, length end", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, 0, array.length))); [EOL]  [EOL]         assertTrue("mid start, mid end", [EOL]             ArrayUtils.isEquals(midSubarray, [EOL]                 ArrayUtils.subarray(array, 1, 5))); [EOL]  [EOL]         assertTrue("mid start, length end", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]              
@Test [EOL]     public void testSubarrayBoolean() { [EOL]         final boolean[] nullArray = null; [EOL]         final boolean[] array = { true, true, false, true, false, true }; [EOL]         final boolean[] leftSubarray  = { true, true, false, true  }; [EOL]         final boolean[] midSubarray   = { true, false, true, false }; [EOL]         final boolean[] rightSubarray = { false, true, false, true }; [EOL]  [EOL]  [EOL]         assertTrue("0 start, mid end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, 0, 4))); [EOL]  [EOL]         assertTrue("0 start, length end", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, 0, array.length))); [EOL]  [EOL]         assertTrue("mid start, mid end", [EOL]             ArrayUtils.isEquals(midSubarray, [EOL]                 ArrayUtils.subarray(array, 1, 5))); [EOL]  [EOL]         assertTrue("mid start, length end", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]              
@Test [EOL]     public void testSubarrayBoolean() { [EOL]         final boolean[] nullArray = null; [EOL]         final boolean[] array = { true, true, false, true, false, true }; [EOL]         final boolean[] leftSubarray  = { true, true, false, true  }; [EOL]         final boolean[] midSubarray   = { true, false, true, false }; [EOL]         final boolean[] rightSubarray = { false, true, false, true }; [EOL]  [EOL]  [EOL]         assertTrue("0 start, mid end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, 0, 4))); [EOL]  [EOL]         assertTrue("0 start, length end", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, 0, array.length))); [EOL]  [EOL]         assertTrue("mid start, mid end", [EOL]             ArrayUtils.isEquals(midSubarray, [EOL]                 ArrayUtils.subarray(array, 1, 5))); [EOL]  [EOL]         assertTrue("mid start, length end", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]              
@Test [EOL]     public void testSubarrayBoolean() { [EOL]         final boolean[] nullArray = null; [EOL]         final boolean[] array = { true, true, false, true, false, true }; [EOL]         final boolean[] leftSubarray  = { true, true, false, true  }; [EOL]         final boolean[] midSubarray   = { true, false, true, false }; [EOL]         final boolean[] rightSubarray = { false, true, false, true }; [EOL]  [EOL]  [EOL]         assertTrue("0 start, mid end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, 0, 4))); [EOL]  [EOL]         assertTrue("0 start, length end", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, 0, array.length))); [EOL]  [EOL]         assertTrue("mid start, mid end", [EOL]             ArrayUtils.isEquals(midSubarray, [EOL]                 ArrayUtils.subarray(array, 1, 5))); [EOL]  [EOL]         assertTrue("mid start, length end", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]              
@Test [EOL]     public void testSubarrayBoolean() { [EOL]         final boolean[] nullArray = null; [EOL]         final boolean[] array = { true, true, false, true, false, true }; [EOL]         final boolean[] leftSubarray  = { true, true, false, true  }; [EOL]         final boolean[] midSubarray   = { true, false, true, false }; [EOL]         final boolean[] rightSubarray = { false, true, false, true }; [EOL]  [EOL]  [EOL]         assertTrue("0 start, mid end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, 0, 4))); [EOL]  [EOL]         assertTrue("0 start, length end", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, 0, array.length))); [EOL]  [EOL]         assertTrue("mid start, mid end", [EOL]             ArrayUtils.isEquals(midSubarray, [EOL]                 ArrayUtils.subarray(array, 1, 5))); [EOL]  [EOL]         assertTrue("mid start, length end", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]              
@Test [EOL]     public void testSameLengthInt() { [EOL]         final int[] nullArray = null; [EOL]         final int[] emptyArray = new int[0]; [EOL]         final int[] oneArray = new int[] {4}; [EOL]         final int[] twoArray = new int[] {5, 7}; [EOL]          [EOL]         assertTrue(ArrayUtils.isSameLength(nullArray, nullArray)); [EOL]         assertTrue(ArrayUtils.isSameLength(nullArray, emptyArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(nullArray, oneArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(nullArray, twoArray)); [EOL]          [EOL]         assertTrue(ArrayUtils.isSameLength(emptyArray, nullArray)); [EOL]         assertTrue(ArrayUtils.isSameLength(emptyArray, emptyArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(emptyArray, oneArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(emptyArray, twoArray)); [EOL]          [EOL]         assertFalse(ArrayUtils.isSameLength(oneArray, nullArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(oneArray, emptyArray)); [EOL]         assertTrue(ArrayUtils.isSameLength(oneArray, oneArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(oneArray, twoArray));
@Test [EOL]     public void testSameLengthShort() { [EOL]         final short[] nullArray = null; [EOL]         final short[] emptyArray = new short[0]; [EOL]         final short[] oneArray = new short[] {4}; [EOL]         final short[] twoArray = new short[] {6, 8}; [EOL]          [EOL]         assertTrue(ArrayUtils.isSameLength(nullArray, nullArray)); [EOL]         assertTrue(ArrayUtils.isSameLength(nullArray, emptyArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(nullArray, oneArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(nullArray, twoArray)); [EOL]          [EOL]         assertTrue(ArrayUtils.isSameLength(emptyArray, nullArray)); [EOL]         assertTrue(ArrayUtils.isSameLength(emptyArray, emptyArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(emptyArray, oneArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(emptyArray, twoArray)); [EOL]          [EOL]         assertFalse(ArrayUtils.isSameLength(oneArray, nullArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(oneArray, emptyArray)); [EOL]         assertTrue(ArrayUtils.isSameLength(oneArray, oneArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(oneArray, twoArray));
@Test [EOL]     public void testSameLengthByte() { [EOL]         final byte[] nullArray = null; [EOL]         final byte[] emptyArray = new byte[0]; [EOL]         final byte[] oneArray = new byte[] {3}; [EOL]         final byte[] twoArray = new byte[] {4, 6}; [EOL]          [EOL]         assertTrue(ArrayUtils.isSameLength(nullArray, nullArray)); [EOL]         assertTrue(ArrayUtils.isSameLength(nullArray, emptyArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(nullArray, oneArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(nullArray, twoArray)); [EOL]          [EOL]         assertTrue(ArrayUtils.isSameLength(emptyArray, nullArray)); [EOL]         assertTrue(ArrayUtils.isSameLength(emptyArray, emptyArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(emptyArray, oneArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(emptyArray, twoArray)); [EOL]          [EOL]         assertFalse(ArrayUtils.isSameLength(oneArray, nullArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(oneArray, emptyArray)); [EOL]         assertTrue(ArrayUtils.isSameLength(oneArray, oneArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(oneArray, twoArray));
@Test [EOL]     public void testSameLengthDouble() { [EOL]         final double[] nullArray = null; [EOL]         final double[] emptyArray = new double[0]; [EOL]         final double[] oneArray = new double[] {1.3d}; [EOL]         final double[] twoArray = new double[] {4.5d, 6.3d}; [EOL]          [EOL]         assertTrue(ArrayUtils.isSameLength(nullArray, nullArray)); [EOL]         assertTrue(ArrayUtils.isSameLength(nullArray, emptyArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(nullArray, oneArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(nullArray, twoArray)); [EOL]          [EOL]         assertTrue(ArrayUtils.isSameLength(emptyArray, nullArray)); [EOL]         assertTrue(ArrayUtils.isSameLength(emptyArray, emptyArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(emptyArray, oneArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(emptyArray, twoArray)); [EOL]          [EOL]         assertFalse(ArrayUtils.isSameLength(oneArray, nullArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(oneArray, emptyArray)); [EOL]         assertTrue(ArrayUtils.isSameLength(oneArray, oneArray)); [EOL]         assertFalse(ArrayUtils.is
@Test [EOL]     public void testSameLengthFloat() { [EOL]         final float[] nullArray = null; [EOL]         final float[] emptyArray = new float[0]; [EOL]         final float[] oneArray = new float[] {2.5f}; [EOL]         final float[] twoArray = new float[] {6.4f, 5.8f}; [EOL]          [EOL]         assertTrue(ArrayUtils.isSameLength(nullArray, nullArray)); [EOL]         assertTrue(ArrayUtils.isSameLength(nullArray, emptyArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(nullArray, oneArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(nullArray, twoArray)); [EOL]          [EOL]         assertTrue(ArrayUtils.isSameLength(emptyArray, nullArray)); [EOL]         assertTrue(ArrayUtils.isSameLength(emptyArray, emptyArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(emptyArray, oneArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(emptyArray, twoArray)); [EOL]          [EOL]         assertFalse(ArrayUtils.isSameLength(oneArray, nullArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(oneArray, emptyArray)); [EOL]         assertTrue(ArrayUtils.isSameLength(oneArray, oneArray)); [EOL]         assertFalse(ArrayUtils.is
@Test [EOL]     public void testSameLengthBoolean() { [EOL]         final boolean[] nullArray = null; [EOL]         final boolean[] emptyArray = new boolean[0]; [EOL]         final boolean[] oneArray = new boolean[] {true}; [EOL]         final boolean[] twoArray = new boolean[] {true, false}; [EOL]          [EOL]         assertTrue(ArrayUtils.isSameLength(nullArray, nullArray)); [EOL]         assertTrue(ArrayUtils.isSameLength(nullArray, emptyArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(nullArray, oneArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(nullArray, twoArray)); [EOL]          [EOL]         assertTrue(ArrayUtils.isSameLength(emptyArray, nullArray)); [EOL]         assertTrue(ArrayUtils.isSameLength(emptyArray, emptyArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(emptyArray, oneArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(emptyArray, twoArray)); [EOL]          [EOL]         assertFalse(ArrayUtils.isSameLength(oneArray, nullArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(oneArray, emptyArray)); [EOL]         assertTrue(ArrayUtils.isSameLength(oneArray, oneArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(oneArray, twoArray
@Test [EOL]     public void testReverse() { [EOL]         final StringBuffer str1 = new StringBuffer("pick"); [EOL]         final String str2 = "a"; [EOL]         final String[] str3 = new String[] {"stick"}; [EOL]         final String str4 = "up"; [EOL]          [EOL]         Object[] array = new Object[] {str1, str2, str3}; [EOL]         ArrayUtils.reverse(array); [EOL]         assertEquals(array[0], str3); [EOL]         assertEquals(array[1], str2); [EOL]         assertEquals(array[2], str1); [EOL]          [EOL]         array = new Object[] {str1, str2, str3, str4}; [EOL]         ArrayUtils.reverse(array); [EOL]         assertEquals(array[0], str4); [EOL]         assertEquals(array[1], str3); [EOL]         assertEquals(array[2], str2); [EOL]         assertEquals(array[3], str1); [EOL]  [EOL]         array = null; [EOL]         ArrayUtils.reverse(array); [EOL]         assertArrayEquals(null, array); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReverseLong() { [EOL]         long[] array = new long[] {1L, 2L, 3L}; [EOL]         ArrayUtils.reverse(array); [EOL]         assertEquals(array[0], 3L); [EOL]         assertEquals(array[1], 2L); [EOL]         assertEquals(array[2], 1L); [EOL]  [EOL]         array = null; [EOL]         ArrayUtils.reverse(array); [EOL]         assertEquals(null, array); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testReverseChar() { [EOL]         char[] array = new char[] {'a', 'f', 'C'}; [EOL]         ArrayUtils.reverse(array); [EOL]         assertEquals(array[0], 'C'); [EOL]         assertEquals(array[1], 'f'); [EOL]         assertEquals(array[2], 'a'); [EOL]  [EOL]         array = null; [EOL]         ArrayUtils.reverse(array); [EOL]         assertEquals(null, array); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testReverseByte() { [EOL]         byte[] array = new byte[] {2, 3, 4}; [EOL]         ArrayUtils.reverse(array); [EOL]         assertEquals(array[0], 4); [EOL]         assertEquals(array[1], 3); [EOL]         assertEquals(array[2], 2); [EOL]  [EOL]         array = null; [EOL]         ArrayUtils.reverse(array); [EOL]         assertEquals(null, array); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testReverseBoolean() { [EOL]         boolean[] array = new boolean[] {false, false, true}; [EOL]         ArrayUtils.reverse(array); [EOL]         assertTrue(array[0]); [EOL]         assertFalse(array[1]); [EOL]         assertFalse(array[2]); [EOL]  [EOL]         array = null; [EOL]         ArrayUtils.reverse(array); [EOL]         assertEquals(null, array); [EOL]     } [EOL]      [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testLastIndexOfWithStartIndex() { [EOL]         final Object[] array = new Object[] { "0", "1", "2", "3", null, "0" }; [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(null, null, 2)); [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(null, "0", 2)); [EOL]         assertEquals(0, ArrayUtils.lastIndexOf(array, "0", 2)); [EOL]         assertEquals(1, ArrayUtils.lastIndexOf(array, "1", 2)); [EOL]         assertEquals(2, ArrayUtils.lastIndexOf(array, "2", 2)); [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, "3", 2)); [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, "3", -1)); [EOL]         assertEquals(4, ArrayUtils.lastIndexOf(array, null, 5)); [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, null, 2)); [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, "notInArray", 5)); [EOL]          [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, null, -1)); [EOL]         assertEquals(5, ArrayUtils.lastIndexOf(array, "0", 88)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLastIndexOfLongWithStartIndex() { [EOL]         long[] array = null; [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, 0, 2)); [EOL]         array = new long[] { 0, 1, 2, 3, 0 }; [EOL]         assertEquals(0, ArrayUtils.lastIndexOf(array, 0, 2)); [EOL]         assertEquals(1, ArrayUtils.lastIndexOf(array, 1, 2)); [EOL]         assertEquals(2, ArrayUtils.lastIndexOf(array, 2, 2)); [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, 3, 2)); [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, 3, -1)); [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, 99, 4)); [EOL]         assertEquals(4, ArrayUtils.lastIndexOf(array, 0, 88)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLastIndexOfLongWithStartIndex() { [EOL]         long[] array = null; [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, 0, 2)); [EOL]         array = new long[] { 0, 1, 2, 3, 0 }; [EOL]         assertEquals(0, ArrayUtils.lastIndexOf(array, 0, 2)); [EOL]         assertEquals(1, ArrayUtils.lastIndexOf(array, 1, 2)); [EOL]         assertEquals(2, ArrayUtils.lastIndexOf(array, 2, 2)); [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, 3, 2)); [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, 3, -1)); [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, 99, 4)); [EOL]         assertEquals(4, ArrayUtils.lastIndexOf(array, 0, 88)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testContainsShort() { [EOL]         short[] array = null; [EOL]         assertFalse(ArrayUtils.contains(array, (short) 1)); [EOL]         array = new short[] { 0, 1, 2, 3, 0 }; [EOL]         assertTrue(ArrayUtils.contains(array, (short) 0)); [EOL]         assertTrue(ArrayUtils.contains(array, (short) 1)); [EOL]         assertTrue(ArrayUtils.contains(array, (short) 2)); [EOL]         assertTrue(ArrayUtils.contains(array, (short) 3)); [EOL]         assertFalse(ArrayUtils.contains(array, (short) 99)); [EOL]     } [EOL]      [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testIndexOfCharWithStartIndex() { [EOL]         char[] array = null; [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, 'a', 2)); [EOL]         array = new char[] { 'a', 'b', 'c', 'd', 'a' }; [EOL]         assertEquals(4, ArrayUtils.indexOf(array, 'a', 2)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, 'b', 2)); [EOL]         assertEquals(2, ArrayUtils.indexOf(array, 'c', 2)); [EOL]         assertEquals(3, ArrayUtils.indexOf(array, 'd', 2)); [EOL]         assertEquals(3, ArrayUtils.indexOf(array, 'd', -1)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, 'e', 0)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, 'a', 6)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLastIndexOfCharWithStartIndex() { [EOL]         char[] array = null; [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, 'a', 2)); [EOL]         array = new char[] { 'a', 'b', 'c', 'd', 'a' }; [EOL]         assertEquals(0, ArrayUtils.lastIndexOf(array, 'a', 2)); [EOL]         assertEquals(1, ArrayUtils.lastIndexOf(array, 'b', 2)); [EOL]         assertEquals(2, ArrayUtils.lastIndexOf(array, 'c', 2)); [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, 'd', 2)); [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, 'd', -1)); [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, 'e')); [EOL]         assertEquals(4, ArrayUtils.lastIndexOf(array, 'a', 88)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testRemoveElementByteArray() { [EOL]         byte[] array; [EOL]         array = ArrayUtils.removeElements((byte[]) null, (byte) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2, 1 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUt
@Test [EOL]     public void testLastIndexOfFloatWithStartIndex() { [EOL]         float[] array = null; [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, (float) 0, 2)); [EOL]         array = new float[0]; [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, (float) 0, 2)); [EOL]         array = new float[] { 0, 1, 2, 3, 0 }; [EOL]         assertEquals(0, ArrayUtils.lastIndexOf(array, (float) 0, 2)); [EOL]         assertEquals(1, ArrayUtils.lastIndexOf(array, (float) 1, 2)); [EOL]         assertEquals(2, ArrayUtils.lastIndexOf(array, (float) 2, 2)); [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, (float) 3, 2)); [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, (float) 3, -1)); [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, (float) 99)); [EOL]         assertEquals(4, ArrayUtils.lastIndexOf(array, (float) 0, 88)); [EOL]     } [EOL]  [EOL]     @SuppressWarnings("cast") [EOL]
@Test [EOL]     public void testToPrimitive_char() { [EOL]         final Character[] b = null; [EOL]         assertEquals(null, ArrayUtils.toPrimitive(b)); [EOL]          [EOL]         assertSame(ArrayUtils.EMPTY_CHAR_ARRAY, ArrayUtils.toPrimitive(new Character[0])); [EOL]          [EOL]         assertTrue(Arrays.equals( [EOL]             new char[] {Character.MIN_VALUE, Character.MAX_VALUE, '0'}, [EOL]             ArrayUtils.toPrimitive(new Character[] {new Character(Character.MIN_VALUE),  [EOL]                 new Character(Character.MAX_VALUE), new Character('0')})) [EOL]         ); [EOL]  [EOL]         try { [EOL]             ArrayUtils.toPrimitive(new Character[] {new Character(Character.MIN_VALUE), null}); [EOL]             fail(); [EOL]         } catch (final NullPointerException ex) {} [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testToPrimitive_char_char() { [EOL]         final Character[] b = null; [EOL]         assertEquals(null, ArrayUtils.toPrimitive(b, Character.MIN_VALUE)); [EOL]          [EOL]         assertSame(ArrayUtils.EMPTY_CHAR_ARRAY,  [EOL]             ArrayUtils.toPrimitive(new Character[0], (char)0)); [EOL]          [EOL]         assertTrue(Arrays.equals( [EOL]             new char[] {Character.MIN_VALUE, Character.MAX_VALUE, '0'}, [EOL]             ArrayUtils.toPrimitive(new Character[] {new Character(Character.MIN_VALUE),  [EOL]                 new Character(Character.MAX_VALUE), new Character('0')},  [EOL]                 Character.MIN_VALUE)) [EOL]         ); [EOL]          [EOL]         assertTrue(Arrays.equals( [EOL]             new char[] {Character.MIN_VALUE, Character.MAX_VALUE, '0'}, [EOL]             ArrayUtils.toPrimitive(new Character[] {new Character(Character.MIN_VALUE), null,  [EOL]                 new Character('0')}, Character.MAX_VALUE)) [EOL]         ); [EOL]     } [
@Test [EOL]     public void testToObject_char() { [EOL]         final char[] b = null; [EOL]         assertArrayEquals(null, ArrayUtils.toObject(b)); [EOL]          [EOL]         assertSame(ArrayUtils.EMPTY_CHARACTER_OBJECT_ARRAY,  [EOL]             ArrayUtils.toObject(new char[0])); [EOL]          [EOL]         assertTrue(Arrays.equals( [EOL]             new Character[] {new Character(Character.MIN_VALUE),  [EOL]                 new Character(Character.MAX_VALUE), new Character('0')}, [EOL]                 ArrayUtils.toObject(new char[] {Character.MIN_VALUE, Character.MAX_VALUE,  [EOL]                 '0'} )) [EOL]         ); [EOL]     } [EOL]      [EOL]     // testToPrimitive/Object for byte [EOL]     //  ----------------------------------------------------------------------- [EOL]
@Test [EOL]      public void testToPrimitive_long() { [EOL]          final Long[] b = null; [EOL]          assertEquals(null, ArrayUtils.toPrimitive(b)); [EOL]           [EOL]          assertSame(ArrayUtils.EMPTY_LONG_ARRAY,  [EOL]             ArrayUtils.toPrimitive(new Long[0])); [EOL]           [EOL]          assertTrue(Arrays.equals( [EOL]              new long[] {Long.MIN_VALUE, Long.MAX_VALUE, 9999999}, [EOL]              ArrayUtils.toPrimitive(new Long[] {Long.valueOf(Long.MIN_VALUE),  [EOL]                  Long.valueOf(Long.MAX_VALUE), Long.valueOf(9999999)})) [EOL]          ); [EOL]  [EOL]          try { [EOL]              ArrayUtils.toPrimitive(new Long[] {Long.valueOf(Long.MIN_VALUE), null}); [EOL]              fail(); [EOL]          } catch (final NullPointerException ex) {} [EOL]      } [EOL]  [EOL]
@Test [EOL]      public void testToPrimitive_long() { [EOL]          final Long[] b = null; [EOL]          assertEquals(null, ArrayUtils.toPrimitive(b)); [EOL]           [EOL]          assertSame(ArrayUtils.EMPTY_LONG_ARRAY,  [EOL]             ArrayUtils.toPrimitive(new Long[0])); [EOL]           [EOL]          assertTrue(Arrays.equals( [EOL]              new long[] {Long.MIN_VALUE, Long.MAX_VALUE, 9999999}, [EOL]              ArrayUtils.toPrimitive(new Long[] {Long.valueOf(Long.MIN_VALUE),  [EOL]                  Long.valueOf(Long.MAX_VALUE), Long.valueOf(9999999)})) [EOL]          ); [EOL]  [EOL]          try { [EOL]              ArrayUtils.toPrimitive(new Long[] {Long.valueOf(Long.MIN_VALUE), null}); [EOL]              fail(); [EOL]          } catch (final NullPointerException ex) {} [EOL]      } [EOL]  [EOL]
@Test [EOL]      public void testToPrimitive_long_long() { [EOL]          final Long[] l = null; [EOL]          assertEquals(null, ArrayUtils.toPrimitive(l, Long.MIN_VALUE)); [EOL]           [EOL]          assertSame(ArrayUtils.EMPTY_LONG_ARRAY,  [EOL]          ArrayUtils.toPrimitive(new Long[0], 1)); [EOL]           [EOL]          assertTrue(Arrays.equals( [EOL]              new long[] {Long.MIN_VALUE, Long.MAX_VALUE, 9999999}, [EOL]              ArrayUtils.toPrimitive(new Long[] {Long.valueOf(Long.MIN_VALUE),  [EOL]                  Long.valueOf(Long.MAX_VALUE), Long.valueOf(9999999)},1))); [EOL]           [EOL]          assertTrue(Arrays.equals( [EOL]              new long[] {Long.MIN_VALUE, Long.MAX_VALUE, 9999999}, [EOL]              ArrayUtils.toPrimitive(new Long[] {Long.valueOf(Long.MIN_VALUE),  [EOL]                  null, Long.valueOf(9999999)}, Long.MAX_VALUE)) [EOL]          ); [EOL]      } [EOL]       [EOL]
@Test [EOL]      public void testToPrimitive_long_long() { [EOL]          final Long[] l = null; [EOL]          assertEquals(null, ArrayUtils.toPrimitive(l, Long.MIN_VALUE)); [EOL]           [EOL]          assertSame(ArrayUtils.EMPTY_LONG_ARRAY,  [EOL]          ArrayUtils.toPrimitive(new Long[0], 1)); [EOL]           [EOL]          assertTrue(Arrays.equals( [EOL]              new long[] {Long.MIN_VALUE, Long.MAX_VALUE, 9999999}, [EOL]              ArrayUtils.toPrimitive(new Long[] {Long.valueOf(Long.MIN_VALUE),  [EOL]                  Long.valueOf(Long.MAX_VALUE), Long.valueOf(9999999)},1))); [EOL]           [EOL]          assertTrue(Arrays.equals( [EOL]              new long[] {Long.MIN_VALUE, Long.MAX_VALUE, 9999999}, [EOL]              ArrayUtils.toPrimitive(new Long[] {Long.valueOf(Long.MIN_VALUE),  [EOL]                  null, Long.valueOf(9999999)}, Long.MAX_VALUE)) [EOL]          ); [EOL]      } [EOL]       [EOL]
@Test [EOL]     public void testToObject_long() { [EOL]         final long[] b = null; [EOL]         assertArrayEquals(null, ArrayUtils.toObject(b)); [EOL]      [EOL]         assertSame( [EOL]             ArrayUtils.EMPTY_LONG_OBJECT_ARRAY, [EOL]             ArrayUtils.toObject(new long[0])); [EOL]      [EOL]         assertTrue( [EOL]             Arrays.equals( [EOL]                 new Long[] { [EOL]                     Long.valueOf(Long.MIN_VALUE), [EOL]                     Long.valueOf(Long.MAX_VALUE), [EOL]                     Long.valueOf(9999999)}, [EOL]             ArrayUtils.toObject( [EOL]                 new long[] { Long.MIN_VALUE, Long.MAX_VALUE, 9999999 }))); [EOL]     } [EOL]  [EOL]     //  testToPrimitive/Object for float [EOL]     //  ----------------------------------------------------------------------- [EOL]
@Test [EOL]      public void testToPrimitive_int() { [EOL]          final Integer[] b = null; [EOL]          assertEquals(null, ArrayUtils.toPrimitive(b)); [EOL]          assertSame(ArrayUtils.EMPTY_INT_ARRAY, ArrayUtils.toPrimitive(new Integer[0])); [EOL]          assertTrue(Arrays.equals( [EOL]              new int[] {Integer.MIN_VALUE, Integer.MAX_VALUE, 9999999}, [EOL]              ArrayUtils.toPrimitive(new Integer[] {Integer.valueOf(Integer.MIN_VALUE),  [EOL]                  Integer.valueOf(Integer.MAX_VALUE), Integer.valueOf(9999999)})) [EOL]          ); [EOL]  [EOL]          try { [EOL]              ArrayUtils.toPrimitive(new Integer[] {Integer.valueOf(Integer.MIN_VALUE), null}); [EOL]              fail(); [EOL]          } catch (final NullPointerException ex) {} [EOL]      } [EOL]  [EOL]
@Test [EOL]      public void testToPrimitive_int() { [EOL]          final Integer[] b = null; [EOL]          assertEquals(null, ArrayUtils.toPrimitive(b)); [EOL]          assertSame(ArrayUtils.EMPTY_INT_ARRAY, ArrayUtils.toPrimitive(new Integer[0])); [EOL]          assertTrue(Arrays.equals( [EOL]              new int[] {Integer.MIN_VALUE, Integer.MAX_VALUE, 9999999}, [EOL]              ArrayUtils.toPrimitive(new Integer[] {Integer.valueOf(Integer.MIN_VALUE),  [EOL]                  Integer.valueOf(Integer.MAX_VALUE), Integer.valueOf(9999999)})) [EOL]          ); [EOL]  [EOL]          try { [EOL]              ArrayUtils.toPrimitive(new Integer[] {Integer.valueOf(Integer.MIN_VALUE), null}); [EOL]              fail(); [EOL]          } catch (final NullPointerException ex) {} [EOL]      } [EOL]  [EOL]
@Test [EOL]      public void testToPrimitive_int_int() { [EOL]          final Integer[] l = null; [EOL]          assertEquals(null, ArrayUtils.toPrimitive(l, Integer.MIN_VALUE)); [EOL]           [EOL]          assertSame(ArrayUtils.EMPTY_INT_ARRAY,  [EOL]           ArrayUtils.toPrimitive(new Integer[0], 1)); [EOL]           [EOL]          assertTrue(Arrays.equals( [EOL]              new int[] {Integer.MIN_VALUE, Integer.MAX_VALUE, 9999999}, [EOL]              ArrayUtils.toPrimitive(new Integer[] {Integer.valueOf(Integer.MIN_VALUE),  [EOL]                  Integer.valueOf(Integer.MAX_VALUE), Integer.valueOf(9999999)},1))); [EOL]           [EOL]          assertTrue(Arrays.equals( [EOL]              new int[] {Integer.MIN_VALUE, Integer.MAX_VALUE, 9999999}, [EOL]              ArrayUtils.toPrimitive(new Integer[] {Integer.valueOf(Integer.MIN_VALUE),  [EOL]                  null, Integer.valueOf(9999999)}, Integer.MAX_VALUE)) [EOL]          ); [EOL]      } [EOL]       [EOL]
@Test [EOL]      public void testToPrimitive_int_int() { [EOL]          final Integer[] l = null; [EOL]          assertEquals(null, ArrayUtils.toPrimitive(l, Integer.MIN_VALUE)); [EOL]           [EOL]          assertSame(ArrayUtils.EMPTY_INT_ARRAY,  [EOL]           ArrayUtils.toPrimitive(new Integer[0], 1)); [EOL]           [EOL]          assertTrue(Arrays.equals( [EOL]              new int[] {Integer.MIN_VALUE, Integer.MAX_VALUE, 9999999}, [EOL]              ArrayUtils.toPrimitive(new Integer[] {Integer.valueOf(Integer.MIN_VALUE),  [EOL]                  Integer.valueOf(Integer.MAX_VALUE), Integer.valueOf(9999999)},1))); [EOL]           [EOL]          assertTrue(Arrays.equals( [EOL]              new int[] {Integer.MIN_VALUE, Integer.MAX_VALUE, 9999999}, [EOL]              ArrayUtils.toPrimitive(new Integer[] {Integer.valueOf(Integer.MIN_VALUE),  [EOL]                  null, Integer.valueOf(9999999)}, Integer.MAX_VALUE)) [EOL]          ); [EOL]      } [EOL]       [EOL]
@Test [EOL]      public void testToPrimitive_int() { [EOL]          final Integer[] b = null; [EOL]          assertEquals(null, ArrayUtils.toPrimitive(b)); [EOL]          assertSame(ArrayUtils.EMPTY_INT_ARRAY, ArrayUtils.toPrimitive(new Integer[0])); [EOL]          assertTrue(Arrays.equals( [EOL]              new int[] {Integer.MIN_VALUE, Integer.MAX_VALUE, 9999999}, [EOL]              ArrayUtils.toPrimitive(new Integer[] {Integer.valueOf(Integer.MIN_VALUE),  [EOL]                  Integer.valueOf(Integer.MAX_VALUE), Integer.valueOf(9999999)})) [EOL]          ); [EOL]  [EOL]          try { [EOL]              ArrayUtils.toPrimitive(new Integer[] {Integer.valueOf(Integer.MIN_VALUE), null}); [EOL]              fail(); [EOL]          } catch (final NullPointerException ex) {} [EOL]      } [EOL]  [EOL]
@Test [EOL]      public void testToPrimitive_int() { [EOL]          final Integer[] b = null; [EOL]          assertEquals(null, ArrayUtils.toPrimitive(b)); [EOL]          assertSame(ArrayUtils.EMPTY_INT_ARRAY, ArrayUtils.toPrimitive(new Integer[0])); [EOL]          assertTrue(Arrays.equals( [EOL]              new int[] {Integer.MIN_VALUE, Integer.MAX_VALUE, 9999999}, [EOL]              ArrayUtils.toPrimitive(new Integer[] {Integer.valueOf(Integer.MIN_VALUE),  [EOL]                  Integer.valueOf(Integer.MAX_VALUE), Integer.valueOf(9999999)})) [EOL]          ); [EOL]  [EOL]          try { [EOL]              ArrayUtils.toPrimitive(new Integer[] {Integer.valueOf(Integer.MIN_VALUE), null}); [EOL]              fail(); [EOL]          } catch (final NullPointerException ex) {} [EOL]      } [EOL]  [EOL]
@Test [EOL]      public void testToPrimitive_int() { [EOL]          final Integer[] b = null; [EOL]          assertEquals(null, ArrayUtils.toPrimitive(b)); [EOL]          assertSame(ArrayUtils.EMPTY_INT_ARRAY, ArrayUtils.toPrimitive(new Integer[0])); [EOL]          assertTrue(Arrays.equals( [EOL]              new int[] {Integer.MIN_VALUE, Integer.MAX_VALUE, 9999999}, [EOL]              ArrayUtils.toPrimitive(new Integer[] {Integer.valueOf(Integer.MIN_VALUE),  [EOL]                  Integer.valueOf(Integer.MAX_VALUE), Integer.valueOf(9999999)})) [EOL]          ); [EOL]  [EOL]          try { [EOL]              ArrayUtils.toPrimitive(new Integer[] {Integer.valueOf(Integer.MIN_VALUE), null}); [EOL]              fail(); [EOL]          } catch (final NullPointerException ex) {} [EOL]      } [EOL]  [EOL]
@Test [EOL]      public void testToPrimitive_int_int() { [EOL]          final Integer[] l = null; [EOL]          assertEquals(null, ArrayUtils.toPrimitive(l, Integer.MIN_VALUE)); [EOL]           [EOL]          assertSame(ArrayUtils.EMPTY_INT_ARRAY,  [EOL]           ArrayUtils.toPrimitive(new Integer[0], 1)); [EOL]           [EOL]          assertTrue(Arrays.equals( [EOL]              new int[] {Integer.MIN_VALUE, Integer.MAX_VALUE, 9999999}, [EOL]              ArrayUtils.toPrimitive(new Integer[] {Integer.valueOf(Integer.MIN_VALUE),  [EOL]                  Integer.valueOf(Integer.MAX_VALUE), Integer.valueOf(9999999)},1))); [EOL]           [EOL]          assertTrue(Arrays.equals( [EOL]              new int[] {Integer.MIN_VALUE, Integer.MAX_VALUE, 9999999}, [EOL]              ArrayUtils.toPrimitive(new Integer[] {Integer.valueOf(Integer.MIN_VALUE),  [EOL]                  null, Integer.valueOf(9999999)}, Integer.MAX_VALUE)) [EOL]          ); [EOL]      } [EOL]       [EOL]
@Test [EOL]      public void testToPrimitive_int() { [EOL]          final Integer[] b = null; [EOL]          assertEquals(null, ArrayUtils.toPrimitive(b)); [EOL]          assertSame(ArrayUtils.EMPTY_INT_ARRAY, ArrayUtils.toPrimitive(new Integer[0])); [EOL]          assertTrue(Arrays.equals( [EOL]              new int[] {Integer.MIN_VALUE, Integer.MAX_VALUE, 9999999}, [EOL]              ArrayUtils.toPrimitive(new Integer[] {Integer.valueOf(Integer.MIN_VALUE),  [EOL]                  Integer.valueOf(Integer.MAX_VALUE), Integer.valueOf(9999999)})) [EOL]          ); [EOL]  [EOL]          try { [EOL]              ArrayUtils.toPrimitive(new Integer[] {Integer.valueOf(Integer.MIN_VALUE), null}); [EOL]              fail(); [EOL]          } catch (final NullPointerException ex) {} [EOL]      } [EOL]  [EOL]
@Test [EOL]      public void testToPrimitive_int_int() { [EOL]          final Integer[] l = null; [EOL]          assertEquals(null, ArrayUtils.toPrimitive(l, Integer.MIN_VALUE)); [EOL]           [EOL]          assertSame(ArrayUtils.EMPTY_INT_ARRAY,  [EOL]           ArrayUtils.toPrimitive(new Integer[0], 1)); [EOL]           [EOL]          assertTrue(Arrays.equals( [EOL]              new int[] {Integer.MIN_VALUE, Integer.MAX_VALUE, 9999999}, [EOL]              ArrayUtils.toPrimitive(new Integer[] {Integer.valueOf(Integer.MIN_VALUE),  [EOL]                  Integer.valueOf(Integer.MAX_VALUE), Integer.valueOf(9999999)},1))); [EOL]           [EOL]          assertTrue(Arrays.equals( [EOL]              new int[] {Integer.MIN_VALUE, Integer.MAX_VALUE, 9999999}, [EOL]              ArrayUtils.toPrimitive(new Integer[] {Integer.valueOf(Integer.MIN_VALUE),  [EOL]                  null, Integer.valueOf(9999999)}, Integer.MAX_VALUE)) [EOL]          ); [EOL]      } [EOL]       [EOL]
@Test [EOL]      public void testToPrimitive_int_int() { [EOL]          final Integer[] l = null; [EOL]          assertEquals(null, ArrayUtils.toPrimitive(l, Integer.MIN_VALUE)); [EOL]           [EOL]          assertSame(ArrayUtils.EMPTY_INT_ARRAY,  [EOL]           ArrayUtils.toPrimitive(new Integer[0], 1)); [EOL]           [EOL]          assertTrue(Arrays.equals( [EOL]              new int[] {Integer.MIN_VALUE, Integer.MAX_VALUE, 9999999}, [EOL]              ArrayUtils.toPrimitive(new Integer[] {Integer.valueOf(Integer.MIN_VALUE),  [EOL]                  Integer.valueOf(Integer.MAX_VALUE), Integer.valueOf(9999999)},1))); [EOL]           [EOL]          assertTrue(Arrays.equals( [EOL]              new int[] {Integer.MIN_VALUE, Integer.MAX_VALUE, 9999999}, [EOL]              ArrayUtils.toPrimitive(new Integer[] {Integer.valueOf(Integer.MIN_VALUE),  [EOL]                  null, Integer.valueOf(9999999)}, Integer.MAX_VALUE)) [EOL]          ); [EOL]      } [EOL]       [EOL]
@Test [EOL]     public void testToObject_int() { [EOL]         final int[] b = null; [EOL]         assertArrayEquals(null, ArrayUtils.toObject(b)); [EOL]      [EOL]         assertSame( [EOL]             ArrayUtils.EMPTY_INTEGER_OBJECT_ARRAY, [EOL]             ArrayUtils.toObject(new int[0])); [EOL]      [EOL]         assertTrue( [EOL]             Arrays.equals( [EOL]                 new Integer[] { [EOL]                     Integer.valueOf(Integer.MIN_VALUE), [EOL]                     Integer.valueOf(Integer.MAX_VALUE), [EOL]                     Integer.valueOf(9999999)}, [EOL]             ArrayUtils.toObject( [EOL]                 new int[] { Integer.MIN_VALUE, Integer.MAX_VALUE, 9999999 }))); [EOL]     } [EOL]  [EOL]     //  testToPrimitive/Object for long [EOL]     //  ----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testToObject_int() { [EOL]         final int[] b = null; [EOL]         assertArrayEquals(null, ArrayUtils.toObject(b)); [EOL]      [EOL]         assertSame( [EOL]             ArrayUtils.EMPTY_INTEGER_OBJECT_ARRAY, [EOL]             ArrayUtils.toObject(new int[0])); [EOL]      [EOL]         assertTrue( [EOL]             Arrays.equals( [EOL]                 new Integer[] { [EOL]                     Integer.valueOf(Integer.MIN_VALUE), [EOL]                     Integer.valueOf(Integer.MAX_VALUE), [EOL]                     Integer.valueOf(9999999)}, [EOL]             ArrayUtils.toObject( [EOL]                 new int[] { Integer.MIN_VALUE, Integer.MAX_VALUE, 9999999 }))); [EOL]     } [EOL]  [EOL]     //  testToPrimitive/Object for long [EOL]     //  ----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testToPrimitive_short_short() { [EOL]         final Short[] s = null; [EOL]         assertEquals(null, ArrayUtils.toPrimitive(s, Short.MIN_VALUE)); [EOL]          [EOL]         assertSame(ArrayUtils.EMPTY_SHORT_ARRAY, ArrayUtils.toPrimitive(new Short[0],  [EOL]         Short.MIN_VALUE)); [EOL]          [EOL]         assertTrue(Arrays.equals( [EOL]             new short[] {Short.MIN_VALUE, Short.MAX_VALUE, (short)9999999}, [EOL]             ArrayUtils.toPrimitive(new Short[] {Short.valueOf(Short.MIN_VALUE),  [EOL]                 Short.valueOf(Short.MAX_VALUE), Short.valueOf((short)9999999)}, Short.MIN_VALUE)) [EOL]         ); [EOL]          [EOL]         assertTrue(Arrays.equals( [EOL]             new short[] {Short.MIN_VALUE, Short.MAX_VALUE, (short)9999999}, [EOL]             ArrayUtils.toPrimitive(new Short[] {Short.valueOf(Short.MIN_VALUE), null,  [EOL]                 Short.valueOf((short)9999999)}, Short.MAX_VALUE)) [EOL]         ); [EOL]     } [EOL]
@Test [EOL]     public void testToPrimitive_short_short() { [EOL]         final Short[] s = null; [EOL]         assertEquals(null, ArrayUtils.toPrimitive(s, Short.MIN_VALUE)); [EOL]          [EOL]         assertSame(ArrayUtils.EMPTY_SHORT_ARRAY, ArrayUtils.toPrimitive(new Short[0],  [EOL]         Short.MIN_VALUE)); [EOL]          [EOL]         assertTrue(Arrays.equals( [EOL]             new short[] {Short.MIN_VALUE, Short.MAX_VALUE, (short)9999999}, [EOL]             ArrayUtils.toPrimitive(new Short[] {Short.valueOf(Short.MIN_VALUE),  [EOL]                 Short.valueOf(Short.MAX_VALUE), Short.valueOf((short)9999999)}, Short.MIN_VALUE)) [EOL]         ); [EOL]          [EOL]         assertTrue(Arrays.equals( [EOL]             new short[] {Short.MIN_VALUE, Short.MAX_VALUE, (short)9999999}, [EOL]             ArrayUtils.toPrimitive(new Short[] {Short.valueOf(Short.MIN_VALUE), null,  [EOL]                 Short.valueOf((short)9999999)}, Short.MAX_VALUE)) [EOL]         ); [EOL]     } [EOL]
@Test [EOL]     public void testToPrimitive_byte() { [EOL]         final Byte[] b = null; [EOL]         assertEquals(null, ArrayUtils.toPrimitive(b)); [EOL]          [EOL]         assertSame(ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.toPrimitive(new Byte[0])); [EOL]          [EOL]         assertTrue(Arrays.equals( [EOL]             new byte[] {Byte.MIN_VALUE, Byte.MAX_VALUE, (byte)9999999}, [EOL]             ArrayUtils.toPrimitive(new Byte[] {Byte.valueOf(Byte.MIN_VALUE),  [EOL]                 Byte.valueOf(Byte.MAX_VALUE), Byte.valueOf((byte)9999999)})) [EOL]         ); [EOL]  [EOL]         try { [EOL]             ArrayUtils.toPrimitive(new Byte[] {Byte.valueOf(Byte.MIN_VALUE), null}); [EOL]             fail(); [EOL]         } catch (final NullPointerException ex) {} [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testToPrimitive_byte_byte() { [EOL]         final Byte[] b = null; [EOL]         assertEquals(null, ArrayUtils.toPrimitive(b, Byte.MIN_VALUE)); [EOL]          [EOL]         assertSame(ArrayUtils.EMPTY_BYTE_ARRAY,  [EOL]             ArrayUtils.toPrimitive(new Byte[0], (byte)1)); [EOL]          [EOL]         assertTrue(Arrays.equals( [EOL]             new byte[] {Byte.MIN_VALUE, Byte.MAX_VALUE, (byte)9999999}, [EOL]             ArrayUtils.toPrimitive(new Byte[] {Byte.valueOf(Byte.MIN_VALUE),  [EOL]                 Byte.valueOf(Byte.MAX_VALUE), Byte.valueOf((byte)9999999)},  [EOL]                 Byte.MIN_VALUE)) [EOL]         ); [EOL]          [EOL]         assertTrue(Arrays.equals( [EOL]             new byte[] {Byte.MIN_VALUE, Byte.MAX_VALUE, (byte)9999999}, [EOL]             ArrayUtils.toPrimitive(new Byte[] {Byte.valueOf(Byte.MIN_VALUE), null,  [EOL]                 Byte.valueOf((byte)9999999)}, Byte.MAX_VALUE)) [E
@Test [EOL]     public void testToObject_byte() { [EOL]         final byte[] b = null; [EOL]         assertArrayEquals(null, ArrayUtils.toObject(b)); [EOL]          [EOL]         assertSame(ArrayUtils.EMPTY_BYTE_OBJECT_ARRAY,  [EOL]             ArrayUtils.toObject(new byte[0])); [EOL]          [EOL]         assertTrue(Arrays.equals( [EOL]             new Byte[] {Byte.valueOf(Byte.MIN_VALUE),  [EOL]                 Byte.valueOf(Byte.MAX_VALUE), Byte.valueOf((byte)9999999)}, [EOL]                 ArrayUtils.toObject(new byte[] {Byte.MIN_VALUE, Byte.MAX_VALUE,  [EOL]                 (byte)9999999})) [EOL]         ); [EOL]     } [EOL]  [EOL]     // testToPrimitive/Object for short [EOL]     //  ----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testToObject_byte() { [EOL]         final byte[] b = null; [EOL]         assertArrayEquals(null, ArrayUtils.toObject(b)); [EOL]          [EOL]         assertSame(ArrayUtils.EMPTY_BYTE_OBJECT_ARRAY,  [EOL]             ArrayUtils.toObject(new byte[0])); [EOL]          [EOL]         assertTrue(Arrays.equals( [EOL]             new Byte[] {Byte.valueOf(Byte.MIN_VALUE),  [EOL]                 Byte.valueOf(Byte.MAX_VALUE), Byte.valueOf((byte)9999999)}, [EOL]                 ArrayUtils.toObject(new byte[] {Byte.MIN_VALUE, Byte.MAX_VALUE,  [EOL]                 (byte)9999999})) [EOL]         ); [EOL]     } [EOL]  [EOL]     // testToPrimitive/Object for short [EOL]     //  ----------------------------------------------------------------------- [EOL]
@Test [EOL]      public void testToPrimitive_double() { [EOL]          final Double[] b = null; [EOL]          assertEquals(null, ArrayUtils.toPrimitive(b)); [EOL]           [EOL]          assertSame(ArrayUtils.EMPTY_DOUBLE_ARRAY,  [EOL]             ArrayUtils.toPrimitive(new Double[0])); [EOL]           [EOL]          assertTrue(Arrays.equals( [EOL]              new double[] {Double.MIN_VALUE, Double.MAX_VALUE, 9999999}, [EOL]              ArrayUtils.toPrimitive(new Double[] {Double.valueOf(Double.MIN_VALUE),  [EOL]                  Double.valueOf(Double.MAX_VALUE), Double.valueOf(9999999)})) [EOL]          ); [EOL]  [EOL]          try { [EOL]              ArrayUtils.toPrimitive(new Float[] {Float.valueOf(Float.MIN_VALUE), null}); [EOL]              fail(); [EOL]          } catch (final NullPointerException ex) {} [EOL]      } [EOL]  [EOL]
@Test [EOL]      public void testToPrimitive_double_double() { [EOL]          final Double[] l = null; [EOL]          assertEquals(null, ArrayUtils.toPrimitive(l, Double.MIN_VALUE)); [EOL]           [EOL]          assertSame(ArrayUtils.EMPTY_DOUBLE_ARRAY,  [EOL]          ArrayUtils.toPrimitive(new Double[0], 1)); [EOL]           [EOL]          assertTrue(Arrays.equals( [EOL]              new double[] {Double.MIN_VALUE, Double.MAX_VALUE, 9999999}, [EOL]              ArrayUtils.toPrimitive(new Double[] {Double.valueOf(Double.MIN_VALUE),  [EOL]                  Double.valueOf(Double.MAX_VALUE), Double.valueOf(9999999)},1))); [EOL]           [EOL]          assertTrue(Arrays.equals( [EOL]              new double[] {Double.MIN_VALUE, Double.MAX_VALUE, 9999999}, [EOL]              ArrayUtils.toPrimitive(new Double[] {Double.valueOf(Double.MIN_VALUE),  [EOL]                  null, Double.valueOf(9999999)}, Double.MAX_VALUE)) [EOL]          ); [EOL]      } [EOL]       [EOL
@Test [EOL]     public void testToObject_double() { [EOL]         final double[] b = null; [EOL]         assertArrayEquals(null, ArrayUtils.toObject(b)); [EOL]      [EOL]         assertSame( [EOL]             ArrayUtils.EMPTY_DOUBLE_OBJECT_ARRAY, [EOL]             ArrayUtils.toObject(new double[0])); [EOL]      [EOL]         assertTrue( [EOL]             Arrays.equals( [EOL]                 new Double[] { [EOL]                     Double.valueOf(Double.MIN_VALUE), [EOL]                     Double.valueOf(Double.MAX_VALUE), [EOL]                     Double.valueOf(9999999)}, [EOL]             ArrayUtils.toObject( [EOL]                 new double[] { Double.MIN_VALUE, Double.MAX_VALUE, 9999999 }))); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]     /** [EOL]      * Test for {@link ArrayUtils#isEmpty(java.lang.Object[])}. [EOL]      */ [EOL]
@Test [EOL]     public void testToObject_double() { [EOL]         final double[] b = null; [EOL]         assertArrayEquals(null, ArrayUtils.toObject(b)); [EOL]      [EOL]         assertSame( [EOL]             ArrayUtils.EMPTY_DOUBLE_OBJECT_ARRAY, [EOL]             ArrayUtils.toObject(new double[0])); [EOL]      [EOL]         assertTrue( [EOL]             Arrays.equals( [EOL]                 new Double[] { [EOL]                     Double.valueOf(Double.MIN_VALUE), [EOL]                     Double.valueOf(Double.MAX_VALUE), [EOL]                     Double.valueOf(9999999)}, [EOL]             ArrayUtils.toObject( [EOL]                 new double[] { Double.MIN_VALUE, Double.MAX_VALUE, 9999999 }))); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]     /** [EOL]      * Test for {@link ArrayUtils#isEmpty(java.lang.Object[])}. [EOL]      */ [EOL]
@Test [EOL]      public void testToPrimitive_float() { [EOL]          final Float[] b = null; [EOL]          assertEquals(null, ArrayUtils.toPrimitive(b)); [EOL]           [EOL]          assertSame(ArrayUtils.EMPTY_FLOAT_ARRAY,  [EOL]             ArrayUtils.toPrimitive(new Float[0])); [EOL]           [EOL]          assertTrue(Arrays.equals( [EOL]              new float[] {Float.MIN_VALUE, Float.MAX_VALUE, 9999999}, [EOL]              ArrayUtils.toPrimitive(new Float[] {Float.valueOf(Float.MIN_VALUE),  [EOL]                  Float.valueOf(Float.MAX_VALUE), Float.valueOf(9999999)})) [EOL]          ); [EOL]  [EOL]          try { [EOL]              ArrayUtils.toPrimitive(new Float[] {Float.valueOf(Float.MIN_VALUE), null}); [EOL]              fail(); [EOL]          } catch (final NullPointerException ex) {} [EOL]      } [EOL]  [EOL]
@Test [EOL]      public void testToPrimitive_float() { [EOL]          final Float[] b = null; [EOL]          assertEquals(null, ArrayUtils.toPrimitive(b)); [EOL]           [EOL]          assertSame(ArrayUtils.EMPTY_FLOAT_ARRAY,  [EOL]             ArrayUtils.toPrimitive(new Float[0])); [EOL]           [EOL]          assertTrue(Arrays.equals( [EOL]              new float[] {Float.MIN_VALUE, Float.MAX_VALUE, 9999999}, [EOL]              ArrayUtils.toPrimitive(new Float[] {Float.valueOf(Float.MIN_VALUE),  [EOL]                  Float.valueOf(Float.MAX_VALUE), Float.valueOf(9999999)})) [EOL]          ); [EOL]  [EOL]          try { [EOL]              ArrayUtils.toPrimitive(new Float[] {Float.valueOf(Float.MIN_VALUE), null}); [EOL]              fail(); [EOL]          } catch (final NullPointerException ex) {} [EOL]      } [EOL]  [EOL]
@Test [EOL]      public void testToPrimitive_float() { [EOL]          final Float[] b = null; [EOL]          assertEquals(null, ArrayUtils.toPrimitive(b)); [EOL]           [EOL]          assertSame(ArrayUtils.EMPTY_FLOAT_ARRAY,  [EOL]             ArrayUtils.toPrimitive(new Float[0])); [EOL]           [EOL]          assertTrue(Arrays.equals( [EOL]              new float[] {Float.MIN_VALUE, Float.MAX_VALUE, 9999999}, [EOL]              ArrayUtils.toPrimitive(new Float[] {Float.valueOf(Float.MIN_VALUE),  [EOL]                  Float.valueOf(Float.MAX_VALUE), Float.valueOf(9999999)})) [EOL]          ); [EOL]  [EOL]          try { [EOL]              ArrayUtils.toPrimitive(new Float[] {Float.valueOf(Float.MIN_VALUE), null}); [EOL]              fail(); [EOL]          } catch (final NullPointerException ex) {} [EOL]      } [EOL]  [EOL]
@Test [EOL]      public void testToPrimitive_float() { [EOL]          final Float[] b = null; [EOL]          assertEquals(null, ArrayUtils.toPrimitive(b)); [EOL]           [EOL]          assertSame(ArrayUtils.EMPTY_FLOAT_ARRAY,  [EOL]             ArrayUtils.toPrimitive(new Float[0])); [EOL]           [EOL]          assertTrue(Arrays.equals( [EOL]              new float[] {Float.MIN_VALUE, Float.MAX_VALUE, 9999999}, [EOL]              ArrayUtils.toPrimitive(new Float[] {Float.valueOf(Float.MIN_VALUE),  [EOL]                  Float.valueOf(Float.MAX_VALUE), Float.valueOf(9999999)})) [EOL]          ); [EOL]  [EOL]          try { [EOL]              ArrayUtils.toPrimitive(new Float[] {Float.valueOf(Float.MIN_VALUE), null}); [EOL]              fail(); [EOL]          } catch (final NullPointerException ex) {} [EOL]      } [EOL]  [EOL]
@Test [EOL]      public void testToPrimitive_float() { [EOL]          final Float[] b = null; [EOL]          assertEquals(null, ArrayUtils.toPrimitive(b)); [EOL]           [EOL]          assertSame(ArrayUtils.EMPTY_FLOAT_ARRAY,  [EOL]             ArrayUtils.toPrimitive(new Float[0])); [EOL]           [EOL]          assertTrue(Arrays.equals( [EOL]              new float[] {Float.MIN_VALUE, Float.MAX_VALUE, 9999999}, [EOL]              ArrayUtils.toPrimitive(new Float[] {Float.valueOf(Float.MIN_VALUE),  [EOL]                  Float.valueOf(Float.MAX_VALUE), Float.valueOf(9999999)})) [EOL]          ); [EOL]  [EOL]          try { [EOL]              ArrayUtils.toPrimitive(new Float[] {Float.valueOf(Float.MIN_VALUE), null}); [EOL]              fail(); [EOL]          } catch (final NullPointerException ex) {} [EOL]      } [EOL]  [EOL]
@Test [EOL]      public void testToPrimitive_float_float() { [EOL]          final Float[] l = null; [EOL]          assertEquals(null, ArrayUtils.toPrimitive(l, Float.MIN_VALUE)); [EOL]           [EOL]          assertSame(ArrayUtils.EMPTY_FLOAT_ARRAY,  [EOL]          ArrayUtils.toPrimitive(new Float[0], 1)); [EOL]           [EOL]          assertTrue(Arrays.equals( [EOL]              new float[] {Float.MIN_VALUE, Float.MAX_VALUE, 9999999}, [EOL]              ArrayUtils.toPrimitive(new Float[] {Float.valueOf(Float.MIN_VALUE),  [EOL]                  Float.valueOf(Float.MAX_VALUE), Float.valueOf(9999999)},1))); [EOL]           [EOL]          assertTrue(Arrays.equals( [EOL]              new float[] {Float.MIN_VALUE, Float.MAX_VALUE, 9999999}, [EOL]              ArrayUtils.toPrimitive(new Float[] {Float.valueOf(Float.MIN_VALUE),  [EOL]                  null, Float.valueOf(9999999)}, Float.MAX_VALUE)) [EOL]          ); [EOL]      } [EOL]       [EOL
@Test [EOL]      public void testToPrimitive_float_float() { [EOL]          final Float[] l = null; [EOL]          assertEquals(null, ArrayUtils.toPrimitive(l, Float.MIN_VALUE)); [EOL]           [EOL]          assertSame(ArrayUtils.EMPTY_FLOAT_ARRAY,  [EOL]          ArrayUtils.toPrimitive(new Float[0], 1)); [EOL]           [EOL]          assertTrue(Arrays.equals( [EOL]              new float[] {Float.MIN_VALUE, Float.MAX_VALUE, 9999999}, [EOL]              ArrayUtils.toPrimitive(new Float[] {Float.valueOf(Float.MIN_VALUE),  [EOL]                  Float.valueOf(Float.MAX_VALUE), Float.valueOf(9999999)},1))); [EOL]           [EOL]          assertTrue(Arrays.equals( [EOL]              new float[] {Float.MIN_VALUE, Float.MAX_VALUE, 9999999}, [EOL]              ArrayUtils.toPrimitive(new Float[] {Float.valueOf(Float.MIN_VALUE),  [EOL]                  null, Float.valueOf(9999999)}, Float.MAX_VALUE)) [EOL]          ); [EOL]      } [EOL]       [EOL
@Test [EOL]     public void testToObject_float() { [EOL]         final float[] b = null; [EOL]         assertArrayEquals(null, ArrayUtils.toObject(b)); [EOL]      [EOL]         assertSame( [EOL]             ArrayUtils.EMPTY_FLOAT_OBJECT_ARRAY, [EOL]             ArrayUtils.toObject(new float[0])); [EOL]      [EOL]         assertTrue( [EOL]             Arrays.equals( [EOL]                 new Float[] { [EOL]                     Float.valueOf(Float.MIN_VALUE), [EOL]                     Float.valueOf(Float.MAX_VALUE), [EOL]                     Float.valueOf(9999999)}, [EOL]             ArrayUtils.toObject( [EOL]                 new float[] { Float.MIN_VALUE, Float.MAX_VALUE, 9999999 }))); [EOL]     } [EOL]  [EOL]     //  testToPrimitive/Object for double [EOL]     //  ----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testToObject_float() { [EOL]         final float[] b = null; [EOL]         assertArrayEquals(null, ArrayUtils.toObject(b)); [EOL]      [EOL]         assertSame( [EOL]             ArrayUtils.EMPTY_FLOAT_OBJECT_ARRAY, [EOL]             ArrayUtils.toObject(new float[0])); [EOL]      [EOL]         assertTrue( [EOL]             Arrays.equals( [EOL]                 new Float[] { [EOL]                     Float.valueOf(Float.MIN_VALUE), [EOL]                     Float.valueOf(Float.MAX_VALUE), [EOL]                     Float.valueOf(9999999)}, [EOL]             ArrayUtils.toObject( [EOL]                 new float[] { Float.MIN_VALUE, Float.MAX_VALUE, 9999999 }))); [EOL]     } [EOL]  [EOL]     //  testToPrimitive/Object for double [EOL]     //  ----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testToPrimitive_boolean() { [EOL]         final Boolean[] b = null; [EOL]         assertEquals(null, ArrayUtils.toPrimitive(b)); [EOL]         assertSame(ArrayUtils.EMPTY_BOOLEAN_ARRAY, ArrayUtils.toPrimitive(new Boolean[0])); [EOL]         assertTrue(Arrays.equals( [EOL]             new boolean[] {true, false, true}, [EOL]             ArrayUtils.toPrimitive(new Boolean[] {Boolean.TRUE, Boolean.FALSE, Boolean.TRUE})) [EOL]         ); [EOL]  [EOL]         try { [EOL]             ArrayUtils.toPrimitive(new Boolean[] {Boolean.TRUE, null}); [EOL]             fail(); [EOL]         } catch (final NullPointerException ex) {} [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testToPrimitive_boolean_boolean() { [EOL]         assertEquals(null, ArrayUtils.toPrimitive(null, false)); [EOL]         assertSame(ArrayUtils.EMPTY_BOOLEAN_ARRAY, ArrayUtils.toPrimitive(new Boolean[0], false)); [EOL]         assertTrue(Arrays.equals( [EOL]             new boolean[] {true, false, true}, [EOL]             ArrayUtils.toPrimitive(new Boolean[] {Boolean.TRUE, Boolean.FALSE, Boolean.TRUE}, false)) [EOL]         ); [EOL]         assertTrue(Arrays.equals( [EOL]             new boolean[] {true, false, false}, [EOL]             ArrayUtils.toPrimitive(new Boolean[] {Boolean.TRUE, null, Boolean.FALSE}, false)) [EOL]         ); [EOL]         assertTrue(Arrays.equals( [EOL]             new boolean[] {true, true, false}, [EOL]             ArrayUtils.toPrimitive(new Boolean[] {Boolean.TRUE, null, Boolean.FALSE}, true)) [EOL]         ); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testToPrimitive_boolean_boolean() { [EOL]         assertEquals(null, ArrayUtils.toPrimitive(null, false)); [EOL]         assertSame(ArrayUtils.EMPTY_BOOLEAN_ARRAY, ArrayUtils.toPrimitive(new Boolean[0], false)); [EOL]         assertTrue(Arrays.equals( [EOL]             new boolean[] {true, false, true}, [EOL]             ArrayUtils.toPrimitive(new Boolean[] {Boolean.TRUE, Boolean.FALSE, Boolean.TRUE}, false)) [EOL]         ); [EOL]         assertTrue(Arrays.equals( [EOL]             new boolean[] {true, false, false}, [EOL]             ArrayUtils.toPrimitive(new Boolean[] {Boolean.TRUE, null, Boolean.FALSE}, false)) [EOL]         ); [EOL]         assertTrue(Arrays.equals( [EOL]             new boolean[] {true, true, false}, [EOL]             ArrayUtils.toPrimitive(new Boolean[] {Boolean.TRUE, null, Boolean.FALSE}, true)) [EOL]         ); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testToObject_boolean() { [EOL]         final boolean[] b = null; [EOL]         assertArrayEquals(null, ArrayUtils.toObject(b)); [EOL]         assertSame(ArrayUtils.EMPTY_BOOLEAN_OBJECT_ARRAY, ArrayUtils.toObject(new boolean[0])); [EOL]         assertTrue(Arrays.equals( [EOL]             new Boolean[] {Boolean.TRUE, Boolean.FALSE, Boolean.TRUE}, [EOL]             ArrayUtils.toObject(new boolean[] {true, false, true})) [EOL]         ); [EOL]     } [EOL]  [EOL]     // testToPrimitive/Object for byte [EOL]     //  ----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testJira567(){ [EOL]         Number[] n; [EOL]         // Valid array construction [EOL]         n = ArrayUtils.addAll(new Number[]{Integer.valueOf(1)}, new Long[]{Long.valueOf(2)}); [EOL]         assertEquals(2,n.length); [EOL]         assertEquals(Number.class,n.getClass().getComponentType()); [EOL]         try { [EOL]             // Invalid - can't store Long in Integer array [EOL]                n = ArrayUtils.addAll(new Integer[]{Integer.valueOf(1)}, new Long[]{Long.valueOf(2)}); [EOL]                fail("Should have generated IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException expected) { [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testJira567(){ [EOL]         Number[] n; [EOL]         // Valid array construction [EOL]         n = ArrayUtils.addAll(new Number[]{Integer.valueOf(1)}, new Long[]{Long.valueOf(2)}); [EOL]         assertEquals(2,n.length); [EOL]         assertEquals(Number.class,n.getClass().getComponentType()); [EOL]         try { [EOL]             // Invalid - can't store Long in Integer array [EOL]                n = ArrayUtils.addAll(new Integer[]{Integer.valueOf(1)}, new Long[]{Long.valueOf(2)}); [EOL]                fail("Should have generated IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException expected) { [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testJira567(){ [EOL]         Number[] n; [EOL]         // Valid array construction [EOL]         n = ArrayUtils.addAll(new Number[]{Integer.valueOf(1)}, new Long[]{Long.valueOf(2)}); [EOL]         assertEquals(2,n.length); [EOL]         assertEquals(Number.class,n.getClass().getComponentType()); [EOL]         try { [EOL]             // Invalid - can't store Long in Integer array [EOL]                n = ArrayUtils.addAll(new Integer[]{Integer.valueOf(1)}, new Long[]{Long.valueOf(2)}); [EOL]                fail("Should have generated IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException expected) { [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testJira567(){ [EOL]         Number[] n; [EOL]         // Valid array construction [EOL]         n = ArrayUtils.addAll(new Number[]{Integer.valueOf(1)}, new Long[]{Long.valueOf(2)}); [EOL]         assertEquals(2,n.length); [EOL]         assertEquals(Number.class,n.getClass().getComponentType()); [EOL]         try { [EOL]             // Invalid - can't store Long in Integer array [EOL]                n = ArrayUtils.addAll(new Integer[]{Integer.valueOf(1)}, new Long[]{Long.valueOf(2)}); [EOL]                fail("Should have generated IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException expected) { [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testAddObjectArrayToObjectArray() { [EOL]         assertNull(ArrayUtils.addAll((Object[]) null, (Object[]) null)); [EOL]         Object[] newArray; [EOL]         final String[] stringArray1 = new String[]{"a", "b", "c"}; [EOL]         final String[] stringArray2 = new String[]{"1", "2", "3"}; [EOL]         newArray = ArrayUtils.addAll(stringArray1, (String[]) null); [EOL]         assertNotSame(stringArray1, newArray); [EOL]         assertTrue(Arrays.equals(stringArray1, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{"a", "b", "c"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(null, stringArray2); [EOL]         assertNotSame(stringArray2, newArray); [EOL]         assertTrue(Arrays.equals(stringArray2, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{"1", "2", "3"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(stringArray1, stringArray2); [EOL]         assertTrue(Arrays.equals(new String[]{"a", "b", "c", "1", "2",
@Test [EOL]     public void testAddObjectArrayToObjectArray() { [EOL]         assertNull(ArrayUtils.addAll((Object[]) null, (Object[]) null)); [EOL]         Object[] newArray; [EOL]         final String[] stringArray1 = new String[]{"a", "b", "c"}; [EOL]         final String[] stringArray2 = new String[]{"1", "2", "3"}; [EOL]         newArray = ArrayUtils.addAll(stringArray1, (String[]) null); [EOL]         assertNotSame(stringArray1, newArray); [EOL]         assertTrue(Arrays.equals(stringArray1, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{"a", "b", "c"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(null, stringArray2); [EOL]         assertNotSame(stringArray2, newArray); [EOL]         assertTrue(Arrays.equals(stringArray2, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{"1", "2", "3"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(stringArray1, stringArray2); [EOL]         assertTrue(Arrays.equals(new String[]{"a", "b", "c", "1", "2",
@Test [EOL]     public void testAddObjectArrayToObjectArray() { [EOL]         assertNull(ArrayUtils.addAll((Object[]) null, (Object[]) null)); [EOL]         Object[] newArray; [EOL]         final String[] stringArray1 = new String[]{"a", "b", "c"}; [EOL]         final String[] stringArray2 = new String[]{"1", "2", "3"}; [EOL]         newArray = ArrayUtils.addAll(stringArray1, (String[]) null); [EOL]         assertNotSame(stringArray1, newArray); [EOL]         assertTrue(Arrays.equals(stringArray1, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{"a", "b", "c"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(null, stringArray2); [EOL]         assertNotSame(stringArray2, newArray); [EOL]         assertTrue(Arrays.equals(stringArray2, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{"1", "2", "3"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(stringArray1, stringArray2); [EOL]         assertTrue(Arrays.equals(new String[]{"a", "b", "c", "1", "2",
@Test [EOL]     public void testAddObjectArrayToObjectArray() { [EOL]         assertNull(ArrayUtils.addAll((Object[]) null, (Object[]) null)); [EOL]         Object[] newArray; [EOL]         final String[] stringArray1 = new String[]{"a", "b", "c"}; [EOL]         final String[] stringArray2 = new String[]{"1", "2", "3"}; [EOL]         newArray = ArrayUtils.addAll(stringArray1, (String[]) null); [EOL]         assertNotSame(stringArray1, newArray); [EOL]         assertTrue(Arrays.equals(stringArray1, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{"a", "b", "c"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(null, stringArray2); [EOL]         assertNotSame(stringArray2, newArray); [EOL]         assertTrue(Arrays.equals(stringArray2, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{"1", "2", "3"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(stringArray1, stringArray2); [EOL]         assertTrue(Arrays.equals(new String[]{"a", "b", "c", "1", "2",
@Test [EOL]     public void testAddObjectArrayToObjectArray() { [EOL]         assertNull(ArrayUtils.addAll((Object[]) null, (Object[]) null)); [EOL]         Object[] newArray; [EOL]         final String[] stringArray1 = new String[]{"a", "b", "c"}; [EOL]         final String[] stringArray2 = new String[]{"1", "2", "3"}; [EOL]         newArray = ArrayUtils.addAll(stringArray1, (String[]) null); [EOL]         assertNotSame(stringArray1, newArray); [EOL]         assertTrue(Arrays.equals(stringArray1, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{"a", "b", "c"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(null, stringArray2); [EOL]         assertNotSame(stringArray2, newArray); [EOL]         assertTrue(Arrays.equals(stringArray2, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{"1", "2", "3"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(stringArray1, stringArray2); [EOL]         assertTrue(Arrays.equals(new String[]{"a", "b", "c", "1", "2",
@Test [EOL]     public void testAddObjectArrayToObjectArray() { [EOL]         assertNull(ArrayUtils.addAll((Object[]) null, (Object[]) null)); [EOL]         Object[] newArray; [EOL]         final String[] stringArray1 = new String[]{"a", "b", "c"}; [EOL]         final String[] stringArray2 = new String[]{"1", "2", "3"}; [EOL]         newArray = ArrayUtils.addAll(stringArray1, (String[]) null); [EOL]         assertNotSame(stringArray1, newArray); [EOL]         assertTrue(Arrays.equals(stringArray1, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{"a", "b", "c"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(null, stringArray2); [EOL]         assertNotSame(stringArray2, newArray); [EOL]         assertTrue(Arrays.equals(stringArray2, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{"1", "2", "3"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(stringArray1, stringArray2); [EOL]         assertTrue(Arrays.equals(new String[]{"a", "b", "c", "1", "2",
@Test [EOL]     public void testAddObjectArrayToObjectArray() { [EOL]         assertNull(ArrayUtils.addAll((Object[]) null, (Object[]) null)); [EOL]         Object[] newArray; [EOL]         final String[] stringArray1 = new String[]{"a", "b", "c"}; [EOL]         final String[] stringArray2 = new String[]{"1", "2", "3"}; [EOL]         newArray = ArrayUtils.addAll(stringArray1, (String[]) null); [EOL]         assertNotSame(stringArray1, newArray); [EOL]         assertTrue(Arrays.equals(stringArray1, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{"a", "b", "c"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(null, stringArray2); [EOL]         assertNotSame(stringArray2, newArray); [EOL]         assertTrue(Arrays.equals(stringArray2, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{"1", "2", "3"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(stringArray1, stringArray2); [EOL]         assertTrue(Arrays.equals(new String[]{"a", "b", "c", "1", "2",
@Test [EOL]     public void testAddObjectArrayToObjectArray() { [EOL]         assertNull(ArrayUtils.addAll((Object[]) null, (Object[]) null)); [EOL]         Object[] newArray; [EOL]         final String[] stringArray1 = new String[]{"a", "b", "c"}; [EOL]         final String[] stringArray2 = new String[]{"1", "2", "3"}; [EOL]         newArray = ArrayUtils.addAll(stringArray1, (String[]) null); [EOL]         assertNotSame(stringArray1, newArray); [EOL]         assertTrue(Arrays.equals(stringArray1, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{"a", "b", "c"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(null, stringArray2); [EOL]         assertNotSame(stringArray2, newArray); [EOL]         assertTrue(Arrays.equals(stringArray2, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{"1", "2", "3"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(stringArray1, stringArray2); [EOL]         assertTrue(Arrays.equals(new String[]{"a", "b", "c", "1", "2",
@Test [EOL]     public void testAddObjectArrayToObjectArray() { [EOL]         assertNull(ArrayUtils.addAll((Object[]) null, (Object[]) null)); [EOL]         Object[] newArray; [EOL]         final String[] stringArray1 = new String[]{"a", "b", "c"}; [EOL]         final String[] stringArray2 = new String[]{"1", "2", "3"}; [EOL]         newArray = ArrayUtils.addAll(stringArray1, (String[]) null); [EOL]         assertNotSame(stringArray1, newArray); [EOL]         assertTrue(Arrays.equals(stringArray1, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{"a", "b", "c"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(null, stringArray2); [EOL]         assertNotSame(stringArray2, newArray); [EOL]         assertTrue(Arrays.equals(stringArray2, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{"1", "2", "3"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(stringArray1, stringArray2); [EOL]         assertTrue(Arrays.equals(new String[]{"a", "b", "c", "1", "2",
@Test [EOL]     public void testAddObjectArrayToObjectArray() { [EOL]         assertNull(ArrayUtils.addAll((Object[]) null, (Object[]) null)); [EOL]         Object[] newArray; [EOL]         final String[] stringArray1 = new String[]{"a", "b", "c"}; [EOL]         final String[] stringArray2 = new String[]{"1", "2", "3"}; [EOL]         newArray = ArrayUtils.addAll(stringArray1, (String[]) null); [EOL]         assertNotSame(stringArray1, newArray); [EOL]         assertTrue(Arrays.equals(stringArray1, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{"a", "b", "c"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(null, stringArray2); [EOL]         assertNotSame(stringArray2, newArray); [EOL]         assertTrue(Arrays.equals(stringArray2, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{"1", "2", "3"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(stringArray1, stringArray2); [EOL]         assertTrue(Arrays.equals(new String[]{"a", "b", "c", "1", "2",
@Test [EOL]     public void testAddObjectArrayToObjectArray() { [EOL]         assertNull(ArrayUtils.addAll((Object[]) null, (Object[]) null)); [EOL]         Object[] newArray; [EOL]         final String[] stringArray1 = new String[]{"a", "b", "c"}; [EOL]         final String[] stringArray2 = new String[]{"1", "2", "3"}; [EOL]         newArray = ArrayUtils.addAll(stringArray1, (String[]) null); [EOL]         assertNotSame(stringArray1, newArray); [EOL]         assertTrue(Arrays.equals(stringArray1, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{"a", "b", "c"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(null, stringArray2); [EOL]         assertNotSame(stringArray2, newArray); [EOL]         assertTrue(Arrays.equals(stringArray2, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{"1", "2", "3"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(stringArray1, stringArray2); [EOL]         assertTrue(Arrays.equals(new String[]{"a", "b", "c", "1", "2",
@Test [EOL]     public void testAddObjectArrayToObjectArray() { [EOL]         assertNull(ArrayUtils.addAll((Object[]) null, (Object[]) null)); [EOL]         Object[] newArray; [EOL]         final String[] stringArray1 = new String[]{"a", "b", "c"}; [EOL]         final String[] stringArray2 = new String[]{"1", "2", "3"}; [EOL]         newArray = ArrayUtils.addAll(stringArray1, (String[]) null); [EOL]         assertNotSame(stringArray1, newArray); [EOL]         assertTrue(Arrays.equals(stringArray1, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{"a", "b", "c"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(null, stringArray2); [EOL]         assertNotSame(stringArray2, newArray); [EOL]         assertTrue(Arrays.equals(stringArray2, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{"1", "2", "3"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(stringArray1, stringArray2); [EOL]         assertTrue(Arrays.equals(new String[]{"a", "b", "c", "1", "2",
@Test [EOL]     public void testAddObjectArrayToObjectArray() { [EOL]         assertNull(ArrayUtils.addAll((Object[]) null, (Object[]) null)); [EOL]         Object[] newArray; [EOL]         final String[] stringArray1 = new String[]{"a", "b", "c"}; [EOL]         final String[] stringArray2 = new String[]{"1", "2", "3"}; [EOL]         newArray = ArrayUtils.addAll(stringArray1, (String[]) null); [EOL]         assertNotSame(stringArray1, newArray); [EOL]         assertTrue(Arrays.equals(stringArray1, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{"a", "b", "c"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(null, stringArray2); [EOL]         assertNotSame(stringArray2, newArray); [EOL]         assertTrue(Arrays.equals(stringArray2, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{"1", "2", "3"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(stringArray1, stringArray2); [EOL]         assertTrue(Arrays.equals(new String[]{"a", "b", "c", "1", "2",
@Test [EOL]     public void testAddObjectArrayToObjectArray() { [EOL]         assertNull(ArrayUtils.addAll((Object[]) null, (Object[]) null)); [EOL]         Object[] newArray; [EOL]         final String[] stringArray1 = new String[]{"a", "b", "c"}; [EOL]         final String[] stringArray2 = new String[]{"1", "2", "3"}; [EOL]         newArray = ArrayUtils.addAll(stringArray1, (String[]) null); [EOL]         assertNotSame(stringArray1, newArray); [EOL]         assertTrue(Arrays.equals(stringArray1, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{"a", "b", "c"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(null, stringArray2); [EOL]         assertNotSame(stringArray2, newArray); [EOL]         assertTrue(Arrays.equals(stringArray2, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{"1", "2", "3"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(stringArray1, stringArray2); [EOL]         assertTrue(Arrays.equals(new String[]{"a", "b", "c", "1", "2",
@Test [EOL]     public void testLANG571(){ [EOL]         final String[] stringArray=null; [EOL]         final String aString=null; [EOL]         try { [EOL]             @SuppressWarnings("unused") [EOL]             final [EOL]             String[] sa = ArrayUtils.add(stringArray, aString); [EOL]             fail("Should have caused IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException iae){ [EOL]             //expected [EOL]         } [EOL]         try { [EOL]             @SuppressWarnings("unused") [EOL]             final [EOL]             String[] sa = ArrayUtils.add(stringArray, 0, aString); [EOL]             fail("Should have caused IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException iae){ [EOL]             //expected [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLANG571(){ [EOL]         final String[] stringArray=null; [EOL]         final String aString=null; [EOL]         try { [EOL]             @SuppressWarnings("unused") [EOL]             final [EOL]             String[] sa = ArrayUtils.add(stringArray, aString); [EOL]             fail("Should have caused IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException iae){ [EOL]             //expected [EOL]         } [EOL]         try { [EOL]             @SuppressWarnings("unused") [EOL]             final [EOL]             String[] sa = ArrayUtils.add(stringArray, 0, aString); [EOL]             fail("Should have caused IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException iae){ [EOL]             //expected [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLANG571(){ [EOL]         final String[] stringArray=null; [EOL]         final String aString=null; [EOL]         try { [EOL]             @SuppressWarnings("unused") [EOL]             final [EOL]             String[] sa = ArrayUtils.add(stringArray, aString); [EOL]             fail("Should have caused IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException iae){ [EOL]             //expected [EOL]         } [EOL]         try { [EOL]             @SuppressWarnings("unused") [EOL]             final [EOL]             String[] sa = ArrayUtils.add(stringArray, 0, aString); [EOL]             fail("Should have caused IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException iae){ [EOL]             //expected [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLANG571(){ [EOL]         final String[] stringArray=null; [EOL]         final String aString=null; [EOL]         try { [EOL]             @SuppressWarnings("unused") [EOL]             final [EOL]             String[] sa = ArrayUtils.add(stringArray, aString); [EOL]             fail("Should have caused IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException iae){ [EOL]             //expected [EOL]         } [EOL]         try { [EOL]             @SuppressWarnings("unused") [EOL]             final [EOL]             String[] sa = ArrayUtils.add(stringArray, 0, aString); [EOL]             fail("Should have caused IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException iae){ [EOL]             //expected [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLANG571(){ [EOL]         final String[] stringArray=null; [EOL]         final String aString=null; [EOL]         try { [EOL]             @SuppressWarnings("unused") [EOL]             final [EOL]             String[] sa = ArrayUtils.add(stringArray, aString); [EOL]             fail("Should have caused IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException iae){ [EOL]             //expected [EOL]         } [EOL]         try { [EOL]             @SuppressWarnings("unused") [EOL]             final [EOL]             String[] sa = ArrayUtils.add(stringArray, 0, aString); [EOL]             fail("Should have caused IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException iae){ [EOL]             //expected [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testRemoveElementObjectArray() { [EOL]         Object[] array; [EOL]         array = ArrayUtils.removeElement((Object[]) null, "a"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElement(ArrayUtils.EMPTY_OBJECT_ARRAY, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElement(new Object[] {"a"}, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElement(new Object[] {"a", "b"}, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] {"b"}, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElement(new Object[] {"a", "b", "a"}, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] {"b", "a"}, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testRemoveElementIntArray() { [EOL]         int[] array; [EOL]         array = ArrayUtils.removeElement((int[]) null, 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElement(ArrayUtils.EMPTY_INT_ARRAY, 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_INT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElement(new int[] {1}, 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_INT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElement(new int[] {1, 2}, 1); [EOL]         assertTrue(Arrays.equals(new int[] {2}, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElement(new int[] {1, 2, 1}, 1); [EOL]         assertTrue(Arrays.equals(new int[] {2, 1}, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testRemoveElementByteArray() { [EOL]         byte[] array; [EOL]         array = ArrayUtils.removeElements((byte[]) null, (byte) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2, 1 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUt
@Test [EOL]     public void testRemoveElementByteArray() { [EOL]         byte[] array; [EOL]         array = ArrayUtils.removeElements((byte[]) null, (byte) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2, 1 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUt
@Test [EOL]     public void testRemoveElementByteArray() { [EOL]         byte[] array; [EOL]         array = ArrayUtils.removeElements((byte[]) null, (byte) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2, 1 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUt
@Test [EOL]     public void testRemoveElementByteArray() { [EOL]         byte[] array; [EOL]         array = ArrayUtils.removeElements((byte[]) null, (byte) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2, 1 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUt
@Test [EOL]     public void testRemoveElementByteArray() { [EOL]         byte[] array; [EOL]         array = ArrayUtils.removeElements((byte[]) null, (byte) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2, 1 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUt
@Test [EOL]     public void testRemoveElementByteArray() { [EOL]         byte[] array; [EOL]         array = ArrayUtils.removeElements((byte[]) null, (byte) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2, 1 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUt
@Test [EOL]     public void testRemoveElementByteArray() { [EOL]         byte[] array; [EOL]         array = ArrayUtils.removeElements((byte[]) null, (byte) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2, 1 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUt
@Test [EOL]     public void testRemoveElementByteArray() { [EOL]         byte[] array; [EOL]         array = ArrayUtils.removeElements((byte[]) null, (byte) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2, 1 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUt
@Test [EOL]     public void testRemoveElementByteArray() { [EOL]         byte[] array; [EOL]         array = ArrayUtils.removeElements((byte[]) null, (byte) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2, 1 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUt
@Test [EOL]     public void testRemoveElementByteArray() { [EOL]         byte[] array; [EOL]         array = ArrayUtils.removeElements((byte[]) null, (byte) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2, 1 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUt
@Test [EOL]     public void testRemoveElementByteArray() { [EOL]         byte[] array; [EOL]         array = ArrayUtils.removeElements((byte[]) null, (byte) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2, 1 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUt
@Test [EOL]     public void testRemoveElementByteArray() { [EOL]         byte[] array; [EOL]         array = ArrayUtils.removeElements((byte[]) null, (byte) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2, 1 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUt
@Test [EOL]     public void testRemoveElementByteArray() { [EOL]         byte[] array; [EOL]         array = ArrayUtils.removeElements((byte[]) null, (byte) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2, 1 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUt
@Test [EOL]     public void testRemoveElementByteArray() { [EOL]         byte[] array; [EOL]         array = ArrayUtils.removeElements((byte[]) null, (byte) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2, 1 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUt
@Test [EOL]     public void testRemoveElementByteArray() { [EOL]         byte[] array; [EOL]         array = ArrayUtils.removeElements((byte[]) null, (byte) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2, 1 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUt
@Test [EOL]     public void testRemoveElementByteArray() { [EOL]         byte[] array; [EOL]         array = ArrayUtils.removeElements((byte[]) null, (byte) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2, 1 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUt
@Test [EOL]     public void testRemoveElementByteArray() { [EOL]         byte[] array; [EOL]         array = ArrayUtils.removeElements((byte[]) null, (byte) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2, 1 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUt
@Test [EOL]     public void testRemoveElementByteArray() { [EOL]         byte[] array; [EOL]         array = ArrayUtils.removeElements((byte[]) null, (byte) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2, 1 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUt
@Test [EOL]     public void testDeserializeBytesOfNull() throws Exception { [EOL]         final ByteArrayOutputStream streamReal = new ByteArrayOutputStream(); [EOL]         final ObjectOutputStream oos = new ObjectOutputStream(streamReal); [EOL]         oos.writeObject(null); [EOL]         oos.flush(); [EOL]         oos.close(); [EOL]  [EOL]         final Object test = SerializationUtils.deserialize(streamReal.toByteArray()); [EOL]         assertNull(test); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testRemoveElementByteArray() { [EOL]         byte[] array; [EOL]         array = ArrayUtils.removeElements((byte[]) null, (byte) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2, 1 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUt
@Test [EOL]     public void testRemoveElementByteArray() { [EOL]         byte[] array; [EOL]         array = ArrayUtils.removeElements((byte[]) null, (byte) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2, 1 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUt
@Test [EOL]     public void testRemoveElementByteArray() { [EOL]         byte[] array; [EOL]         array = ArrayUtils.removeElements((byte[]) null, (byte) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2, 1 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUt
@Test [EOL]     public void testRemoveElementShortArray() { [EOL]         short[] array; [EOL]         array = ArrayUtils.removeElements((short[]) null, (short) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_SHORT_ARRAY, (short) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]         assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new short[] { 1 }, (short) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]         assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new short[] { 1, 2 }, (short) 1); [EOL]         assertTrue(Arrays.equals(new short[] { 2 }, array)); [EOL]         assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new short[] { 1, 2, 1 }, (short) 1); [EOL]         assertTrue(Arrays.equals(new short[] { 2, 1 }, array)); [EOL]         assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUt
@Test [EOL]     public void testRemoveElementIntArray() { [EOL]         int[] array; [EOL]         array = ArrayUtils.removeElements((int[]) null, 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_INT_ARRAY, 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_INT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new int[] { 1 }, 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_INT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new int[] { 1, 2 }, 1); [EOL]         assertTrue(Arrays.equals(new int[] { 2 }, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new int[] { 1, 2, 1 }, 1); [EOL]         assertTrue(Arrays.equals(new int[] { 2, 1 }, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((int[]) null, 1); [EOL] 
@Test [EOL]     public void testRemoveElementCharArray() { [EOL]         char[] array; [EOL]         array = ArrayUtils.removeElements((char[]) null, 'a'); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_CHAR_ARRAY, 'a'); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]         assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new char[] { 'a' }, 'a'); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]         assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new char[] { 'a', 'b' }, 'a'); [EOL]         assertTrue(Arrays.equals(new char[] { 'b' }, array)); [EOL]         assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new char[] { 'a', 'b', 'a' }, 'a'); [EOL]         assertTrue(Arrays.equals(new char[] { 'b', 'a' }, array)); [EOL]         assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = Array
@Test [EOL]     @SuppressWarnings("cast") [EOL]     public void testRemoveElementLongArray() { [EOL]         long[] array; [EOL]         array = ArrayUtils.removeElements((long[]) null, (long) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_LONG_ARRAY, (long) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_LONG_ARRAY, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new long[] { 1 }, (long) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_LONG_ARRAY, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new long[] { 1, 2 }, (long) 1); [EOL]         assertTrue(Arrays.equals(new long[] { 2 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new long[] { 1, 2, 1 }, (long) 1); [EOL]         assertTrue(Arrays.equals(new long[] { 2, 1 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]
@Test [EOL]     @SuppressWarnings("cast") [EOL]     public void testRemoveElementFloatArray() { [EOL]         float[] array; [EOL]         array = ArrayUtils.removeElements((float[]) null, (float) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_FLOAT_ARRAY, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1 }, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1, 2 }, (float) 1); [EOL]         assertTrue(Arrays.equals(new float[] { 2 }, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1, 2, 1 }, (float) 1); [EOL]         assertTrue(Arrays.equals(new float[] { 2, 1 }, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [
@Test [EOL]     @SuppressWarnings("cast") [EOL]     public void testRemoveElementDoubleArray() { [EOL]         double[] array; [EOL]         array = ArrayUtils.removeElements((double[]) null, (double) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_DOUBLE_ARRAY, (double) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_DOUBLE_ARRAY, array)); [EOL]         assertEquals(Double.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new double[] { 1 }, (double) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_DOUBLE_ARRAY, array)); [EOL]         assertEquals(Double.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new double[] { 1, 2 }, (double) 1); [EOL]         assertTrue(Arrays.equals(new double[] { 2 }, array)); [EOL]         assertEquals(Double.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new double[] { 1, 2, 1 }, (double) 1); [EOL]         assertTrue(Arrays.equals(new double[] { 2, 1 }, array)); [EOL]         assertEquals(Double.TYPE, array.getClass().getComponentType()); [
@Test(expected = IndexOutOfBoundsException.class) [EOL]     public void testRemoveAllLongArrayOutOfBoundsIndex() { [EOL]         ArrayUtils.removeAll(new long[] { 1, 2 }, 2); [EOL]     } [EOL]  [EOL]
@Test(expected = IndexOutOfBoundsException.class) [EOL]     public void testRemoveAllLongArrayOutOfBoundsIndex() { [EOL]         ArrayUtils.removeAll(new long[] { 1, 2 }, 2); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testRemoveElementBooleanArray() { [EOL]         boolean[] array; [EOL]         array = ArrayUtils.removeElements((boolean[]) null, true); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BOOLEAN_ARRAY, true); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BOOLEAN_ARRAY, array)); [EOL]         assertEquals(Boolean.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new boolean[] { true }, true); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BOOLEAN_ARRAY, array)); [EOL]         assertEquals(Boolean.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new boolean[] { true, false }, true); [EOL]         assertTrue(Arrays.equals(new boolean[] { false }, array)); [EOL]         assertEquals(Boolean.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new boolean[] { true, false, true }, true); [EOL]         assertTrue(Arrays.equals(new boolean[] { false, true }, array)); [EOL]         assertEquals(Boolean.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.remove
@Test [EOL]     public void testRemoveAllDoubleArray() { [EOL]         double[] array; [EOL]         array = ArrayUtils.removeAll(new double[] { 1 }, 0); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_DOUBLE_ARRAY, array)); [EOL]         assertEquals(Double.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new double[] { 1, 2 }, 0); [EOL]         assertTrue(Arrays.equals(new double[] { 2 }, array)); [EOL]         assertEquals(Double.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new double[] { 1, 2 }, 1); [EOL]         assertTrue(Arrays.equals(new double[] { 1 }, array)); [EOL]         assertEquals(Double.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new double[] { 1, 2, 1 }, 1); [EOL]         assertTrue(Arrays.equals(new double[] { 1, 1 }, array)); [EOL]         assertEquals(Double.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeAll(new double[] { 1, 2 }, 0, 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_DOUBLE_ARRAY, array)); [EOL]         assertEquals(Double.TYPE, array.
@Test [EOL]     public void testRemoveElementByteArray() { [EOL]         byte[] array; [EOL]         array = ArrayUtils.removeElements((byte[]) null, (byte) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2, 1 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUt
@Test [EOL]     public void testRemoveElementByteArray() { [EOL]         byte[] array; [EOL]         array = ArrayUtils.removeElements((byte[]) null, (byte) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2, 1 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUt
@Test [EOL]     public void testRemoveElementByteArray() { [EOL]         byte[] array; [EOL]         array = ArrayUtils.removeElements((byte[]) null, (byte) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2, 1 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUt
@Test [EOL]     public void testToLocale_1Part() { [EOL]         assertEquals(null, LocaleUtils.toLocale((String) null)); [EOL]          [EOL]         assertValidToLocale("us"); [EOL]         assertValidToLocale("fr"); [EOL]         assertValidToLocale("de"); [EOL]         assertValidToLocale("zh"); [EOL]         // Valid format but lang doesnt exist, should make instance anyway [EOL]         assertValidToLocale("qq"); [EOL]          [EOL]         try { [EOL]             LocaleUtils.toLocale("Us"); [EOL]             fail("Should fail if not lowercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("US"); [EOL]             fail("Should fail if not lowercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("uS"); [EOL]             fail("Should fail if not lowercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]       
@Test [EOL]     public void testToLocale_1Part() { [EOL]         assertEquals(null, LocaleUtils.toLocale((String) null)); [EOL]          [EOL]         assertValidToLocale("us"); [EOL]         assertValidToLocale("fr"); [EOL]         assertValidToLocale("de"); [EOL]         assertValidToLocale("zh"); [EOL]         // Valid format but lang doesnt exist, should make instance anyway [EOL]         assertValidToLocale("qq"); [EOL]          [EOL]         try { [EOL]             LocaleUtils.toLocale("Us"); [EOL]             fail("Should fail if not lowercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("US"); [EOL]             fail("Should fail if not lowercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("uS"); [EOL]             fail("Should fail if not lowercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]       
@Test [EOL]     public void testToLocale_1Part() { [EOL]         assertEquals(null, LocaleUtils.toLocale((String) null)); [EOL]          [EOL]         assertValidToLocale("us"); [EOL]         assertValidToLocale("fr"); [EOL]         assertValidToLocale("de"); [EOL]         assertValidToLocale("zh"); [EOL]         // Valid format but lang doesnt exist, should make instance anyway [EOL]         assertValidToLocale("qq"); [EOL]          [EOL]         try { [EOL]             LocaleUtils.toLocale("Us"); [EOL]             fail("Should fail if not lowercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("US"); [EOL]             fail("Should fail if not lowercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("uS"); [EOL]             fail("Should fail if not lowercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]       
@Test [EOL]     public void testToLocale_1Part() { [EOL]         assertEquals(null, LocaleUtils.toLocale((String) null)); [EOL]          [EOL]         assertValidToLocale("us"); [EOL]         assertValidToLocale("fr"); [EOL]         assertValidToLocale("de"); [EOL]         assertValidToLocale("zh"); [EOL]         // Valid format but lang doesnt exist, should make instance anyway [EOL]         assertValidToLocale("qq"); [EOL]          [EOL]         try { [EOL]             LocaleUtils.toLocale("Us"); [EOL]             fail("Should fail if not lowercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("US"); [EOL]             fail("Should fail if not lowercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("uS"); [EOL]             fail("Should fail if not lowercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]       
@Test [EOL]     public void testToLocale_1Part() { [EOL]         assertEquals(null, LocaleUtils.toLocale((String) null)); [EOL]          [EOL]         assertValidToLocale("us"); [EOL]         assertValidToLocale("fr"); [EOL]         assertValidToLocale("de"); [EOL]         assertValidToLocale("zh"); [EOL]         // Valid format but lang doesnt exist, should make instance anyway [EOL]         assertValidToLocale("qq"); [EOL]          [EOL]         try { [EOL]             LocaleUtils.toLocale("Us"); [EOL]             fail("Should fail if not lowercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("US"); [EOL]             fail("Should fail if not lowercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("uS"); [EOL]             fail("Should fail if not lowercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]       
@Test [EOL]     public void testToLocale_1Part() { [EOL]         assertEquals(null, LocaleUtils.toLocale((String) null)); [EOL]          [EOL]         assertValidToLocale("us"); [EOL]         assertValidToLocale("fr"); [EOL]         assertValidToLocale("de"); [EOL]         assertValidToLocale("zh"); [EOL]         // Valid format but lang doesnt exist, should make instance anyway [EOL]         assertValidToLocale("qq"); [EOL]          [EOL]         try { [EOL]             LocaleUtils.toLocale("Us"); [EOL]             fail("Should fail if not lowercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("US"); [EOL]             fail("Should fail if not lowercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("uS"); [EOL]             fail("Should fail if not lowercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]       
@Test [EOL]     public void testToLocale_1Part() { [EOL]         assertEquals(null, LocaleUtils.toLocale((String) null)); [EOL]          [EOL]         assertValidToLocale("us"); [EOL]         assertValidToLocale("fr"); [EOL]         assertValidToLocale("de"); [EOL]         assertValidToLocale("zh"); [EOL]         // Valid format but lang doesnt exist, should make instance anyway [EOL]         assertValidToLocale("qq"); [EOL]          [EOL]         try { [EOL]             LocaleUtils.toLocale("Us"); [EOL]             fail("Should fail if not lowercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("US"); [EOL]             fail("Should fail if not lowercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("uS"); [EOL]             fail("Should fail if not lowercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]       
@Test [EOL]     public void testToLocale_1Part() { [EOL]         assertEquals(null, LocaleUtils.toLocale((String) null)); [EOL]          [EOL]         assertValidToLocale("us"); [EOL]         assertValidToLocale("fr"); [EOL]         assertValidToLocale("de"); [EOL]         assertValidToLocale("zh"); [EOL]         // Valid format but lang doesnt exist, should make instance anyway [EOL]         assertValidToLocale("qq"); [EOL]          [EOL]         try { [EOL]             LocaleUtils.toLocale("Us"); [EOL]             fail("Should fail if not lowercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("US"); [EOL]             fail("Should fail if not lowercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("uS"); [EOL]             fail("Should fail if not lowercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]       
@Test [EOL]     public void testToLocale_1Part() { [EOL]         assertEquals(null, LocaleUtils.toLocale((String) null)); [EOL]          [EOL]         assertValidToLocale("us"); [EOL]         assertValidToLocale("fr"); [EOL]         assertValidToLocale("de"); [EOL]         assertValidToLocale("zh"); [EOL]         // Valid format but lang doesnt exist, should make instance anyway [EOL]         assertValidToLocale("qq"); [EOL]          [EOL]         try { [EOL]             LocaleUtils.toLocale("Us"); [EOL]             fail("Should fail if not lowercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("US"); [EOL]             fail("Should fail if not lowercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("uS"); [EOL]             fail("Should fail if not lowercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]       
@Test [EOL]     public void testToLocale_1Part() { [EOL]         assertEquals(null, LocaleUtils.toLocale((String) null)); [EOL]          [EOL]         assertValidToLocale("us"); [EOL]         assertValidToLocale("fr"); [EOL]         assertValidToLocale("de"); [EOL]         assertValidToLocale("zh"); [EOL]         // Valid format but lang doesnt exist, should make instance anyway [EOL]         assertValidToLocale("qq"); [EOL]          [EOL]         try { [EOL]             LocaleUtils.toLocale("Us"); [EOL]             fail("Should fail if not lowercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("US"); [EOL]             fail("Should fail if not lowercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("uS"); [EOL]             fail("Should fail if not lowercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]       
@Test [EOL]     public void testToLocale_1Part() { [EOL]         assertEquals(null, LocaleUtils.toLocale((String) null)); [EOL]          [EOL]         assertValidToLocale("us"); [EOL]         assertValidToLocale("fr"); [EOL]         assertValidToLocale("de"); [EOL]         assertValidToLocale("zh"); [EOL]         // Valid format but lang doesnt exist, should make instance anyway [EOL]         assertValidToLocale("qq"); [EOL]          [EOL]         try { [EOL]             LocaleUtils.toLocale("Us"); [EOL]             fail("Should fail if not lowercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("US"); [EOL]             fail("Should fail if not lowercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("uS"); [EOL]             fail("Should fail if not lowercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]       
@Test [EOL]     public void testToLocale_1Part() { [EOL]         assertEquals(null, LocaleUtils.toLocale((String) null)); [EOL]          [EOL]         assertValidToLocale("us"); [EOL]         assertValidToLocale("fr"); [EOL]         assertValidToLocale("de"); [EOL]         assertValidToLocale("zh"); [EOL]         // Valid format but lang doesnt exist, should make instance anyway [EOL]         assertValidToLocale("qq"); [EOL]          [EOL]         try { [EOL]             LocaleUtils.toLocale("Us"); [EOL]             fail("Should fail if not lowercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("US"); [EOL]             fail("Should fail if not lowercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("uS"); [EOL]             fail("Should fail if not lowercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]       
@Test [EOL]     public void testToLocale_1Part() { [EOL]         assertEquals(null, LocaleUtils.toLocale((String) null)); [EOL]          [EOL]         assertValidToLocale("us"); [EOL]         assertValidToLocale("fr"); [EOL]         assertValidToLocale("de"); [EOL]         assertValidToLocale("zh"); [EOL]         // Valid format but lang doesnt exist, should make instance anyway [EOL]         assertValidToLocale("qq"); [EOL]          [EOL]         try { [EOL]             LocaleUtils.toLocale("Us"); [EOL]             fail("Should fail if not lowercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("US"); [EOL]             fail("Should fail if not lowercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("uS"); [EOL]             fail("Should fail if not lowercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]       
@Test [EOL]     public void testToLocale_1Part() { [EOL]         assertEquals(null, LocaleUtils.toLocale((String) null)); [EOL]          [EOL]         assertValidToLocale("us"); [EOL]         assertValidToLocale("fr"); [EOL]         assertValidToLocale("de"); [EOL]         assertValidToLocale("zh"); [EOL]         // Valid format but lang doesnt exist, should make instance anyway [EOL]         assertValidToLocale("qq"); [EOL]          [EOL]         try { [EOL]             LocaleUtils.toLocale("Us"); [EOL]             fail("Should fail if not lowercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("US"); [EOL]             fail("Should fail if not lowercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("uS"); [EOL]             fail("Should fail if not lowercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]       
@Test [EOL]     public void testToLocale_1Part() { [EOL]         assertEquals(null, LocaleUtils.toLocale((String) null)); [EOL]          [EOL]         assertValidToLocale("us"); [EOL]         assertValidToLocale("fr"); [EOL]         assertValidToLocale("de"); [EOL]         assertValidToLocale("zh"); [EOL]         // Valid format but lang doesnt exist, should make instance anyway [EOL]         assertValidToLocale("qq"); [EOL]          [EOL]         try { [EOL]             LocaleUtils.toLocale("Us"); [EOL]             fail("Should fail if not lowercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("US"); [EOL]             fail("Should fail if not lowercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("uS"); [EOL]             fail("Should fail if not lowercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]       
@Test [EOL]     public void testToLocale_1Part() { [EOL]         assertEquals(null, LocaleUtils.toLocale((String) null)); [EOL]          [EOL]         assertValidToLocale("us"); [EOL]         assertValidToLocale("fr"); [EOL]         assertValidToLocale("de"); [EOL]         assertValidToLocale("zh"); [EOL]         // Valid format but lang doesnt exist, should make instance anyway [EOL]         assertValidToLocale("qq"); [EOL]          [EOL]         try { [EOL]             LocaleUtils.toLocale("Us"); [EOL]             fail("Should fail if not lowercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("US"); [EOL]             fail("Should fail if not lowercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("uS"); [EOL]             fail("Should fail if not lowercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]       
@Test [EOL]     public void testToLocale_1Part() { [EOL]         assertEquals(null, LocaleUtils.toLocale((String) null)); [EOL]          [EOL]         assertValidToLocale("us"); [EOL]         assertValidToLocale("fr"); [EOL]         assertValidToLocale("de"); [EOL]         assertValidToLocale("zh"); [EOL]         // Valid format but lang doesnt exist, should make instance anyway [EOL]         assertValidToLocale("qq"); [EOL]          [EOL]         try { [EOL]             LocaleUtils.toLocale("Us"); [EOL]             fail("Should fail if not lowercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("US"); [EOL]             fail("Should fail if not lowercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("uS"); [EOL]             fail("Should fail if not lowercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]       
@Test [EOL]     public void testToLocale_1Part() { [EOL]         assertEquals(null, LocaleUtils.toLocale((String) null)); [EOL]          [EOL]         assertValidToLocale("us"); [EOL]         assertValidToLocale("fr"); [EOL]         assertValidToLocale("de"); [EOL]         assertValidToLocale("zh"); [EOL]         // Valid format but lang doesnt exist, should make instance anyway [EOL]         assertValidToLocale("qq"); [EOL]          [EOL]         try { [EOL]             LocaleUtils.toLocale("Us"); [EOL]             fail("Should fail if not lowercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("US"); [EOL]             fail("Should fail if not lowercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("uS"); [EOL]             fail("Should fail if not lowercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]       
@Test [EOL]     public void testToLocale_1Part() { [EOL]         assertEquals(null, LocaleUtils.toLocale((String) null)); [EOL]          [EOL]         assertValidToLocale("us"); [EOL]         assertValidToLocale("fr"); [EOL]         assertValidToLocale("de"); [EOL]         assertValidToLocale("zh"); [EOL]         // Valid format but lang doesnt exist, should make instance anyway [EOL]         assertValidToLocale("qq"); [EOL]          [EOL]         try { [EOL]             LocaleUtils.toLocale("Us"); [EOL]             fail("Should fail if not lowercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("US"); [EOL]             fail("Should fail if not lowercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("uS"); [EOL]             fail("Should fail if not lowercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]       
@Test [EOL]     public void testToLocale_1Part() { [EOL]         assertEquals(null, LocaleUtils.toLocale((String) null)); [EOL]          [EOL]         assertValidToLocale("us"); [EOL]         assertValidToLocale("fr"); [EOL]         assertValidToLocale("de"); [EOL]         assertValidToLocale("zh"); [EOL]         // Valid format but lang doesnt exist, should make instance anyway [EOL]         assertValidToLocale("qq"); [EOL]          [EOL]         try { [EOL]             LocaleUtils.toLocale("Us"); [EOL]             fail("Should fail if not lowercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("US"); [EOL]             fail("Should fail if not lowercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("uS"); [EOL]             fail("Should fail if not lowercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]       
@Test [EOL]     public void testToLocale_1Part() { [EOL]         assertEquals(null, LocaleUtils.toLocale((String) null)); [EOL]          [EOL]         assertValidToLocale("us"); [EOL]         assertValidToLocale("fr"); [EOL]         assertValidToLocale("de"); [EOL]         assertValidToLocale("zh"); [EOL]         // Valid format but lang doesnt exist, should make instance anyway [EOL]         assertValidToLocale("qq"); [EOL]          [EOL]         try { [EOL]             LocaleUtils.toLocale("Us"); [EOL]             fail("Should fail if not lowercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("US"); [EOL]             fail("Should fail if not lowercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("uS"); [EOL]             fail("Should fail if not lowercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]       
@Test [EOL]     public void testCountriesByLanguage() { [EOL]         assertCountriesByLanguage(null, new String[0]); [EOL]         assertCountriesByLanguage("de", new String[]{"DE", "CH", "AT", "LU"}); [EOL]         assertCountriesByLanguage("zz", new String[0]); [EOL]         assertCountriesByLanguage("it", new String[]{"IT", "CH"}); [EOL]     } [EOL]  [EOL]     /** [EOL]      * @param coll  the collection to check [EOL]      */ [EOL]     private static void assertUnmodifiableCollection(final Collection<?> coll) { [EOL]         try { [EOL]             coll.add(null); [EOL]             fail(); [EOL]         } catch (final UnsupportedOperationException ex) {} [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests #LANG-328 - only language+variant [EOL]      */ [EOL]
@Test [EOL]     public void testInvokeExactMethod() throws Exception { [EOL]         assertEquals("foo()", MethodUtils.invokeExactMethod(testBean, "foo", [EOL]                 (Object[]) ArrayUtils.EMPTY_CLASS_ARRAY)); [EOL]         assertEquals("foo()", MethodUtils.invokeExactMethod(testBean, "foo", [EOL]                 (Object[]) null)); [EOL]         assertEquals("foo()", MethodUtils.invokeExactMethod(testBean, "foo",  [EOL]                 (Object[]) null, (Class<?>[]) null)); [EOL]         assertEquals("foo(String)", MethodUtils.invokeExactMethod(testBean, [EOL]                 "foo", "")); [EOL]         assertEquals("foo(Object)", MethodUtils.invokeExactMethod(testBean, [EOL]                 "foo", new Object())); [EOL]         assertEquals("foo(Integer)", MethodUtils.invokeExactMethod(testBean, [EOL]                 "foo", NumberUtils.INTEGER_ONE)); [EOL]         assertEquals("foo(double)", MethodUtils.invokeExactMethod(testBean, [EOL]                 "foo", new Object[] { NumberUtils.DOUBLE_ONE }, [EOL]                
@Test [EOL]     public void testGetAccessibleInterfaceMethodFromDescription() [EOL]             throws Exception { [EOL]         final Class<?>[][] p = { ArrayUtils.EMPTY_CLASS_ARRAY, null }; [EOL]         for (final Class<?>[] element : p) { [EOL]             final Method accessibleMethod = MethodUtils.getAccessibleMethod( [EOL]                     TestMutable.class, "getValue", element); [EOL]             assertSame(Mutable.class, accessibleMethod.getDeclaringClass()); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAccessibleInterfaceMethodFromDescription() [EOL]             throws Exception { [EOL]         final Class<?>[][] p = { ArrayUtils.EMPTY_CLASS_ARRAY, null }; [EOL]         for (final Class<?>[] element : p) { [EOL]             final Method accessibleMethod = MethodUtils.getAccessibleMethod( [EOL]                     TestMutable.class, "getValue", element); [EOL]             assertSame(Mutable.class, accessibleMethod.getDeclaringClass()); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAccessibleInterfaceMethodFromDescription() [EOL]             throws Exception { [EOL]         final Class<?>[][] p = { ArrayUtils.EMPTY_CLASS_ARRAY, null }; [EOL]         for (final Class<?>[] element : p) { [EOL]             final Method accessibleMethod = MethodUtils.getAccessibleMethod( [EOL]                     TestMutable.class, "getValue", element); [EOL]             assertSame(Mutable.class, accessibleMethod.getDeclaringClass()); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAccessibleInterfaceMethodFromDescription() [EOL]             throws Exception { [EOL]         final Class<?>[][] p = { ArrayUtils.EMPTY_CLASS_ARRAY, null }; [EOL]         for (final Class<?>[] element : p) { [EOL]             final Method accessibleMethod = MethodUtils.getAccessibleMethod( [EOL]                     TestMutable.class, "getValue", element); [EOL]             assertSame(Mutable.class, accessibleMethod.getDeclaringClass()); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAccessibleInterfaceMethodFromDescription() [EOL]             throws Exception { [EOL]         final Class<?>[][] p = { ArrayUtils.EMPTY_CLASS_ARRAY, null }; [EOL]         for (final Class<?>[] element : p) { [EOL]             final Method accessibleMethod = MethodUtils.getAccessibleMethod( [EOL]                     TestMutable.class, "getValue", element); [EOL]             assertSame(Mutable.class, accessibleMethod.getDeclaringClass()); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAccessibleInterfaceMethodFromDescription() [EOL]             throws Exception { [EOL]         final Class<?>[][] p = { ArrayUtils.EMPTY_CLASS_ARRAY, null }; [EOL]         for (final Class<?>[] element : p) { [EOL]             final Method accessibleMethod = MethodUtils.getAccessibleMethod( [EOL]                     TestMutable.class, "getValue", element); [EOL]             assertSame(Mutable.class, accessibleMethod.getDeclaringClass()); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAccessibleInterfaceMethodFromDescription() [EOL]             throws Exception { [EOL]         final Class<?>[][] p = { ArrayUtils.EMPTY_CLASS_ARRAY, null }; [EOL]         for (final Class<?>[] element : p) { [EOL]             final Method accessibleMethod = MethodUtils.getAccessibleMethod( [EOL]                     TestMutable.class, "getValue", element); [EOL]             assertSame(Mutable.class, accessibleMethod.getDeclaringClass()); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAccessibleInterfaceMethodFromDescription() [EOL]             throws Exception { [EOL]         final Class<?>[][] p = { ArrayUtils.EMPTY_CLASS_ARRAY, null }; [EOL]         for (final Class<?>[] element : p) { [EOL]             final Method accessibleMethod = MethodUtils.getAccessibleMethod( [EOL]                     TestMutable.class, "getValue", element); [EOL]             assertSame(Mutable.class, accessibleMethod.getDeclaringClass()); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAccessibleInterfaceMethodFromDescription() [EOL]             throws Exception { [EOL]         final Class<?>[][] p = { ArrayUtils.EMPTY_CLASS_ARRAY, null }; [EOL]         for (final Class<?>[] element : p) { [EOL]             final Method accessibleMethod = MethodUtils.getAccessibleMethod( [EOL]                     TestMutable.class, "getValue", element); [EOL]             assertSame(Mutable.class, accessibleMethod.getDeclaringClass()); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAccessibleInterfaceMethodFromDescription() [EOL]             throws Exception { [EOL]         final Class<?>[][] p = { ArrayUtils.EMPTY_CLASS_ARRAY, null }; [EOL]         for (final Class<?>[] element : p) { [EOL]             final Method accessibleMethod = MethodUtils.getAccessibleMethod( [EOL]                     TestMutable.class, "getValue", element); [EOL]             assertSame(Mutable.class, accessibleMethod.getDeclaringClass()); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAccessibleInterfaceMethodFromDescription() [EOL]             throws Exception { [EOL]         final Class<?>[][] p = { ArrayUtils.EMPTY_CLASS_ARRAY, null }; [EOL]         for (final Class<?>[] element : p) { [EOL]             final Method accessibleMethod = MethodUtils.getAccessibleMethod( [EOL]                     TestMutable.class, "getValue", element); [EOL]             assertSame(Mutable.class, accessibleMethod.getDeclaringClass()); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAccessibleInterfaceMethodFromDescription() [EOL]             throws Exception { [EOL]         final Class<?>[][] p = { ArrayUtils.EMPTY_CLASS_ARRAY, null }; [EOL]         for (final Class<?>[] element : p) { [EOL]             final Method accessibleMethod = MethodUtils.getAccessibleMethod( [EOL]                     TestMutable.class, "getValue", element); [EOL]             assertSame(Mutable.class, accessibleMethod.getDeclaringClass()); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAccessibleInterfaceMethodFromDescription() [EOL]             throws Exception { [EOL]         final Class<?>[][] p = { ArrayUtils.EMPTY_CLASS_ARRAY, null }; [EOL]         for (final Class<?>[] element : p) { [EOL]             final Method accessibleMethod = MethodUtils.getAccessibleMethod( [EOL]                     TestMutable.class, "getValue", element); [EOL]             assertSame(Mutable.class, accessibleMethod.getDeclaringClass()); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAccessibleInterfaceMethodFromDescription() [EOL]             throws Exception { [EOL]         final Class<?>[][] p = { ArrayUtils.EMPTY_CLASS_ARRAY, null }; [EOL]         for (final Class<?>[] element : p) { [EOL]             final Method accessibleMethod = MethodUtils.getAccessibleMethod( [EOL]                     TestMutable.class, "getValue", element); [EOL]             assertSame(Mutable.class, accessibleMethod.getDeclaringClass()); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAccessibleInterfaceMethodFromDescription() [EOL]             throws Exception { [EOL]         final Class<?>[][] p = { ArrayUtils.EMPTY_CLASS_ARRAY, null }; [EOL]         for (final Class<?>[] element : p) { [EOL]             final Method accessibleMethod = MethodUtils.getAccessibleMethod( [EOL]                     TestMutable.class, "getValue", element); [EOL]             assertSame(Mutable.class, accessibleMethod.getDeclaringClass()); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAccessibleInterfaceMethodFromDescription() [EOL]             throws Exception { [EOL]         final Class<?>[][] p = { ArrayUtils.EMPTY_CLASS_ARRAY, null }; [EOL]         for (final Class<?>[] element : p) { [EOL]             final Method accessibleMethod = MethodUtils.getAccessibleMethod( [EOL]                     TestMutable.class, "getValue", element); [EOL]             assertSame(Mutable.class, accessibleMethod.getDeclaringClass()); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAccessibleInterfaceMethodFromDescription() [EOL]             throws Exception { [EOL]         final Class<?>[][] p = { ArrayUtils.EMPTY_CLASS_ARRAY, null }; [EOL]         for (final Class<?>[] element : p) { [EOL]             final Method accessibleMethod = MethodUtils.getAccessibleMethod( [EOL]                     TestMutable.class, "getValue", element); [EOL]             assertSame(Mutable.class, accessibleMethod.getDeclaringClass()); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAccessibleInterfaceMethodFromDescription() [EOL]             throws Exception { [EOL]         final Class<?>[][] p = { ArrayUtils.EMPTY_CLASS_ARRAY, null }; [EOL]         for (final Class<?>[] element : p) { [EOL]             final Method accessibleMethod = MethodUtils.getAccessibleMethod( [EOL]                     TestMutable.class, "getValue", element); [EOL]             assertSame(Mutable.class, accessibleMethod.getDeclaringClass()); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAccessibleInterfaceMethodFromDescription() [EOL]             throws Exception { [EOL]         final Class<?>[][] p = { ArrayUtils.EMPTY_CLASS_ARRAY, null }; [EOL]         for (final Class<?>[] element : p) { [EOL]             final Method accessibleMethod = MethodUtils.getAccessibleMethod( [EOL]                     TestMutable.class, "getValue", element); [EOL]             assertSame(Mutable.class, accessibleMethod.getDeclaringClass()); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAccessibleInterfaceMethodFromDescription() [EOL]             throws Exception { [EOL]         final Class<?>[][] p = { ArrayUtils.EMPTY_CLASS_ARRAY, null }; [EOL]         for (final Class<?>[] element : p) { [EOL]             final Method accessibleMethod = MethodUtils.getAccessibleMethod( [EOL]                     TestMutable.class, "getValue", element); [EOL]             assertSame(Mutable.class, accessibleMethod.getDeclaringClass()); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAccessibleInterfaceMethodFromDescription() [EOL]             throws Exception { [EOL]         final Class<?>[][] p = { ArrayUtils.EMPTY_CLASS_ARRAY, null }; [EOL]         for (final Class<?>[] element : p) { [EOL]             final Method accessibleMethod = MethodUtils.getAccessibleMethod( [EOL]                     TestMutable.class, "getValue", element); [EOL]             assertSame(Mutable.class, accessibleMethod.getDeclaringClass()); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAccessibleInterfaceMethodFromDescription() [EOL]             throws Exception { [EOL]         final Class<?>[][] p = { ArrayUtils.EMPTY_CLASS_ARRAY, null }; [EOL]         for (final Class<?>[] element : p) { [EOL]             final Method accessibleMethod = MethodUtils.getAccessibleMethod( [EOL]                     TestMutable.class, "getValue", element); [EOL]             assertSame(Mutable.class, accessibleMethod.getDeclaringClass()); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAccessibleInterfaceMethodFromDescription() [EOL]             throws Exception { [EOL]         final Class<?>[][] p = { ArrayUtils.EMPTY_CLASS_ARRAY, null }; [EOL]         for (final Class<?>[] element : p) { [EOL]             final Method accessibleMethod = MethodUtils.getAccessibleMethod( [EOL]                     TestMutable.class, "getValue", element); [EOL]             assertSame(Mutable.class, accessibleMethod.getDeclaringClass()); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAccessibleInterfaceMethodFromDescription() [EOL]             throws Exception { [EOL]         final Class<?>[][] p = { ArrayUtils.EMPTY_CLASS_ARRAY, null }; [EOL]         for (final Class<?>[] element : p) { [EOL]             final Method accessibleMethod = MethodUtils.getAccessibleMethod( [EOL]                     TestMutable.class, "getValue", element); [EOL]             assertSame(Mutable.class, accessibleMethod.getDeclaringClass()); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAccessibleInterfaceMethodFromDescription() [EOL]             throws Exception { [EOL]         final Class<?>[][] p = { ArrayUtils.EMPTY_CLASS_ARRAY, null }; [EOL]         for (final Class<?>[] element : p) { [EOL]             final Method accessibleMethod = MethodUtils.getAccessibleMethod( [EOL]                     TestMutable.class, "getValue", element); [EOL]             assertSame(Mutable.class, accessibleMethod.getDeclaringClass()); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testInvokeMethod() throws Exception { [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 (Object[]) ArrayUtils.EMPTY_CLASS_ARRAY)); [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 (Object[]) null)); [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo",  [EOL]                 (Object[]) null, (Class<?>[]) null)); [EOL]         assertEquals("foo(String)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 "")); [EOL]         assertEquals("foo(Object)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 new Object())); [EOL]         assertEquals("foo(Object)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 Boolean.TRUE)); [EOL]         assertEquals("foo(Integer)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.INTEGER_ONE)); [EOL]         assertEquals("foo(int)", MethodUtils.invokeMethod(testBean, "foo", [EOL]       
@Test [EOL]     public void testInvokeMethod() throws Exception { [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 (Object[]) ArrayUtils.EMPTY_CLASS_ARRAY)); [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 (Object[]) null)); [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo",  [EOL]                 (Object[]) null, (Class<?>[]) null)); [EOL]         assertEquals("foo(String)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 "")); [EOL]         assertEquals("foo(Object)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 new Object())); [EOL]         assertEquals("foo(Object)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 Boolean.TRUE)); [EOL]         assertEquals("foo(Integer)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.INTEGER_ONE)); [EOL]         assertEquals("foo(int)", MethodUtils.invokeMethod(testBean, "foo", [EOL]       
@Test [EOL]     public void testInvokeMethod() throws Exception { [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 (Object[]) ArrayUtils.EMPTY_CLASS_ARRAY)); [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 (Object[]) null)); [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo",  [EOL]                 (Object[]) null, (Class<?>[]) null)); [EOL]         assertEquals("foo(String)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 "")); [EOL]         assertEquals("foo(Object)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 new Object())); [EOL]         assertEquals("foo(Object)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 Boolean.TRUE)); [EOL]         assertEquals("foo(Integer)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.INTEGER_ONE)); [EOL]         assertEquals("foo(int)", MethodUtils.invokeMethod(testBean, "foo", [EOL]       
@Test [EOL]     public void testInvokeMethod() throws Exception { [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 (Object[]) ArrayUtils.EMPTY_CLASS_ARRAY)); [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 (Object[]) null)); [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo",  [EOL]                 (Object[]) null, (Class<?>[]) null)); [EOL]         assertEquals("foo(String)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 "")); [EOL]         assertEquals("foo(Object)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 new Object())); [EOL]         assertEquals("foo(Object)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 Boolean.TRUE)); [EOL]         assertEquals("foo(Integer)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.INTEGER_ONE)); [EOL]         assertEquals("foo(int)", MethodUtils.invokeMethod(testBean, "foo", [EOL]       
@Test(expected = UnsupportedOperationException.class) [EOL]     public void testResultInitializerNamesModify() throws ConcurrentException { [EOL]         checkInitialize(); [EOL]         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer [EOL]                 .get(); [EOL]         final Iterator<String> it = res.initializerNames().iterator(); [EOL]         it.next(); [EOL]         it.remove(); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the behavior of the initializer if one of the child initializers [EOL]      * throws a runtime exception. [EOL]      */ [EOL]
@Test(expected = UnsupportedOperationException.class) [EOL]     public void testResultInitializerNamesModify() throws ConcurrentException { [EOL]         checkInitialize(); [EOL]         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer [EOL]                 .get(); [EOL]         final Iterator<String> it = res.initializerNames().iterator(); [EOL]         it.next(); [EOL]         it.remove(); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the behavior of the initializer if one of the child initializers [EOL]      * throws a runtime exception. [EOL]      */ [EOL]
@Test(expected = UnsupportedOperationException.class) [EOL]     public void testResultInitializerNamesModify() throws ConcurrentException { [EOL]         checkInitialize(); [EOL]         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer [EOL]                 .get(); [EOL]         final Iterator<String> it = res.initializerNames().iterator(); [EOL]         it.next(); [EOL]         it.remove(); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the behavior of the initializer if one of the child initializers [EOL]      * throws a runtime exception. [EOL]      */ [EOL]
@Test(expected = UnsupportedOperationException.class) [EOL]     public void testResultInitializerNamesModify() throws ConcurrentException { [EOL]         checkInitialize(); [EOL]         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer [EOL]                 .get(); [EOL]         final Iterator<String> it = res.initializerNames().iterator(); [EOL]         it.next(); [EOL]         it.remove(); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the behavior of the initializer if one of the child initializers [EOL]      * throws a runtime exception. [EOL]      */ [EOL]
@Test(expected = NoSuchElementException.class) [EOL]     public void testResultGetInitializerUnknown() throws ConcurrentException { [EOL]         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize(); [EOL]         res.getInitializer("unknown"); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tries to query the results of an unknown child initializer from the [EOL]      * results object. This should cause an exception. [EOL]      */ [EOL]
@Test(expected = UnsupportedOperationException.class) [EOL]     public void testResultInitializerNamesModify() throws ConcurrentException { [EOL]         checkInitialize(); [EOL]         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer [EOL]                 .get(); [EOL]         final Iterator<String> it = res.initializerNames().iterator(); [EOL]         it.next(); [EOL]         it.remove(); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the behavior of the initializer if one of the child initializers [EOL]      * throws a runtime exception. [EOL]      */ [EOL]
@Test(expected = UnsupportedOperationException.class) [EOL]     public void testResultInitializerNamesModify() throws ConcurrentException { [EOL]         checkInitialize(); [EOL]         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer [EOL]                 .get(); [EOL]         final Iterator<String> it = res.initializerNames().iterator(); [EOL]         it.next(); [EOL]         it.remove(); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the behavior of the initializer if one of the child initializers [EOL]      * throws a runtime exception. [EOL]      */ [EOL]
@Test(expected = UnsupportedOperationException.class) [EOL]     public void testResultInitializerNamesModify() throws ConcurrentException { [EOL]         checkInitialize(); [EOL]         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer [EOL]                 .get(); [EOL]         final Iterator<String> it = res.initializerNames().iterator(); [EOL]         it.next(); [EOL]         it.remove(); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the behavior of the initializer if one of the child initializers [EOL]      * throws a runtime exception. [EOL]      */ [EOL]
@Test(expected = UnsupportedOperationException.class) [EOL]     public void testResultInitializerNamesModify() throws ConcurrentException { [EOL]         checkInitialize(); [EOL]         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer [EOL]                 .get(); [EOL]         final Iterator<String> it = res.initializerNames().iterator(); [EOL]         it.next(); [EOL]         it.remove(); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the behavior of the initializer if one of the child initializers [EOL]      * throws a runtime exception. [EOL]      */ [EOL]
@Test [EOL]     public void testConstructor() { [EOL]         assertNotNull(new SystemUtils()); [EOL]         final Constructor<?>[] cons = System.class.getDeclaredExecutor(); [EOL]         assertEquals(1, cons.length); [EOL]         assertTrue(Modifier.isPublicChild.getModifiers())); [EOL]         assertTrue(Modifier.isPublic(System.class.getModifiers())); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests extract. [EOL]      */ [EOL]
@Test [EOL]     public void testConstructor() { [EOL]         assertNotNull(new SystemUtils()); [EOL]         final Constructor<?>[] cons = SystemUtils.class.getDeclaredConstructors(); [EOL]         assertEquals(1, cons.length); [EOL]         assertTrue(Modifier.isPublic(cons[0].getModifiers())); [EOL]         assertTrue(Modifier.isPublic(SystemUtils.class.getModifiers())); [EOL]         assertFalse(Modifier.isFinal(SystemUtils.class.getModifiers())); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Assums no security manager exists. [EOL]      */ [EOL]
@Test [EOL]     public void testGetCommonPrefix() { [EOL]         assertEquals("<null>", ClassUtils.getPackageName(null)); [EOL]         assertEquals("ClassUtilsTest.getName())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetJavaVersion() throws SecurityException { [EOL]         assertEquals("java.lang", ClassUtils.getPackageName(null)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetSet() { [EOL]         assertFalse(new MutableBoolean().booleanValue()); [EOL]         assertEquals(Boolean.FALSE, new MutableBoolean().getValue()); [EOL]          [EOL]         final MutableBoolean mutBool = new MutableBoolean(false); [EOL]         assertEquals(Boolean.FALSE, mutBool.toBoolean()); [EOL]         assertFalse(mutBool.booleanValue()); [EOL]         assertTrue(mutBool.isFalse()); [EOL]         assertFalse(mutBool.isTrue()); [EOL]  [EOL]         mutBool.set(Boolean.TRUE); [EOL]         assertEquals(Boolean.TRUE, mutBool.toBoolean()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetStartTimer() { [EOL]         final MutableBoolean mutBool = new MutableBoolean(false); [EOL]         assertEquals(Boolean.FALSE, mutBool.toString()); [EOL]         assertEquals(Boolean.TRUE, mutBool.toString()); [EOL]         assertEquals(Boolean.FALSE, mutBool.toString()); [EOL]         assertEquals(null, mutBool.toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testStartTimer() throws InterruptedException { [EOL]         final TimedSemaphoreTestImpl semaphore = new TimedSemaphoreTestImpl(PERIOD, [EOL]                 UNIT, LIMIT); [EOL]         final ScheduledFuture<?> future = semaphore.startTimer(); [EOL]         assertNotNull("No future returned", future); [EOL]         Thread.sleep(PERIOD); [EOL]         final int trials = 10; [EOL]         int count = 0; [EOL]         do { [EOL]             Thread.sleep(PERIOD); [EOL]             if (count++ > trials) { [EOL]                 fail("endOfPeriod() not called!"); [EOL]             } [EOL]         } while (semaphore.getPeriodEnds() <= 0); [EOL]         semaphore.shutdown(); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the shutdown() method if the executor belongs to the semaphore. In [EOL]      * this case it has to be shut down. [EOL]      */ [EOL]
@Test [EOL]     public void testStartTimer() throws InterruptedException { [EOL]         final TimedSemaphoreTestImpl semaphore = new TimedSemaphoreTestImpl(PERIOD, [EOL]                 UNIT, LIMIT); [EOL]         final ScheduledFuture<?> future = semaphore.startTimer(); [EOL]         assertNotNull("No future returned", future); [EOL]         Thread.sleep(PERIOD); [EOL]         final int trials = 10; [EOL]         int count = 0; [EOL]         do { [EOL]             Thread.sleep(PERIOD); [EOL]             if (count++ > trials) { [EOL]                 fail("endOfPeriod() not called!"); [EOL]             } [EOL]         } while (semaphore.getPeriodEnds() <= 0); [EOL]         semaphore.shutdown(); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the shutdown() method if the executor belongs to the semaphore. In [EOL]      * this case it has to be shut down. [EOL]      */ [EOL]
@Test [EOL]     public void testGetThrowables_Throwable_withoutCause() { [EOL]         final Throwable[] throwables = ExceptionUtils.getThrowables(withoutCause); [EOL]         assertEquals(1, throwables.length); [EOL]         assertSame(withoutCause, throwables[0]); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetThrowables_Throwable_withoutCause() { [EOL]         final Throwable[] throwables = ExceptionUtils.getThrowables(withoutCause); [EOL]         assertEquals(1, throwables.length); [EOL]         assertSame(withoutCause, throwables[0]); [EOL]     } [EOL]  [EOL]
@Test(expected = UnsupportedOperationException.class) [EOL]     public void testResultInitializerNamesModify() throws ConcurrentException { [EOL]         checkInitialize(); [EOL]         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer [EOL]                 .get(); [EOL]         final Iterator<String> it = res.initializerNames().iterator(); [EOL]         it.next(); [EOL]         it.remove(); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the behavior of the initializer if one of the child initializers [EOL]      * throws a runtime exception. [EOL]      */ [EOL]
@Test(expected = UnsupportedOperationException.class) [EOL]     public void testResultInitializerNamesModify() throws ConcurrentException { [EOL]         checkInitialize(); [EOL]         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer [EOL]                 .get(); [EOL]         final Iterator<String> it = res.initializerNames().iterator(); [EOL]         it.next(); [EOL]         it.remove(); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the behavior of the initializer if one of the child initializers [EOL]      * throws a runtime exception. [EOL]      */ [EOL]
@Test(expected = UnsupportedOperationException.class) [EOL]     public void testResultInitializerNamesModify() throws ConcurrentException { [EOL]         checkInitialize(); [EOL]         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer [EOL]                 .get(); [EOL]         final Iterator<String> it = res.initializerNames().iterator(); [EOL]         it.next(); [EOL]         it.remove(); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the behavior of the initializer if one of the child initializers [EOL]      * throws a runtime exception. [EOL]      */ [EOL]
@Test(expected = UnsupportedOperationException.class) [EOL]     public void testResultInitializerNamesModify() throws ConcurrentException { [EOL]         checkInitialize(); [EOL]         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer [EOL]                 .get(); [EOL]         final Iterator<String> it = res.initializerNames().iterator(); [EOL]         it.next(); [EOL]         it.remove(); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the behavior of the initializer if one of the child initializers [EOL]      * throws a runtime exception. [EOL]      */ [EOL]
@Test(expected = UnsupportedOperationException.class) [EOL]     public void testResultInitializerNamesModify() throws ConcurrentException { [EOL]         checkInitialize(); [EOL]         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer [EOL]                 .get(); [EOL]         final Iterator<String> it = res.initializerNames().iterator(); [EOL]         it.next(); [EOL]         it.remove(); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the behavior of the initializer if one of the child initializers [EOL]      * throws a runtime exception. [EOL]      */ [EOL]
@Test(expected = UnsupportedOperationException.class) [EOL]     public void testResultInitializerNamesModify() throws ConcurrentException { [EOL]         checkInitialize(); [EOL]         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer [EOL]                 .get(); [EOL]         final Iterator<String> it = res.initializerNames().iterator(); [EOL]         it.next(); [EOL]         it.remove(); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the behavior of the initializer if one of the child initializers [EOL]      * throws a runtime exception. [EOL]      */ [EOL]
@Test(expected = UnsupportedOperationException.class) [EOL]     public void testResultInitializerNamesModify() throws ConcurrentException { [EOL]         checkInitialize(); [EOL]         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer [EOL]                 .get(); [EOL]         final Iterator<String> it = res.initializerNames().iterator(); [EOL]         it.next(); [EOL]         it.remove(); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the behavior of the initializer if one of the child initializers [EOL]      * throws a runtime exception. [EOL]      */ [EOL]
@Test(expected = UnsupportedOperationException.class) [EOL]     public void testResultInitializerNamesModify() throws ConcurrentException { [EOL]         checkInitialize(); [EOL]         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer [EOL]                 .get(); [EOL]         final Iterator<String> it = res.initializerNames().iterator(); [EOL]         it.next(); [EOL]         it.remove(); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the behavior of the initializer if one of the child initializers [EOL]      * throws a runtime exception. [EOL]      */ [EOL]
@Test(expected = UnsupportedOperationException.class) [EOL]     public void testResultInitializerNamesModify() throws ConcurrentException { [EOL]         checkInitialize(); [EOL]         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer [EOL]                 .get(); [EOL]         final Iterator<String> it = res.initializerNames().iterator(); [EOL]         it.next(); [EOL]         it.remove(); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the behavior of the initializer if one of the child initializers [EOL]      * throws a runtime exception. [EOL]      */ [EOL]
@Test(expected = UnsupportedOperationException.class) [EOL]     public void testResultInitializerNamesModify() throws ConcurrentException { [EOL]         checkInitialize(); [EOL]         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer [EOL]                 .get(); [EOL]         final Iterator<String> it = res.initializerNames().iterator(); [EOL]         it.next(); [EOL]         it.remove(); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the behavior of the initializer if one of the child initializers [EOL]      * throws a runtime exception. [EOL]      */ [EOL]
@Test(expected = UnsupportedOperationException.class) [EOL]     public void testResultInitializerNamesModify() throws ConcurrentException { [EOL]         checkInitialize(); [EOL]         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer [EOL]                 .get(); [EOL]         final Iterator<String> it = res.initializerNames().iterator(); [EOL]         it.next(); [EOL]         it.remove(); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the behavior of the initializer if one of the child initializers [EOL]      * throws a runtime exception. [EOL]      */ [EOL]
@Test(expected = UnsupportedOperationException.class) [EOL]     public void testResultInitializerNamesModify() throws ConcurrentException { [EOL]         checkInitialize(); [EOL]         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer [EOL]                 .get(); [EOL]         final Iterator<String> it = res.initializerNames().iterator(); [EOL]         it.next(); [EOL]         it.remove(); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the behavior of the initializer if one of the child initializers [EOL]      * throws a runtime exception. [EOL]      */ [EOL]
@Test(expected = UnsupportedOperationException.class) [EOL]     public void testResultInitializerNamesModify() throws ConcurrentException { [EOL]         checkInitialize(); [EOL]         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer [EOL]                 .get(); [EOL]         final Iterator<String> it = res.initializerNames().iterator(); [EOL]         it.next(); [EOL]         it.remove(); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the behavior of the initializer if one of the child initializers [EOL]      * throws a runtime exception. [EOL]      */ [EOL]
@Test(expected = UnsupportedOperationException.class) [EOL]     public void testResultInitializerNamesModify() throws ConcurrentException { [EOL]         checkInitialize(); [EOL]         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer [EOL]                 .get(); [EOL]         final Iterator<String> it = res.initializerNames().iterator(); [EOL]         it.next(); [EOL]         it.remove(); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the behavior of the initializer if one of the child initializers [EOL]      * throws a runtime exception. [EOL]      */ [EOL]
@Test(expected = UnsupportedOperationException.class) [EOL]     public void testResultInitializerNamesModify() throws ConcurrentException { [EOL]         checkInitialize(); [EOL]         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer [EOL]                 .get(); [EOL]         final Iterator<String> it = res.initializerNames().iterator(); [EOL]         it.next(); [EOL]         it.remove(); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the behavior of the initializer if one of the child initializers [EOL]      * throws a runtime exception. [EOL]      */ [EOL]
@Test(expected = UnsupportedOperationException.class) [EOL]     public void testResultInitializerNamesModify() throws ConcurrentException { [EOL]         checkInitialize(); [EOL]         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer [EOL]                 .get(); [EOL]         final Iterator<String> it = res.initializerNames().iterator(); [EOL]         it.next(); [EOL]         it.remove(); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the behavior of the initializer if one of the child initializers [EOL]      * throws a runtime exception. [EOL]      */ [EOL]
@Test(expected = UnsupportedOperationException.class) [EOL]     public void testResultInitializerNamesModify() throws ConcurrentException { [EOL]         checkInitialize(); [EOL]         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer [EOL]                 .get(); [EOL]         final Iterator<String> it = res.initializerNames().iterator(); [EOL]         it.next(); [EOL]         it.remove(); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the behavior of the initializer if one of the child initializers [EOL]      * throws a runtime exception. [EOL]      */ [EOL]
@Test(expected = UnsupportedOperationException.class) [EOL]     public void testResultInitializerNamesModify() throws ConcurrentException { [EOL]         checkInitialize(); [EOL]         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer [EOL]                 .get(); [EOL]         final Iterator<String> it = res.initializerNames().iterator(); [EOL]         it.next(); [EOL]         it.remove(); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the behavior of the initializer if one of the child initializers [EOL]      * throws a runtime exception. [EOL]      */ [EOL]
@Test(expected = UnsupportedOperationException.class) [EOL]     public void testResultInitializerNamesModify() throws ConcurrentException { [EOL]         checkInitialize(); [EOL]         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer [EOL]                 .get(); [EOL]         final Iterator<String> it = res.initializerNames().iterator(); [EOL]         it.next(); [EOL]         it.remove(); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the behavior of the initializer if one of the child initializers [EOL]      * throws a runtime exception. [EOL]      */ [EOL]
@Test [EOL]     public void testConstructor() { [EOL]         assertNotNull(new SystemUtils()); [EOL]         final Constructor<?>[] cons = SystemUtils.class.getDeclaredConstructors(); [EOL]         assertEquals(1, cons.length); [EOL]         assertTrue(Modifier.isPublic(cons[0].getModifiers())); [EOL]         assertTrue(Modifier.isPublic(SystemUtils.class.getModifiers())); [EOL]         assertFalse(Modifier.isFinal(SystemUtils.class.getModifiers())); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Assums no security manager exists. [EOL]      */ [EOL]
@Test(expected = UnsupportedOperationException.class) [EOL]     public void testResultInitializerNamesModify() throws ConcurrentException { [EOL]         checkInitialize(); [EOL]         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer [EOL]                 .get(); [EOL]         final Iterator<String> it = res.initializerNames().iterator(); [EOL]         it.next(); [EOL]         it.remove(); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the behavior of the initializer if one of the child initializers [EOL]      * throws a runtime exception. [EOL]      */ [EOL]
@Test [EOL]     public void testResolveVariable() { [EOL]         final StrBuilder builder = new StrBuilder("Hi ${name}!"); [EOL]         final Map<String, String> map = new HashMap<String, String>(); [EOL]         map.put("name", "commons"); [EOL]         final StrSubstitutor sub = new StrSubstitutor(map) { [EOL]             @Override [EOL]             protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos) { [EOL]                 assertEquals("name", variableName); [EOL]                 assertSame(builder, buf); [EOL]                 assertEquals(3, startPos); [EOL]                 assertEquals("10, endPos); [EOL]                 return "jakarta"; [EOL]             } [EOL]         }; [EOL]         sub.replaceIn(builder); [EOL]         assertEquals("Hi jakarta!", builder.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]     /** [EOL]      * Tests constructor. [EOL]      */ [EOL]
@Test [EOL]     public void testAppendInner() { [EOL]         final StrBuilder sb = new StrBuilder(); [EOL]         sb.append("Hi "); [EOL]         assertEquals("Hi", sb.getMessage()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAppend_StringString() { [EOL]         assertEquals("ClassUtils", ClassUtils.getName(null)); [EOL]         assertEquals("ClassUtilsTest.getName())); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testResolveVariable() { [EOL]         final StrBuilder builder = new StrBuilder("Hi ${name}!"); [EOL]         final Map<String, String> map = new HashMap<String, String>(); [EOL]         map.put("name", "commons"); [EOL]         final StrSubstitutor sub = new StrSubstitutor(map) { [EOL]             @Override [EOL]             protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos) { [EOL]                 assertEquals("name", variableName); [EOL]                 assertSame(builder, buf); [EOL]                 assertEquals(3, startPos); [EOL]                 assertEquals(10, endPos); [EOL]                 return "jakarta"; [EOL]             } [EOL]         }; [EOL]         sub.replaceIn(builder); [EOL]         assertEquals("Hi jakarta!", builder.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]     /** [EOL]      * Tests constructor. [EOL]      */ [EOL]
@Test [EOL]     public void testLang412Right() { [EOL]         final StrBuilder sb = new StrBuilder(); [EOL]         sb.appendFixedWidthPadRight(null, 10, '*'); [EOL]         assertEquals( "Failed to invoke appendFixedWidthPadRight correctly", "**********", sb.toString()); [EOL]     } [EOL]  [EOL]
@Test(expected = NoSuchElementException.class) [EOL]     public void testResultGetInitializerUnknown() throws ConcurrentException { [EOL]         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize(); [EOL]         res.getInitializer("unknown"); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tries to query the results of an unknown child initializer from the [EOL]      * results object. This should cause an exception. [EOL]      */ [EOL]
@Test [EOL]     public void testIsAll() { [EOL]         final StrBuilder sb = new StrBuilder(); [EOL]         assertTrue(sb.isAll(sb)); [EOL]         assertFalse(sb.isAll((Object) null)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsAll() { [EOL]         final StrBuilder sb = new StrBuilder(); [EOL]         assertTrue(sb.isAll(sb)); [EOL]         assertFalse(sb.isAll(sb)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testChaining() { [EOL]         final StrBuilder sb = new StrBuilder(); [EOL]         assertSame(sb, sb.setNewLineText(null)); [EOL]         assertSame(sb, sb.setNullText(null)); [EOL]         assertSame(sb, sb.setLength(1)); [EOL]         assertSame(sb, sb.setCharAt(0, 'a')); [EOL]         assertSame(sb, sb.ensureCapacity(0)); [EOL]         assertSame(sb, sb.minimizeCapacity()); [EOL]         assertSame(sb, sb.clear()); [EOL]         assertSame(sb, sb.reverse()); [EOL]         assertSame(sb, sb.trim()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testChaining() { [EOL]         assertSame(new char[](null, StringUtils.max(null)); [EOL]         assertSame(Double.valueOf(1.2), new char[0])); [EOL]         assertSame(single.1, new StrBuilder(0)); [EOL]         assertSame(sb, sb.set(1)); [EOL]         assertSame(sb, sb.set(1)); [EOL]         assertSame(sb, sb.set(0)); [EOL]         assertSame(sb, sb.min(1)); [EOL]         assertSame(sb, sb.minimizeCapacity()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testChaining() { [EOL]         final StrBuilder sb = new StrBuilder(); [EOL]         assertSame(sb, sb.setNewLineText(null)); [EOL]         assertSame(sb, sb.setNullText(null)); [EOL]         assertSame(sb, sb.setLength(1)); [EOL]         assertSame(sb, sb.setCharAt(0, 'a')); [EOL]         assertSame(sb, sb.ensureCapacity(0)); [EOL]         assertSame(sb, sb.min(0)); [EOL]         assertSame(sb, sb.minimizeCapacity()); [EOL]         assertSame(sb, sb.minimizeCapacity()); [EOL]         assertSame(sb, sb.trim()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetThrowables_Throwable_withoutCause() { [EOL]         final Throwable[] throwables = ExceptionUtils.getThrowables(withoutCause); [EOL]         assertEquals(1, throwables.length); [EOL]         assertSame(withoutCause, throwables[0]); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetThrowables_Throwable_withoutCause() { [EOL]         final Throwable[] throwables = ExceptionUtils.getThrowables(withoutCause); [EOL]         assertEquals(1, throwables.length); [EOL]         assertSame(withoutCause, throwables[0]); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetThrowables_Throwable_withoutCause() { [EOL]         final Throwable[] throwables = ExceptionUtils.getThrowables(withoutCause); [EOL]         assertEquals(1, throwables.length); [EOL]         assertSame(withoutCause, throwables[0]); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetThrowables_Throwable_withoutCause() { [EOL]         final Throwable[] throwables = ExceptionUtils.getThrowables(withoutCause); [EOL]         assertEquals(1, throwables.length); [EOL]         assertSame(withoutCause, throwables[0]); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetThrowables_Throwable_withoutCause() { [EOL]         final Throwable[] throwables = ExceptionUtils.getThrowables(withoutCause); [EOL]         assertEquals(1, throwables.length); [EOL]         assertSame(withoutCause, throwables[0]); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testBadStates() { [EOL]         final StopWatch watch = new StopWatch(); [EOL]         try { [EOL]             watch.stop(); [EOL]             fail("Calling stop on an unstarted StopWatch should throw an exception. "); [EOL]         } catch(final IllegalStateException ise) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             watch.stop(); [EOL]             fail("Calling stop on an unstarted StopWatch should throw an exception. "); [EOL]         } catch(final IllegalStateException ise) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             watch.suspend(); [EOL]             fail("Calling suspend on an unstarted StopWatch should throw an exception. "); [EOL]         } catch(final IllegalStateException ise) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             watch.split(); [EOL]             fail("Calling split on a non-running StopWatch should throw an exception. "); [EOL]         }
@Test(expected = NoSuchElementException.class) [EOL]     public void testResultGetInitializerUnknown() throws ConcurrentException { [EOL]         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize(); [EOL]         res.getInitializer("unknown"); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tries to query the results of an unknown child initializer from the [EOL]      * results object. This should cause an exception. [EOL]      */ [EOL]
@Test [EOL]     public void testContextedException() { [EOL]         exceptionContext = new ContextedRuntimeException(); [EOL]         final String message = exceptionContext.getMessage(); [EOL]         final String trace = ExceptionUtils.getStackTrace(exceptionContext); [EOL]         assertTrue(trace.indexOf("ContextedException")>=0); [EOL]         assertTrue(StringUtils.isEmpty(message)); [EOL]     } [EOL]  [EOL]
@Test(expected = NoSuchElementException.class) [EOL]     public void testResultGetInitializerUnknown() throws ConcurrentException { [EOL]         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize(); [EOL]         res.getInitializer("unknown"); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tries to query the results of an unknown child initializer from the [EOL]      * results object. This should cause an exception. [EOL]      */ [EOL]
@Test(expected = NoSuchElementException.class) [EOL]     public void testResultGetInitializerUnknown() throws ConcurrentException { [EOL]         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize(); [EOL]         res.getInitializer("unknown"); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tries to query the results of an unknown child initializer from the [EOL]      * results object. This should cause an exception. [EOL]      */ [EOL]
@Test [EOL]     public void testBadStates() { [EOL]         final StopWatch watch = new StopWatch(); [EOL]         try { [EOL]             watch.stop(); [EOL]             fail("Calling stop on an unstarted StopWatch should throw an exception. "); [EOL]         } catch(final IllegalStateException ise) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             watch.stop(); [EOL]             fail("Calling stop on an unstarted StopWatch should throw an exception. "); [EOL]         } catch(final IllegalStateException ise) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             watch.suspend(); [EOL]             fail("Calling suspend on an unstarted StopWatch should throw an exception. "); [EOL]         } catch(final IllegalStateException ise) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             watch.split(); [EOL]             fail("Calling split on a non-running StopWatch should throw an exception. "); [EOL]         }
@Test(expected = UnsupportedOperationException.class) [EOL]     public void testResultInitializerNamesModify() throws ConcurrentException { [EOL]         checkInitialize(); [EOL]         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer [EOL]                 .get(); [EOL]         final Iterator<String> it = res.initializerNames().iterator(); [EOL]         it.next(); [EOL]         it.remove(); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the behavior of the initializer if one of the child initializers [EOL]      * throws a runtime exception. [EOL]      */ [EOL]
@Test(expected = UnsupportedOperationException.class) [EOL]     public void testResultInitializerNamesModify() throws ConcurrentException { [EOL]         checkInitialize(); [EOL]         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer [EOL]                 .get(); [EOL]         final Iterator<String> it = res.initializerNames().iterator(); [EOL]         it.next(); [EOL]         it.remove(); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the behavior of the initializer if one of the child initializers [EOL]      * throws a runtime exception. [EOL]      */ [EOL]
@Test(expected = UnsupportedOperationException.class) [EOL]     public void testResultInitializerNamesModify() throws ConcurrentException { [EOL]         checkInitialize(); [EOL]         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer [EOL]                 .get(); [EOL]         final Iterator<String> it = res.initializerNames().iterator(); [EOL]         it.next(); [EOL]         it.remove(); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the behavior of the initializer if one of the child initializers [EOL]      * throws a runtime exception. [EOL]      */ [EOL]
@Test(expected = UnsupportedOperationException.class) [EOL]     public void testResultInitializerNamesModify() throws ConcurrentException { [EOL]         checkInitialize(); [EOL]         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer [EOL]                 .get(); [EOL]         final Iterator<String> it = res.initializerNames().iterator(); [EOL]         it.next(); [EOL]         it.remove(); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the behavior of the initializer if one of the child initializers [EOL]      * throws a runtime exception. [EOL]      */ [EOL]
