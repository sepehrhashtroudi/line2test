@Test [EOL]     public void testGetMultipleTimes() throws ConcurrentException { [EOL]         final ConcurrentInitializer<Object> initializer = createInitializer(); [EOL]         final Object obj = initializer.get(); [EOL]         for (int i = 0; i < 10; i++) { [EOL]             assertEquals("Got different object at " + i, obj, initializer.get()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether get() can be invoked from multiple threads concurrently. [EOL]      * Always the same object should be returned. [EOL]      */ [EOL]
@Test [EOL]     public void testGetMultipleTimes() throws ConcurrentException { [EOL]         final ConcurrentInitializer<Object> initializer = createInitializer(); [EOL]         final Object obj = initializer.get(); [EOL]         for (int i = 0; i < 10; i++) { [EOL]             assertEquals("Got different object at " + i, obj, initializer.get()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether get() can be invoked from multiple threads concurrently. [EOL]      * Always the same object should be returned. [EOL]      */ [EOL]
@Test [EOL]     public void testGetMultipleTimes() throws ConcurrentException { [EOL]         final ConcurrentInitializer<Object> initializer = createInitializer(); [EOL]         final Object obj = initializer.get(); [EOL]         for (int i = 0; i < 10; i++) { [EOL]             assertEquals("Got different object at " + i, obj, initializer.get()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether get() can be invoked from multiple threads concurrently. [EOL]      * Always the same object should be returned. [EOL]      */ [EOL]
@Test [EOL]     public void testGetMultipleTimes() throws ConcurrentException { [EOL]         final ConcurrentInitializer<Object> initializer = createInitializer(); [EOL]         final Object obj = initializer.get(); [EOL]         for (int i = 0; i < 10; i++) { [EOL]             assertEquals("Got different object at " + i, obj, initializer.get()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether get() can be invoked from multiple threads concurrently. [EOL]      * Always the same object should be returned. [EOL]      */ [EOL]
@Test [EOL]     public void testGetMultipleTimes() throws ConcurrentException { [EOL]         final ConcurrentInitializer<Object> initializer = createInitializer(); [EOL]         final Object obj = initializer.get(); [EOL]         for (int i = 0; i < 10; i++) { [EOL]             assertEquals("Got different object at " + i, obj, initializer.get()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether get() can be invoked from multiple threads concurrently. [EOL]      * Always the same object should be returned. [EOL]      */ [EOL]
@Test [EOL]     public void testGetMultipleTimes() throws ConcurrentException { [EOL]         final ConcurrentInitializer<Object> initializer = createInitializer(); [EOL]         final Object obj = initializer.get(); [EOL]         for (int i = 0; i < 10; i++) { [EOL]             assertEquals("Got different object at " + i, obj, initializer.get()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether get() can be invoked from multiple threads concurrently. [EOL]      * Always the same object should be returned. [EOL]      */ [EOL]
@Test [EOL]     public void testGetMultipleTimes() throws ConcurrentException { [EOL]         final ConcurrentInitializer<Object> initializer = createInitializer(); [EOL]         final Object obj = initializer.get(); [EOL]         for (int i = 0; i < 10; i++) { [EOL]             assertEquals("Got different object at " + i, obj, initializer.get()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether get() can be invoked from multiple threads concurrently. [EOL]      * Always the same object should be returned. [EOL]      */ [EOL]
@Test [EOL]     public void testGetMultipleTimes() throws ConcurrentException { [EOL]         final ConcurrentInitializer<Object> initializer = createInitializer(); [EOL]         final Object obj = initializer.get(); [EOL]         for (int i = 0; i < 10; i++) { [EOL]             assertEquals("Got different object at " + i, obj, initializer.get()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether get() can be invoked from multiple threads concurrently. [EOL]      * Always the same object should be returned. [EOL]      */ [EOL]
@Test [EOL]     public void testInclusiveBetween_withMessage() [EOL]     { [EOL]         Validate.inclusiveBetween("a", "c", "b", "Error"); [EOL]         Validate.inclusiveBetween(0, 2, 1, "Error"); [EOL]         Validate.inclusiveBetween(0, 2, 2, "Error"); [EOL]         try { [EOL]             Validate.inclusiveBetween(0, 5, 6, "Error"); [EOL]             fail("Expecting IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             assertEquals("Error", e.getMessage()); [EOL]         } [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testExclusiveBetween() [EOL]     { [EOL]         Validate.exclusiveBetween("a", "c", "b"); [EOL]         Validate.exclusiveBetween(0, 2, 1); [EOL]         try { [EOL]             Validate.exclusiveBetween(0, 5, 6); [EOL]             fail("Expecting IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             assertEquals("The value 6 is not in the specified exclusive range of 0 to 5", e.getMessage()); [EOL]         } [EOL]         try { [EOL]             Validate.exclusiveBetween(0, 5, 5); [EOL]             fail("Expecting IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             assertEquals("The value 5 is not in the specified exclusive range of 0 to 5", e.getMessage()); [EOL]         } [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testIntegerWithTransients() { [EOL]         testInteger(true); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMultiLongArray() { [EOL]         final long[][] array1 = new long[2][2]; [EOL]         final long[][] array2 = new long[2][2]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         assertTrue(new EqualsBuilder().append(array1, array1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(array1, array2).isEquals()); [EOL]         array1[1][1] = 0; [EOL]         assertTrue(!new EqualsBuilder().append(array1, array2).isEquals()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMultiBooleanArray() { [EOL]         final boolean[][] array1 = new boolean[2][2]; [EOL]         final boolean[][] array2 = new boolean[2][2]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = i == 1 || j == 1; [EOL]                 array2[i][j] = i == 1 || j == 1; [EOL]             } [EOL]         } [EOL]         assertTrue(new EqualsBuilder().append(array1, array1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(array1, array2).isEquals()); [EOL]         array1[1][1] = false; [EOL]         assertTrue(!new EqualsBuilder().append(array1, array2).isEquals()); [EOL]          [EOL]         // compare 1 dim to 2. [EOL]         final boolean[] array3 = new boolean[]{true, true}; [EOL]         assertFalse(new EqualsBuilder().append(array1, array3).isEquals()); [EOL]         assertFalse(new EqualsBuilder().append(array3, array1).isEquals()); [EOL]         assertFalse(new EqualsBuilder().append(array2, array3).isEquals()); [EOL]         assertFalse(new EqualsBuilder().append(array3, array2).isEquals()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMultiLongArray() { [EOL]         final long[][] array1 = new long[2][2]; [EOL]         final long[][] array2 = new long[2][2]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         assertTrue(new EqualsBuilder().append(array1, array1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(array1, array2).isEquals()); [EOL]         array1[1][1] = 0; [EOL]         assertTrue(!new EqualsBuilder().append(array1, array2).isEquals()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMultiLongArray() { [EOL]         final long[][] array1 = new long[2][2]; [EOL]         final long[][] array2 = new long[2][2]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         assertTrue(new EqualsBuilder().append(array1, array1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(array1, array2).isEquals()); [EOL]         array1[1][1] = 0; [EOL]         assertTrue(!new EqualsBuilder().append(array1, array2).isEquals()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMultiShortArray() { [EOL]         final short[][] array1 = new short[2][2]; [EOL]         final short[][] array2 = new short[2][2]; [EOL]         for (short i = 0; i < array1.length; ++i) { [EOL]             for (short j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = i; [EOL]                 array2[i][j] = i; [EOL]             } [EOL]         } [EOL]         assertTrue(new EqualsBuilder().append(array1, array1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(array1, array2).isEquals()); [EOL]         array1[1][1] = 0; [EOL]         assertTrue(!new EqualsBuilder().append(array1, array2).isEquals()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIntArrayHiddenByObject() { [EOL]         final int[] array1 = new int[2]; [EOL]         array1[0] = 5; [EOL]         array1[1] = 6; [EOL]         final int[] array2 = new int[2]; [EOL]         array2[0] = 5; [EOL]         array2[1] = 6; [EOL]         final Object obj1 = array1; [EOL]         final Object obj2 = array2; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, array1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, array2).isEquals()); [EOL]         array1[1] = 7; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMultiShortArray() { [EOL]         final short[][] array1 = new short[2][2]; [EOL]         final short[][] array2 = new short[2][2]; [EOL]         for (short i = 0; i < array1.length; ++i) { [EOL]             for (short j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = i; [EOL]                 array2[i][j] = i; [EOL]             } [EOL]         } [EOL]         assertTrue(new EqualsBuilder().append(array1, array1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(array1, array2).isEquals()); [EOL]         array1[1][1] = 0; [EOL]         assertTrue(!new EqualsBuilder().append(array1, array2).isEquals()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMultiShortArray() { [EOL]         final short[][] array1 = new short[2][2]; [EOL]         final short[][] array2 = new short[2][2]; [EOL]         for (short i = 0; i < array1.length; ++i) { [EOL]             for (short j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = i; [EOL]                 array2[i][j] = i; [EOL]             } [EOL]         } [EOL]         assertTrue(new EqualsBuilder().append(array1, array1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(array1, array2).isEquals()); [EOL]         array1[1][1] = 0; [EOL]         assertTrue(!new EqualsBuilder().append(array1, array2).isEquals()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testBooleanArrayHiddenByObject() { [EOL]         final boolean[] array1 = new boolean[2]; [EOL]         array1[0] = true; [EOL]         array1[1] = false; [EOL]         final boolean[] array2 = new boolean[2]; [EOL]         array2[0] = true; [EOL]         array2[1] = false; [EOL]         final Object obj1 = array1; [EOL]         final Object obj2 = array2; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, array1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, array2).isEquals()); [EOL]         array1[1] = true; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     } [EOL]      [EOL]     public static class TestACanEqualB { [EOL]         private final int a; [EOL]  [EOL]         public TestACanEqualB(final int a) { [EOL]             this.a = a; [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean equals(final Object o) { [EOL]             if (o == this) { [EOL]                 return true; [EOL]             } [EOL]             if (o instanceof TestACanEqualB) { [EOL]                 return this.a == ((TestACanEqualB) o).getA(); [EOL]             } [EOL]             if (o instanceof TestBCanEqualA) { [EOL]                 return this.a == ((TestBCanEqualA) o).getB(); [EOL]             } [EOL]             return false; [EOL]         } [EOL]  [EOL]         @Override [EOL]         public int hashCode() { [EOL]             return a; [EOL]         } [EOL]  [EOL]         public int getA() { [EOL]             return this.a; [EOL]         } [EOL]     } [EOL]  [EOL]     public static class TestBCanEqualA { [EOL]         private final int b; [EOL]  [EOL]         public TestBCanEqualA(final int b) { [EOL]             this.b = b; [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean equals(final Object o) { [EOL]             if (o == this) { [EOL]                 return true; [EOL]             } [EOL]             if (o instanceof TestACanEqualB) { [EOL]                 return this.b == ((TestACanEqualB) o).getA(); [EOL]             } [EOL]             if (o instanceof TestBCanEqualA) { [EOL]                 return this.b == ((TestBCanEqualA) o).getB(); [EOL]             } [EOL]             return false; [EOL]         } [EOL]  [EOL]         @Override [EOL]         public int hashCode() { [EOL]             return b; [EOL]         } [EOL]  [EOL]         public int getB() { [EOL]             return this.b; [EOL]         } [EOL]     } [EOL]      [EOL]     /** [EOL]      * Tests two instances of classes that can be equal and that are not "related". The two classes are not subclasses [EOL]      * of each other and do not share a parent aside from Object. [EOL]      * See http://issues.apache.org/bugzilla/show_bug.cgi?id=33069 [EOL]      */ [EOL]
@Test [EOL]     public void testCharArrayHiddenByObject() { [EOL]         final char[] array1 = new char[2]; [EOL]         array1[0] = 5; [EOL]         array1[1] = 6; [EOL]         final char[] array2 = new char[2]; [EOL]         array2[0] = 5; [EOL]         array2[1] = 6; [EOL]         final Object obj1 = array1; [EOL]         final Object obj2 = array2; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, array1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, array2).isEquals()); [EOL]         array1[1] = 7; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testBooleanArrayHiddenByObject() { [EOL]         final boolean[] array1 = new boolean[2]; [EOL]         array1[0] = true; [EOL]         array1[1] = false; [EOL]         final boolean[] array2 = new boolean[2]; [EOL]         array2[0] = true; [EOL]         array2[1] = false; [EOL]         final Object obj1 = array1; [EOL]         final Object obj2 = array2; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, array1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, array2).isEquals()); [EOL]         array1[1] = true; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     } [EOL]      [EOL]     public static class TestACanEqualB { [EOL]         private final int a; [EOL]  [EOL]         public TestACanEqualB(final int a) { [EOL]             this.a = a; [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean equals(final Object o) { [EOL]             if (o == this) { [EOL]                 return true; [EOL]             } [EOL]             if (o instanceof TestACanEqualB) { [EOL]                 return this.a == ((TestACanEqualB) o).getA(); [EOL]             } [EOL]             if (o instanceof TestBCanEqualA) { [EOL]                 return this.a == ((TestBCanEqualA) o).getB(); [EOL]             } [EOL]             return false; [EOL]         } [EOL]  [EOL]         @Override [EOL]         public int hashCode() { [EOL]             return a; [EOL]         } [EOL]  [EOL]         public int getA() { [EOL]             return this.a; [EOL]         } [EOL]     } [EOL]  [EOL]     public static class TestBCanEqualA { [EOL]         private final int b; [EOL]  [EOL]         public TestBCanEqualA(final int b) { [EOL]             this.b = b; [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean equals(final Object o) { [EOL]             if (o == this) { [EOL]                 return true; [EOL]             } [EOL]             if (o instanceof TestACanEqualB) { [EOL]                 return this.b == ((TestACanEqualB) o).getA(); [EOL]             } [EOL]             if (o instanceof TestBCanEqualA) { [EOL]                 return this.b == ((TestBCanEqualA) o).getB(); [EOL]             } [EOL]             return false; [EOL]         } [EOL]  [EOL]         @Override [EOL]         public int hashCode() { [EOL]             return b; [EOL]         } [EOL]  [EOL]         public int getB() { [EOL]             return this.b; [EOL]         } [EOL]     } [EOL]      [EOL]     /** [EOL]      * Tests two instances of classes that can be equal and that are not "related". The two classes are not subclasses [EOL]      * of each other and do not share a parent aside from Object. [EOL]      * See http://issues.apache.org/bugzilla/show_bug.cgi?id=33069 [EOL]      */ [EOL]
@Test [EOL]     public void testMultiByteArray() { [EOL]         final byte[][] array1 = new byte[2][2]; [EOL]         final byte[][] array2 = new byte[2][2]; [EOL]         for (byte i = 0; i < array1.length; ++i) { [EOL]             for (byte j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = i; [EOL]                 array2[i][j] = i; [EOL]             } [EOL]         } [EOL]         assertTrue(new EqualsBuilder().append(array1, array1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(array1, array2).isEquals()); [EOL]         array1[1][1] = 0; [EOL]         assertTrue(!new EqualsBuilder().append(array1, array2).isEquals()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testBooleanArrayHiddenByObject() { [EOL]         final boolean[] array1 = new boolean[2]; [EOL]         array1[0] = true; [EOL]         array1[1] = false; [EOL]         final boolean[] array2 = new boolean[2]; [EOL]         array2[0] = true; [EOL]         array2[1] = false; [EOL]         final Object obj1 = array1; [EOL]         final Object obj2 = array2; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, array1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, array2).isEquals()); [EOL]         array1[1] = true; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     } [EOL]      [EOL]     public static class TestACanEqualB { [EOL]         private final int a; [EOL]  [EOL]         public TestACanEqualB(final int a) { [EOL]             this.a = a; [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean equals(final Object o) { [EOL]             if (o == this) { [EOL]                 return true; [EOL]             } [EOL]             if (o instanceof TestACanEqualB) { [EOL]                 return this.a == ((TestACanEqualB) o).getA(); [EOL]             } [EOL]             if (o instanceof TestBCanEqualA) { [EOL]                 return this.a == ((TestBCanEqualA) o).getB(); [EOL]             } [EOL]             return false; [EOL]         } [EOL]  [EOL]         @Override [EOL]         public int hashCode() { [EOL]             return a; [EOL]         } [EOL]  [EOL]         public int getA() { [EOL]             return this.a; [EOL]         } [EOL]     } [EOL]  [EOL]     public static class TestBCanEqualA { [EOL]         private final int b; [EOL]  [EOL]         public TestBCanEqualA(final int b) { [EOL]             this.b = b; [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean equals(final Object o) { [EOL]             if (o == this) { [EOL]                 return true; [EOL]             } [EOL]             if (o instanceof TestACanEqualB) { [EOL]                 return this.b == ((TestACanEqualB) o).getA(); [EOL]             } [EOL]             if (o instanceof TestBCanEqualA) { [EOL]                 return this.b == ((TestBCanEqualA) o).getB(); [EOL]             } [EOL]             return false; [EOL]         } [EOL]  [EOL]         @Override [EOL]         public int hashCode() { [EOL]             return b; [EOL]         } [EOL]  [EOL]         public int getB() { [EOL]             return this.b; [EOL]         } [EOL]     } [EOL]      [EOL]     /** [EOL]      * Tests two instances of classes that can be equal and that are not "related". The two classes are not subclasses [EOL]      * of each other and do not share a parent aside from Object. [EOL]      * See http://issues.apache.org/bugzilla/show_bug.cgi?id=33069 [EOL]      */ [EOL]
@Test [EOL]     public void testMultiDoubleArray() { [EOL]         final double[][] array1 = new double[2][2]; [EOL]         final double[][] array2 = new double[2][2]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         assertTrue(new EqualsBuilder().append(array1, array1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(array1, array2).isEquals()); [EOL]         array1[1][1] = 0; [EOL]         assertTrue(!new EqualsBuilder().append(array1, array2).isEquals()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testBooleanArrayHiddenByObject() { [EOL]         final boolean[] array1 = new boolean[2]; [EOL]         array1[0] = true; [EOL]         array1[1] = false; [EOL]         final boolean[] array2 = new boolean[2]; [EOL]         array2[0] = true; [EOL]         array2[1] = false; [EOL]         final Object obj1 = array1; [EOL]         final Object obj2 = array2; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, array1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, array2).isEquals()); [EOL]         array1[1] = true; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     } [EOL]      [EOL]     public static class TestACanEqualB { [EOL]         private final int a; [EOL]  [EOL]         public TestACanEqualB(final int a) { [EOL]             this.a = a; [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean equals(final Object o) { [EOL]             if (o == this) { [EOL]                 return true; [EOL]             } [EOL]             if (o instanceof TestACanEqualB) { [EOL]                 return this.a == ((TestACanEqualB) o).getA(); [EOL]             } [EOL]             if (o instanceof TestBCanEqualA) { [EOL]                 return this.a == ((TestBCanEqualA) o).getB(); [EOL]             } [EOL]             return false; [EOL]         } [EOL]  [EOL]         @Override [EOL]         public int hashCode() { [EOL]             return a; [EOL]         } [EOL]  [EOL]         public int getA() { [EOL]             return this.a; [EOL]         } [EOL]     } [EOL]  [EOL]     public static class TestBCanEqualA { [EOL]         private final int b; [EOL]  [EOL]         public TestBCanEqualA(final int b) { [EOL]             this.b = b; [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean equals(final Object o) { [EOL]             if (o == this) { [EOL]                 return true; [EOL]             } [EOL]             if (o instanceof TestACanEqualB) { [EOL]                 return this.b == ((TestACanEqualB) o).getA(); [EOL]             } [EOL]             if (o instanceof TestBCanEqualA) { [EOL]                 return this.b == ((TestBCanEqualA) o).getB(); [EOL]             } [EOL]             return false; [EOL]         } [EOL]  [EOL]         @Override [EOL]         public int hashCode() { [EOL]             return b; [EOL]         } [EOL]  [EOL]         public int getB() { [EOL]             return this.b; [EOL]         } [EOL]     } [EOL]      [EOL]     /** [EOL]      * Tests two instances of classes that can be equal and that are not "related". The two classes are not subclasses [EOL]      * of each other and do not share a parent aside from Object. [EOL]      * See http://issues.apache.org/bugzilla/show_bug.cgi?id=33069 [EOL]      */ [EOL]
@Test [EOL]     public void testMultiFloatArray() { [EOL]         final float[][] array1 = new float[2][2]; [EOL]         final float[][] array2 = new float[2][2]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         assertTrue(new EqualsBuilder().append(array1, array1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(array1, array2).isEquals()); [EOL]         array1[1][1] = 0; [EOL]         assertTrue(!new EqualsBuilder().append(array1, array2).isEquals()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testBooleanArrayHiddenByObject() { [EOL]         final boolean[] array1 = new boolean[2]; [EOL]         array1[0] = true; [EOL]         array1[1] = false; [EOL]         final boolean[] array2 = new boolean[2]; [EOL]         array2[0] = true; [EOL]         array2[1] = false; [EOL]         final Object obj1 = array1; [EOL]         final Object obj2 = array2; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, array1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, array2).isEquals()); [EOL]         array1[1] = true; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     } [EOL]      [EOL]     public static class TestACanEqualB { [EOL]         private final int a; [EOL]  [EOL]         public TestACanEqualB(final int a) { [EOL]             this.a = a; [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean equals(final Object o) { [EOL]             if (o == this) { [EOL]                 return true; [EOL]             } [EOL]             if (o instanceof TestACanEqualB) { [EOL]                 return this.a == ((TestACanEqualB) o).getA(); [EOL]             } [EOL]             if (o instanceof TestBCanEqualA) { [EOL]                 return this.a == ((TestBCanEqualA) o).getB(); [EOL]             } [EOL]             return false; [EOL]         } [EOL]  [EOL]         @Override [EOL]         public int hashCode() { [EOL]             return a; [EOL]         } [EOL]  [EOL]         public int getA() { [EOL]             return this.a; [EOL]         } [EOL]     } [EOL]  [EOL]     public static class TestBCanEqualA { [EOL]         private final int b; [EOL]  [EOL]         public TestBCanEqualA(final int b) { [EOL]             this.b = b; [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean equals(final Object o) { [EOL]             if (o == this) { [EOL]                 return true; [EOL]             } [EOL]             if (o instanceof TestACanEqualB) { [EOL]                 return this.b == ((TestACanEqualB) o).getA(); [EOL]             } [EOL]             if (o instanceof TestBCanEqualA) { [EOL]                 return this.b == ((TestBCanEqualA) o).getB(); [EOL]             } [EOL]             return false; [EOL]         } [EOL]  [EOL]         @Override [EOL]         public int hashCode() { [EOL]             return b; [EOL]         } [EOL]  [EOL]         public int getB() { [EOL]             return this.b; [EOL]         } [EOL]     } [EOL]      [EOL]     /** [EOL]      * Tests two instances of classes that can be equal and that are not "related". The two classes are not subclasses [EOL]      * of each other and do not share a parent aside from Object. [EOL]      * See http://issues.apache.org/bugzilla/show_bug.cgi?id=33069 [EOL]      */ [EOL]
@Test [EOL]     public void testBooleanArrayHiddenByObject() { [EOL]         final boolean[] array1 = new boolean[2]; [EOL]         array1[0] = true; [EOL]         array1[1] = false; [EOL]         final boolean[] array2 = new boolean[2]; [EOL]         array2[0] = true; [EOL]         array2[1] = false; [EOL]         final Object obj1 = array1; [EOL]         final Object obj2 = array2; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, array1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, array2).isEquals()); [EOL]         array1[1] = true; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     } [EOL]      [EOL]     public static class TestACanEqualB { [EOL]         private final int a; [EOL]  [EOL]         public TestACanEqualB(final int a) { [EOL]             this.a = a; [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean equals(final Object o) { [EOL]             if (o == this) { [EOL]                 return true; [EOL]             } [EOL]             if (o instanceof TestACanEqualB) { [EOL]                 return this.a == ((TestACanEqualB) o).getA(); [EOL]             } [EOL]             if (o instanceof TestBCanEqualA) { [EOL]                 return this.a == ((TestBCanEqualA) o).getB(); [EOL]             } [EOL]             return false; [EOL]         } [EOL]  [EOL]         @Override [EOL]         public int hashCode() { [EOL]             return a; [EOL]         } [EOL]  [EOL]         public int getA() { [EOL]             return this.a; [EOL]         } [EOL]     } [EOL]  [EOL]     public static class TestBCanEqualA { [EOL]         private final int b; [EOL]  [EOL]         public TestBCanEqualA(final int b) { [EOL]             this.b = b; [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean equals(final Object o) { [EOL]             if (o == this) { [EOL]                 return true; [EOL]             } [EOL]             if (o instanceof TestACanEqualB) { [EOL]                 return this.b == ((TestACanEqualB) o).getA(); [EOL]             } [EOL]             if (o instanceof TestBCanEqualA) { [EOL]                 return this.b == ((TestBCanEqualA) o).getB(); [EOL]             } [EOL]             return false; [EOL]         } [EOL]  [EOL]         @Override [EOL]         public int hashCode() { [EOL]             return b; [EOL]         } [EOL]  [EOL]         public int getB() { [EOL]             return this.b; [EOL]         } [EOL]     } [EOL]      [EOL]     /** [EOL]      * Tests two instances of classes that can be equal and that are not "related". The two classes are not subclasses [EOL]      * of each other and do not share a parent aside from Object. [EOL]      * See http://issues.apache.org/bugzilla/show_bug.cgi?id=33069 [EOL]      */ [EOL]
@Test [EOL]     public void testObjectArrayHiddenByObject() { [EOL]         final TestObject[] array1 = new TestObject[2]; [EOL]         array1[0] = new TestObject(4); [EOL]         array1[1] = new TestObject(5); [EOL]         final TestObject[] array2 = new TestObject[2]; [EOL]         array2[0] = new TestObject(4); [EOL]         array2[1] = new TestObject(5); [EOL]         final Object obj1 = array1; [EOL]         final Object obj2 = array2; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, array1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, array2).isEquals()); [EOL]         array1[1].setA(6); [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testShortArray() { [EOL]         short[] obj1 = new short[2]; [EOL]         obj1[0] = 5; [EOL]         obj1[1] = 6; [EOL]         short[] obj2 = new short[2]; [EOL]         obj2[0] = 5; [EOL]         obj2[1] = 6; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         obj1[1] = 7; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]  [EOL]         obj2 = null; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         obj1 = null; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testShortArray() { [EOL]         short[] obj1 = new short[2]; [EOL]         obj1[0] = 5; [EOL]         obj1[1] = 6; [EOL]         short[] obj2 = new short[2]; [EOL]         obj2[0] = 5; [EOL]         obj2[1] = 6; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         obj1[1] = 7; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]  [EOL]         obj2 = null; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         obj1 = null; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testShortArray() { [EOL]         short[] obj1 = new short[2]; [EOL]         obj1[0] = 5; [EOL]         obj1[1] = 6; [EOL]         short[] obj2 = new short[2]; [EOL]         obj2[0] = 5; [EOL]         obj2[1] = 6; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         obj1[1] = 7; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]  [EOL]         obj2 = null; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         obj1 = null; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testByteArray() { [EOL]         byte[] obj1 = new byte[2]; [EOL]         obj1[0] = 5; [EOL]         obj1[1] = 6; [EOL]         byte[] obj2 = new byte[2]; [EOL]         obj2[0] = 5; [EOL]         obj2[1] = 6; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         obj1[1] = 7; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]  [EOL]         obj2 = null; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         obj1 = null; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testByteArray() { [EOL]         byte[] obj1 = new byte[2]; [EOL]         obj1[0] = 5; [EOL]         obj1[1] = 6; [EOL]         byte[] obj2 = new byte[2]; [EOL]         obj2[0] = 5; [EOL]         obj2[1] = 6; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         obj1[1] = 7; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]  [EOL]         obj2 = null; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         obj1 = null; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testByteArray() { [EOL]         byte[] obj1 = new byte[2]; [EOL]         obj1[0] = 5; [EOL]         obj1[1] = 6; [EOL]         byte[] obj2 = new byte[2]; [EOL]         obj2[0] = 5; [EOL]         obj2[1] = 6; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         obj1[1] = 7; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]  [EOL]         obj2 = null; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         obj1 = null; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMultiDoubleArray() { [EOL]         final double[][] array1 = new double[2][2]; [EOL]         final double[][] array2 = new double[2][2]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         assertTrue(new EqualsBuilder().append(array1, array1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(array1, array2).isEquals()); [EOL]         array1[1][1] = 0; [EOL]         assertTrue(!new EqualsBuilder().append(array1, array2).isEquals()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMultiDoubleArray() { [EOL]         final double[][] array1 = new double[2][2]; [EOL]         final double[][] array2 = new double[2][2]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         assertTrue(new EqualsBuilder().append(array1, array1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(array1, array2).isEquals()); [EOL]         array1[1][1] = 0; [EOL]         assertTrue(!new EqualsBuilder().append(array1, array2).isEquals()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMultiDoubleArray() { [EOL]         final double[][] array1 = new double[2][2]; [EOL]         final double[][] array2 = new double[2][2]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         assertTrue(new EqualsBuilder().append(array1, array1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(array1, array2).isEquals()); [EOL]         array1[1][1] = 0; [EOL]         assertTrue(!new EqualsBuilder().append(array1, array2).isEquals()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testBooleanArray() { [EOL]         boolean[] obj1 = new boolean[2]; [EOL]         obj1[0] = true; [EOL]         obj1[1] = false; [EOL]         boolean[] obj2 = new boolean[2]; [EOL]         obj2[0] = true; [EOL]         obj2[1] = false; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         obj1[1] = true; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]  [EOL]         obj2 = null; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         obj1 = null; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testBooleanArray() { [EOL]         boolean[] obj1 = new boolean[2]; [EOL]         obj1[0] = true; [EOL]         obj1[1] = false; [EOL]         boolean[] obj2 = new boolean[2]; [EOL]         obj2[0] = true; [EOL]         obj2[1] = false; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         obj1[1] = true; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]  [EOL]         obj2 = null; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         obj1 = null; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testBooleanArray() { [EOL]         boolean[] obj1 = new boolean[2]; [EOL]         obj1[0] = true; [EOL]         obj1[1] = false; [EOL]         boolean[] obj2 = new boolean[2]; [EOL]         obj2[0] = true; [EOL]         obj2[1] = false; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         obj1[1] = true; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]  [EOL]         obj2 = null; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         obj1 = null; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLANG805() { [EOL]         final long seed = System.currentTimeMillis(); [EOL]         assertEquals("aaa", RandomStringUtils.random(3,0,0,false,false,new char[]{'a'},new Random(seed))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testRandomStringUtils() { [EOL]         String r1 = RandomStringUtils.random(50); [EOL]         assertEquals("random(50) length", 50, r1.length()); [EOL]         String r2 = RandomStringUtils.random(50); [EOL]         assertEquals("random(50) length", 50, r2.length()); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]          [EOL]         r1 = RandomStringUtils.randomAscii(50); [EOL]         assertEquals("randomAscii(50) length", 50, r1.length()); [EOL]         for(int i = 0; i < r1.length(); i++) { [EOL]             assertTrue("char between 32 and 127", r1.charAt(i) >= 32 && r1.charAt(i) <= 127); [EOL]         }         [EOL]         r2 = RandomStringUtils.randomAscii(50); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]  [EOL]         r1 = RandomStringUtils.randomAlphabetic(50); [EOL]         assertEquals("randomAlphabetic(50)", 50, r1.length()); [EOL]         for(int i = 0; i < r1.length(); i++) { [EOL]             assertTrue("r1 contains alphabetic", Character.isLetter(r1.charAt(i)) && !Character.isDigit(r1.charAt(i))); [EOL]         } [EOL]         r2 = RandomStringUtils.randomAlphabetic(50); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]          [EOL]         r1 = RandomStringUtils.randomAlphanumeric(50); [EOL]         assertEquals("randomAlphanumeric(50)", 50, r1.length()); [EOL]         for(int i = 0; i < r1.length(); i++) { [EOL]             assertTrue("r1 contains alphanumeric", Character.isLetterOrDigit(r1.charAt(i))); [EOL]         } [EOL]         r2 = RandomStringUtils.randomAlphabetic(50); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]          [EOL]         r1 = RandomStringUtils.randomNumeric(50); [EOL]         assertEquals("randomNumeric(50)", 50, r1.length()); [EOL]         for(int i = 0; i < r1.length(); i++) { [EOL]             assertTrue("r1 contains numeric", Character.isDigit(r1.charAt(i)) && !Character.isLetter(r1.charAt(i))); [EOL]         } [EOL]         r2 = RandomStringUtils.randomNumeric(50); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]          [EOL]         String set = "abcdefg"; [EOL]         r1 = RandomStringUtils.random(50, set); [EOL]         assertEquals("random(50, \"abcdefg\")", 50, r1.length()); [EOL]         for(int i = 0; i < r1.length(); i++) { [EOL]             assertTrue("random char in set", set.indexOf(r1.charAt(i)) > -1); [EOL]         } [EOL]         r2 = RandomStringUtils.random(50, set); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]          [EOL]         r1 = RandomStringUtils.random(50, (String) null); [EOL]         assertEquals("random(50) length", 50, r1.length()); [EOL]         r2 = RandomStringUtils.random(50, (String) null); [EOL]         assertEquals("random(50) length", 50, r2.length()); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]          [EOL]         set = "stuvwxyz"; [EOL]         r1 = RandomStringUtils.random(50, set.toCharArray()); [EOL]         assertEquals("random(50, \"stuvwxyz\")", 50, r1.length()); [EOL]         for(int i = 0; i < r1.length(); i++) { [EOL]             assertTrue("random char in set", set.indexOf(r1.charAt(i)) > -1); [EOL]         } [EOL]         r2 = RandomStringUtils.random(50, set); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]          [EOL]         r1 = RandomStringUtils.random(50, (char[]) null); [EOL]         assertEquals("random(50) length", 50, r1.length()); [EOL]         r2 = RandomStringUtils.random(50, (char[]) null); [EOL]         assertEquals("random(50) length", 50, r2.length()); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]  [EOL]         final long seed = System.currentTimeMillis(); [EOL]         r1 = RandomStringUtils.random(50,0,0,true,true,null,new Random(seed)); [EOL]         r2 = RandomStringUtils.random(50,0,0,true,true,null,new Random(seed)); [EOL]         assertEquals("r1.equals(r2)", r1, r2); [EOL]  [EOL]         r1 = RandomStringUtils.random(0); [EOL]         assertEquals("random(0).equals(\"\")", "", r1); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testRandomStringUtils() { [EOL]         String r1 = RandomStringUtils.random(50); [EOL]         assertEquals("random(50) length", 50, r1.length()); [EOL]         String r2 = RandomStringUtils.random(50); [EOL]         assertEquals("random(50) length", 50, r2.length()); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]          [EOL]         r1 = RandomStringUtils.randomAscii(50); [EOL]         assertEquals("randomAscii(50) length", 50, r1.length()); [EOL]         for(int i = 0; i < r1.length(); i++) { [EOL]             assertTrue("char between 32 and 127", r1.charAt(i) >= 32 && r1.charAt(i) <= 127); [EOL]         }         [EOL]         r2 = RandomStringUtils.randomAscii(50); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]  [EOL]         r1 = RandomStringUtils.randomAlphabetic(50); [EOL]         assertEquals("randomAlphabetic(50)", 50, r1.length()); [EOL]         for(int i = 0; i < r1.length(); i++) { [EOL]             assertTrue("r1 contains alphabetic", Character.isLetter(r1.charAt(i)) && !Character.isDigit(r1.charAt(i))); [EOL]         } [EOL]         r2 = RandomStringUtils.randomAlphabetic(50); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]          [EOL]         r1 = RandomStringUtils.randomAlphanumeric(50); [EOL]         assertEquals("randomAlphanumeric(50)", 50, r1.length()); [EOL]         for(int i = 0; i < r1.length(); i++) { [EOL]             assertTrue("r1 contains alphanumeric", Character.isLetterOrDigit(r1.charAt(i))); [EOL]         } [EOL]         r2 = RandomStringUtils.randomAlphabetic(50); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]          [EOL]         r1 = RandomStringUtils.randomNumeric(50); [EOL]         assertEquals("randomNumeric(50)", 50, r1.length()); [EOL]         for(int i = 0; i < r1.length(); i++) { [EOL]             assertTrue("r1 contains numeric", Character.isDigit(r1.charAt(i)) && !Character.isLetter(r1.charAt(i))); [EOL]         } [EOL]         r2 = RandomStringUtils.randomNumeric(50); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]          [EOL]         String set = "abcdefg"; [EOL]         r1 = RandomStringUtils.random(50, set); [EOL]         assertEquals("random(50, \"abcdefg\")", 50, r1.length()); [EOL]         for(int i = 0; i < r1.length(); i++) { [EOL]             assertTrue("random char in set", set.indexOf(r1.charAt(i)) > -1); [EOL]         } [EOL]         r2 = RandomStringUtils.random(50, set); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]          [EOL]         r1 = RandomStringUtils.random(50, (String) null); [EOL]         assertEquals("random(50) length", 50, r1.length()); [EOL]         r2 = RandomStringUtils.random(50, (String) null); [EOL]         assertEquals("random(50) length", 50, r2.length()); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]          [EOL]         set = "stuvwxyz"; [EOL]         r1 = RandomStringUtils.random(50, set.toCharArray()); [EOL]         assertEquals("random(50, \"stuvwxyz\")", 50, r1.length()); [EOL]         for(int i = 0; i < r1.length(); i++) { [EOL]             assertTrue("random char in set", set.indexOf(r1.charAt(i)) > -1); [EOL]         } [EOL]         r2 = RandomStringUtils.random(50, set); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]          [EOL]         r1 = RandomStringUtils.random(50, (char[]) null); [EOL]         assertEquals("random(50) length", 50, r1.length()); [EOL]         r2 = RandomStringUtils.random(50, (char[]) null); [EOL]         assertEquals("random(50) length", 50, r2.length()); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]  [EOL]         final long seed = System.currentTimeMillis(); [EOL]         r1 = RandomStringUtils.random(50,0,0,true,true,null,new Random(seed)); [EOL]         r2 = RandomStringUtils.random(50,0,0,true,true,null,new Random(seed)); [EOL]         assertEquals("r1.equals(r2)", r1, r2); [EOL]  [EOL]         r1 = RandomStringUtils.random(0); [EOL]         assertEquals("random(0).equals(\"\")", "", r1); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testRandomStringUtils() { [EOL]         String r1 = RandomStringUtils.random(50); [EOL]         assertEquals("random(50) length", 50, r1.length()); [EOL]         String r2 = RandomStringUtils.random(50); [EOL]         assertEquals("random(50) length", 50, r2.length()); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]          [EOL]         r1 = RandomStringUtils.randomAscii(50); [EOL]         assertEquals("randomAscii(50) length", 50, r1.length()); [EOL]         for(int i = 0; i < r1.length(); i++) { [EOL]             assertTrue("char between 32 and 127", r1.charAt(i) >= 32 && r1.charAt(i) <= 127); [EOL]         }         [EOL]         r2 = RandomStringUtils.randomAscii(50); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]  [EOL]         r1 = RandomStringUtils.randomAlphabetic(50); [EOL]         assertEquals("randomAlphabetic(50)", 50, r1.length()); [EOL]         for(int i = 0; i < r1.length(); i++) { [EOL]             assertTrue("r1 contains alphabetic", Character.isLetter(r1.charAt(i)) && !Character.isDigit(r1.charAt(i))); [EOL]         } [EOL]         r2 = RandomStringUtils.randomAlphabetic(50); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]          [EOL]         r1 = RandomStringUtils.randomAlphanumeric(50); [EOL]         assertEquals("randomAlphanumeric(50)", 50, r1.length()); [EOL]         for(int i = 0; i < r1.length(); i++) { [EOL]             assertTrue("r1 contains alphanumeric", Character.isLetterOrDigit(r1.charAt(i))); [EOL]         } [EOL]         r2 = RandomStringUtils.randomAlphabetic(50); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]          [EOL]         r1 = RandomStringUtils.randomNumeric(50); [EOL]         assertEquals("randomNumeric(50)", 50, r1.length()); [EOL]         for(int i = 0; i < r1.length(); i++) { [EOL]             assertTrue("r1 contains numeric", Character.isDigit(r1.charAt(i)) && !Character.isLetter(r1.charAt(i))); [EOL]         } [EOL]         r2 = RandomStringUtils.randomNumeric(50); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]          [EOL]         String set = "abcdefg"; [EOL]         r1 = RandomStringUtils.random(50, set); [EOL]         assertEquals("random(50, \"abcdefg\")", 50, r1.length()); [EOL]         for(int i = 0; i < r1.length(); i++) { [EOL]             assertTrue("random char in set", set.indexOf(r1.charAt(i)) > -1); [EOL]         } [EOL]         r2 = RandomStringUtils.random(50, set); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]          [EOL]         r1 = RandomStringUtils.random(50, (String) null); [EOL]         assertEquals("random(50) length", 50, r1.length()); [EOL]         r2 = RandomStringUtils.random(50, (String) null); [EOL]         assertEquals("random(50) length", 50, r2.length()); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]          [EOL]         set = "stuvwxyz"; [EOL]         r1 = RandomStringUtils.random(50, set.toCharArray()); [EOL]         assertEquals("random(50, \"stuvwxyz\")", 50, r1.length()); [EOL]         for(int i = 0; i < r1.length(); i++) { [EOL]             assertTrue("random char in set", set.indexOf(r1.charAt(i)) > -1); [EOL]         } [EOL]         r2 = RandomStringUtils.random(50, set); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]          [EOL]         r1 = RandomStringUtils.random(50, (char[]) null); [EOL]         assertEquals("random(50) length", 50, r1.length()); [EOL]         r2 = RandomStringUtils.random(50, (char[]) null); [EOL]         assertEquals("random(50) length", 50, r2.length()); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]  [EOL]         final long seed = System.currentTimeMillis(); [EOL]         r1 = RandomStringUtils.random(50,0,0,true,true,null,new Random(seed)); [EOL]         r2 = RandomStringUtils.random(50,0,0,true,true,null,new Random(seed)); [EOL]         assertEquals("r1.equals(r2)", r1, r2); [EOL]  [EOL]         r1 = RandomStringUtils.random(0); [EOL]         assertEquals("random(0).equals(\"\")", "", r1); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testRandomStringUtils() { [EOL]         String r1 = RandomStringUtils.random(50); [EOL]         assertEquals("random(50) length", 50, r1.length()); [EOL]         String r2 = RandomStringUtils.random(50); [EOL]         assertEquals("random(50) length", 50, r2.length()); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]          [EOL]         r1 = RandomStringUtils.randomAscii(50); [EOL]         assertEquals("randomAscii(50) length", 50, r1.length()); [EOL]         for(int i = 0; i < r1.length(); i++) { [EOL]             assertTrue("char between 32 and 127", r1.charAt(i) >= 32 && r1.charAt(i) <= 127); [EOL]         }         [EOL]         r2 = RandomStringUtils.randomAscii(50); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]  [EOL]         r1 = RandomStringUtils.randomAlphabetic(50); [EOL]         assertEquals("randomAlphabetic(50)", 50, r1.length()); [EOL]         for(int i = 0; i < r1.length(); i++) { [EOL]             assertTrue("r1 contains alphabetic", Character.isLetter(r1.charAt(i)) && !Character.isDigit(r1.charAt(i))); [EOL]         } [EOL]         r2 = RandomStringUtils.randomAlphabetic(50); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]          [EOL]         r1 = RandomStringUtils.randomAlphanumeric(50); [EOL]         assertEquals("randomAlphanumeric(50)", 50, r1.length()); [EOL]         for(int i = 0; i < r1.length(); i++) { [EOL]             assertTrue("r1 contains alphanumeric", Character.isLetterOrDigit(r1.charAt(i))); [EOL]         } [EOL]         r2 = RandomStringUtils.randomAlphabetic(50); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]          [EOL]         r1 = RandomStringUtils.randomNumeric(50); [EOL]         assertEquals("randomNumeric(50)", 50, r1.length()); [EOL]         for(int i = 0; i < r1.length(); i++) { [EOL]             assertTrue("r1 contains numeric", Character.isDigit(r1.charAt(i)) && !Character.isLetter(r1.charAt(i))); [EOL]         } [EOL]         r2 = RandomStringUtils.randomNumeric(50); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]          [EOL]         String set = "abcdefg"; [EOL]         r1 = RandomStringUtils.random(50, set); [EOL]         assertEquals("random(50, \"abcdefg\")", 50, r1.length()); [EOL]         for(int i = 0; i < r1.length(); i++) { [EOL]             assertTrue("random char in set", set.indexOf(r1.charAt(i)) > -1); [EOL]         } [EOL]         r2 = RandomStringUtils.random(50, set); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]          [EOL]         r1 = RandomStringUtils.random(50, (String) null); [EOL]         assertEquals("random(50) length", 50, r1.length()); [EOL]         r2 = RandomStringUtils.random(50, (String) null); [EOL]         assertEquals("random(50) length", 50, r2.length()); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]          [EOL]         set = "stuvwxyz"; [EOL]         r1 = RandomStringUtils.random(50, set.toCharArray()); [EOL]         assertEquals("random(50, \"stuvwxyz\")", 50, r1.length()); [EOL]         for(int i = 0; i < r1.length(); i++) { [EOL]             assertTrue("random char in set", set.indexOf(r1.charAt(i)) > -1); [EOL]         } [EOL]         r2 = RandomStringUtils.random(50, set); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]          [EOL]         r1 = RandomStringUtils.random(50, (char[]) null); [EOL]         assertEquals("random(50) length", 50, r1.length()); [EOL]         r2 = RandomStringUtils.random(50, (char[]) null); [EOL]         assertEquals("random(50) length", 50, r2.length()); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]  [EOL]         final long seed = System.currentTimeMillis(); [EOL]         r1 = RandomStringUtils.random(50,0,0,true,true,null,new Random(seed)); [EOL]         r2 = RandomStringUtils.random(50,0,0,true,true,null,new Random(seed)); [EOL]         assertEquals("r1.equals(r2)", r1, r2); [EOL]  [EOL]         r1 = RandomStringUtils.random(0); [EOL]         assertEquals("random(0).equals(\"\")", "", r1); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testRandomStringUtils() { [EOL]         String r1 = RandomStringUtils.random(50); [EOL]         assertEquals("random(50) length", 50, r1.length()); [EOL]         String r2 = RandomStringUtils.random(50); [EOL]         assertEquals("random(50) length", 50, r2.length()); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]          [EOL]         r1 = RandomStringUtils.randomAscii(50); [EOL]         assertEquals("randomAscii(50) length", 50, r1.length()); [EOL]         for(int i = 0; i < r1.length(); i++) { [EOL]             assertTrue("char between 32 and 127", r1.charAt(i) >= 32 && r1.charAt(i) <= 127); [EOL]         }         [EOL]         r2 = RandomStringUtils.randomAscii(50); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]  [EOL]         r1 = RandomStringUtils.randomAlphabetic(50); [EOL]         assertEquals("randomAlphabetic(50)", 50, r1.length()); [EOL]         for(int i = 0; i < r1.length(); i++) { [EOL]             assertTrue("r1 contains alphabetic", Character.isLetter(r1.charAt(i)) && !Character.isDigit(r1.charAt(i))); [EOL]         } [EOL]         r2 = RandomStringUtils.randomAlphabetic(50); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]          [EOL]         r1 = RandomStringUtils.randomAlphanumeric(50); [EOL]         assertEquals("randomAlphanumeric(50)", 50, r1.length()); [EOL]         for(int i = 0; i < r1.length(); i++) { [EOL]             assertTrue("r1 contains alphanumeric", Character.isLetterOrDigit(r1.charAt(i))); [EOL]         } [EOL]         r2 = RandomStringUtils.randomAlphabetic(50); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]          [EOL]         r1 = RandomStringUtils.randomNumeric(50); [EOL]         assertEquals("randomNumeric(50)", 50, r1.length()); [EOL]         for(int i = 0; i < r1.length(); i++) { [EOL]             assertTrue("r1 contains numeric", Character.isDigit(r1.charAt(i)) && !Character.isLetter(r1.charAt(i))); [EOL]         } [EOL]         r2 = RandomStringUtils.randomNumeric(50); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]          [EOL]         String set = "abcdefg"; [EOL]         r1 = RandomStringUtils.random(50, set); [EOL]         assertEquals("random(50, \"abcdefg\")", 50, r1.length()); [EOL]         for(int i = 0; i < r1.length(); i++) { [EOL]             assertTrue("random char in set", set.indexOf(r1.charAt(i)) > -1); [EOL]         } [EOL]         r2 = RandomStringUtils.random(50, set); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]          [EOL]         r1 = RandomStringUtils.random(50, (String) null); [EOL]         assertEquals("random(50) length", 50, r1.length()); [EOL]         r2 = RandomStringUtils.random(50, (String) null); [EOL]         assertEquals("random(50) length", 50, r2.length()); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]          [EOL]         set = "stuvwxyz"; [EOL]         r1 = RandomStringUtils.random(50, set.toCharArray()); [EOL]         assertEquals("random(50, \"stuvwxyz\")", 50, r1.length()); [EOL]         for(int i = 0; i < r1.length(); i++) { [EOL]             assertTrue("random char in set", set.indexOf(r1.charAt(i)) > -1); [EOL]         } [EOL]         r2 = RandomStringUtils.random(50, set); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]          [EOL]         r1 = RandomStringUtils.random(50, (char[]) null); [EOL]         assertEquals("random(50) length", 50, r1.length()); [EOL]         r2 = RandomStringUtils.random(50, (char[]) null); [EOL]         assertEquals("random(50) length", 50, r2.length()); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]  [EOL]         final long seed = System.currentTimeMillis(); [EOL]         r1 = RandomStringUtils.random(50,0,0,true,true,null,new Random(seed)); [EOL]         r2 = RandomStringUtils.random(50,0,0,true,true,null,new Random(seed)); [EOL]         assertEquals("r1.equals(r2)", r1, r2); [EOL]  [EOL]         r1 = RandomStringUtils.random(0); [EOL]         assertEquals("random(0).equals(\"\")", "", r1); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testRandomStringUtils() { [EOL]         String r1 = RandomStringUtils.random(50); [EOL]         assertEquals("random(50) length", 50, r1.length()); [EOL]         String r2 = RandomStringUtils.random(50); [EOL]         assertEquals("random(50) length", 50, r2.length()); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]          [EOL]         r1 = RandomStringUtils.randomAscii(50); [EOL]         assertEquals("randomAscii(50) length", 50, r1.length()); [EOL]         for(int i = 0; i < r1.length(); i++) { [EOL]             assertTrue("char between 32 and 127", r1.charAt(i) >= 32 && r1.charAt(i) <= 127); [EOL]         }         [EOL]         r2 = RandomStringUtils.randomAscii(50); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]  [EOL]         r1 = RandomStringUtils.randomAlphabetic(50); [EOL]         assertEquals("randomAlphabetic(50)", 50, r1.length()); [EOL]         for(int i = 0; i < r1.length(); i++) { [EOL]             assertTrue("r1 contains alphabetic", Character.isLetter(r1.charAt(i)) && !Character.isDigit(r1.charAt(i))); [EOL]         } [EOL]         r2 = RandomStringUtils.randomAlphabetic(50); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]          [EOL]         r1 = RandomStringUtils.randomAlphanumeric(50); [EOL]         assertEquals("randomAlphanumeric(50)", 50, r1.length()); [EOL]         for(int i = 0; i < r1.length(); i++) { [EOL]             assertTrue("r1 contains alphanumeric", Character.isLetterOrDigit(r1.charAt(i))); [EOL]         } [EOL]         r2 = RandomStringUtils.randomAlphabetic(50); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]          [EOL]         r1 = RandomStringUtils.randomNumeric(50); [EOL]         assertEquals("randomNumeric(50)", 50, r1.length()); [EOL]         for(int i = 0; i < r1.length(); i++) { [EOL]             assertTrue("r1 contains numeric", Character.isDigit(r1.charAt(i)) && !Character.isLetter(r1.charAt(i))); [EOL]         } [EOL]         r2 = RandomStringUtils.randomNumeric(50); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]          [EOL]         String set = "abcdefg"; [EOL]         r1 = RandomStringUtils.random(50, set); [EOL]         assertEquals("random(50, \"abcdefg\")", 50, r1.length()); [EOL]         for(int i = 0; i < r1.length(); i++) { [EOL]             assertTrue("random char in set", set.indexOf(r1.charAt(i)) > -1); [EOL]         } [EOL]         r2 = RandomStringUtils.random(50, set); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]          [EOL]         r1 = RandomStringUtils.random(50, (String) null); [EOL]         assertEquals("random(50) length", 50, r1.length()); [EOL]         r2 = RandomStringUtils.random(50, (String) null); [EOL]         assertEquals("random(50) length", 50, r2.length()); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]          [EOL]         set = "stuvwxyz"; [EOL]         r1 = RandomStringUtils.random(50, set.toCharArray()); [EOL]         assertEquals("random(50, \"stuvwxyz\")", 50, r1.length()); [EOL]         for(int i = 0; i < r1.length(); i++) { [EOL]             assertTrue("random char in set", set.indexOf(r1.charAt(i)) > -1); [EOL]         } [EOL]         r2 = RandomStringUtils.random(50, set); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]          [EOL]         r1 = RandomStringUtils.random(50, (char[]) null); [EOL]         assertEquals("random(50) length", 50, r1.length()); [EOL]         r2 = RandomStringUtils.random(50, (char[]) null); [EOL]         assertEquals("random(50) length", 50, r2.length()); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]  [EOL]         final long seed = System.currentTimeMillis(); [EOL]         r1 = RandomStringUtils.random(50,0,0,true,true,null,new Random(seed)); [EOL]         r2 = RandomStringUtils.random(50,0,0,true,true,null,new Random(seed)); [EOL]         assertEquals("r1.equals(r2)", r1, r2); [EOL]  [EOL]         r1 = RandomStringUtils.random(0); [EOL]         assertEquals("random(0).equals(\"\")", "", r1); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testRandomStringUtils() { [EOL]         String r1 = RandomStringUtils.random(50); [EOL]         assertEquals("random(50) length", 50, r1.length()); [EOL]         String r2 = RandomStringUtils.random(50); [EOL]         assertEquals("random(50) length", 50, r2.length()); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]          [EOL]         r1 = RandomStringUtils.randomAscii(50); [EOL]         assertEquals("randomAscii(50) length", 50, r1.length()); [EOL]         for(int i = 0; i < r1.length(); i++) { [EOL]             assertTrue("char between 32 and 127", r1.charAt(i) >= 32 && r1.charAt(i) <= 127); [EOL]         }         [EOL]         r2 = RandomStringUtils.randomAscii(50); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]  [EOL]         r1 = RandomStringUtils.randomAlphabetic(50); [EOL]         assertEquals("randomAlphabetic(50)", 50, r1.length()); [EOL]         for(int i = 0; i < r1.length(); i++) { [EOL]             assertTrue("r1 contains alphabetic", Character.isLetter(r1.charAt(i)) && !Character.isDigit(r1.charAt(i))); [EOL]         } [EOL]         r2 = RandomStringUtils.randomAlphabetic(50); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]          [EOL]         r1 = RandomStringUtils.randomAlphanumeric(50); [EOL]         assertEquals("randomAlphanumeric(50)", 50, r1.length()); [EOL]         for(int i = 0; i < r1.length(); i++) { [EOL]             assertTrue("r1 contains alphanumeric", Character.isLetterOrDigit(r1.charAt(i))); [EOL]         } [EOL]         r2 = RandomStringUtils.randomAlphabetic(50); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]          [EOL]         r1 = RandomStringUtils.randomNumeric(50); [EOL]         assertEquals("randomNumeric(50)", 50, r1.length()); [EOL]         for(int i = 0; i < r1.length(); i++) { [EOL]             assertTrue("r1 contains numeric", Character.isDigit(r1.charAt(i)) && !Character.isLetter(r1.charAt(i))); [EOL]         } [EOL]         r2 = RandomStringUtils.randomNumeric(50); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]          [EOL]         String set = "abcdefg"; [EOL]         r1 = RandomStringUtils.random(50, set); [EOL]         assertEquals("random(50, \"abcdefg\")", 50, r1.length()); [EOL]         for(int i = 0; i < r1.length(); i++) { [EOL]             assertTrue("random char in set", set.indexOf(r1.charAt(i)) > -1); [EOL]         } [EOL]         r2 = RandomStringUtils.random(50, set); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]          [EOL]         r1 = RandomStringUtils.random(50, (String) null); [EOL]         assertEquals("random(50) length", 50, r1.length()); [EOL]         r2 = RandomStringUtils.random(50, (String) null); [EOL]         assertEquals("random(50) length", 50, r2.length()); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]          [EOL]         set = "stuvwxyz"; [EOL]         r1 = RandomStringUtils.random(50, set.toCharArray()); [EOL]         assertEquals("random(50, \"stuvwxyz\")", 50, r1.length()); [EOL]         for(int i = 0; i < r1.length(); i++) { [EOL]             assertTrue("random char in set", set.indexOf(r1.charAt(i)) > -1); [EOL]         } [EOL]         r2 = RandomStringUtils.random(50, set); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]          [EOL]         r1 = RandomStringUtils.random(50, (char[]) null); [EOL]         assertEquals("random(50) length", 50, r1.length()); [EOL]         r2 = RandomStringUtils.random(50, (char[]) null); [EOL]         assertEquals("random(50) length", 50, r2.length()); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]  [EOL]         final long seed = System.currentTimeMillis(); [EOL]         r1 = RandomStringUtils.random(50,0,0,true,true,null,new Random(seed)); [EOL]         r2 = RandomStringUtils.random(50,0,0,true,true,null,new Random(seed)); [EOL]         assertEquals("r1.equals(r2)", r1, r2); [EOL]  [EOL]         r1 = RandomStringUtils.random(0); [EOL]         assertEquals("random(0).equals(\"\")", "", r1); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testRandomStringUtils() { [EOL]         String r1 = RandomStringUtils.random(50); [EOL]         assertEquals("random(50) length", 50, r1.length()); [EOL]         String r2 = RandomStringUtils.random(50); [EOL]         assertEquals("random(50) length", 50, r2.length()); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]          [EOL]         r1 = RandomStringUtils.randomAscii(50); [EOL]         assertEquals("randomAscii(50) length", 50, r1.length()); [EOL]         for(int i = 0; i < r1.length(); i++) { [EOL]             assertTrue("char between 32 and 127", r1.charAt(i) >= 32 && r1.charAt(i) <= 127); [EOL]         }         [EOL]         r2 = RandomStringUtils.randomAscii(50); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]  [EOL]         r1 = RandomStringUtils.randomAlphabetic(50); [EOL]         assertEquals("randomAlphabetic(50)", 50, r1.length()); [EOL]         for(int i = 0; i < r1.length(); i++) { [EOL]             assertTrue("r1 contains alphabetic", Character.isLetter(r1.charAt(i)) && !Character.isDigit(r1.charAt(i))); [EOL]         } [EOL]         r2 = RandomStringUtils.randomAlphabetic(50); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]          [EOL]         r1 = RandomStringUtils.randomAlphanumeric(50); [EOL]         assertEquals("randomAlphanumeric(50)", 50, r1.length()); [EOL]         for(int i = 0; i < r1.length(); i++) { [EOL]             assertTrue("r1 contains alphanumeric", Character.isLetterOrDigit(r1.charAt(i))); [EOL]         } [EOL]         r2 = RandomStringUtils.randomAlphabetic(50); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]          [EOL]         r1 = RandomStringUtils.randomNumeric(50); [EOL]         assertEquals("randomNumeric(50)", 50, r1.length()); [EOL]         for(int i = 0; i < r1.length(); i++) { [EOL]             assertTrue("r1 contains numeric", Character.isDigit(r1.charAt(i)) && !Character.isLetter(r1.charAt(i))); [EOL]         } [EOL]         r2 = RandomStringUtils.randomNumeric(50); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]          [EOL]         String set = "abcdefg"; [EOL]         r1 = RandomStringUtils.random(50, set); [EOL]         assertEquals("random(50, \"abcdefg\")", 50, r1.length()); [EOL]         for(int i = 0; i < r1.length(); i++) { [EOL]             assertTrue("random char in set", set.indexOf(r1.charAt(i)) > -1); [EOL]         } [EOL]         r2 = RandomStringUtils.random(50, set); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]          [EOL]         r1 = RandomStringUtils.random(50, (String) null); [EOL]         assertEquals("random(50) length", 50, r1.length()); [EOL]         r2 = RandomStringUtils.random(50, (String) null); [EOL]         assertEquals("random(50) length", 50, r2.length()); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]          [EOL]         set = "stuvwxyz"; [EOL]         r1 = RandomStringUtils.random(50, set.toCharArray()); [EOL]         assertEquals("random(50, \"stuvwxyz\")", 50, r1.length()); [EOL]         for(int i = 0; i < r1.length(); i++) { [EOL]             assertTrue("random char in set", set.indexOf(r1.charAt(i)) > -1); [EOL]         } [EOL]         r2 = RandomStringUtils.random(50, set); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]          [EOL]         r1 = RandomStringUtils.random(50, (char[]) null); [EOL]         assertEquals("random(50) length", 50, r1.length()); [EOL]         r2 = RandomStringUtils.random(50, (char[]) null); [EOL]         assertEquals("random(50) length", 50, r2.length()); [EOL]         assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]  [EOL]         final long seed = System.currentTimeMillis(); [EOL]         r1 = RandomStringUtils.random(50,0,0,true,true,null,new Random(seed)); [EOL]         r2 = RandomStringUtils.random(50,0,0,true,true,null,new Random(seed)); [EOL]         assertEquals("r1.equals(r2)", r1, r2); [EOL]  [EOL]         r1 = RandomStringUtils.random(0); [EOL]         assertEquals("random(0).equals(\"\")", "", r1); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLang100() throws Exception { [EOL]         final int size = 5000; [EOL]         final String encoding = "UTF-8"; [EOL]         final String orig = RandomStringUtils.random(size); [EOL]         final byte[] bytes = orig.getBytes(encoding); [EOL]         final String copy = new String(bytes, encoding); [EOL]  [EOL]         // for a verbose compare: [EOL]         for (int i=0; i < orig.length() && i < copy.length(); i++) { [EOL]             final char o = orig.charAt(i); [EOL]             final char c = copy.charAt(i); [EOL]             assertEquals("differs at " + i + "(" + Integer.toHexString(new Character(o).hashCode()) + "," + [EOL]             Integer.toHexString(new Character(c).hashCode()) + ")", o, c); [EOL]         } [EOL]         // compare length also [EOL]         assertEquals(orig.length(), copy.length()); [EOL]         // just to be complete [EOL]         assertEquals(orig, copy); [EOL]     } [EOL] } [EOL]  [EOL]
@Test [EOL]     public void testExceptions() { [EOL]         final char[] DUMMY = new char[]{'a'}; // valid char array [EOL]         try { [EOL]             RandomStringUtils.random(-1); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             RandomStringUtils.random(-1, true, true); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             RandomStringUtils.random(-1, DUMMY); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             RandomStringUtils.random(1, new char[0]); // must not provide empty array => IAE [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             RandomStringUtils.random(-1, ""); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             RandomStringUtils.random(-1, (String)null); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             RandomStringUtils.random(-1, 'a', 'z', false, false); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             RandomStringUtils.random(-1, 'a', 'z', false, false, DUMMY); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             RandomStringUtils.random(-1, 'a', 'z', false, false, DUMMY, new Random()); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]     } [EOL]      [EOL]     /** [EOL]      * Make sure boundary alphanumeric characters are generated by randomAlphaNumeric [EOL]      * This test will fail randomly with probability = 6 * (61/62)**1000 ~ 5.2E-7 [EOL]      */   [EOL]
@Test [EOL]     public void testAppendSuper() { [EOL]         assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).appendSuper("Integer@8888[" + SystemUtils.LINE_SEPARATOR + "]").toString()); [EOL]         assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + "  <null>" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).appendSuper("Integer@8888[" + SystemUtils.LINE_SEPARATOR + "  <null>" + SystemUtils.LINE_SEPARATOR + "]").toString()); [EOL]          [EOL]         assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + "  a=hello" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).appendSuper("Integer@8888[" + SystemUtils.LINE_SEPARATOR + "]").append("a", "hello").toString()); [EOL]         assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + "  <null>" + SystemUtils.LINE_SEPARATOR + "  a=hello" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).appendSuper("Integer@8888[" + SystemUtils.LINE_SEPARATOR + "  <null>" + SystemUtils.LINE_SEPARATOR + "]").append("a", "hello").toString()); [EOL]         assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + "  a=hello" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).appendSuper(null).append("a", "hello").toString()); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLongArray() { [EOL]         long[] array = new long[] {1, 2, -3, 4}; [EOL]         assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(array).toString()); [EOL]         assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]         array = null; [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLongArray() { [EOL]         long[] array = new long[] {1, 2, -3, 4}; [EOL]         assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(array).toString()); [EOL]         assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]         array = null; [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testObjectArray() { [EOL]         Object[] array = new Object[] {null, base, new int[] {3, 6}}; [EOL]         assertEquals(baseStr + "[{<null>,5,{3,6}}]", new ToStringBuilder(base).append(array).toString()); [EOL]         assertEquals(baseStr + "[{<null>,5,{3,6}}]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]         array = null; [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testObjectArray() { [EOL]         Object[] array = new Object[] {null, base, new int[] {3, 6}}; [EOL]         assertEquals(baseStr + "[{<null>,5,{3,6}}]", new ToStringBuilder(base).append(array).toString()); [EOL]         assertEquals(baseStr + "[{<null>,5,{3,6}}]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]         array = null; [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testShortArrayArray() { [EOL]         short[][] array = new short[][] {{1, 2}, null, {5}}; [EOL]         assertEquals(baseStr + "[{{1,2},<null>,{5}}]", new ToStringBuilder(base).append(array).toString()); [EOL]         assertEquals(baseStr + "[{{1,2},<null>,{5}}]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]         array = null; [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testShortArrayArray() { [EOL]         short[][] array = new short[][] {{1, 2}, null, {5}}; [EOL]         assertEquals(baseStr + "[{{1,2},<null>,{5}}]", new ToStringBuilder(base).append(array).toString()); [EOL]         assertEquals(baseStr + "[{{1,2},<null>,{5}}]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]         array = null; [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testByteArrayArray() { [EOL]         byte[][] array = new byte[][] {{1, 2}, null, {5}}; [EOL]         assertEquals(baseStr + "[{{1,2},<null>,{5}}]", new ToStringBuilder(base).append(array).toString()); [EOL]         assertEquals(baseStr + "[{{1,2},<null>,{5}}]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]         array = null; [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testByteArrayArray() { [EOL]         byte[][] array = new byte[][] {{1, 2}, null, {5}}; [EOL]         assertEquals(baseStr + "[{{1,2},<null>,{5}}]", new ToStringBuilder(base).append(array).toString()); [EOL]         assertEquals(baseStr + "[{{1,2},<null>,{5}}]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]         array = null; [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReflectionDoubleArrayArray() { [EOL]         double[][] array = new double[][] { { 1.0, 2.29686 }, null, { Double.NaN } }; [EOL]         final String baseStr = this.toBaseString(array); [EOL]         assertEquals(baseStr + "[{{1.0,2.29686},<null>,{NaN}}]", ToStringBuilder.reflectionToString(array)); [EOL]         array = null; [EOL]         assertReflectionArray("<null>", array); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReflectionDoubleArrayArray() { [EOL]         double[][] array = new double[][] { { 1.0, 2.29686 }, null, { Double.NaN } }; [EOL]         final String baseStr = this.toBaseString(array); [EOL]         assertEquals(baseStr + "[{{1.0,2.29686},<null>,{NaN}}]", ToStringBuilder.reflectionToString(array)); [EOL]         array = null; [EOL]         assertReflectionArray("<null>", array); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReflectionFloatArrayArray() { [EOL]         float[][] array = new float[][] { { 1.0f, 2.29686f }, null, { Float.NaN } }; [EOL]         final String baseStr = this.toBaseString(array); [EOL]         assertEquals(baseStr + "[{{1.0,2.29686},<null>,{NaN}}]", ToStringBuilder.reflectionToString(array)); [EOL]         array = null; [EOL]         assertReflectionArray("<null>", array); [EOL]     } [EOL]  [EOL]  [EOL]
@Test [EOL]     public void testReflectionFloatArrayArray() { [EOL]         float[][] array = new float[][] { { 1.0f, 2.29686f }, null, { Float.NaN } }; [EOL]         final String baseStr = this.toBaseString(array); [EOL]         assertEquals(baseStr + "[{{1.0,2.29686},<null>,{NaN}}]", ToStringBuilder.reflectionToString(array)); [EOL]         array = null; [EOL]         assertReflectionArray("<null>", array); [EOL]     } [EOL]  [EOL]  [EOL]
@Test [EOL]     public void testBooleanArray() { [EOL]         boolean[] array = new boolean[] {true, false, false}; [EOL]         assertEquals(baseStr + "[{true,false,false}]", new ToStringBuilder(base).append(array).toString()); [EOL]         assertEquals(baseStr + "[{true,false,false}]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]         array = null; [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testBooleanArray() { [EOL]         boolean[] array = new boolean[] {true, false, false}; [EOL]         assertEquals(baseStr + "[{true,false,false}]", new ToStringBuilder(base).append(array).toString()); [EOL]         assertEquals(baseStr + "[{true,false,false}]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]         array = null; [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReflectionBooleanArray() { [EOL]         boolean[] array = new boolean[] { true, false, false }; [EOL]         final String baseStr = this.toBaseString(array); [EOL]         assertEquals(baseStr + "[{true,false,false}]", ToStringBuilder.reflectionToString(array)); [EOL]         array = null; [EOL]         assertReflectionArray("<null>", array); [EOL]     } [EOL]  [EOL]     // Reflection Array Array tests [EOL]  [EOL]
@Test [EOL]     public void testReflectionBooleanArray() { [EOL]         boolean[] array = new boolean[] { true, false, false }; [EOL]         final String baseStr = this.toBaseString(array); [EOL]         assertEquals(baseStr + "[{true,false,false}]", ToStringBuilder.reflectionToString(array)); [EOL]         array = null; [EOL]         assertReflectionArray("<null>", array); [EOL]     } [EOL]  [EOL]     // Reflection Array Array tests [EOL]  [EOL]
@Test [EOL]     public void testReflectionBooleanArray() { [EOL]         boolean[] array = new boolean[] { true, false, false }; [EOL]         final String baseStr = this.toBaseString(array); [EOL]         assertEquals(baseStr + "[{true,false,false}]", ToStringBuilder.reflectionToString(array)); [EOL]         array = null; [EOL]         assertReflectionArray("<null>", array); [EOL]     } [EOL]  [EOL]     // Reflection Array Array tests [EOL]  [EOL]
@Test [EOL]     public void testReflectionBooleanArray() { [EOL]         boolean[] array = new boolean[] { true, false, false }; [EOL]         final String baseStr = this.toBaseString(array); [EOL]         assertEquals(baseStr + "[{true,false,false}]", ToStringBuilder.reflectionToString(array)); [EOL]         array = null; [EOL]         assertReflectionArray("<null>", array); [EOL]     } [EOL]  [EOL]     // Reflection Array Array tests [EOL]  [EOL]
@Test [EOL]     public void testReflectionBooleanArray() { [EOL]         boolean[] array = new boolean[] { true, false, false }; [EOL]         final String baseStr = this.toBaseString(array); [EOL]         assertEquals(baseStr + "[{true,false,false}]", ToStringBuilder.reflectionToString(array)); [EOL]         array = null; [EOL]         assertReflectionArray("<null>", array); [EOL]     } [EOL]  [EOL]     // Reflection Array Array tests [EOL]  [EOL]
@Test [EOL]     public void testReflectionFloatArrayArray() { [EOL]         float[][] array = new float[][] { { 1.0f, 2.29686f }, null, { Float.NaN } }; [EOL]         final String baseStr = this.toBaseString(array); [EOL]         assertEquals(baseStr + "[{{1.0,2.29686},<null>,{NaN}}]", ToStringBuilder.reflectionToString(array)); [EOL]         array = null; [EOL]         assertReflectionArray("<null>", array); [EOL]     } [EOL]  [EOL]  [EOL]
@Test [EOL]     public void testReflectionBooleanArray() { [EOL]         boolean[] array = new boolean[] { true, false, false }; [EOL]         final String baseStr = this.toBaseString(array); [EOL]         assertEquals(baseStr + "[{true,false,false}]", ToStringBuilder.reflectionToString(array)); [EOL]         array = null; [EOL]         assertReflectionArray("<null>", array); [EOL]     } [EOL]  [EOL]     // Reflection Array Array tests [EOL]  [EOL]
@Test [EOL]     public void testReflectionBooleanArray() { [EOL]         boolean[] array = new boolean[] { true, false, false }; [EOL]         final String baseStr = this.toBaseString(array); [EOL]         assertEquals(baseStr + "[{true,false,false}]", ToStringBuilder.reflectionToString(array)); [EOL]         array = null; [EOL]         assertReflectionArray("<null>", array); [EOL]     } [EOL]  [EOL]     // Reflection Array Array tests [EOL]  [EOL]
@Test [EOL]     public void testFloatArray() { [EOL]         float[] array = new float[] {1.0f, 2.9876f, -3.00001f, 4.3f}; [EOL]         assertEquals(baseStr + "[{1.0,2.9876,-3.00001,4.3}]", new ToStringBuilder(base).append(array).toString()); [EOL]         assertEquals(baseStr + "[{1.0,2.9876,-3.00001,4.3}]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]         array = null; [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSetSizeStartText() { [EOL]         final ToStringStyle style = new ToStringStyleImpl(); [EOL]         style.setSizeStartText(null); [EOL]         assertEquals("", style.getSizeStartText()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [EOL]         final Type[] types = method.getGenericParameterTypes(); [EOL] //        list0 = list0; [EOL]         delegateBooleanAssertion(types, 0, 0, true); [EOL]         list1 = list0; [EOL]         delegateBooleanAssertion(types, 0, 1, true); [EOL]         list0 = list1; [EOL]         delegateBooleanAssertion(types, 1, 0, true); [EOL]         list2 = list0; [EOL]         delegateBooleanAssertion(types, 0, 2, true); [EOL]         list0 = list2; [EOL]         delegateBooleanAssertion(types, 2, 0, true); [EOL]         list3 = list0; [EOL]         delegateBooleanAssertion(types, 0, 3, true); [EOL]         list0 = list3; [EOL]         delegateBooleanAssertion(types, 3, 0, true); [EOL]         list4 = list0; [EOL]         delegateBooleanAssertion(types, 0, 4, true); [EOL]         list0 = list4; [EOL]         delegateBooleanAssertion(types, 4, 0, true); [EOL]         list5 = list0; [EOL]         delegateBooleanAssertion(types, 0, 5, true); [EOL]         list0 = list5; [EOL]         delegateBooleanAssertion(types, 5, 0, true); [EOL]         list6 = list0; [EOL]         delegateBooleanAssertion(types, 0, 6, true); [EOL]         list0 = list6; [EOL]         delegateBooleanAssertion(types, 6, 0, true); [EOL] //        list1 = list1; [EOL]         delegateBooleanAssertion(types, 1, 1, true); [EOL]         list2 = list1; [EOL]         delegateBooleanAssertion(types, 1, 2, true); [EOL]         list1 = (List<Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 1, false); [EOL]         list3 = list1; [EOL]         delegateBooleanAssertion(types, 1, 3, true); [EOL]         list1 = (List<Object>) list3; [EOL]         delegateBooleanAssertion(types, 3, 1, false); [EOL]         // list4 = list1; [EOL]         delegateBooleanAssertion(types, 1, 4, false); [EOL]         // list1 = list4; [EOL]         delegateBooleanAssertion(types, 4, 1, false); [EOL]         // list5 = list1; [EOL]         delegateBooleanAssertion(types, 1, 5, false); [EOL]         // list1 = list5; [EOL]         delegateBooleanAssertion(types, 5, 1, false); [EOL]         list6 = list1; [EOL]         delegateBooleanAssertion(types, 1, 6, true); [EOL]         list1 = (List<Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 1, false); [EOL] //        list2 = list2; [EOL]         delegateBooleanAssertion(types, 2, 2, true); [EOL]         list2 = list3; [EOL]         delegateBooleanAssertion(types, 2, 3, false); [EOL]         list2 = list4; [EOL]         delegateBooleanAssertion(types, 3, 2, true); [EOL]         list3 = (List<? super Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 4, false); [EOL]         list2 = list5; [EOL]         delegateBooleanAssertion(types, 4, 2, true); [EOL]         list4 = (List<String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 5, false); [EOL]         list2 = list6; [EOL]         delegateBooleanAssertion(types, 5, 2, true); [EOL]         list5 = (List<? extends String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 6, false); [EOL] //        list3 = list3; [EOL]         delegateBooleanAssertion(types, 6, 2, true); [EOL]         list6 = (List<? super String>) list2; [EOL]         delegateBooleanAssertion(types, 3, 3, true); [EOL]         // list4 = list3; [EOL]         delegateBooleanAssertion(types, 3, 4, false); [EOL]         // list3 = list4; [EOL]         delegateBooleanAssertion(types, 4, 3, false); [EOL]         // list5 = list3; [EOL]         delegateBooleanAssertion(types, 3, 5, false); [EOL]         // list3 = list5; [EOL]         delegateBooleanAssertion(types, 5, 3, false); [EOL]         list6 = list3; [EOL]         delegateBooleanAssertion(types, 3, 6, true); [EOL]         list3 = (List<? super Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 3, false); [EOL] //        list4 = list4; [EOL]         delegateBooleanAssertion(types, 4, 4, true); [EOL]         list5 = list4; [EOL]         delegateBooleanAssertion(types, 4, 5, true); [EOL]         list4 = (List<String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 4, false); [EOL]         list6 = list4; [EOL]         delegateBooleanAssertion(types, 4, 6, true); [EOL]         list4 = (List<String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 4, false); [EOL] //        list5 = list5; [EOL]         delegateBooleanAssertion(types, 5, 5, true); [EOL]         list6 = (List<? super String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 6, false); [EOL]         list5 = (List<? extends String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 5, false); [EOL] //        list6 = list6; [EOL]         delegateBooleanAssertion(types, 6, 6, true); [EOL]  [EOL] //        list7 = list7; [EOL]         delegateBooleanAssertion(types, 7, 7, true); [EOL]         list8 = list7; [EOL]         delegateBooleanAssertion(types, 7, 8, true); [EOL]         list7 = list8; [EOL]         delegateBooleanAssertion(types, 8, 7, true); [EOL]         list9 = list7; [EOL]         delegateBooleanAssertion(types, 7, 9, true); [EOL]         list7 = list9; [EOL]         delegateBooleanAssertion(types, 9, 7, true); [EOL]         list10 = list7; [EOL]         delegateBooleanAssertion(types, 7, 10, true); [EOL]         list7 = list10; [EOL]         delegateBooleanAssertion(types, 10, 7, true); [EOL]         list11 = list7; [EOL]         delegateBooleanAssertion(types, 7, 11, true); [EOL]         list7 = list11; [EOL]         delegateBooleanAssertion(types, 11, 7, true); [EOL]         list12 = list7; [EOL]         delegateBooleanAssertion(types, 7, 12, true); [EOL]         list7 = list12; [EOL]         delegateBooleanAssertion(types, 12, 7, true); [EOL]         list13 = list7; [EOL]         delegateBooleanAssertion(types, 7, 13, true); [EOL]         list7 = list13; [EOL]         delegateBooleanAssertion(types, 13, 7, true); [EOL] //        list8 = list8; [EOL]         delegateBooleanAssertion(types, 8, 8, true); [EOL]         list9 = list8; [EOL]         delegateBooleanAssertion(types, 8, 9, true); [EOL]         list8 = (List<Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 8, false); [EOL]         list10 = list8; [EOL]         delegateBooleanAssertion(types, 8, 10, true); [EOL]         list8 = (List<Object>[]) list10; // NOTE cast is required by Sun Java, but not by Eclipse [EOL]         delegateBooleanAssertion(types, 10, 8, false); [EOL]         // list11 = list8; [EOL]         delegateBooleanAssertion(types, 8, 11, false); [EOL]         // list8 = list11; [EOL]         delegateBooleanAssertion(types, 11, 8, false); [EOL]         // list12 = list8; [EOL]         delegateBooleanAssertion(types, 8, 12, false); [EOL]         // list8 = list12; [EOL]         delegateBooleanAssertion(types, 12, 8, false); [EOL]         list13 = list8; [EOL]         delegateBooleanAssertion(types, 8, 13, true); [EOL]         list8 = (List<Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 8, false); [EOL] //        list9 = list9; [EOL]         delegateBooleanAssertion(types, 9, 9, true); [EOL]         list10 = (List<? super Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 10, false); [EOL]         list9 = list10; [EOL]         delegateBooleanAssertion(types, 10, 9, true); [EOL]         list11 = (List<String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 11, false); [EOL]         list9 = list11; [EOL]         delegateBooleanAssertion(types, 11, 9, true); [EOL]         list12 = (List<? extends String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 12, false); [EOL]         list9 = list12; [EOL]         delegateBooleanAssertion(types, 12, 9, true); [EOL]         list13 = (List<? super String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 13, false); [EOL]         list9 = list13; [EOL]         delegateBooleanAssertion(types, 13, 9, true); [EOL] //        list10 = list10; [EOL]         delegateBooleanAssertion(types, 10, 10, true); [EOL]         // list11 = list10; [EOL]         delegateBooleanAssertion(types, 10, 11, false); [EOL]         // list10 = list11; [EOL]         delegateBooleanAssertion(types, 11, 10, false); [EOL]         // list12 = list10; [EOL]         delegateBooleanAssertion(types, 10, 12, false); [EOL]         // list10 = list12; [EOL]         delegateBooleanAssertion(types, 12, 10, false); [EOL]         list13 = list10; [EOL]         delegateBooleanAssertion(types, 10, 13, true); [EOL]         list10 = (List<? super Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 10, false); [EOL] //        list11 = list11; [EOL]         delegateBooleanAssertion(types, 11, 11, true); [EOL]         list12 = list11; [EOL]         delegateBooleanAssertion(types, 11, 12, true); [EOL]         list11 = (List<String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 11, false); [EOL]         list13 = list11; [EOL]         delegateBooleanAssertion(types, 11, 13, true); [EOL]         list11 = (List<String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 11, false); [EOL] //        list12 = list12; [EOL]         delegateBooleanAssertion(types, 12, 12, true); [EOL]         list13 = (List<? super String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 13, false); [EOL]         list12 = (List<? extends String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 12, false); [EOL] //        list13 = list13; [EOL]         delegateBooleanAssertion(types, 13, 13, true); [EOL]         final Type disType = getClass().getField("dis").getGenericType(); [EOL]         // Reporter.log( ( ( ParameterizedType ) disType [EOL]         // ).getOwnerType().getClass().toString() ); [EOL]         final Type datType = getClass().getField("dat").getGenericType(); [EOL]         final Type daType = getClass().getField("da").getGenericType(); [EOL]         final Type uhderType = getClass().getField("uhder").getGenericType(); [EOL]         final Type dingType = getClass().getField("ding").getGenericType(); [EOL]         final Type testerType = getClass().getField("tester").getGenericType(); [EOL]         final Type tester2Type = getClass().getField("tester2").getGenericType(); [EOL]         final Type dat2Type = getClass().getField("dat2").getGenericType(); [EOL]         final Type dat3Type = getClass().getField("dat3").getGenericType(); [EOL]         dis = dat; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(datType, disType)); [EOL]         // dis = da; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(daType, disType)); [EOL]         dis = uhder; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(uhderType, disType)); [EOL]         dis = ding; [EOL]         Assert.assertFalse(String.format("type %s not assignable to %s!", dingType, disType), [EOL]                 TypeUtils.isAssignable(dingType, disType)); [EOL]         dis = tester; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(testerType, disType)); [EOL]         // dis = tester2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(tester2Type, disType)); [EOL]         // dat = dat2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat2Type, datType)); [EOL]         // dat2 = dat; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(datType, dat2Type)); [EOL]         // dat = dat3; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat3Type, datType)); [EOL]         final char ch = 0; [EOL]         final boolean bo = false; [EOL]         final byte by = 0; [EOL]         final short sh = 0; [EOL]         int in = 0; [EOL]         long lo = 0; [EOL]         final float fl = 0; [EOL]         double du = 0; [EOL]         du = ch; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(char.class, double.class)); [EOL]         du = by; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(byte.class, double.class)); [EOL]         du = sh; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(short.class, double.class)); [EOL]         du = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, double.class)); [EOL]         du = lo; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(long.class, double.class)); [EOL]         du = fl; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(float.class, double.class)); [EOL]         lo = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, long.class)); [EOL]         lo = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, long.class)); [EOL]         // Long lngW = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, Long.class)); [EOL]         // lngW = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, Long.class)); [EOL]         in = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, int.class)); [EOL]         final Integer inte = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Integer.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Number.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Object.class)); [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, intComparableType)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Comparable.class)); [EOL]         final Serializable ser = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Serializable.class)); [EOL]         final Type longComparableType = getClass().getField("longComparable").getGenericType(); [EOL]         // longComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, longComparableType)); [EOL]         // longComparable = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, longComparableType)); [EOL]         // int[] ia; [EOL]         // long[] la = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, long[].class)); [EOL]         final Integer[] ia = null; [EOL]         final Type caType = getClass().getField("intWildcardComparable").getGenericType(); [EOL]         intWildcardComparable = ia; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, caType)); [EOL]         // int[] ina = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer[].class, int[].class)); [EOL]         final int[] ina = null; [EOL]         Object[] oa; [EOL]         // oa = ina; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, Object[].class)); [EOL]         oa = new Integer[0]; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, Object[].class)); [EOL]         final Type bClassType = AClass.class.getField("bClass").getGenericType(); [EOL]         final Type cClassType = AClass.class.getField("cClass").getGenericType(); [EOL]         final Type dClassType = AClass.class.getField("dClass").getGenericType(); [EOL]         final Type eClassType = AClass.class.getField("eClass").getGenericType(); [EOL]         final Type fClassType = AClass.class.getField("fClass").getGenericType(); [EOL]         final AClass aClass = new AClass(new AAClass<String>()); [EOL]         aClass.bClass = aClass.cClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(cClassType, bClassType)); [EOL]         aClass.bClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, bClassType)); [EOL]         aClass.bClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, bClassType)); [EOL]         aClass.bClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, bClassType)); [EOL]         aClass.cClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, cClassType)); [EOL]         aClass.cClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, cClassType)); [EOL]         aClass.cClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, cClassType)); [EOL]         aClass.dClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, dClassType)); [EOL]         aClass.dClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, dClassType)); [EOL]         aClass.eClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, eClassType)); [EOL]     } [EOL]  [EOL]     public void delegateBooleanAssertion(final Type[] types, final int i2, final int i1, final boolean expected) { [EOL]         final Type type1 = types[i1]; [EOL]         final Type type2 = types[i2]; [EOL]         final boolean isAssignable = TypeUtils.isAssignable(type2, type1); [EOL]  [EOL]         if (expected) { [EOL]             Assert.assertTrue("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } else { [EOL]             Assert.assertFalse("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } [EOL]     } [EOL]  [EOL]     @SuppressWarnings("boxing") // boxing is deliberate here [EOL]
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [EOL]         final Type[] types = method.getGenericParameterTypes(); [EOL] //        list0 = list0; [EOL]         delegateBooleanAssertion(types, 0, 0, true); [EOL]         list1 = list0; [EOL]         delegateBooleanAssertion(types, 0, 1, true); [EOL]         list0 = list1; [EOL]         delegateBooleanAssertion(types, 1, 0, true); [EOL]         list2 = list0; [EOL]         delegateBooleanAssertion(types, 0, 2, true); [EOL]         list0 = list2; [EOL]         delegateBooleanAssertion(types, 2, 0, true); [EOL]         list3 = list0; [EOL]         delegateBooleanAssertion(types, 0, 3, true); [EOL]         list0 = list3; [EOL]         delegateBooleanAssertion(types, 3, 0, true); [EOL]         list4 = list0; [EOL]         delegateBooleanAssertion(types, 0, 4, true); [EOL]         list0 = list4; [EOL]         delegateBooleanAssertion(types, 4, 0, true); [EOL]         list5 = list0; [EOL]         delegateBooleanAssertion(types, 0, 5, true); [EOL]         list0 = list5; [EOL]         delegateBooleanAssertion(types, 5, 0, true); [EOL]         list6 = list0; [EOL]         delegateBooleanAssertion(types, 0, 6, true); [EOL]         list0 = list6; [EOL]         delegateBooleanAssertion(types, 6, 0, true); [EOL] //        list1 = list1; [EOL]         delegateBooleanAssertion(types, 1, 1, true); [EOL]         list2 = list1; [EOL]         delegateBooleanAssertion(types, 1, 2, true); [EOL]         list1 = (List<Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 1, false); [EOL]         list3 = list1; [EOL]         delegateBooleanAssertion(types, 1, 3, true); [EOL]         list1 = (List<Object>) list3; [EOL]         delegateBooleanAssertion(types, 3, 1, false); [EOL]         // list4 = list1; [EOL]         delegateBooleanAssertion(types, 1, 4, false); [EOL]         // list1 = list4; [EOL]         delegateBooleanAssertion(types, 4, 1, false); [EOL]         // list5 = list1; [EOL]         delegateBooleanAssertion(types, 1, 5, false); [EOL]         // list1 = list5; [EOL]         delegateBooleanAssertion(types, 5, 1, false); [EOL]         list6 = list1; [EOL]         delegateBooleanAssertion(types, 1, 6, true); [EOL]         list1 = (List<Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 1, false); [EOL] //        list2 = list2; [EOL]         delegateBooleanAssertion(types, 2, 2, true); [EOL]         list2 = list3; [EOL]         delegateBooleanAssertion(types, 2, 3, false); [EOL]         list2 = list4; [EOL]         delegateBooleanAssertion(types, 3, 2, true); [EOL]         list3 = (List<? super Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 4, false); [EOL]         list2 = list5; [EOL]         delegateBooleanAssertion(types, 4, 2, true); [EOL]         list4 = (List<String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 5, false); [EOL]         list2 = list6; [EOL]         delegateBooleanAssertion(types, 5, 2, true); [EOL]         list5 = (List<? extends String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 6, false); [EOL] //        list3 = list3; [EOL]         delegateBooleanAssertion(types, 6, 2, true); [EOL]         list6 = (List<? super String>) list2; [EOL]         delegateBooleanAssertion(types, 3, 3, true); [EOL]         // list4 = list3; [EOL]         delegateBooleanAssertion(types, 3, 4, false); [EOL]         // list3 = list4; [EOL]         delegateBooleanAssertion(types, 4, 3, false); [EOL]         // list5 = list3; [EOL]         delegateBooleanAssertion(types, 3, 5, false); [EOL]         // list3 = list5; [EOL]         delegateBooleanAssertion(types, 5, 3, false); [EOL]         list6 = list3; [EOL]         delegateBooleanAssertion(types, 3, 6, true); [EOL]         list3 = (List<? super Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 3, false); [EOL] //        list4 = list4; [EOL]         delegateBooleanAssertion(types, 4, 4, true); [EOL]         list5 = list4; [EOL]         delegateBooleanAssertion(types, 4, 5, true); [EOL]         list4 = (List<String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 4, false); [EOL]         list6 = list4; [EOL]         delegateBooleanAssertion(types, 4, 6, true); [EOL]         list4 = (List<String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 4, false); [EOL] //        list5 = list5; [EOL]         delegateBooleanAssertion(types, 5, 5, true); [EOL]         list6 = (List<? super String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 6, false); [EOL]         list5 = (List<? extends String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 5, false); [EOL] //        list6 = list6; [EOL]         delegateBooleanAssertion(types, 6, 6, true); [EOL]  [EOL] //        list7 = list7; [EOL]         delegateBooleanAssertion(types, 7, 7, true); [EOL]         list8 = list7; [EOL]         delegateBooleanAssertion(types, 7, 8, true); [EOL]         list7 = list8; [EOL]         delegateBooleanAssertion(types, 8, 7, true); [EOL]         list9 = list7; [EOL]         delegateBooleanAssertion(types, 7, 9, true); [EOL]         list7 = list9; [EOL]         delegateBooleanAssertion(types, 9, 7, true); [EOL]         list10 = list7; [EOL]         delegateBooleanAssertion(types, 7, 10, true); [EOL]         list7 = list10; [EOL]         delegateBooleanAssertion(types, 10, 7, true); [EOL]         list11 = list7; [EOL]         delegateBooleanAssertion(types, 7, 11, true); [EOL]         list7 = list11; [EOL]         delegateBooleanAssertion(types, 11, 7, true); [EOL]         list12 = list7; [EOL]         delegateBooleanAssertion(types, 7, 12, true); [EOL]         list7 = list12; [EOL]         delegateBooleanAssertion(types, 12, 7, true); [EOL]         list13 = list7; [EOL]         delegateBooleanAssertion(types, 7, 13, true); [EOL]         list7 = list13; [EOL]         delegateBooleanAssertion(types, 13, 7, true); [EOL] //        list8 = list8; [EOL]         delegateBooleanAssertion(types, 8, 8, true); [EOL]         list9 = list8; [EOL]         delegateBooleanAssertion(types, 8, 9, true); [EOL]         list8 = (List<Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 8, false); [EOL]         list10 = list8; [EOL]         delegateBooleanAssertion(types, 8, 10, true); [EOL]         list8 = (List<Object>[]) list10; // NOTE cast is required by Sun Java, but not by Eclipse [EOL]         delegateBooleanAssertion(types, 10, 8, false); [EOL]         // list11 = list8; [EOL]         delegateBooleanAssertion(types, 8, 11, false); [EOL]         // list8 = list11; [EOL]         delegateBooleanAssertion(types, 11, 8, false); [EOL]         // list12 = list8; [EOL]         delegateBooleanAssertion(types, 8, 12, false); [EOL]         // list8 = list12; [EOL]         delegateBooleanAssertion(types, 12, 8, false); [EOL]         list13 = list8; [EOL]         delegateBooleanAssertion(types, 8, 13, true); [EOL]         list8 = (List<Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 8, false); [EOL] //        list9 = list9; [EOL]         delegateBooleanAssertion(types, 9, 9, true); [EOL]         list10 = (List<? super Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 10, false); [EOL]         list9 = list10; [EOL]         delegateBooleanAssertion(types, 10, 9, true); [EOL]         list11 = (List<String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 11, false); [EOL]         list9 = list11; [EOL]         delegateBooleanAssertion(types, 11, 9, true); [EOL]         list12 = (List<? extends String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 12, false); [EOL]         list9 = list12; [EOL]         delegateBooleanAssertion(types, 12, 9, true); [EOL]         list13 = (List<? super String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 13, false); [EOL]         list9 = list13; [EOL]         delegateBooleanAssertion(types, 13, 9, true); [EOL] //        list10 = list10; [EOL]         delegateBooleanAssertion(types, 10, 10, true); [EOL]         // list11 = list10; [EOL]         delegateBooleanAssertion(types, 10, 11, false); [EOL]         // list10 = list11; [EOL]         delegateBooleanAssertion(types, 11, 10, false); [EOL]         // list12 = list10; [EOL]         delegateBooleanAssertion(types, 10, 12, false); [EOL]         // list10 = list12; [EOL]         delegateBooleanAssertion(types, 12, 10, false); [EOL]         list13 = list10; [EOL]         delegateBooleanAssertion(types, 10, 13, true); [EOL]         list10 = (List<? super Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 10, false); [EOL] //        list11 = list11; [EOL]         delegateBooleanAssertion(types, 11, 11, true); [EOL]         list12 = list11; [EOL]         delegateBooleanAssertion(types, 11, 12, true); [EOL]         list11 = (List<String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 11, false); [EOL]         list13 = list11; [EOL]         delegateBooleanAssertion(types, 11, 13, true); [EOL]         list11 = (List<String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 11, false); [EOL] //        list12 = list12; [EOL]         delegateBooleanAssertion(types, 12, 12, true); [EOL]         list13 = (List<? super String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 13, false); [EOL]         list12 = (List<? extends String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 12, false); [EOL] //        list13 = list13; [EOL]         delegateBooleanAssertion(types, 13, 13, true); [EOL]         final Type disType = getClass().getField("dis").getGenericType(); [EOL]         // Reporter.log( ( ( ParameterizedType ) disType [EOL]         // ).getOwnerType().getClass().toString() ); [EOL]         final Type datType = getClass().getField("dat").getGenericType(); [EOL]         final Type daType = getClass().getField("da").getGenericType(); [EOL]         final Type uhderType = getClass().getField("uhder").getGenericType(); [EOL]         final Type dingType = getClass().getField("ding").getGenericType(); [EOL]         final Type testerType = getClass().getField("tester").getGenericType(); [EOL]         final Type tester2Type = getClass().getField("tester2").getGenericType(); [EOL]         final Type dat2Type = getClass().getField("dat2").getGenericType(); [EOL]         final Type dat3Type = getClass().getField("dat3").getGenericType(); [EOL]         dis = dat; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(datType, disType)); [EOL]         // dis = da; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(daType, disType)); [EOL]         dis = uhder; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(uhderType, disType)); [EOL]         dis = ding; [EOL]         Assert.assertFalse(String.format("type %s not assignable to %s!", dingType, disType), [EOL]                 TypeUtils.isAssignable(dingType, disType)); [EOL]         dis = tester; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(testerType, disType)); [EOL]         // dis = tester2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(tester2Type, disType)); [EOL]         // dat = dat2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat2Type, datType)); [EOL]         // dat2 = dat; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(datType, dat2Type)); [EOL]         // dat = dat3; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat3Type, datType)); [EOL]         final char ch = 0; [EOL]         final boolean bo = false; [EOL]         final byte by = 0; [EOL]         final short sh = 0; [EOL]         int in = 0; [EOL]         long lo = 0; [EOL]         final float fl = 0; [EOL]         double du = 0; [EOL]         du = ch; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(char.class, double.class)); [EOL]         du = by; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(byte.class, double.class)); [EOL]         du = sh; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(short.class, double.class)); [EOL]         du = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, double.class)); [EOL]         du = lo; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(long.class, double.class)); [EOL]         du = fl; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(float.class, double.class)); [EOL]         lo = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, long.class)); [EOL]         lo = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, long.class)); [EOL]         // Long lngW = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, Long.class)); [EOL]         // lngW = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, Long.class)); [EOL]         in = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, int.class)); [EOL]         final Integer inte = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Integer.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Number.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Object.class)); [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, intComparableType)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Comparable.class)); [EOL]         final Serializable ser = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Serializable.class)); [EOL]         final Type longComparableType = getClass().getField("longComparable").getGenericType(); [EOL]         // longComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, longComparableType)); [EOL]         // longComparable = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, longComparableType)); [EOL]         // int[] ia; [EOL]         // long[] la = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, long[].class)); [EOL]         final Integer[] ia = null; [EOL]         final Type caType = getClass().getField("intWildcardComparable").getGenericType(); [EOL]         intWildcardComparable = ia; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, caType)); [EOL]         // int[] ina = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer[].class, int[].class)); [EOL]         final int[] ina = null; [EOL]         Object[] oa; [EOL]         // oa = ina; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, Object[].class)); [EOL]         oa = new Integer[0]; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, Object[].class)); [EOL]         final Type bClassType = AClass.class.getField("bClass").getGenericType(); [EOL]         final Type cClassType = AClass.class.getField("cClass").getGenericType(); [EOL]         final Type dClassType = AClass.class.getField("dClass").getGenericType(); [EOL]         final Type eClassType = AClass.class.getField("eClass").getGenericType(); [EOL]         final Type fClassType = AClass.class.getField("fClass").getGenericType(); [EOL]         final AClass aClass = new AClass(new AAClass<String>()); [EOL]         aClass.bClass = aClass.cClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(cClassType, bClassType)); [EOL]         aClass.bClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, bClassType)); [EOL]         aClass.bClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, bClassType)); [EOL]         aClass.bClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, bClassType)); [EOL]         aClass.cClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, cClassType)); [EOL]         aClass.cClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, cClassType)); [EOL]         aClass.cClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, cClassType)); [EOL]         aClass.dClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, dClassType)); [EOL]         aClass.dClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, dClassType)); [EOL]         aClass.eClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, eClassType)); [EOL]     } [EOL]  [EOL]     public void delegateBooleanAssertion(final Type[] types, final int i2, final int i1, final boolean expected) { [EOL]         final Type type1 = types[i1]; [EOL]         final Type type2 = types[i2]; [EOL]         final boolean isAssignable = TypeUtils.isAssignable(type2, type1); [EOL]  [EOL]         if (expected) { [EOL]             Assert.assertTrue("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } else { [EOL]             Assert.assertFalse("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } [EOL]     } [EOL]  [EOL]     @SuppressWarnings("boxing") // boxing is deliberate here [EOL]
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [EOL]         final Type[] types = method.getGenericParameterTypes(); [EOL] //        list0 = list0; [EOL]         delegateBooleanAssertion(types, 0, 0, true); [EOL]         list1 = list0; [EOL]         delegateBooleanAssertion(types, 0, 1, true); [EOL]         list0 = list1; [EOL]         delegateBooleanAssertion(types, 1, 0, true); [EOL]         list2 = list0; [EOL]         delegateBooleanAssertion(types, 0, 2, true); [EOL]         list0 = list2; [EOL]         delegateBooleanAssertion(types, 2, 0, true); [EOL]         list3 = list0; [EOL]         delegateBooleanAssertion(types, 0, 3, true); [EOL]         list0 = list3; [EOL]         delegateBooleanAssertion(types, 3, 0, true); [EOL]         list4 = list0; [EOL]         delegateBooleanAssertion(types, 0, 4, true); [EOL]         list0 = list4; [EOL]         delegateBooleanAssertion(types, 4, 0, true); [EOL]         list5 = list0; [EOL]         delegateBooleanAssertion(types, 0, 5, true); [EOL]         list0 = list5; [EOL]         delegateBooleanAssertion(types, 5, 0, true); [EOL]         list6 = list0; [EOL]         delegateBooleanAssertion(types, 0, 6, true); [EOL]         list0 = list6; [EOL]         delegateBooleanAssertion(types, 6, 0, true); [EOL] //        list1 = list1; [EOL]         delegateBooleanAssertion(types, 1, 1, true); [EOL]         list2 = list1; [EOL]         delegateBooleanAssertion(types, 1, 2, true); [EOL]         list1 = (List<Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 1, false); [EOL]         list3 = list1; [EOL]         delegateBooleanAssertion(types, 1, 3, true); [EOL]         list1 = (List<Object>) list3; [EOL]         delegateBooleanAssertion(types, 3, 1, false); [EOL]         // list4 = list1; [EOL]         delegateBooleanAssertion(types, 1, 4, false); [EOL]         // list1 = list4; [EOL]         delegateBooleanAssertion(types, 4, 1, false); [EOL]         // list5 = list1; [EOL]         delegateBooleanAssertion(types, 1, 5, false); [EOL]         // list1 = list5; [EOL]         delegateBooleanAssertion(types, 5, 1, false); [EOL]         list6 = list1; [EOL]         delegateBooleanAssertion(types, 1, 6, true); [EOL]         list1 = (List<Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 1, false); [EOL] //        list2 = list2; [EOL]         delegateBooleanAssertion(types, 2, 2, true); [EOL]         list2 = list3; [EOL]         delegateBooleanAssertion(types, 2, 3, false); [EOL]         list2 = list4; [EOL]         delegateBooleanAssertion(types, 3, 2, true); [EOL]         list3 = (List<? super Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 4, false); [EOL]         list2 = list5; [EOL]         delegateBooleanAssertion(types, 4, 2, true); [EOL]         list4 = (List<String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 5, false); [EOL]         list2 = list6; [EOL]         delegateBooleanAssertion(types, 5, 2, true); [EOL]         list5 = (List<? extends String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 6, false); [EOL] //        list3 = list3; [EOL]         delegateBooleanAssertion(types, 6, 2, true); [EOL]         list6 = (List<? super String>) list2; [EOL]         delegateBooleanAssertion(types, 3, 3, true); [EOL]         // list4 = list3; [EOL]         delegateBooleanAssertion(types, 3, 4, false); [EOL]         // list3 = list4; [EOL]         delegateBooleanAssertion(types, 4, 3, false); [EOL]         // list5 = list3; [EOL]         delegateBooleanAssertion(types, 3, 5, false); [EOL]         // list3 = list5; [EOL]         delegateBooleanAssertion(types, 5, 3, false); [EOL]         list6 = list3; [EOL]         delegateBooleanAssertion(types, 3, 6, true); [EOL]         list3 = (List<? super Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 3, false); [EOL] //        list4 = list4; [EOL]         delegateBooleanAssertion(types, 4, 4, true); [EOL]         list5 = list4; [EOL]         delegateBooleanAssertion(types, 4, 5, true); [EOL]         list4 = (List<String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 4, false); [EOL]         list6 = list4; [EOL]         delegateBooleanAssertion(types, 4, 6, true); [EOL]         list4 = (List<String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 4, false); [EOL] //        list5 = list5; [EOL]         delegateBooleanAssertion(types, 5, 5, true); [EOL]         list6 = (List<? super String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 6, false); [EOL]         list5 = (List<? extends String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 5, false); [EOL] //        list6 = list6; [EOL]         delegateBooleanAssertion(types, 6, 6, true); [EOL]  [EOL] //        list7 = list7; [EOL]         delegateBooleanAssertion(types, 7, 7, true); [EOL]         list8 = list7; [EOL]         delegateBooleanAssertion(types, 7, 8, true); [EOL]         list7 = list8; [EOL]         delegateBooleanAssertion(types, 8, 7, true); [EOL]         list9 = list7; [EOL]         delegateBooleanAssertion(types, 7, 9, true); [EOL]         list7 = list9; [EOL]         delegateBooleanAssertion(types, 9, 7, true); [EOL]         list10 = list7; [EOL]         delegateBooleanAssertion(types, 7, 10, true); [EOL]         list7 = list10; [EOL]         delegateBooleanAssertion(types, 10, 7, true); [EOL]         list11 = list7; [EOL]         delegateBooleanAssertion(types, 7, 11, true); [EOL]         list7 = list11; [EOL]         delegateBooleanAssertion(types, 11, 7, true); [EOL]         list12 = list7; [EOL]         delegateBooleanAssertion(types, 7, 12, true); [EOL]         list7 = list12; [EOL]         delegateBooleanAssertion(types, 12, 7, true); [EOL]         list13 = list7; [EOL]         delegateBooleanAssertion(types, 7, 13, true); [EOL]         list7 = list13; [EOL]         delegateBooleanAssertion(types, 13, 7, true); [EOL] //        list8 = list8; [EOL]         delegateBooleanAssertion(types, 8, 8, true); [EOL]         list9 = list8; [EOL]         delegateBooleanAssertion(types, 8, 9, true); [EOL]         list8 = (List<Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 8, false); [EOL]         list10 = list8; [EOL]         delegateBooleanAssertion(types, 8, 10, true); [EOL]         list8 = (List<Object>[]) list10; // NOTE cast is required by Sun Java, but not by Eclipse [EOL]         delegateBooleanAssertion(types, 10, 8, false); [EOL]         // list11 = list8; [EOL]         delegateBooleanAssertion(types, 8, 11, false); [EOL]         // list8 = list11; [EOL]         delegateBooleanAssertion(types, 11, 8, false); [EOL]         // list12 = list8; [EOL]         delegateBooleanAssertion(types, 8, 12, false); [EOL]         // list8 = list12; [EOL]         delegateBooleanAssertion(types, 12, 8, false); [EOL]         list13 = list8; [EOL]         delegateBooleanAssertion(types, 8, 13, true); [EOL]         list8 = (List<Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 8, false); [EOL] //        list9 = list9; [EOL]         delegateBooleanAssertion(types, 9, 9, true); [EOL]         list10 = (List<? super Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 10, false); [EOL]         list9 = list10; [EOL]         delegateBooleanAssertion(types, 10, 9, true); [EOL]         list11 = (List<String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 11, false); [EOL]         list9 = list11; [EOL]         delegateBooleanAssertion(types, 11, 9, true); [EOL]         list12 = (List<? extends String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 12, false); [EOL]         list9 = list12; [EOL]         delegateBooleanAssertion(types, 12, 9, true); [EOL]         list13 = (List<? super String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 13, false); [EOL]         list9 = list13; [EOL]         delegateBooleanAssertion(types, 13, 9, true); [EOL] //        list10 = list10; [EOL]         delegateBooleanAssertion(types, 10, 10, true); [EOL]         // list11 = list10; [EOL]         delegateBooleanAssertion(types, 10, 11, false); [EOL]         // list10 = list11; [EOL]         delegateBooleanAssertion(types, 11, 10, false); [EOL]         // list12 = list10; [EOL]         delegateBooleanAssertion(types, 10, 12, false); [EOL]         // list10 = list12; [EOL]         delegateBooleanAssertion(types, 12, 10, false); [EOL]         list13 = list10; [EOL]         delegateBooleanAssertion(types, 10, 13, true); [EOL]         list10 = (List<? super Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 10, false); [EOL] //        list11 = list11; [EOL]         delegateBooleanAssertion(types, 11, 11, true); [EOL]         list12 = list11; [EOL]         delegateBooleanAssertion(types, 11, 12, true); [EOL]         list11 = (List<String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 11, false); [EOL]         list13 = list11; [EOL]         delegateBooleanAssertion(types, 11, 13, true); [EOL]         list11 = (List<String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 11, false); [EOL] //        list12 = list12; [EOL]         delegateBooleanAssertion(types, 12, 12, true); [EOL]         list13 = (List<? super String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 13, false); [EOL]         list12 = (List<? extends String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 12, false); [EOL] //        list13 = list13; [EOL]         delegateBooleanAssertion(types, 13, 13, true); [EOL]         final Type disType = getClass().getField("dis").getGenericType(); [EOL]         // Reporter.log( ( ( ParameterizedType ) disType [EOL]         // ).getOwnerType().getClass().toString() ); [EOL]         final Type datType = getClass().getField("dat").getGenericType(); [EOL]         final Type daType = getClass().getField("da").getGenericType(); [EOL]         final Type uhderType = getClass().getField("uhder").getGenericType(); [EOL]         final Type dingType = getClass().getField("ding").getGenericType(); [EOL]         final Type testerType = getClass().getField("tester").getGenericType(); [EOL]         final Type tester2Type = getClass().getField("tester2").getGenericType(); [EOL]         final Type dat2Type = getClass().getField("dat2").getGenericType(); [EOL]         final Type dat3Type = getClass().getField("dat3").getGenericType(); [EOL]         dis = dat; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(datType, disType)); [EOL]         // dis = da; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(daType, disType)); [EOL]         dis = uhder; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(uhderType, disType)); [EOL]         dis = ding; [EOL]         Assert.assertFalse(String.format("type %s not assignable to %s!", dingType, disType), [EOL]                 TypeUtils.isAssignable(dingType, disType)); [EOL]         dis = tester; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(testerType, disType)); [EOL]         // dis = tester2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(tester2Type, disType)); [EOL]         // dat = dat2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat2Type, datType)); [EOL]         // dat2 = dat; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(datType, dat2Type)); [EOL]         // dat = dat3; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat3Type, datType)); [EOL]         final char ch = 0; [EOL]         final boolean bo = false; [EOL]         final byte by = 0; [EOL]         final short sh = 0; [EOL]         int in = 0; [EOL]         long lo = 0; [EOL]         final float fl = 0; [EOL]         double du = 0; [EOL]         du = ch; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(char.class, double.class)); [EOL]         du = by; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(byte.class, double.class)); [EOL]         du = sh; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(short.class, double.class)); [EOL]         du = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, double.class)); [EOL]         du = lo; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(long.class, double.class)); [EOL]         du = fl; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(float.class, double.class)); [EOL]         lo = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, long.class)); [EOL]         lo = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, long.class)); [EOL]         // Long lngW = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, Long.class)); [EOL]         // lngW = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, Long.class)); [EOL]         in = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, int.class)); [EOL]         final Integer inte = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Integer.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Number.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Object.class)); [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, intComparableType)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Comparable.class)); [EOL]         final Serializable ser = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Serializable.class)); [EOL]         final Type longComparableType = getClass().getField("longComparable").getGenericType(); [EOL]         // longComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, longComparableType)); [EOL]         // longComparable = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, longComparableType)); [EOL]         // int[] ia; [EOL]         // long[] la = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, long[].class)); [EOL]         final Integer[] ia = null; [EOL]         final Type caType = getClass().getField("intWildcardComparable").getGenericType(); [EOL]         intWildcardComparable = ia; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, caType)); [EOL]         // int[] ina = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer[].class, int[].class)); [EOL]         final int[] ina = null; [EOL]         Object[] oa; [EOL]         // oa = ina; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, Object[].class)); [EOL]         oa = new Integer[0]; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, Object[].class)); [EOL]         final Type bClassType = AClass.class.getField("bClass").getGenericType(); [EOL]         final Type cClassType = AClass.class.getField("cClass").getGenericType(); [EOL]         final Type dClassType = AClass.class.getField("dClass").getGenericType(); [EOL]         final Type eClassType = AClass.class.getField("eClass").getGenericType(); [EOL]         final Type fClassType = AClass.class.getField("fClass").getGenericType(); [EOL]         final AClass aClass = new AClass(new AAClass<String>()); [EOL]         aClass.bClass = aClass.cClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(cClassType, bClassType)); [EOL]         aClass.bClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, bClassType)); [EOL]         aClass.bClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, bClassType)); [EOL]         aClass.bClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, bClassType)); [EOL]         aClass.cClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, cClassType)); [EOL]         aClass.cClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, cClassType)); [EOL]         aClass.cClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, cClassType)); [EOL]         aClass.dClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, dClassType)); [EOL]         aClass.dClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, dClassType)); [EOL]         aClass.eClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, eClassType)); [EOL]     } [EOL]  [EOL]     public void delegateBooleanAssertion(final Type[] types, final int i2, final int i1, final boolean expected) { [EOL]         final Type type1 = types[i1]; [EOL]         final Type type2 = types[i2]; [EOL]         final boolean isAssignable = TypeUtils.isAssignable(type2, type1); [EOL]  [EOL]         if (expected) { [EOL]             Assert.assertTrue("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } else { [EOL]             Assert.assertFalse("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } [EOL]     } [EOL]  [EOL]     @SuppressWarnings("boxing") // boxing is deliberate here [EOL]
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [EOL]         final Type[] types = method.getGenericParameterTypes(); [EOL] //        list0 = list0; [EOL]         delegateBooleanAssertion(types, 0, 0, true); [EOL]         list1 = list0; [EOL]         delegateBooleanAssertion(types, 0, 1, true); [EOL]         list0 = list1; [EOL]         delegateBooleanAssertion(types, 1, 0, true); [EOL]         list2 = list0; [EOL]         delegateBooleanAssertion(types, 0, 2, true); [EOL]         list0 = list2; [EOL]         delegateBooleanAssertion(types, 2, 0, true); [EOL]         list3 = list0; [EOL]         delegateBooleanAssertion(types, 0, 3, true); [EOL]         list0 = list3; [EOL]         delegateBooleanAssertion(types, 3, 0, true); [EOL]         list4 = list0; [EOL]         delegateBooleanAssertion(types, 0, 4, true); [EOL]         list0 = list4; [EOL]         delegateBooleanAssertion(types, 4, 0, true); [EOL]         list5 = list0; [EOL]         delegateBooleanAssertion(types, 0, 5, true); [EOL]         list0 = list5; [EOL]         delegateBooleanAssertion(types, 5, 0, true); [EOL]         list6 = list0; [EOL]         delegateBooleanAssertion(types, 0, 6, true); [EOL]         list0 = list6; [EOL]         delegateBooleanAssertion(types, 6, 0, true); [EOL] //        list1 = list1; [EOL]         delegateBooleanAssertion(types, 1, 1, true); [EOL]         list2 = list1; [EOL]         delegateBooleanAssertion(types, 1, 2, true); [EOL]         list1 = (List<Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 1, false); [EOL]         list3 = list1; [EOL]         delegateBooleanAssertion(types, 1, 3, true); [EOL]         list1 = (List<Object>) list3; [EOL]         delegateBooleanAssertion(types, 3, 1, false); [EOL]         // list4 = list1; [EOL]         delegateBooleanAssertion(types, 1, 4, false); [EOL]         // list1 = list4; [EOL]         delegateBooleanAssertion(types, 4, 1, false); [EOL]         // list5 = list1; [EOL]         delegateBooleanAssertion(types, 1, 5, false); [EOL]         // list1 = list5; [EOL]         delegateBooleanAssertion(types, 5, 1, false); [EOL]         list6 = list1; [EOL]         delegateBooleanAssertion(types, 1, 6, true); [EOL]         list1 = (List<Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 1, false); [EOL] //        list2 = list2; [EOL]         delegateBooleanAssertion(types, 2, 2, true); [EOL]         list2 = list3; [EOL]         delegateBooleanAssertion(types, 2, 3, false); [EOL]         list2 = list4; [EOL]         delegateBooleanAssertion(types, 3, 2, true); [EOL]         list3 = (List<? super Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 4, false); [EOL]         list2 = list5; [EOL]         delegateBooleanAssertion(types, 4, 2, true); [EOL]         list4 = (List<String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 5, false); [EOL]         list2 = list6; [EOL]         delegateBooleanAssertion(types, 5, 2, true); [EOL]         list5 = (List<? extends String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 6, false); [EOL] //        list3 = list3; [EOL]         delegateBooleanAssertion(types, 6, 2, true); [EOL]         list6 = (List<? super String>) list2; [EOL]         delegateBooleanAssertion(types, 3, 3, true); [EOL]         // list4 = list3; [EOL]         delegateBooleanAssertion(types, 3, 4, false); [EOL]         // list3 = list4; [EOL]         delegateBooleanAssertion(types, 4, 3, false); [EOL]         // list5 = list3; [EOL]         delegateBooleanAssertion(types, 3, 5, false); [EOL]         // list3 = list5; [EOL]         delegateBooleanAssertion(types, 5, 3, false); [EOL]         list6 = list3; [EOL]         delegateBooleanAssertion(types, 3, 6, true); [EOL]         list3 = (List<? super Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 3, false); [EOL] //        list4 = list4; [EOL]         delegateBooleanAssertion(types, 4, 4, true); [EOL]         list5 = list4; [EOL]         delegateBooleanAssertion(types, 4, 5, true); [EOL]         list4 = (List<String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 4, false); [EOL]         list6 = list4; [EOL]         delegateBooleanAssertion(types, 4, 6, true); [EOL]         list4 = (List<String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 4, false); [EOL] //        list5 = list5; [EOL]         delegateBooleanAssertion(types, 5, 5, true); [EOL]         list6 = (List<? super String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 6, false); [EOL]         list5 = (List<? extends String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 5, false); [EOL] //        list6 = list6; [EOL]         delegateBooleanAssertion(types, 6, 6, true); [EOL]  [EOL] //        list7 = list7; [EOL]         delegateBooleanAssertion(types, 7, 7, true); [EOL]         list8 = list7; [EOL]         delegateBooleanAssertion(types, 7, 8, true); [EOL]         list7 = list8; [EOL]         delegateBooleanAssertion(types, 8, 7, true); [EOL]         list9 = list7; [EOL]         delegateBooleanAssertion(types, 7, 9, true); [EOL]         list7 = list9; [EOL]         delegateBooleanAssertion(types, 9, 7, true); [EOL]         list10 = list7; [EOL]         delegateBooleanAssertion(types, 7, 10, true); [EOL]         list7 = list10; [EOL]         delegateBooleanAssertion(types, 10, 7, true); [EOL]         list11 = list7; [EOL]         delegateBooleanAssertion(types, 7, 11, true); [EOL]         list7 = list11; [EOL]         delegateBooleanAssertion(types, 11, 7, true); [EOL]         list12 = list7; [EOL]         delegateBooleanAssertion(types, 7, 12, true); [EOL]         list7 = list12; [EOL]         delegateBooleanAssertion(types, 12, 7, true); [EOL]         list13 = list7; [EOL]         delegateBooleanAssertion(types, 7, 13, true); [EOL]         list7 = list13; [EOL]         delegateBooleanAssertion(types, 13, 7, true); [EOL] //        list8 = list8; [EOL]         delegateBooleanAssertion(types, 8, 8, true); [EOL]         list9 = list8; [EOL]         delegateBooleanAssertion(types, 8, 9, true); [EOL]         list8 = (List<Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 8, false); [EOL]         list10 = list8; [EOL]         delegateBooleanAssertion(types, 8, 10, true); [EOL]         list8 = (List<Object>[]) list10; // NOTE cast is required by Sun Java, but not by Eclipse [EOL]         delegateBooleanAssertion(types, 10, 8, false); [EOL]         // list11 = list8; [EOL]         delegateBooleanAssertion(types, 8, 11, false); [EOL]         // list8 = list11; [EOL]         delegateBooleanAssertion(types, 11, 8, false); [EOL]         // list12 = list8; [EOL]         delegateBooleanAssertion(types, 8, 12, false); [EOL]         // list8 = list12; [EOL]         delegateBooleanAssertion(types, 12, 8, false); [EOL]         list13 = list8; [EOL]         delegateBooleanAssertion(types, 8, 13, true); [EOL]         list8 = (List<Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 8, false); [EOL] //        list9 = list9; [EOL]         delegateBooleanAssertion(types, 9, 9, true); [EOL]         list10 = (List<? super Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 10, false); [EOL]         list9 = list10; [EOL]         delegateBooleanAssertion(types, 10, 9, true); [EOL]         list11 = (List<String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 11, false); [EOL]         list9 = list11; [EOL]         delegateBooleanAssertion(types, 11, 9, true); [EOL]         list12 = (List<? extends String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 12, false); [EOL]         list9 = list12; [EOL]         delegateBooleanAssertion(types, 12, 9, true); [EOL]         list13 = (List<? super String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 13, false); [EOL]         list9 = list13; [EOL]         delegateBooleanAssertion(types, 13, 9, true); [EOL] //        list10 = list10; [EOL]         delegateBooleanAssertion(types, 10, 10, true); [EOL]         // list11 = list10; [EOL]         delegateBooleanAssertion(types, 10, 11, false); [EOL]         // list10 = list11; [EOL]         delegateBooleanAssertion(types, 11, 10, false); [EOL]         // list12 = list10; [EOL]         delegateBooleanAssertion(types, 10, 12, false); [EOL]         // list10 = list12; [EOL]         delegateBooleanAssertion(types, 12, 10, false); [EOL]         list13 = list10; [EOL]         delegateBooleanAssertion(types, 10, 13, true); [EOL]         list10 = (List<? super Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 10, false); [EOL] //        list11 = list11; [EOL]         delegateBooleanAssertion(types, 11, 11, true); [EOL]         list12 = list11; [EOL]         delegateBooleanAssertion(types, 11, 12, true); [EOL]         list11 = (List<String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 11, false); [EOL]         list13 = list11; [EOL]         delegateBooleanAssertion(types, 11, 13, true); [EOL]         list11 = (List<String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 11, false); [EOL] //        list12 = list12; [EOL]         delegateBooleanAssertion(types, 12, 12, true); [EOL]         list13 = (List<? super String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 13, false); [EOL]         list12 = (List<? extends String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 12, false); [EOL] //        list13 = list13; [EOL]         delegateBooleanAssertion(types, 13, 13, true); [EOL]         final Type disType = getClass().getField("dis").getGenericType(); [EOL]         // Reporter.log( ( ( ParameterizedType ) disType [EOL]         // ).getOwnerType().getClass().toString() ); [EOL]         final Type datType = getClass().getField("dat").getGenericType(); [EOL]         final Type daType = getClass().getField("da").getGenericType(); [EOL]         final Type uhderType = getClass().getField("uhder").getGenericType(); [EOL]         final Type dingType = getClass().getField("ding").getGenericType(); [EOL]         final Type testerType = getClass().getField("tester").getGenericType(); [EOL]         final Type tester2Type = getClass().getField("tester2").getGenericType(); [EOL]         final Type dat2Type = getClass().getField("dat2").getGenericType(); [EOL]         final Type dat3Type = getClass().getField("dat3").getGenericType(); [EOL]         dis = dat; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(datType, disType)); [EOL]         // dis = da; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(daType, disType)); [EOL]         dis = uhder; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(uhderType, disType)); [EOL]         dis = ding; [EOL]         Assert.assertFalse(String.format("type %s not assignable to %s!", dingType, disType), [EOL]                 TypeUtils.isAssignable(dingType, disType)); [EOL]         dis = tester; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(testerType, disType)); [EOL]         // dis = tester2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(tester2Type, disType)); [EOL]         // dat = dat2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat2Type, datType)); [EOL]         // dat2 = dat; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(datType, dat2Type)); [EOL]         // dat = dat3; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat3Type, datType)); [EOL]         final char ch = 0; [EOL]         final boolean bo = false; [EOL]         final byte by = 0; [EOL]         final short sh = 0; [EOL]         int in = 0; [EOL]         long lo = 0; [EOL]         final float fl = 0; [EOL]         double du = 0; [EOL]         du = ch; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(char.class, double.class)); [EOL]         du = by; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(byte.class, double.class)); [EOL]         du = sh; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(short.class, double.class)); [EOL]         du = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, double.class)); [EOL]         du = lo; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(long.class, double.class)); [EOL]         du = fl; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(float.class, double.class)); [EOL]         lo = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, long.class)); [EOL]         lo = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, long.class)); [EOL]         // Long lngW = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, Long.class)); [EOL]         // lngW = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, Long.class)); [EOL]         in = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, int.class)); [EOL]         final Integer inte = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Integer.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Number.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Object.class)); [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, intComparableType)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Comparable.class)); [EOL]         final Serializable ser = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Serializable.class)); [EOL]         final Type longComparableType = getClass().getField("longComparable").getGenericType(); [EOL]         // longComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, longComparableType)); [EOL]         // longComparable = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, longComparableType)); [EOL]         // int[] ia; [EOL]         // long[] la = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, long[].class)); [EOL]         final Integer[] ia = null; [EOL]         final Type caType = getClass().getField("intWildcardComparable").getGenericType(); [EOL]         intWildcardComparable = ia; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, caType)); [EOL]         // int[] ina = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer[].class, int[].class)); [EOL]         final int[] ina = null; [EOL]         Object[] oa; [EOL]         // oa = ina; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, Object[].class)); [EOL]         oa = new Integer[0]; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, Object[].class)); [EOL]         final Type bClassType = AClass.class.getField("bClass").getGenericType(); [EOL]         final Type cClassType = AClass.class.getField("cClass").getGenericType(); [EOL]         final Type dClassType = AClass.class.getField("dClass").getGenericType(); [EOL]         final Type eClassType = AClass.class.getField("eClass").getGenericType(); [EOL]         final Type fClassType = AClass.class.getField("fClass").getGenericType(); [EOL]         final AClass aClass = new AClass(new AAClass<String>()); [EOL]         aClass.bClass = aClass.cClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(cClassType, bClassType)); [EOL]         aClass.bClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, bClassType)); [EOL]         aClass.bClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, bClassType)); [EOL]         aClass.bClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, bClassType)); [EOL]         aClass.cClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, cClassType)); [EOL]         aClass.cClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, cClassType)); [EOL]         aClass.cClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, cClassType)); [EOL]         aClass.dClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, dClassType)); [EOL]         aClass.dClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, dClassType)); [EOL]         aClass.eClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, eClassType)); [EOL]     } [EOL]  [EOL]     public void delegateBooleanAssertion(final Type[] types, final int i2, final int i1, final boolean expected) { [EOL]         final Type type1 = types[i1]; [EOL]         final Type type2 = types[i2]; [EOL]         final boolean isAssignable = TypeUtils.isAssignable(type2, type1); [EOL]  [EOL]         if (expected) { [EOL]             Assert.assertTrue("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } else { [EOL]             Assert.assertFalse("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } [EOL]     } [EOL]  [EOL]     @SuppressWarnings("boxing") // boxing is deliberate here [EOL]
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [EOL]         final Type[] types = method.getGenericParameterTypes(); [EOL] //        list0 = list0; [EOL]         delegateBooleanAssertion(types, 0, 0, true); [EOL]         list1 = list0; [EOL]         delegateBooleanAssertion(types, 0, 1, true); [EOL]         list0 = list1; [EOL]         delegateBooleanAssertion(types, 1, 0, true); [EOL]         list2 = list0; [EOL]         delegateBooleanAssertion(types, 0, 2, true); [EOL]         list0 = list2; [EOL]         delegateBooleanAssertion(types, 2, 0, true); [EOL]         list3 = list0; [EOL]         delegateBooleanAssertion(types, 0, 3, true); [EOL]         list0 = list3; [EOL]         delegateBooleanAssertion(types, 3, 0, true); [EOL]         list4 = list0; [EOL]         delegateBooleanAssertion(types, 0, 4, true); [EOL]         list0 = list4; [EOL]         delegateBooleanAssertion(types, 4, 0, true); [EOL]         list5 = list0; [EOL]         delegateBooleanAssertion(types, 0, 5, true); [EOL]         list0 = list5; [EOL]         delegateBooleanAssertion(types, 5, 0, true); [EOL]         list6 = list0; [EOL]         delegateBooleanAssertion(types, 0, 6, true); [EOL]         list0 = list6; [EOL]         delegateBooleanAssertion(types, 6, 0, true); [EOL] //        list1 = list1; [EOL]         delegateBooleanAssertion(types, 1, 1, true); [EOL]         list2 = list1; [EOL]         delegateBooleanAssertion(types, 1, 2, true); [EOL]         list1 = (List<Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 1, false); [EOL]         list3 = list1; [EOL]         delegateBooleanAssertion(types, 1, 3, true); [EOL]         list1 = (List<Object>) list3; [EOL]         delegateBooleanAssertion(types, 3, 1, false); [EOL]         // list4 = list1; [EOL]         delegateBooleanAssertion(types, 1, 4, false); [EOL]         // list1 = list4; [EOL]         delegateBooleanAssertion(types, 4, 1, false); [EOL]         // list5 = list1; [EOL]         delegateBooleanAssertion(types, 1, 5, false); [EOL]         // list1 = list5; [EOL]         delegateBooleanAssertion(types, 5, 1, false); [EOL]         list6 = list1; [EOL]         delegateBooleanAssertion(types, 1, 6, true); [EOL]         list1 = (List<Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 1, false); [EOL] //        list2 = list2; [EOL]         delegateBooleanAssertion(types, 2, 2, true); [EOL]         list2 = list3; [EOL]         delegateBooleanAssertion(types, 2, 3, false); [EOL]         list2 = list4; [EOL]         delegateBooleanAssertion(types, 3, 2, true); [EOL]         list3 = (List<? super Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 4, false); [EOL]         list2 = list5; [EOL]         delegateBooleanAssertion(types, 4, 2, true); [EOL]         list4 = (List<String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 5, false); [EOL]         list2 = list6; [EOL]         delegateBooleanAssertion(types, 5, 2, true); [EOL]         list5 = (List<? extends String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 6, false); [EOL] //        list3 = list3; [EOL]         delegateBooleanAssertion(types, 6, 2, true); [EOL]         list6 = (List<? super String>) list2; [EOL]         delegateBooleanAssertion(types, 3, 3, true); [EOL]         // list4 = list3; [EOL]         delegateBooleanAssertion(types, 3, 4, false); [EOL]         // list3 = list4; [EOL]         delegateBooleanAssertion(types, 4, 3, false); [EOL]         // list5 = list3; [EOL]         delegateBooleanAssertion(types, 3, 5, false); [EOL]         // list3 = list5; [EOL]         delegateBooleanAssertion(types, 5, 3, false); [EOL]         list6 = list3; [EOL]         delegateBooleanAssertion(types, 3, 6, true); [EOL]         list3 = (List<? super Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 3, false); [EOL] //        list4 = list4; [EOL]         delegateBooleanAssertion(types, 4, 4, true); [EOL]         list5 = list4; [EOL]         delegateBooleanAssertion(types, 4, 5, true); [EOL]         list4 = (List<String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 4, false); [EOL]         list6 = list4; [EOL]         delegateBooleanAssertion(types, 4, 6, true); [EOL]         list4 = (List<String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 4, false); [EOL] //        list5 = list5; [EOL]         delegateBooleanAssertion(types, 5, 5, true); [EOL]         list6 = (List<? super String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 6, false); [EOL]         list5 = (List<? extends String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 5, false); [EOL] //        list6 = list6; [EOL]         delegateBooleanAssertion(types, 6, 6, true); [EOL]  [EOL] //        list7 = list7; [EOL]         delegateBooleanAssertion(types, 7, 7, true); [EOL]         list8 = list7; [EOL]         delegateBooleanAssertion(types, 7, 8, true); [EOL]         list7 = list8; [EOL]         delegateBooleanAssertion(types, 8, 7, true); [EOL]         list9 = list7; [EOL]         delegateBooleanAssertion(types, 7, 9, true); [EOL]         list7 = list9; [EOL]         delegateBooleanAssertion(types, 9, 7, true); [EOL]         list10 = list7; [EOL]         delegateBooleanAssertion(types, 7, 10, true); [EOL]         list7 = list10; [EOL]         delegateBooleanAssertion(types, 10, 7, true); [EOL]         list11 = list7; [EOL]         delegateBooleanAssertion(types, 7, 11, true); [EOL]         list7 = list11; [EOL]         delegateBooleanAssertion(types, 11, 7, true); [EOL]         list12 = list7; [EOL]         delegateBooleanAssertion(types, 7, 12, true); [EOL]         list7 = list12; [EOL]         delegateBooleanAssertion(types, 12, 7, true); [EOL]         list13 = list7; [EOL]         delegateBooleanAssertion(types, 7, 13, true); [EOL]         list7 = list13; [EOL]         delegateBooleanAssertion(types, 13, 7, true); [EOL] //        list8 = list8; [EOL]         delegateBooleanAssertion(types, 8, 8, true); [EOL]         list9 = list8; [EOL]         delegateBooleanAssertion(types, 8, 9, true); [EOL]         list8 = (List<Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 8, false); [EOL]         list10 = list8; [EOL]         delegateBooleanAssertion(types, 8, 10, true); [EOL]         list8 = (List<Object>[]) list10; // NOTE cast is required by Sun Java, but not by Eclipse [EOL]         delegateBooleanAssertion(types, 10, 8, false); [EOL]         // list11 = list8; [EOL]         delegateBooleanAssertion(types, 8, 11, false); [EOL]         // list8 = list11; [EOL]         delegateBooleanAssertion(types, 11, 8, false); [EOL]         // list12 = list8; [EOL]         delegateBooleanAssertion(types, 8, 12, false); [EOL]         // list8 = list12; [EOL]         delegateBooleanAssertion(types, 12, 8, false); [EOL]         list13 = list8; [EOL]         delegateBooleanAssertion(types, 8, 13, true); [EOL]         list8 = (List<Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 8, false); [EOL] //        list9 = list9; [EOL]         delegateBooleanAssertion(types, 9, 9, true); [EOL]         list10 = (List<? super Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 10, false); [EOL]         list9 = list10; [EOL]         delegateBooleanAssertion(types, 10, 9, true); [EOL]         list11 = (List<String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 11, false); [EOL]         list9 = list11; [EOL]         delegateBooleanAssertion(types, 11, 9, true); [EOL]         list12 = (List<? extends String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 12, false); [EOL]         list9 = list12; [EOL]         delegateBooleanAssertion(types, 12, 9, true); [EOL]         list13 = (List<? super String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 13, false); [EOL]         list9 = list13; [EOL]         delegateBooleanAssertion(types, 13, 9, true); [EOL] //        list10 = list10; [EOL]         delegateBooleanAssertion(types, 10, 10, true); [EOL]         // list11 = list10; [EOL]         delegateBooleanAssertion(types, 10, 11, false); [EOL]         // list10 = list11; [EOL]         delegateBooleanAssertion(types, 11, 10, false); [EOL]         // list12 = list10; [EOL]         delegateBooleanAssertion(types, 10, 12, false); [EOL]         // list10 = list12; [EOL]         delegateBooleanAssertion(types, 12, 10, false); [EOL]         list13 = list10; [EOL]         delegateBooleanAssertion(types, 10, 13, true); [EOL]         list10 = (List<? super Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 10, false); [EOL] //        list11 = list11; [EOL]         delegateBooleanAssertion(types, 11, 11, true); [EOL]         list12 = list11; [EOL]         delegateBooleanAssertion(types, 11, 12, true); [EOL]         list11 = (List<String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 11, false); [EOL]         list13 = list11; [EOL]         delegateBooleanAssertion(types, 11, 13, true); [EOL]         list11 = (List<String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 11, false); [EOL] //        list12 = list12; [EOL]         delegateBooleanAssertion(types, 12, 12, true); [EOL]         list13 = (List<? super String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 13, false); [EOL]         list12 = (List<? extends String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 12, false); [EOL] //        list13 = list13; [EOL]         delegateBooleanAssertion(types, 13, 13, true); [EOL]         final Type disType = getClass().getField("dis").getGenericType(); [EOL]         // Reporter.log( ( ( ParameterizedType ) disType [EOL]         // ).getOwnerType().getClass().toString() ); [EOL]         final Type datType = getClass().getField("dat").getGenericType(); [EOL]         final Type daType = getClass().getField("da").getGenericType(); [EOL]         final Type uhderType = getClass().getField("uhder").getGenericType(); [EOL]         final Type dingType = getClass().getField("ding").getGenericType(); [EOL]         final Type testerType = getClass().getField("tester").getGenericType(); [EOL]         final Type tester2Type = getClass().getField("tester2").getGenericType(); [EOL]         final Type dat2Type = getClass().getField("dat2").getGenericType(); [EOL]         final Type dat3Type = getClass().getField("dat3").getGenericType(); [EOL]         dis = dat; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(datType, disType)); [EOL]         // dis = da; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(daType, disType)); [EOL]         dis = uhder; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(uhderType, disType)); [EOL]         dis = ding; [EOL]         Assert.assertFalse(String.format("type %s not assignable to %s!", dingType, disType), [EOL]                 TypeUtils.isAssignable(dingType, disType)); [EOL]         dis = tester; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(testerType, disType)); [EOL]         // dis = tester2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(tester2Type, disType)); [EOL]         // dat = dat2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat2Type, datType)); [EOL]         // dat2 = dat; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(datType, dat2Type)); [EOL]         // dat = dat3; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat3Type, datType)); [EOL]         final char ch = 0; [EOL]         final boolean bo = false; [EOL]         final byte by = 0; [EOL]         final short sh = 0; [EOL]         int in = 0; [EOL]         long lo = 0; [EOL]         final float fl = 0; [EOL]         double du = 0; [EOL]         du = ch; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(char.class, double.class)); [EOL]         du = by; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(byte.class, double.class)); [EOL]         du = sh; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(short.class, double.class)); [EOL]         du = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, double.class)); [EOL]         du = lo; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(long.class, double.class)); [EOL]         du = fl; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(float.class, double.class)); [EOL]         lo = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, long.class)); [EOL]         lo = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, long.class)); [EOL]         // Long lngW = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, Long.class)); [EOL]         // lngW = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, Long.class)); [EOL]         in = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, int.class)); [EOL]         final Integer inte = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Integer.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Number.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Object.class)); [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, intComparableType)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Comparable.class)); [EOL]         final Serializable ser = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Serializable.class)); [EOL]         final Type longComparableType = getClass().getField("longComparable").getGenericType(); [EOL]         // longComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, longComparableType)); [EOL]         // longComparable = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, longComparableType)); [EOL]         // int[] ia; [EOL]         // long[] la = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, long[].class)); [EOL]         final Integer[] ia = null; [EOL]         final Type caType = getClass().getField("intWildcardComparable").getGenericType(); [EOL]         intWildcardComparable = ia; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, caType)); [EOL]         // int[] ina = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer[].class, int[].class)); [EOL]         final int[] ina = null; [EOL]         Object[] oa; [EOL]         // oa = ina; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, Object[].class)); [EOL]         oa = new Integer[0]; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, Object[].class)); [EOL]         final Type bClassType = AClass.class.getField("bClass").getGenericType(); [EOL]         final Type cClassType = AClass.class.getField("cClass").getGenericType(); [EOL]         final Type dClassType = AClass.class.getField("dClass").getGenericType(); [EOL]         final Type eClassType = AClass.class.getField("eClass").getGenericType(); [EOL]         final Type fClassType = AClass.class.getField("fClass").getGenericType(); [EOL]         final AClass aClass = new AClass(new AAClass<String>()); [EOL]         aClass.bClass = aClass.cClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(cClassType, bClassType)); [EOL]         aClass.bClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, bClassType)); [EOL]         aClass.bClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, bClassType)); [EOL]         aClass.bClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, bClassType)); [EOL]         aClass.cClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, cClassType)); [EOL]         aClass.cClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, cClassType)); [EOL]         aClass.cClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, cClassType)); [EOL]         aClass.dClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, dClassType)); [EOL]         aClass.dClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, dClassType)); [EOL]         aClass.eClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, eClassType)); [EOL]     } [EOL]  [EOL]     public void delegateBooleanAssertion(final Type[] types, final int i2, final int i1, final boolean expected) { [EOL]         final Type type1 = types[i1]; [EOL]         final Type type2 = types[i2]; [EOL]         final boolean isAssignable = TypeUtils.isAssignable(type2, type1); [EOL]  [EOL]         if (expected) { [EOL]             Assert.assertTrue("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } else { [EOL]             Assert.assertFalse("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } [EOL]     } [EOL]  [EOL]     @SuppressWarnings("boxing") // boxing is deliberate here [EOL]
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [EOL]         final Type[] types = method.getGenericParameterTypes(); [EOL] //        list0 = list0; [EOL]         delegateBooleanAssertion(types, 0, 0, true); [EOL]         list1 = list0; [EOL]         delegateBooleanAssertion(types, 0, 1, true); [EOL]         list0 = list1; [EOL]         delegateBooleanAssertion(types, 1, 0, true); [EOL]         list2 = list0; [EOL]         delegateBooleanAssertion(types, 0, 2, true); [EOL]         list0 = list2; [EOL]         delegateBooleanAssertion(types, 2, 0, true); [EOL]         list3 = list0; [EOL]         delegateBooleanAssertion(types, 0, 3, true); [EOL]         list0 = list3; [EOL]         delegateBooleanAssertion(types, 3, 0, true); [EOL]         list4 = list0; [EOL]         delegateBooleanAssertion(types, 0, 4, true); [EOL]         list0 = list4; [EOL]         delegateBooleanAssertion(types, 4, 0, true); [EOL]         list5 = list0; [EOL]         delegateBooleanAssertion(types, 0, 5, true); [EOL]         list0 = list5; [EOL]         delegateBooleanAssertion(types, 5, 0, true); [EOL]         list6 = list0; [EOL]         delegateBooleanAssertion(types, 0, 6, true); [EOL]         list0 = list6; [EOL]         delegateBooleanAssertion(types, 6, 0, true); [EOL] //        list1 = list1; [EOL]         delegateBooleanAssertion(types, 1, 1, true); [EOL]         list2 = list1; [EOL]         delegateBooleanAssertion(types, 1, 2, true); [EOL]         list1 = (List<Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 1, false); [EOL]         list3 = list1; [EOL]         delegateBooleanAssertion(types, 1, 3, true); [EOL]         list1 = (List<Object>) list3; [EOL]         delegateBooleanAssertion(types, 3, 1, false); [EOL]         // list4 = list1; [EOL]         delegateBooleanAssertion(types, 1, 4, false); [EOL]         // list1 = list4; [EOL]         delegateBooleanAssertion(types, 4, 1, false); [EOL]         // list5 = list1; [EOL]         delegateBooleanAssertion(types, 1, 5, false); [EOL]         // list1 = list5; [EOL]         delegateBooleanAssertion(types, 5, 1, false); [EOL]         list6 = list1; [EOL]         delegateBooleanAssertion(types, 1, 6, true); [EOL]         list1 = (List<Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 1, false); [EOL] //        list2 = list2; [EOL]         delegateBooleanAssertion(types, 2, 2, true); [EOL]         list2 = list3; [EOL]         delegateBooleanAssertion(types, 2, 3, false); [EOL]         list2 = list4; [EOL]         delegateBooleanAssertion(types, 3, 2, true); [EOL]         list3 = (List<? super Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 4, false); [EOL]         list2 = list5; [EOL]         delegateBooleanAssertion(types, 4, 2, true); [EOL]         list4 = (List<String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 5, false); [EOL]         list2 = list6; [EOL]         delegateBooleanAssertion(types, 5, 2, true); [EOL]         list5 = (List<? extends String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 6, false); [EOL] //        list3 = list3; [EOL]         delegateBooleanAssertion(types, 6, 2, true); [EOL]         list6 = (List<? super String>) list2; [EOL]         delegateBooleanAssertion(types, 3, 3, true); [EOL]         // list4 = list3; [EOL]         delegateBooleanAssertion(types, 3, 4, false); [EOL]         // list3 = list4; [EOL]         delegateBooleanAssertion(types, 4, 3, false); [EOL]         // list5 = list3; [EOL]         delegateBooleanAssertion(types, 3, 5, false); [EOL]         // list3 = list5; [EOL]         delegateBooleanAssertion(types, 5, 3, false); [EOL]         list6 = list3; [EOL]         delegateBooleanAssertion(types, 3, 6, true); [EOL]         list3 = (List<? super Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 3, false); [EOL] //        list4 = list4; [EOL]         delegateBooleanAssertion(types, 4, 4, true); [EOL]         list5 = list4; [EOL]         delegateBooleanAssertion(types, 4, 5, true); [EOL]         list4 = (List<String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 4, false); [EOL]         list6 = list4; [EOL]         delegateBooleanAssertion(types, 4, 6, true); [EOL]         list4 = (List<String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 4, false); [EOL] //        list5 = list5; [EOL]         delegateBooleanAssertion(types, 5, 5, true); [EOL]         list6 = (List<? super String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 6, false); [EOL]         list5 = (List<? extends String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 5, false); [EOL] //        list6 = list6; [EOL]         delegateBooleanAssertion(types, 6, 6, true); [EOL]  [EOL] //        list7 = list7; [EOL]         delegateBooleanAssertion(types, 7, 7, true); [EOL]         list8 = list7; [EOL]         delegateBooleanAssertion(types, 7, 8, true); [EOL]         list7 = list8; [EOL]         delegateBooleanAssertion(types, 8, 7, true); [EOL]         list9 = list7; [EOL]         delegateBooleanAssertion(types, 7, 9, true); [EOL]         list7 = list9; [EOL]         delegateBooleanAssertion(types, 9, 7, true); [EOL]         list10 = list7; [EOL]         delegateBooleanAssertion(types, 7, 10, true); [EOL]         list7 = list10; [EOL]         delegateBooleanAssertion(types, 10, 7, true); [EOL]         list11 = list7; [EOL]         delegateBooleanAssertion(types, 7, 11, true); [EOL]         list7 = list11; [EOL]         delegateBooleanAssertion(types, 11, 7, true); [EOL]         list12 = list7; [EOL]         delegateBooleanAssertion(types, 7, 12, true); [EOL]         list7 = list12; [EOL]         delegateBooleanAssertion(types, 12, 7, true); [EOL]         list13 = list7; [EOL]         delegateBooleanAssertion(types, 7, 13, true); [EOL]         list7 = list13; [EOL]         delegateBooleanAssertion(types, 13, 7, true); [EOL] //        list8 = list8; [EOL]         delegateBooleanAssertion(types, 8, 8, true); [EOL]         list9 = list8; [EOL]         delegateBooleanAssertion(types, 8, 9, true); [EOL]         list8 = (List<Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 8, false); [EOL]         list10 = list8; [EOL]         delegateBooleanAssertion(types, 8, 10, true); [EOL]         list8 = (List<Object>[]) list10; // NOTE cast is required by Sun Java, but not by Eclipse [EOL]         delegateBooleanAssertion(types, 10, 8, false); [EOL]         // list11 = list8; [EOL]         delegateBooleanAssertion(types, 8, 11, false); [EOL]         // list8 = list11; [EOL]         delegateBooleanAssertion(types, 11, 8, false); [EOL]         // list12 = list8; [EOL]         delegateBooleanAssertion(types, 8, 12, false); [EOL]         // list8 = list12; [EOL]         delegateBooleanAssertion(types, 12, 8, false); [EOL]         list13 = list8; [EOL]         delegateBooleanAssertion(types, 8, 13, true); [EOL]         list8 = (List<Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 8, false); [EOL] //        list9 = list9; [EOL]         delegateBooleanAssertion(types, 9, 9, true); [EOL]         list10 = (List<? super Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 10, false); [EOL]         list9 = list10; [EOL]         delegateBooleanAssertion(types, 10, 9, true); [EOL]         list11 = (List<String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 11, false); [EOL]         list9 = list11; [EOL]         delegateBooleanAssertion(types, 11, 9, true); [EOL]         list12 = (List<? extends String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 12, false); [EOL]         list9 = list12; [EOL]         delegateBooleanAssertion(types, 12, 9, true); [EOL]         list13 = (List<? super String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 13, false); [EOL]         list9 = list13; [EOL]         delegateBooleanAssertion(types, 13, 9, true); [EOL] //        list10 = list10; [EOL]         delegateBooleanAssertion(types, 10, 10, true); [EOL]         // list11 = list10; [EOL]         delegateBooleanAssertion(types, 10, 11, false); [EOL]         // list10 = list11; [EOL]         delegateBooleanAssertion(types, 11, 10, false); [EOL]         // list12 = list10; [EOL]         delegateBooleanAssertion(types, 10, 12, false); [EOL]         // list10 = list12; [EOL]         delegateBooleanAssertion(types, 12, 10, false); [EOL]         list13 = list10; [EOL]         delegateBooleanAssertion(types, 10, 13, true); [EOL]         list10 = (List<? super Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 10, false); [EOL] //        list11 = list11; [EOL]         delegateBooleanAssertion(types, 11, 11, true); [EOL]         list12 = list11; [EOL]         delegateBooleanAssertion(types, 11, 12, true); [EOL]         list11 = (List<String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 11, false); [EOL]         list13 = list11; [EOL]         delegateBooleanAssertion(types, 11, 13, true); [EOL]         list11 = (List<String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 11, false); [EOL] //        list12 = list12; [EOL]         delegateBooleanAssertion(types, 12, 12, true); [EOL]         list13 = (List<? super String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 13, false); [EOL]         list12 = (List<? extends String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 12, false); [EOL] //        list13 = list13; [EOL]         delegateBooleanAssertion(types, 13, 13, true); [EOL]         final Type disType = getClass().getField("dis").getGenericType(); [EOL]         // Reporter.log( ( ( ParameterizedType ) disType [EOL]         // ).getOwnerType().getClass().toString() ); [EOL]         final Type datType = getClass().getField("dat").getGenericType(); [EOL]         final Type daType = getClass().getField("da").getGenericType(); [EOL]         final Type uhderType = getClass().getField("uhder").getGenericType(); [EOL]         final Type dingType = getClass().getField("ding").getGenericType(); [EOL]         final Type testerType = getClass().getField("tester").getGenericType(); [EOL]         final Type tester2Type = getClass().getField("tester2").getGenericType(); [EOL]         final Type dat2Type = getClass().getField("dat2").getGenericType(); [EOL]         final Type dat3Type = getClass().getField("dat3").getGenericType(); [EOL]         dis = dat; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(datType, disType)); [EOL]         // dis = da; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(daType, disType)); [EOL]         dis = uhder; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(uhderType, disType)); [EOL]         dis = ding; [EOL]         Assert.assertFalse(String.format("type %s not assignable to %s!", dingType, disType), [EOL]                 TypeUtils.isAssignable(dingType, disType)); [EOL]         dis = tester; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(testerType, disType)); [EOL]         // dis = tester2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(tester2Type, disType)); [EOL]         // dat = dat2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat2Type, datType)); [EOL]         // dat2 = dat; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(datType, dat2Type)); [EOL]         // dat = dat3; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat3Type, datType)); [EOL]         final char ch = 0; [EOL]         final boolean bo = false; [EOL]         final byte by = 0; [EOL]         final short sh = 0; [EOL]         int in = 0; [EOL]         long lo = 0; [EOL]         final float fl = 0; [EOL]         double du = 0; [EOL]         du = ch; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(char.class, double.class)); [EOL]         du = by; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(byte.class, double.class)); [EOL]         du = sh; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(short.class, double.class)); [EOL]         du = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, double.class)); [EOL]         du = lo; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(long.class, double.class)); [EOL]         du = fl; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(float.class, double.class)); [EOL]         lo = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, long.class)); [EOL]         lo = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, long.class)); [EOL]         // Long lngW = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, Long.class)); [EOL]         // lngW = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, Long.class)); [EOL]         in = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, int.class)); [EOL]         final Integer inte = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Integer.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Number.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Object.class)); [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, intComparableType)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Comparable.class)); [EOL]         final Serializable ser = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Serializable.class)); [EOL]         final Type longComparableType = getClass().getField("longComparable").getGenericType(); [EOL]         // longComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, longComparableType)); [EOL]         // longComparable = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, longComparableType)); [EOL]         // int[] ia; [EOL]         // long[] la = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, long[].class)); [EOL]         final Integer[] ia = null; [EOL]         final Type caType = getClass().getField("intWildcardComparable").getGenericType(); [EOL]         intWildcardComparable = ia; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, caType)); [EOL]         // int[] ina = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer[].class, int[].class)); [EOL]         final int[] ina = null; [EOL]         Object[] oa; [EOL]         // oa = ina; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, Object[].class)); [EOL]         oa = new Integer[0]; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, Object[].class)); [EOL]         final Type bClassType = AClass.class.getField("bClass").getGenericType(); [EOL]         final Type cClassType = AClass.class.getField("cClass").getGenericType(); [EOL]         final Type dClassType = AClass.class.getField("dClass").getGenericType(); [EOL]         final Type eClassType = AClass.class.getField("eClass").getGenericType(); [EOL]         final Type fClassType = AClass.class.getField("fClass").getGenericType(); [EOL]         final AClass aClass = new AClass(new AAClass<String>()); [EOL]         aClass.bClass = aClass.cClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(cClassType, bClassType)); [EOL]         aClass.bClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, bClassType)); [EOL]         aClass.bClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, bClassType)); [EOL]         aClass.bClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, bClassType)); [EOL]         aClass.cClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, cClassType)); [EOL]         aClass.cClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, cClassType)); [EOL]         aClass.cClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, cClassType)); [EOL]         aClass.dClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, dClassType)); [EOL]         aClass.dClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, dClassType)); [EOL]         aClass.eClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, eClassType)); [EOL]     } [EOL]  [EOL]     public void delegateBooleanAssertion(final Type[] types, final int i2, final int i1, final boolean expected) { [EOL]         final Type type1 = types[i1]; [EOL]         final Type type2 = types[i2]; [EOL]         final boolean isAssignable = TypeUtils.isAssignable(type2, type1); [EOL]  [EOL]         if (expected) { [EOL]             Assert.assertTrue("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } else { [EOL]             Assert.assertFalse("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } [EOL]     } [EOL]  [EOL]     @SuppressWarnings("boxing") // boxing is deliberate here [EOL]
@Test [EOL]     public void testIsInstance() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isInstance(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isInstance(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsInstance() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isInstance(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isInstance(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsInstance() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isInstance(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isInstance(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsInstance() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isInstance(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isInstance(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsInstance() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isInstance(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isInstance(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsInstance() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isInstance(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isInstance(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsInstance() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isInstance(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isInstance(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsInstance() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isInstance(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isInstance(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsInstance() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isInstance(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isInstance(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsInstance() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isInstance(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isInstance(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsInstance() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isInstance(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isInstance(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsInstance() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isInstance(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isInstance(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [EOL]         final Type[] types = method.getGenericParameterTypes(); [EOL] //        list0 = list0; [EOL]         delegateBooleanAssertion(types, 0, 0, true); [EOL]         list1 = list0; [EOL]         delegateBooleanAssertion(types, 0, 1, true); [EOL]         list0 = list1; [EOL]         delegateBooleanAssertion(types, 1, 0, true); [EOL]         list2 = list0; [EOL]         delegateBooleanAssertion(types, 0, 2, true); [EOL]         list0 = list2; [EOL]         delegateBooleanAssertion(types, 2, 0, true); [EOL]         list3 = list0; [EOL]         delegateBooleanAssertion(types, 0, 3, true); [EOL]         list0 = list3; [EOL]         delegateBooleanAssertion(types, 3, 0, true); [EOL]         list4 = list0; [EOL]         delegateBooleanAssertion(types, 0, 4, true); [EOL]         list0 = list4; [EOL]         delegateBooleanAssertion(types, 4, 0, true); [EOL]         list5 = list0; [EOL]         delegateBooleanAssertion(types, 0, 5, true); [EOL]         list0 = list5; [EOL]         delegateBooleanAssertion(types, 5, 0, true); [EOL]         list6 = list0; [EOL]         delegateBooleanAssertion(types, 0, 6, true); [EOL]         list0 = list6; [EOL]         delegateBooleanAssertion(types, 6, 0, true); [EOL] //        list1 = list1; [EOL]         delegateBooleanAssertion(types, 1, 1, true); [EOL]         list2 = list1; [EOL]         delegateBooleanAssertion(types, 1, 2, true); [EOL]         list1 = (List<Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 1, false); [EOL]         list3 = list1; [EOL]         delegateBooleanAssertion(types, 1, 3, true); [EOL]         list1 = (List<Object>) list3; [EOL]         delegateBooleanAssertion(types, 3, 1, false); [EOL]         // list4 = list1; [EOL]         delegateBooleanAssertion(types, 1, 4, false); [EOL]         // list1 = list4; [EOL]         delegateBooleanAssertion(types, 4, 1, false); [EOL]         // list5 = list1; [EOL]         delegateBooleanAssertion(types, 1, 5, false); [EOL]         // list1 = list5; [EOL]         delegateBooleanAssertion(types, 5, 1, false); [EOL]         list6 = list1; [EOL]         delegateBooleanAssertion(types, 1, 6, true); [EOL]         list1 = (List<Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 1, false); [EOL] //        list2 = list2; [EOL]         delegateBooleanAssertion(types, 2, 2, true); [EOL]         list2 = list3; [EOL]         delegateBooleanAssertion(types, 2, 3, false); [EOL]         list2 = list4; [EOL]         delegateBooleanAssertion(types, 3, 2, true); [EOL]         list3 = (List<? super Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 4, false); [EOL]         list2 = list5; [EOL]         delegateBooleanAssertion(types, 4, 2, true); [EOL]         list4 = (List<String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 5, false); [EOL]         list2 = list6; [EOL]         delegateBooleanAssertion(types, 5, 2, true); [EOL]         list5 = (List<? extends String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 6, false); [EOL] //        list3 = list3; [EOL]         delegateBooleanAssertion(types, 6, 2, true); [EOL]         list6 = (List<? super String>) list2; [EOL]         delegateBooleanAssertion(types, 3, 3, true); [EOL]         // list4 = list3; [EOL]         delegateBooleanAssertion(types, 3, 4, false); [EOL]         // list3 = list4; [EOL]         delegateBooleanAssertion(types, 4, 3, false); [EOL]         // list5 = list3; [EOL]         delegateBooleanAssertion(types, 3, 5, false); [EOL]         // list3 = list5; [EOL]         delegateBooleanAssertion(types, 5, 3, false); [EOL]         list6 = list3; [EOL]         delegateBooleanAssertion(types, 3, 6, true); [EOL]         list3 = (List<? super Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 3, false); [EOL] //        list4 = list4; [EOL]         delegateBooleanAssertion(types, 4, 4, true); [EOL]         list5 = list4; [EOL]         delegateBooleanAssertion(types, 4, 5, true); [EOL]         list4 = (List<String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 4, false); [EOL]         list6 = list4; [EOL]         delegateBooleanAssertion(types, 4, 6, true); [EOL]         list4 = (List<String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 4, false); [EOL] //        list5 = list5; [EOL]         delegateBooleanAssertion(types, 5, 5, true); [EOL]         list6 = (List<? super String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 6, false); [EOL]         list5 = (List<? extends String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 5, false); [EOL] //        list6 = list6; [EOL]         delegateBooleanAssertion(types, 6, 6, true); [EOL]  [EOL] //        list7 = list7; [EOL]         delegateBooleanAssertion(types, 7, 7, true); [EOL]         list8 = list7; [EOL]         delegateBooleanAssertion(types, 7, 8, true); [EOL]         list7 = list8; [EOL]         delegateBooleanAssertion(types, 8, 7, true); [EOL]         list9 = list7; [EOL]         delegateBooleanAssertion(types, 7, 9, true); [EOL]         list7 = list9; [EOL]         delegateBooleanAssertion(types, 9, 7, true); [EOL]         list10 = list7; [EOL]         delegateBooleanAssertion(types, 7, 10, true); [EOL]         list7 = list10; [EOL]         delegateBooleanAssertion(types, 10, 7, true); [EOL]         list11 = list7; [EOL]         delegateBooleanAssertion(types, 7, 11, true); [EOL]         list7 = list11; [EOL]         delegateBooleanAssertion(types, 11, 7, true); [EOL]         list12 = list7; [EOL]         delegateBooleanAssertion(types, 7, 12, true); [EOL]         list7 = list12; [EOL]         delegateBooleanAssertion(types, 12, 7, true); [EOL]         list13 = list7; [EOL]         delegateBooleanAssertion(types, 7, 13, true); [EOL]         list7 = list13; [EOL]         delegateBooleanAssertion(types, 13, 7, true); [EOL] //        list8 = list8; [EOL]         delegateBooleanAssertion(types, 8, 8, true); [EOL]         list9 = list8; [EOL]         delegateBooleanAssertion(types, 8, 9, true); [EOL]         list8 = (List<Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 8, false); [EOL]         list10 = list8; [EOL]         delegateBooleanAssertion(types, 8, 10, true); [EOL]         list8 = (List<Object>[]) list10; // NOTE cast is required by Sun Java, but not by Eclipse [EOL]         delegateBooleanAssertion(types, 10, 8, false); [EOL]         // list11 = list8; [EOL]         delegateBooleanAssertion(types, 8, 11, false); [EOL]         // list8 = list11; [EOL]         delegateBooleanAssertion(types, 11, 8, false); [EOL]         // list12 = list8; [EOL]         delegateBooleanAssertion(types, 8, 12, false); [EOL]         // list8 = list12; [EOL]         delegateBooleanAssertion(types, 12, 8, false); [EOL]         list13 = list8; [EOL]         delegateBooleanAssertion(types, 8, 13, true); [EOL]         list8 = (List<Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 8, false); [EOL] //        list9 = list9; [EOL]         delegateBooleanAssertion(types, 9, 9, true); [EOL]         list10 = (List<? super Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 10, false); [EOL]         list9 = list10; [EOL]         delegateBooleanAssertion(types, 10, 9, true); [EOL]         list11 = (List<String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 11, false); [EOL]         list9 = list11; [EOL]         delegateBooleanAssertion(types, 11, 9, true); [EOL]         list12 = (List<? extends String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 12, false); [EOL]         list9 = list12; [EOL]         delegateBooleanAssertion(types, 12, 9, true); [EOL]         list13 = (List<? super String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 13, false); [EOL]         list9 = list13; [EOL]         delegateBooleanAssertion(types, 13, 9, true); [EOL] //        list10 = list10; [EOL]         delegateBooleanAssertion(types, 10, 10, true); [EOL]         // list11 = list10; [EOL]         delegateBooleanAssertion(types, 10, 11, false); [EOL]         // list10 = list11; [EOL]         delegateBooleanAssertion(types, 11, 10, false); [EOL]         // list12 = list10; [EOL]         delegateBooleanAssertion(types, 10, 12, false); [EOL]         // list10 = list12; [EOL]         delegateBooleanAssertion(types, 12, 10, false); [EOL]         list13 = list10; [EOL]         delegateBooleanAssertion(types, 10, 13, true); [EOL]         list10 = (List<? super Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 10, false); [EOL] //        list11 = list11; [EOL]         delegateBooleanAssertion(types, 11, 11, true); [EOL]         list12 = list11; [EOL]         delegateBooleanAssertion(types, 11, 12, true); [EOL]         list11 = (List<String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 11, false); [EOL]         list13 = list11; [EOL]         delegateBooleanAssertion(types, 11, 13, true); [EOL]         list11 = (List<String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 11, false); [EOL] //        list12 = list12; [EOL]         delegateBooleanAssertion(types, 12, 12, true); [EOL]         list13 = (List<? super String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 13, false); [EOL]         list12 = (List<? extends String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 12, false); [EOL] //        list13 = list13; [EOL]         delegateBooleanAssertion(types, 13, 13, true); [EOL]         final Type disType = getClass().getField("dis").getGenericType(); [EOL]         // Reporter.log( ( ( ParameterizedType ) disType [EOL]         // ).getOwnerType().getClass().toString() ); [EOL]         final Type datType = getClass().getField("dat").getGenericType(); [EOL]         final Type daType = getClass().getField("da").getGenericType(); [EOL]         final Type uhderType = getClass().getField("uhder").getGenericType(); [EOL]         final Type dingType = getClass().getField("ding").getGenericType(); [EOL]         final Type testerType = getClass().getField("tester").getGenericType(); [EOL]         final Type tester2Type = getClass().getField("tester2").getGenericType(); [EOL]         final Type dat2Type = getClass().getField("dat2").getGenericType(); [EOL]         final Type dat3Type = getClass().getField("dat3").getGenericType(); [EOL]         dis = dat; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(datType, disType)); [EOL]         // dis = da; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(daType, disType)); [EOL]         dis = uhder; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(uhderType, disType)); [EOL]         dis = ding; [EOL]         Assert.assertFalse(String.format("type %s not assignable to %s!", dingType, disType), [EOL]                 TypeUtils.isAssignable(dingType, disType)); [EOL]         dis = tester; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(testerType, disType)); [EOL]         // dis = tester2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(tester2Type, disType)); [EOL]         // dat = dat2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat2Type, datType)); [EOL]         // dat2 = dat; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(datType, dat2Type)); [EOL]         // dat = dat3; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat3Type, datType)); [EOL]         final char ch = 0; [EOL]         final boolean bo = false; [EOL]         final byte by = 0; [EOL]         final short sh = 0; [EOL]         int in = 0; [EOL]         long lo = 0; [EOL]         final float fl = 0; [EOL]         double du = 0; [EOL]         du = ch; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(char.class, double.class)); [EOL]         du = by; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(byte.class, double.class)); [EOL]         du = sh; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(short.class, double.class)); [EOL]         du = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, double.class)); [EOL]         du = lo; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(long.class, double.class)); [EOL]         du = fl; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(float.class, double.class)); [EOL]         lo = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, long.class)); [EOL]         lo = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, long.class)); [EOL]         // Long lngW = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, Long.class)); [EOL]         // lngW = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, Long.class)); [EOL]         in = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, int.class)); [EOL]         final Integer inte = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Integer.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Number.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Object.class)); [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, intComparableType)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Comparable.class)); [EOL]         final Serializable ser = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Serializable.class)); [EOL]         final Type longComparableType = getClass().getField("longComparable").getGenericType(); [EOL]         // longComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, longComparableType)); [EOL]         // longComparable = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, longComparableType)); [EOL]         // int[] ia; [EOL]         // long[] la = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, long[].class)); [EOL]         final Integer[] ia = null; [EOL]         final Type caType = getClass().getField("intWildcardComparable").getGenericType(); [EOL]         intWildcardComparable = ia; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, caType)); [EOL]         // int[] ina = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer[].class, int[].class)); [EOL]         final int[] ina = null; [EOL]         Object[] oa; [EOL]         // oa = ina; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, Object[].class)); [EOL]         oa = new Integer[0]; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, Object[].class)); [EOL]         final Type bClassType = AClass.class.getField("bClass").getGenericType(); [EOL]         final Type cClassType = AClass.class.getField("cClass").getGenericType(); [EOL]         final Type dClassType = AClass.class.getField("dClass").getGenericType(); [EOL]         final Type eClassType = AClass.class.getField("eClass").getGenericType(); [EOL]         final Type fClassType = AClass.class.getField("fClass").getGenericType(); [EOL]         final AClass aClass = new AClass(new AAClass<String>()); [EOL]         aClass.bClass = aClass.cClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(cClassType, bClassType)); [EOL]         aClass.bClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, bClassType)); [EOL]         aClass.bClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, bClassType)); [EOL]         aClass.bClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, bClassType)); [EOL]         aClass.cClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, cClassType)); [EOL]         aClass.cClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, cClassType)); [EOL]         aClass.cClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, cClassType)); [EOL]         aClass.dClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, dClassType)); [EOL]         aClass.dClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, dClassType)); [EOL]         aClass.eClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, eClassType)); [EOL]     } [EOL]  [EOL]     public void delegateBooleanAssertion(final Type[] types, final int i2, final int i1, final boolean expected) { [EOL]         final Type type1 = types[i1]; [EOL]         final Type type2 = types[i2]; [EOL]         final boolean isAssignable = TypeUtils.isAssignable(type2, type1); [EOL]  [EOL]         if (expected) { [EOL]             Assert.assertTrue("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } else { [EOL]             Assert.assertFalse("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } [EOL]     } [EOL]  [EOL]     @SuppressWarnings("boxing") // boxing is deliberate here [EOL]
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [EOL]         final Type[] types = method.getGenericParameterTypes(); [EOL] //        list0 = list0; [EOL]         delegateBooleanAssertion(types, 0, 0, true); [EOL]         list1 = list0; [EOL]         delegateBooleanAssertion(types, 0, 1, true); [EOL]         list0 = list1; [EOL]         delegateBooleanAssertion(types, 1, 0, true); [EOL]         list2 = list0; [EOL]         delegateBooleanAssertion(types, 0, 2, true); [EOL]         list0 = list2; [EOL]         delegateBooleanAssertion(types, 2, 0, true); [EOL]         list3 = list0; [EOL]         delegateBooleanAssertion(types, 0, 3, true); [EOL]         list0 = list3; [EOL]         delegateBooleanAssertion(types, 3, 0, true); [EOL]         list4 = list0; [EOL]         delegateBooleanAssertion(types, 0, 4, true); [EOL]         list0 = list4; [EOL]         delegateBooleanAssertion(types, 4, 0, true); [EOL]         list5 = list0; [EOL]         delegateBooleanAssertion(types, 0, 5, true); [EOL]         list0 = list5; [EOL]         delegateBooleanAssertion(types, 5, 0, true); [EOL]         list6 = list0; [EOL]         delegateBooleanAssertion(types, 0, 6, true); [EOL]         list0 = list6; [EOL]         delegateBooleanAssertion(types, 6, 0, true); [EOL] //        list1 = list1; [EOL]         delegateBooleanAssertion(types, 1, 1, true); [EOL]         list2 = list1; [EOL]         delegateBooleanAssertion(types, 1, 2, true); [EOL]         list1 = (List<Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 1, false); [EOL]         list3 = list1; [EOL]         delegateBooleanAssertion(types, 1, 3, true); [EOL]         list1 = (List<Object>) list3; [EOL]         delegateBooleanAssertion(types, 3, 1, false); [EOL]         // list4 = list1; [EOL]         delegateBooleanAssertion(types, 1, 4, false); [EOL]         // list1 = list4; [EOL]         delegateBooleanAssertion(types, 4, 1, false); [EOL]         // list5 = list1; [EOL]         delegateBooleanAssertion(types, 1, 5, false); [EOL]         // list1 = list5; [EOL]         delegateBooleanAssertion(types, 5, 1, false); [EOL]         list6 = list1; [EOL]         delegateBooleanAssertion(types, 1, 6, true); [EOL]         list1 = (List<Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 1, false); [EOL] //        list2 = list2; [EOL]         delegateBooleanAssertion(types, 2, 2, true); [EOL]         list2 = list3; [EOL]         delegateBooleanAssertion(types, 2, 3, false); [EOL]         list2 = list4; [EOL]         delegateBooleanAssertion(types, 3, 2, true); [EOL]         list3 = (List<? super Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 4, false); [EOL]         list2 = list5; [EOL]         delegateBooleanAssertion(types, 4, 2, true); [EOL]         list4 = (List<String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 5, false); [EOL]         list2 = list6; [EOL]         delegateBooleanAssertion(types, 5, 2, true); [EOL]         list5 = (List<? extends String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 6, false); [EOL] //        list3 = list3; [EOL]         delegateBooleanAssertion(types, 6, 2, true); [EOL]         list6 = (List<? super String>) list2; [EOL]         delegateBooleanAssertion(types, 3, 3, true); [EOL]         // list4 = list3; [EOL]         delegateBooleanAssertion(types, 3, 4, false); [EOL]         // list3 = list4; [EOL]         delegateBooleanAssertion(types, 4, 3, false); [EOL]         // list5 = list3; [EOL]         delegateBooleanAssertion(types, 3, 5, false); [EOL]         // list3 = list5; [EOL]         delegateBooleanAssertion(types, 5, 3, false); [EOL]         list6 = list3; [EOL]         delegateBooleanAssertion(types, 3, 6, true); [EOL]         list3 = (List<? super Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 3, false); [EOL] //        list4 = list4; [EOL]         delegateBooleanAssertion(types, 4, 4, true); [EOL]         list5 = list4; [EOL]         delegateBooleanAssertion(types, 4, 5, true); [EOL]         list4 = (List<String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 4, false); [EOL]         list6 = list4; [EOL]         delegateBooleanAssertion(types, 4, 6, true); [EOL]         list4 = (List<String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 4, false); [EOL] //        list5 = list5; [EOL]         delegateBooleanAssertion(types, 5, 5, true); [EOL]         list6 = (List<? super String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 6, false); [EOL]         list5 = (List<? extends String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 5, false); [EOL] //        list6 = list6; [EOL]         delegateBooleanAssertion(types, 6, 6, true); [EOL]  [EOL] //        list7 = list7; [EOL]         delegateBooleanAssertion(types, 7, 7, true); [EOL]         list8 = list7; [EOL]         delegateBooleanAssertion(types, 7, 8, true); [EOL]         list7 = list8; [EOL]         delegateBooleanAssertion(types, 8, 7, true); [EOL]         list9 = list7; [EOL]         delegateBooleanAssertion(types, 7, 9, true); [EOL]         list7 = list9; [EOL]         delegateBooleanAssertion(types, 9, 7, true); [EOL]         list10 = list7; [EOL]         delegateBooleanAssertion(types, 7, 10, true); [EOL]         list7 = list10; [EOL]         delegateBooleanAssertion(types, 10, 7, true); [EOL]         list11 = list7; [EOL]         delegateBooleanAssertion(types, 7, 11, true); [EOL]         list7 = list11; [EOL]         delegateBooleanAssertion(types, 11, 7, true); [EOL]         list12 = list7; [EOL]         delegateBooleanAssertion(types, 7, 12, true); [EOL]         list7 = list12; [EOL]         delegateBooleanAssertion(types, 12, 7, true); [EOL]         list13 = list7; [EOL]         delegateBooleanAssertion(types, 7, 13, true); [EOL]         list7 = list13; [EOL]         delegateBooleanAssertion(types, 13, 7, true); [EOL] //        list8 = list8; [EOL]         delegateBooleanAssertion(types, 8, 8, true); [EOL]         list9 = list8; [EOL]         delegateBooleanAssertion(types, 8, 9, true); [EOL]         list8 = (List<Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 8, false); [EOL]         list10 = list8; [EOL]         delegateBooleanAssertion(types, 8, 10, true); [EOL]         list8 = (List<Object>[]) list10; // NOTE cast is required by Sun Java, but not by Eclipse [EOL]         delegateBooleanAssertion(types, 10, 8, false); [EOL]         // list11 = list8; [EOL]         delegateBooleanAssertion(types, 8, 11, false); [EOL]         // list8 = list11; [EOL]         delegateBooleanAssertion(types, 11, 8, false); [EOL]         // list12 = list8; [EOL]         delegateBooleanAssertion(types, 8, 12, false); [EOL]         // list8 = list12; [EOL]         delegateBooleanAssertion(types, 12, 8, false); [EOL]         list13 = list8; [EOL]         delegateBooleanAssertion(types, 8, 13, true); [EOL]         list8 = (List<Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 8, false); [EOL] //        list9 = list9; [EOL]         delegateBooleanAssertion(types, 9, 9, true); [EOL]         list10 = (List<? super Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 10, false); [EOL]         list9 = list10; [EOL]         delegateBooleanAssertion(types, 10, 9, true); [EOL]         list11 = (List<String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 11, false); [EOL]         list9 = list11; [EOL]         delegateBooleanAssertion(types, 11, 9, true); [EOL]         list12 = (List<? extends String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 12, false); [EOL]         list9 = list12; [EOL]         delegateBooleanAssertion(types, 12, 9, true); [EOL]         list13 = (List<? super String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 13, false); [EOL]         list9 = list13; [EOL]         delegateBooleanAssertion(types, 13, 9, true); [EOL] //        list10 = list10; [EOL]         delegateBooleanAssertion(types, 10, 10, true); [EOL]         // list11 = list10; [EOL]         delegateBooleanAssertion(types, 10, 11, false); [EOL]         // list10 = list11; [EOL]         delegateBooleanAssertion(types, 11, 10, false); [EOL]         // list12 = list10; [EOL]         delegateBooleanAssertion(types, 10, 12, false); [EOL]         // list10 = list12; [EOL]         delegateBooleanAssertion(types, 12, 10, false); [EOL]         list13 = list10; [EOL]         delegateBooleanAssertion(types, 10, 13, true); [EOL]         list10 = (List<? super Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 10, false); [EOL] //        list11 = list11; [EOL]         delegateBooleanAssertion(types, 11, 11, true); [EOL]         list12 = list11; [EOL]         delegateBooleanAssertion(types, 11, 12, true); [EOL]         list11 = (List<String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 11, false); [EOL]         list13 = list11; [EOL]         delegateBooleanAssertion(types, 11, 13, true); [EOL]         list11 = (List<String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 11, false); [EOL] //        list12 = list12; [EOL]         delegateBooleanAssertion(types, 12, 12, true); [EOL]         list13 = (List<? super String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 13, false); [EOL]         list12 = (List<? extends String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 12, false); [EOL] //        list13 = list13; [EOL]         delegateBooleanAssertion(types, 13, 13, true); [EOL]         final Type disType = getClass().getField("dis").getGenericType(); [EOL]         // Reporter.log( ( ( ParameterizedType ) disType [EOL]         // ).getOwnerType().getClass().toString() ); [EOL]         final Type datType = getClass().getField("dat").getGenericType(); [EOL]         final Type daType = getClass().getField("da").getGenericType(); [EOL]         final Type uhderType = getClass().getField("uhder").getGenericType(); [EOL]         final Type dingType = getClass().getField("ding").getGenericType(); [EOL]         final Type testerType = getClass().getField("tester").getGenericType(); [EOL]         final Type tester2Type = getClass().getField("tester2").getGenericType(); [EOL]         final Type dat2Type = getClass().getField("dat2").getGenericType(); [EOL]         final Type dat3Type = getClass().getField("dat3").getGenericType(); [EOL]         dis = dat; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(datType, disType)); [EOL]         // dis = da; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(daType, disType)); [EOL]         dis = uhder; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(uhderType, disType)); [EOL]         dis = ding; [EOL]         Assert.assertFalse(String.format("type %s not assignable to %s!", dingType, disType), [EOL]                 TypeUtils.isAssignable(dingType, disType)); [EOL]         dis = tester; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(testerType, disType)); [EOL]         // dis = tester2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(tester2Type, disType)); [EOL]         // dat = dat2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat2Type, datType)); [EOL]         // dat2 = dat; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(datType, dat2Type)); [EOL]         // dat = dat3; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat3Type, datType)); [EOL]         final char ch = 0; [EOL]         final boolean bo = false; [EOL]         final byte by = 0; [EOL]         final short sh = 0; [EOL]         int in = 0; [EOL]         long lo = 0; [EOL]         final float fl = 0; [EOL]         double du = 0; [EOL]         du = ch; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(char.class, double.class)); [EOL]         du = by; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(byte.class, double.class)); [EOL]         du = sh; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(short.class, double.class)); [EOL]         du = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, double.class)); [EOL]         du = lo; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(long.class, double.class)); [EOL]         du = fl; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(float.class, double.class)); [EOL]         lo = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, long.class)); [EOL]         lo = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, long.class)); [EOL]         // Long lngW = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, Long.class)); [EOL]         // lngW = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, Long.class)); [EOL]         in = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, int.class)); [EOL]         final Integer inte = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Integer.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Number.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Object.class)); [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, intComparableType)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Comparable.class)); [EOL]         final Serializable ser = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Serializable.class)); [EOL]         final Type longComparableType = getClass().getField("longComparable").getGenericType(); [EOL]         // longComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, longComparableType)); [EOL]         // longComparable = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, longComparableType)); [EOL]         // int[] ia; [EOL]         // long[] la = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, long[].class)); [EOL]         final Integer[] ia = null; [EOL]         final Type caType = getClass().getField("intWildcardComparable").getGenericType(); [EOL]         intWildcardComparable = ia; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, caType)); [EOL]         // int[] ina = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer[].class, int[].class)); [EOL]         final int[] ina = null; [EOL]         Object[] oa; [EOL]         // oa = ina; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, Object[].class)); [EOL]         oa = new Integer[0]; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, Object[].class)); [EOL]         final Type bClassType = AClass.class.getField("bClass").getGenericType(); [EOL]         final Type cClassType = AClass.class.getField("cClass").getGenericType(); [EOL]         final Type dClassType = AClass.class.getField("dClass").getGenericType(); [EOL]         final Type eClassType = AClass.class.getField("eClass").getGenericType(); [EOL]         final Type fClassType = AClass.class.getField("fClass").getGenericType(); [EOL]         final AClass aClass = new AClass(new AAClass<String>()); [EOL]         aClass.bClass = aClass.cClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(cClassType, bClassType)); [EOL]         aClass.bClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, bClassType)); [EOL]         aClass.bClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, bClassType)); [EOL]         aClass.bClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, bClassType)); [EOL]         aClass.cClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, cClassType)); [EOL]         aClass.cClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, cClassType)); [EOL]         aClass.cClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, cClassType)); [EOL]         aClass.dClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, dClassType)); [EOL]         aClass.dClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, dClassType)); [EOL]         aClass.eClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, eClassType)); [EOL]     } [EOL]  [EOL]     public void delegateBooleanAssertion(final Type[] types, final int i2, final int i1, final boolean expected) { [EOL]         final Type type1 = types[i1]; [EOL]         final Type type2 = types[i2]; [EOL]         final boolean isAssignable = TypeUtils.isAssignable(type2, type1); [EOL]  [EOL]         if (expected) { [EOL]             Assert.assertTrue("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } else { [EOL]             Assert.assertFalse("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } [EOL]     } [EOL]  [EOL]     @SuppressWarnings("boxing") // boxing is deliberate here [EOL]
@Test [EOL]     public void testIsInstance() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isInstance(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isInstance(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsInstance() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isInstance(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isInstance(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [EOL]         final Type[] types = method.getGenericParameterTypes(); [EOL] //        list0 = list0; [EOL]         delegateBooleanAssertion(types, 0, 0, true); [EOL]         list1 = list0; [EOL]         delegateBooleanAssertion(types, 0, 1, true); [EOL]         list0 = list1; [EOL]         delegateBooleanAssertion(types, 1, 0, true); [EOL]         list2 = list0; [EOL]         delegateBooleanAssertion(types, 0, 2, true); [EOL]         list0 = list2; [EOL]         delegateBooleanAssertion(types, 2, 0, true); [EOL]         list3 = list0; [EOL]         delegateBooleanAssertion(types, 0, 3, true); [EOL]         list0 = list3; [EOL]         delegateBooleanAssertion(types, 3, 0, true); [EOL]         list4 = list0; [EOL]         delegateBooleanAssertion(types, 0, 4, true); [EOL]         list0 = list4; [EOL]         delegateBooleanAssertion(types, 4, 0, true); [EOL]         list5 = list0; [EOL]         delegateBooleanAssertion(types, 0, 5, true); [EOL]         list0 = list5; [EOL]         delegateBooleanAssertion(types, 5, 0, true); [EOL]         list6 = list0; [EOL]         delegateBooleanAssertion(types, 0, 6, true); [EOL]         list0 = list6; [EOL]         delegateBooleanAssertion(types, 6, 0, true); [EOL] //        list1 = list1; [EOL]         delegateBooleanAssertion(types, 1, 1, true); [EOL]         list2 = list1; [EOL]         delegateBooleanAssertion(types, 1, 2, true); [EOL]         list1 = (List<Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 1, false); [EOL]         list3 = list1; [EOL]         delegateBooleanAssertion(types, 1, 3, true); [EOL]         list1 = (List<Object>) list3; [EOL]         delegateBooleanAssertion(types, 3, 1, false); [EOL]         // list4 = list1; [EOL]         delegateBooleanAssertion(types, 1, 4, false); [EOL]         // list1 = list4; [EOL]         delegateBooleanAssertion(types, 4, 1, false); [EOL]         // list5 = list1; [EOL]         delegateBooleanAssertion(types, 1, 5, false); [EOL]         // list1 = list5; [EOL]         delegateBooleanAssertion(types, 5, 1, false); [EOL]         list6 = list1; [EOL]         delegateBooleanAssertion(types, 1, 6, true); [EOL]         list1 = (List<Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 1, false); [EOL] //        list2 = list2; [EOL]         delegateBooleanAssertion(types, 2, 2, true); [EOL]         list2 = list3; [EOL]         delegateBooleanAssertion(types, 2, 3, false); [EOL]         list2 = list4; [EOL]         delegateBooleanAssertion(types, 3, 2, true); [EOL]         list3 = (List<? super Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 4, false); [EOL]         list2 = list5; [EOL]         delegateBooleanAssertion(types, 4, 2, true); [EOL]         list4 = (List<String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 5, false); [EOL]         list2 = list6; [EOL]         delegateBooleanAssertion(types, 5, 2, true); [EOL]         list5 = (List<? extends String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 6, false); [EOL] //        list3 = list3; [EOL]         delegateBooleanAssertion(types, 6, 2, true); [EOL]         list6 = (List<? super String>) list2; [EOL]         delegateBooleanAssertion(types, 3, 3, true); [EOL]         // list4 = list3; [EOL]         delegateBooleanAssertion(types, 3, 4, false); [EOL]         // list3 = list4; [EOL]         delegateBooleanAssertion(types, 4, 3, false); [EOL]         // list5 = list3; [EOL]         delegateBooleanAssertion(types, 3, 5, false); [EOL]         // list3 = list5; [EOL]         delegateBooleanAssertion(types, 5, 3, false); [EOL]         list6 = list3; [EOL]         delegateBooleanAssertion(types, 3, 6, true); [EOL]         list3 = (List<? super Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 3, false); [EOL] //        list4 = list4; [EOL]         delegateBooleanAssertion(types, 4, 4, true); [EOL]         list5 = list4; [EOL]         delegateBooleanAssertion(types, 4, 5, true); [EOL]         list4 = (List<String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 4, false); [EOL]         list6 = list4; [EOL]         delegateBooleanAssertion(types, 4, 6, true); [EOL]         list4 = (List<String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 4, false); [EOL] //        list5 = list5; [EOL]         delegateBooleanAssertion(types, 5, 5, true); [EOL]         list6 = (List<? super String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 6, false); [EOL]         list5 = (List<? extends String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 5, false); [EOL] //        list6 = list6; [EOL]         delegateBooleanAssertion(types, 6, 6, true); [EOL]  [EOL] //        list7 = list7; [EOL]         delegateBooleanAssertion(types, 7, 7, true); [EOL]         list8 = list7; [EOL]         delegateBooleanAssertion(types, 7, 8, true); [EOL]         list7 = list8; [EOL]         delegateBooleanAssertion(types, 8, 7, true); [EOL]         list9 = list7; [EOL]         delegateBooleanAssertion(types, 7, 9, true); [EOL]         list7 = list9; [EOL]         delegateBooleanAssertion(types, 9, 7, true); [EOL]         list10 = list7; [EOL]         delegateBooleanAssertion(types, 7, 10, true); [EOL]         list7 = list10; [EOL]         delegateBooleanAssertion(types, 10, 7, true); [EOL]         list11 = list7; [EOL]         delegateBooleanAssertion(types, 7, 11, true); [EOL]         list7 = list11; [EOL]         delegateBooleanAssertion(types, 11, 7, true); [EOL]         list12 = list7; [EOL]         delegateBooleanAssertion(types, 7, 12, true); [EOL]         list7 = list12; [EOL]         delegateBooleanAssertion(types, 12, 7, true); [EOL]         list13 = list7; [EOL]         delegateBooleanAssertion(types, 7, 13, true); [EOL]         list7 = list13; [EOL]         delegateBooleanAssertion(types, 13, 7, true); [EOL] //        list8 = list8; [EOL]         delegateBooleanAssertion(types, 8, 8, true); [EOL]         list9 = list8; [EOL]         delegateBooleanAssertion(types, 8, 9, true); [EOL]         list8 = (List<Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 8, false); [EOL]         list10 = list8; [EOL]         delegateBooleanAssertion(types, 8, 10, true); [EOL]         list8 = (List<Object>[]) list10; // NOTE cast is required by Sun Java, but not by Eclipse [EOL]         delegateBooleanAssertion(types, 10, 8, false); [EOL]         // list11 = list8; [EOL]         delegateBooleanAssertion(types, 8, 11, false); [EOL]         // list8 = list11; [EOL]         delegateBooleanAssertion(types, 11, 8, false); [EOL]         // list12 = list8; [EOL]         delegateBooleanAssertion(types, 8, 12, false); [EOL]         // list8 = list12; [EOL]         delegateBooleanAssertion(types, 12, 8, false); [EOL]         list13 = list8; [EOL]         delegateBooleanAssertion(types, 8, 13, true); [EOL]         list8 = (List<Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 8, false); [EOL] //        list9 = list9; [EOL]         delegateBooleanAssertion(types, 9, 9, true); [EOL]         list10 = (List<? super Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 10, false); [EOL]         list9 = list10; [EOL]         delegateBooleanAssertion(types, 10, 9, true); [EOL]         list11 = (List<String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 11, false); [EOL]         list9 = list11; [EOL]         delegateBooleanAssertion(types, 11, 9, true); [EOL]         list12 = (List<? extends String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 12, false); [EOL]         list9 = list12; [EOL]         delegateBooleanAssertion(types, 12, 9, true); [EOL]         list13 = (List<? super String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 13, false); [EOL]         list9 = list13; [EOL]         delegateBooleanAssertion(types, 13, 9, true); [EOL] //        list10 = list10; [EOL]         delegateBooleanAssertion(types, 10, 10, true); [EOL]         // list11 = list10; [EOL]         delegateBooleanAssertion(types, 10, 11, false); [EOL]         // list10 = list11; [EOL]         delegateBooleanAssertion(types, 11, 10, false); [EOL]         // list12 = list10; [EOL]         delegateBooleanAssertion(types, 10, 12, false); [EOL]         // list10 = list12; [EOL]         delegateBooleanAssertion(types, 12, 10, false); [EOL]         list13 = list10; [EOL]         delegateBooleanAssertion(types, 10, 13, true); [EOL]         list10 = (List<? super Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 10, false); [EOL] //        list11 = list11; [EOL]         delegateBooleanAssertion(types, 11, 11, true); [EOL]         list12 = list11; [EOL]         delegateBooleanAssertion(types, 11, 12, true); [EOL]         list11 = (List<String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 11, false); [EOL]         list13 = list11; [EOL]         delegateBooleanAssertion(types, 11, 13, true); [EOL]         list11 = (List<String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 11, false); [EOL] //        list12 = list12; [EOL]         delegateBooleanAssertion(types, 12, 12, true); [EOL]         list13 = (List<? super String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 13, false); [EOL]         list12 = (List<? extends String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 12, false); [EOL] //        list13 = list13; [EOL]         delegateBooleanAssertion(types, 13, 13, true); [EOL]         final Type disType = getClass().getField("dis").getGenericType(); [EOL]         // Reporter.log( ( ( ParameterizedType ) disType [EOL]         // ).getOwnerType().getClass().toString() ); [EOL]         final Type datType = getClass().getField("dat").getGenericType(); [EOL]         final Type daType = getClass().getField("da").getGenericType(); [EOL]         final Type uhderType = getClass().getField("uhder").getGenericType(); [EOL]         final Type dingType = getClass().getField("ding").getGenericType(); [EOL]         final Type testerType = getClass().getField("tester").getGenericType(); [EOL]         final Type tester2Type = getClass().getField("tester2").getGenericType(); [EOL]         final Type dat2Type = getClass().getField("dat2").getGenericType(); [EOL]         final Type dat3Type = getClass().getField("dat3").getGenericType(); [EOL]         dis = dat; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(datType, disType)); [EOL]         // dis = da; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(daType, disType)); [EOL]         dis = uhder; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(uhderType, disType)); [EOL]         dis = ding; [EOL]         Assert.assertFalse(String.format("type %s not assignable to %s!", dingType, disType), [EOL]                 TypeUtils.isAssignable(dingType, disType)); [EOL]         dis = tester; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(testerType, disType)); [EOL]         // dis = tester2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(tester2Type, disType)); [EOL]         // dat = dat2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat2Type, datType)); [EOL]         // dat2 = dat; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(datType, dat2Type)); [EOL]         // dat = dat3; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat3Type, datType)); [EOL]         final char ch = 0; [EOL]         final boolean bo = false; [EOL]         final byte by = 0; [EOL]         final short sh = 0; [EOL]         int in = 0; [EOL]         long lo = 0; [EOL]         final float fl = 0; [EOL]         double du = 0; [EOL]         du = ch; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(char.class, double.class)); [EOL]         du = by; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(byte.class, double.class)); [EOL]         du = sh; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(short.class, double.class)); [EOL]         du = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, double.class)); [EOL]         du = lo; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(long.class, double.class)); [EOL]         du = fl; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(float.class, double.class)); [EOL]         lo = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, long.class)); [EOL]         lo = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, long.class)); [EOL]         // Long lngW = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, Long.class)); [EOL]         // lngW = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, Long.class)); [EOL]         in = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, int.class)); [EOL]         final Integer inte = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Integer.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Number.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Object.class)); [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, intComparableType)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Comparable.class)); [EOL]         final Serializable ser = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Serializable.class)); [EOL]         final Type longComparableType = getClass().getField("longComparable").getGenericType(); [EOL]         // longComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, longComparableType)); [EOL]         // longComparable = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, longComparableType)); [EOL]         // int[] ia; [EOL]         // long[] la = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, long[].class)); [EOL]         final Integer[] ia = null; [EOL]         final Type caType = getClass().getField("intWildcardComparable").getGenericType(); [EOL]         intWildcardComparable = ia; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, caType)); [EOL]         // int[] ina = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer[].class, int[].class)); [EOL]         final int[] ina = null; [EOL]         Object[] oa; [EOL]         // oa = ina; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, Object[].class)); [EOL]         oa = new Integer[0]; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, Object[].class)); [EOL]         final Type bClassType = AClass.class.getField("bClass").getGenericType(); [EOL]         final Type cClassType = AClass.class.getField("cClass").getGenericType(); [EOL]         final Type dClassType = AClass.class.getField("dClass").getGenericType(); [EOL]         final Type eClassType = AClass.class.getField("eClass").getGenericType(); [EOL]         final Type fClassType = AClass.class.getField("fClass").getGenericType(); [EOL]         final AClass aClass = new AClass(new AAClass<String>()); [EOL]         aClass.bClass = aClass.cClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(cClassType, bClassType)); [EOL]         aClass.bClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, bClassType)); [EOL]         aClass.bClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, bClassType)); [EOL]         aClass.bClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, bClassType)); [EOL]         aClass.cClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, cClassType)); [EOL]         aClass.cClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, cClassType)); [EOL]         aClass.cClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, cClassType)); [EOL]         aClass.dClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, dClassType)); [EOL]         aClass.dClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, dClassType)); [EOL]         aClass.eClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, eClassType)); [EOL]     } [EOL]  [EOL]     public void delegateBooleanAssertion(final Type[] types, final int i2, final int i1, final boolean expected) { [EOL]         final Type type1 = types[i1]; [EOL]         final Type type2 = types[i2]; [EOL]         final boolean isAssignable = TypeUtils.isAssignable(type2, type1); [EOL]  [EOL]         if (expected) { [EOL]             Assert.assertTrue("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } else { [EOL]             Assert.assertFalse("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } [EOL]     } [EOL]  [EOL]     @SuppressWarnings("boxing") // boxing is deliberate here [EOL]
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [EOL]         final Type[] types = method.getGenericParameterTypes(); [EOL] //        list0 = list0; [EOL]         delegateBooleanAssertion(types, 0, 0, true); [EOL]         list1 = list0; [EOL]         delegateBooleanAssertion(types, 0, 1, true); [EOL]         list0 = list1; [EOL]         delegateBooleanAssertion(types, 1, 0, true); [EOL]         list2 = list0; [EOL]         delegateBooleanAssertion(types, 0, 2, true); [EOL]         list0 = list2; [EOL]         delegateBooleanAssertion(types, 2, 0, true); [EOL]         list3 = list0; [EOL]         delegateBooleanAssertion(types, 0, 3, true); [EOL]         list0 = list3; [EOL]         delegateBooleanAssertion(types, 3, 0, true); [EOL]         list4 = list0; [EOL]         delegateBooleanAssertion(types, 0, 4, true); [EOL]         list0 = list4; [EOL]         delegateBooleanAssertion(types, 4, 0, true); [EOL]         list5 = list0; [EOL]         delegateBooleanAssertion(types, 0, 5, true); [EOL]         list0 = list5; [EOL]         delegateBooleanAssertion(types, 5, 0, true); [EOL]         list6 = list0; [EOL]         delegateBooleanAssertion(types, 0, 6, true); [EOL]         list0 = list6; [EOL]         delegateBooleanAssertion(types, 6, 0, true); [EOL] //        list1 = list1; [EOL]         delegateBooleanAssertion(types, 1, 1, true); [EOL]         list2 = list1; [EOL]         delegateBooleanAssertion(types, 1, 2, true); [EOL]         list1 = (List<Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 1, false); [EOL]         list3 = list1; [EOL]         delegateBooleanAssertion(types, 1, 3, true); [EOL]         list1 = (List<Object>) list3; [EOL]         delegateBooleanAssertion(types, 3, 1, false); [EOL]         // list4 = list1; [EOL]         delegateBooleanAssertion(types, 1, 4, false); [EOL]         // list1 = list4; [EOL]         delegateBooleanAssertion(types, 4, 1, false); [EOL]         // list5 = list1; [EOL]         delegateBooleanAssertion(types, 1, 5, false); [EOL]         // list1 = list5; [EOL]         delegateBooleanAssertion(types, 5, 1, false); [EOL]         list6 = list1; [EOL]         delegateBooleanAssertion(types, 1, 6, true); [EOL]         list1 = (List<Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 1, false); [EOL] //        list2 = list2; [EOL]         delegateBooleanAssertion(types, 2, 2, true); [EOL]         list2 = list3; [EOL]         delegateBooleanAssertion(types, 2, 3, false); [EOL]         list2 = list4; [EOL]         delegateBooleanAssertion(types, 3, 2, true); [EOL]         list3 = (List<? super Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 4, false); [EOL]         list2 = list5; [EOL]         delegateBooleanAssertion(types, 4, 2, true); [EOL]         list4 = (List<String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 5, false); [EOL]         list2 = list6; [EOL]         delegateBooleanAssertion(types, 5, 2, true); [EOL]         list5 = (List<? extends String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 6, false); [EOL] //        list3 = list3; [EOL]         delegateBooleanAssertion(types, 6, 2, true); [EOL]         list6 = (List<? super String>) list2; [EOL]         delegateBooleanAssertion(types, 3, 3, true); [EOL]         // list4 = list3; [EOL]         delegateBooleanAssertion(types, 3, 4, false); [EOL]         // list3 = list4; [EOL]         delegateBooleanAssertion(types, 4, 3, false); [EOL]         // list5 = list3; [EOL]         delegateBooleanAssertion(types, 3, 5, false); [EOL]         // list3 = list5; [EOL]         delegateBooleanAssertion(types, 5, 3, false); [EOL]         list6 = list3; [EOL]         delegateBooleanAssertion(types, 3, 6, true); [EOL]         list3 = (List<? super Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 3, false); [EOL] //        list4 = list4; [EOL]         delegateBooleanAssertion(types, 4, 4, true); [EOL]         list5 = list4; [EOL]         delegateBooleanAssertion(types, 4, 5, true); [EOL]         list4 = (List<String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 4, false); [EOL]         list6 = list4; [EOL]         delegateBooleanAssertion(types, 4, 6, true); [EOL]         list4 = (List<String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 4, false); [EOL] //        list5 = list5; [EOL]         delegateBooleanAssertion(types, 5, 5, true); [EOL]         list6 = (List<? super String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 6, false); [EOL]         list5 = (List<? extends String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 5, false); [EOL] //        list6 = list6; [EOL]         delegateBooleanAssertion(types, 6, 6, true); [EOL]  [EOL] //        list7 = list7; [EOL]         delegateBooleanAssertion(types, 7, 7, true); [EOL]         list8 = list7; [EOL]         delegateBooleanAssertion(types, 7, 8, true); [EOL]         list7 = list8; [EOL]         delegateBooleanAssertion(types, 8, 7, true); [EOL]         list9 = list7; [EOL]         delegateBooleanAssertion(types, 7, 9, true); [EOL]         list7 = list9; [EOL]         delegateBooleanAssertion(types, 9, 7, true); [EOL]         list10 = list7; [EOL]         delegateBooleanAssertion(types, 7, 10, true); [EOL]         list7 = list10; [EOL]         delegateBooleanAssertion(types, 10, 7, true); [EOL]         list11 = list7; [EOL]         delegateBooleanAssertion(types, 7, 11, true); [EOL]         list7 = list11; [EOL]         delegateBooleanAssertion(types, 11, 7, true); [EOL]         list12 = list7; [EOL]         delegateBooleanAssertion(types, 7, 12, true); [EOL]         list7 = list12; [EOL]         delegateBooleanAssertion(types, 12, 7, true); [EOL]         list13 = list7; [EOL]         delegateBooleanAssertion(types, 7, 13, true); [EOL]         list7 = list13; [EOL]         delegateBooleanAssertion(types, 13, 7, true); [EOL] //        list8 = list8; [EOL]         delegateBooleanAssertion(types, 8, 8, true); [EOL]         list9 = list8; [EOL]         delegateBooleanAssertion(types, 8, 9, true); [EOL]         list8 = (List<Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 8, false); [EOL]         list10 = list8; [EOL]         delegateBooleanAssertion(types, 8, 10, true); [EOL]         list8 = (List<Object>[]) list10; // NOTE cast is required by Sun Java, but not by Eclipse [EOL]         delegateBooleanAssertion(types, 10, 8, false); [EOL]         // list11 = list8; [EOL]         delegateBooleanAssertion(types, 8, 11, false); [EOL]         // list8 = list11; [EOL]         delegateBooleanAssertion(types, 11, 8, false); [EOL]         // list12 = list8; [EOL]         delegateBooleanAssertion(types, 8, 12, false); [EOL]         // list8 = list12; [EOL]         delegateBooleanAssertion(types, 12, 8, false); [EOL]         list13 = list8; [EOL]         delegateBooleanAssertion(types, 8, 13, true); [EOL]         list8 = (List<Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 8, false); [EOL] //        list9 = list9; [EOL]         delegateBooleanAssertion(types, 9, 9, true); [EOL]         list10 = (List<? super Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 10, false); [EOL]         list9 = list10; [EOL]         delegateBooleanAssertion(types, 10, 9, true); [EOL]         list11 = (List<String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 11, false); [EOL]         list9 = list11; [EOL]         delegateBooleanAssertion(types, 11, 9, true); [EOL]         list12 = (List<? extends String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 12, false); [EOL]         list9 = list12; [EOL]         delegateBooleanAssertion(types, 12, 9, true); [EOL]         list13 = (List<? super String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 13, false); [EOL]         list9 = list13; [EOL]         delegateBooleanAssertion(types, 13, 9, true); [EOL] //        list10 = list10; [EOL]         delegateBooleanAssertion(types, 10, 10, true); [EOL]         // list11 = list10; [EOL]         delegateBooleanAssertion(types, 10, 11, false); [EOL]         // list10 = list11; [EOL]         delegateBooleanAssertion(types, 11, 10, false); [EOL]         // list12 = list10; [EOL]         delegateBooleanAssertion(types, 10, 12, false); [EOL]         // list10 = list12; [EOL]         delegateBooleanAssertion(types, 12, 10, false); [EOL]         list13 = list10; [EOL]         delegateBooleanAssertion(types, 10, 13, true); [EOL]         list10 = (List<? super Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 10, false); [EOL] //        list11 = list11; [EOL]         delegateBooleanAssertion(types, 11, 11, true); [EOL]         list12 = list11; [EOL]         delegateBooleanAssertion(types, 11, 12, true); [EOL]         list11 = (List<String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 11, false); [EOL]         list13 = list11; [EOL]         delegateBooleanAssertion(types, 11, 13, true); [EOL]         list11 = (List<String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 11, false); [EOL] //        list12 = list12; [EOL]         delegateBooleanAssertion(types, 12, 12, true); [EOL]         list13 = (List<? super String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 13, false); [EOL]         list12 = (List<? extends String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 12, false); [EOL] //        list13 = list13; [EOL]         delegateBooleanAssertion(types, 13, 13, true); [EOL]         final Type disType = getClass().getField("dis").getGenericType(); [EOL]         // Reporter.log( ( ( ParameterizedType ) disType [EOL]         // ).getOwnerType().getClass().toString() ); [EOL]         final Type datType = getClass().getField("dat").getGenericType(); [EOL]         final Type daType = getClass().getField("da").getGenericType(); [EOL]         final Type uhderType = getClass().getField("uhder").getGenericType(); [EOL]         final Type dingType = getClass().getField("ding").getGenericType(); [EOL]         final Type testerType = getClass().getField("tester").getGenericType(); [EOL]         final Type tester2Type = getClass().getField("tester2").getGenericType(); [EOL]         final Type dat2Type = getClass().getField("dat2").getGenericType(); [EOL]         final Type dat3Type = getClass().getField("dat3").getGenericType(); [EOL]         dis = dat; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(datType, disType)); [EOL]         // dis = da; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(daType, disType)); [EOL]         dis = uhder; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(uhderType, disType)); [EOL]         dis = ding; [EOL]         Assert.assertFalse(String.format("type %s not assignable to %s!", dingType, disType), [EOL]                 TypeUtils.isAssignable(dingType, disType)); [EOL]         dis = tester; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(testerType, disType)); [EOL]         // dis = tester2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(tester2Type, disType)); [EOL]         // dat = dat2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat2Type, datType)); [EOL]         // dat2 = dat; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(datType, dat2Type)); [EOL]         // dat = dat3; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat3Type, datType)); [EOL]         final char ch = 0; [EOL]         final boolean bo = false; [EOL]         final byte by = 0; [EOL]         final short sh = 0; [EOL]         int in = 0; [EOL]         long lo = 0; [EOL]         final float fl = 0; [EOL]         double du = 0; [EOL]         du = ch; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(char.class, double.class)); [EOL]         du = by; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(byte.class, double.class)); [EOL]         du = sh; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(short.class, double.class)); [EOL]         du = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, double.class)); [EOL]         du = lo; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(long.class, double.class)); [EOL]         du = fl; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(float.class, double.class)); [EOL]         lo = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, long.class)); [EOL]         lo = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, long.class)); [EOL]         // Long lngW = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, Long.class)); [EOL]         // lngW = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, Long.class)); [EOL]         in = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, int.class)); [EOL]         final Integer inte = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Integer.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Number.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Object.class)); [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, intComparableType)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Comparable.class)); [EOL]         final Serializable ser = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Serializable.class)); [EOL]         final Type longComparableType = getClass().getField("longComparable").getGenericType(); [EOL]         // longComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, longComparableType)); [EOL]         // longComparable = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, longComparableType)); [EOL]         // int[] ia; [EOL]         // long[] la = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, long[].class)); [EOL]         final Integer[] ia = null; [EOL]         final Type caType = getClass().getField("intWildcardComparable").getGenericType(); [EOL]         intWildcardComparable = ia; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, caType)); [EOL]         // int[] ina = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer[].class, int[].class)); [EOL]         final int[] ina = null; [EOL]         Object[] oa; [EOL]         // oa = ina; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, Object[].class)); [EOL]         oa = new Integer[0]; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, Object[].class)); [EOL]         final Type bClassType = AClass.class.getField("bClass").getGenericType(); [EOL]         final Type cClassType = AClass.class.getField("cClass").getGenericType(); [EOL]         final Type dClassType = AClass.class.getField("dClass").getGenericType(); [EOL]         final Type eClassType = AClass.class.getField("eClass").getGenericType(); [EOL]         final Type fClassType = AClass.class.getField("fClass").getGenericType(); [EOL]         final AClass aClass = new AClass(new AAClass<String>()); [EOL]         aClass.bClass = aClass.cClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(cClassType, bClassType)); [EOL]         aClass.bClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, bClassType)); [EOL]         aClass.bClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, bClassType)); [EOL]         aClass.bClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, bClassType)); [EOL]         aClass.cClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, cClassType)); [EOL]         aClass.cClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, cClassType)); [EOL]         aClass.cClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, cClassType)); [EOL]         aClass.dClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, dClassType)); [EOL]         aClass.dClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, dClassType)); [EOL]         aClass.eClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, eClassType)); [EOL]     } [EOL]  [EOL]     public void delegateBooleanAssertion(final Type[] types, final int i2, final int i1, final boolean expected) { [EOL]         final Type type1 = types[i1]; [EOL]         final Type type2 = types[i2]; [EOL]         final boolean isAssignable = TypeUtils.isAssignable(type2, type1); [EOL]  [EOL]         if (expected) { [EOL]             Assert.assertTrue("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } else { [EOL]             Assert.assertFalse("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } [EOL]     } [EOL]  [EOL]     @SuppressWarnings("boxing") // boxing is deliberate here [EOL]
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [EOL]         final Type[] types = method.getGenericParameterTypes(); [EOL] //        list0 = list0; [EOL]         delegateBooleanAssertion(types, 0, 0, true); [EOL]         list1 = list0; [EOL]         delegateBooleanAssertion(types, 0, 1, true); [EOL]         list0 = list1; [EOL]         delegateBooleanAssertion(types, 1, 0, true); [EOL]         list2 = list0; [EOL]         delegateBooleanAssertion(types, 0, 2, true); [EOL]         list0 = list2; [EOL]         delegateBooleanAssertion(types, 2, 0, true); [EOL]         list3 = list0; [EOL]         delegateBooleanAssertion(types, 0, 3, true); [EOL]         list0 = list3; [EOL]         delegateBooleanAssertion(types, 3, 0, true); [EOL]         list4 = list0; [EOL]         delegateBooleanAssertion(types, 0, 4, true); [EOL]         list0 = list4; [EOL]         delegateBooleanAssertion(types, 4, 0, true); [EOL]         list5 = list0; [EOL]         delegateBooleanAssertion(types, 0, 5, true); [EOL]         list0 = list5; [EOL]         delegateBooleanAssertion(types, 5, 0, true); [EOL]         list6 = list0; [EOL]         delegateBooleanAssertion(types, 0, 6, true); [EOL]         list0 = list6; [EOL]         delegateBooleanAssertion(types, 6, 0, true); [EOL] //        list1 = list1; [EOL]         delegateBooleanAssertion(types, 1, 1, true); [EOL]         list2 = list1; [EOL]         delegateBooleanAssertion(types, 1, 2, true); [EOL]         list1 = (List<Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 1, false); [EOL]         list3 = list1; [EOL]         delegateBooleanAssertion(types, 1, 3, true); [EOL]         list1 = (List<Object>) list3; [EOL]         delegateBooleanAssertion(types, 3, 1, false); [EOL]         // list4 = list1; [EOL]         delegateBooleanAssertion(types, 1, 4, false); [EOL]         // list1 = list4; [EOL]         delegateBooleanAssertion(types, 4, 1, false); [EOL]         // list5 = list1; [EOL]         delegateBooleanAssertion(types, 1, 5, false); [EOL]         // list1 = list5; [EOL]         delegateBooleanAssertion(types, 5, 1, false); [EOL]         list6 = list1; [EOL]         delegateBooleanAssertion(types, 1, 6, true); [EOL]         list1 = (List<Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 1, false); [EOL] //        list2 = list2; [EOL]         delegateBooleanAssertion(types, 2, 2, true); [EOL]         list2 = list3; [EOL]         delegateBooleanAssertion(types, 2, 3, false); [EOL]         list2 = list4; [EOL]         delegateBooleanAssertion(types, 3, 2, true); [EOL]         list3 = (List<? super Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 4, false); [EOL]         list2 = list5; [EOL]         delegateBooleanAssertion(types, 4, 2, true); [EOL]         list4 = (List<String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 5, false); [EOL]         list2 = list6; [EOL]         delegateBooleanAssertion(types, 5, 2, true); [EOL]         list5 = (List<? extends String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 6, false); [EOL] //        list3 = list3; [EOL]         delegateBooleanAssertion(types, 6, 2, true); [EOL]         list6 = (List<? super String>) list2; [EOL]         delegateBooleanAssertion(types, 3, 3, true); [EOL]         // list4 = list3; [EOL]         delegateBooleanAssertion(types, 3, 4, false); [EOL]         // list3 = list4; [EOL]         delegateBooleanAssertion(types, 4, 3, false); [EOL]         // list5 = list3; [EOL]         delegateBooleanAssertion(types, 3, 5, false); [EOL]         // list3 = list5; [EOL]         delegateBooleanAssertion(types, 5, 3, false); [EOL]         list6 = list3; [EOL]         delegateBooleanAssertion(types, 3, 6, true); [EOL]         list3 = (List<? super Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 3, false); [EOL] //        list4 = list4; [EOL]         delegateBooleanAssertion(types, 4, 4, true); [EOL]         list5 = list4; [EOL]         delegateBooleanAssertion(types, 4, 5, true); [EOL]         list4 = (List<String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 4, false); [EOL]         list6 = list4; [EOL]         delegateBooleanAssertion(types, 4, 6, true); [EOL]         list4 = (List<String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 4, false); [EOL] //        list5 = list5; [EOL]         delegateBooleanAssertion(types, 5, 5, true); [EOL]         list6 = (List<? super String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 6, false); [EOL]         list5 = (List<? extends String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 5, false); [EOL] //        list6 = list6; [EOL]         delegateBooleanAssertion(types, 6, 6, true); [EOL]  [EOL] //        list7 = list7; [EOL]         delegateBooleanAssertion(types, 7, 7, true); [EOL]         list8 = list7; [EOL]         delegateBooleanAssertion(types, 7, 8, true); [EOL]         list7 = list8; [EOL]         delegateBooleanAssertion(types, 8, 7, true); [EOL]         list9 = list7; [EOL]         delegateBooleanAssertion(types, 7, 9, true); [EOL]         list7 = list9; [EOL]         delegateBooleanAssertion(types, 9, 7, true); [EOL]         list10 = list7; [EOL]         delegateBooleanAssertion(types, 7, 10, true); [EOL]         list7 = list10; [EOL]         delegateBooleanAssertion(types, 10, 7, true); [EOL]         list11 = list7; [EOL]         delegateBooleanAssertion(types, 7, 11, true); [EOL]         list7 = list11; [EOL]         delegateBooleanAssertion(types, 11, 7, true); [EOL]         list12 = list7; [EOL]         delegateBooleanAssertion(types, 7, 12, true); [EOL]         list7 = list12; [EOL]         delegateBooleanAssertion(types, 12, 7, true); [EOL]         list13 = list7; [EOL]         delegateBooleanAssertion(types, 7, 13, true); [EOL]         list7 = list13; [EOL]         delegateBooleanAssertion(types, 13, 7, true); [EOL] //        list8 = list8; [EOL]         delegateBooleanAssertion(types, 8, 8, true); [EOL]         list9 = list8; [EOL]         delegateBooleanAssertion(types, 8, 9, true); [EOL]         list8 = (List<Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 8, false); [EOL]         list10 = list8; [EOL]         delegateBooleanAssertion(types, 8, 10, true); [EOL]         list8 = (List<Object>[]) list10; // NOTE cast is required by Sun Java, but not by Eclipse [EOL]         delegateBooleanAssertion(types, 10, 8, false); [EOL]         // list11 = list8; [EOL]         delegateBooleanAssertion(types, 8, 11, false); [EOL]         // list8 = list11; [EOL]         delegateBooleanAssertion(types, 11, 8, false); [EOL]         // list12 = list8; [EOL]         delegateBooleanAssertion(types, 8, 12, false); [EOL]         // list8 = list12; [EOL]         delegateBooleanAssertion(types, 12, 8, false); [EOL]         list13 = list8; [EOL]         delegateBooleanAssertion(types, 8, 13, true); [EOL]         list8 = (List<Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 8, false); [EOL] //        list9 = list9; [EOL]         delegateBooleanAssertion(types, 9, 9, true); [EOL]         list10 = (List<? super Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 10, false); [EOL]         list9 = list10; [EOL]         delegateBooleanAssertion(types, 10, 9, true); [EOL]         list11 = (List<String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 11, false); [EOL]         list9 = list11; [EOL]         delegateBooleanAssertion(types, 11, 9, true); [EOL]         list12 = (List<? extends String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 12, false); [EOL]         list9 = list12; [EOL]         delegateBooleanAssertion(types, 12, 9, true); [EOL]         list13 = (List<? super String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 13, false); [EOL]         list9 = list13; [EOL]         delegateBooleanAssertion(types, 13, 9, true); [EOL] //        list10 = list10; [EOL]         delegateBooleanAssertion(types, 10, 10, true); [EOL]         // list11 = list10; [EOL]         delegateBooleanAssertion(types, 10, 11, false); [EOL]         // list10 = list11; [EOL]         delegateBooleanAssertion(types, 11, 10, false); [EOL]         // list12 = list10; [EOL]         delegateBooleanAssertion(types, 10, 12, false); [EOL]         // list10 = list12; [EOL]         delegateBooleanAssertion(types, 12, 10, false); [EOL]         list13 = list10; [EOL]         delegateBooleanAssertion(types, 10, 13, true); [EOL]         list10 = (List<? super Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 10, false); [EOL] //        list11 = list11; [EOL]         delegateBooleanAssertion(types, 11, 11, true); [EOL]         list12 = list11; [EOL]         delegateBooleanAssertion(types, 11, 12, true); [EOL]         list11 = (List<String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 11, false); [EOL]         list13 = list11; [EOL]         delegateBooleanAssertion(types, 11, 13, true); [EOL]         list11 = (List<String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 11, false); [EOL] //        list12 = list12; [EOL]         delegateBooleanAssertion(types, 12, 12, true); [EOL]         list13 = (List<? super String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 13, false); [EOL]         list12 = (List<? extends String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 12, false); [EOL] //        list13 = list13; [EOL]         delegateBooleanAssertion(types, 13, 13, true); [EOL]         final Type disType = getClass().getField("dis").getGenericType(); [EOL]         // Reporter.log( ( ( ParameterizedType ) disType [EOL]         // ).getOwnerType().getClass().toString() ); [EOL]         final Type datType = getClass().getField("dat").getGenericType(); [EOL]         final Type daType = getClass().getField("da").getGenericType(); [EOL]         final Type uhderType = getClass().getField("uhder").getGenericType(); [EOL]         final Type dingType = getClass().getField("ding").getGenericType(); [EOL]         final Type testerType = getClass().getField("tester").getGenericType(); [EOL]         final Type tester2Type = getClass().getField("tester2").getGenericType(); [EOL]         final Type dat2Type = getClass().getField("dat2").getGenericType(); [EOL]         final Type dat3Type = getClass().getField("dat3").getGenericType(); [EOL]         dis = dat; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(datType, disType)); [EOL]         // dis = da; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(daType, disType)); [EOL]         dis = uhder; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(uhderType, disType)); [EOL]         dis = ding; [EOL]         Assert.assertFalse(String.format("type %s not assignable to %s!", dingType, disType), [EOL]                 TypeUtils.isAssignable(dingType, disType)); [EOL]         dis = tester; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(testerType, disType)); [EOL]         // dis = tester2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(tester2Type, disType)); [EOL]         // dat = dat2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat2Type, datType)); [EOL]         // dat2 = dat; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(datType, dat2Type)); [EOL]         // dat = dat3; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat3Type, datType)); [EOL]         final char ch = 0; [EOL]         final boolean bo = false; [EOL]         final byte by = 0; [EOL]         final short sh = 0; [EOL]         int in = 0; [EOL]         long lo = 0; [EOL]         final float fl = 0; [EOL]         double du = 0; [EOL]         du = ch; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(char.class, double.class)); [EOL]         du = by; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(byte.class, double.class)); [EOL]         du = sh; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(short.class, double.class)); [EOL]         du = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, double.class)); [EOL]         du = lo; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(long.class, double.class)); [EOL]         du = fl; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(float.class, double.class)); [EOL]         lo = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, long.class)); [EOL]         lo = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, long.class)); [EOL]         // Long lngW = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, Long.class)); [EOL]         // lngW = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, Long.class)); [EOL]         in = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, int.class)); [EOL]         final Integer inte = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Integer.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Number.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Object.class)); [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, intComparableType)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Comparable.class)); [EOL]         final Serializable ser = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Serializable.class)); [EOL]         final Type longComparableType = getClass().getField("longComparable").getGenericType(); [EOL]         // longComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, longComparableType)); [EOL]         // longComparable = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, longComparableType)); [EOL]         // int[] ia; [EOL]         // long[] la = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, long[].class)); [EOL]         final Integer[] ia = null; [EOL]         final Type caType = getClass().getField("intWildcardComparable").getGenericType(); [EOL]         intWildcardComparable = ia; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, caType)); [EOL]         // int[] ina = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer[].class, int[].class)); [EOL]         final int[] ina = null; [EOL]         Object[] oa; [EOL]         // oa = ina; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, Object[].class)); [EOL]         oa = new Integer[0]; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, Object[].class)); [EOL]         final Type bClassType = AClass.class.getField("bClass").getGenericType(); [EOL]         final Type cClassType = AClass.class.getField("cClass").getGenericType(); [EOL]         final Type dClassType = AClass.class.getField("dClass").getGenericType(); [EOL]         final Type eClassType = AClass.class.getField("eClass").getGenericType(); [EOL]         final Type fClassType = AClass.class.getField("fClass").getGenericType(); [EOL]         final AClass aClass = new AClass(new AAClass<String>()); [EOL]         aClass.bClass = aClass.cClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(cClassType, bClassType)); [EOL]         aClass.bClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, bClassType)); [EOL]         aClass.bClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, bClassType)); [EOL]         aClass.bClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, bClassType)); [EOL]         aClass.cClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, cClassType)); [EOL]         aClass.cClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, cClassType)); [EOL]         aClass.cClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, cClassType)); [EOL]         aClass.dClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, dClassType)); [EOL]         aClass.dClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, dClassType)); [EOL]         aClass.eClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, eClassType)); [EOL]     } [EOL]  [EOL]     public void delegateBooleanAssertion(final Type[] types, final int i2, final int i1, final boolean expected) { [EOL]         final Type type1 = types[i1]; [EOL]         final Type type2 = types[i2]; [EOL]         final boolean isAssignable = TypeUtils.isAssignable(type2, type1); [EOL]  [EOL]         if (expected) { [EOL]             Assert.assertTrue("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } else { [EOL]             Assert.assertFalse("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } [EOL]     } [EOL]  [EOL]     @SuppressWarnings("boxing") // boxing is deliberate here [EOL]
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [EOL]         final Type[] types = method.getGenericParameterTypes(); [EOL] //        list0 = list0; [EOL]         delegateBooleanAssertion(types, 0, 0, true); [EOL]         list1 = list0; [EOL]         delegateBooleanAssertion(types, 0, 1, true); [EOL]         list0 = list1; [EOL]         delegateBooleanAssertion(types, 1, 0, true); [EOL]         list2 = list0; [EOL]         delegateBooleanAssertion(types, 0, 2, true); [EOL]         list0 = list2; [EOL]         delegateBooleanAssertion(types, 2, 0, true); [EOL]         list3 = list0; [EOL]         delegateBooleanAssertion(types, 0, 3, true); [EOL]         list0 = list3; [EOL]         delegateBooleanAssertion(types, 3, 0, true); [EOL]         list4 = list0; [EOL]         delegateBooleanAssertion(types, 0, 4, true); [EOL]         list0 = list4; [EOL]         delegateBooleanAssertion(types, 4, 0, true); [EOL]         list5 = list0; [EOL]         delegateBooleanAssertion(types, 0, 5, true); [EOL]         list0 = list5; [EOL]         delegateBooleanAssertion(types, 5, 0, true); [EOL]         list6 = list0; [EOL]         delegateBooleanAssertion(types, 0, 6, true); [EOL]         list0 = list6; [EOL]         delegateBooleanAssertion(types, 6, 0, true); [EOL] //        list1 = list1; [EOL]         delegateBooleanAssertion(types, 1, 1, true); [EOL]         list2 = list1; [EOL]         delegateBooleanAssertion(types, 1, 2, true); [EOL]         list1 = (List<Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 1, false); [EOL]         list3 = list1; [EOL]         delegateBooleanAssertion(types, 1, 3, true); [EOL]         list1 = (List<Object>) list3; [EOL]         delegateBooleanAssertion(types, 3, 1, false); [EOL]         // list4 = list1; [EOL]         delegateBooleanAssertion(types, 1, 4, false); [EOL]         // list1 = list4; [EOL]         delegateBooleanAssertion(types, 4, 1, false); [EOL]         // list5 = list1; [EOL]         delegateBooleanAssertion(types, 1, 5, false); [EOL]         // list1 = list5; [EOL]         delegateBooleanAssertion(types, 5, 1, false); [EOL]         list6 = list1; [EOL]         delegateBooleanAssertion(types, 1, 6, true); [EOL]         list1 = (List<Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 1, false); [EOL] //        list2 = list2; [EOL]         delegateBooleanAssertion(types, 2, 2, true); [EOL]         list2 = list3; [EOL]         delegateBooleanAssertion(types, 2, 3, false); [EOL]         list2 = list4; [EOL]         delegateBooleanAssertion(types, 3, 2, true); [EOL]         list3 = (List<? super Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 4, false); [EOL]         list2 = list5; [EOL]         delegateBooleanAssertion(types, 4, 2, true); [EOL]         list4 = (List<String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 5, false); [EOL]         list2 = list6; [EOL]         delegateBooleanAssertion(types, 5, 2, true); [EOL]         list5 = (List<? extends String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 6, false); [EOL] //        list3 = list3; [EOL]         delegateBooleanAssertion(types, 6, 2, true); [EOL]         list6 = (List<? super String>) list2; [EOL]         delegateBooleanAssertion(types, 3, 3, true); [EOL]         // list4 = list3; [EOL]         delegateBooleanAssertion(types, 3, 4, false); [EOL]         // list3 = list4; [EOL]         delegateBooleanAssertion(types, 4, 3, false); [EOL]         // list5 = list3; [EOL]         delegateBooleanAssertion(types, 3, 5, false); [EOL]         // list3 = list5; [EOL]         delegateBooleanAssertion(types, 5, 3, false); [EOL]         list6 = list3; [EOL]         delegateBooleanAssertion(types, 3, 6, true); [EOL]         list3 = (List<? super Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 3, false); [EOL] //        list4 = list4; [EOL]         delegateBooleanAssertion(types, 4, 4, true); [EOL]         list5 = list4; [EOL]         delegateBooleanAssertion(types, 4, 5, true); [EOL]         list4 = (List<String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 4, false); [EOL]         list6 = list4; [EOL]         delegateBooleanAssertion(types, 4, 6, true); [EOL]         list4 = (List<String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 4, false); [EOL] //        list5 = list5; [EOL]         delegateBooleanAssertion(types, 5, 5, true); [EOL]         list6 = (List<? super String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 6, false); [EOL]         list5 = (List<? extends String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 5, false); [EOL] //        list6 = list6; [EOL]         delegateBooleanAssertion(types, 6, 6, true); [EOL]  [EOL] //        list7 = list7; [EOL]         delegateBooleanAssertion(types, 7, 7, true); [EOL]         list8 = list7; [EOL]         delegateBooleanAssertion(types, 7, 8, true); [EOL]         list7 = list8; [EOL]         delegateBooleanAssertion(types, 8, 7, true); [EOL]         list9 = list7; [EOL]         delegateBooleanAssertion(types, 7, 9, true); [EOL]         list7 = list9; [EOL]         delegateBooleanAssertion(types, 9, 7, true); [EOL]         list10 = list7; [EOL]         delegateBooleanAssertion(types, 7, 10, true); [EOL]         list7 = list10; [EOL]         delegateBooleanAssertion(types, 10, 7, true); [EOL]         list11 = list7; [EOL]         delegateBooleanAssertion(types, 7, 11, true); [EOL]         list7 = list11; [EOL]         delegateBooleanAssertion(types, 11, 7, true); [EOL]         list12 = list7; [EOL]         delegateBooleanAssertion(types, 7, 12, true); [EOL]         list7 = list12; [EOL]         delegateBooleanAssertion(types, 12, 7, true); [EOL]         list13 = list7; [EOL]         delegateBooleanAssertion(types, 7, 13, true); [EOL]         list7 = list13; [EOL]         delegateBooleanAssertion(types, 13, 7, true); [EOL] //        list8 = list8; [EOL]         delegateBooleanAssertion(types, 8, 8, true); [EOL]         list9 = list8; [EOL]         delegateBooleanAssertion(types, 8, 9, true); [EOL]         list8 = (List<Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 8, false); [EOL]         list10 = list8; [EOL]         delegateBooleanAssertion(types, 8, 10, true); [EOL]         list8 = (List<Object>[]) list10; // NOTE cast is required by Sun Java, but not by Eclipse [EOL]         delegateBooleanAssertion(types, 10, 8, false); [EOL]         // list11 = list8; [EOL]         delegateBooleanAssertion(types, 8, 11, false); [EOL]         // list8 = list11; [EOL]         delegateBooleanAssertion(types, 11, 8, false); [EOL]         // list12 = list8; [EOL]         delegateBooleanAssertion(types, 8, 12, false); [EOL]         // list8 = list12; [EOL]         delegateBooleanAssertion(types, 12, 8, false); [EOL]         list13 = list8; [EOL]         delegateBooleanAssertion(types, 8, 13, true); [EOL]         list8 = (List<Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 8, false); [EOL] //        list9 = list9; [EOL]         delegateBooleanAssertion(types, 9, 9, true); [EOL]         list10 = (List<? super Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 10, false); [EOL]         list9 = list10; [EOL]         delegateBooleanAssertion(types, 10, 9, true); [EOL]         list11 = (List<String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 11, false); [EOL]         list9 = list11; [EOL]         delegateBooleanAssertion(types, 11, 9, true); [EOL]         list12 = (List<? extends String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 12, false); [EOL]         list9 = list12; [EOL]         delegateBooleanAssertion(types, 12, 9, true); [EOL]         list13 = (List<? super String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 13, false); [EOL]         list9 = list13; [EOL]         delegateBooleanAssertion(types, 13, 9, true); [EOL] //        list10 = list10; [EOL]         delegateBooleanAssertion(types, 10, 10, true); [EOL]         // list11 = list10; [EOL]         delegateBooleanAssertion(types, 10, 11, false); [EOL]         // list10 = list11; [EOL]         delegateBooleanAssertion(types, 11, 10, false); [EOL]         // list12 = list10; [EOL]         delegateBooleanAssertion(types, 10, 12, false); [EOL]         // list10 = list12; [EOL]         delegateBooleanAssertion(types, 12, 10, false); [EOL]         list13 = list10; [EOL]         delegateBooleanAssertion(types, 10, 13, true); [EOL]         list10 = (List<? super Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 10, false); [EOL] //        list11 = list11; [EOL]         delegateBooleanAssertion(types, 11, 11, true); [EOL]         list12 = list11; [EOL]         delegateBooleanAssertion(types, 11, 12, true); [EOL]         list11 = (List<String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 11, false); [EOL]         list13 = list11; [EOL]         delegateBooleanAssertion(types, 11, 13, true); [EOL]         list11 = (List<String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 11, false); [EOL] //        list12 = list12; [EOL]         delegateBooleanAssertion(types, 12, 12, true); [EOL]         list13 = (List<? super String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 13, false); [EOL]         list12 = (List<? extends String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 12, false); [EOL] //        list13 = list13; [EOL]         delegateBooleanAssertion(types, 13, 13, true); [EOL]         final Type disType = getClass().getField("dis").getGenericType(); [EOL]         // Reporter.log( ( ( ParameterizedType ) disType [EOL]         // ).getOwnerType().getClass().toString() ); [EOL]         final Type datType = getClass().getField("dat").getGenericType(); [EOL]         final Type daType = getClass().getField("da").getGenericType(); [EOL]         final Type uhderType = getClass().getField("uhder").getGenericType(); [EOL]         final Type dingType = getClass().getField("ding").getGenericType(); [EOL]         final Type testerType = getClass().getField("tester").getGenericType(); [EOL]         final Type tester2Type = getClass().getField("tester2").getGenericType(); [EOL]         final Type dat2Type = getClass().getField("dat2").getGenericType(); [EOL]         final Type dat3Type = getClass().getField("dat3").getGenericType(); [EOL]         dis = dat; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(datType, disType)); [EOL]         // dis = da; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(daType, disType)); [EOL]         dis = uhder; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(uhderType, disType)); [EOL]         dis = ding; [EOL]         Assert.assertFalse(String.format("type %s not assignable to %s!", dingType, disType), [EOL]                 TypeUtils.isAssignable(dingType, disType)); [EOL]         dis = tester; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(testerType, disType)); [EOL]         // dis = tester2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(tester2Type, disType)); [EOL]         // dat = dat2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat2Type, datType)); [EOL]         // dat2 = dat; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(datType, dat2Type)); [EOL]         // dat = dat3; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat3Type, datType)); [EOL]         final char ch = 0; [EOL]         final boolean bo = false; [EOL]         final byte by = 0; [EOL]         final short sh = 0; [EOL]         int in = 0; [EOL]         long lo = 0; [EOL]         final float fl = 0; [EOL]         double du = 0; [EOL]         du = ch; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(char.class, double.class)); [EOL]         du = by; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(byte.class, double.class)); [EOL]         du = sh; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(short.class, double.class)); [EOL]         du = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, double.class)); [EOL]         du = lo; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(long.class, double.class)); [EOL]         du = fl; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(float.class, double.class)); [EOL]         lo = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, long.class)); [EOL]         lo = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, long.class)); [EOL]         // Long lngW = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, Long.class)); [EOL]         // lngW = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, Long.class)); [EOL]         in = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, int.class)); [EOL]         final Integer inte = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Integer.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Number.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Object.class)); [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, intComparableType)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Comparable.class)); [EOL]         final Serializable ser = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Serializable.class)); [EOL]         final Type longComparableType = getClass().getField("longComparable").getGenericType(); [EOL]         // longComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, longComparableType)); [EOL]         // longComparable = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, longComparableType)); [EOL]         // int[] ia; [EOL]         // long[] la = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, long[].class)); [EOL]         final Integer[] ia = null; [EOL]         final Type caType = getClass().getField("intWildcardComparable").getGenericType(); [EOL]         intWildcardComparable = ia; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, caType)); [EOL]         // int[] ina = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer[].class, int[].class)); [EOL]         final int[] ina = null; [EOL]         Object[] oa; [EOL]         // oa = ina; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, Object[].class)); [EOL]         oa = new Integer[0]; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, Object[].class)); [EOL]         final Type bClassType = AClass.class.getField("bClass").getGenericType(); [EOL]         final Type cClassType = AClass.class.getField("cClass").getGenericType(); [EOL]         final Type dClassType = AClass.class.getField("dClass").getGenericType(); [EOL]         final Type eClassType = AClass.class.getField("eClass").getGenericType(); [EOL]         final Type fClassType = AClass.class.getField("fClass").getGenericType(); [EOL]         final AClass aClass = new AClass(new AAClass<String>()); [EOL]         aClass.bClass = aClass.cClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(cClassType, bClassType)); [EOL]         aClass.bClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, bClassType)); [EOL]         aClass.bClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, bClassType)); [EOL]         aClass.bClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, bClassType)); [EOL]         aClass.cClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, cClassType)); [EOL]         aClass.cClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, cClassType)); [EOL]         aClass.cClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, cClassType)); [EOL]         aClass.dClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, dClassType)); [EOL]         aClass.dClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, dClassType)); [EOL]         aClass.eClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, eClassType)); [EOL]     } [EOL]  [EOL]     public void delegateBooleanAssertion(final Type[] types, final int i2, final int i1, final boolean expected) { [EOL]         final Type type1 = types[i1]; [EOL]         final Type type2 = types[i2]; [EOL]         final boolean isAssignable = TypeUtils.isAssignable(type2, type1); [EOL]  [EOL]         if (expected) { [EOL]             Assert.assertTrue("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } else { [EOL]             Assert.assertFalse("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } [EOL]     } [EOL]  [EOL]     @SuppressWarnings("boxing") // boxing is deliberate here [EOL]
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [EOL]         final Type[] types = method.getGenericParameterTypes(); [EOL] //        list0 = list0; [EOL]         delegateBooleanAssertion(types, 0, 0, true); [EOL]         list1 = list0; [EOL]         delegateBooleanAssertion(types, 0, 1, true); [EOL]         list0 = list1; [EOL]         delegateBooleanAssertion(types, 1, 0, true); [EOL]         list2 = list0; [EOL]         delegateBooleanAssertion(types, 0, 2, true); [EOL]         list0 = list2; [EOL]         delegateBooleanAssertion(types, 2, 0, true); [EOL]         list3 = list0; [EOL]         delegateBooleanAssertion(types, 0, 3, true); [EOL]         list0 = list3; [EOL]         delegateBooleanAssertion(types, 3, 0, true); [EOL]         list4 = list0; [EOL]         delegateBooleanAssertion(types, 0, 4, true); [EOL]         list0 = list4; [EOL]         delegateBooleanAssertion(types, 4, 0, true); [EOL]         list5 = list0; [EOL]         delegateBooleanAssertion(types, 0, 5, true); [EOL]         list0 = list5; [EOL]         delegateBooleanAssertion(types, 5, 0, true); [EOL]         list6 = list0; [EOL]         delegateBooleanAssertion(types, 0, 6, true); [EOL]         list0 = list6; [EOL]         delegateBooleanAssertion(types, 6, 0, true); [EOL] //        list1 = list1; [EOL]         delegateBooleanAssertion(types, 1, 1, true); [EOL]         list2 = list1; [EOL]         delegateBooleanAssertion(types, 1, 2, true); [EOL]         list1 = (List<Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 1, false); [EOL]         list3 = list1; [EOL]         delegateBooleanAssertion(types, 1, 3, true); [EOL]         list1 = (List<Object>) list3; [EOL]         delegateBooleanAssertion(types, 3, 1, false); [EOL]         // list4 = list1; [EOL]         delegateBooleanAssertion(types, 1, 4, false); [EOL]         // list1 = list4; [EOL]         delegateBooleanAssertion(types, 4, 1, false); [EOL]         // list5 = list1; [EOL]         delegateBooleanAssertion(types, 1, 5, false); [EOL]         // list1 = list5; [EOL]         delegateBooleanAssertion(types, 5, 1, false); [EOL]         list6 = list1; [EOL]         delegateBooleanAssertion(types, 1, 6, true); [EOL]         list1 = (List<Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 1, false); [EOL] //        list2 = list2; [EOL]         delegateBooleanAssertion(types, 2, 2, true); [EOL]         list2 = list3; [EOL]         delegateBooleanAssertion(types, 2, 3, false); [EOL]         list2 = list4; [EOL]         delegateBooleanAssertion(types, 3, 2, true); [EOL]         list3 = (List<? super Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 4, false); [EOL]         list2 = list5; [EOL]         delegateBooleanAssertion(types, 4, 2, true); [EOL]         list4 = (List<String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 5, false); [EOL]         list2 = list6; [EOL]         delegateBooleanAssertion(types, 5, 2, true); [EOL]         list5 = (List<? extends String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 6, false); [EOL] //        list3 = list3; [EOL]         delegateBooleanAssertion(types, 6, 2, true); [EOL]         list6 = (List<? super String>) list2; [EOL]         delegateBooleanAssertion(types, 3, 3, true); [EOL]         // list4 = list3; [EOL]         delegateBooleanAssertion(types, 3, 4, false); [EOL]         // list3 = list4; [EOL]         delegateBooleanAssertion(types, 4, 3, false); [EOL]         // list5 = list3; [EOL]         delegateBooleanAssertion(types, 3, 5, false); [EOL]         // list3 = list5; [EOL]         delegateBooleanAssertion(types, 5, 3, false); [EOL]         list6 = list3; [EOL]         delegateBooleanAssertion(types, 3, 6, true); [EOL]         list3 = (List<? super Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 3, false); [EOL] //        list4 = list4; [EOL]         delegateBooleanAssertion(types, 4, 4, true); [EOL]         list5 = list4; [EOL]         delegateBooleanAssertion(types, 4, 5, true); [EOL]         list4 = (List<String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 4, false); [EOL]         list6 = list4; [EOL]         delegateBooleanAssertion(types, 4, 6, true); [EOL]         list4 = (List<String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 4, false); [EOL] //        list5 = list5; [EOL]         delegateBooleanAssertion(types, 5, 5, true); [EOL]         list6 = (List<? super String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 6, false); [EOL]         list5 = (List<? extends String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 5, false); [EOL] //        list6 = list6; [EOL]         delegateBooleanAssertion(types, 6, 6, true); [EOL]  [EOL] //        list7 = list7; [EOL]         delegateBooleanAssertion(types, 7, 7, true); [EOL]         list8 = list7; [EOL]         delegateBooleanAssertion(types, 7, 8, true); [EOL]         list7 = list8; [EOL]         delegateBooleanAssertion(types, 8, 7, true); [EOL]         list9 = list7; [EOL]         delegateBooleanAssertion(types, 7, 9, true); [EOL]         list7 = list9; [EOL]         delegateBooleanAssertion(types, 9, 7, true); [EOL]         list10 = list7; [EOL]         delegateBooleanAssertion(types, 7, 10, true); [EOL]         list7 = list10; [EOL]         delegateBooleanAssertion(types, 10, 7, true); [EOL]         list11 = list7; [EOL]         delegateBooleanAssertion(types, 7, 11, true); [EOL]         list7 = list11; [EOL]         delegateBooleanAssertion(types, 11, 7, true); [EOL]         list12 = list7; [EOL]         delegateBooleanAssertion(types, 7, 12, true); [EOL]         list7 = list12; [EOL]         delegateBooleanAssertion(types, 12, 7, true); [EOL]         list13 = list7; [EOL]         delegateBooleanAssertion(types, 7, 13, true); [EOL]         list7 = list13; [EOL]         delegateBooleanAssertion(types, 13, 7, true); [EOL] //        list8 = list8; [EOL]         delegateBooleanAssertion(types, 8, 8, true); [EOL]         list9 = list8; [EOL]         delegateBooleanAssertion(types, 8, 9, true); [EOL]         list8 = (List<Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 8, false); [EOL]         list10 = list8; [EOL]         delegateBooleanAssertion(types, 8, 10, true); [EOL]         list8 = (List<Object>[]) list10; // NOTE cast is required by Sun Java, but not by Eclipse [EOL]         delegateBooleanAssertion(types, 10, 8, false); [EOL]         // list11 = list8; [EOL]         delegateBooleanAssertion(types, 8, 11, false); [EOL]         // list8 = list11; [EOL]         delegateBooleanAssertion(types, 11, 8, false); [EOL]         // list12 = list8; [EOL]         delegateBooleanAssertion(types, 8, 12, false); [EOL]         // list8 = list12; [EOL]         delegateBooleanAssertion(types, 12, 8, false); [EOL]         list13 = list8; [EOL]         delegateBooleanAssertion(types, 8, 13, true); [EOL]         list8 = (List<Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 8, false); [EOL] //        list9 = list9; [EOL]         delegateBooleanAssertion(types, 9, 9, true); [EOL]         list10 = (List<? super Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 10, false); [EOL]         list9 = list10; [EOL]         delegateBooleanAssertion(types, 10, 9, true); [EOL]         list11 = (List<String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 11, false); [EOL]         list9 = list11; [EOL]         delegateBooleanAssertion(types, 11, 9, true); [EOL]         list12 = (List<? extends String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 12, false); [EOL]         list9 = list12; [EOL]         delegateBooleanAssertion(types, 12, 9, true); [EOL]         list13 = (List<? super String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 13, false); [EOL]         list9 = list13; [EOL]         delegateBooleanAssertion(types, 13, 9, true); [EOL] //        list10 = list10; [EOL]         delegateBooleanAssertion(types, 10, 10, true); [EOL]         // list11 = list10; [EOL]         delegateBooleanAssertion(types, 10, 11, false); [EOL]         // list10 = list11; [EOL]         delegateBooleanAssertion(types, 11, 10, false); [EOL]         // list12 = list10; [EOL]         delegateBooleanAssertion(types, 10, 12, false); [EOL]         // list10 = list12; [EOL]         delegateBooleanAssertion(types, 12, 10, false); [EOL]         list13 = list10; [EOL]         delegateBooleanAssertion(types, 10, 13, true); [EOL]         list10 = (List<? super Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 10, false); [EOL] //        list11 = list11; [EOL]         delegateBooleanAssertion(types, 11, 11, true); [EOL]         list12 = list11; [EOL]         delegateBooleanAssertion(types, 11, 12, true); [EOL]         list11 = (List<String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 11, false); [EOL]         list13 = list11; [EOL]         delegateBooleanAssertion(types, 11, 13, true); [EOL]         list11 = (List<String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 11, false); [EOL] //        list12 = list12; [EOL]         delegateBooleanAssertion(types, 12, 12, true); [EOL]         list13 = (List<? super String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 13, false); [EOL]         list12 = (List<? extends String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 12, false); [EOL] //        list13 = list13; [EOL]         delegateBooleanAssertion(types, 13, 13, true); [EOL]         final Type disType = getClass().getField("dis").getGenericType(); [EOL]         // Reporter.log( ( ( ParameterizedType ) disType [EOL]         // ).getOwnerType().getClass().toString() ); [EOL]         final Type datType = getClass().getField("dat").getGenericType(); [EOL]         final Type daType = getClass().getField("da").getGenericType(); [EOL]         final Type uhderType = getClass().getField("uhder").getGenericType(); [EOL]         final Type dingType = getClass().getField("ding").getGenericType(); [EOL]         final Type testerType = getClass().getField("tester").getGenericType(); [EOL]         final Type tester2Type = getClass().getField("tester2").getGenericType(); [EOL]         final Type dat2Type = getClass().getField("dat2").getGenericType(); [EOL]         final Type dat3Type = getClass().getField("dat3").getGenericType(); [EOL]         dis = dat; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(datType, disType)); [EOL]         // dis = da; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(daType, disType)); [EOL]         dis = uhder; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(uhderType, disType)); [EOL]         dis = ding; [EOL]         Assert.assertFalse(String.format("type %s not assignable to %s!", dingType, disType), [EOL]                 TypeUtils.isAssignable(dingType, disType)); [EOL]         dis = tester; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(testerType, disType)); [EOL]         // dis = tester2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(tester2Type, disType)); [EOL]         // dat = dat2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat2Type, datType)); [EOL]         // dat2 = dat; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(datType, dat2Type)); [EOL]         // dat = dat3; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat3Type, datType)); [EOL]         final char ch = 0; [EOL]         final boolean bo = false; [EOL]         final byte by = 0; [EOL]         final short sh = 0; [EOL]         int in = 0; [EOL]         long lo = 0; [EOL]         final float fl = 0; [EOL]         double du = 0; [EOL]         du = ch; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(char.class, double.class)); [EOL]         du = by; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(byte.class, double.class)); [EOL]         du = sh; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(short.class, double.class)); [EOL]         du = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, double.class)); [EOL]         du = lo; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(long.class, double.class)); [EOL]         du = fl; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(float.class, double.class)); [EOL]         lo = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, long.class)); [EOL]         lo = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, long.class)); [EOL]         // Long lngW = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, Long.class)); [EOL]         // lngW = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, Long.class)); [EOL]         in = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, int.class)); [EOL]         final Integer inte = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Integer.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Number.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Object.class)); [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, intComparableType)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Comparable.class)); [EOL]         final Serializable ser = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Serializable.class)); [EOL]         final Type longComparableType = getClass().getField("longComparable").getGenericType(); [EOL]         // longComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, longComparableType)); [EOL]         // longComparable = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, longComparableType)); [EOL]         // int[] ia; [EOL]         // long[] la = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, long[].class)); [EOL]         final Integer[] ia = null; [EOL]         final Type caType = getClass().getField("intWildcardComparable").getGenericType(); [EOL]         intWildcardComparable = ia; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, caType)); [EOL]         // int[] ina = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer[].class, int[].class)); [EOL]         final int[] ina = null; [EOL]         Object[] oa; [EOL]         // oa = ina; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, Object[].class)); [EOL]         oa = new Integer[0]; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, Object[].class)); [EOL]         final Type bClassType = AClass.class.getField("bClass").getGenericType(); [EOL]         final Type cClassType = AClass.class.getField("cClass").getGenericType(); [EOL]         final Type dClassType = AClass.class.getField("dClass").getGenericType(); [EOL]         final Type eClassType = AClass.class.getField("eClass").getGenericType(); [EOL]         final Type fClassType = AClass.class.getField("fClass").getGenericType(); [EOL]         final AClass aClass = new AClass(new AAClass<String>()); [EOL]         aClass.bClass = aClass.cClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(cClassType, bClassType)); [EOL]         aClass.bClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, bClassType)); [EOL]         aClass.bClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, bClassType)); [EOL]         aClass.bClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, bClassType)); [EOL]         aClass.cClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, cClassType)); [EOL]         aClass.cClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, cClassType)); [EOL]         aClass.cClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, cClassType)); [EOL]         aClass.dClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, dClassType)); [EOL]         aClass.dClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, dClassType)); [EOL]         aClass.eClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, eClassType)); [EOL]     } [EOL]  [EOL]     public void delegateBooleanAssertion(final Type[] types, final int i2, final int i1, final boolean expected) { [EOL]         final Type type1 = types[i1]; [EOL]         final Type type2 = types[i2]; [EOL]         final boolean isAssignable = TypeUtils.isAssignable(type2, type1); [EOL]  [EOL]         if (expected) { [EOL]             Assert.assertTrue("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } else { [EOL]             Assert.assertFalse("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } [EOL]     } [EOL]  [EOL]     @SuppressWarnings("boxing") // boxing is deliberate here [EOL]
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [EOL]         final Type[] types = method.getGenericParameterTypes(); [EOL] //        list0 = list0; [EOL]         delegateBooleanAssertion(types, 0, 0, true); [EOL]         list1 = list0; [EOL]         delegateBooleanAssertion(types, 0, 1, true); [EOL]         list0 = list1; [EOL]         delegateBooleanAssertion(types, 1, 0, true); [EOL]         list2 = list0; [EOL]         delegateBooleanAssertion(types, 0, 2, true); [EOL]         list0 = list2; [EOL]         delegateBooleanAssertion(types, 2, 0, true); [EOL]         list3 = list0; [EOL]         delegateBooleanAssertion(types, 0, 3, true); [EOL]         list0 = list3; [EOL]         delegateBooleanAssertion(types, 3, 0, true); [EOL]         list4 = list0; [EOL]         delegateBooleanAssertion(types, 0, 4, true); [EOL]         list0 = list4; [EOL]         delegateBooleanAssertion(types, 4, 0, true); [EOL]         list5 = list0; [EOL]         delegateBooleanAssertion(types, 0, 5, true); [EOL]         list0 = list5; [EOL]         delegateBooleanAssertion(types, 5, 0, true); [EOL]         list6 = list0; [EOL]         delegateBooleanAssertion(types, 0, 6, true); [EOL]         list0 = list6; [EOL]         delegateBooleanAssertion(types, 6, 0, true); [EOL] //        list1 = list1; [EOL]         delegateBooleanAssertion(types, 1, 1, true); [EOL]         list2 = list1; [EOL]         delegateBooleanAssertion(types, 1, 2, true); [EOL]         list1 = (List<Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 1, false); [EOL]         list3 = list1; [EOL]         delegateBooleanAssertion(types, 1, 3, true); [EOL]         list1 = (List<Object>) list3; [EOL]         delegateBooleanAssertion(types, 3, 1, false); [EOL]         // list4 = list1; [EOL]         delegateBooleanAssertion(types, 1, 4, false); [EOL]         // list1 = list4; [EOL]         delegateBooleanAssertion(types, 4, 1, false); [EOL]         // list5 = list1; [EOL]         delegateBooleanAssertion(types, 1, 5, false); [EOL]         // list1 = list5; [EOL]         delegateBooleanAssertion(types, 5, 1, false); [EOL]         list6 = list1; [EOL]         delegateBooleanAssertion(types, 1, 6, true); [EOL]         list1 = (List<Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 1, false); [EOL] //        list2 = list2; [EOL]         delegateBooleanAssertion(types, 2, 2, true); [EOL]         list2 = list3; [EOL]         delegateBooleanAssertion(types, 2, 3, false); [EOL]         list2 = list4; [EOL]         delegateBooleanAssertion(types, 3, 2, true); [EOL]         list3 = (List<? super Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 4, false); [EOL]         list2 = list5; [EOL]         delegateBooleanAssertion(types, 4, 2, true); [EOL]         list4 = (List<String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 5, false); [EOL]         list2 = list6; [EOL]         delegateBooleanAssertion(types, 5, 2, true); [EOL]         list5 = (List<? extends String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 6, false); [EOL] //        list3 = list3; [EOL]         delegateBooleanAssertion(types, 6, 2, true); [EOL]         list6 = (List<? super String>) list2; [EOL]         delegateBooleanAssertion(types, 3, 3, true); [EOL]         // list4 = list3; [EOL]         delegateBooleanAssertion(types, 3, 4, false); [EOL]         // list3 = list4; [EOL]         delegateBooleanAssertion(types, 4, 3, false); [EOL]         // list5 = list3; [EOL]         delegateBooleanAssertion(types, 3, 5, false); [EOL]         // list3 = list5; [EOL]         delegateBooleanAssertion(types, 5, 3, false); [EOL]         list6 = list3; [EOL]         delegateBooleanAssertion(types, 3, 6, true); [EOL]         list3 = (List<? super Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 3, false); [EOL] //        list4 = list4; [EOL]         delegateBooleanAssertion(types, 4, 4, true); [EOL]         list5 = list4; [EOL]         delegateBooleanAssertion(types, 4, 5, true); [EOL]         list4 = (List<String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 4, false); [EOL]         list6 = list4; [EOL]         delegateBooleanAssertion(types, 4, 6, true); [EOL]         list4 = (List<String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 4, false); [EOL] //        list5 = list5; [EOL]         delegateBooleanAssertion(types, 5, 5, true); [EOL]         list6 = (List<? super String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 6, false); [EOL]         list5 = (List<? extends String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 5, false); [EOL] //        list6 = list6; [EOL]         delegateBooleanAssertion(types, 6, 6, true); [EOL]  [EOL] //        list7 = list7; [EOL]         delegateBooleanAssertion(types, 7, 7, true); [EOL]         list8 = list7; [EOL]         delegateBooleanAssertion(types, 7, 8, true); [EOL]         list7 = list8; [EOL]         delegateBooleanAssertion(types, 8, 7, true); [EOL]         list9 = list7; [EOL]         delegateBooleanAssertion(types, 7, 9, true); [EOL]         list7 = list9; [EOL]         delegateBooleanAssertion(types, 9, 7, true); [EOL]         list10 = list7; [EOL]         delegateBooleanAssertion(types, 7, 10, true); [EOL]         list7 = list10; [EOL]         delegateBooleanAssertion(types, 10, 7, true); [EOL]         list11 = list7; [EOL]         delegateBooleanAssertion(types, 7, 11, true); [EOL]         list7 = list11; [EOL]         delegateBooleanAssertion(types, 11, 7, true); [EOL]         list12 = list7; [EOL]         delegateBooleanAssertion(types, 7, 12, true); [EOL]         list7 = list12; [EOL]         delegateBooleanAssertion(types, 12, 7, true); [EOL]         list13 = list7; [EOL]         delegateBooleanAssertion(types, 7, 13, true); [EOL]         list7 = list13; [EOL]         delegateBooleanAssertion(types, 13, 7, true); [EOL] //        list8 = list8; [EOL]         delegateBooleanAssertion(types, 8, 8, true); [EOL]         list9 = list8; [EOL]         delegateBooleanAssertion(types, 8, 9, true); [EOL]         list8 = (List<Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 8, false); [EOL]         list10 = list8; [EOL]         delegateBooleanAssertion(types, 8, 10, true); [EOL]         list8 = (List<Object>[]) list10; // NOTE cast is required by Sun Java, but not by Eclipse [EOL]         delegateBooleanAssertion(types, 10, 8, false); [EOL]         // list11 = list8; [EOL]         delegateBooleanAssertion(types, 8, 11, false); [EOL]         // list8 = list11; [EOL]         delegateBooleanAssertion(types, 11, 8, false); [EOL]         // list12 = list8; [EOL]         delegateBooleanAssertion(types, 8, 12, false); [EOL]         // list8 = list12; [EOL]         delegateBooleanAssertion(types, 12, 8, false); [EOL]         list13 = list8; [EOL]         delegateBooleanAssertion(types, 8, 13, true); [EOL]         list8 = (List<Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 8, false); [EOL] //        list9 = list9; [EOL]         delegateBooleanAssertion(types, 9, 9, true); [EOL]         list10 = (List<? super Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 10, false); [EOL]         list9 = list10; [EOL]         delegateBooleanAssertion(types, 10, 9, true); [EOL]         list11 = (List<String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 11, false); [EOL]         list9 = list11; [EOL]         delegateBooleanAssertion(types, 11, 9, true); [EOL]         list12 = (List<? extends String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 12, false); [EOL]         list9 = list12; [EOL]         delegateBooleanAssertion(types, 12, 9, true); [EOL]         list13 = (List<? super String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 13, false); [EOL]         list9 = list13; [EOL]         delegateBooleanAssertion(types, 13, 9, true); [EOL] //        list10 = list10; [EOL]         delegateBooleanAssertion(types, 10, 10, true); [EOL]         // list11 = list10; [EOL]         delegateBooleanAssertion(types, 10, 11, false); [EOL]         // list10 = list11; [EOL]         delegateBooleanAssertion(types, 11, 10, false); [EOL]         // list12 = list10; [EOL]         delegateBooleanAssertion(types, 10, 12, false); [EOL]         // list10 = list12; [EOL]         delegateBooleanAssertion(types, 12, 10, false); [EOL]         list13 = list10; [EOL]         delegateBooleanAssertion(types, 10, 13, true); [EOL]         list10 = (List<? super Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 10, false); [EOL] //        list11 = list11; [EOL]         delegateBooleanAssertion(types, 11, 11, true); [EOL]         list12 = list11; [EOL]         delegateBooleanAssertion(types, 11, 12, true); [EOL]         list11 = (List<String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 11, false); [EOL]         list13 = list11; [EOL]         delegateBooleanAssertion(types, 11, 13, true); [EOL]         list11 = (List<String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 11, false); [EOL] //        list12 = list12; [EOL]         delegateBooleanAssertion(types, 12, 12, true); [EOL]         list13 = (List<? super String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 13, false); [EOL]         list12 = (List<? extends String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 12, false); [EOL] //        list13 = list13; [EOL]         delegateBooleanAssertion(types, 13, 13, true); [EOL]         final Type disType = getClass().getField("dis").getGenericType(); [EOL]         // Reporter.log( ( ( ParameterizedType ) disType [EOL]         // ).getOwnerType().getClass().toString() ); [EOL]         final Type datType = getClass().getField("dat").getGenericType(); [EOL]         final Type daType = getClass().getField("da").getGenericType(); [EOL]         final Type uhderType = getClass().getField("uhder").getGenericType(); [EOL]         final Type dingType = getClass().getField("ding").getGenericType(); [EOL]         final Type testerType = getClass().getField("tester").getGenericType(); [EOL]         final Type tester2Type = getClass().getField("tester2").getGenericType(); [EOL]         final Type dat2Type = getClass().getField("dat2").getGenericType(); [EOL]         final Type dat3Type = getClass().getField("dat3").getGenericType(); [EOL]         dis = dat; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(datType, disType)); [EOL]         // dis = da; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(daType, disType)); [EOL]         dis = uhder; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(uhderType, disType)); [EOL]         dis = ding; [EOL]         Assert.assertFalse(String.format("type %s not assignable to %s!", dingType, disType), [EOL]                 TypeUtils.isAssignable(dingType, disType)); [EOL]         dis = tester; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(testerType, disType)); [EOL]         // dis = tester2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(tester2Type, disType)); [EOL]         // dat = dat2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat2Type, datType)); [EOL]         // dat2 = dat; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(datType, dat2Type)); [EOL]         // dat = dat3; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat3Type, datType)); [EOL]         final char ch = 0; [EOL]         final boolean bo = false; [EOL]         final byte by = 0; [EOL]         final short sh = 0; [EOL]         int in = 0; [EOL]         long lo = 0; [EOL]         final float fl = 0; [EOL]         double du = 0; [EOL]         du = ch; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(char.class, double.class)); [EOL]         du = by; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(byte.class, double.class)); [EOL]         du = sh; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(short.class, double.class)); [EOL]         du = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, double.class)); [EOL]         du = lo; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(long.class, double.class)); [EOL]         du = fl; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(float.class, double.class)); [EOL]         lo = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, long.class)); [EOL]         lo = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, long.class)); [EOL]         // Long lngW = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, Long.class)); [EOL]         // lngW = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, Long.class)); [EOL]         in = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, int.class)); [EOL]         final Integer inte = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Integer.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Number.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Object.class)); [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, intComparableType)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Comparable.class)); [EOL]         final Serializable ser = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Serializable.class)); [EOL]         final Type longComparableType = getClass().getField("longComparable").getGenericType(); [EOL]         // longComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, longComparableType)); [EOL]         // longComparable = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, longComparableType)); [EOL]         // int[] ia; [EOL]         // long[] la = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, long[].class)); [EOL]         final Integer[] ia = null; [EOL]         final Type caType = getClass().getField("intWildcardComparable").getGenericType(); [EOL]         intWildcardComparable = ia; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, caType)); [EOL]         // int[] ina = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer[].class, int[].class)); [EOL]         final int[] ina = null; [EOL]         Object[] oa; [EOL]         // oa = ina; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, Object[].class)); [EOL]         oa = new Integer[0]; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, Object[].class)); [EOL]         final Type bClassType = AClass.class.getField("bClass").getGenericType(); [EOL]         final Type cClassType = AClass.class.getField("cClass").getGenericType(); [EOL]         final Type dClassType = AClass.class.getField("dClass").getGenericType(); [EOL]         final Type eClassType = AClass.class.getField("eClass").getGenericType(); [EOL]         final Type fClassType = AClass.class.getField("fClass").getGenericType(); [EOL]         final AClass aClass = new AClass(new AAClass<String>()); [EOL]         aClass.bClass = aClass.cClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(cClassType, bClassType)); [EOL]         aClass.bClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, bClassType)); [EOL]         aClass.bClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, bClassType)); [EOL]         aClass.bClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, bClassType)); [EOL]         aClass.cClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, cClassType)); [EOL]         aClass.cClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, cClassType)); [EOL]         aClass.cClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, cClassType)); [EOL]         aClass.dClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, dClassType)); [EOL]         aClass.dClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, dClassType)); [EOL]         aClass.eClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, eClassType)); [EOL]     } [EOL]  [EOL]     public void delegateBooleanAssertion(final Type[] types, final int i2, final int i1, final boolean expected) { [EOL]         final Type type1 = types[i1]; [EOL]         final Type type2 = types[i2]; [EOL]         final boolean isAssignable = TypeUtils.isAssignable(type2, type1); [EOL]  [EOL]         if (expected) { [EOL]             Assert.assertTrue("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } else { [EOL]             Assert.assertFalse("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } [EOL]     } [EOL]  [EOL]     @SuppressWarnings("boxing") // boxing is deliberate here [EOL]
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [EOL]         final Type[] types = method.getGenericParameterTypes(); [EOL] //        list0 = list0; [EOL]         delegateBooleanAssertion(types, 0, 0, true); [EOL]         list1 = list0; [EOL]         delegateBooleanAssertion(types, 0, 1, true); [EOL]         list0 = list1; [EOL]         delegateBooleanAssertion(types, 1, 0, true); [EOL]         list2 = list0; [EOL]         delegateBooleanAssertion(types, 0, 2, true); [EOL]         list0 = list2; [EOL]         delegateBooleanAssertion(types, 2, 0, true); [EOL]         list3 = list0; [EOL]         delegateBooleanAssertion(types, 0, 3, true); [EOL]         list0 = list3; [EOL]         delegateBooleanAssertion(types, 3, 0, true); [EOL]         list4 = list0; [EOL]         delegateBooleanAssertion(types, 0, 4, true); [EOL]         list0 = list4; [EOL]         delegateBooleanAssertion(types, 4, 0, true); [EOL]         list5 = list0; [EOL]         delegateBooleanAssertion(types, 0, 5, true); [EOL]         list0 = list5; [EOL]         delegateBooleanAssertion(types, 5, 0, true); [EOL]         list6 = list0; [EOL]         delegateBooleanAssertion(types, 0, 6, true); [EOL]         list0 = list6; [EOL]         delegateBooleanAssertion(types, 6, 0, true); [EOL] //        list1 = list1; [EOL]         delegateBooleanAssertion(types, 1, 1, true); [EOL]         list2 = list1; [EOL]         delegateBooleanAssertion(types, 1, 2, true); [EOL]         list1 = (List<Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 1, false); [EOL]         list3 = list1; [EOL]         delegateBooleanAssertion(types, 1, 3, true); [EOL]         list1 = (List<Object>) list3; [EOL]         delegateBooleanAssertion(types, 3, 1, false); [EOL]         // list4 = list1; [EOL]         delegateBooleanAssertion(types, 1, 4, false); [EOL]         // list1 = list4; [EOL]         delegateBooleanAssertion(types, 4, 1, false); [EOL]         // list5 = list1; [EOL]         delegateBooleanAssertion(types, 1, 5, false); [EOL]         // list1 = list5; [EOL]         delegateBooleanAssertion(types, 5, 1, false); [EOL]         list6 = list1; [EOL]         delegateBooleanAssertion(types, 1, 6, true); [EOL]         list1 = (List<Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 1, false); [EOL] //        list2 = list2; [EOL]         delegateBooleanAssertion(types, 2, 2, true); [EOL]         list2 = list3; [EOL]         delegateBooleanAssertion(types, 2, 3, false); [EOL]         list2 = list4; [EOL]         delegateBooleanAssertion(types, 3, 2, true); [EOL]         list3 = (List<? super Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 4, false); [EOL]         list2 = list5; [EOL]         delegateBooleanAssertion(types, 4, 2, true); [EOL]         list4 = (List<String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 5, false); [EOL]         list2 = list6; [EOL]         delegateBooleanAssertion(types, 5, 2, true); [EOL]         list5 = (List<? extends String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 6, false); [EOL] //        list3 = list3; [EOL]         delegateBooleanAssertion(types, 6, 2, true); [EOL]         list6 = (List<? super String>) list2; [EOL]         delegateBooleanAssertion(types, 3, 3, true); [EOL]         // list4 = list3; [EOL]         delegateBooleanAssertion(types, 3, 4, false); [EOL]         // list3 = list4; [EOL]         delegateBooleanAssertion(types, 4, 3, false); [EOL]         // list5 = list3; [EOL]         delegateBooleanAssertion(types, 3, 5, false); [EOL]         // list3 = list5; [EOL]         delegateBooleanAssertion(types, 5, 3, false); [EOL]         list6 = list3; [EOL]         delegateBooleanAssertion(types, 3, 6, true); [EOL]         list3 = (List<? super Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 3, false); [EOL] //        list4 = list4; [EOL]         delegateBooleanAssertion(types, 4, 4, true); [EOL]         list5 = list4; [EOL]         delegateBooleanAssertion(types, 4, 5, true); [EOL]         list4 = (List<String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 4, false); [EOL]         list6 = list4; [EOL]         delegateBooleanAssertion(types, 4, 6, true); [EOL]         list4 = (List<String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 4, false); [EOL] //        list5 = list5; [EOL]         delegateBooleanAssertion(types, 5, 5, true); [EOL]         list6 = (List<? super String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 6, false); [EOL]         list5 = (List<? extends String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 5, false); [EOL] //        list6 = list6; [EOL]         delegateBooleanAssertion(types, 6, 6, true); [EOL]  [EOL] //        list7 = list7; [EOL]         delegateBooleanAssertion(types, 7, 7, true); [EOL]         list8 = list7; [EOL]         delegateBooleanAssertion(types, 7, 8, true); [EOL]         list7 = list8; [EOL]         delegateBooleanAssertion(types, 8, 7, true); [EOL]         list9 = list7; [EOL]         delegateBooleanAssertion(types, 7, 9, true); [EOL]         list7 = list9; [EOL]         delegateBooleanAssertion(types, 9, 7, true); [EOL]         list10 = list7; [EOL]         delegateBooleanAssertion(types, 7, 10, true); [EOL]         list7 = list10; [EOL]         delegateBooleanAssertion(types, 10, 7, true); [EOL]         list11 = list7; [EOL]         delegateBooleanAssertion(types, 7, 11, true); [EOL]         list7 = list11; [EOL]         delegateBooleanAssertion(types, 11, 7, true); [EOL]         list12 = list7; [EOL]         delegateBooleanAssertion(types, 7, 12, true); [EOL]         list7 = list12; [EOL]         delegateBooleanAssertion(types, 12, 7, true); [EOL]         list13 = list7; [EOL]         delegateBooleanAssertion(types, 7, 13, true); [EOL]         list7 = list13; [EOL]         delegateBooleanAssertion(types, 13, 7, true); [EOL] //        list8 = list8; [EOL]         delegateBooleanAssertion(types, 8, 8, true); [EOL]         list9 = list8; [EOL]         delegateBooleanAssertion(types, 8, 9, true); [EOL]         list8 = (List<Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 8, false); [EOL]         list10 = list8; [EOL]         delegateBooleanAssertion(types, 8, 10, true); [EOL]         list8 = (List<Object>[]) list10; // NOTE cast is required by Sun Java, but not by Eclipse [EOL]         delegateBooleanAssertion(types, 10, 8, false); [EOL]         // list11 = list8; [EOL]         delegateBooleanAssertion(types, 8, 11, false); [EOL]         // list8 = list11; [EOL]         delegateBooleanAssertion(types, 11, 8, false); [EOL]         // list12 = list8; [EOL]         delegateBooleanAssertion(types, 8, 12, false); [EOL]         // list8 = list12; [EOL]         delegateBooleanAssertion(types, 12, 8, false); [EOL]         list13 = list8; [EOL]         delegateBooleanAssertion(types, 8, 13, true); [EOL]         list8 = (List<Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 8, false); [EOL] //        list9 = list9; [EOL]         delegateBooleanAssertion(types, 9, 9, true); [EOL]         list10 = (List<? super Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 10, false); [EOL]         list9 = list10; [EOL]         delegateBooleanAssertion(types, 10, 9, true); [EOL]         list11 = (List<String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 11, false); [EOL]         list9 = list11; [EOL]         delegateBooleanAssertion(types, 11, 9, true); [EOL]         list12 = (List<? extends String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 12, false); [EOL]         list9 = list12; [EOL]         delegateBooleanAssertion(types, 12, 9, true); [EOL]         list13 = (List<? super String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 13, false); [EOL]         list9 = list13; [EOL]         delegateBooleanAssertion(types, 13, 9, true); [EOL] //        list10 = list10; [EOL]         delegateBooleanAssertion(types, 10, 10, true); [EOL]         // list11 = list10; [EOL]         delegateBooleanAssertion(types, 10, 11, false); [EOL]         // list10 = list11; [EOL]         delegateBooleanAssertion(types, 11, 10, false); [EOL]         // list12 = list10; [EOL]         delegateBooleanAssertion(types, 10, 12, false); [EOL]         // list10 = list12; [EOL]         delegateBooleanAssertion(types, 12, 10, false); [EOL]         list13 = list10; [EOL]         delegateBooleanAssertion(types, 10, 13, true); [EOL]         list10 = (List<? super Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 10, false); [EOL] //        list11 = list11; [EOL]         delegateBooleanAssertion(types, 11, 11, true); [EOL]         list12 = list11; [EOL]         delegateBooleanAssertion(types, 11, 12, true); [EOL]         list11 = (List<String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 11, false); [EOL]         list13 = list11; [EOL]         delegateBooleanAssertion(types, 11, 13, true); [EOL]         list11 = (List<String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 11, false); [EOL] //        list12 = list12; [EOL]         delegateBooleanAssertion(types, 12, 12, true); [EOL]         list13 = (List<? super String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 13, false); [EOL]         list12 = (List<? extends String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 12, false); [EOL] //        list13 = list13; [EOL]         delegateBooleanAssertion(types, 13, 13, true); [EOL]         final Type disType = getClass().getField("dis").getGenericType(); [EOL]         // Reporter.log( ( ( ParameterizedType ) disType [EOL]         // ).getOwnerType().getClass().toString() ); [EOL]         final Type datType = getClass().getField("dat").getGenericType(); [EOL]         final Type daType = getClass().getField("da").getGenericType(); [EOL]         final Type uhderType = getClass().getField("uhder").getGenericType(); [EOL]         final Type dingType = getClass().getField("ding").getGenericType(); [EOL]         final Type testerType = getClass().getField("tester").getGenericType(); [EOL]         final Type tester2Type = getClass().getField("tester2").getGenericType(); [EOL]         final Type dat2Type = getClass().getField("dat2").getGenericType(); [EOL]         final Type dat3Type = getClass().getField("dat3").getGenericType(); [EOL]         dis = dat; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(datType, disType)); [EOL]         // dis = da; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(daType, disType)); [EOL]         dis = uhder; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(uhderType, disType)); [EOL]         dis = ding; [EOL]         Assert.assertFalse(String.format("type %s not assignable to %s!", dingType, disType), [EOL]                 TypeUtils.isAssignable(dingType, disType)); [EOL]         dis = tester; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(testerType, disType)); [EOL]         // dis = tester2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(tester2Type, disType)); [EOL]         // dat = dat2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat2Type, datType)); [EOL]         // dat2 = dat; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(datType, dat2Type)); [EOL]         // dat = dat3; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat3Type, datType)); [EOL]         final char ch = 0; [EOL]         final boolean bo = false; [EOL]         final byte by = 0; [EOL]         final short sh = 0; [EOL]         int in = 0; [EOL]         long lo = 0; [EOL]         final float fl = 0; [EOL]         double du = 0; [EOL]         du = ch; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(char.class, double.class)); [EOL]         du = by; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(byte.class, double.class)); [EOL]         du = sh; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(short.class, double.class)); [EOL]         du = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, double.class)); [EOL]         du = lo; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(long.class, double.class)); [EOL]         du = fl; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(float.class, double.class)); [EOL]         lo = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, long.class)); [EOL]         lo = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, long.class)); [EOL]         // Long lngW = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, Long.class)); [EOL]         // lngW = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, Long.class)); [EOL]         in = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, int.class)); [EOL]         final Integer inte = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Integer.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Number.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Object.class)); [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, intComparableType)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Comparable.class)); [EOL]         final Serializable ser = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Serializable.class)); [EOL]         final Type longComparableType = getClass().getField("longComparable").getGenericType(); [EOL]         // longComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, longComparableType)); [EOL]         // longComparable = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, longComparableType)); [EOL]         // int[] ia; [EOL]         // long[] la = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, long[].class)); [EOL]         final Integer[] ia = null; [EOL]         final Type caType = getClass().getField("intWildcardComparable").getGenericType(); [EOL]         intWildcardComparable = ia; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, caType)); [EOL]         // int[] ina = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer[].class, int[].class)); [EOL]         final int[] ina = null; [EOL]         Object[] oa; [EOL]         // oa = ina; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, Object[].class)); [EOL]         oa = new Integer[0]; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, Object[].class)); [EOL]         final Type bClassType = AClass.class.getField("bClass").getGenericType(); [EOL]         final Type cClassType = AClass.class.getField("cClass").getGenericType(); [EOL]         final Type dClassType = AClass.class.getField("dClass").getGenericType(); [EOL]         final Type eClassType = AClass.class.getField("eClass").getGenericType(); [EOL]         final Type fClassType = AClass.class.getField("fClass").getGenericType(); [EOL]         final AClass aClass = new AClass(new AAClass<String>()); [EOL]         aClass.bClass = aClass.cClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(cClassType, bClassType)); [EOL]         aClass.bClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, bClassType)); [EOL]         aClass.bClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, bClassType)); [EOL]         aClass.bClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, bClassType)); [EOL]         aClass.cClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, cClassType)); [EOL]         aClass.cClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, cClassType)); [EOL]         aClass.cClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, cClassType)); [EOL]         aClass.dClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, dClassType)); [EOL]         aClass.dClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, dClassType)); [EOL]         aClass.eClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, eClassType)); [EOL]     } [EOL]  [EOL]     public void delegateBooleanAssertion(final Type[] types, final int i2, final int i1, final boolean expected) { [EOL]         final Type type1 = types[i1]; [EOL]         final Type type2 = types[i2]; [EOL]         final boolean isAssignable = TypeUtils.isAssignable(type2, type1); [EOL]  [EOL]         if (expected) { [EOL]             Assert.assertTrue("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } else { [EOL]             Assert.assertFalse("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } [EOL]     } [EOL]  [EOL]     @SuppressWarnings("boxing") // boxing is deliberate here [EOL]
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [EOL]         final Type[] types = method.getGenericParameterTypes(); [EOL] //        list0 = list0; [EOL]         delegateBooleanAssertion(types, 0, 0, true); [EOL]         list1 = list0; [EOL]         delegateBooleanAssertion(types, 0, 1, true); [EOL]         list0 = list1; [EOL]         delegateBooleanAssertion(types, 1, 0, true); [EOL]         list2 = list0; [EOL]         delegateBooleanAssertion(types, 0, 2, true); [EOL]         list0 = list2; [EOL]         delegateBooleanAssertion(types, 2, 0, true); [EOL]         list3 = list0; [EOL]         delegateBooleanAssertion(types, 0, 3, true); [EOL]         list0 = list3; [EOL]         delegateBooleanAssertion(types, 3, 0, true); [EOL]         list4 = list0; [EOL]         delegateBooleanAssertion(types, 0, 4, true); [EOL]         list0 = list4; [EOL]         delegateBooleanAssertion(types, 4, 0, true); [EOL]         list5 = list0; [EOL]         delegateBooleanAssertion(types, 0, 5, true); [EOL]         list0 = list5; [EOL]         delegateBooleanAssertion(types, 5, 0, true); [EOL]         list6 = list0; [EOL]         delegateBooleanAssertion(types, 0, 6, true); [EOL]         list0 = list6; [EOL]         delegateBooleanAssertion(types, 6, 0, true); [EOL] //        list1 = list1; [EOL]         delegateBooleanAssertion(types, 1, 1, true); [EOL]         list2 = list1; [EOL]         delegateBooleanAssertion(types, 1, 2, true); [EOL]         list1 = (List<Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 1, false); [EOL]         list3 = list1; [EOL]         delegateBooleanAssertion(types, 1, 3, true); [EOL]         list1 = (List<Object>) list3; [EOL]         delegateBooleanAssertion(types, 3, 1, false); [EOL]         // list4 = list1; [EOL]         delegateBooleanAssertion(types, 1, 4, false); [EOL]         // list1 = list4; [EOL]         delegateBooleanAssertion(types, 4, 1, false); [EOL]         // list5 = list1; [EOL]         delegateBooleanAssertion(types, 1, 5, false); [EOL]         // list1 = list5; [EOL]         delegateBooleanAssertion(types, 5, 1, false); [EOL]         list6 = list1; [EOL]         delegateBooleanAssertion(types, 1, 6, true); [EOL]         list1 = (List<Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 1, false); [EOL] //        list2 = list2; [EOL]         delegateBooleanAssertion(types, 2, 2, true); [EOL]         list2 = list3; [EOL]         delegateBooleanAssertion(types, 2, 3, false); [EOL]         list2 = list4; [EOL]         delegateBooleanAssertion(types, 3, 2, true); [EOL]         list3 = (List<? super Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 4, false); [EOL]         list2 = list5; [EOL]         delegateBooleanAssertion(types, 4, 2, true); [EOL]         list4 = (List<String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 5, false); [EOL]         list2 = list6; [EOL]         delegateBooleanAssertion(types, 5, 2, true); [EOL]         list5 = (List<? extends String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 6, false); [EOL] //        list3 = list3; [EOL]         delegateBooleanAssertion(types, 6, 2, true); [EOL]         list6 = (List<? super String>) list2; [EOL]         delegateBooleanAssertion(types, 3, 3, true); [EOL]         // list4 = list3; [EOL]         delegateBooleanAssertion(types, 3, 4, false); [EOL]         // list3 = list4; [EOL]         delegateBooleanAssertion(types, 4, 3, false); [EOL]         // list5 = list3; [EOL]         delegateBooleanAssertion(types, 3, 5, false); [EOL]         // list3 = list5; [EOL]         delegateBooleanAssertion(types, 5, 3, false); [EOL]         list6 = list3; [EOL]         delegateBooleanAssertion(types, 3, 6, true); [EOL]         list3 = (List<? super Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 3, false); [EOL] //        list4 = list4; [EOL]         delegateBooleanAssertion(types, 4, 4, true); [EOL]         list5 = list4; [EOL]         delegateBooleanAssertion(types, 4, 5, true); [EOL]         list4 = (List<String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 4, false); [EOL]         list6 = list4; [EOL]         delegateBooleanAssertion(types, 4, 6, true); [EOL]         list4 = (List<String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 4, false); [EOL] //        list5 = list5; [EOL]         delegateBooleanAssertion(types, 5, 5, true); [EOL]         list6 = (List<? super String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 6, false); [EOL]         list5 = (List<? extends String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 5, false); [EOL] //        list6 = list6; [EOL]         delegateBooleanAssertion(types, 6, 6, true); [EOL]  [EOL] //        list7 = list7; [EOL]         delegateBooleanAssertion(types, 7, 7, true); [EOL]         list8 = list7; [EOL]         delegateBooleanAssertion(types, 7, 8, true); [EOL]         list7 = list8; [EOL]         delegateBooleanAssertion(types, 8, 7, true); [EOL]         list9 = list7; [EOL]         delegateBooleanAssertion(types, 7, 9, true); [EOL]         list7 = list9; [EOL]         delegateBooleanAssertion(types, 9, 7, true); [EOL]         list10 = list7; [EOL]         delegateBooleanAssertion(types, 7, 10, true); [EOL]         list7 = list10; [EOL]         delegateBooleanAssertion(types, 10, 7, true); [EOL]         list11 = list7; [EOL]         delegateBooleanAssertion(types, 7, 11, true); [EOL]         list7 = list11; [EOL]         delegateBooleanAssertion(types, 11, 7, true); [EOL]         list12 = list7; [EOL]         delegateBooleanAssertion(types, 7, 12, true); [EOL]         list7 = list12; [EOL]         delegateBooleanAssertion(types, 12, 7, true); [EOL]         list13 = list7; [EOL]         delegateBooleanAssertion(types, 7, 13, true); [EOL]         list7 = list13; [EOL]         delegateBooleanAssertion(types, 13, 7, true); [EOL] //        list8 = list8; [EOL]         delegateBooleanAssertion(types, 8, 8, true); [EOL]         list9 = list8; [EOL]         delegateBooleanAssertion(types, 8, 9, true); [EOL]         list8 = (List<Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 8, false); [EOL]         list10 = list8; [EOL]         delegateBooleanAssertion(types, 8, 10, true); [EOL]         list8 = (List<Object>[]) list10; // NOTE cast is required by Sun Java, but not by Eclipse [EOL]         delegateBooleanAssertion(types, 10, 8, false); [EOL]         // list11 = list8; [EOL]         delegateBooleanAssertion(types, 8, 11, false); [EOL]         // list8 = list11; [EOL]         delegateBooleanAssertion(types, 11, 8, false); [EOL]         // list12 = list8; [EOL]         delegateBooleanAssertion(types, 8, 12, false); [EOL]         // list8 = list12; [EOL]         delegateBooleanAssertion(types, 12, 8, false); [EOL]         list13 = list8; [EOL]         delegateBooleanAssertion(types, 8, 13, true); [EOL]         list8 = (List<Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 8, false); [EOL] //        list9 = list9; [EOL]         delegateBooleanAssertion(types, 9, 9, true); [EOL]         list10 = (List<? super Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 10, false); [EOL]         list9 = list10; [EOL]         delegateBooleanAssertion(types, 10, 9, true); [EOL]         list11 = (List<String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 11, false); [EOL]         list9 = list11; [EOL]         delegateBooleanAssertion(types, 11, 9, true); [EOL]         list12 = (List<? extends String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 12, false); [EOL]         list9 = list12; [EOL]         delegateBooleanAssertion(types, 12, 9, true); [EOL]         list13 = (List<? super String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 13, false); [EOL]         list9 = list13; [EOL]         delegateBooleanAssertion(types, 13, 9, true); [EOL] //        list10 = list10; [EOL]         delegateBooleanAssertion(types, 10, 10, true); [EOL]         // list11 = list10; [EOL]         delegateBooleanAssertion(types, 10, 11, false); [EOL]         // list10 = list11; [EOL]         delegateBooleanAssertion(types, 11, 10, false); [EOL]         // list12 = list10; [EOL]         delegateBooleanAssertion(types, 10, 12, false); [EOL]         // list10 = list12; [EOL]         delegateBooleanAssertion(types, 12, 10, false); [EOL]         list13 = list10; [EOL]         delegateBooleanAssertion(types, 10, 13, true); [EOL]         list10 = (List<? super Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 10, false); [EOL] //        list11 = list11; [EOL]         delegateBooleanAssertion(types, 11, 11, true); [EOL]         list12 = list11; [EOL]         delegateBooleanAssertion(types, 11, 12, true); [EOL]         list11 = (List<String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 11, false); [EOL]         list13 = list11; [EOL]         delegateBooleanAssertion(types, 11, 13, true); [EOL]         list11 = (List<String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 11, false); [EOL] //        list12 = list12; [EOL]         delegateBooleanAssertion(types, 12, 12, true); [EOL]         list13 = (List<? super String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 13, false); [EOL]         list12 = (List<? extends String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 12, false); [EOL] //        list13 = list13; [EOL]         delegateBooleanAssertion(types, 13, 13, true); [EOL]         final Type disType = getClass().getField("dis").getGenericType(); [EOL]         // Reporter.log( ( ( ParameterizedType ) disType [EOL]         // ).getOwnerType().getClass().toString() ); [EOL]         final Type datType = getClass().getField("dat").getGenericType(); [EOL]         final Type daType = getClass().getField("da").getGenericType(); [EOL]         final Type uhderType = getClass().getField("uhder").getGenericType(); [EOL]         final Type dingType = getClass().getField("ding").getGenericType(); [EOL]         final Type testerType = getClass().getField("tester").getGenericType(); [EOL]         final Type tester2Type = getClass().getField("tester2").getGenericType(); [EOL]         final Type dat2Type = getClass().getField("dat2").getGenericType(); [EOL]         final Type dat3Type = getClass().getField("dat3").getGenericType(); [EOL]         dis = dat; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(datType, disType)); [EOL]         // dis = da; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(daType, disType)); [EOL]         dis = uhder; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(uhderType, disType)); [EOL]         dis = ding; [EOL]         Assert.assertFalse(String.format("type %s not assignable to %s!", dingType, disType), [EOL]                 TypeUtils.isAssignable(dingType, disType)); [EOL]         dis = tester; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(testerType, disType)); [EOL]         // dis = tester2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(tester2Type, disType)); [EOL]         // dat = dat2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat2Type, datType)); [EOL]         // dat2 = dat; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(datType, dat2Type)); [EOL]         // dat = dat3; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat3Type, datType)); [EOL]         final char ch = 0; [EOL]         final boolean bo = false; [EOL]         final byte by = 0; [EOL]         final short sh = 0; [EOL]         int in = 0; [EOL]         long lo = 0; [EOL]         final float fl = 0; [EOL]         double du = 0; [EOL]         du = ch; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(char.class, double.class)); [EOL]         du = by; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(byte.class, double.class)); [EOL]         du = sh; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(short.class, double.class)); [EOL]         du = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, double.class)); [EOL]         du = lo; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(long.class, double.class)); [EOL]         du = fl; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(float.class, double.class)); [EOL]         lo = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, long.class)); [EOL]         lo = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, long.class)); [EOL]         // Long lngW = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, Long.class)); [EOL]         // lngW = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, Long.class)); [EOL]         in = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, int.class)); [EOL]         final Integer inte = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Integer.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Number.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Object.class)); [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, intComparableType)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Comparable.class)); [EOL]         final Serializable ser = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Serializable.class)); [EOL]         final Type longComparableType = getClass().getField("longComparable").getGenericType(); [EOL]         // longComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, longComparableType)); [EOL]         // longComparable = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, longComparableType)); [EOL]         // int[] ia; [EOL]         // long[] la = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, long[].class)); [EOL]         final Integer[] ia = null; [EOL]         final Type caType = getClass().getField("intWildcardComparable").getGenericType(); [EOL]         intWildcardComparable = ia; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, caType)); [EOL]         // int[] ina = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer[].class, int[].class)); [EOL]         final int[] ina = null; [EOL]         Object[] oa; [EOL]         // oa = ina; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, Object[].class)); [EOL]         oa = new Integer[0]; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, Object[].class)); [EOL]         final Type bClassType = AClass.class.getField("bClass").getGenericType(); [EOL]         final Type cClassType = AClass.class.getField("cClass").getGenericType(); [EOL]         final Type dClassType = AClass.class.getField("dClass").getGenericType(); [EOL]         final Type eClassType = AClass.class.getField("eClass").getGenericType(); [EOL]         final Type fClassType = AClass.class.getField("fClass").getGenericType(); [EOL]         final AClass aClass = new AClass(new AAClass<String>()); [EOL]         aClass.bClass = aClass.cClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(cClassType, bClassType)); [EOL]         aClass.bClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, bClassType)); [EOL]         aClass.bClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, bClassType)); [EOL]         aClass.bClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, bClassType)); [EOL]         aClass.cClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, cClassType)); [EOL]         aClass.cClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, cClassType)); [EOL]         aClass.cClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, cClassType)); [EOL]         aClass.dClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, dClassType)); [EOL]         aClass.dClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, dClassType)); [EOL]         aClass.eClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, eClassType)); [EOL]     } [EOL]  [EOL]     public void delegateBooleanAssertion(final Type[] types, final int i2, final int i1, final boolean expected) { [EOL]         final Type type1 = types[i1]; [EOL]         final Type type2 = types[i2]; [EOL]         final boolean isAssignable = TypeUtils.isAssignable(type2, type1); [EOL]  [EOL]         if (expected) { [EOL]             Assert.assertTrue("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } else { [EOL]             Assert.assertFalse("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } [EOL]     } [EOL]  [EOL]     @SuppressWarnings("boxing") // boxing is deliberate here [EOL]
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [EOL]         final Type[] types = method.getGenericParameterTypes(); [EOL] //        list0 = list0; [EOL]         delegateBooleanAssertion(types, 0, 0, true); [EOL]         list1 = list0; [EOL]         delegateBooleanAssertion(types, 0, 1, true); [EOL]         list0 = list1; [EOL]         delegateBooleanAssertion(types, 1, 0, true); [EOL]         list2 = list0; [EOL]         delegateBooleanAssertion(types, 0, 2, true); [EOL]         list0 = list2; [EOL]         delegateBooleanAssertion(types, 2, 0, true); [EOL]         list3 = list0; [EOL]         delegateBooleanAssertion(types, 0, 3, true); [EOL]         list0 = list3; [EOL]         delegateBooleanAssertion(types, 3, 0, true); [EOL]         list4 = list0; [EOL]         delegateBooleanAssertion(types, 0, 4, true); [EOL]         list0 = list4; [EOL]         delegateBooleanAssertion(types, 4, 0, true); [EOL]         list5 = list0; [EOL]         delegateBooleanAssertion(types, 0, 5, true); [EOL]         list0 = list5; [EOL]         delegateBooleanAssertion(types, 5, 0, true); [EOL]         list6 = list0; [EOL]         delegateBooleanAssertion(types, 0, 6, true); [EOL]         list0 = list6; [EOL]         delegateBooleanAssertion(types, 6, 0, true); [EOL] //        list1 = list1; [EOL]         delegateBooleanAssertion(types, 1, 1, true); [EOL]         list2 = list1; [EOL]         delegateBooleanAssertion(types, 1, 2, true); [EOL]         list1 = (List<Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 1, false); [EOL]         list3 = list1; [EOL]         delegateBooleanAssertion(types, 1, 3, true); [EOL]         list1 = (List<Object>) list3; [EOL]         delegateBooleanAssertion(types, 3, 1, false); [EOL]         // list4 = list1; [EOL]         delegateBooleanAssertion(types, 1, 4, false); [EOL]         // list1 = list4; [EOL]         delegateBooleanAssertion(types, 4, 1, false); [EOL]         // list5 = list1; [EOL]         delegateBooleanAssertion(types, 1, 5, false); [EOL]         // list1 = list5; [EOL]         delegateBooleanAssertion(types, 5, 1, false); [EOL]         list6 = list1; [EOL]         delegateBooleanAssertion(types, 1, 6, true); [EOL]         list1 = (List<Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 1, false); [EOL] //        list2 = list2; [EOL]         delegateBooleanAssertion(types, 2, 2, true); [EOL]         list2 = list3; [EOL]         delegateBooleanAssertion(types, 2, 3, false); [EOL]         list2 = list4; [EOL]         delegateBooleanAssertion(types, 3, 2, true); [EOL]         list3 = (List<? super Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 4, false); [EOL]         list2 = list5; [EOL]         delegateBooleanAssertion(types, 4, 2, true); [EOL]         list4 = (List<String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 5, false); [EOL]         list2 = list6; [EOL]         delegateBooleanAssertion(types, 5, 2, true); [EOL]         list5 = (List<? extends String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 6, false); [EOL] //        list3 = list3; [EOL]         delegateBooleanAssertion(types, 6, 2, true); [EOL]         list6 = (List<? super String>) list2; [EOL]         delegateBooleanAssertion(types, 3, 3, true); [EOL]         // list4 = list3; [EOL]         delegateBooleanAssertion(types, 3, 4, false); [EOL]         // list3 = list4; [EOL]         delegateBooleanAssertion(types, 4, 3, false); [EOL]         // list5 = list3; [EOL]         delegateBooleanAssertion(types, 3, 5, false); [EOL]         // list3 = list5; [EOL]         delegateBooleanAssertion(types, 5, 3, false); [EOL]         list6 = list3; [EOL]         delegateBooleanAssertion(types, 3, 6, true); [EOL]         list3 = (List<? super Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 3, false); [EOL] //        list4 = list4; [EOL]         delegateBooleanAssertion(types, 4, 4, true); [EOL]         list5 = list4; [EOL]         delegateBooleanAssertion(types, 4, 5, true); [EOL]         list4 = (List<String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 4, false); [EOL]         list6 = list4; [EOL]         delegateBooleanAssertion(types, 4, 6, true); [EOL]         list4 = (List<String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 4, false); [EOL] //        list5 = list5; [EOL]         delegateBooleanAssertion(types, 5, 5, true); [EOL]         list6 = (List<? super String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 6, false); [EOL]         list5 = (List<? extends String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 5, false); [EOL] //        list6 = list6; [EOL]         delegateBooleanAssertion(types, 6, 6, true); [EOL]  [EOL] //        list7 = list7; [EOL]         delegateBooleanAssertion(types, 7, 7, true); [EOL]         list8 = list7; [EOL]         delegateBooleanAssertion(types, 7, 8, true); [EOL]         list7 = list8; [EOL]         delegateBooleanAssertion(types, 8, 7, true); [EOL]         list9 = list7; [EOL]         delegateBooleanAssertion(types, 7, 9, true); [EOL]         list7 = list9; [EOL]         delegateBooleanAssertion(types, 9, 7, true); [EOL]         list10 = list7; [EOL]         delegateBooleanAssertion(types, 7, 10, true); [EOL]         list7 = list10; [EOL]         delegateBooleanAssertion(types, 10, 7, true); [EOL]         list11 = list7; [EOL]         delegateBooleanAssertion(types, 7, 11, true); [EOL]         list7 = list11; [EOL]         delegateBooleanAssertion(types, 11, 7, true); [EOL]         list12 = list7; [EOL]         delegateBooleanAssertion(types, 7, 12, true); [EOL]         list7 = list12; [EOL]         delegateBooleanAssertion(types, 12, 7, true); [EOL]         list13 = list7; [EOL]         delegateBooleanAssertion(types, 7, 13, true); [EOL]         list7 = list13; [EOL]         delegateBooleanAssertion(types, 13, 7, true); [EOL] //        list8 = list8; [EOL]         delegateBooleanAssertion(types, 8, 8, true); [EOL]         list9 = list8; [EOL]         delegateBooleanAssertion(types, 8, 9, true); [EOL]         list8 = (List<Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 8, false); [EOL]         list10 = list8; [EOL]         delegateBooleanAssertion(types, 8, 10, true); [EOL]         list8 = (List<Object>[]) list10; // NOTE cast is required by Sun Java, but not by Eclipse [EOL]         delegateBooleanAssertion(types, 10, 8, false); [EOL]         // list11 = list8; [EOL]         delegateBooleanAssertion(types, 8, 11, false); [EOL]         // list8 = list11; [EOL]         delegateBooleanAssertion(types, 11, 8, false); [EOL]         // list12 = list8; [EOL]         delegateBooleanAssertion(types, 8, 12, false); [EOL]         // list8 = list12; [EOL]         delegateBooleanAssertion(types, 12, 8, false); [EOL]         list13 = list8; [EOL]         delegateBooleanAssertion(types, 8, 13, true); [EOL]         list8 = (List<Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 8, false); [EOL] //        list9 = list9; [EOL]         delegateBooleanAssertion(types, 9, 9, true); [EOL]         list10 = (List<? super Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 10, false); [EOL]         list9 = list10; [EOL]         delegateBooleanAssertion(types, 10, 9, true); [EOL]         list11 = (List<String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 11, false); [EOL]         list9 = list11; [EOL]         delegateBooleanAssertion(types, 11, 9, true); [EOL]         list12 = (List<? extends String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 12, false); [EOL]         list9 = list12; [EOL]         delegateBooleanAssertion(types, 12, 9, true); [EOL]         list13 = (List<? super String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 13, false); [EOL]         list9 = list13; [EOL]         delegateBooleanAssertion(types, 13, 9, true); [EOL] //        list10 = list10; [EOL]         delegateBooleanAssertion(types, 10, 10, true); [EOL]         // list11 = list10; [EOL]         delegateBooleanAssertion(types, 10, 11, false); [EOL]         // list10 = list11; [EOL]         delegateBooleanAssertion(types, 11, 10, false); [EOL]         // list12 = list10; [EOL]         delegateBooleanAssertion(types, 10, 12, false); [EOL]         // list10 = list12; [EOL]         delegateBooleanAssertion(types, 12, 10, false); [EOL]         list13 = list10; [EOL]         delegateBooleanAssertion(types, 10, 13, true); [EOL]         list10 = (List<? super Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 10, false); [EOL] //        list11 = list11; [EOL]         delegateBooleanAssertion(types, 11, 11, true); [EOL]         list12 = list11; [EOL]         delegateBooleanAssertion(types, 11, 12, true); [EOL]         list11 = (List<String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 11, false); [EOL]         list13 = list11; [EOL]         delegateBooleanAssertion(types, 11, 13, true); [EOL]         list11 = (List<String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 11, false); [EOL] //        list12 = list12; [EOL]         delegateBooleanAssertion(types, 12, 12, true); [EOL]         list13 = (List<? super String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 13, false); [EOL]         list12 = (List<? extends String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 12, false); [EOL] //        list13 = list13; [EOL]         delegateBooleanAssertion(types, 13, 13, true); [EOL]         final Type disType = getClass().getField("dis").getGenericType(); [EOL]         // Reporter.log( ( ( ParameterizedType ) disType [EOL]         // ).getOwnerType().getClass().toString() ); [EOL]         final Type datType = getClass().getField("dat").getGenericType(); [EOL]         final Type daType = getClass().getField("da").getGenericType(); [EOL]         final Type uhderType = getClass().getField("uhder").getGenericType(); [EOL]         final Type dingType = getClass().getField("ding").getGenericType(); [EOL]         final Type testerType = getClass().getField("tester").getGenericType(); [EOL]         final Type tester2Type = getClass().getField("tester2").getGenericType(); [EOL]         final Type dat2Type = getClass().getField("dat2").getGenericType(); [EOL]         final Type dat3Type = getClass().getField("dat3").getGenericType(); [EOL]         dis = dat; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(datType, disType)); [EOL]         // dis = da; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(daType, disType)); [EOL]         dis = uhder; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(uhderType, disType)); [EOL]         dis = ding; [EOL]         Assert.assertFalse(String.format("type %s not assignable to %s!", dingType, disType), [EOL]                 TypeUtils.isAssignable(dingType, disType)); [EOL]         dis = tester; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(testerType, disType)); [EOL]         // dis = tester2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(tester2Type, disType)); [EOL]         // dat = dat2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat2Type, datType)); [EOL]         // dat2 = dat; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(datType, dat2Type)); [EOL]         // dat = dat3; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat3Type, datType)); [EOL]         final char ch = 0; [EOL]         final boolean bo = false; [EOL]         final byte by = 0; [EOL]         final short sh = 0; [EOL]         int in = 0; [EOL]         long lo = 0; [EOL]         final float fl = 0; [EOL]         double du = 0; [EOL]         du = ch; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(char.class, double.class)); [EOL]         du = by; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(byte.class, double.class)); [EOL]         du = sh; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(short.class, double.class)); [EOL]         du = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, double.class)); [EOL]         du = lo; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(long.class, double.class)); [EOL]         du = fl; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(float.class, double.class)); [EOL]         lo = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, long.class)); [EOL]         lo = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, long.class)); [EOL]         // Long lngW = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, Long.class)); [EOL]         // lngW = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, Long.class)); [EOL]         in = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, int.class)); [EOL]         final Integer inte = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Integer.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Number.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Object.class)); [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, intComparableType)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Comparable.class)); [EOL]         final Serializable ser = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Serializable.class)); [EOL]         final Type longComparableType = getClass().getField("longComparable").getGenericType(); [EOL]         // longComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, longComparableType)); [EOL]         // longComparable = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, longComparableType)); [EOL]         // int[] ia; [EOL]         // long[] la = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, long[].class)); [EOL]         final Integer[] ia = null; [EOL]         final Type caType = getClass().getField("intWildcardComparable").getGenericType(); [EOL]         intWildcardComparable = ia; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, caType)); [EOL]         // int[] ina = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer[].class, int[].class)); [EOL]         final int[] ina = null; [EOL]         Object[] oa; [EOL]         // oa = ina; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, Object[].class)); [EOL]         oa = new Integer[0]; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, Object[].class)); [EOL]         final Type bClassType = AClass.class.getField("bClass").getGenericType(); [EOL]         final Type cClassType = AClass.class.getField("cClass").getGenericType(); [EOL]         final Type dClassType = AClass.class.getField("dClass").getGenericType(); [EOL]         final Type eClassType = AClass.class.getField("eClass").getGenericType(); [EOL]         final Type fClassType = AClass.class.getField("fClass").getGenericType(); [EOL]         final AClass aClass = new AClass(new AAClass<String>()); [EOL]         aClass.bClass = aClass.cClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(cClassType, bClassType)); [EOL]         aClass.bClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, bClassType)); [EOL]         aClass.bClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, bClassType)); [EOL]         aClass.bClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, bClassType)); [EOL]         aClass.cClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, cClassType)); [EOL]         aClass.cClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, cClassType)); [EOL]         aClass.cClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, cClassType)); [EOL]         aClass.dClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, dClassType)); [EOL]         aClass.dClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, dClassType)); [EOL]         aClass.eClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, eClassType)); [EOL]     } [EOL]  [EOL]     public void delegateBooleanAssertion(final Type[] types, final int i2, final int i1, final boolean expected) { [EOL]         final Type type1 = types[i1]; [EOL]         final Type type2 = types[i2]; [EOL]         final boolean isAssignable = TypeUtils.isAssignable(type2, type1); [EOL]  [EOL]         if (expected) { [EOL]             Assert.assertTrue("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } else { [EOL]             Assert.assertFalse("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } [EOL]     } [EOL]  [EOL]     @SuppressWarnings("boxing") // boxing is deliberate here [EOL]
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [EOL]         final Type[] types = method.getGenericParameterTypes(); [EOL] //        list0 = list0; [EOL]         delegateBooleanAssertion(types, 0, 0, true); [EOL]         list1 = list0; [EOL]         delegateBooleanAssertion(types, 0, 1, true); [EOL]         list0 = list1; [EOL]         delegateBooleanAssertion(types, 1, 0, true); [EOL]         list2 = list0; [EOL]         delegateBooleanAssertion(types, 0, 2, true); [EOL]         list0 = list2; [EOL]         delegateBooleanAssertion(types, 2, 0, true); [EOL]         list3 = list0; [EOL]         delegateBooleanAssertion(types, 0, 3, true); [EOL]         list0 = list3; [EOL]         delegateBooleanAssertion(types, 3, 0, true); [EOL]         list4 = list0; [EOL]         delegateBooleanAssertion(types, 0, 4, true); [EOL]         list0 = list4; [EOL]         delegateBooleanAssertion(types, 4, 0, true); [EOL]         list5 = list0; [EOL]         delegateBooleanAssertion(types, 0, 5, true); [EOL]         list0 = list5; [EOL]         delegateBooleanAssertion(types, 5, 0, true); [EOL]         list6 = list0; [EOL]         delegateBooleanAssertion(types, 0, 6, true); [EOL]         list0 = list6; [EOL]         delegateBooleanAssertion(types, 6, 0, true); [EOL] //        list1 = list1; [EOL]         delegateBooleanAssertion(types, 1, 1, true); [EOL]         list2 = list1; [EOL]         delegateBooleanAssertion(types, 1, 2, true); [EOL]         list1 = (List<Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 1, false); [EOL]         list3 = list1; [EOL]         delegateBooleanAssertion(types, 1, 3, true); [EOL]         list1 = (List<Object>) list3; [EOL]         delegateBooleanAssertion(types, 3, 1, false); [EOL]         // list4 = list1; [EOL]         delegateBooleanAssertion(types, 1, 4, false); [EOL]         // list1 = list4; [EOL]         delegateBooleanAssertion(types, 4, 1, false); [EOL]         // list5 = list1; [EOL]         delegateBooleanAssertion(types, 1, 5, false); [EOL]         // list1 = list5; [EOL]         delegateBooleanAssertion(types, 5, 1, false); [EOL]         list6 = list1; [EOL]         delegateBooleanAssertion(types, 1, 6, true); [EOL]         list1 = (List<Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 1, false); [EOL] //        list2 = list2; [EOL]         delegateBooleanAssertion(types, 2, 2, true); [EOL]         list2 = list3; [EOL]         delegateBooleanAssertion(types, 2, 3, false); [EOL]         list2 = list4; [EOL]         delegateBooleanAssertion(types, 3, 2, true); [EOL]         list3 = (List<? super Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 4, false); [EOL]         list2 = list5; [EOL]         delegateBooleanAssertion(types, 4, 2, true); [EOL]         list4 = (List<String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 5, false); [EOL]         list2 = list6; [EOL]         delegateBooleanAssertion(types, 5, 2, true); [EOL]         list5 = (List<? extends String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 6, false); [EOL] //        list3 = list3; [EOL]         delegateBooleanAssertion(types, 6, 2, true); [EOL]         list6 = (List<? super String>) list2; [EOL]         delegateBooleanAssertion(types, 3, 3, true); [EOL]         // list4 = list3; [EOL]         delegateBooleanAssertion(types, 3, 4, false); [EOL]         // list3 = list4; [EOL]         delegateBooleanAssertion(types, 4, 3, false); [EOL]         // list5 = list3; [EOL]         delegateBooleanAssertion(types, 3, 5, false); [EOL]         // list3 = list5; [EOL]         delegateBooleanAssertion(types, 5, 3, false); [EOL]         list6 = list3; [EOL]         delegateBooleanAssertion(types, 3, 6, true); [EOL]         list3 = (List<? super Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 3, false); [EOL] //        list4 = list4; [EOL]         delegateBooleanAssertion(types, 4, 4, true); [EOL]         list5 = list4; [EOL]         delegateBooleanAssertion(types, 4, 5, true); [EOL]         list4 = (List<String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 4, false); [EOL]         list6 = list4; [EOL]         delegateBooleanAssertion(types, 4, 6, true); [EOL]         list4 = (List<String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 4, false); [EOL] //        list5 = list5; [EOL]         delegateBooleanAssertion(types, 5, 5, true); [EOL]         list6 = (List<? super String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 6, false); [EOL]         list5 = (List<? extends String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 5, false); [EOL] //        list6 = list6; [EOL]         delegateBooleanAssertion(types, 6, 6, true); [EOL]  [EOL] //        list7 = list7; [EOL]         delegateBooleanAssertion(types, 7, 7, true); [EOL]         list8 = list7; [EOL]         delegateBooleanAssertion(types, 7, 8, true); [EOL]         list7 = list8; [EOL]         delegateBooleanAssertion(types, 8, 7, true); [EOL]         list9 = list7; [EOL]         delegateBooleanAssertion(types, 7, 9, true); [EOL]         list7 = list9; [EOL]         delegateBooleanAssertion(types, 9, 7, true); [EOL]         list10 = list7; [EOL]         delegateBooleanAssertion(types, 7, 10, true); [EOL]         list7 = list10; [EOL]         delegateBooleanAssertion(types, 10, 7, true); [EOL]         list11 = list7; [EOL]         delegateBooleanAssertion(types, 7, 11, true); [EOL]         list7 = list11; [EOL]         delegateBooleanAssertion(types, 11, 7, true); [EOL]         list12 = list7; [EOL]         delegateBooleanAssertion(types, 7, 12, true); [EOL]         list7 = list12; [EOL]         delegateBooleanAssertion(types, 12, 7, true); [EOL]         list13 = list7; [EOL]         delegateBooleanAssertion(types, 7, 13, true); [EOL]         list7 = list13; [EOL]         delegateBooleanAssertion(types, 13, 7, true); [EOL] //        list8 = list8; [EOL]         delegateBooleanAssertion(types, 8, 8, true); [EOL]         list9 = list8; [EOL]         delegateBooleanAssertion(types, 8, 9, true); [EOL]         list8 = (List<Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 8, false); [EOL]         list10 = list8; [EOL]         delegateBooleanAssertion(types, 8, 10, true); [EOL]         list8 = (List<Object>[]) list10; // NOTE cast is required by Sun Java, but not by Eclipse [EOL]         delegateBooleanAssertion(types, 10, 8, false); [EOL]         // list11 = list8; [EOL]         delegateBooleanAssertion(types, 8, 11, false); [EOL]         // list8 = list11; [EOL]         delegateBooleanAssertion(types, 11, 8, false); [EOL]         // list12 = list8; [EOL]         delegateBooleanAssertion(types, 8, 12, false); [EOL]         // list8 = list12; [EOL]         delegateBooleanAssertion(types, 12, 8, false); [EOL]         list13 = list8; [EOL]         delegateBooleanAssertion(types, 8, 13, true); [EOL]         list8 = (List<Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 8, false); [EOL] //        list9 = list9; [EOL]         delegateBooleanAssertion(types, 9, 9, true); [EOL]         list10 = (List<? super Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 10, false); [EOL]         list9 = list10; [EOL]         delegateBooleanAssertion(types, 10, 9, true); [EOL]         list11 = (List<String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 11, false); [EOL]         list9 = list11; [EOL]         delegateBooleanAssertion(types, 11, 9, true); [EOL]         list12 = (List<? extends String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 12, false); [EOL]         list9 = list12; [EOL]         delegateBooleanAssertion(types, 12, 9, true); [EOL]         list13 = (List<? super String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 13, false); [EOL]         list9 = list13; [EOL]         delegateBooleanAssertion(types, 13, 9, true); [EOL] //        list10 = list10; [EOL]         delegateBooleanAssertion(types, 10, 10, true); [EOL]         // list11 = list10; [EOL]         delegateBooleanAssertion(types, 10, 11, false); [EOL]         // list10 = list11; [EOL]         delegateBooleanAssertion(types, 11, 10, false); [EOL]         // list12 = list10; [EOL]         delegateBooleanAssertion(types, 10, 12, false); [EOL]         // list10 = list12; [EOL]         delegateBooleanAssertion(types, 12, 10, false); [EOL]         list13 = list10; [EOL]         delegateBooleanAssertion(types, 10, 13, true); [EOL]         list10 = (List<? super Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 10, false); [EOL] //        list11 = list11; [EOL]         delegateBooleanAssertion(types, 11, 11, true); [EOL]         list12 = list11; [EOL]         delegateBooleanAssertion(types, 11, 12, true); [EOL]         list11 = (List<String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 11, false); [EOL]         list13 = list11; [EOL]         delegateBooleanAssertion(types, 11, 13, true); [EOL]         list11 = (List<String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 11, false); [EOL] //        list12 = list12; [EOL]         delegateBooleanAssertion(types, 12, 12, true); [EOL]         list13 = (List<? super String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 13, false); [EOL]         list12 = (List<? extends String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 12, false); [EOL] //        list13 = list13; [EOL]         delegateBooleanAssertion(types, 13, 13, true); [EOL]         final Type disType = getClass().getField("dis").getGenericType(); [EOL]         // Reporter.log( ( ( ParameterizedType ) disType [EOL]         // ).getOwnerType().getClass().toString() ); [EOL]         final Type datType = getClass().getField("dat").getGenericType(); [EOL]         final Type daType = getClass().getField("da").getGenericType(); [EOL]         final Type uhderType = getClass().getField("uhder").getGenericType(); [EOL]         final Type dingType = getClass().getField("ding").getGenericType(); [EOL]         final Type testerType = getClass().getField("tester").getGenericType(); [EOL]         final Type tester2Type = getClass().getField("tester2").getGenericType(); [EOL]         final Type dat2Type = getClass().getField("dat2").getGenericType(); [EOL]         final Type dat3Type = getClass().getField("dat3").getGenericType(); [EOL]         dis = dat; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(datType, disType)); [EOL]         // dis = da; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(daType, disType)); [EOL]         dis = uhder; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(uhderType, disType)); [EOL]         dis = ding; [EOL]         Assert.assertFalse(String.format("type %s not assignable to %s!", dingType, disType), [EOL]                 TypeUtils.isAssignable(dingType, disType)); [EOL]         dis = tester; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(testerType, disType)); [EOL]         // dis = tester2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(tester2Type, disType)); [EOL]         // dat = dat2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat2Type, datType)); [EOL]         // dat2 = dat; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(datType, dat2Type)); [EOL]         // dat = dat3; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat3Type, datType)); [EOL]         final char ch = 0; [EOL]         final boolean bo = false; [EOL]         final byte by = 0; [EOL]         final short sh = 0; [EOL]         int in = 0; [EOL]         long lo = 0; [EOL]         final float fl = 0; [EOL]         double du = 0; [EOL]         du = ch; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(char.class, double.class)); [EOL]         du = by; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(byte.class, double.class)); [EOL]         du = sh; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(short.class, double.class)); [EOL]         du = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, double.class)); [EOL]         du = lo; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(long.class, double.class)); [EOL]         du = fl; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(float.class, double.class)); [EOL]         lo = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, long.class)); [EOL]         lo = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, long.class)); [EOL]         // Long lngW = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, Long.class)); [EOL]         // lngW = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, Long.class)); [EOL]         in = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, int.class)); [EOL]         final Integer inte = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Integer.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Number.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Object.class)); [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, intComparableType)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Comparable.class)); [EOL]         final Serializable ser = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Serializable.class)); [EOL]         final Type longComparableType = getClass().getField("longComparable").getGenericType(); [EOL]         // longComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, longComparableType)); [EOL]         // longComparable = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, longComparableType)); [EOL]         // int[] ia; [EOL]         // long[] la = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, long[].class)); [EOL]         final Integer[] ia = null; [EOL]         final Type caType = getClass().getField("intWildcardComparable").getGenericType(); [EOL]         intWildcardComparable = ia; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, caType)); [EOL]         // int[] ina = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer[].class, int[].class)); [EOL]         final int[] ina = null; [EOL]         Object[] oa; [EOL]         // oa = ina; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, Object[].class)); [EOL]         oa = new Integer[0]; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, Object[].class)); [EOL]         final Type bClassType = AClass.class.getField("bClass").getGenericType(); [EOL]         final Type cClassType = AClass.class.getField("cClass").getGenericType(); [EOL]         final Type dClassType = AClass.class.getField("dClass").getGenericType(); [EOL]         final Type eClassType = AClass.class.getField("eClass").getGenericType(); [EOL]         final Type fClassType = AClass.class.getField("fClass").getGenericType(); [EOL]         final AClass aClass = new AClass(new AAClass<String>()); [EOL]         aClass.bClass = aClass.cClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(cClassType, bClassType)); [EOL]         aClass.bClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, bClassType)); [EOL]         aClass.bClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, bClassType)); [EOL]         aClass.bClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, bClassType)); [EOL]         aClass.cClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, cClassType)); [EOL]         aClass.cClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, cClassType)); [EOL]         aClass.cClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, cClassType)); [EOL]         aClass.dClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, dClassType)); [EOL]         aClass.dClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, dClassType)); [EOL]         aClass.eClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, eClassType)); [EOL]     } [EOL]  [EOL]     public void delegateBooleanAssertion(final Type[] types, final int i2, final int i1, final boolean expected) { [EOL]         final Type type1 = types[i1]; [EOL]         final Type type2 = types[i2]; [EOL]         final boolean isAssignable = TypeUtils.isAssignable(type2, type1); [EOL]  [EOL]         if (expected) { [EOL]             Assert.assertTrue("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } else { [EOL]             Assert.assertFalse("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } [EOL]     } [EOL]  [EOL]     @SuppressWarnings("boxing") // boxing is deliberate here [EOL]
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [EOL]         final Type[] types = method.getGenericParameterTypes(); [EOL] //        list0 = list0; [EOL]         delegateBooleanAssertion(types, 0, 0, true); [EOL]         list1 = list0; [EOL]         delegateBooleanAssertion(types, 0, 1, true); [EOL]         list0 = list1; [EOL]         delegateBooleanAssertion(types, 1, 0, true); [EOL]         list2 = list0; [EOL]         delegateBooleanAssertion(types, 0, 2, true); [EOL]         list0 = list2; [EOL]         delegateBooleanAssertion(types, 2, 0, true); [EOL]         list3 = list0; [EOL]         delegateBooleanAssertion(types, 0, 3, true); [EOL]         list0 = list3; [EOL]         delegateBooleanAssertion(types, 3, 0, true); [EOL]         list4 = list0; [EOL]         delegateBooleanAssertion(types, 0, 4, true); [EOL]         list0 = list4; [EOL]         delegateBooleanAssertion(types, 4, 0, true); [EOL]         list5 = list0; [EOL]         delegateBooleanAssertion(types, 0, 5, true); [EOL]         list0 = list5; [EOL]         delegateBooleanAssertion(types, 5, 0, true); [EOL]         list6 = list0; [EOL]         delegateBooleanAssertion(types, 0, 6, true); [EOL]         list0 = list6; [EOL]         delegateBooleanAssertion(types, 6, 0, true); [EOL] //        list1 = list1; [EOL]         delegateBooleanAssertion(types, 1, 1, true); [EOL]         list2 = list1; [EOL]         delegateBooleanAssertion(types, 1, 2, true); [EOL]         list1 = (List<Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 1, false); [EOL]         list3 = list1; [EOL]         delegateBooleanAssertion(types, 1, 3, true); [EOL]         list1 = (List<Object>) list3; [EOL]         delegateBooleanAssertion(types, 3, 1, false); [EOL]         // list4 = list1; [EOL]         delegateBooleanAssertion(types, 1, 4, false); [EOL]         // list1 = list4; [EOL]         delegateBooleanAssertion(types, 4, 1, false); [EOL]         // list5 = list1; [EOL]         delegateBooleanAssertion(types, 1, 5, false); [EOL]         // list1 = list5; [EOL]         delegateBooleanAssertion(types, 5, 1, false); [EOL]         list6 = list1; [EOL]         delegateBooleanAssertion(types, 1, 6, true); [EOL]         list1 = (List<Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 1, false); [EOL] //        list2 = list2; [EOL]         delegateBooleanAssertion(types, 2, 2, true); [EOL]         list2 = list3; [EOL]         delegateBooleanAssertion(types, 2, 3, false); [EOL]         list2 = list4; [EOL]         delegateBooleanAssertion(types, 3, 2, true); [EOL]         list3 = (List<? super Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 4, false); [EOL]         list2 = list5; [EOL]         delegateBooleanAssertion(types, 4, 2, true); [EOL]         list4 = (List<String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 5, false); [EOL]         list2 = list6; [EOL]         delegateBooleanAssertion(types, 5, 2, true); [EOL]         list5 = (List<? extends String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 6, false); [EOL] //        list3 = list3; [EOL]         delegateBooleanAssertion(types, 6, 2, true); [EOL]         list6 = (List<? super String>) list2; [EOL]         delegateBooleanAssertion(types, 3, 3, true); [EOL]         // list4 = list3; [EOL]         delegateBooleanAssertion(types, 3, 4, false); [EOL]         // list3 = list4; [EOL]         delegateBooleanAssertion(types, 4, 3, false); [EOL]         // list5 = list3; [EOL]         delegateBooleanAssertion(types, 3, 5, false); [EOL]         // list3 = list5; [EOL]         delegateBooleanAssertion(types, 5, 3, false); [EOL]         list6 = list3; [EOL]         delegateBooleanAssertion(types, 3, 6, true); [EOL]         list3 = (List<? super Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 3, false); [EOL] //        list4 = list4; [EOL]         delegateBooleanAssertion(types, 4, 4, true); [EOL]         list5 = list4; [EOL]         delegateBooleanAssertion(types, 4, 5, true); [EOL]         list4 = (List<String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 4, false); [EOL]         list6 = list4; [EOL]         delegateBooleanAssertion(types, 4, 6, true); [EOL]         list4 = (List<String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 4, false); [EOL] //        list5 = list5; [EOL]         delegateBooleanAssertion(types, 5, 5, true); [EOL]         list6 = (List<? super String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 6, false); [EOL]         list5 = (List<? extends String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 5, false); [EOL] //        list6 = list6; [EOL]         delegateBooleanAssertion(types, 6, 6, true); [EOL]  [EOL] //        list7 = list7; [EOL]         delegateBooleanAssertion(types, 7, 7, true); [EOL]         list8 = list7; [EOL]         delegateBooleanAssertion(types, 7, 8, true); [EOL]         list7 = list8; [EOL]         delegateBooleanAssertion(types, 8, 7, true); [EOL]         list9 = list7; [EOL]         delegateBooleanAssertion(types, 7, 9, true); [EOL]         list7 = list9; [EOL]         delegateBooleanAssertion(types, 9, 7, true); [EOL]         list10 = list7; [EOL]         delegateBooleanAssertion(types, 7, 10, true); [EOL]         list7 = list10; [EOL]         delegateBooleanAssertion(types, 10, 7, true); [EOL]         list11 = list7; [EOL]         delegateBooleanAssertion(types, 7, 11, true); [EOL]         list7 = list11; [EOL]         delegateBooleanAssertion(types, 11, 7, true); [EOL]         list12 = list7; [EOL]         delegateBooleanAssertion(types, 7, 12, true); [EOL]         list7 = list12; [EOL]         delegateBooleanAssertion(types, 12, 7, true); [EOL]         list13 = list7; [EOL]         delegateBooleanAssertion(types, 7, 13, true); [EOL]         list7 = list13; [EOL]         delegateBooleanAssertion(types, 13, 7, true); [EOL] //        list8 = list8; [EOL]         delegateBooleanAssertion(types, 8, 8, true); [EOL]         list9 = list8; [EOL]         delegateBooleanAssertion(types, 8, 9, true); [EOL]         list8 = (List<Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 8, false); [EOL]         list10 = list8; [EOL]         delegateBooleanAssertion(types, 8, 10, true); [EOL]         list8 = (List<Object>[]) list10; // NOTE cast is required by Sun Java, but not by Eclipse [EOL]         delegateBooleanAssertion(types, 10, 8, false); [EOL]         // list11 = list8; [EOL]         delegateBooleanAssertion(types, 8, 11, false); [EOL]         // list8 = list11; [EOL]         delegateBooleanAssertion(types, 11, 8, false); [EOL]         // list12 = list8; [EOL]         delegateBooleanAssertion(types, 8, 12, false); [EOL]         // list8 = list12; [EOL]         delegateBooleanAssertion(types, 12, 8, false); [EOL]         list13 = list8; [EOL]         delegateBooleanAssertion(types, 8, 13, true); [EOL]         list8 = (List<Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 8, false); [EOL] //        list9 = list9; [EOL]         delegateBooleanAssertion(types, 9, 9, true); [EOL]         list10 = (List<? super Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 10, false); [EOL]         list9 = list10; [EOL]         delegateBooleanAssertion(types, 10, 9, true); [EOL]         list11 = (List<String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 11, false); [EOL]         list9 = list11; [EOL]         delegateBooleanAssertion(types, 11, 9, true); [EOL]         list12 = (List<? extends String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 12, false); [EOL]         list9 = list12; [EOL]         delegateBooleanAssertion(types, 12, 9, true); [EOL]         list13 = (List<? super String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 13, false); [EOL]         list9 = list13; [EOL]         delegateBooleanAssertion(types, 13, 9, true); [EOL] //        list10 = list10; [EOL]         delegateBooleanAssertion(types, 10, 10, true); [EOL]         // list11 = list10; [EOL]         delegateBooleanAssertion(types, 10, 11, false); [EOL]         // list10 = list11; [EOL]         delegateBooleanAssertion(types, 11, 10, false); [EOL]         // list12 = list10; [EOL]         delegateBooleanAssertion(types, 10, 12, false); [EOL]         // list10 = list12; [EOL]         delegateBooleanAssertion(types, 12, 10, false); [EOL]         list13 = list10; [EOL]         delegateBooleanAssertion(types, 10, 13, true); [EOL]         list10 = (List<? super Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 10, false); [EOL] //        list11 = list11; [EOL]         delegateBooleanAssertion(types, 11, 11, true); [EOL]         list12 = list11; [EOL]         delegateBooleanAssertion(types, 11, 12, true); [EOL]         list11 = (List<String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 11, false); [EOL]         list13 = list11; [EOL]         delegateBooleanAssertion(types, 11, 13, true); [EOL]         list11 = (List<String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 11, false); [EOL] //        list12 = list12; [EOL]         delegateBooleanAssertion(types, 12, 12, true); [EOL]         list13 = (List<? super String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 13, false); [EOL]         list12 = (List<? extends String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 12, false); [EOL] //        list13 = list13; [EOL]         delegateBooleanAssertion(types, 13, 13, true); [EOL]         final Type disType = getClass().getField("dis").getGenericType(); [EOL]         // Reporter.log( ( ( ParameterizedType ) disType [EOL]         // ).getOwnerType().getClass().toString() ); [EOL]         final Type datType = getClass().getField("dat").getGenericType(); [EOL]         final Type daType = getClass().getField("da").getGenericType(); [EOL]         final Type uhderType = getClass().getField("uhder").getGenericType(); [EOL]         final Type dingType = getClass().getField("ding").getGenericType(); [EOL]         final Type testerType = getClass().getField("tester").getGenericType(); [EOL]         final Type tester2Type = getClass().getField("tester2").getGenericType(); [EOL]         final Type dat2Type = getClass().getField("dat2").getGenericType(); [EOL]         final Type dat3Type = getClass().getField("dat3").getGenericType(); [EOL]         dis = dat; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(datType, disType)); [EOL]         // dis = da; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(daType, disType)); [EOL]         dis = uhder; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(uhderType, disType)); [EOL]         dis = ding; [EOL]         Assert.assertFalse(String.format("type %s not assignable to %s!", dingType, disType), [EOL]                 TypeUtils.isAssignable(dingType, disType)); [EOL]         dis = tester; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(testerType, disType)); [EOL]         // dis = tester2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(tester2Type, disType)); [EOL]         // dat = dat2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat2Type, datType)); [EOL]         // dat2 = dat; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(datType, dat2Type)); [EOL]         // dat = dat3; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat3Type, datType)); [EOL]         final char ch = 0; [EOL]         final boolean bo = false; [EOL]         final byte by = 0; [EOL]         final short sh = 0; [EOL]         int in = 0; [EOL]         long lo = 0; [EOL]         final float fl = 0; [EOL]         double du = 0; [EOL]         du = ch; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(char.class, double.class)); [EOL]         du = by; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(byte.class, double.class)); [EOL]         du = sh; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(short.class, double.class)); [EOL]         du = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, double.class)); [EOL]         du = lo; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(long.class, double.class)); [EOL]         du = fl; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(float.class, double.class)); [EOL]         lo = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, long.class)); [EOL]         lo = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, long.class)); [EOL]         // Long lngW = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, Long.class)); [EOL]         // lngW = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, Long.class)); [EOL]         in = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, int.class)); [EOL]         final Integer inte = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Integer.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Number.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Object.class)); [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, intComparableType)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Comparable.class)); [EOL]         final Serializable ser = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Serializable.class)); [EOL]         final Type longComparableType = getClass().getField("longComparable").getGenericType(); [EOL]         // longComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, longComparableType)); [EOL]         // longComparable = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, longComparableType)); [EOL]         // int[] ia; [EOL]         // long[] la = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, long[].class)); [EOL]         final Integer[] ia = null; [EOL]         final Type caType = getClass().getField("intWildcardComparable").getGenericType(); [EOL]         intWildcardComparable = ia; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, caType)); [EOL]         // int[] ina = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer[].class, int[].class)); [EOL]         final int[] ina = null; [EOL]         Object[] oa; [EOL]         // oa = ina; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, Object[].class)); [EOL]         oa = new Integer[0]; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, Object[].class)); [EOL]         final Type bClassType = AClass.class.getField("bClass").getGenericType(); [EOL]         final Type cClassType = AClass.class.getField("cClass").getGenericType(); [EOL]         final Type dClassType = AClass.class.getField("dClass").getGenericType(); [EOL]         final Type eClassType = AClass.class.getField("eClass").getGenericType(); [EOL]         final Type fClassType = AClass.class.getField("fClass").getGenericType(); [EOL]         final AClass aClass = new AClass(new AAClass<String>()); [EOL]         aClass.bClass = aClass.cClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(cClassType, bClassType)); [EOL]         aClass.bClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, bClassType)); [EOL]         aClass.bClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, bClassType)); [EOL]         aClass.bClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, bClassType)); [EOL]         aClass.cClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, cClassType)); [EOL]         aClass.cClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, cClassType)); [EOL]         aClass.cClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, cClassType)); [EOL]         aClass.dClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, dClassType)); [EOL]         aClass.dClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, dClassType)); [EOL]         aClass.eClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, eClassType)); [EOL]     } [EOL]  [EOL]     public void delegateBooleanAssertion(final Type[] types, final int i2, final int i1, final boolean expected) { [EOL]         final Type type1 = types[i1]; [EOL]         final Type type2 = types[i2]; [EOL]         final boolean isAssignable = TypeUtils.isAssignable(type2, type1); [EOL]  [EOL]         if (expected) { [EOL]             Assert.assertTrue("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } else { [EOL]             Assert.assertFalse("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } [EOL]     } [EOL]  [EOL]     @SuppressWarnings("boxing") // boxing is deliberate here [EOL]
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [EOL]         final Type[] types = method.getGenericParameterTypes(); [EOL] //        list0 = list0; [EOL]         delegateBooleanAssertion(types, 0, 0, true); [EOL]         list1 = list0; [EOL]         delegateBooleanAssertion(types, 0, 1, true); [EOL]         list0 = list1; [EOL]         delegateBooleanAssertion(types, 1, 0, true); [EOL]         list2 = list0; [EOL]         delegateBooleanAssertion(types, 0, 2, true); [EOL]         list0 = list2; [EOL]         delegateBooleanAssertion(types, 2, 0, true); [EOL]         list3 = list0; [EOL]         delegateBooleanAssertion(types, 0, 3, true); [EOL]         list0 = list3; [EOL]         delegateBooleanAssertion(types, 3, 0, true); [EOL]         list4 = list0; [EOL]         delegateBooleanAssertion(types, 0, 4, true); [EOL]         list0 = list4; [EOL]         delegateBooleanAssertion(types, 4, 0, true); [EOL]         list5 = list0; [EOL]         delegateBooleanAssertion(types, 0, 5, true); [EOL]         list0 = list5; [EOL]         delegateBooleanAssertion(types, 5, 0, true); [EOL]         list6 = list0; [EOL]         delegateBooleanAssertion(types, 0, 6, true); [EOL]         list0 = list6; [EOL]         delegateBooleanAssertion(types, 6, 0, true); [EOL] //        list1 = list1; [EOL]         delegateBooleanAssertion(types, 1, 1, true); [EOL]         list2 = list1; [EOL]         delegateBooleanAssertion(types, 1, 2, true); [EOL]         list1 = (List<Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 1, false); [EOL]         list3 = list1; [EOL]         delegateBooleanAssertion(types, 1, 3, true); [EOL]         list1 = (List<Object>) list3; [EOL]         delegateBooleanAssertion(types, 3, 1, false); [EOL]         // list4 = list1; [EOL]         delegateBooleanAssertion(types, 1, 4, false); [EOL]         // list1 = list4; [EOL]         delegateBooleanAssertion(types, 4, 1, false); [EOL]         // list5 = list1; [EOL]         delegateBooleanAssertion(types, 1, 5, false); [EOL]         // list1 = list5; [EOL]         delegateBooleanAssertion(types, 5, 1, false); [EOL]         list6 = list1; [EOL]         delegateBooleanAssertion(types, 1, 6, true); [EOL]         list1 = (List<Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 1, false); [EOL] //        list2 = list2; [EOL]         delegateBooleanAssertion(types, 2, 2, true); [EOL]         list2 = list3; [EOL]         delegateBooleanAssertion(types, 2, 3, false); [EOL]         list2 = list4; [EOL]         delegateBooleanAssertion(types, 3, 2, true); [EOL]         list3 = (List<? super Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 4, false); [EOL]         list2 = list5; [EOL]         delegateBooleanAssertion(types, 4, 2, true); [EOL]         list4 = (List<String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 5, false); [EOL]         list2 = list6; [EOL]         delegateBooleanAssertion(types, 5, 2, true); [EOL]         list5 = (List<? extends String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 6, false); [EOL] //        list3 = list3; [EOL]         delegateBooleanAssertion(types, 6, 2, true); [EOL]         list6 = (List<? super String>) list2; [EOL]         delegateBooleanAssertion(types, 3, 3, true); [EOL]         // list4 = list3; [EOL]         delegateBooleanAssertion(types, 3, 4, false); [EOL]         // list3 = list4; [EOL]         delegateBooleanAssertion(types, 4, 3, false); [EOL]         // list5 = list3; [EOL]         delegateBooleanAssertion(types, 3, 5, false); [EOL]         // list3 = list5; [EOL]         delegateBooleanAssertion(types, 5, 3, false); [EOL]         list6 = list3; [EOL]         delegateBooleanAssertion(types, 3, 6, true); [EOL]         list3 = (List<? super Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 3, false); [EOL] //        list4 = list4; [EOL]         delegateBooleanAssertion(types, 4, 4, true); [EOL]         list5 = list4; [EOL]         delegateBooleanAssertion(types, 4, 5, true); [EOL]         list4 = (List<String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 4, false); [EOL]         list6 = list4; [EOL]         delegateBooleanAssertion(types, 4, 6, true); [EOL]         list4 = (List<String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 4, false); [EOL] //        list5 = list5; [EOL]         delegateBooleanAssertion(types, 5, 5, true); [EOL]         list6 = (List<? super String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 6, false); [EOL]         list5 = (List<? extends String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 5, false); [EOL] //        list6 = list6; [EOL]         delegateBooleanAssertion(types, 6, 6, true); [EOL]  [EOL] //        list7 = list7; [EOL]         delegateBooleanAssertion(types, 7, 7, true); [EOL]         list8 = list7; [EOL]         delegateBooleanAssertion(types, 7, 8, true); [EOL]         list7 = list8; [EOL]         delegateBooleanAssertion(types, 8, 7, true); [EOL]         list9 = list7; [EOL]         delegateBooleanAssertion(types, 7, 9, true); [EOL]         list7 = list9; [EOL]         delegateBooleanAssertion(types, 9, 7, true); [EOL]         list10 = list7; [EOL]         delegateBooleanAssertion(types, 7, 10, true); [EOL]         list7 = list10; [EOL]         delegateBooleanAssertion(types, 10, 7, true); [EOL]         list11 = list7; [EOL]         delegateBooleanAssertion(types, 7, 11, true); [EOL]         list7 = list11; [EOL]         delegateBooleanAssertion(types, 11, 7, true); [EOL]         list12 = list7; [EOL]         delegateBooleanAssertion(types, 7, 12, true); [EOL]         list7 = list12; [EOL]         delegateBooleanAssertion(types, 12, 7, true); [EOL]         list13 = list7; [EOL]         delegateBooleanAssertion(types, 7, 13, true); [EOL]         list7 = list13; [EOL]         delegateBooleanAssertion(types, 13, 7, true); [EOL] //        list8 = list8; [EOL]         delegateBooleanAssertion(types, 8, 8, true); [EOL]         list9 = list8; [EOL]         delegateBooleanAssertion(types, 8, 9, true); [EOL]         list8 = (List<Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 8, false); [EOL]         list10 = list8; [EOL]         delegateBooleanAssertion(types, 8, 10, true); [EOL]         list8 = (List<Object>[]) list10; // NOTE cast is required by Sun Java, but not by Eclipse [EOL]         delegateBooleanAssertion(types, 10, 8, false); [EOL]         // list11 = list8; [EOL]         delegateBooleanAssertion(types, 8, 11, false); [EOL]         // list8 = list11; [EOL]         delegateBooleanAssertion(types, 11, 8, false); [EOL]         // list12 = list8; [EOL]         delegateBooleanAssertion(types, 8, 12, false); [EOL]         // list8 = list12; [EOL]         delegateBooleanAssertion(types, 12, 8, false); [EOL]         list13 = list8; [EOL]         delegateBooleanAssertion(types, 8, 13, true); [EOL]         list8 = (List<Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 8, false); [EOL] //        list9 = list9; [EOL]         delegateBooleanAssertion(types, 9, 9, true); [EOL]         list10 = (List<? super Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 10, false); [EOL]         list9 = list10; [EOL]         delegateBooleanAssertion(types, 10, 9, true); [EOL]         list11 = (List<String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 11, false); [EOL]         list9 = list11; [EOL]         delegateBooleanAssertion(types, 11, 9, true); [EOL]         list12 = (List<? extends String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 12, false); [EOL]         list9 = list12; [EOL]         delegateBooleanAssertion(types, 12, 9, true); [EOL]         list13 = (List<? super String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 13, false); [EOL]         list9 = list13; [EOL]         delegateBooleanAssertion(types, 13, 9, true); [EOL] //        list10 = list10; [EOL]         delegateBooleanAssertion(types, 10, 10, true); [EOL]         // list11 = list10; [EOL]         delegateBooleanAssertion(types, 10, 11, false); [EOL]         // list10 = list11; [EOL]         delegateBooleanAssertion(types, 11, 10, false); [EOL]         // list12 = list10; [EOL]         delegateBooleanAssertion(types, 10, 12, false); [EOL]         // list10 = list12; [EOL]         delegateBooleanAssertion(types, 12, 10, false); [EOL]         list13 = list10; [EOL]         delegateBooleanAssertion(types, 10, 13, true); [EOL]         list10 = (List<? super Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 10, false); [EOL] //        list11 = list11; [EOL]         delegateBooleanAssertion(types, 11, 11, true); [EOL]         list12 = list11; [EOL]         delegateBooleanAssertion(types, 11, 12, true); [EOL]         list11 = (List<String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 11, false); [EOL]         list13 = list11; [EOL]         delegateBooleanAssertion(types, 11, 13, true); [EOL]         list11 = (List<String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 11, false); [EOL] //        list12 = list12; [EOL]         delegateBooleanAssertion(types, 12, 12, true); [EOL]         list13 = (List<? super String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 13, false); [EOL]         list12 = (List<? extends String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 12, false); [EOL] //        list13 = list13; [EOL]         delegateBooleanAssertion(types, 13, 13, true); [EOL]         final Type disType = getClass().getField("dis").getGenericType(); [EOL]         // Reporter.log( ( ( ParameterizedType ) disType [EOL]         // ).getOwnerType().getClass().toString() ); [EOL]         final Type datType = getClass().getField("dat").getGenericType(); [EOL]         final Type daType = getClass().getField("da").getGenericType(); [EOL]         final Type uhderType = getClass().getField("uhder").getGenericType(); [EOL]         final Type dingType = getClass().getField("ding").getGenericType(); [EOL]         final Type testerType = getClass().getField("tester").getGenericType(); [EOL]         final Type tester2Type = getClass().getField("tester2").getGenericType(); [EOL]         final Type dat2Type = getClass().getField("dat2").getGenericType(); [EOL]         final Type dat3Type = getClass().getField("dat3").getGenericType(); [EOL]         dis = dat; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(datType, disType)); [EOL]         // dis = da; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(daType, disType)); [EOL]         dis = uhder; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(uhderType, disType)); [EOL]         dis = ding; [EOL]         Assert.assertFalse(String.format("type %s not assignable to %s!", dingType, disType), [EOL]                 TypeUtils.isAssignable(dingType, disType)); [EOL]         dis = tester; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(testerType, disType)); [EOL]         // dis = tester2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(tester2Type, disType)); [EOL]         // dat = dat2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat2Type, datType)); [EOL]         // dat2 = dat; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(datType, dat2Type)); [EOL]         // dat = dat3; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat3Type, datType)); [EOL]         final char ch = 0; [EOL]         final boolean bo = false; [EOL]         final byte by = 0; [EOL]         final short sh = 0; [EOL]         int in = 0; [EOL]         long lo = 0; [EOL]         final float fl = 0; [EOL]         double du = 0; [EOL]         du = ch; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(char.class, double.class)); [EOL]         du = by; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(byte.class, double.class)); [EOL]         du = sh; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(short.class, double.class)); [EOL]         du = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, double.class)); [EOL]         du = lo; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(long.class, double.class)); [EOL]         du = fl; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(float.class, double.class)); [EOL]         lo = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, long.class)); [EOL]         lo = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, long.class)); [EOL]         // Long lngW = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, Long.class)); [EOL]         // lngW = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, Long.class)); [EOL]         in = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, int.class)); [EOL]         final Integer inte = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Integer.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Number.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Object.class)); [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, intComparableType)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Comparable.class)); [EOL]         final Serializable ser = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Serializable.class)); [EOL]         final Type longComparableType = getClass().getField("longComparable").getGenericType(); [EOL]         // longComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, longComparableType)); [EOL]         // longComparable = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, longComparableType)); [EOL]         // int[] ia; [EOL]         // long[] la = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, long[].class)); [EOL]         final Integer[] ia = null; [EOL]         final Type caType = getClass().getField("intWildcardComparable").getGenericType(); [EOL]         intWildcardComparable = ia; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, caType)); [EOL]         // int[] ina = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer[].class, int[].class)); [EOL]         final int[] ina = null; [EOL]         Object[] oa; [EOL]         // oa = ina; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, Object[].class)); [EOL]         oa = new Integer[0]; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, Object[].class)); [EOL]         final Type bClassType = AClass.class.getField("bClass").getGenericType(); [EOL]         final Type cClassType = AClass.class.getField("cClass").getGenericType(); [EOL]         final Type dClassType = AClass.class.getField("dClass").getGenericType(); [EOL]         final Type eClassType = AClass.class.getField("eClass").getGenericType(); [EOL]         final Type fClassType = AClass.class.getField("fClass").getGenericType(); [EOL]         final AClass aClass = new AClass(new AAClass<String>()); [EOL]         aClass.bClass = aClass.cClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(cClassType, bClassType)); [EOL]         aClass.bClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, bClassType)); [EOL]         aClass.bClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, bClassType)); [EOL]         aClass.bClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, bClassType)); [EOL]         aClass.cClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, cClassType)); [EOL]         aClass.cClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, cClassType)); [EOL]         aClass.cClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, cClassType)); [EOL]         aClass.dClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, dClassType)); [EOL]         aClass.dClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, dClassType)); [EOL]         aClass.eClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, eClassType)); [EOL]     } [EOL]  [EOL]     public void delegateBooleanAssertion(final Type[] types, final int i2, final int i1, final boolean expected) { [EOL]         final Type type1 = types[i1]; [EOL]         final Type type2 = types[i2]; [EOL]         final boolean isAssignable = TypeUtils.isAssignable(type2, type1); [EOL]  [EOL]         if (expected) { [EOL]             Assert.assertTrue("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } else { [EOL]             Assert.assertFalse("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } [EOL]     } [EOL]  [EOL]     @SuppressWarnings("boxing") // boxing is deliberate here [EOL]
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [EOL]         final Type[] types = method.getGenericParameterTypes(); [EOL] //        list0 = list0; [EOL]         delegateBooleanAssertion(types, 0, 0, true); [EOL]         list1 = list0; [EOL]         delegateBooleanAssertion(types, 0, 1, true); [EOL]         list0 = list1; [EOL]         delegateBooleanAssertion(types, 1, 0, true); [EOL]         list2 = list0; [EOL]         delegateBooleanAssertion(types, 0, 2, true); [EOL]         list0 = list2; [EOL]         delegateBooleanAssertion(types, 2, 0, true); [EOL]         list3 = list0; [EOL]         delegateBooleanAssertion(types, 0, 3, true); [EOL]         list0 = list3; [EOL]         delegateBooleanAssertion(types, 3, 0, true); [EOL]         list4 = list0; [EOL]         delegateBooleanAssertion(types, 0, 4, true); [EOL]         list0 = list4; [EOL]         delegateBooleanAssertion(types, 4, 0, true); [EOL]         list5 = list0; [EOL]         delegateBooleanAssertion(types, 0, 5, true); [EOL]         list0 = list5; [EOL]         delegateBooleanAssertion(types, 5, 0, true); [EOL]         list6 = list0; [EOL]         delegateBooleanAssertion(types, 0, 6, true); [EOL]         list0 = list6; [EOL]         delegateBooleanAssertion(types, 6, 0, true); [EOL] //        list1 = list1; [EOL]         delegateBooleanAssertion(types, 1, 1, true); [EOL]         list2 = list1; [EOL]         delegateBooleanAssertion(types, 1, 2, true); [EOL]         list1 = (List<Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 1, false); [EOL]         list3 = list1; [EOL]         delegateBooleanAssertion(types, 1, 3, true); [EOL]         list1 = (List<Object>) list3; [EOL]         delegateBooleanAssertion(types, 3, 1, false); [EOL]         // list4 = list1; [EOL]         delegateBooleanAssertion(types, 1, 4, false); [EOL]         // list1 = list4; [EOL]         delegateBooleanAssertion(types, 4, 1, false); [EOL]         // list5 = list1; [EOL]         delegateBooleanAssertion(types, 1, 5, false); [EOL]         // list1 = list5; [EOL]         delegateBooleanAssertion(types, 5, 1, false); [EOL]         list6 = list1; [EOL]         delegateBooleanAssertion(types, 1, 6, true); [EOL]         list1 = (List<Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 1, false); [EOL] //        list2 = list2; [EOL]         delegateBooleanAssertion(types, 2, 2, true); [EOL]         list2 = list3; [EOL]         delegateBooleanAssertion(types, 2, 3, false); [EOL]         list2 = list4; [EOL]         delegateBooleanAssertion(types, 3, 2, true); [EOL]         list3 = (List<? super Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 4, false); [EOL]         list2 = list5; [EOL]         delegateBooleanAssertion(types, 4, 2, true); [EOL]         list4 = (List<String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 5, false); [EOL]         list2 = list6; [EOL]         delegateBooleanAssertion(types, 5, 2, true); [EOL]         list5 = (List<? extends String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 6, false); [EOL] //        list3 = list3; [EOL]         delegateBooleanAssertion(types, 6, 2, true); [EOL]         list6 = (List<? super String>) list2; [EOL]         delegateBooleanAssertion(types, 3, 3, true); [EOL]         // list4 = list3; [EOL]         delegateBooleanAssertion(types, 3, 4, false); [EOL]         // list3 = list4; [EOL]         delegateBooleanAssertion(types, 4, 3, false); [EOL]         // list5 = list3; [EOL]         delegateBooleanAssertion(types, 3, 5, false); [EOL]         // list3 = list5; [EOL]         delegateBooleanAssertion(types, 5, 3, false); [EOL]         list6 = list3; [EOL]         delegateBooleanAssertion(types, 3, 6, true); [EOL]         list3 = (List<? super Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 3, false); [EOL] //        list4 = list4; [EOL]         delegateBooleanAssertion(types, 4, 4, true); [EOL]         list5 = list4; [EOL]         delegateBooleanAssertion(types, 4, 5, true); [EOL]         list4 = (List<String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 4, false); [EOL]         list6 = list4; [EOL]         delegateBooleanAssertion(types, 4, 6, true); [EOL]         list4 = (List<String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 4, false); [EOL] //        list5 = list5; [EOL]         delegateBooleanAssertion(types, 5, 5, true); [EOL]         list6 = (List<? super String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 6, false); [EOL]         list5 = (List<? extends String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 5, false); [EOL] //        list6 = list6; [EOL]         delegateBooleanAssertion(types, 6, 6, true); [EOL]  [EOL] //        list7 = list7; [EOL]         delegateBooleanAssertion(types, 7, 7, true); [EOL]         list8 = list7; [EOL]         delegateBooleanAssertion(types, 7, 8, true); [EOL]         list7 = list8; [EOL]         delegateBooleanAssertion(types, 8, 7, true); [EOL]         list9 = list7; [EOL]         delegateBooleanAssertion(types, 7, 9, true); [EOL]         list7 = list9; [EOL]         delegateBooleanAssertion(types, 9, 7, true); [EOL]         list10 = list7; [EOL]         delegateBooleanAssertion(types, 7, 10, true); [EOL]         list7 = list10; [EOL]         delegateBooleanAssertion(types, 10, 7, true); [EOL]         list11 = list7; [EOL]         delegateBooleanAssertion(types, 7, 11, true); [EOL]         list7 = list11; [EOL]         delegateBooleanAssertion(types, 11, 7, true); [EOL]         list12 = list7; [EOL]         delegateBooleanAssertion(types, 7, 12, true); [EOL]         list7 = list12; [EOL]         delegateBooleanAssertion(types, 12, 7, true); [EOL]         list13 = list7; [EOL]         delegateBooleanAssertion(types, 7, 13, true); [EOL]         list7 = list13; [EOL]         delegateBooleanAssertion(types, 13, 7, true); [EOL] //        list8 = list8; [EOL]         delegateBooleanAssertion(types, 8, 8, true); [EOL]         list9 = list8; [EOL]         delegateBooleanAssertion(types, 8, 9, true); [EOL]         list8 = (List<Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 8, false); [EOL]         list10 = list8; [EOL]         delegateBooleanAssertion(types, 8, 10, true); [EOL]         list8 = (List<Object>[]) list10; // NOTE cast is required by Sun Java, but not by Eclipse [EOL]         delegateBooleanAssertion(types, 10, 8, false); [EOL]         // list11 = list8; [EOL]         delegateBooleanAssertion(types, 8, 11, false); [EOL]         // list8 = list11; [EOL]         delegateBooleanAssertion(types, 11, 8, false); [EOL]         // list12 = list8; [EOL]         delegateBooleanAssertion(types, 8, 12, false); [EOL]         // list8 = list12; [EOL]         delegateBooleanAssertion(types, 12, 8, false); [EOL]         list13 = list8; [EOL]         delegateBooleanAssertion(types, 8, 13, true); [EOL]         list8 = (List<Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 8, false); [EOL] //        list9 = list9; [EOL]         delegateBooleanAssertion(types, 9, 9, true); [EOL]         list10 = (List<? super Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 10, false); [EOL]         list9 = list10; [EOL]         delegateBooleanAssertion(types, 10, 9, true); [EOL]         list11 = (List<String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 11, false); [EOL]         list9 = list11; [EOL]         delegateBooleanAssertion(types, 11, 9, true); [EOL]         list12 = (List<? extends String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 12, false); [EOL]         list9 = list12; [EOL]         delegateBooleanAssertion(types, 12, 9, true); [EOL]         list13 = (List<? super String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 13, false); [EOL]         list9 = list13; [EOL]         delegateBooleanAssertion(types, 13, 9, true); [EOL] //        list10 = list10; [EOL]         delegateBooleanAssertion(types, 10, 10, true); [EOL]         // list11 = list10; [EOL]         delegateBooleanAssertion(types, 10, 11, false); [EOL]         // list10 = list11; [EOL]         delegateBooleanAssertion(types, 11, 10, false); [EOL]         // list12 = list10; [EOL]         delegateBooleanAssertion(types, 10, 12, false); [EOL]         // list10 = list12; [EOL]         delegateBooleanAssertion(types, 12, 10, false); [EOL]         list13 = list10; [EOL]         delegateBooleanAssertion(types, 10, 13, true); [EOL]         list10 = (List<? super Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 10, false); [EOL] //        list11 = list11; [EOL]         delegateBooleanAssertion(types, 11, 11, true); [EOL]         list12 = list11; [EOL]         delegateBooleanAssertion(types, 11, 12, true); [EOL]         list11 = (List<String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 11, false); [EOL]         list13 = list11; [EOL]         delegateBooleanAssertion(types, 11, 13, true); [EOL]         list11 = (List<String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 11, false); [EOL] //        list12 = list12; [EOL]         delegateBooleanAssertion(types, 12, 12, true); [EOL]         list13 = (List<? super String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 13, false); [EOL]         list12 = (List<? extends String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 12, false); [EOL] //        list13 = list13; [EOL]         delegateBooleanAssertion(types, 13, 13, true); [EOL]         final Type disType = getClass().getField("dis").getGenericType(); [EOL]         // Reporter.log( ( ( ParameterizedType ) disType [EOL]         // ).getOwnerType().getClass().toString() ); [EOL]         final Type datType = getClass().getField("dat").getGenericType(); [EOL]         final Type daType = getClass().getField("da").getGenericType(); [EOL]         final Type uhderType = getClass().getField("uhder").getGenericType(); [EOL]         final Type dingType = getClass().getField("ding").getGenericType(); [EOL]         final Type testerType = getClass().getField("tester").getGenericType(); [EOL]         final Type tester2Type = getClass().getField("tester2").getGenericType(); [EOL]         final Type dat2Type = getClass().getField("dat2").getGenericType(); [EOL]         final Type dat3Type = getClass().getField("dat3").getGenericType(); [EOL]         dis = dat; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(datType, disType)); [EOL]         // dis = da; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(daType, disType)); [EOL]         dis = uhder; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(uhderType, disType)); [EOL]         dis = ding; [EOL]         Assert.assertFalse(String.format("type %s not assignable to %s!", dingType, disType), [EOL]                 TypeUtils.isAssignable(dingType, disType)); [EOL]         dis = tester; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(testerType, disType)); [EOL]         // dis = tester2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(tester2Type, disType)); [EOL]         // dat = dat2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat2Type, datType)); [EOL]         // dat2 = dat; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(datType, dat2Type)); [EOL]         // dat = dat3; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat3Type, datType)); [EOL]         final char ch = 0; [EOL]         final boolean bo = false; [EOL]         final byte by = 0; [EOL]         final short sh = 0; [EOL]         int in = 0; [EOL]         long lo = 0; [EOL]         final float fl = 0; [EOL]         double du = 0; [EOL]         du = ch; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(char.class, double.class)); [EOL]         du = by; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(byte.class, double.class)); [EOL]         du = sh; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(short.class, double.class)); [EOL]         du = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, double.class)); [EOL]         du = lo; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(long.class, double.class)); [EOL]         du = fl; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(float.class, double.class)); [EOL]         lo = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, long.class)); [EOL]         lo = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, long.class)); [EOL]         // Long lngW = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, Long.class)); [EOL]         // lngW = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, Long.class)); [EOL]         in = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, int.class)); [EOL]         final Integer inte = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Integer.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Number.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Object.class)); [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, intComparableType)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Comparable.class)); [EOL]         final Serializable ser = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Serializable.class)); [EOL]         final Type longComparableType = getClass().getField("longComparable").getGenericType(); [EOL]         // longComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, longComparableType)); [EOL]         // longComparable = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, longComparableType)); [EOL]         // int[] ia; [EOL]         // long[] la = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, long[].class)); [EOL]         final Integer[] ia = null; [EOL]         final Type caType = getClass().getField("intWildcardComparable").getGenericType(); [EOL]         intWildcardComparable = ia; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, caType)); [EOL]         // int[] ina = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer[].class, int[].class)); [EOL]         final int[] ina = null; [EOL]         Object[] oa; [EOL]         // oa = ina; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, Object[].class)); [EOL]         oa = new Integer[0]; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, Object[].class)); [EOL]         final Type bClassType = AClass.class.getField("bClass").getGenericType(); [EOL]         final Type cClassType = AClass.class.getField("cClass").getGenericType(); [EOL]         final Type dClassType = AClass.class.getField("dClass").getGenericType(); [EOL]         final Type eClassType = AClass.class.getField("eClass").getGenericType(); [EOL]         final Type fClassType = AClass.class.getField("fClass").getGenericType(); [EOL]         final AClass aClass = new AClass(new AAClass<String>()); [EOL]         aClass.bClass = aClass.cClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(cClassType, bClassType)); [EOL]         aClass.bClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, bClassType)); [EOL]         aClass.bClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, bClassType)); [EOL]         aClass.bClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, bClassType)); [EOL]         aClass.cClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, cClassType)); [EOL]         aClass.cClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, cClassType)); [EOL]         aClass.cClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, cClassType)); [EOL]         aClass.dClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, dClassType)); [EOL]         aClass.dClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, dClassType)); [EOL]         aClass.eClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, eClassType)); [EOL]     } [EOL]  [EOL]     public void delegateBooleanAssertion(final Type[] types, final int i2, final int i1, final boolean expected) { [EOL]         final Type type1 = types[i1]; [EOL]         final Type type2 = types[i2]; [EOL]         final boolean isAssignable = TypeUtils.isAssignable(type2, type1); [EOL]  [EOL]         if (expected) { [EOL]             Assert.assertTrue("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } else { [EOL]             Assert.assertFalse("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } [EOL]     } [EOL]  [EOL]     @SuppressWarnings("boxing") // boxing is deliberate here [EOL]
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [EOL]         final Type[] types = method.getGenericParameterTypes(); [EOL] //        list0 = list0; [EOL]         delegateBooleanAssertion(types, 0, 0, true); [EOL]         list1 = list0; [EOL]         delegateBooleanAssertion(types, 0, 1, true); [EOL]         list0 = list1; [EOL]         delegateBooleanAssertion(types, 1, 0, true); [EOL]         list2 = list0; [EOL]         delegateBooleanAssertion(types, 0, 2, true); [EOL]         list0 = list2; [EOL]         delegateBooleanAssertion(types, 2, 0, true); [EOL]         list3 = list0; [EOL]         delegateBooleanAssertion(types, 0, 3, true); [EOL]         list0 = list3; [EOL]         delegateBooleanAssertion(types, 3, 0, true); [EOL]         list4 = list0; [EOL]         delegateBooleanAssertion(types, 0, 4, true); [EOL]         list0 = list4; [EOL]         delegateBooleanAssertion(types, 4, 0, true); [EOL]         list5 = list0; [EOL]         delegateBooleanAssertion(types, 0, 5, true); [EOL]         list0 = list5; [EOL]         delegateBooleanAssertion(types, 5, 0, true); [EOL]         list6 = list0; [EOL]         delegateBooleanAssertion(types, 0, 6, true); [EOL]         list0 = list6; [EOL]         delegateBooleanAssertion(types, 6, 0, true); [EOL] //        list1 = list1; [EOL]         delegateBooleanAssertion(types, 1, 1, true); [EOL]         list2 = list1; [EOL]         delegateBooleanAssertion(types, 1, 2, true); [EOL]         list1 = (List<Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 1, false); [EOL]         list3 = list1; [EOL]         delegateBooleanAssertion(types, 1, 3, true); [EOL]         list1 = (List<Object>) list3; [EOL]         delegateBooleanAssertion(types, 3, 1, false); [EOL]         // list4 = list1; [EOL]         delegateBooleanAssertion(types, 1, 4, false); [EOL]         // list1 = list4; [EOL]         delegateBooleanAssertion(types, 4, 1, false); [EOL]         // list5 = list1; [EOL]         delegateBooleanAssertion(types, 1, 5, false); [EOL]         // list1 = list5; [EOL]         delegateBooleanAssertion(types, 5, 1, false); [EOL]         list6 = list1; [EOL]         delegateBooleanAssertion(types, 1, 6, true); [EOL]         list1 = (List<Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 1, false); [EOL] //        list2 = list2; [EOL]         delegateBooleanAssertion(types, 2, 2, true); [EOL]         list2 = list3; [EOL]         delegateBooleanAssertion(types, 2, 3, false); [EOL]         list2 = list4; [EOL]         delegateBooleanAssertion(types, 3, 2, true); [EOL]         list3 = (List<? super Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 4, false); [EOL]         list2 = list5; [EOL]         delegateBooleanAssertion(types, 4, 2, true); [EOL]         list4 = (List<String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 5, false); [EOL]         list2 = list6; [EOL]         delegateBooleanAssertion(types, 5, 2, true); [EOL]         list5 = (List<? extends String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 6, false); [EOL] //        list3 = list3; [EOL]         delegateBooleanAssertion(types, 6, 2, true); [EOL]         list6 = (List<? super String>) list2; [EOL]         delegateBooleanAssertion(types, 3, 3, true); [EOL]         // list4 = list3; [EOL]         delegateBooleanAssertion(types, 3, 4, false); [EOL]         // list3 = list4; [EOL]         delegateBooleanAssertion(types, 4, 3, false); [EOL]         // list5 = list3; [EOL]         delegateBooleanAssertion(types, 3, 5, false); [EOL]         // list3 = list5; [EOL]         delegateBooleanAssertion(types, 5, 3, false); [EOL]         list6 = list3; [EOL]         delegateBooleanAssertion(types, 3, 6, true); [EOL]         list3 = (List<? super Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 3, false); [EOL] //        list4 = list4; [EOL]         delegateBooleanAssertion(types, 4, 4, true); [EOL]         list5 = list4; [EOL]         delegateBooleanAssertion(types, 4, 5, true); [EOL]         list4 = (List<String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 4, false); [EOL]         list6 = list4; [EOL]         delegateBooleanAssertion(types, 4, 6, true); [EOL]         list4 = (List<String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 4, false); [EOL] //        list5 = list5; [EOL]         delegateBooleanAssertion(types, 5, 5, true); [EOL]         list6 = (List<? super String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 6, false); [EOL]         list5 = (List<? extends String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 5, false); [EOL] //        list6 = list6; [EOL]         delegateBooleanAssertion(types, 6, 6, true); [EOL]  [EOL] //        list7 = list7; [EOL]         delegateBooleanAssertion(types, 7, 7, true); [EOL]         list8 = list7; [EOL]         delegateBooleanAssertion(types, 7, 8, true); [EOL]         list7 = list8; [EOL]         delegateBooleanAssertion(types, 8, 7, true); [EOL]         list9 = list7; [EOL]         delegateBooleanAssertion(types, 7, 9, true); [EOL]         list7 = list9; [EOL]         delegateBooleanAssertion(types, 9, 7, true); [EOL]         list10 = list7; [EOL]         delegateBooleanAssertion(types, 7, 10, true); [EOL]         list7 = list10; [EOL]         delegateBooleanAssertion(types, 10, 7, true); [EOL]         list11 = list7; [EOL]         delegateBooleanAssertion(types, 7, 11, true); [EOL]         list7 = list11; [EOL]         delegateBooleanAssertion(types, 11, 7, true); [EOL]         list12 = list7; [EOL]         delegateBooleanAssertion(types, 7, 12, true); [EOL]         list7 = list12; [EOL]         delegateBooleanAssertion(types, 12, 7, true); [EOL]         list13 = list7; [EOL]         delegateBooleanAssertion(types, 7, 13, true); [EOL]         list7 = list13; [EOL]         delegateBooleanAssertion(types, 13, 7, true); [EOL] //        list8 = list8; [EOL]         delegateBooleanAssertion(types, 8, 8, true); [EOL]         list9 = list8; [EOL]         delegateBooleanAssertion(types, 8, 9, true); [EOL]         list8 = (List<Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 8, false); [EOL]         list10 = list8; [EOL]         delegateBooleanAssertion(types, 8, 10, true); [EOL]         list8 = (List<Object>[]) list10; // NOTE cast is required by Sun Java, but not by Eclipse [EOL]         delegateBooleanAssertion(types, 10, 8, false); [EOL]         // list11 = list8; [EOL]         delegateBooleanAssertion(types, 8, 11, false); [EOL]         // list8 = list11; [EOL]         delegateBooleanAssertion(types, 11, 8, false); [EOL]         // list12 = list8; [EOL]         delegateBooleanAssertion(types, 8, 12, false); [EOL]         // list8 = list12; [EOL]         delegateBooleanAssertion(types, 12, 8, false); [EOL]         list13 = list8; [EOL]         delegateBooleanAssertion(types, 8, 13, true); [EOL]         list8 = (List<Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 8, false); [EOL] //        list9 = list9; [EOL]         delegateBooleanAssertion(types, 9, 9, true); [EOL]         list10 = (List<? super Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 10, false); [EOL]         list9 = list10; [EOL]         delegateBooleanAssertion(types, 10, 9, true); [EOL]         list11 = (List<String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 11, false); [EOL]         list9 = list11; [EOL]         delegateBooleanAssertion(types, 11, 9, true); [EOL]         list12 = (List<? extends String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 12, false); [EOL]         list9 = list12; [EOL]         delegateBooleanAssertion(types, 12, 9, true); [EOL]         list13 = (List<? super String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 13, false); [EOL]         list9 = list13; [EOL]         delegateBooleanAssertion(types, 13, 9, true); [EOL] //        list10 = list10; [EOL]         delegateBooleanAssertion(types, 10, 10, true); [EOL]         // list11 = list10; [EOL]         delegateBooleanAssertion(types, 10, 11, false); [EOL]         // list10 = list11; [EOL]         delegateBooleanAssertion(types, 11, 10, false); [EOL]         // list12 = list10; [EOL]         delegateBooleanAssertion(types, 10, 12, false); [EOL]         // list10 = list12; [EOL]         delegateBooleanAssertion(types, 12, 10, false); [EOL]         list13 = list10; [EOL]         delegateBooleanAssertion(types, 10, 13, true); [EOL]         list10 = (List<? super Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 10, false); [EOL] //        list11 = list11; [EOL]         delegateBooleanAssertion(types, 11, 11, true); [EOL]         list12 = list11; [EOL]         delegateBooleanAssertion(types, 11, 12, true); [EOL]         list11 = (List<String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 11, false); [EOL]         list13 = list11; [EOL]         delegateBooleanAssertion(types, 11, 13, true); [EOL]         list11 = (List<String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 11, false); [EOL] //        list12 = list12; [EOL]         delegateBooleanAssertion(types, 12, 12, true); [EOL]         list13 = (List<? super String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 13, false); [EOL]         list12 = (List<? extends String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 12, false); [EOL] //        list13 = list13; [EOL]         delegateBooleanAssertion(types, 13, 13, true); [EOL]         final Type disType = getClass().getField("dis").getGenericType(); [EOL]         // Reporter.log( ( ( ParameterizedType ) disType [EOL]         // ).getOwnerType().getClass().toString() ); [EOL]         final Type datType = getClass().getField("dat").getGenericType(); [EOL]         final Type daType = getClass().getField("da").getGenericType(); [EOL]         final Type uhderType = getClass().getField("uhder").getGenericType(); [EOL]         final Type dingType = getClass().getField("ding").getGenericType(); [EOL]         final Type testerType = getClass().getField("tester").getGenericType(); [EOL]         final Type tester2Type = getClass().getField("tester2").getGenericType(); [EOL]         final Type dat2Type = getClass().getField("dat2").getGenericType(); [EOL]         final Type dat3Type = getClass().getField("dat3").getGenericType(); [EOL]         dis = dat; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(datType, disType)); [EOL]         // dis = da; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(daType, disType)); [EOL]         dis = uhder; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(uhderType, disType)); [EOL]         dis = ding; [EOL]         Assert.assertFalse(String.format("type %s not assignable to %s!", dingType, disType), [EOL]                 TypeUtils.isAssignable(dingType, disType)); [EOL]         dis = tester; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(testerType, disType)); [EOL]         // dis = tester2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(tester2Type, disType)); [EOL]         // dat = dat2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat2Type, datType)); [EOL]         // dat2 = dat; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(datType, dat2Type)); [EOL]         // dat = dat3; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat3Type, datType)); [EOL]         final char ch = 0; [EOL]         final boolean bo = false; [EOL]         final byte by = 0; [EOL]         final short sh = 0; [EOL]         int in = 0; [EOL]         long lo = 0; [EOL]         final float fl = 0; [EOL]         double du = 0; [EOL]         du = ch; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(char.class, double.class)); [EOL]         du = by; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(byte.class, double.class)); [EOL]         du = sh; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(short.class, double.class)); [EOL]         du = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, double.class)); [EOL]         du = lo; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(long.class, double.class)); [EOL]         du = fl; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(float.class, double.class)); [EOL]         lo = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, long.class)); [EOL]         lo = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, long.class)); [EOL]         // Long lngW = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, Long.class)); [EOL]         // lngW = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, Long.class)); [EOL]         in = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, int.class)); [EOL]         final Integer inte = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Integer.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Number.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Object.class)); [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, intComparableType)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Comparable.class)); [EOL]         final Serializable ser = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Serializable.class)); [EOL]         final Type longComparableType = getClass().getField("longComparable").getGenericType(); [EOL]         // longComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, longComparableType)); [EOL]         // longComparable = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, longComparableType)); [EOL]         // int[] ia; [EOL]         // long[] la = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, long[].class)); [EOL]         final Integer[] ia = null; [EOL]         final Type caType = getClass().getField("intWildcardComparable").getGenericType(); [EOL]         intWildcardComparable = ia; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, caType)); [EOL]         // int[] ina = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer[].class, int[].class)); [EOL]         final int[] ina = null; [EOL]         Object[] oa; [EOL]         // oa = ina; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, Object[].class)); [EOL]         oa = new Integer[0]; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, Object[].class)); [EOL]         final Type bClassType = AClass.class.getField("bClass").getGenericType(); [EOL]         final Type cClassType = AClass.class.getField("cClass").getGenericType(); [EOL]         final Type dClassType = AClass.class.getField("dClass").getGenericType(); [EOL]         final Type eClassType = AClass.class.getField("eClass").getGenericType(); [EOL]         final Type fClassType = AClass.class.getField("fClass").getGenericType(); [EOL]         final AClass aClass = new AClass(new AAClass<String>()); [EOL]         aClass.bClass = aClass.cClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(cClassType, bClassType)); [EOL]         aClass.bClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, bClassType)); [EOL]         aClass.bClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, bClassType)); [EOL]         aClass.bClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, bClassType)); [EOL]         aClass.cClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, cClassType)); [EOL]         aClass.cClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, cClassType)); [EOL]         aClass.cClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, cClassType)); [EOL]         aClass.dClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, dClassType)); [EOL]         aClass.dClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, dClassType)); [EOL]         aClass.eClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, eClassType)); [EOL]     } [EOL]  [EOL]     public void delegateBooleanAssertion(final Type[] types, final int i2, final int i1, final boolean expected) { [EOL]         final Type type1 = types[i1]; [EOL]         final Type type2 = types[i2]; [EOL]         final boolean isAssignable = TypeUtils.isAssignable(type2, type1); [EOL]  [EOL]         if (expected) { [EOL]             Assert.assertTrue("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } else { [EOL]             Assert.assertFalse("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } [EOL]     } [EOL]  [EOL]     @SuppressWarnings("boxing") // boxing is deliberate here [EOL]
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [EOL]         final Type[] types = method.getGenericParameterTypes(); [EOL] //        list0 = list0; [EOL]         delegateBooleanAssertion(types, 0, 0, true); [EOL]         list1 = list0; [EOL]         delegateBooleanAssertion(types, 0, 1, true); [EOL]         list0 = list1; [EOL]         delegateBooleanAssertion(types, 1, 0, true); [EOL]         list2 = list0; [EOL]         delegateBooleanAssertion(types, 0, 2, true); [EOL]         list0 = list2; [EOL]         delegateBooleanAssertion(types, 2, 0, true); [EOL]         list3 = list0; [EOL]         delegateBooleanAssertion(types, 0, 3, true); [EOL]         list0 = list3; [EOL]         delegateBooleanAssertion(types, 3, 0, true); [EOL]         list4 = list0; [EOL]         delegateBooleanAssertion(types, 0, 4, true); [EOL]         list0 = list4; [EOL]         delegateBooleanAssertion(types, 4, 0, true); [EOL]         list5 = list0; [EOL]         delegateBooleanAssertion(types, 0, 5, true); [EOL]         list0 = list5; [EOL]         delegateBooleanAssertion(types, 5, 0, true); [EOL]         list6 = list0; [EOL]         delegateBooleanAssertion(types, 0, 6, true); [EOL]         list0 = list6; [EOL]         delegateBooleanAssertion(types, 6, 0, true); [EOL] //        list1 = list1; [EOL]         delegateBooleanAssertion(types, 1, 1, true); [EOL]         list2 = list1; [EOL]         delegateBooleanAssertion(types, 1, 2, true); [EOL]         list1 = (List<Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 1, false); [EOL]         list3 = list1; [EOL]         delegateBooleanAssertion(types, 1, 3, true); [EOL]         list1 = (List<Object>) list3; [EOL]         delegateBooleanAssertion(types, 3, 1, false); [EOL]         // list4 = list1; [EOL]         delegateBooleanAssertion(types, 1, 4, false); [EOL]         // list1 = list4; [EOL]         delegateBooleanAssertion(types, 4, 1, false); [EOL]         // list5 = list1; [EOL]         delegateBooleanAssertion(types, 1, 5, false); [EOL]         // list1 = list5; [EOL]         delegateBooleanAssertion(types, 5, 1, false); [EOL]         list6 = list1; [EOL]         delegateBooleanAssertion(types, 1, 6, true); [EOL]         list1 = (List<Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 1, false); [EOL] //        list2 = list2; [EOL]         delegateBooleanAssertion(types, 2, 2, true); [EOL]         list2 = list3; [EOL]         delegateBooleanAssertion(types, 2, 3, false); [EOL]         list2 = list4; [EOL]         delegateBooleanAssertion(types, 3, 2, true); [EOL]         list3 = (List<? super Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 4, false); [EOL]         list2 = list5; [EOL]         delegateBooleanAssertion(types, 4, 2, true); [EOL]         list4 = (List<String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 5, false); [EOL]         list2 = list6; [EOL]         delegateBooleanAssertion(types, 5, 2, true); [EOL]         list5 = (List<? extends String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 6, false); [EOL] //        list3 = list3; [EOL]         delegateBooleanAssertion(types, 6, 2, true); [EOL]         list6 = (List<? super String>) list2; [EOL]         delegateBooleanAssertion(types, 3, 3, true); [EOL]         // list4 = list3; [EOL]         delegateBooleanAssertion(types, 3, 4, false); [EOL]         // list3 = list4; [EOL]         delegateBooleanAssertion(types, 4, 3, false); [EOL]         // list5 = list3; [EOL]         delegateBooleanAssertion(types, 3, 5, false); [EOL]         // list3 = list5; [EOL]         delegateBooleanAssertion(types, 5, 3, false); [EOL]         list6 = list3; [EOL]         delegateBooleanAssertion(types, 3, 6, true); [EOL]         list3 = (List<? super Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 3, false); [EOL] //        list4 = list4; [EOL]         delegateBooleanAssertion(types, 4, 4, true); [EOL]         list5 = list4; [EOL]         delegateBooleanAssertion(types, 4, 5, true); [EOL]         list4 = (List<String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 4, false); [EOL]         list6 = list4; [EOL]         delegateBooleanAssertion(types, 4, 6, true); [EOL]         list4 = (List<String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 4, false); [EOL] //        list5 = list5; [EOL]         delegateBooleanAssertion(types, 5, 5, true); [EOL]         list6 = (List<? super String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 6, false); [EOL]         list5 = (List<? extends String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 5, false); [EOL] //        list6 = list6; [EOL]         delegateBooleanAssertion(types, 6, 6, true); [EOL]  [EOL] //        list7 = list7; [EOL]         delegateBooleanAssertion(types, 7, 7, true); [EOL]         list8 = list7; [EOL]         delegateBooleanAssertion(types, 7, 8, true); [EOL]         list7 = list8; [EOL]         delegateBooleanAssertion(types, 8, 7, true); [EOL]         list9 = list7; [EOL]         delegateBooleanAssertion(types, 7, 9, true); [EOL]         list7 = list9; [EOL]         delegateBooleanAssertion(types, 9, 7, true); [EOL]         list10 = list7; [EOL]         delegateBooleanAssertion(types, 7, 10, true); [EOL]         list7 = list10; [EOL]         delegateBooleanAssertion(types, 10, 7, true); [EOL]         list11 = list7; [EOL]         delegateBooleanAssertion(types, 7, 11, true); [EOL]         list7 = list11; [EOL]         delegateBooleanAssertion(types, 11, 7, true); [EOL]         list12 = list7; [EOL]         delegateBooleanAssertion(types, 7, 12, true); [EOL]         list7 = list12; [EOL]         delegateBooleanAssertion(types, 12, 7, true); [EOL]         list13 = list7; [EOL]         delegateBooleanAssertion(types, 7, 13, true); [EOL]         list7 = list13; [EOL]         delegateBooleanAssertion(types, 13, 7, true); [EOL] //        list8 = list8; [EOL]         delegateBooleanAssertion(types, 8, 8, true); [EOL]         list9 = list8; [EOL]         delegateBooleanAssertion(types, 8, 9, true); [EOL]         list8 = (List<Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 8, false); [EOL]         list10 = list8; [EOL]         delegateBooleanAssertion(types, 8, 10, true); [EOL]         list8 = (List<Object>[]) list10; // NOTE cast is required by Sun Java, but not by Eclipse [EOL]         delegateBooleanAssertion(types, 10, 8, false); [EOL]         // list11 = list8; [EOL]         delegateBooleanAssertion(types, 8, 11, false); [EOL]         // list8 = list11; [EOL]         delegateBooleanAssertion(types, 11, 8, false); [EOL]         // list12 = list8; [EOL]         delegateBooleanAssertion(types, 8, 12, false); [EOL]         // list8 = list12; [EOL]         delegateBooleanAssertion(types, 12, 8, false); [EOL]         list13 = list8; [EOL]         delegateBooleanAssertion(types, 8, 13, true); [EOL]         list8 = (List<Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 8, false); [EOL] //        list9 = list9; [EOL]         delegateBooleanAssertion(types, 9, 9, true); [EOL]         list10 = (List<? super Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 10, false); [EOL]         list9 = list10; [EOL]         delegateBooleanAssertion(types, 10, 9, true); [EOL]         list11 = (List<String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 11, false); [EOL]         list9 = list11; [EOL]         delegateBooleanAssertion(types, 11, 9, true); [EOL]         list12 = (List<? extends String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 12, false); [EOL]         list9 = list12; [EOL]         delegateBooleanAssertion(types, 12, 9, true); [EOL]         list13 = (List<? super String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 13, false); [EOL]         list9 = list13; [EOL]         delegateBooleanAssertion(types, 13, 9, true); [EOL] //        list10 = list10; [EOL]         delegateBooleanAssertion(types, 10, 10, true); [EOL]         // list11 = list10; [EOL]         delegateBooleanAssertion(types, 10, 11, false); [EOL]         // list10 = list11; [EOL]         delegateBooleanAssertion(types, 11, 10, false); [EOL]         // list12 = list10; [EOL]         delegateBooleanAssertion(types, 10, 12, false); [EOL]         // list10 = list12; [EOL]         delegateBooleanAssertion(types, 12, 10, false); [EOL]         list13 = list10; [EOL]         delegateBooleanAssertion(types, 10, 13, true); [EOL]         list10 = (List<? super Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 10, false); [EOL] //        list11 = list11; [EOL]         delegateBooleanAssertion(types, 11, 11, true); [EOL]         list12 = list11; [EOL]         delegateBooleanAssertion(types, 11, 12, true); [EOL]         list11 = (List<String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 11, false); [EOL]         list13 = list11; [EOL]         delegateBooleanAssertion(types, 11, 13, true); [EOL]         list11 = (List<String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 11, false); [EOL] //        list12 = list12; [EOL]         delegateBooleanAssertion(types, 12, 12, true); [EOL]         list13 = (List<? super String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 13, false); [EOL]         list12 = (List<? extends String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 12, false); [EOL] //        list13 = list13; [EOL]         delegateBooleanAssertion(types, 13, 13, true); [EOL]         final Type disType = getClass().getField("dis").getGenericType(); [EOL]         // Reporter.log( ( ( ParameterizedType ) disType [EOL]         // ).getOwnerType().getClass().toString() ); [EOL]         final Type datType = getClass().getField("dat").getGenericType(); [EOL]         final Type daType = getClass().getField("da").getGenericType(); [EOL]         final Type uhderType = getClass().getField("uhder").getGenericType(); [EOL]         final Type dingType = getClass().getField("ding").getGenericType(); [EOL]         final Type testerType = getClass().getField("tester").getGenericType(); [EOL]         final Type tester2Type = getClass().getField("tester2").getGenericType(); [EOL]         final Type dat2Type = getClass().getField("dat2").getGenericType(); [EOL]         final Type dat3Type = getClass().getField("dat3").getGenericType(); [EOL]         dis = dat; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(datType, disType)); [EOL]         // dis = da; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(daType, disType)); [EOL]         dis = uhder; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(uhderType, disType)); [EOL]         dis = ding; [EOL]         Assert.assertFalse(String.format("type %s not assignable to %s!", dingType, disType), [EOL]                 TypeUtils.isAssignable(dingType, disType)); [EOL]         dis = tester; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(testerType, disType)); [EOL]         // dis = tester2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(tester2Type, disType)); [EOL]         // dat = dat2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat2Type, datType)); [EOL]         // dat2 = dat; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(datType, dat2Type)); [EOL]         // dat = dat3; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat3Type, datType)); [EOL]         final char ch = 0; [EOL]         final boolean bo = false; [EOL]         final byte by = 0; [EOL]         final short sh = 0; [EOL]         int in = 0; [EOL]         long lo = 0; [EOL]         final float fl = 0; [EOL]         double du = 0; [EOL]         du = ch; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(char.class, double.class)); [EOL]         du = by; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(byte.class, double.class)); [EOL]         du = sh; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(short.class, double.class)); [EOL]         du = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, double.class)); [EOL]         du = lo; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(long.class, double.class)); [EOL]         du = fl; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(float.class, double.class)); [EOL]         lo = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, long.class)); [EOL]         lo = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, long.class)); [EOL]         // Long lngW = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, Long.class)); [EOL]         // lngW = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, Long.class)); [EOL]         in = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, int.class)); [EOL]         final Integer inte = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Integer.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Number.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Object.class)); [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, intComparableType)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Comparable.class)); [EOL]         final Serializable ser = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Serializable.class)); [EOL]         final Type longComparableType = getClass().getField("longComparable").getGenericType(); [EOL]         // longComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, longComparableType)); [EOL]         // longComparable = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, longComparableType)); [EOL]         // int[] ia; [EOL]         // long[] la = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, long[].class)); [EOL]         final Integer[] ia = null; [EOL]         final Type caType = getClass().getField("intWildcardComparable").getGenericType(); [EOL]         intWildcardComparable = ia; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, caType)); [EOL]         // int[] ina = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer[].class, int[].class)); [EOL]         final int[] ina = null; [EOL]         Object[] oa; [EOL]         // oa = ina; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, Object[].class)); [EOL]         oa = new Integer[0]; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, Object[].class)); [EOL]         final Type bClassType = AClass.class.getField("bClass").getGenericType(); [EOL]         final Type cClassType = AClass.class.getField("cClass").getGenericType(); [EOL]         final Type dClassType = AClass.class.getField("dClass").getGenericType(); [EOL]         final Type eClassType = AClass.class.getField("eClass").getGenericType(); [EOL]         final Type fClassType = AClass.class.getField("fClass").getGenericType(); [EOL]         final AClass aClass = new AClass(new AAClass<String>()); [EOL]         aClass.bClass = aClass.cClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(cClassType, bClassType)); [EOL]         aClass.bClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, bClassType)); [EOL]         aClass.bClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, bClassType)); [EOL]         aClass.bClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, bClassType)); [EOL]         aClass.cClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, cClassType)); [EOL]         aClass.cClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, cClassType)); [EOL]         aClass.cClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, cClassType)); [EOL]         aClass.dClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, dClassType)); [EOL]         aClass.dClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, dClassType)); [EOL]         aClass.eClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, eClassType)); [EOL]     } [EOL]  [EOL]     public void delegateBooleanAssertion(final Type[] types, final int i2, final int i1, final boolean expected) { [EOL]         final Type type1 = types[i1]; [EOL]         final Type type2 = types[i2]; [EOL]         final boolean isAssignable = TypeUtils.isAssignable(type2, type1); [EOL]  [EOL]         if (expected) { [EOL]             Assert.assertTrue("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } else { [EOL]             Assert.assertFalse("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } [EOL]     } [EOL]  [EOL]     @SuppressWarnings("boxing") // boxing is deliberate here [EOL]
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [EOL]         final Type[] types = method.getGenericParameterTypes(); [EOL] //        list0 = list0; [EOL]         delegateBooleanAssertion(types, 0, 0, true); [EOL]         list1 = list0; [EOL]         delegateBooleanAssertion(types, 0, 1, true); [EOL]         list0 = list1; [EOL]         delegateBooleanAssertion(types, 1, 0, true); [EOL]         list2 = list0; [EOL]         delegateBooleanAssertion(types, 0, 2, true); [EOL]         list0 = list2; [EOL]         delegateBooleanAssertion(types, 2, 0, true); [EOL]         list3 = list0; [EOL]         delegateBooleanAssertion(types, 0, 3, true); [EOL]         list0 = list3; [EOL]         delegateBooleanAssertion(types, 3, 0, true); [EOL]         list4 = list0; [EOL]         delegateBooleanAssertion(types, 0, 4, true); [EOL]         list0 = list4; [EOL]         delegateBooleanAssertion(types, 4, 0, true); [EOL]         list5 = list0; [EOL]         delegateBooleanAssertion(types, 0, 5, true); [EOL]         list0 = list5; [EOL]         delegateBooleanAssertion(types, 5, 0, true); [EOL]         list6 = list0; [EOL]         delegateBooleanAssertion(types, 0, 6, true); [EOL]         list0 = list6; [EOL]         delegateBooleanAssertion(types, 6, 0, true); [EOL] //        list1 = list1; [EOL]         delegateBooleanAssertion(types, 1, 1, true); [EOL]         list2 = list1; [EOL]         delegateBooleanAssertion(types, 1, 2, true); [EOL]         list1 = (List<Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 1, false); [EOL]         list3 = list1; [EOL]         delegateBooleanAssertion(types, 1, 3, true); [EOL]         list1 = (List<Object>) list3; [EOL]         delegateBooleanAssertion(types, 3, 1, false); [EOL]         // list4 = list1; [EOL]         delegateBooleanAssertion(types, 1, 4, false); [EOL]         // list1 = list4; [EOL]         delegateBooleanAssertion(types, 4, 1, false); [EOL]         // list5 = list1; [EOL]         delegateBooleanAssertion(types, 1, 5, false); [EOL]         // list1 = list5; [EOL]         delegateBooleanAssertion(types, 5, 1, false); [EOL]         list6 = list1; [EOL]         delegateBooleanAssertion(types, 1, 6, true); [EOL]         list1 = (List<Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 1, false); [EOL] //        list2 = list2; [EOL]         delegateBooleanAssertion(types, 2, 2, true); [EOL]         list2 = list3; [EOL]         delegateBooleanAssertion(types, 2, 3, false); [EOL]         list2 = list4; [EOL]         delegateBooleanAssertion(types, 3, 2, true); [EOL]         list3 = (List<? super Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 4, false); [EOL]         list2 = list5; [EOL]         delegateBooleanAssertion(types, 4, 2, true); [EOL]         list4 = (List<String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 5, false); [EOL]         list2 = list6; [EOL]         delegateBooleanAssertion(types, 5, 2, true); [EOL]         list5 = (List<? extends String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 6, false); [EOL] //        list3 = list3; [EOL]         delegateBooleanAssertion(types, 6, 2, true); [EOL]         list6 = (List<? super String>) list2; [EOL]         delegateBooleanAssertion(types, 3, 3, true); [EOL]         // list4 = list3; [EOL]         delegateBooleanAssertion(types, 3, 4, false); [EOL]         // list3 = list4; [EOL]         delegateBooleanAssertion(types, 4, 3, false); [EOL]         // list5 = list3; [EOL]         delegateBooleanAssertion(types, 3, 5, false); [EOL]         // list3 = list5; [EOL]         delegateBooleanAssertion(types, 5, 3, false); [EOL]         list6 = list3; [EOL]         delegateBooleanAssertion(types, 3, 6, true); [EOL]         list3 = (List<? super Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 3, false); [EOL] //        list4 = list4; [EOL]         delegateBooleanAssertion(types, 4, 4, true); [EOL]         list5 = list4; [EOL]         delegateBooleanAssertion(types, 4, 5, true); [EOL]         list4 = (List<String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 4, false); [EOL]         list6 = list4; [EOL]         delegateBooleanAssertion(types, 4, 6, true); [EOL]         list4 = (List<String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 4, false); [EOL] //        list5 = list5; [EOL]         delegateBooleanAssertion(types, 5, 5, true); [EOL]         list6 = (List<? super String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 6, false); [EOL]         list5 = (List<? extends String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 5, false); [EOL] //        list6 = list6; [EOL]         delegateBooleanAssertion(types, 6, 6, true); [EOL]  [EOL] //        list7 = list7; [EOL]         delegateBooleanAssertion(types, 7, 7, true); [EOL]         list8 = list7; [EOL]         delegateBooleanAssertion(types, 7, 8, true); [EOL]         list7 = list8; [EOL]         delegateBooleanAssertion(types, 8, 7, true); [EOL]         list9 = list7; [EOL]         delegateBooleanAssertion(types, 7, 9, true); [EOL]         list7 = list9; [EOL]         delegateBooleanAssertion(types, 9, 7, true); [EOL]         list10 = list7; [EOL]         delegateBooleanAssertion(types, 7, 10, true); [EOL]         list7 = list10; [EOL]         delegateBooleanAssertion(types, 10, 7, true); [EOL]         list11 = list7; [EOL]         delegateBooleanAssertion(types, 7, 11, true); [EOL]         list7 = list11; [EOL]         delegateBooleanAssertion(types, 11, 7, true); [EOL]         list12 = list7; [EOL]         delegateBooleanAssertion(types, 7, 12, true); [EOL]         list7 = list12; [EOL]         delegateBooleanAssertion(types, 12, 7, true); [EOL]         list13 = list7; [EOL]         delegateBooleanAssertion(types, 7, 13, true); [EOL]         list7 = list13; [EOL]         delegateBooleanAssertion(types, 13, 7, true); [EOL] //        list8 = list8; [EOL]         delegateBooleanAssertion(types, 8, 8, true); [EOL]         list9 = list8; [EOL]         delegateBooleanAssertion(types, 8, 9, true); [EOL]         list8 = (List<Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 8, false); [EOL]         list10 = list8; [EOL]         delegateBooleanAssertion(types, 8, 10, true); [EOL]         list8 = (List<Object>[]) list10; // NOTE cast is required by Sun Java, but not by Eclipse [EOL]         delegateBooleanAssertion(types, 10, 8, false); [EOL]         // list11 = list8; [EOL]         delegateBooleanAssertion(types, 8, 11, false); [EOL]         // list8 = list11; [EOL]         delegateBooleanAssertion(types, 11, 8, false); [EOL]         // list12 = list8; [EOL]         delegateBooleanAssertion(types, 8, 12, false); [EOL]         // list8 = list12; [EOL]         delegateBooleanAssertion(types, 12, 8, false); [EOL]         list13 = list8; [EOL]         delegateBooleanAssertion(types, 8, 13, true); [EOL]         list8 = (List<Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 8, false); [EOL] //        list9 = list9; [EOL]         delegateBooleanAssertion(types, 9, 9, true); [EOL]         list10 = (List<? super Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 10, false); [EOL]         list9 = list10; [EOL]         delegateBooleanAssertion(types, 10, 9, true); [EOL]         list11 = (List<String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 11, false); [EOL]         list9 = list11; [EOL]         delegateBooleanAssertion(types, 11, 9, true); [EOL]         list12 = (List<? extends String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 12, false); [EOL]         list9 = list12; [EOL]         delegateBooleanAssertion(types, 12, 9, true); [EOL]         list13 = (List<? super String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 13, false); [EOL]         list9 = list13; [EOL]         delegateBooleanAssertion(types, 13, 9, true); [EOL] //        list10 = list10; [EOL]         delegateBooleanAssertion(types, 10, 10, true); [EOL]         // list11 = list10; [EOL]         delegateBooleanAssertion(types, 10, 11, false); [EOL]         // list10 = list11; [EOL]         delegateBooleanAssertion(types, 11, 10, false); [EOL]         // list12 = list10; [EOL]         delegateBooleanAssertion(types, 10, 12, false); [EOL]         // list10 = list12; [EOL]         delegateBooleanAssertion(types, 12, 10, false); [EOL]         list13 = list10; [EOL]         delegateBooleanAssertion(types, 10, 13, true); [EOL]         list10 = (List<? super Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 10, false); [EOL] //        list11 = list11; [EOL]         delegateBooleanAssertion(types, 11, 11, true); [EOL]         list12 = list11; [EOL]         delegateBooleanAssertion(types, 11, 12, true); [EOL]         list11 = (List<String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 11, false); [EOL]         list13 = list11; [EOL]         delegateBooleanAssertion(types, 11, 13, true); [EOL]         list11 = (List<String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 11, false); [EOL] //        list12 = list12; [EOL]         delegateBooleanAssertion(types, 12, 12, true); [EOL]         list13 = (List<? super String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 13, false); [EOL]         list12 = (List<? extends String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 12, false); [EOL] //        list13 = list13; [EOL]         delegateBooleanAssertion(types, 13, 13, true); [EOL]         final Type disType = getClass().getField("dis").getGenericType(); [EOL]         // Reporter.log( ( ( ParameterizedType ) disType [EOL]         // ).getOwnerType().getClass().toString() ); [EOL]         final Type datType = getClass().getField("dat").getGenericType(); [EOL]         final Type daType = getClass().getField("da").getGenericType(); [EOL]         final Type uhderType = getClass().getField("uhder").getGenericType(); [EOL]         final Type dingType = getClass().getField("ding").getGenericType(); [EOL]         final Type testerType = getClass().getField("tester").getGenericType(); [EOL]         final Type tester2Type = getClass().getField("tester2").getGenericType(); [EOL]         final Type dat2Type = getClass().getField("dat2").getGenericType(); [EOL]         final Type dat3Type = getClass().getField("dat3").getGenericType(); [EOL]         dis = dat; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(datType, disType)); [EOL]         // dis = da; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(daType, disType)); [EOL]         dis = uhder; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(uhderType, disType)); [EOL]         dis = ding; [EOL]         Assert.assertFalse(String.format("type %s not assignable to %s!", dingType, disType), [EOL]                 TypeUtils.isAssignable(dingType, disType)); [EOL]         dis = tester; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(testerType, disType)); [EOL]         // dis = tester2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(tester2Type, disType)); [EOL]         // dat = dat2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat2Type, datType)); [EOL]         // dat2 = dat; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(datType, dat2Type)); [EOL]         // dat = dat3; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat3Type, datType)); [EOL]         final char ch = 0; [EOL]         final boolean bo = false; [EOL]         final byte by = 0; [EOL]         final short sh = 0; [EOL]         int in = 0; [EOL]         long lo = 0; [EOL]         final float fl = 0; [EOL]         double du = 0; [EOL]         du = ch; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(char.class, double.class)); [EOL]         du = by; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(byte.class, double.class)); [EOL]         du = sh; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(short.class, double.class)); [EOL]         du = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, double.class)); [EOL]         du = lo; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(long.class, double.class)); [EOL]         du = fl; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(float.class, double.class)); [EOL]         lo = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, long.class)); [EOL]         lo = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, long.class)); [EOL]         // Long lngW = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, Long.class)); [EOL]         // lngW = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, Long.class)); [EOL]         in = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, int.class)); [EOL]         final Integer inte = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Integer.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Number.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Object.class)); [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, intComparableType)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Comparable.class)); [EOL]         final Serializable ser = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Serializable.class)); [EOL]         final Type longComparableType = getClass().getField("longComparable").getGenericType(); [EOL]         // longComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, longComparableType)); [EOL]         // longComparable = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, longComparableType)); [EOL]         // int[] ia; [EOL]         // long[] la = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, long[].class)); [EOL]         final Integer[] ia = null; [EOL]         final Type caType = getClass().getField("intWildcardComparable").getGenericType(); [EOL]         intWildcardComparable = ia; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, caType)); [EOL]         // int[] ina = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer[].class, int[].class)); [EOL]         final int[] ina = null; [EOL]         Object[] oa; [EOL]         // oa = ina; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, Object[].class)); [EOL]         oa = new Integer[0]; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, Object[].class)); [EOL]         final Type bClassType = AClass.class.getField("bClass").getGenericType(); [EOL]         final Type cClassType = AClass.class.getField("cClass").getGenericType(); [EOL]         final Type dClassType = AClass.class.getField("dClass").getGenericType(); [EOL]         final Type eClassType = AClass.class.getField("eClass").getGenericType(); [EOL]         final Type fClassType = AClass.class.getField("fClass").getGenericType(); [EOL]         final AClass aClass = new AClass(new AAClass<String>()); [EOL]         aClass.bClass = aClass.cClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(cClassType, bClassType)); [EOL]         aClass.bClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, bClassType)); [EOL]         aClass.bClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, bClassType)); [EOL]         aClass.bClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, bClassType)); [EOL]         aClass.cClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, cClassType)); [EOL]         aClass.cClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, cClassType)); [EOL]         aClass.cClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, cClassType)); [EOL]         aClass.dClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, dClassType)); [EOL]         aClass.dClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, dClassType)); [EOL]         aClass.eClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, eClassType)); [EOL]     } [EOL]  [EOL]     public void delegateBooleanAssertion(final Type[] types, final int i2, final int i1, final boolean expected) { [EOL]         final Type type1 = types[i1]; [EOL]         final Type type2 = types[i2]; [EOL]         final boolean isAssignable = TypeUtils.isAssignable(type2, type1); [EOL]  [EOL]         if (expected) { [EOL]             Assert.assertTrue("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } else { [EOL]             Assert.assertFalse("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } [EOL]     } [EOL]  [EOL]     @SuppressWarnings("boxing") // boxing is deliberate here [EOL]
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [EOL]         final Type[] types = method.getGenericParameterTypes(); [EOL] //        list0 = list0; [EOL]         delegateBooleanAssertion(types, 0, 0, true); [EOL]         list1 = list0; [EOL]         delegateBooleanAssertion(types, 0, 1, true); [EOL]         list0 = list1; [EOL]         delegateBooleanAssertion(types, 1, 0, true); [EOL]         list2 = list0; [EOL]         delegateBooleanAssertion(types, 0, 2, true); [EOL]         list0 = list2; [EOL]         delegateBooleanAssertion(types, 2, 0, true); [EOL]         list3 = list0; [EOL]         delegateBooleanAssertion(types, 0, 3, true); [EOL]         list0 = list3; [EOL]         delegateBooleanAssertion(types, 3, 0, true); [EOL]         list4 = list0; [EOL]         delegateBooleanAssertion(types, 0, 4, true); [EOL]         list0 = list4; [EOL]         delegateBooleanAssertion(types, 4, 0, true); [EOL]         list5 = list0; [EOL]         delegateBooleanAssertion(types, 0, 5, true); [EOL]         list0 = list5; [EOL]         delegateBooleanAssertion(types, 5, 0, true); [EOL]         list6 = list0; [EOL]         delegateBooleanAssertion(types, 0, 6, true); [EOL]         list0 = list6; [EOL]         delegateBooleanAssertion(types, 6, 0, true); [EOL] //        list1 = list1; [EOL]         delegateBooleanAssertion(types, 1, 1, true); [EOL]         list2 = list1; [EOL]         delegateBooleanAssertion(types, 1, 2, true); [EOL]         list1 = (List<Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 1, false); [EOL]         list3 = list1; [EOL]         delegateBooleanAssertion(types, 1, 3, true); [EOL]         list1 = (List<Object>) list3; [EOL]         delegateBooleanAssertion(types, 3, 1, false); [EOL]         // list4 = list1; [EOL]         delegateBooleanAssertion(types, 1, 4, false); [EOL]         // list1 = list4; [EOL]         delegateBooleanAssertion(types, 4, 1, false); [EOL]         // list5 = list1; [EOL]         delegateBooleanAssertion(types, 1, 5, false); [EOL]         // list1 = list5; [EOL]         delegateBooleanAssertion(types, 5, 1, false); [EOL]         list6 = list1; [EOL]         delegateBooleanAssertion(types, 1, 6, true); [EOL]         list1 = (List<Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 1, false); [EOL] //        list2 = list2; [EOL]         delegateBooleanAssertion(types, 2, 2, true); [EOL]         list2 = list3; [EOL]         delegateBooleanAssertion(types, 2, 3, false); [EOL]         list2 = list4; [EOL]         delegateBooleanAssertion(types, 3, 2, true); [EOL]         list3 = (List<? super Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 4, false); [EOL]         list2 = list5; [EOL]         delegateBooleanAssertion(types, 4, 2, true); [EOL]         list4 = (List<String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 5, false); [EOL]         list2 = list6; [EOL]         delegateBooleanAssertion(types, 5, 2, true); [EOL]         list5 = (List<? extends String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 6, false); [EOL] //        list3 = list3; [EOL]         delegateBooleanAssertion(types, 6, 2, true); [EOL]         list6 = (List<? super String>) list2; [EOL]         delegateBooleanAssertion(types, 3, 3, true); [EOL]         // list4 = list3; [EOL]         delegateBooleanAssertion(types, 3, 4, false); [EOL]         // list3 = list4; [EOL]         delegateBooleanAssertion(types, 4, 3, false); [EOL]         // list5 = list3; [EOL]         delegateBooleanAssertion(types, 3, 5, false); [EOL]         // list3 = list5; [EOL]         delegateBooleanAssertion(types, 5, 3, false); [EOL]         list6 = list3; [EOL]         delegateBooleanAssertion(types, 3, 6, true); [EOL]         list3 = (List<? super Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 3, false); [EOL] //        list4 = list4; [EOL]         delegateBooleanAssertion(types, 4, 4, true); [EOL]         list5 = list4; [EOL]         delegateBooleanAssertion(types, 4, 5, true); [EOL]         list4 = (List<String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 4, false); [EOL]         list6 = list4; [EOL]         delegateBooleanAssertion(types, 4, 6, true); [EOL]         list4 = (List<String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 4, false); [EOL] //        list5 = list5; [EOL]         delegateBooleanAssertion(types, 5, 5, true); [EOL]         list6 = (List<? super String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 6, false); [EOL]         list5 = (List<? extends String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 5, false); [EOL] //        list6 = list6; [EOL]         delegateBooleanAssertion(types, 6, 6, true); [EOL]  [EOL] //        list7 = list7; [EOL]         delegateBooleanAssertion(types, 7, 7, true); [EOL]         list8 = list7; [EOL]         delegateBooleanAssertion(types, 7, 8, true); [EOL]         list7 = list8; [EOL]         delegateBooleanAssertion(types, 8, 7, true); [EOL]         list9 = list7; [EOL]         delegateBooleanAssertion(types, 7, 9, true); [EOL]         list7 = list9; [EOL]         delegateBooleanAssertion(types, 9, 7, true); [EOL]         list10 = list7; [EOL]         delegateBooleanAssertion(types, 7, 10, true); [EOL]         list7 = list10; [EOL]         delegateBooleanAssertion(types, 10, 7, true); [EOL]         list11 = list7; [EOL]         delegateBooleanAssertion(types, 7, 11, true); [EOL]         list7 = list11; [EOL]         delegateBooleanAssertion(types, 11, 7, true); [EOL]         list12 = list7; [EOL]         delegateBooleanAssertion(types, 7, 12, true); [EOL]         list7 = list12; [EOL]         delegateBooleanAssertion(types, 12, 7, true); [EOL]         list13 = list7; [EOL]         delegateBooleanAssertion(types, 7, 13, true); [EOL]         list7 = list13; [EOL]         delegateBooleanAssertion(types, 13, 7, true); [EOL] //        list8 = list8; [EOL]         delegateBooleanAssertion(types, 8, 8, true); [EOL]         list9 = list8; [EOL]         delegateBooleanAssertion(types, 8, 9, true); [EOL]         list8 = (List<Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 8, false); [EOL]         list10 = list8; [EOL]         delegateBooleanAssertion(types, 8, 10, true); [EOL]         list8 = (List<Object>[]) list10; // NOTE cast is required by Sun Java, but not by Eclipse [EOL]         delegateBooleanAssertion(types, 10, 8, false); [EOL]         // list11 = list8; [EOL]         delegateBooleanAssertion(types, 8, 11, false); [EOL]         // list8 = list11; [EOL]         delegateBooleanAssertion(types, 11, 8, false); [EOL]         // list12 = list8; [EOL]         delegateBooleanAssertion(types, 8, 12, false); [EOL]         // list8 = list12; [EOL]         delegateBooleanAssertion(types, 12, 8, false); [EOL]         list13 = list8; [EOL]         delegateBooleanAssertion(types, 8, 13, true); [EOL]         list8 = (List<Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 8, false); [EOL] //        list9 = list9; [EOL]         delegateBooleanAssertion(types, 9, 9, true); [EOL]         list10 = (List<? super Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 10, false); [EOL]         list9 = list10; [EOL]         delegateBooleanAssertion(types, 10, 9, true); [EOL]         list11 = (List<String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 11, false); [EOL]         list9 = list11; [EOL]         delegateBooleanAssertion(types, 11, 9, true); [EOL]         list12 = (List<? extends String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 12, false); [EOL]         list9 = list12; [EOL]         delegateBooleanAssertion(types, 12, 9, true); [EOL]         list13 = (List<? super String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 13, false); [EOL]         list9 = list13; [EOL]         delegateBooleanAssertion(types, 13, 9, true); [EOL] //        list10 = list10; [EOL]         delegateBooleanAssertion(types, 10, 10, true); [EOL]         // list11 = list10; [EOL]         delegateBooleanAssertion(types, 10, 11, false); [EOL]         // list10 = list11; [EOL]         delegateBooleanAssertion(types, 11, 10, false); [EOL]         // list12 = list10; [EOL]         delegateBooleanAssertion(types, 10, 12, false); [EOL]         // list10 = list12; [EOL]         delegateBooleanAssertion(types, 12, 10, false); [EOL]         list13 = list10; [EOL]         delegateBooleanAssertion(types, 10, 13, true); [EOL]         list10 = (List<? super Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 10, false); [EOL] //        list11 = list11; [EOL]         delegateBooleanAssertion(types, 11, 11, true); [EOL]         list12 = list11; [EOL]         delegateBooleanAssertion(types, 11, 12, true); [EOL]         list11 = (List<String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 11, false); [EOL]         list13 = list11; [EOL]         delegateBooleanAssertion(types, 11, 13, true); [EOL]         list11 = (List<String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 11, false); [EOL] //        list12 = list12; [EOL]         delegateBooleanAssertion(types, 12, 12, true); [EOL]         list13 = (List<? super String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 13, false); [EOL]         list12 = (List<? extends String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 12, false); [EOL] //        list13 = list13; [EOL]         delegateBooleanAssertion(types, 13, 13, true); [EOL]         final Type disType = getClass().getField("dis").getGenericType(); [EOL]         // Reporter.log( ( ( ParameterizedType ) disType [EOL]         // ).getOwnerType().getClass().toString() ); [EOL]         final Type datType = getClass().getField("dat").getGenericType(); [EOL]         final Type daType = getClass().getField("da").getGenericType(); [EOL]         final Type uhderType = getClass().getField("uhder").getGenericType(); [EOL]         final Type dingType = getClass().getField("ding").getGenericType(); [EOL]         final Type testerType = getClass().getField("tester").getGenericType(); [EOL]         final Type tester2Type = getClass().getField("tester2").getGenericType(); [EOL]         final Type dat2Type = getClass().getField("dat2").getGenericType(); [EOL]         final Type dat3Type = getClass().getField("dat3").getGenericType(); [EOL]         dis = dat; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(datType, disType)); [EOL]         // dis = da; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(daType, disType)); [EOL]         dis = uhder; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(uhderType, disType)); [EOL]         dis = ding; [EOL]         Assert.assertFalse(String.format("type %s not assignable to %s!", dingType, disType), [EOL]                 TypeUtils.isAssignable(dingType, disType)); [EOL]         dis = tester; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(testerType, disType)); [EOL]         // dis = tester2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(tester2Type, disType)); [EOL]         // dat = dat2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat2Type, datType)); [EOL]         // dat2 = dat; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(datType, dat2Type)); [EOL]         // dat = dat3; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat3Type, datType)); [EOL]         final char ch = 0; [EOL]         final boolean bo = false; [EOL]         final byte by = 0; [EOL]         final short sh = 0; [EOL]         int in = 0; [EOL]         long lo = 0; [EOL]         final float fl = 0; [EOL]         double du = 0; [EOL]         du = ch; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(char.class, double.class)); [EOL]         du = by; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(byte.class, double.class)); [EOL]         du = sh; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(short.class, double.class)); [EOL]         du = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, double.class)); [EOL]         du = lo; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(long.class, double.class)); [EOL]         du = fl; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(float.class, double.class)); [EOL]         lo = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, long.class)); [EOL]         lo = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, long.class)); [EOL]         // Long lngW = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, Long.class)); [EOL]         // lngW = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, Long.class)); [EOL]         in = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, int.class)); [EOL]         final Integer inte = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Integer.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Number.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Object.class)); [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, intComparableType)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Comparable.class)); [EOL]         final Serializable ser = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Serializable.class)); [EOL]         final Type longComparableType = getClass().getField("longComparable").getGenericType(); [EOL]         // longComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, longComparableType)); [EOL]         // longComparable = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, longComparableType)); [EOL]         // int[] ia; [EOL]         // long[] la = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, long[].class)); [EOL]         final Integer[] ia = null; [EOL]         final Type caType = getClass().getField("intWildcardComparable").getGenericType(); [EOL]         intWildcardComparable = ia; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, caType)); [EOL]         // int[] ina = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer[].class, int[].class)); [EOL]         final int[] ina = null; [EOL]         Object[] oa; [EOL]         // oa = ina; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, Object[].class)); [EOL]         oa = new Integer[0]; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, Object[].class)); [EOL]         final Type bClassType = AClass.class.getField("bClass").getGenericType(); [EOL]         final Type cClassType = AClass.class.getField("cClass").getGenericType(); [EOL]         final Type dClassType = AClass.class.getField("dClass").getGenericType(); [EOL]         final Type eClassType = AClass.class.getField("eClass").getGenericType(); [EOL]         final Type fClassType = AClass.class.getField("fClass").getGenericType(); [EOL]         final AClass aClass = new AClass(new AAClass<String>()); [EOL]         aClass.bClass = aClass.cClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(cClassType, bClassType)); [EOL]         aClass.bClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, bClassType)); [EOL]         aClass.bClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, bClassType)); [EOL]         aClass.bClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, bClassType)); [EOL]         aClass.cClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, cClassType)); [EOL]         aClass.cClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, cClassType)); [EOL]         aClass.cClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, cClassType)); [EOL]         aClass.dClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, dClassType)); [EOL]         aClass.dClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, dClassType)); [EOL]         aClass.eClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, eClassType)); [EOL]     } [EOL]  [EOL]     public void delegateBooleanAssertion(final Type[] types, final int i2, final int i1, final boolean expected) { [EOL]         final Type type1 = types[i1]; [EOL]         final Type type2 = types[i2]; [EOL]         final boolean isAssignable = TypeUtils.isAssignable(type2, type1); [EOL]  [EOL]         if (expected) { [EOL]             Assert.assertTrue("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } else { [EOL]             Assert.assertFalse("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } [EOL]     } [EOL]  [EOL]     @SuppressWarnings("boxing") // boxing is deliberate here [EOL]
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [EOL]         final Type[] types = method.getGenericParameterTypes(); [EOL] //        list0 = list0; [EOL]         delegateBooleanAssertion(types, 0, 0, true); [EOL]         list1 = list0; [EOL]         delegateBooleanAssertion(types, 0, 1, true); [EOL]         list0 = list1; [EOL]         delegateBooleanAssertion(types, 1, 0, true); [EOL]         list2 = list0; [EOL]         delegateBooleanAssertion(types, 0, 2, true); [EOL]         list0 = list2; [EOL]         delegateBooleanAssertion(types, 2, 0, true); [EOL]         list3 = list0; [EOL]         delegateBooleanAssertion(types, 0, 3, true); [EOL]         list0 = list3; [EOL]         delegateBooleanAssertion(types, 3, 0, true); [EOL]         list4 = list0; [EOL]         delegateBooleanAssertion(types, 0, 4, true); [EOL]         list0 = list4; [EOL]         delegateBooleanAssertion(types, 4, 0, true); [EOL]         list5 = list0; [EOL]         delegateBooleanAssertion(types, 0, 5, true); [EOL]         list0 = list5; [EOL]         delegateBooleanAssertion(types, 5, 0, true); [EOL]         list6 = list0; [EOL]         delegateBooleanAssertion(types, 0, 6, true); [EOL]         list0 = list6; [EOL]         delegateBooleanAssertion(types, 6, 0, true); [EOL] //        list1 = list1; [EOL]         delegateBooleanAssertion(types, 1, 1, true); [EOL]         list2 = list1; [EOL]         delegateBooleanAssertion(types, 1, 2, true); [EOL]         list1 = (List<Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 1, false); [EOL]         list3 = list1; [EOL]         delegateBooleanAssertion(types, 1, 3, true); [EOL]         list1 = (List<Object>) list3; [EOL]         delegateBooleanAssertion(types, 3, 1, false); [EOL]         // list4 = list1; [EOL]         delegateBooleanAssertion(types, 1, 4, false); [EOL]         // list1 = list4; [EOL]         delegateBooleanAssertion(types, 4, 1, false); [EOL]         // list5 = list1; [EOL]         delegateBooleanAssertion(types, 1, 5, false); [EOL]         // list1 = list5; [EOL]         delegateBooleanAssertion(types, 5, 1, false); [EOL]         list6 = list1; [EOL]         delegateBooleanAssertion(types, 1, 6, true); [EOL]         list1 = (List<Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 1, false); [EOL] //        list2 = list2; [EOL]         delegateBooleanAssertion(types, 2, 2, true); [EOL]         list2 = list3; [EOL]         delegateBooleanAssertion(types, 2, 3, false); [EOL]         list2 = list4; [EOL]         delegateBooleanAssertion(types, 3, 2, true); [EOL]         list3 = (List<? super Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 4, false); [EOL]         list2 = list5; [EOL]         delegateBooleanAssertion(types, 4, 2, true); [EOL]         list4 = (List<String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 5, false); [EOL]         list2 = list6; [EOL]         delegateBooleanAssertion(types, 5, 2, true); [EOL]         list5 = (List<? extends String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 6, false); [EOL] //        list3 = list3; [EOL]         delegateBooleanAssertion(types, 6, 2, true); [EOL]         list6 = (List<? super String>) list2; [EOL]         delegateBooleanAssertion(types, 3, 3, true); [EOL]         // list4 = list3; [EOL]         delegateBooleanAssertion(types, 3, 4, false); [EOL]         // list3 = list4; [EOL]         delegateBooleanAssertion(types, 4, 3, false); [EOL]         // list5 = list3; [EOL]         delegateBooleanAssertion(types, 3, 5, false); [EOL]         // list3 = list5; [EOL]         delegateBooleanAssertion(types, 5, 3, false); [EOL]         list6 = list3; [EOL]         delegateBooleanAssertion(types, 3, 6, true); [EOL]         list3 = (List<? super Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 3, false); [EOL] //        list4 = list4; [EOL]         delegateBooleanAssertion(types, 4, 4, true); [EOL]         list5 = list4; [EOL]         delegateBooleanAssertion(types, 4, 5, true); [EOL]         list4 = (List<String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 4, false); [EOL]         list6 = list4; [EOL]         delegateBooleanAssertion(types, 4, 6, true); [EOL]         list4 = (List<String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 4, false); [EOL] //        list5 = list5; [EOL]         delegateBooleanAssertion(types, 5, 5, true); [EOL]         list6 = (List<? super String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 6, false); [EOL]         list5 = (List<? extends String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 5, false); [EOL] //        list6 = list6; [EOL]         delegateBooleanAssertion(types, 6, 6, true); [EOL]  [EOL] //        list7 = list7; [EOL]         delegateBooleanAssertion(types, 7, 7, true); [EOL]         list8 = list7; [EOL]         delegateBooleanAssertion(types, 7, 8, true); [EOL]         list7 = list8; [EOL]         delegateBooleanAssertion(types, 8, 7, true); [EOL]         list9 = list7; [EOL]         delegateBooleanAssertion(types, 7, 9, true); [EOL]         list7 = list9; [EOL]         delegateBooleanAssertion(types, 9, 7, true); [EOL]         list10 = list7; [EOL]         delegateBooleanAssertion(types, 7, 10, true); [EOL]         list7 = list10; [EOL]         delegateBooleanAssertion(types, 10, 7, true); [EOL]         list11 = list7; [EOL]         delegateBooleanAssertion(types, 7, 11, true); [EOL]         list7 = list11; [EOL]         delegateBooleanAssertion(types, 11, 7, true); [EOL]         list12 = list7; [EOL]         delegateBooleanAssertion(types, 7, 12, true); [EOL]         list7 = list12; [EOL]         delegateBooleanAssertion(types, 12, 7, true); [EOL]         list13 = list7; [EOL]         delegateBooleanAssertion(types, 7, 13, true); [EOL]         list7 = list13; [EOL]         delegateBooleanAssertion(types, 13, 7, true); [EOL] //        list8 = list8; [EOL]         delegateBooleanAssertion(types, 8, 8, true); [EOL]         list9 = list8; [EOL]         delegateBooleanAssertion(types, 8, 9, true); [EOL]         list8 = (List<Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 8, false); [EOL]         list10 = list8; [EOL]         delegateBooleanAssertion(types, 8, 10, true); [EOL]         list8 = (List<Object>[]) list10; // NOTE cast is required by Sun Java, but not by Eclipse [EOL]         delegateBooleanAssertion(types, 10, 8, false); [EOL]         // list11 = list8; [EOL]         delegateBooleanAssertion(types, 8, 11, false); [EOL]         // list8 = list11; [EOL]         delegateBooleanAssertion(types, 11, 8, false); [EOL]         // list12 = list8; [EOL]         delegateBooleanAssertion(types, 8, 12, false); [EOL]         // list8 = list12; [EOL]         delegateBooleanAssertion(types, 12, 8, false); [EOL]         list13 = list8; [EOL]         delegateBooleanAssertion(types, 8, 13, true); [EOL]         list8 = (List<Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 8, false); [EOL] //        list9 = list9; [EOL]         delegateBooleanAssertion(types, 9, 9, true); [EOL]         list10 = (List<? super Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 10, false); [EOL]         list9 = list10; [EOL]         delegateBooleanAssertion(types, 10, 9, true); [EOL]         list11 = (List<String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 11, false); [EOL]         list9 = list11; [EOL]         delegateBooleanAssertion(types, 11, 9, true); [EOL]         list12 = (List<? extends String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 12, false); [EOL]         list9 = list12; [EOL]         delegateBooleanAssertion(types, 12, 9, true); [EOL]         list13 = (List<? super String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 13, false); [EOL]         list9 = list13; [EOL]         delegateBooleanAssertion(types, 13, 9, true); [EOL] //        list10 = list10; [EOL]         delegateBooleanAssertion(types, 10, 10, true); [EOL]         // list11 = list10; [EOL]         delegateBooleanAssertion(types, 10, 11, false); [EOL]         // list10 = list11; [EOL]         delegateBooleanAssertion(types, 11, 10, false); [EOL]         // list12 = list10; [EOL]         delegateBooleanAssertion(types, 10, 12, false); [EOL]         // list10 = list12; [EOL]         delegateBooleanAssertion(types, 12, 10, false); [EOL]         list13 = list10; [EOL]         delegateBooleanAssertion(types, 10, 13, true); [EOL]         list10 = (List<? super Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 10, false); [EOL] //        list11 = list11; [EOL]         delegateBooleanAssertion(types, 11, 11, true); [EOL]         list12 = list11; [EOL]         delegateBooleanAssertion(types, 11, 12, true); [EOL]         list11 = (List<String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 11, false); [EOL]         list13 = list11; [EOL]         delegateBooleanAssertion(types, 11, 13, true); [EOL]         list11 = (List<String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 11, false); [EOL] //        list12 = list12; [EOL]         delegateBooleanAssertion(types, 12, 12, true); [EOL]         list13 = (List<? super String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 13, false); [EOL]         list12 = (List<? extends String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 12, false); [EOL] //        list13 = list13; [EOL]         delegateBooleanAssertion(types, 13, 13, true); [EOL]         final Type disType = getClass().getField("dis").getGenericType(); [EOL]         // Reporter.log( ( ( ParameterizedType ) disType [EOL]         // ).getOwnerType().getClass().toString() ); [EOL]         final Type datType = getClass().getField("dat").getGenericType(); [EOL]         final Type daType = getClass().getField("da").getGenericType(); [EOL]         final Type uhderType = getClass().getField("uhder").getGenericType(); [EOL]         final Type dingType = getClass().getField("ding").getGenericType(); [EOL]         final Type testerType = getClass().getField("tester").getGenericType(); [EOL]         final Type tester2Type = getClass().getField("tester2").getGenericType(); [EOL]         final Type dat2Type = getClass().getField("dat2").getGenericType(); [EOL]         final Type dat3Type = getClass().getField("dat3").getGenericType(); [EOL]         dis = dat; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(datType, disType)); [EOL]         // dis = da; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(daType, disType)); [EOL]         dis = uhder; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(uhderType, disType)); [EOL]         dis = ding; [EOL]         Assert.assertFalse(String.format("type %s not assignable to %s!", dingType, disType), [EOL]                 TypeUtils.isAssignable(dingType, disType)); [EOL]         dis = tester; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(testerType, disType)); [EOL]         // dis = tester2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(tester2Type, disType)); [EOL]         // dat = dat2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat2Type, datType)); [EOL]         // dat2 = dat; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(datType, dat2Type)); [EOL]         // dat = dat3; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat3Type, datType)); [EOL]         final char ch = 0; [EOL]         final boolean bo = false; [EOL]         final byte by = 0; [EOL]         final short sh = 0; [EOL]         int in = 0; [EOL]         long lo = 0; [EOL]         final float fl = 0; [EOL]         double du = 0; [EOL]         du = ch; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(char.class, double.class)); [EOL]         du = by; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(byte.class, double.class)); [EOL]         du = sh; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(short.class, double.class)); [EOL]         du = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, double.class)); [EOL]         du = lo; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(long.class, double.class)); [EOL]         du = fl; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(float.class, double.class)); [EOL]         lo = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, long.class)); [EOL]         lo = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, long.class)); [EOL]         // Long lngW = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, Long.class)); [EOL]         // lngW = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, Long.class)); [EOL]         in = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, int.class)); [EOL]         final Integer inte = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Integer.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Number.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Object.class)); [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, intComparableType)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Comparable.class)); [EOL]         final Serializable ser = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Serializable.class)); [EOL]         final Type longComparableType = getClass().getField("longComparable").getGenericType(); [EOL]         // longComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, longComparableType)); [EOL]         // longComparable = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, longComparableType)); [EOL]         // int[] ia; [EOL]         // long[] la = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, long[].class)); [EOL]         final Integer[] ia = null; [EOL]         final Type caType = getClass().getField("intWildcardComparable").getGenericType(); [EOL]         intWildcardComparable = ia; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, caType)); [EOL]         // int[] ina = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer[].class, int[].class)); [EOL]         final int[] ina = null; [EOL]         Object[] oa; [EOL]         // oa = ina; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, Object[].class)); [EOL]         oa = new Integer[0]; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, Object[].class)); [EOL]         final Type bClassType = AClass.class.getField("bClass").getGenericType(); [EOL]         final Type cClassType = AClass.class.getField("cClass").getGenericType(); [EOL]         final Type dClassType = AClass.class.getField("dClass").getGenericType(); [EOL]         final Type eClassType = AClass.class.getField("eClass").getGenericType(); [EOL]         final Type fClassType = AClass.class.getField("fClass").getGenericType(); [EOL]         final AClass aClass = new AClass(new AAClass<String>()); [EOL]         aClass.bClass = aClass.cClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(cClassType, bClassType)); [EOL]         aClass.bClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, bClassType)); [EOL]         aClass.bClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, bClassType)); [EOL]         aClass.bClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, bClassType)); [EOL]         aClass.cClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, cClassType)); [EOL]         aClass.cClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, cClassType)); [EOL]         aClass.cClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, cClassType)); [EOL]         aClass.dClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, dClassType)); [EOL]         aClass.dClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, dClassType)); [EOL]         aClass.eClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, eClassType)); [EOL]     } [EOL]  [EOL]     public void delegateBooleanAssertion(final Type[] types, final int i2, final int i1, final boolean expected) { [EOL]         final Type type1 = types[i1]; [EOL]         final Type type2 = types[i2]; [EOL]         final boolean isAssignable = TypeUtils.isAssignable(type2, type1); [EOL]  [EOL]         if (expected) { [EOL]             Assert.assertTrue("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } else { [EOL]             Assert.assertFalse("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } [EOL]     } [EOL]  [EOL]     @SuppressWarnings("boxing") // boxing is deliberate here [EOL]
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [EOL]         final Type[] types = method.getGenericParameterTypes(); [EOL] //        list0 = list0; [EOL]         delegateBooleanAssertion(types, 0, 0, true); [EOL]         list1 = list0; [EOL]         delegateBooleanAssertion(types, 0, 1, true); [EOL]         list0 = list1; [EOL]         delegateBooleanAssertion(types, 1, 0, true); [EOL]         list2 = list0; [EOL]         delegateBooleanAssertion(types, 0, 2, true); [EOL]         list0 = list2; [EOL]         delegateBooleanAssertion(types, 2, 0, true); [EOL]         list3 = list0; [EOL]         delegateBooleanAssertion(types, 0, 3, true); [EOL]         list0 = list3; [EOL]         delegateBooleanAssertion(types, 3, 0, true); [EOL]         list4 = list0; [EOL]         delegateBooleanAssertion(types, 0, 4, true); [EOL]         list0 = list4; [EOL]         delegateBooleanAssertion(types, 4, 0, true); [EOL]         list5 = list0; [EOL]         delegateBooleanAssertion(types, 0, 5, true); [EOL]         list0 = list5; [EOL]         delegateBooleanAssertion(types, 5, 0, true); [EOL]         list6 = list0; [EOL]         delegateBooleanAssertion(types, 0, 6, true); [EOL]         list0 = list6; [EOL]         delegateBooleanAssertion(types, 6, 0, true); [EOL] //        list1 = list1; [EOL]         delegateBooleanAssertion(types, 1, 1, true); [EOL]         list2 = list1; [EOL]         delegateBooleanAssertion(types, 1, 2, true); [EOL]         list1 = (List<Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 1, false); [EOL]         list3 = list1; [EOL]         delegateBooleanAssertion(types, 1, 3, true); [EOL]         list1 = (List<Object>) list3; [EOL]         delegateBooleanAssertion(types, 3, 1, false); [EOL]         // list4 = list1; [EOL]         delegateBooleanAssertion(types, 1, 4, false); [EOL]         // list1 = list4; [EOL]         delegateBooleanAssertion(types, 4, 1, false); [EOL]         // list5 = list1; [EOL]         delegateBooleanAssertion(types, 1, 5, false); [EOL]         // list1 = list5; [EOL]         delegateBooleanAssertion(types, 5, 1, false); [EOL]         list6 = list1; [EOL]         delegateBooleanAssertion(types, 1, 6, true); [EOL]         list1 = (List<Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 1, false); [EOL] //        list2 = list2; [EOL]         delegateBooleanAssertion(types, 2, 2, true); [EOL]         list2 = list3; [EOL]         delegateBooleanAssertion(types, 2, 3, false); [EOL]         list2 = list4; [EOL]         delegateBooleanAssertion(types, 3, 2, true); [EOL]         list3 = (List<? super Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 4, false); [EOL]         list2 = list5; [EOL]         delegateBooleanAssertion(types, 4, 2, true); [EOL]         list4 = (List<String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 5, false); [EOL]         list2 = list6; [EOL]         delegateBooleanAssertion(types, 5, 2, true); [EOL]         list5 = (List<? extends String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 6, false); [EOL] //        list3 = list3; [EOL]         delegateBooleanAssertion(types, 6, 2, true); [EOL]         list6 = (List<? super String>) list2; [EOL]         delegateBooleanAssertion(types, 3, 3, true); [EOL]         // list4 = list3; [EOL]         delegateBooleanAssertion(types, 3, 4, false); [EOL]         // list3 = list4; [EOL]         delegateBooleanAssertion(types, 4, 3, false); [EOL]         // list5 = list3; [EOL]         delegateBooleanAssertion(types, 3, 5, false); [EOL]         // list3 = list5; [EOL]         delegateBooleanAssertion(types, 5, 3, false); [EOL]         list6 = list3; [EOL]         delegateBooleanAssertion(types, 3, 6, true); [EOL]         list3 = (List<? super Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 3, false); [EOL] //        list4 = list4; [EOL]         delegateBooleanAssertion(types, 4, 4, true); [EOL]         list5 = list4; [EOL]         delegateBooleanAssertion(types, 4, 5, true); [EOL]         list4 = (List<String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 4, false); [EOL]         list6 = list4; [EOL]         delegateBooleanAssertion(types, 4, 6, true); [EOL]         list4 = (List<String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 4, false); [EOL] //        list5 = list5; [EOL]         delegateBooleanAssertion(types, 5, 5, true); [EOL]         list6 = (List<? super String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 6, false); [EOL]         list5 = (List<? extends String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 5, false); [EOL] //        list6 = list6; [EOL]         delegateBooleanAssertion(types, 6, 6, true); [EOL]  [EOL] //        list7 = list7; [EOL]         delegateBooleanAssertion(types, 7, 7, true); [EOL]         list8 = list7; [EOL]         delegateBooleanAssertion(types, 7, 8, true); [EOL]         list7 = list8; [EOL]         delegateBooleanAssertion(types, 8, 7, true); [EOL]         list9 = list7; [EOL]         delegateBooleanAssertion(types, 7, 9, true); [EOL]         list7 = list9; [EOL]         delegateBooleanAssertion(types, 9, 7, true); [EOL]         list10 = list7; [EOL]         delegateBooleanAssertion(types, 7, 10, true); [EOL]         list7 = list10; [EOL]         delegateBooleanAssertion(types, 10, 7, true); [EOL]         list11 = list7; [EOL]         delegateBooleanAssertion(types, 7, 11, true); [EOL]         list7 = list11; [EOL]         delegateBooleanAssertion(types, 11, 7, true); [EOL]         list12 = list7; [EOL]         delegateBooleanAssertion(types, 7, 12, true); [EOL]         list7 = list12; [EOL]         delegateBooleanAssertion(types, 12, 7, true); [EOL]         list13 = list7; [EOL]         delegateBooleanAssertion(types, 7, 13, true); [EOL]         list7 = list13; [EOL]         delegateBooleanAssertion(types, 13, 7, true); [EOL] //        list8 = list8; [EOL]         delegateBooleanAssertion(types, 8, 8, true); [EOL]         list9 = list8; [EOL]         delegateBooleanAssertion(types, 8, 9, true); [EOL]         list8 = (List<Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 8, false); [EOL]         list10 = list8; [EOL]         delegateBooleanAssertion(types, 8, 10, true); [EOL]         list8 = (List<Object>[]) list10; // NOTE cast is required by Sun Java, but not by Eclipse [EOL]         delegateBooleanAssertion(types, 10, 8, false); [EOL]         // list11 = list8; [EOL]         delegateBooleanAssertion(types, 8, 11, false); [EOL]         // list8 = list11; [EOL]         delegateBooleanAssertion(types, 11, 8, false); [EOL]         // list12 = list8; [EOL]         delegateBooleanAssertion(types, 8, 12, false); [EOL]         // list8 = list12; [EOL]         delegateBooleanAssertion(types, 12, 8, false); [EOL]         list13 = list8; [EOL]         delegateBooleanAssertion(types, 8, 13, true); [EOL]         list8 = (List<Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 8, false); [EOL] //        list9 = list9; [EOL]         delegateBooleanAssertion(types, 9, 9, true); [EOL]         list10 = (List<? super Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 10, false); [EOL]         list9 = list10; [EOL]         delegateBooleanAssertion(types, 10, 9, true); [EOL]         list11 = (List<String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 11, false); [EOL]         list9 = list11; [EOL]         delegateBooleanAssertion(types, 11, 9, true); [EOL]         list12 = (List<? extends String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 12, false); [EOL]         list9 = list12; [EOL]         delegateBooleanAssertion(types, 12, 9, true); [EOL]         list13 = (List<? super String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 13, false); [EOL]         list9 = list13; [EOL]         delegateBooleanAssertion(types, 13, 9, true); [EOL] //        list10 = list10; [EOL]         delegateBooleanAssertion(types, 10, 10, true); [EOL]         // list11 = list10; [EOL]         delegateBooleanAssertion(types, 10, 11, false); [EOL]         // list10 = list11; [EOL]         delegateBooleanAssertion(types, 11, 10, false); [EOL]         // list12 = list10; [EOL]         delegateBooleanAssertion(types, 10, 12, false); [EOL]         // list10 = list12; [EOL]         delegateBooleanAssertion(types, 12, 10, false); [EOL]         list13 = list10; [EOL]         delegateBooleanAssertion(types, 10, 13, true); [EOL]         list10 = (List<? super Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 10, false); [EOL] //        list11 = list11; [EOL]         delegateBooleanAssertion(types, 11, 11, true); [EOL]         list12 = list11; [EOL]         delegateBooleanAssertion(types, 11, 12, true); [EOL]         list11 = (List<String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 11, false); [EOL]         list13 = list11; [EOL]         delegateBooleanAssertion(types, 11, 13, true); [EOL]         list11 = (List<String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 11, false); [EOL] //        list12 = list12; [EOL]         delegateBooleanAssertion(types, 12, 12, true); [EOL]         list13 = (List<? super String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 13, false); [EOL]         list12 = (List<? extends String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 12, false); [EOL] //        list13 = list13; [EOL]         delegateBooleanAssertion(types, 13, 13, true); [EOL]         final Type disType = getClass().getField("dis").getGenericType(); [EOL]         // Reporter.log( ( ( ParameterizedType ) disType [EOL]         // ).getOwnerType().getClass().toString() ); [EOL]         final Type datType = getClass().getField("dat").getGenericType(); [EOL]         final Type daType = getClass().getField("da").getGenericType(); [EOL]         final Type uhderType = getClass().getField("uhder").getGenericType(); [EOL]         final Type dingType = getClass().getField("ding").getGenericType(); [EOL]         final Type testerType = getClass().getField("tester").getGenericType(); [EOL]         final Type tester2Type = getClass().getField("tester2").getGenericType(); [EOL]         final Type dat2Type = getClass().getField("dat2").getGenericType(); [EOL]         final Type dat3Type = getClass().getField("dat3").getGenericType(); [EOL]         dis = dat; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(datType, disType)); [EOL]         // dis = da; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(daType, disType)); [EOL]         dis = uhder; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(uhderType, disType)); [EOL]         dis = ding; [EOL]         Assert.assertFalse(String.format("type %s not assignable to %s!", dingType, disType), [EOL]                 TypeUtils.isAssignable(dingType, disType)); [EOL]         dis = tester; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(testerType, disType)); [EOL]         // dis = tester2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(tester2Type, disType)); [EOL]         // dat = dat2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat2Type, datType)); [EOL]         // dat2 = dat; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(datType, dat2Type)); [EOL]         // dat = dat3; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat3Type, datType)); [EOL]         final char ch = 0; [EOL]         final boolean bo = false; [EOL]         final byte by = 0; [EOL]         final short sh = 0; [EOL]         int in = 0; [EOL]         long lo = 0; [EOL]         final float fl = 0; [EOL]         double du = 0; [EOL]         du = ch; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(char.class, double.class)); [EOL]         du = by; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(byte.class, double.class)); [EOL]         du = sh; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(short.class, double.class)); [EOL]         du = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, double.class)); [EOL]         du = lo; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(long.class, double.class)); [EOL]         du = fl; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(float.class, double.class)); [EOL]         lo = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, long.class)); [EOL]         lo = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, long.class)); [EOL]         // Long lngW = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, Long.class)); [EOL]         // lngW = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, Long.class)); [EOL]         in = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, int.class)); [EOL]         final Integer inte = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Integer.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Number.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Object.class)); [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, intComparableType)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Comparable.class)); [EOL]         final Serializable ser = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Serializable.class)); [EOL]         final Type longComparableType = getClass().getField("longComparable").getGenericType(); [EOL]         // longComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, longComparableType)); [EOL]         // longComparable = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, longComparableType)); [EOL]         // int[] ia; [EOL]         // long[] la = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, long[].class)); [EOL]         final Integer[] ia = null; [EOL]         final Type caType = getClass().getField("intWildcardComparable").getGenericType(); [EOL]         intWildcardComparable = ia; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, caType)); [EOL]         // int[] ina = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer[].class, int[].class)); [EOL]         final int[] ina = null; [EOL]         Object[] oa; [EOL]         // oa = ina; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, Object[].class)); [EOL]         oa = new Integer[0]; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, Object[].class)); [EOL]         final Type bClassType = AClass.class.getField("bClass").getGenericType(); [EOL]         final Type cClassType = AClass.class.getField("cClass").getGenericType(); [EOL]         final Type dClassType = AClass.class.getField("dClass").getGenericType(); [EOL]         final Type eClassType = AClass.class.getField("eClass").getGenericType(); [EOL]         final Type fClassType = AClass.class.getField("fClass").getGenericType(); [EOL]         final AClass aClass = new AClass(new AAClass<String>()); [EOL]         aClass.bClass = aClass.cClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(cClassType, bClassType)); [EOL]         aClass.bClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, bClassType)); [EOL]         aClass.bClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, bClassType)); [EOL]         aClass.bClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, bClassType)); [EOL]         aClass.cClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, cClassType)); [EOL]         aClass.cClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, cClassType)); [EOL]         aClass.cClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, cClassType)); [EOL]         aClass.dClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, dClassType)); [EOL]         aClass.dClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, dClassType)); [EOL]         aClass.eClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, eClassType)); [EOL]     } [EOL]  [EOL]     public void delegateBooleanAssertion(final Type[] types, final int i2, final int i1, final boolean expected) { [EOL]         final Type type1 = types[i1]; [EOL]         final Type type2 = types[i2]; [EOL]         final boolean isAssignable = TypeUtils.isAssignable(type2, type1); [EOL]  [EOL]         if (expected) { [EOL]             Assert.assertTrue("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } else { [EOL]             Assert.assertFalse("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } [EOL]     } [EOL]  [EOL]     @SuppressWarnings("boxing") // boxing is deliberate here [EOL]
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [EOL]         final Type[] types = method.getGenericParameterTypes(); [EOL] //        list0 = list0; [EOL]         delegateBooleanAssertion(types, 0, 0, true); [EOL]         list1 = list0; [EOL]         delegateBooleanAssertion(types, 0, 1, true); [EOL]         list0 = list1; [EOL]         delegateBooleanAssertion(types, 1, 0, true); [EOL]         list2 = list0; [EOL]         delegateBooleanAssertion(types, 0, 2, true); [EOL]         list0 = list2; [EOL]         delegateBooleanAssertion(types, 2, 0, true); [EOL]         list3 = list0; [EOL]         delegateBooleanAssertion(types, 0, 3, true); [EOL]         list0 = list3; [EOL]         delegateBooleanAssertion(types, 3, 0, true); [EOL]         list4 = list0; [EOL]         delegateBooleanAssertion(types, 0, 4, true); [EOL]         list0 = list4; [EOL]         delegateBooleanAssertion(types, 4, 0, true); [EOL]         list5 = list0; [EOL]         delegateBooleanAssertion(types, 0, 5, true); [EOL]         list0 = list5; [EOL]         delegateBooleanAssertion(types, 5, 0, true); [EOL]         list6 = list0; [EOL]         delegateBooleanAssertion(types, 0, 6, true); [EOL]         list0 = list6; [EOL]         delegateBooleanAssertion(types, 6, 0, true); [EOL] //        list1 = list1; [EOL]         delegateBooleanAssertion(types, 1, 1, true); [EOL]         list2 = list1; [EOL]         delegateBooleanAssertion(types, 1, 2, true); [EOL]         list1 = (List<Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 1, false); [EOL]         list3 = list1; [EOL]         delegateBooleanAssertion(types, 1, 3, true); [EOL]         list1 = (List<Object>) list3; [EOL]         delegateBooleanAssertion(types, 3, 1, false); [EOL]         // list4 = list1; [EOL]         delegateBooleanAssertion(types, 1, 4, false); [EOL]         // list1 = list4; [EOL]         delegateBooleanAssertion(types, 4, 1, false); [EOL]         // list5 = list1; [EOL]         delegateBooleanAssertion(types, 1, 5, false); [EOL]         // list1 = list5; [EOL]         delegateBooleanAssertion(types, 5, 1, false); [EOL]         list6 = list1; [EOL]         delegateBooleanAssertion(types, 1, 6, true); [EOL]         list1 = (List<Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 1, false); [EOL] //        list2 = list2; [EOL]         delegateBooleanAssertion(types, 2, 2, true); [EOL]         list2 = list3; [EOL]         delegateBooleanAssertion(types, 2, 3, false); [EOL]         list2 = list4; [EOL]         delegateBooleanAssertion(types, 3, 2, true); [EOL]         list3 = (List<? super Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 4, false); [EOL]         list2 = list5; [EOL]         delegateBooleanAssertion(types, 4, 2, true); [EOL]         list4 = (List<String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 5, false); [EOL]         list2 = list6; [EOL]         delegateBooleanAssertion(types, 5, 2, true); [EOL]         list5 = (List<? extends String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 6, false); [EOL] //        list3 = list3; [EOL]         delegateBooleanAssertion(types, 6, 2, true); [EOL]         list6 = (List<? super String>) list2; [EOL]         delegateBooleanAssertion(types, 3, 3, true); [EOL]         // list4 = list3; [EOL]         delegateBooleanAssertion(types, 3, 4, false); [EOL]         // list3 = list4; [EOL]         delegateBooleanAssertion(types, 4, 3, false); [EOL]         // list5 = list3; [EOL]         delegateBooleanAssertion(types, 3, 5, false); [EOL]         // list3 = list5; [EOL]         delegateBooleanAssertion(types, 5, 3, false); [EOL]         list6 = list3; [EOL]         delegateBooleanAssertion(types, 3, 6, true); [EOL]         list3 = (List<? super Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 3, false); [EOL] //        list4 = list4; [EOL]         delegateBooleanAssertion(types, 4, 4, true); [EOL]         list5 = list4; [EOL]         delegateBooleanAssertion(types, 4, 5, true); [EOL]         list4 = (List<String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 4, false); [EOL]         list6 = list4; [EOL]         delegateBooleanAssertion(types, 4, 6, true); [EOL]         list4 = (List<String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 4, false); [EOL] //        list5 = list5; [EOL]         delegateBooleanAssertion(types, 5, 5, true); [EOL]         list6 = (List<? super String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 6, false); [EOL]         list5 = (List<? extends String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 5, false); [EOL] //        list6 = list6; [EOL]         delegateBooleanAssertion(types, 6, 6, true); [EOL]  [EOL] //        list7 = list7; [EOL]         delegateBooleanAssertion(types, 7, 7, true); [EOL]         list8 = list7; [EOL]         delegateBooleanAssertion(types, 7, 8, true); [EOL]         list7 = list8; [EOL]         delegateBooleanAssertion(types, 8, 7, true); [EOL]         list9 = list7; [EOL]         delegateBooleanAssertion(types, 7, 9, true); [EOL]         list7 = list9; [EOL]         delegateBooleanAssertion(types, 9, 7, true); [EOL]         list10 = list7; [EOL]         delegateBooleanAssertion(types, 7, 10, true); [EOL]         list7 = list10; [EOL]         delegateBooleanAssertion(types, 10, 7, true); [EOL]         list11 = list7; [EOL]         delegateBooleanAssertion(types, 7, 11, true); [EOL]         list7 = list11; [EOL]         delegateBooleanAssertion(types, 11, 7, true); [EOL]         list12 = list7; [EOL]         delegateBooleanAssertion(types, 7, 12, true); [EOL]         list7 = list12; [EOL]         delegateBooleanAssertion(types, 12, 7, true); [EOL]         list13 = list7; [EOL]         delegateBooleanAssertion(types, 7, 13, true); [EOL]         list7 = list13; [EOL]         delegateBooleanAssertion(types, 13, 7, true); [EOL] //        list8 = list8; [EOL]         delegateBooleanAssertion(types, 8, 8, true); [EOL]         list9 = list8; [EOL]         delegateBooleanAssertion(types, 8, 9, true); [EOL]         list8 = (List<Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 8, false); [EOL]         list10 = list8; [EOL]         delegateBooleanAssertion(types, 8, 10, true); [EOL]         list8 = (List<Object>[]) list10; // NOTE cast is required by Sun Java, but not by Eclipse [EOL]         delegateBooleanAssertion(types, 10, 8, false); [EOL]         // list11 = list8; [EOL]         delegateBooleanAssertion(types, 8, 11, false); [EOL]         // list8 = list11; [EOL]         delegateBooleanAssertion(types, 11, 8, false); [EOL]         // list12 = list8; [EOL]         delegateBooleanAssertion(types, 8, 12, false); [EOL]         // list8 = list12; [EOL]         delegateBooleanAssertion(types, 12, 8, false); [EOL]         list13 = list8; [EOL]         delegateBooleanAssertion(types, 8, 13, true); [EOL]         list8 = (List<Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 8, false); [EOL] //        list9 = list9; [EOL]         delegateBooleanAssertion(types, 9, 9, true); [EOL]         list10 = (List<? super Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 10, false); [EOL]         list9 = list10; [EOL]         delegateBooleanAssertion(types, 10, 9, true); [EOL]         list11 = (List<String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 11, false); [EOL]         list9 = list11; [EOL]         delegateBooleanAssertion(types, 11, 9, true); [EOL]         list12 = (List<? extends String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 12, false); [EOL]         list9 = list12; [EOL]         delegateBooleanAssertion(types, 12, 9, true); [EOL]         list13 = (List<? super String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 13, false); [EOL]         list9 = list13; [EOL]         delegateBooleanAssertion(types, 13, 9, true); [EOL] //        list10 = list10; [EOL]         delegateBooleanAssertion(types, 10, 10, true); [EOL]         // list11 = list10; [EOL]         delegateBooleanAssertion(types, 10, 11, false); [EOL]         // list10 = list11; [EOL]         delegateBooleanAssertion(types, 11, 10, false); [EOL]         // list12 = list10; [EOL]         delegateBooleanAssertion(types, 10, 12, false); [EOL]         // list10 = list12; [EOL]         delegateBooleanAssertion(types, 12, 10, false); [EOL]         list13 = list10; [EOL]         delegateBooleanAssertion(types, 10, 13, true); [EOL]         list10 = (List<? super Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 10, false); [EOL] //        list11 = list11; [EOL]         delegateBooleanAssertion(types, 11, 11, true); [EOL]         list12 = list11; [EOL]         delegateBooleanAssertion(types, 11, 12, true); [EOL]         list11 = (List<String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 11, false); [EOL]         list13 = list11; [EOL]         delegateBooleanAssertion(types, 11, 13, true); [EOL]         list11 = (List<String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 11, false); [EOL] //        list12 = list12; [EOL]         delegateBooleanAssertion(types, 12, 12, true); [EOL]         list13 = (List<? super String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 13, false); [EOL]         list12 = (List<? extends String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 12, false); [EOL] //        list13 = list13; [EOL]         delegateBooleanAssertion(types, 13, 13, true); [EOL]         final Type disType = getClass().getField("dis").getGenericType(); [EOL]         // Reporter.log( ( ( ParameterizedType ) disType [EOL]         // ).getOwnerType().getClass().toString() ); [EOL]         final Type datType = getClass().getField("dat").getGenericType(); [EOL]         final Type daType = getClass().getField("da").getGenericType(); [EOL]         final Type uhderType = getClass().getField("uhder").getGenericType(); [EOL]         final Type dingType = getClass().getField("ding").getGenericType(); [EOL]         final Type testerType = getClass().getField("tester").getGenericType(); [EOL]         final Type tester2Type = getClass().getField("tester2").getGenericType(); [EOL]         final Type dat2Type = getClass().getField("dat2").getGenericType(); [EOL]         final Type dat3Type = getClass().getField("dat3").getGenericType(); [EOL]         dis = dat; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(datType, disType)); [EOL]         // dis = da; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(daType, disType)); [EOL]         dis = uhder; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(uhderType, disType)); [EOL]         dis = ding; [EOL]         Assert.assertFalse(String.format("type %s not assignable to %s!", dingType, disType), [EOL]                 TypeUtils.isAssignable(dingType, disType)); [EOL]         dis = tester; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(testerType, disType)); [EOL]         // dis = tester2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(tester2Type, disType)); [EOL]         // dat = dat2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat2Type, datType)); [EOL]         // dat2 = dat; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(datType, dat2Type)); [EOL]         // dat = dat3; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat3Type, datType)); [EOL]         final char ch = 0; [EOL]         final boolean bo = false; [EOL]         final byte by = 0; [EOL]         final short sh = 0; [EOL]         int in = 0; [EOL]         long lo = 0; [EOL]         final float fl = 0; [EOL]         double du = 0; [EOL]         du = ch; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(char.class, double.class)); [EOL]         du = by; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(byte.class, double.class)); [EOL]         du = sh; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(short.class, double.class)); [EOL]         du = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, double.class)); [EOL]         du = lo; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(long.class, double.class)); [EOL]         du = fl; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(float.class, double.class)); [EOL]         lo = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, long.class)); [EOL]         lo = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, long.class)); [EOL]         // Long lngW = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, Long.class)); [EOL]         // lngW = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, Long.class)); [EOL]         in = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, int.class)); [EOL]         final Integer inte = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Integer.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Number.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Object.class)); [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, intComparableType)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Comparable.class)); [EOL]         final Serializable ser = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Serializable.class)); [EOL]         final Type longComparableType = getClass().getField("longComparable").getGenericType(); [EOL]         // longComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, longComparableType)); [EOL]         // longComparable = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, longComparableType)); [EOL]         // int[] ia; [EOL]         // long[] la = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, long[].class)); [EOL]         final Integer[] ia = null; [EOL]         final Type caType = getClass().getField("intWildcardComparable").getGenericType(); [EOL]         intWildcardComparable = ia; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, caType)); [EOL]         // int[] ina = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer[].class, int[].class)); [EOL]         final int[] ina = null; [EOL]         Object[] oa; [EOL]         // oa = ina; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, Object[].class)); [EOL]         oa = new Integer[0]; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, Object[].class)); [EOL]         final Type bClassType = AClass.class.getField("bClass").getGenericType(); [EOL]         final Type cClassType = AClass.class.getField("cClass").getGenericType(); [EOL]         final Type dClassType = AClass.class.getField("dClass").getGenericType(); [EOL]         final Type eClassType = AClass.class.getField("eClass").getGenericType(); [EOL]         final Type fClassType = AClass.class.getField("fClass").getGenericType(); [EOL]         final AClass aClass = new AClass(new AAClass<String>()); [EOL]         aClass.bClass = aClass.cClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(cClassType, bClassType)); [EOL]         aClass.bClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, bClassType)); [EOL]         aClass.bClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, bClassType)); [EOL]         aClass.bClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, bClassType)); [EOL]         aClass.cClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, cClassType)); [EOL]         aClass.cClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, cClassType)); [EOL]         aClass.cClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, cClassType)); [EOL]         aClass.dClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, dClassType)); [EOL]         aClass.dClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, dClassType)); [EOL]         aClass.eClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, eClassType)); [EOL]     } [EOL]  [EOL]     public void delegateBooleanAssertion(final Type[] types, final int i2, final int i1, final boolean expected) { [EOL]         final Type type1 = types[i1]; [EOL]         final Type type2 = types[i2]; [EOL]         final boolean isAssignable = TypeUtils.isAssignable(type2, type1); [EOL]  [EOL]         if (expected) { [EOL]             Assert.assertTrue("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } else { [EOL]             Assert.assertFalse("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } [EOL]     } [EOL]  [EOL]     @SuppressWarnings("boxing") // boxing is deliberate here [EOL]
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [EOL]         final Type[] types = method.getGenericParameterTypes(); [EOL] //        list0 = list0; [EOL]         delegateBooleanAssertion(types, 0, 0, true); [EOL]         list1 = list0; [EOL]         delegateBooleanAssertion(types, 0, 1, true); [EOL]         list0 = list1; [EOL]         delegateBooleanAssertion(types, 1, 0, true); [EOL]         list2 = list0; [EOL]         delegateBooleanAssertion(types, 0, 2, true); [EOL]         list0 = list2; [EOL]         delegateBooleanAssertion(types, 2, 0, true); [EOL]         list3 = list0; [EOL]         delegateBooleanAssertion(types, 0, 3, true); [EOL]         list0 = list3; [EOL]         delegateBooleanAssertion(types, 3, 0, true); [EOL]         list4 = list0; [EOL]         delegateBooleanAssertion(types, 0, 4, true); [EOL]         list0 = list4; [EOL]         delegateBooleanAssertion(types, 4, 0, true); [EOL]         list5 = list0; [EOL]         delegateBooleanAssertion(types, 0, 5, true); [EOL]         list0 = list5; [EOL]         delegateBooleanAssertion(types, 5, 0, true); [EOL]         list6 = list0; [EOL]         delegateBooleanAssertion(types, 0, 6, true); [EOL]         list0 = list6; [EOL]         delegateBooleanAssertion(types, 6, 0, true); [EOL] //        list1 = list1; [EOL]         delegateBooleanAssertion(types, 1, 1, true); [EOL]         list2 = list1; [EOL]         delegateBooleanAssertion(types, 1, 2, true); [EOL]         list1 = (List<Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 1, false); [EOL]         list3 = list1; [EOL]         delegateBooleanAssertion(types, 1, 3, true); [EOL]         list1 = (List<Object>) list3; [EOL]         delegateBooleanAssertion(types, 3, 1, false); [EOL]         // list4 = list1; [EOL]         delegateBooleanAssertion(types, 1, 4, false); [EOL]         // list1 = list4; [EOL]         delegateBooleanAssertion(types, 4, 1, false); [EOL]         // list5 = list1; [EOL]         delegateBooleanAssertion(types, 1, 5, false); [EOL]         // list1 = list5; [EOL]         delegateBooleanAssertion(types, 5, 1, false); [EOL]         list6 = list1; [EOL]         delegateBooleanAssertion(types, 1, 6, true); [EOL]         list1 = (List<Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 1, false); [EOL] //        list2 = list2; [EOL]         delegateBooleanAssertion(types, 2, 2, true); [EOL]         list2 = list3; [EOL]         delegateBooleanAssertion(types, 2, 3, false); [EOL]         list2 = list4; [EOL]         delegateBooleanAssertion(types, 3, 2, true); [EOL]         list3 = (List<? super Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 4, false); [EOL]         list2 = list5; [EOL]         delegateBooleanAssertion(types, 4, 2, true); [EOL]         list4 = (List<String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 5, false); [EOL]         list2 = list6; [EOL]         delegateBooleanAssertion(types, 5, 2, true); [EOL]         list5 = (List<? extends String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 6, false); [EOL] //        list3 = list3; [EOL]         delegateBooleanAssertion(types, 6, 2, true); [EOL]         list6 = (List<? super String>) list2; [EOL]         delegateBooleanAssertion(types, 3, 3, true); [EOL]         // list4 = list3; [EOL]         delegateBooleanAssertion(types, 3, 4, false); [EOL]         // list3 = list4; [EOL]         delegateBooleanAssertion(types, 4, 3, false); [EOL]         // list5 = list3; [EOL]         delegateBooleanAssertion(types, 3, 5, false); [EOL]         // list3 = list5; [EOL]         delegateBooleanAssertion(types, 5, 3, false); [EOL]         list6 = list3; [EOL]         delegateBooleanAssertion(types, 3, 6, true); [EOL]         list3 = (List<? super Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 3, false); [EOL] //        list4 = list4; [EOL]         delegateBooleanAssertion(types, 4, 4, true); [EOL]         list5 = list4; [EOL]         delegateBooleanAssertion(types, 4, 5, true); [EOL]         list4 = (List<String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 4, false); [EOL]         list6 = list4; [EOL]         delegateBooleanAssertion(types, 4, 6, true); [EOL]         list4 = (List<String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 4, false); [EOL] //        list5 = list5; [EOL]         delegateBooleanAssertion(types, 5, 5, true); [EOL]         list6 = (List<? super String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 6, false); [EOL]         list5 = (List<? extends String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 5, false); [EOL] //        list6 = list6; [EOL]         delegateBooleanAssertion(types, 6, 6, true); [EOL]  [EOL] //        list7 = list7; [EOL]         delegateBooleanAssertion(types, 7, 7, true); [EOL]         list8 = list7; [EOL]         delegateBooleanAssertion(types, 7, 8, true); [EOL]         list7 = list8; [EOL]         delegateBooleanAssertion(types, 8, 7, true); [EOL]         list9 = list7; [EOL]         delegateBooleanAssertion(types, 7, 9, true); [EOL]         list7 = list9; [EOL]         delegateBooleanAssertion(types, 9, 7, true); [EOL]         list10 = list7; [EOL]         delegateBooleanAssertion(types, 7, 10, true); [EOL]         list7 = list10; [EOL]         delegateBooleanAssertion(types, 10, 7, true); [EOL]         list11 = list7; [EOL]         delegateBooleanAssertion(types, 7, 11, true); [EOL]         list7 = list11; [EOL]         delegateBooleanAssertion(types, 11, 7, true); [EOL]         list12 = list7; [EOL]         delegateBooleanAssertion(types, 7, 12, true); [EOL]         list7 = list12; [EOL]         delegateBooleanAssertion(types, 12, 7, true); [EOL]         list13 = list7; [EOL]         delegateBooleanAssertion(types, 7, 13, true); [EOL]         list7 = list13; [EOL]         delegateBooleanAssertion(types, 13, 7, true); [EOL] //        list8 = list8; [EOL]         delegateBooleanAssertion(types, 8, 8, true); [EOL]         list9 = list8; [EOL]         delegateBooleanAssertion(types, 8, 9, true); [EOL]         list8 = (List<Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 8, false); [EOL]         list10 = list8; [EOL]         delegateBooleanAssertion(types, 8, 10, true); [EOL]         list8 = (List<Object>[]) list10; // NOTE cast is required by Sun Java, but not by Eclipse [EOL]         delegateBooleanAssertion(types, 10, 8, false); [EOL]         // list11 = list8; [EOL]         delegateBooleanAssertion(types, 8, 11, false); [EOL]         // list8 = list11; [EOL]         delegateBooleanAssertion(types, 11, 8, false); [EOL]         // list12 = list8; [EOL]         delegateBooleanAssertion(types, 8, 12, false); [EOL]         // list8 = list12; [EOL]         delegateBooleanAssertion(types, 12, 8, false); [EOL]         list13 = list8; [EOL]         delegateBooleanAssertion(types, 8, 13, true); [EOL]         list8 = (List<Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 8, false); [EOL] //        list9 = list9; [EOL]         delegateBooleanAssertion(types, 9, 9, true); [EOL]         list10 = (List<? super Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 10, false); [EOL]         list9 = list10; [EOL]         delegateBooleanAssertion(types, 10, 9, true); [EOL]         list11 = (List<String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 11, false); [EOL]         list9 = list11; [EOL]         delegateBooleanAssertion(types, 11, 9, true); [EOL]         list12 = (List<? extends String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 12, false); [EOL]         list9 = list12; [EOL]         delegateBooleanAssertion(types, 12, 9, true); [EOL]         list13 = (List<? super String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 13, false); [EOL]         list9 = list13; [EOL]         delegateBooleanAssertion(types, 13, 9, true); [EOL] //        list10 = list10; [EOL]         delegateBooleanAssertion(types, 10, 10, true); [EOL]         // list11 = list10; [EOL]         delegateBooleanAssertion(types, 10, 11, false); [EOL]         // list10 = list11; [EOL]         delegateBooleanAssertion(types, 11, 10, false); [EOL]         // list12 = list10; [EOL]         delegateBooleanAssertion(types, 10, 12, false); [EOL]         // list10 = list12; [EOL]         delegateBooleanAssertion(types, 12, 10, false); [EOL]         list13 = list10; [EOL]         delegateBooleanAssertion(types, 10, 13, true); [EOL]         list10 = (List<? super Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 10, false); [EOL] //        list11 = list11; [EOL]         delegateBooleanAssertion(types, 11, 11, true); [EOL]         list12 = list11; [EOL]         delegateBooleanAssertion(types, 11, 12, true); [EOL]         list11 = (List<String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 11, false); [EOL]         list13 = list11; [EOL]         delegateBooleanAssertion(types, 11, 13, true); [EOL]         list11 = (List<String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 11, false); [EOL] //        list12 = list12; [EOL]         delegateBooleanAssertion(types, 12, 12, true); [EOL]         list13 = (List<? super String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 13, false); [EOL]         list12 = (List<? extends String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 12, false); [EOL] //        list13 = list13; [EOL]         delegateBooleanAssertion(types, 13, 13, true); [EOL]         final Type disType = getClass().getField("dis").getGenericType(); [EOL]         // Reporter.log( ( ( ParameterizedType ) disType [EOL]         // ).getOwnerType().getClass().toString() ); [EOL]         final Type datType = getClass().getField("dat").getGenericType(); [EOL]         final Type daType = getClass().getField("da").getGenericType(); [EOL]         final Type uhderType = getClass().getField("uhder").getGenericType(); [EOL]         final Type dingType = getClass().getField("ding").getGenericType(); [EOL]         final Type testerType = getClass().getField("tester").getGenericType(); [EOL]         final Type tester2Type = getClass().getField("tester2").getGenericType(); [EOL]         final Type dat2Type = getClass().getField("dat2").getGenericType(); [EOL]         final Type dat3Type = getClass().getField("dat3").getGenericType(); [EOL]         dis = dat; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(datType, disType)); [EOL]         // dis = da; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(daType, disType)); [EOL]         dis = uhder; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(uhderType, disType)); [EOL]         dis = ding; [EOL]         Assert.assertFalse(String.format("type %s not assignable to %s!", dingType, disType), [EOL]                 TypeUtils.isAssignable(dingType, disType)); [EOL]         dis = tester; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(testerType, disType)); [EOL]         // dis = tester2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(tester2Type, disType)); [EOL]         // dat = dat2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat2Type, datType)); [EOL]         // dat2 = dat; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(datType, dat2Type)); [EOL]         // dat = dat3; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat3Type, datType)); [EOL]         final char ch = 0; [EOL]         final boolean bo = false; [EOL]         final byte by = 0; [EOL]         final short sh = 0; [EOL]         int in = 0; [EOL]         long lo = 0; [EOL]         final float fl = 0; [EOL]         double du = 0; [EOL]         du = ch; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(char.class, double.class)); [EOL]         du = by; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(byte.class, double.class)); [EOL]         du = sh; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(short.class, double.class)); [EOL]         du = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, double.class)); [EOL]         du = lo; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(long.class, double.class)); [EOL]         du = fl; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(float.class, double.class)); [EOL]         lo = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, long.class)); [EOL]         lo = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, long.class)); [EOL]         // Long lngW = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, Long.class)); [EOL]         // lngW = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, Long.class)); [EOL]         in = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, int.class)); [EOL]         final Integer inte = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Integer.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Number.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Object.class)); [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, intComparableType)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Comparable.class)); [EOL]         final Serializable ser = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Serializable.class)); [EOL]         final Type longComparableType = getClass().getField("longComparable").getGenericType(); [EOL]         // longComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, longComparableType)); [EOL]         // longComparable = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, longComparableType)); [EOL]         // int[] ia; [EOL]         // long[] la = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, long[].class)); [EOL]         final Integer[] ia = null; [EOL]         final Type caType = getClass().getField("intWildcardComparable").getGenericType(); [EOL]         intWildcardComparable = ia; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, caType)); [EOL]         // int[] ina = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer[].class, int[].class)); [EOL]         final int[] ina = null; [EOL]         Object[] oa; [EOL]         // oa = ina; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, Object[].class)); [EOL]         oa = new Integer[0]; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, Object[].class)); [EOL]         final Type bClassType = AClass.class.getField("bClass").getGenericType(); [EOL]         final Type cClassType = AClass.class.getField("cClass").getGenericType(); [EOL]         final Type dClassType = AClass.class.getField("dClass").getGenericType(); [EOL]         final Type eClassType = AClass.class.getField("eClass").getGenericType(); [EOL]         final Type fClassType = AClass.class.getField("fClass").getGenericType(); [EOL]         final AClass aClass = new AClass(new AAClass<String>()); [EOL]         aClass.bClass = aClass.cClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(cClassType, bClassType)); [EOL]         aClass.bClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, bClassType)); [EOL]         aClass.bClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, bClassType)); [EOL]         aClass.bClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, bClassType)); [EOL]         aClass.cClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, cClassType)); [EOL]         aClass.cClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, cClassType)); [EOL]         aClass.cClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, cClassType)); [EOL]         aClass.dClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, dClassType)); [EOL]         aClass.dClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, dClassType)); [EOL]         aClass.eClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, eClassType)); [EOL]     } [EOL]  [EOL]     public void delegateBooleanAssertion(final Type[] types, final int i2, final int i1, final boolean expected) { [EOL]         final Type type1 = types[i1]; [EOL]         final Type type2 = types[i2]; [EOL]         final boolean isAssignable = TypeUtils.isAssignable(type2, type1); [EOL]  [EOL]         if (expected) { [EOL]             Assert.assertTrue("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } else { [EOL]             Assert.assertFalse("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } [EOL]     } [EOL]  [EOL]     @SuppressWarnings("boxing") // boxing is deliberate here [EOL]
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [EOL]         final Type[] types = method.getGenericParameterTypes(); [EOL] //        list0 = list0; [EOL]         delegateBooleanAssertion(types, 0, 0, true); [EOL]         list1 = list0; [EOL]         delegateBooleanAssertion(types, 0, 1, true); [EOL]         list0 = list1; [EOL]         delegateBooleanAssertion(types, 1, 0, true); [EOL]         list2 = list0; [EOL]         delegateBooleanAssertion(types, 0, 2, true); [EOL]         list0 = list2; [EOL]         delegateBooleanAssertion(types, 2, 0, true); [EOL]         list3 = list0; [EOL]         delegateBooleanAssertion(types, 0, 3, true); [EOL]         list0 = list3; [EOL]         delegateBooleanAssertion(types, 3, 0, true); [EOL]         list4 = list0; [EOL]         delegateBooleanAssertion(types, 0, 4, true); [EOL]         list0 = list4; [EOL]         delegateBooleanAssertion(types, 4, 0, true); [EOL]         list5 = list0; [EOL]         delegateBooleanAssertion(types, 0, 5, true); [EOL]         list0 = list5; [EOL]         delegateBooleanAssertion(types, 5, 0, true); [EOL]         list6 = list0; [EOL]         delegateBooleanAssertion(types, 0, 6, true); [EOL]         list0 = list6; [EOL]         delegateBooleanAssertion(types, 6, 0, true); [EOL] //        list1 = list1; [EOL]         delegateBooleanAssertion(types, 1, 1, true); [EOL]         list2 = list1; [EOL]         delegateBooleanAssertion(types, 1, 2, true); [EOL]         list1 = (List<Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 1, false); [EOL]         list3 = list1; [EOL]         delegateBooleanAssertion(types, 1, 3, true); [EOL]         list1 = (List<Object>) list3; [EOL]         delegateBooleanAssertion(types, 3, 1, false); [EOL]         // list4 = list1; [EOL]         delegateBooleanAssertion(types, 1, 4, false); [EOL]         // list1 = list4; [EOL]         delegateBooleanAssertion(types, 4, 1, false); [EOL]         // list5 = list1; [EOL]         delegateBooleanAssertion(types, 1, 5, false); [EOL]         // list1 = list5; [EOL]         delegateBooleanAssertion(types, 5, 1, false); [EOL]         list6 = list1; [EOL]         delegateBooleanAssertion(types, 1, 6, true); [EOL]         list1 = (List<Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 1, false); [EOL] //        list2 = list2; [EOL]         delegateBooleanAssertion(types, 2, 2, true); [EOL]         list2 = list3; [EOL]         delegateBooleanAssertion(types, 2, 3, false); [EOL]         list2 = list4; [EOL]         delegateBooleanAssertion(types, 3, 2, true); [EOL]         list3 = (List<? super Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 4, false); [EOL]         list2 = list5; [EOL]         delegateBooleanAssertion(types, 4, 2, true); [EOL]         list4 = (List<String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 5, false); [EOL]         list2 = list6; [EOL]         delegateBooleanAssertion(types, 5, 2, true); [EOL]         list5 = (List<? extends String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 6, false); [EOL] //        list3 = list3; [EOL]         delegateBooleanAssertion(types, 6, 2, true); [EOL]         list6 = (List<? super String>) list2; [EOL]         delegateBooleanAssertion(types, 3, 3, true); [EOL]         // list4 = list3; [EOL]         delegateBooleanAssertion(types, 3, 4, false); [EOL]         // list3 = list4; [EOL]         delegateBooleanAssertion(types, 4, 3, false); [EOL]         // list5 = list3; [EOL]         delegateBooleanAssertion(types, 3, 5, false); [EOL]         // list3 = list5; [EOL]         delegateBooleanAssertion(types, 5, 3, false); [EOL]         list6 = list3; [EOL]         delegateBooleanAssertion(types, 3, 6, true); [EOL]         list3 = (List<? super Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 3, false); [EOL] //        list4 = list4; [EOL]         delegateBooleanAssertion(types, 4, 4, true); [EOL]         list5 = list4; [EOL]         delegateBooleanAssertion(types, 4, 5, true); [EOL]         list4 = (List<String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 4, false); [EOL]         list6 = list4; [EOL]         delegateBooleanAssertion(types, 4, 6, true); [EOL]         list4 = (List<String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 4, false); [EOL] //        list5 = list5; [EOL]         delegateBooleanAssertion(types, 5, 5, true); [EOL]         list6 = (List<? super String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 6, false); [EOL]         list5 = (List<? extends String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 5, false); [EOL] //        list6 = list6; [EOL]         delegateBooleanAssertion(types, 6, 6, true); [EOL]  [EOL] //        list7 = list7; [EOL]         delegateBooleanAssertion(types, 7, 7, true); [EOL]         list8 = list7; [EOL]         delegateBooleanAssertion(types, 7, 8, true); [EOL]         list7 = list8; [EOL]         delegateBooleanAssertion(types, 8, 7, true); [EOL]         list9 = list7; [EOL]         delegateBooleanAssertion(types, 7, 9, true); [EOL]         list7 = list9; [EOL]         delegateBooleanAssertion(types, 9, 7, true); [EOL]         list10 = list7; [EOL]         delegateBooleanAssertion(types, 7, 10, true); [EOL]         list7 = list10; [EOL]         delegateBooleanAssertion(types, 10, 7, true); [EOL]         list11 = list7; [EOL]         delegateBooleanAssertion(types, 7, 11, true); [EOL]         list7 = list11; [EOL]         delegateBooleanAssertion(types, 11, 7, true); [EOL]         list12 = list7; [EOL]         delegateBooleanAssertion(types, 7, 12, true); [EOL]         list7 = list12; [EOL]         delegateBooleanAssertion(types, 12, 7, true); [EOL]         list13 = list7; [EOL]         delegateBooleanAssertion(types, 7, 13, true); [EOL]         list7 = list13; [EOL]         delegateBooleanAssertion(types, 13, 7, true); [EOL] //        list8 = list8; [EOL]         delegateBooleanAssertion(types, 8, 8, true); [EOL]         list9 = list8; [EOL]         delegateBooleanAssertion(types, 8, 9, true); [EOL]         list8 = (List<Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 8, false); [EOL]         list10 = list8; [EOL]         delegateBooleanAssertion(types, 8, 10, true); [EOL]         list8 = (List<Object>[]) list10; // NOTE cast is required by Sun Java, but not by Eclipse [EOL]         delegateBooleanAssertion(types, 10, 8, false); [EOL]         // list11 = list8; [EOL]         delegateBooleanAssertion(types, 8, 11, false); [EOL]         // list8 = list11; [EOL]         delegateBooleanAssertion(types, 11, 8, false); [EOL]         // list12 = list8; [EOL]         delegateBooleanAssertion(types, 8, 12, false); [EOL]         // list8 = list12; [EOL]         delegateBooleanAssertion(types, 12, 8, false); [EOL]         list13 = list8; [EOL]         delegateBooleanAssertion(types, 8, 13, true); [EOL]         list8 = (List<Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 8, false); [EOL] //        list9 = list9; [EOL]         delegateBooleanAssertion(types, 9, 9, true); [EOL]         list10 = (List<? super Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 10, false); [EOL]         list9 = list10; [EOL]         delegateBooleanAssertion(types, 10, 9, true); [EOL]         list11 = (List<String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 11, false); [EOL]         list9 = list11; [EOL]         delegateBooleanAssertion(types, 11, 9, true); [EOL]         list12 = (List<? extends String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 12, false); [EOL]         list9 = list12; [EOL]         delegateBooleanAssertion(types, 12, 9, true); [EOL]         list13 = (List<? super String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 13, false); [EOL]         list9 = list13; [EOL]         delegateBooleanAssertion(types, 13, 9, true); [EOL] //        list10 = list10; [EOL]         delegateBooleanAssertion(types, 10, 10, true); [EOL]         // list11 = list10; [EOL]         delegateBooleanAssertion(types, 10, 11, false); [EOL]         // list10 = list11; [EOL]         delegateBooleanAssertion(types, 11, 10, false); [EOL]         // list12 = list10; [EOL]         delegateBooleanAssertion(types, 10, 12, false); [EOL]         // list10 = list12; [EOL]         delegateBooleanAssertion(types, 12, 10, false); [EOL]         list13 = list10; [EOL]         delegateBooleanAssertion(types, 10, 13, true); [EOL]         list10 = (List<? super Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 10, false); [EOL] //        list11 = list11; [EOL]         delegateBooleanAssertion(types, 11, 11, true); [EOL]         list12 = list11; [EOL]         delegateBooleanAssertion(types, 11, 12, true); [EOL]         list11 = (List<String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 11, false); [EOL]         list13 = list11; [EOL]         delegateBooleanAssertion(types, 11, 13, true); [EOL]         list11 = (List<String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 11, false); [EOL] //        list12 = list12; [EOL]         delegateBooleanAssertion(types, 12, 12, true); [EOL]         list13 = (List<? super String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 13, false); [EOL]         list12 = (List<? extends String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 12, false); [EOL] //        list13 = list13; [EOL]         delegateBooleanAssertion(types, 13, 13, true); [EOL]         final Type disType = getClass().getField("dis").getGenericType(); [EOL]         // Reporter.log( ( ( ParameterizedType ) disType [EOL]         // ).getOwnerType().getClass().toString() ); [EOL]         final Type datType = getClass().getField("dat").getGenericType(); [EOL]         final Type daType = getClass().getField("da").getGenericType(); [EOL]         final Type uhderType = getClass().getField("uhder").getGenericType(); [EOL]         final Type dingType = getClass().getField("ding").getGenericType(); [EOL]         final Type testerType = getClass().getField("tester").getGenericType(); [EOL]         final Type tester2Type = getClass().getField("tester2").getGenericType(); [EOL]         final Type dat2Type = getClass().getField("dat2").getGenericType(); [EOL]         final Type dat3Type = getClass().getField("dat3").getGenericType(); [EOL]         dis = dat; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(datType, disType)); [EOL]         // dis = da; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(daType, disType)); [EOL]         dis = uhder; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(uhderType, disType)); [EOL]         dis = ding; [EOL]         Assert.assertFalse(String.format("type %s not assignable to %s!", dingType, disType), [EOL]                 TypeUtils.isAssignable(dingType, disType)); [EOL]         dis = tester; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(testerType, disType)); [EOL]         // dis = tester2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(tester2Type, disType)); [EOL]         // dat = dat2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat2Type, datType)); [EOL]         // dat2 = dat; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(datType, dat2Type)); [EOL]         // dat = dat3; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat3Type, datType)); [EOL]         final char ch = 0; [EOL]         final boolean bo = false; [EOL]         final byte by = 0; [EOL]         final short sh = 0; [EOL]         int in = 0; [EOL]         long lo = 0; [EOL]         final float fl = 0; [EOL]         double du = 0; [EOL]         du = ch; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(char.class, double.class)); [EOL]         du = by; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(byte.class, double.class)); [EOL]         du = sh; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(short.class, double.class)); [EOL]         du = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, double.class)); [EOL]         du = lo; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(long.class, double.class)); [EOL]         du = fl; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(float.class, double.class)); [EOL]         lo = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, long.class)); [EOL]         lo = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, long.class)); [EOL]         // Long lngW = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, Long.class)); [EOL]         // lngW = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, Long.class)); [EOL]         in = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, int.class)); [EOL]         final Integer inte = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Integer.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Number.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Object.class)); [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, intComparableType)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Comparable.class)); [EOL]         final Serializable ser = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Serializable.class)); [EOL]         final Type longComparableType = getClass().getField("longComparable").getGenericType(); [EOL]         // longComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, longComparableType)); [EOL]         // longComparable = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, longComparableType)); [EOL]         // int[] ia; [EOL]         // long[] la = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, long[].class)); [EOL]         final Integer[] ia = null; [EOL]         final Type caType = getClass().getField("intWildcardComparable").getGenericType(); [EOL]         intWildcardComparable = ia; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, caType)); [EOL]         // int[] ina = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer[].class, int[].class)); [EOL]         final int[] ina = null; [EOL]         Object[] oa; [EOL]         // oa = ina; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, Object[].class)); [EOL]         oa = new Integer[0]; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, Object[].class)); [EOL]         final Type bClassType = AClass.class.getField("bClass").getGenericType(); [EOL]         final Type cClassType = AClass.class.getField("cClass").getGenericType(); [EOL]         final Type dClassType = AClass.class.getField("dClass").getGenericType(); [EOL]         final Type eClassType = AClass.class.getField("eClass").getGenericType(); [EOL]         final Type fClassType = AClass.class.getField("fClass").getGenericType(); [EOL]         final AClass aClass = new AClass(new AAClass<String>()); [EOL]         aClass.bClass = aClass.cClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(cClassType, bClassType)); [EOL]         aClass.bClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, bClassType)); [EOL]         aClass.bClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, bClassType)); [EOL]         aClass.bClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, bClassType)); [EOL]         aClass.cClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, cClassType)); [EOL]         aClass.cClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, cClassType)); [EOL]         aClass.cClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, cClassType)); [EOL]         aClass.dClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, dClassType)); [EOL]         aClass.dClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, dClassType)); [EOL]         aClass.eClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, eClassType)); [EOL]     } [EOL]  [EOL]     public void delegateBooleanAssertion(final Type[] types, final int i2, final int i1, final boolean expected) { [EOL]         final Type type1 = types[i1]; [EOL]         final Type type2 = types[i2]; [EOL]         final boolean isAssignable = TypeUtils.isAssignable(type2, type1); [EOL]  [EOL]         if (expected) { [EOL]             Assert.assertTrue("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } else { [EOL]             Assert.assertFalse("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } [EOL]     } [EOL]  [EOL]     @SuppressWarnings("boxing") // boxing is deliberate here [EOL]
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [EOL]         final Type[] types = method.getGenericParameterTypes(); [EOL] //        list0 = list0; [EOL]         delegateBooleanAssertion(types, 0, 0, true); [EOL]         list1 = list0; [EOL]         delegateBooleanAssertion(types, 0, 1, true); [EOL]         list0 = list1; [EOL]         delegateBooleanAssertion(types, 1, 0, true); [EOL]         list2 = list0; [EOL]         delegateBooleanAssertion(types, 0, 2, true); [EOL]         list0 = list2; [EOL]         delegateBooleanAssertion(types, 2, 0, true); [EOL]         list3 = list0; [EOL]         delegateBooleanAssertion(types, 0, 3, true); [EOL]         list0 = list3; [EOL]         delegateBooleanAssertion(types, 3, 0, true); [EOL]         list4 = list0; [EOL]         delegateBooleanAssertion(types, 0, 4, true); [EOL]         list0 = list4; [EOL]         delegateBooleanAssertion(types, 4, 0, true); [EOL]         list5 = list0; [EOL]         delegateBooleanAssertion(types, 0, 5, true); [EOL]         list0 = list5; [EOL]         delegateBooleanAssertion(types, 5, 0, true); [EOL]         list6 = list0; [EOL]         delegateBooleanAssertion(types, 0, 6, true); [EOL]         list0 = list6; [EOL]         delegateBooleanAssertion(types, 6, 0, true); [EOL] //        list1 = list1; [EOL]         delegateBooleanAssertion(types, 1, 1, true); [EOL]         list2 = list1; [EOL]         delegateBooleanAssertion(types, 1, 2, true); [EOL]         list1 = (List<Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 1, false); [EOL]         list3 = list1; [EOL]         delegateBooleanAssertion(types, 1, 3, true); [EOL]         list1 = (List<Object>) list3; [EOL]         delegateBooleanAssertion(types, 3, 1, false); [EOL]         // list4 = list1; [EOL]         delegateBooleanAssertion(types, 1, 4, false); [EOL]         // list1 = list4; [EOL]         delegateBooleanAssertion(types, 4, 1, false); [EOL]         // list5 = list1; [EOL]         delegateBooleanAssertion(types, 1, 5, false); [EOL]         // list1 = list5; [EOL]         delegateBooleanAssertion(types, 5, 1, false); [EOL]         list6 = list1; [EOL]         delegateBooleanAssertion(types, 1, 6, true); [EOL]         list1 = (List<Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 1, false); [EOL] //        list2 = list2; [EOL]         delegateBooleanAssertion(types, 2, 2, true); [EOL]         list2 = list3; [EOL]         delegateBooleanAssertion(types, 2, 3, false); [EOL]         list2 = list4; [EOL]         delegateBooleanAssertion(types, 3, 2, true); [EOL]         list3 = (List<? super Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 4, false); [EOL]         list2 = list5; [EOL]         delegateBooleanAssertion(types, 4, 2, true); [EOL]         list4 = (List<String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 5, false); [EOL]         list2 = list6; [EOL]         delegateBooleanAssertion(types, 5, 2, true); [EOL]         list5 = (List<? extends String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 6, false); [EOL] //        list3 = list3; [EOL]         delegateBooleanAssertion(types, 6, 2, true); [EOL]         list6 = (List<? super String>) list2; [EOL]         delegateBooleanAssertion(types, 3, 3, true); [EOL]         // list4 = list3; [EOL]         delegateBooleanAssertion(types, 3, 4, false); [EOL]         // list3 = list4; [EOL]         delegateBooleanAssertion(types, 4, 3, false); [EOL]         // list5 = list3; [EOL]         delegateBooleanAssertion(types, 3, 5, false); [EOL]         // list3 = list5; [EOL]         delegateBooleanAssertion(types, 5, 3, false); [EOL]         list6 = list3; [EOL]         delegateBooleanAssertion(types, 3, 6, true); [EOL]         list3 = (List<? super Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 3, false); [EOL] //        list4 = list4; [EOL]         delegateBooleanAssertion(types, 4, 4, true); [EOL]         list5 = list4; [EOL]         delegateBooleanAssertion(types, 4, 5, true); [EOL]         list4 = (List<String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 4, false); [EOL]         list6 = list4; [EOL]         delegateBooleanAssertion(types, 4, 6, true); [EOL]         list4 = (List<String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 4, false); [EOL] //        list5 = list5; [EOL]         delegateBooleanAssertion(types, 5, 5, true); [EOL]         list6 = (List<? super String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 6, false); [EOL]         list5 = (List<? extends String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 5, false); [EOL] //        list6 = list6; [EOL]         delegateBooleanAssertion(types, 6, 6, true); [EOL]  [EOL] //        list7 = list7; [EOL]         delegateBooleanAssertion(types, 7, 7, true); [EOL]         list8 = list7; [EOL]         delegateBooleanAssertion(types, 7, 8, true); [EOL]         list7 = list8; [EOL]         delegateBooleanAssertion(types, 8, 7, true); [EOL]         list9 = list7; [EOL]         delegateBooleanAssertion(types, 7, 9, true); [EOL]         list7 = list9; [EOL]         delegateBooleanAssertion(types, 9, 7, true); [EOL]         list10 = list7; [EOL]         delegateBooleanAssertion(types, 7, 10, true); [EOL]         list7 = list10; [EOL]         delegateBooleanAssertion(types, 10, 7, true); [EOL]         list11 = list7; [EOL]         delegateBooleanAssertion(types, 7, 11, true); [EOL]         list7 = list11; [EOL]         delegateBooleanAssertion(types, 11, 7, true); [EOL]         list12 = list7; [EOL]         delegateBooleanAssertion(types, 7, 12, true); [EOL]         list7 = list12; [EOL]         delegateBooleanAssertion(types, 12, 7, true); [EOL]         list13 = list7; [EOL]         delegateBooleanAssertion(types, 7, 13, true); [EOL]         list7 = list13; [EOL]         delegateBooleanAssertion(types, 13, 7, true); [EOL] //        list8 = list8; [EOL]         delegateBooleanAssertion(types, 8, 8, true); [EOL]         list9 = list8; [EOL]         delegateBooleanAssertion(types, 8, 9, true); [EOL]         list8 = (List<Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 8, false); [EOL]         list10 = list8; [EOL]         delegateBooleanAssertion(types, 8, 10, true); [EOL]         list8 = (List<Object>[]) list10; // NOTE cast is required by Sun Java, but not by Eclipse [EOL]         delegateBooleanAssertion(types, 10, 8, false); [EOL]         // list11 = list8; [EOL]         delegateBooleanAssertion(types, 8, 11, false); [EOL]         // list8 = list11; [EOL]         delegateBooleanAssertion(types, 11, 8, false); [EOL]         // list12 = list8; [EOL]         delegateBooleanAssertion(types, 8, 12, false); [EOL]         // list8 = list12; [EOL]         delegateBooleanAssertion(types, 12, 8, false); [EOL]         list13 = list8; [EOL]         delegateBooleanAssertion(types, 8, 13, true); [EOL]         list8 = (List<Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 8, false); [EOL] //        list9 = list9; [EOL]         delegateBooleanAssertion(types, 9, 9, true); [EOL]         list10 = (List<? super Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 10, false); [EOL]         list9 = list10; [EOL]         delegateBooleanAssertion(types, 10, 9, true); [EOL]         list11 = (List<String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 11, false); [EOL]         list9 = list11; [EOL]         delegateBooleanAssertion(types, 11, 9, true); [EOL]         list12 = (List<? extends String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 12, false); [EOL]         list9 = list12; [EOL]         delegateBooleanAssertion(types, 12, 9, true); [EOL]         list13 = (List<? super String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 13, false); [EOL]         list9 = list13; [EOL]         delegateBooleanAssertion(types, 13, 9, true); [EOL] //        list10 = list10; [EOL]         delegateBooleanAssertion(types, 10, 10, true); [EOL]         // list11 = list10; [EOL]         delegateBooleanAssertion(types, 10, 11, false); [EOL]         // list10 = list11; [EOL]         delegateBooleanAssertion(types, 11, 10, false); [EOL]         // list12 = list10; [EOL]         delegateBooleanAssertion(types, 10, 12, false); [EOL]         // list10 = list12; [EOL]         delegateBooleanAssertion(types, 12, 10, false); [EOL]         list13 = list10; [EOL]         delegateBooleanAssertion(types, 10, 13, true); [EOL]         list10 = (List<? super Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 10, false); [EOL] //        list11 = list11; [EOL]         delegateBooleanAssertion(types, 11, 11, true); [EOL]         list12 = list11; [EOL]         delegateBooleanAssertion(types, 11, 12, true); [EOL]         list11 = (List<String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 11, false); [EOL]         list13 = list11; [EOL]         delegateBooleanAssertion(types, 11, 13, true); [EOL]         list11 = (List<String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 11, false); [EOL] //        list12 = list12; [EOL]         delegateBooleanAssertion(types, 12, 12, true); [EOL]         list13 = (List<? super String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 13, false); [EOL]         list12 = (List<? extends String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 12, false); [EOL] //        list13 = list13; [EOL]         delegateBooleanAssertion(types, 13, 13, true); [EOL]         final Type disType = getClass().getField("dis").getGenericType(); [EOL]         // Reporter.log( ( ( ParameterizedType ) disType [EOL]         // ).getOwnerType().getClass().toString() ); [EOL]         final Type datType = getClass().getField("dat").getGenericType(); [EOL]         final Type daType = getClass().getField("da").getGenericType(); [EOL]         final Type uhderType = getClass().getField("uhder").getGenericType(); [EOL]         final Type dingType = getClass().getField("ding").getGenericType(); [EOL]         final Type testerType = getClass().getField("tester").getGenericType(); [EOL]         final Type tester2Type = getClass().getField("tester2").getGenericType(); [EOL]         final Type dat2Type = getClass().getField("dat2").getGenericType(); [EOL]         final Type dat3Type = getClass().getField("dat3").getGenericType(); [EOL]         dis = dat; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(datType, disType)); [EOL]         // dis = da; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(daType, disType)); [EOL]         dis = uhder; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(uhderType, disType)); [EOL]         dis = ding; [EOL]         Assert.assertFalse(String.format("type %s not assignable to %s!", dingType, disType), [EOL]                 TypeUtils.isAssignable(dingType, disType)); [EOL]         dis = tester; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(testerType, disType)); [EOL]         // dis = tester2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(tester2Type, disType)); [EOL]         // dat = dat2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat2Type, datType)); [EOL]         // dat2 = dat; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(datType, dat2Type)); [EOL]         // dat = dat3; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat3Type, datType)); [EOL]         final char ch = 0; [EOL]         final boolean bo = false; [EOL]         final byte by = 0; [EOL]         final short sh = 0; [EOL]         int in = 0; [EOL]         long lo = 0; [EOL]         final float fl = 0; [EOL]         double du = 0; [EOL]         du = ch; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(char.class, double.class)); [EOL]         du = by; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(byte.class, double.class)); [EOL]         du = sh; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(short.class, double.class)); [EOL]         du = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, double.class)); [EOL]         du = lo; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(long.class, double.class)); [EOL]         du = fl; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(float.class, double.class)); [EOL]         lo = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, long.class)); [EOL]         lo = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, long.class)); [EOL]         // Long lngW = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, Long.class)); [EOL]         // lngW = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, Long.class)); [EOL]         in = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, int.class)); [EOL]         final Integer inte = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Integer.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Number.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Object.class)); [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, intComparableType)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Comparable.class)); [EOL]         final Serializable ser = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Serializable.class)); [EOL]         final Type longComparableType = getClass().getField("longComparable").getGenericType(); [EOL]         // longComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, longComparableType)); [EOL]         // longComparable = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, longComparableType)); [EOL]         // int[] ia; [EOL]         // long[] la = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, long[].class)); [EOL]         final Integer[] ia = null; [EOL]         final Type caType = getClass().getField("intWildcardComparable").getGenericType(); [EOL]         intWildcardComparable = ia; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, caType)); [EOL]         // int[] ina = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer[].class, int[].class)); [EOL]         final int[] ina = null; [EOL]         Object[] oa; [EOL]         // oa = ina; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, Object[].class)); [EOL]         oa = new Integer[0]; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, Object[].class)); [EOL]         final Type bClassType = AClass.class.getField("bClass").getGenericType(); [EOL]         final Type cClassType = AClass.class.getField("cClass").getGenericType(); [EOL]         final Type dClassType = AClass.class.getField("dClass").getGenericType(); [EOL]         final Type eClassType = AClass.class.getField("eClass").getGenericType(); [EOL]         final Type fClassType = AClass.class.getField("fClass").getGenericType(); [EOL]         final AClass aClass = new AClass(new AAClass<String>()); [EOL]         aClass.bClass = aClass.cClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(cClassType, bClassType)); [EOL]         aClass.bClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, bClassType)); [EOL]         aClass.bClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, bClassType)); [EOL]         aClass.bClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, bClassType)); [EOL]         aClass.cClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, cClassType)); [EOL]         aClass.cClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, cClassType)); [EOL]         aClass.cClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, cClassType)); [EOL]         aClass.dClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, dClassType)); [EOL]         aClass.dClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, dClassType)); [EOL]         aClass.eClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, eClassType)); [EOL]     } [EOL]  [EOL]     public void delegateBooleanAssertion(final Type[] types, final int i2, final int i1, final boolean expected) { [EOL]         final Type type1 = types[i1]; [EOL]         final Type type2 = types[i2]; [EOL]         final boolean isAssignable = TypeUtils.isAssignable(type2, type1); [EOL]  [EOL]         if (expected) { [EOL]             Assert.assertTrue("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } else { [EOL]             Assert.assertFalse("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } [EOL]     } [EOL]  [EOL]     @SuppressWarnings("boxing") // boxing is deliberate here [EOL]
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [EOL]         final Type[] types = method.getGenericParameterTypes(); [EOL] //        list0 = list0; [EOL]         delegateBooleanAssertion(types, 0, 0, true); [EOL]         list1 = list0; [EOL]         delegateBooleanAssertion(types, 0, 1, true); [EOL]         list0 = list1; [EOL]         delegateBooleanAssertion(types, 1, 0, true); [EOL]         list2 = list0; [EOL]         delegateBooleanAssertion(types, 0, 2, true); [EOL]         list0 = list2; [EOL]         delegateBooleanAssertion(types, 2, 0, true); [EOL]         list3 = list0; [EOL]         delegateBooleanAssertion(types, 0, 3, true); [EOL]         list0 = list3; [EOL]         delegateBooleanAssertion(types, 3, 0, true); [EOL]         list4 = list0; [EOL]         delegateBooleanAssertion(types, 0, 4, true); [EOL]         list0 = list4; [EOL]         delegateBooleanAssertion(types, 4, 0, true); [EOL]         list5 = list0; [EOL]         delegateBooleanAssertion(types, 0, 5, true); [EOL]         list0 = list5; [EOL]         delegateBooleanAssertion(types, 5, 0, true); [EOL]         list6 = list0; [EOL]         delegateBooleanAssertion(types, 0, 6, true); [EOL]         list0 = list6; [EOL]         delegateBooleanAssertion(types, 6, 0, true); [EOL] //        list1 = list1; [EOL]         delegateBooleanAssertion(types, 1, 1, true); [EOL]         list2 = list1; [EOL]         delegateBooleanAssertion(types, 1, 2, true); [EOL]         list1 = (List<Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 1, false); [EOL]         list3 = list1; [EOL]         delegateBooleanAssertion(types, 1, 3, true); [EOL]         list1 = (List<Object>) list3; [EOL]         delegateBooleanAssertion(types, 3, 1, false); [EOL]         // list4 = list1; [EOL]         delegateBooleanAssertion(types, 1, 4, false); [EOL]         // list1 = list4; [EOL]         delegateBooleanAssertion(types, 4, 1, false); [EOL]         // list5 = list1; [EOL]         delegateBooleanAssertion(types, 1, 5, false); [EOL]         // list1 = list5; [EOL]         delegateBooleanAssertion(types, 5, 1, false); [EOL]         list6 = list1; [EOL]         delegateBooleanAssertion(types, 1, 6, true); [EOL]         list1 = (List<Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 1, false); [EOL] //        list2 = list2; [EOL]         delegateBooleanAssertion(types, 2, 2, true); [EOL]         list2 = list3; [EOL]         delegateBooleanAssertion(types, 2, 3, false); [EOL]         list2 = list4; [EOL]         delegateBooleanAssertion(types, 3, 2, true); [EOL]         list3 = (List<? super Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 4, false); [EOL]         list2 = list5; [EOL]         delegateBooleanAssertion(types, 4, 2, true); [EOL]         list4 = (List<String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 5, false); [EOL]         list2 = list6; [EOL]         delegateBooleanAssertion(types, 5, 2, true); [EOL]         list5 = (List<? extends String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 6, false); [EOL] //        list3 = list3; [EOL]         delegateBooleanAssertion(types, 6, 2, true); [EOL]         list6 = (List<? super String>) list2; [EOL]         delegateBooleanAssertion(types, 3, 3, true); [EOL]         // list4 = list3; [EOL]         delegateBooleanAssertion(types, 3, 4, false); [EOL]         // list3 = list4; [EOL]         delegateBooleanAssertion(types, 4, 3, false); [EOL]         // list5 = list3; [EOL]         delegateBooleanAssertion(types, 3, 5, false); [EOL]         // list3 = list5; [EOL]         delegateBooleanAssertion(types, 5, 3, false); [EOL]         list6 = list3; [EOL]         delegateBooleanAssertion(types, 3, 6, true); [EOL]         list3 = (List<? super Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 3, false); [EOL] //        list4 = list4; [EOL]         delegateBooleanAssertion(types, 4, 4, true); [EOL]         list5 = list4; [EOL]         delegateBooleanAssertion(types, 4, 5, true); [EOL]         list4 = (List<String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 4, false); [EOL]         list6 = list4; [EOL]         delegateBooleanAssertion(types, 4, 6, true); [EOL]         list4 = (List<String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 4, false); [EOL] //        list5 = list5; [EOL]         delegateBooleanAssertion(types, 5, 5, true); [EOL]         list6 = (List<? super String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 6, false); [EOL]         list5 = (List<? extends String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 5, false); [EOL] //        list6 = list6; [EOL]         delegateBooleanAssertion(types, 6, 6, true); [EOL]  [EOL] //        list7 = list7; [EOL]         delegateBooleanAssertion(types, 7, 7, true); [EOL]         list8 = list7; [EOL]         delegateBooleanAssertion(types, 7, 8, true); [EOL]         list7 = list8; [EOL]         delegateBooleanAssertion(types, 8, 7, true); [EOL]         list9 = list7; [EOL]         delegateBooleanAssertion(types, 7, 9, true); [EOL]         list7 = list9; [EOL]         delegateBooleanAssertion(types, 9, 7, true); [EOL]         list10 = list7; [EOL]         delegateBooleanAssertion(types, 7, 10, true); [EOL]         list7 = list10; [EOL]         delegateBooleanAssertion(types, 10, 7, true); [EOL]         list11 = list7; [EOL]         delegateBooleanAssertion(types, 7, 11, true); [EOL]         list7 = list11; [EOL]         delegateBooleanAssertion(types, 11, 7, true); [EOL]         list12 = list7; [EOL]         delegateBooleanAssertion(types, 7, 12, true); [EOL]         list7 = list12; [EOL]         delegateBooleanAssertion(types, 12, 7, true); [EOL]         list13 = list7; [EOL]         delegateBooleanAssertion(types, 7, 13, true); [EOL]         list7 = list13; [EOL]         delegateBooleanAssertion(types, 13, 7, true); [EOL] //        list8 = list8; [EOL]         delegateBooleanAssertion(types, 8, 8, true); [EOL]         list9 = list8; [EOL]         delegateBooleanAssertion(types, 8, 9, true); [EOL]         list8 = (List<Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 8, false); [EOL]         list10 = list8; [EOL]         delegateBooleanAssertion(types, 8, 10, true); [EOL]         list8 = (List<Object>[]) list10; // NOTE cast is required by Sun Java, but not by Eclipse [EOL]         delegateBooleanAssertion(types, 10, 8, false); [EOL]         // list11 = list8; [EOL]         delegateBooleanAssertion(types, 8, 11, false); [EOL]         // list8 = list11; [EOL]         delegateBooleanAssertion(types, 11, 8, false); [EOL]         // list12 = list8; [EOL]         delegateBooleanAssertion(types, 8, 12, false); [EOL]         // list8 = list12; [EOL]         delegateBooleanAssertion(types, 12, 8, false); [EOL]         list13 = list8; [EOL]         delegateBooleanAssertion(types, 8, 13, true); [EOL]         list8 = (List<Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 8, false); [EOL] //        list9 = list9; [EOL]         delegateBooleanAssertion(types, 9, 9, true); [EOL]         list10 = (List<? super Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 10, false); [EOL]         list9 = list10; [EOL]         delegateBooleanAssertion(types, 10, 9, true); [EOL]         list11 = (List<String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 11, false); [EOL]         list9 = list11; [EOL]         delegateBooleanAssertion(types, 11, 9, true); [EOL]         list12 = (List<? extends String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 12, false); [EOL]         list9 = list12; [EOL]         delegateBooleanAssertion(types, 12, 9, true); [EOL]         list13 = (List<? super String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 13, false); [EOL]         list9 = list13; [EOL]         delegateBooleanAssertion(types, 13, 9, true); [EOL] //        list10 = list10; [EOL]         delegateBooleanAssertion(types, 10, 10, true); [EOL]         // list11 = list10; [EOL]         delegateBooleanAssertion(types, 10, 11, false); [EOL]         // list10 = list11; [EOL]         delegateBooleanAssertion(types, 11, 10, false); [EOL]         // list12 = list10; [EOL]         delegateBooleanAssertion(types, 10, 12, false); [EOL]         // list10 = list12; [EOL]         delegateBooleanAssertion(types, 12, 10, false); [EOL]         list13 = list10; [EOL]         delegateBooleanAssertion(types, 10, 13, true); [EOL]         list10 = (List<? super Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 10, false); [EOL] //        list11 = list11; [EOL]         delegateBooleanAssertion(types, 11, 11, true); [EOL]         list12 = list11; [EOL]         delegateBooleanAssertion(types, 11, 12, true); [EOL]         list11 = (List<String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 11, false); [EOL]         list13 = list11; [EOL]         delegateBooleanAssertion(types, 11, 13, true); [EOL]         list11 = (List<String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 11, false); [EOL] //        list12 = list12; [EOL]         delegateBooleanAssertion(types, 12, 12, true); [EOL]         list13 = (List<? super String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 13, false); [EOL]         list12 = (List<? extends String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 12, false); [EOL] //        list13 = list13; [EOL]         delegateBooleanAssertion(types, 13, 13, true); [EOL]         final Type disType = getClass().getField("dis").getGenericType(); [EOL]         // Reporter.log( ( ( ParameterizedType ) disType [EOL]         // ).getOwnerType().getClass().toString() ); [EOL]         final Type datType = getClass().getField("dat").getGenericType(); [EOL]         final Type daType = getClass().getField("da").getGenericType(); [EOL]         final Type uhderType = getClass().getField("uhder").getGenericType(); [EOL]         final Type dingType = getClass().getField("ding").getGenericType(); [EOL]         final Type testerType = getClass().getField("tester").getGenericType(); [EOL]         final Type tester2Type = getClass().getField("tester2").getGenericType(); [EOL]         final Type dat2Type = getClass().getField("dat2").getGenericType(); [EOL]         final Type dat3Type = getClass().getField("dat3").getGenericType(); [EOL]         dis = dat; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(datType, disType)); [EOL]         // dis = da; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(daType, disType)); [EOL]         dis = uhder; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(uhderType, disType)); [EOL]         dis = ding; [EOL]         Assert.assertFalse(String.format("type %s not assignable to %s!", dingType, disType), [EOL]                 TypeUtils.isAssignable(dingType, disType)); [EOL]         dis = tester; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(testerType, disType)); [EOL]         // dis = tester2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(tester2Type, disType)); [EOL]         // dat = dat2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat2Type, datType)); [EOL]         // dat2 = dat; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(datType, dat2Type)); [EOL]         // dat = dat3; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat3Type, datType)); [EOL]         final char ch = 0; [EOL]         final boolean bo = false; [EOL]         final byte by = 0; [EOL]         final short sh = 0; [EOL]         int in = 0; [EOL]         long lo = 0; [EOL]         final float fl = 0; [EOL]         double du = 0; [EOL]         du = ch; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(char.class, double.class)); [EOL]         du = by; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(byte.class, double.class)); [EOL]         du = sh; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(short.class, double.class)); [EOL]         du = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, double.class)); [EOL]         du = lo; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(long.class, double.class)); [EOL]         du = fl; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(float.class, double.class)); [EOL]         lo = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, long.class)); [EOL]         lo = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, long.class)); [EOL]         // Long lngW = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, Long.class)); [EOL]         // lngW = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, Long.class)); [EOL]         in = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, int.class)); [EOL]         final Integer inte = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Integer.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Number.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Object.class)); [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, intComparableType)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Comparable.class)); [EOL]         final Serializable ser = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Serializable.class)); [EOL]         final Type longComparableType = getClass().getField("longComparable").getGenericType(); [EOL]         // longComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, longComparableType)); [EOL]         // longComparable = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, longComparableType)); [EOL]         // int[] ia; [EOL]         // long[] la = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, long[].class)); [EOL]         final Integer[] ia = null; [EOL]         final Type caType = getClass().getField("intWildcardComparable").getGenericType(); [EOL]         intWildcardComparable = ia; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, caType)); [EOL]         // int[] ina = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer[].class, int[].class)); [EOL]         final int[] ina = null; [EOL]         Object[] oa; [EOL]         // oa = ina; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, Object[].class)); [EOL]         oa = new Integer[0]; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, Object[].class)); [EOL]         final Type bClassType = AClass.class.getField("bClass").getGenericType(); [EOL]         final Type cClassType = AClass.class.getField("cClass").getGenericType(); [EOL]         final Type dClassType = AClass.class.getField("dClass").getGenericType(); [EOL]         final Type eClassType = AClass.class.getField("eClass").getGenericType(); [EOL]         final Type fClassType = AClass.class.getField("fClass").getGenericType(); [EOL]         final AClass aClass = new AClass(new AAClass<String>()); [EOL]         aClass.bClass = aClass.cClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(cClassType, bClassType)); [EOL]         aClass.bClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, bClassType)); [EOL]         aClass.bClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, bClassType)); [EOL]         aClass.bClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, bClassType)); [EOL]         aClass.cClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, cClassType)); [EOL]         aClass.cClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, cClassType)); [EOL]         aClass.cClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, cClassType)); [EOL]         aClass.dClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, dClassType)); [EOL]         aClass.dClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, dClassType)); [EOL]         aClass.eClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, eClassType)); [EOL]     } [EOL]  [EOL]     public void delegateBooleanAssertion(final Type[] types, final int i2, final int i1, final boolean expected) { [EOL]         final Type type1 = types[i1]; [EOL]         final Type type2 = types[i2]; [EOL]         final boolean isAssignable = TypeUtils.isAssignable(type2, type1); [EOL]  [EOL]         if (expected) { [EOL]             Assert.assertTrue("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } else { [EOL]             Assert.assertFalse("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } [EOL]     } [EOL]  [EOL]     @SuppressWarnings("boxing") // boxing is deliberate here [EOL]
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [EOL]         final Type[] types = method.getGenericParameterTypes(); [EOL] //        list0 = list0; [EOL]         delegateBooleanAssertion(types, 0, 0, true); [EOL]         list1 = list0; [EOL]         delegateBooleanAssertion(types, 0, 1, true); [EOL]         list0 = list1; [EOL]         delegateBooleanAssertion(types, 1, 0, true); [EOL]         list2 = list0; [EOL]         delegateBooleanAssertion(types, 0, 2, true); [EOL]         list0 = list2; [EOL]         delegateBooleanAssertion(types, 2, 0, true); [EOL]         list3 = list0; [EOL]         delegateBooleanAssertion(types, 0, 3, true); [EOL]         list0 = list3; [EOL]         delegateBooleanAssertion(types, 3, 0, true); [EOL]         list4 = list0; [EOL]         delegateBooleanAssertion(types, 0, 4, true); [EOL]         list0 = list4; [EOL]         delegateBooleanAssertion(types, 4, 0, true); [EOL]         list5 = list0; [EOL]         delegateBooleanAssertion(types, 0, 5, true); [EOL]         list0 = list5; [EOL]         delegateBooleanAssertion(types, 5, 0, true); [EOL]         list6 = list0; [EOL]         delegateBooleanAssertion(types, 0, 6, true); [EOL]         list0 = list6; [EOL]         delegateBooleanAssertion(types, 6, 0, true); [EOL] //        list1 = list1; [EOL]         delegateBooleanAssertion(types, 1, 1, true); [EOL]         list2 = list1; [EOL]         delegateBooleanAssertion(types, 1, 2, true); [EOL]         list1 = (List<Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 1, false); [EOL]         list3 = list1; [EOL]         delegateBooleanAssertion(types, 1, 3, true); [EOL]         list1 = (List<Object>) list3; [EOL]         delegateBooleanAssertion(types, 3, 1, false); [EOL]         // list4 = list1; [EOL]         delegateBooleanAssertion(types, 1, 4, false); [EOL]         // list1 = list4; [EOL]         delegateBooleanAssertion(types, 4, 1, false); [EOL]         // list5 = list1; [EOL]         delegateBooleanAssertion(types, 1, 5, false); [EOL]         // list1 = list5; [EOL]         delegateBooleanAssertion(types, 5, 1, false); [EOL]         list6 = list1; [EOL]         delegateBooleanAssertion(types, 1, 6, true); [EOL]         list1 = (List<Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 1, false); [EOL] //        list2 = list2; [EOL]         delegateBooleanAssertion(types, 2, 2, true); [EOL]         list2 = list3; [EOL]         delegateBooleanAssertion(types, 2, 3, false); [EOL]         list2 = list4; [EOL]         delegateBooleanAssertion(types, 3, 2, true); [EOL]         list3 = (List<? super Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 4, false); [EOL]         list2 = list5; [EOL]         delegateBooleanAssertion(types, 4, 2, true); [EOL]         list4 = (List<String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 5, false); [EOL]         list2 = list6; [EOL]         delegateBooleanAssertion(types, 5, 2, true); [EOL]         list5 = (List<? extends String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 6, false); [EOL] //        list3 = list3; [EOL]         delegateBooleanAssertion(types, 6, 2, true); [EOL]         list6 = (List<? super String>) list2; [EOL]         delegateBooleanAssertion(types, 3, 3, true); [EOL]         // list4 = list3; [EOL]         delegateBooleanAssertion(types, 3, 4, false); [EOL]         // list3 = list4; [EOL]         delegateBooleanAssertion(types, 4, 3, false); [EOL]         // list5 = list3; [EOL]         delegateBooleanAssertion(types, 3, 5, false); [EOL]         // list3 = list5; [EOL]         delegateBooleanAssertion(types, 5, 3, false); [EOL]         list6 = list3; [EOL]         delegateBooleanAssertion(types, 3, 6, true); [EOL]         list3 = (List<? super Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 3, false); [EOL] //        list4 = list4; [EOL]         delegateBooleanAssertion(types, 4, 4, true); [EOL]         list5 = list4; [EOL]         delegateBooleanAssertion(types, 4, 5, true); [EOL]         list4 = (List<String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 4, false); [EOL]         list6 = list4; [EOL]         delegateBooleanAssertion(types, 4, 6, true); [EOL]         list4 = (List<String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 4, false); [EOL] //        list5 = list5; [EOL]         delegateBooleanAssertion(types, 5, 5, true); [EOL]         list6 = (List<? super String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 6, false); [EOL]         list5 = (List<? extends String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 5, false); [EOL] //        list6 = list6; [EOL]         delegateBooleanAssertion(types, 6, 6, true); [EOL]  [EOL] //        list7 = list7; [EOL]         delegateBooleanAssertion(types, 7, 7, true); [EOL]         list8 = list7; [EOL]         delegateBooleanAssertion(types, 7, 8, true); [EOL]         list7 = list8; [EOL]         delegateBooleanAssertion(types, 8, 7, true); [EOL]         list9 = list7; [EOL]         delegateBooleanAssertion(types, 7, 9, true); [EOL]         list7 = list9; [EOL]         delegateBooleanAssertion(types, 9, 7, true); [EOL]         list10 = list7; [EOL]         delegateBooleanAssertion(types, 7, 10, true); [EOL]         list7 = list10; [EOL]         delegateBooleanAssertion(types, 10, 7, true); [EOL]         list11 = list7; [EOL]         delegateBooleanAssertion(types, 7, 11, true); [EOL]         list7 = list11; [EOL]         delegateBooleanAssertion(types, 11, 7, true); [EOL]         list12 = list7; [EOL]         delegateBooleanAssertion(types, 7, 12, true); [EOL]         list7 = list12; [EOL]         delegateBooleanAssertion(types, 12, 7, true); [EOL]         list13 = list7; [EOL]         delegateBooleanAssertion(types, 7, 13, true); [EOL]         list7 = list13; [EOL]         delegateBooleanAssertion(types, 13, 7, true); [EOL] //        list8 = list8; [EOL]         delegateBooleanAssertion(types, 8, 8, true); [EOL]         list9 = list8; [EOL]         delegateBooleanAssertion(types, 8, 9, true); [EOL]         list8 = (List<Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 8, false); [EOL]         list10 = list8; [EOL]         delegateBooleanAssertion(types, 8, 10, true); [EOL]         list8 = (List<Object>[]) list10; // NOTE cast is required by Sun Java, but not by Eclipse [EOL]         delegateBooleanAssertion(types, 10, 8, false); [EOL]         // list11 = list8; [EOL]         delegateBooleanAssertion(types, 8, 11, false); [EOL]         // list8 = list11; [EOL]         delegateBooleanAssertion(types, 11, 8, false); [EOL]         // list12 = list8; [EOL]         delegateBooleanAssertion(types, 8, 12, false); [EOL]         // list8 = list12; [EOL]         delegateBooleanAssertion(types, 12, 8, false); [EOL]         list13 = list8; [EOL]         delegateBooleanAssertion(types, 8, 13, true); [EOL]         list8 = (List<Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 8, false); [EOL] //        list9 = list9; [EOL]         delegateBooleanAssertion(types, 9, 9, true); [EOL]         list10 = (List<? super Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 10, false); [EOL]         list9 = list10; [EOL]         delegateBooleanAssertion(types, 10, 9, true); [EOL]         list11 = (List<String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 11, false); [EOL]         list9 = list11; [EOL]         delegateBooleanAssertion(types, 11, 9, true); [EOL]         list12 = (List<? extends String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 12, false); [EOL]         list9 = list12; [EOL]         delegateBooleanAssertion(types, 12, 9, true); [EOL]         list13 = (List<? super String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 13, false); [EOL]         list9 = list13; [EOL]         delegateBooleanAssertion(types, 13, 9, true); [EOL] //        list10 = list10; [EOL]         delegateBooleanAssertion(types, 10, 10, true); [EOL]         // list11 = list10; [EOL]         delegateBooleanAssertion(types, 10, 11, false); [EOL]         // list10 = list11; [EOL]         delegateBooleanAssertion(types, 11, 10, false); [EOL]         // list12 = list10; [EOL]         delegateBooleanAssertion(types, 10, 12, false); [EOL]         // list10 = list12; [EOL]         delegateBooleanAssertion(types, 12, 10, false); [EOL]         list13 = list10; [EOL]         delegateBooleanAssertion(types, 10, 13, true); [EOL]         list10 = (List<? super Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 10, false); [EOL] //        list11 = list11; [EOL]         delegateBooleanAssertion(types, 11, 11, true); [EOL]         list12 = list11; [EOL]         delegateBooleanAssertion(types, 11, 12, true); [EOL]         list11 = (List<String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 11, false); [EOL]         list13 = list11; [EOL]         delegateBooleanAssertion(types, 11, 13, true); [EOL]         list11 = (List<String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 11, false); [EOL] //        list12 = list12; [EOL]         delegateBooleanAssertion(types, 12, 12, true); [EOL]         list13 = (List<? super String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 13, false); [EOL]         list12 = (List<? extends String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 12, false); [EOL] //        list13 = list13; [EOL]         delegateBooleanAssertion(types, 13, 13, true); [EOL]         final Type disType = getClass().getField("dis").getGenericType(); [EOL]         // Reporter.log( ( ( ParameterizedType ) disType [EOL]         // ).getOwnerType().getClass().toString() ); [EOL]         final Type datType = getClass().getField("dat").getGenericType(); [EOL]         final Type daType = getClass().getField("da").getGenericType(); [EOL]         final Type uhderType = getClass().getField("uhder").getGenericType(); [EOL]         final Type dingType = getClass().getField("ding").getGenericType(); [EOL]         final Type testerType = getClass().getField("tester").getGenericType(); [EOL]         final Type tester2Type = getClass().getField("tester2").getGenericType(); [EOL]         final Type dat2Type = getClass().getField("dat2").getGenericType(); [EOL]         final Type dat3Type = getClass().getField("dat3").getGenericType(); [EOL]         dis = dat; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(datType, disType)); [EOL]         // dis = da; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(daType, disType)); [EOL]         dis = uhder; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(uhderType, disType)); [EOL]         dis = ding; [EOL]         Assert.assertFalse(String.format("type %s not assignable to %s!", dingType, disType), [EOL]                 TypeUtils.isAssignable(dingType, disType)); [EOL]         dis = tester; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(testerType, disType)); [EOL]         // dis = tester2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(tester2Type, disType)); [EOL]         // dat = dat2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat2Type, datType)); [EOL]         // dat2 = dat; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(datType, dat2Type)); [EOL]         // dat = dat3; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat3Type, datType)); [EOL]         final char ch = 0; [EOL]         final boolean bo = false; [EOL]         final byte by = 0; [EOL]         final short sh = 0; [EOL]         int in = 0; [EOL]         long lo = 0; [EOL]         final float fl = 0; [EOL]         double du = 0; [EOL]         du = ch; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(char.class, double.class)); [EOL]         du = by; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(byte.class, double.class)); [EOL]         du = sh; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(short.class, double.class)); [EOL]         du = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, double.class)); [EOL]         du = lo; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(long.class, double.class)); [EOL]         du = fl; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(float.class, double.class)); [EOL]         lo = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, long.class)); [EOL]         lo = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, long.class)); [EOL]         // Long lngW = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, Long.class)); [EOL]         // lngW = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, Long.class)); [EOL]         in = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, int.class)); [EOL]         final Integer inte = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Integer.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Number.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Object.class)); [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, intComparableType)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Comparable.class)); [EOL]         final Serializable ser = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Serializable.class)); [EOL]         final Type longComparableType = getClass().getField("longComparable").getGenericType(); [EOL]         // longComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, longComparableType)); [EOL]         // longComparable = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, longComparableType)); [EOL]         // int[] ia; [EOL]         // long[] la = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, long[].class)); [EOL]         final Integer[] ia = null; [EOL]         final Type caType = getClass().getField("intWildcardComparable").getGenericType(); [EOL]         intWildcardComparable = ia; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, caType)); [EOL]         // int[] ina = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer[].class, int[].class)); [EOL]         final int[] ina = null; [EOL]         Object[] oa; [EOL]         // oa = ina; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, Object[].class)); [EOL]         oa = new Integer[0]; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, Object[].class)); [EOL]         final Type bClassType = AClass.class.getField("bClass").getGenericType(); [EOL]         final Type cClassType = AClass.class.getField("cClass").getGenericType(); [EOL]         final Type dClassType = AClass.class.getField("dClass").getGenericType(); [EOL]         final Type eClassType = AClass.class.getField("eClass").getGenericType(); [EOL]         final Type fClassType = AClass.class.getField("fClass").getGenericType(); [EOL]         final AClass aClass = new AClass(new AAClass<String>()); [EOL]         aClass.bClass = aClass.cClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(cClassType, bClassType)); [EOL]         aClass.bClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, bClassType)); [EOL]         aClass.bClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, bClassType)); [EOL]         aClass.bClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, bClassType)); [EOL]         aClass.cClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, cClassType)); [EOL]         aClass.cClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, cClassType)); [EOL]         aClass.cClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, cClassType)); [EOL]         aClass.dClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, dClassType)); [EOL]         aClass.dClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, dClassType)); [EOL]         aClass.eClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, eClassType)); [EOL]     } [EOL]  [EOL]     public void delegateBooleanAssertion(final Type[] types, final int i2, final int i1, final boolean expected) { [EOL]         final Type type1 = types[i1]; [EOL]         final Type type2 = types[i2]; [EOL]         final boolean isAssignable = TypeUtils.isAssignable(type2, type1); [EOL]  [EOL]         if (expected) { [EOL]             Assert.assertTrue("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } else { [EOL]             Assert.assertFalse("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } [EOL]     } [EOL]  [EOL]     @SuppressWarnings("boxing") // boxing is deliberate here [EOL]
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [EOL]         final Type[] types = method.getGenericParameterTypes(); [EOL] //        list0 = list0; [EOL]         delegateBooleanAssertion(types, 0, 0, true); [EOL]         list1 = list0; [EOL]         delegateBooleanAssertion(types, 0, 1, true); [EOL]         list0 = list1; [EOL]         delegateBooleanAssertion(types, 1, 0, true); [EOL]         list2 = list0; [EOL]         delegateBooleanAssertion(types, 0, 2, true); [EOL]         list0 = list2; [EOL]         delegateBooleanAssertion(types, 2, 0, true); [EOL]         list3 = list0; [EOL]         delegateBooleanAssertion(types, 0, 3, true); [EOL]         list0 = list3; [EOL]         delegateBooleanAssertion(types, 3, 0, true); [EOL]         list4 = list0; [EOL]         delegateBooleanAssertion(types, 0, 4, true); [EOL]         list0 = list4; [EOL]         delegateBooleanAssertion(types, 4, 0, true); [EOL]         list5 = list0; [EOL]         delegateBooleanAssertion(types, 0, 5, true); [EOL]         list0 = list5; [EOL]         delegateBooleanAssertion(types, 5, 0, true); [EOL]         list6 = list0; [EOL]         delegateBooleanAssertion(types, 0, 6, true); [EOL]         list0 = list6; [EOL]         delegateBooleanAssertion(types, 6, 0, true); [EOL] //        list1 = list1; [EOL]         delegateBooleanAssertion(types, 1, 1, true); [EOL]         list2 = list1; [EOL]         delegateBooleanAssertion(types, 1, 2, true); [EOL]         list1 = (List<Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 1, false); [EOL]         list3 = list1; [EOL]         delegateBooleanAssertion(types, 1, 3, true); [EOL]         list1 = (List<Object>) list3; [EOL]         delegateBooleanAssertion(types, 3, 1, false); [EOL]         // list4 = list1; [EOL]         delegateBooleanAssertion(types, 1, 4, false); [EOL]         // list1 = list4; [EOL]         delegateBooleanAssertion(types, 4, 1, false); [EOL]         // list5 = list1; [EOL]         delegateBooleanAssertion(types, 1, 5, false); [EOL]         // list1 = list5; [EOL]         delegateBooleanAssertion(types, 5, 1, false); [EOL]         list6 = list1; [EOL]         delegateBooleanAssertion(types, 1, 6, true); [EOL]         list1 = (List<Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 1, false); [EOL] //        list2 = list2; [EOL]         delegateBooleanAssertion(types, 2, 2, true); [EOL]         list2 = list3; [EOL]         delegateBooleanAssertion(types, 2, 3, false); [EOL]         list2 = list4; [EOL]         delegateBooleanAssertion(types, 3, 2, true); [EOL]         list3 = (List<? super Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 4, false); [EOL]         list2 = list5; [EOL]         delegateBooleanAssertion(types, 4, 2, true); [EOL]         list4 = (List<String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 5, false); [EOL]         list2 = list6; [EOL]         delegateBooleanAssertion(types, 5, 2, true); [EOL]         list5 = (List<? extends String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 6, false); [EOL] //        list3 = list3; [EOL]         delegateBooleanAssertion(types, 6, 2, true); [EOL]         list6 = (List<? super String>) list2; [EOL]         delegateBooleanAssertion(types, 3, 3, true); [EOL]         // list4 = list3; [EOL]         delegateBooleanAssertion(types, 3, 4, false); [EOL]         // list3 = list4; [EOL]         delegateBooleanAssertion(types, 4, 3, false); [EOL]         // list5 = list3; [EOL]         delegateBooleanAssertion(types, 3, 5, false); [EOL]         // list3 = list5; [EOL]         delegateBooleanAssertion(types, 5, 3, false); [EOL]         list6 = list3; [EOL]         delegateBooleanAssertion(types, 3, 6, true); [EOL]         list3 = (List<? super Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 3, false); [EOL] //        list4 = list4; [EOL]         delegateBooleanAssertion(types, 4, 4, true); [EOL]         list5 = list4; [EOL]         delegateBooleanAssertion(types, 4, 5, true); [EOL]         list4 = (List<String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 4, false); [EOL]         list6 = list4; [EOL]         delegateBooleanAssertion(types, 4, 6, true); [EOL]         list4 = (List<String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 4, false); [EOL] //        list5 = list5; [EOL]         delegateBooleanAssertion(types, 5, 5, true); [EOL]         list6 = (List<? super String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 6, false); [EOL]         list5 = (List<? extends String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 5, false); [EOL] //        list6 = list6; [EOL]         delegateBooleanAssertion(types, 6, 6, true); [EOL]  [EOL] //        list7 = list7; [EOL]         delegateBooleanAssertion(types, 7, 7, true); [EOL]         list8 = list7; [EOL]         delegateBooleanAssertion(types, 7, 8, true); [EOL]         list7 = list8; [EOL]         delegateBooleanAssertion(types, 8, 7, true); [EOL]         list9 = list7; [EOL]         delegateBooleanAssertion(types, 7, 9, true); [EOL]         list7 = list9; [EOL]         delegateBooleanAssertion(types, 9, 7, true); [EOL]         list10 = list7; [EOL]         delegateBooleanAssertion(types, 7, 10, true); [EOL]         list7 = list10; [EOL]         delegateBooleanAssertion(types, 10, 7, true); [EOL]         list11 = list7; [EOL]         delegateBooleanAssertion(types, 7, 11, true); [EOL]         list7 = list11; [EOL]         delegateBooleanAssertion(types, 11, 7, true); [EOL]         list12 = list7; [EOL]         delegateBooleanAssertion(types, 7, 12, true); [EOL]         list7 = list12; [EOL]         delegateBooleanAssertion(types, 12, 7, true); [EOL]         list13 = list7; [EOL]         delegateBooleanAssertion(types, 7, 13, true); [EOL]         list7 = list13; [EOL]         delegateBooleanAssertion(types, 13, 7, true); [EOL] //        list8 = list8; [EOL]         delegateBooleanAssertion(types, 8, 8, true); [EOL]         list9 = list8; [EOL]         delegateBooleanAssertion(types, 8, 9, true); [EOL]         list8 = (List<Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 8, false); [EOL]         list10 = list8; [EOL]         delegateBooleanAssertion(types, 8, 10, true); [EOL]         list8 = (List<Object>[]) list10; // NOTE cast is required by Sun Java, but not by Eclipse [EOL]         delegateBooleanAssertion(types, 10, 8, false); [EOL]         // list11 = list8; [EOL]         delegateBooleanAssertion(types, 8, 11, false); [EOL]         // list8 = list11; [EOL]         delegateBooleanAssertion(types, 11, 8, false); [EOL]         // list12 = list8; [EOL]         delegateBooleanAssertion(types, 8, 12, false); [EOL]         // list8 = list12; [EOL]         delegateBooleanAssertion(types, 12, 8, false); [EOL]         list13 = list8; [EOL]         delegateBooleanAssertion(types, 8, 13, true); [EOL]         list8 = (List<Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 8, false); [EOL] //        list9 = list9; [EOL]         delegateBooleanAssertion(types, 9, 9, true); [EOL]         list10 = (List<? super Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 10, false); [EOL]         list9 = list10; [EOL]         delegateBooleanAssertion(types, 10, 9, true); [EOL]         list11 = (List<String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 11, false); [EOL]         list9 = list11; [EOL]         delegateBooleanAssertion(types, 11, 9, true); [EOL]         list12 = (List<? extends String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 12, false); [EOL]         list9 = list12; [EOL]         delegateBooleanAssertion(types, 12, 9, true); [EOL]         list13 = (List<? super String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 13, false); [EOL]         list9 = list13; [EOL]         delegateBooleanAssertion(types, 13, 9, true); [EOL] //        list10 = list10; [EOL]         delegateBooleanAssertion(types, 10, 10, true); [EOL]         // list11 = list10; [EOL]         delegateBooleanAssertion(types, 10, 11, false); [EOL]         // list10 = list11; [EOL]         delegateBooleanAssertion(types, 11, 10, false); [EOL]         // list12 = list10; [EOL]         delegateBooleanAssertion(types, 10, 12, false); [EOL]         // list10 = list12; [EOL]         delegateBooleanAssertion(types, 12, 10, false); [EOL]         list13 = list10; [EOL]         delegateBooleanAssertion(types, 10, 13, true); [EOL]         list10 = (List<? super Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 10, false); [EOL] //        list11 = list11; [EOL]         delegateBooleanAssertion(types, 11, 11, true); [EOL]         list12 = list11; [EOL]         delegateBooleanAssertion(types, 11, 12, true); [EOL]         list11 = (List<String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 11, false); [EOL]         list13 = list11; [EOL]         delegateBooleanAssertion(types, 11, 13, true); [EOL]         list11 = (List<String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 11, false); [EOL] //        list12 = list12; [EOL]         delegateBooleanAssertion(types, 12, 12, true); [EOL]         list13 = (List<? super String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 13, false); [EOL]         list12 = (List<? extends String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 12, false); [EOL] //        list13 = list13; [EOL]         delegateBooleanAssertion(types, 13, 13, true); [EOL]         final Type disType = getClass().getField("dis").getGenericType(); [EOL]         // Reporter.log( ( ( ParameterizedType ) disType [EOL]         // ).getOwnerType().getClass().toString() ); [EOL]         final Type datType = getClass().getField("dat").getGenericType(); [EOL]         final Type daType = getClass().getField("da").getGenericType(); [EOL]         final Type uhderType = getClass().getField("uhder").getGenericType(); [EOL]         final Type dingType = getClass().getField("ding").getGenericType(); [EOL]         final Type testerType = getClass().getField("tester").getGenericType(); [EOL]         final Type tester2Type = getClass().getField("tester2").getGenericType(); [EOL]         final Type dat2Type = getClass().getField("dat2").getGenericType(); [EOL]         final Type dat3Type = getClass().getField("dat3").getGenericType(); [EOL]         dis = dat; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(datType, disType)); [EOL]         // dis = da; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(daType, disType)); [EOL]         dis = uhder; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(uhderType, disType)); [EOL]         dis = ding; [EOL]         Assert.assertFalse(String.format("type %s not assignable to %s!", dingType, disType), [EOL]                 TypeUtils.isAssignable(dingType, disType)); [EOL]         dis = tester; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(testerType, disType)); [EOL]         // dis = tester2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(tester2Type, disType)); [EOL]         // dat = dat2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat2Type, datType)); [EOL]         // dat2 = dat; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(datType, dat2Type)); [EOL]         // dat = dat3; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat3Type, datType)); [EOL]         final char ch = 0; [EOL]         final boolean bo = false; [EOL]         final byte by = 0; [EOL]         final short sh = 0; [EOL]         int in = 0; [EOL]         long lo = 0; [EOL]         final float fl = 0; [EOL]         double du = 0; [EOL]         du = ch; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(char.class, double.class)); [EOL]         du = by; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(byte.class, double.class)); [EOL]         du = sh; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(short.class, double.class)); [EOL]         du = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, double.class)); [EOL]         du = lo; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(long.class, double.class)); [EOL]         du = fl; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(float.class, double.class)); [EOL]         lo = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, long.class)); [EOL]         lo = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, long.class)); [EOL]         // Long lngW = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, Long.class)); [EOL]         // lngW = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, Long.class)); [EOL]         in = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, int.class)); [EOL]         final Integer inte = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Integer.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Number.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Object.class)); [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, intComparableType)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Comparable.class)); [EOL]         final Serializable ser = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Serializable.class)); [EOL]         final Type longComparableType = getClass().getField("longComparable").getGenericType(); [EOL]         // longComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, longComparableType)); [EOL]         // longComparable = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, longComparableType)); [EOL]         // int[] ia; [EOL]         // long[] la = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, long[].class)); [EOL]         final Integer[] ia = null; [EOL]         final Type caType = getClass().getField("intWildcardComparable").getGenericType(); [EOL]         intWildcardComparable = ia; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, caType)); [EOL]         // int[] ina = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer[].class, int[].class)); [EOL]         final int[] ina = null; [EOL]         Object[] oa; [EOL]         // oa = ina; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, Object[].class)); [EOL]         oa = new Integer[0]; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, Object[].class)); [EOL]         final Type bClassType = AClass.class.getField("bClass").getGenericType(); [EOL]         final Type cClassType = AClass.class.getField("cClass").getGenericType(); [EOL]         final Type dClassType = AClass.class.getField("dClass").getGenericType(); [EOL]         final Type eClassType = AClass.class.getField("eClass").getGenericType(); [EOL]         final Type fClassType = AClass.class.getField("fClass").getGenericType(); [EOL]         final AClass aClass = new AClass(new AAClass<String>()); [EOL]         aClass.bClass = aClass.cClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(cClassType, bClassType)); [EOL]         aClass.bClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, bClassType)); [EOL]         aClass.bClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, bClassType)); [EOL]         aClass.bClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, bClassType)); [EOL]         aClass.cClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, cClassType)); [EOL]         aClass.cClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, cClassType)); [EOL]         aClass.cClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, cClassType)); [EOL]         aClass.dClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, dClassType)); [EOL]         aClass.dClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, dClassType)); [EOL]         aClass.eClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, eClassType)); [EOL]     } [EOL]  [EOL]     public void delegateBooleanAssertion(final Type[] types, final int i2, final int i1, final boolean expected) { [EOL]         final Type type1 = types[i1]; [EOL]         final Type type2 = types[i2]; [EOL]         final boolean isAssignable = TypeUtils.isAssignable(type2, type1); [EOL]  [EOL]         if (expected) { [EOL]             Assert.assertTrue("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } else { [EOL]             Assert.assertFalse("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } [EOL]     } [EOL]  [EOL]     @SuppressWarnings("boxing") // boxing is deliberate here [EOL]
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [EOL]         final Type[] types = method.getGenericParameterTypes(); [EOL] //        list0 = list0; [EOL]         delegateBooleanAssertion(types, 0, 0, true); [EOL]         list1 = list0; [EOL]         delegateBooleanAssertion(types, 0, 1, true); [EOL]         list0 = list1; [EOL]         delegateBooleanAssertion(types, 1, 0, true); [EOL]         list2 = list0; [EOL]         delegateBooleanAssertion(types, 0, 2, true); [EOL]         list0 = list2; [EOL]         delegateBooleanAssertion(types, 2, 0, true); [EOL]         list3 = list0; [EOL]         delegateBooleanAssertion(types, 0, 3, true); [EOL]         list0 = list3; [EOL]         delegateBooleanAssertion(types, 3, 0, true); [EOL]         list4 = list0; [EOL]         delegateBooleanAssertion(types, 0, 4, true); [EOL]         list0 = list4; [EOL]         delegateBooleanAssertion(types, 4, 0, true); [EOL]         list5 = list0; [EOL]         delegateBooleanAssertion(types, 0, 5, true); [EOL]         list0 = list5; [EOL]         delegateBooleanAssertion(types, 5, 0, true); [EOL]         list6 = list0; [EOL]         delegateBooleanAssertion(types, 0, 6, true); [EOL]         list0 = list6; [EOL]         delegateBooleanAssertion(types, 6, 0, true); [EOL] //        list1 = list1; [EOL]         delegateBooleanAssertion(types, 1, 1, true); [EOL]         list2 = list1; [EOL]         delegateBooleanAssertion(types, 1, 2, true); [EOL]         list1 = (List<Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 1, false); [EOL]         list3 = list1; [EOL]         delegateBooleanAssertion(types, 1, 3, true); [EOL]         list1 = (List<Object>) list3; [EOL]         delegateBooleanAssertion(types, 3, 1, false); [EOL]         // list4 = list1; [EOL]         delegateBooleanAssertion(types, 1, 4, false); [EOL]         // list1 = list4; [EOL]         delegateBooleanAssertion(types, 4, 1, false); [EOL]         // list5 = list1; [EOL]         delegateBooleanAssertion(types, 1, 5, false); [EOL]         // list1 = list5; [EOL]         delegateBooleanAssertion(types, 5, 1, false); [EOL]         list6 = list1; [EOL]         delegateBooleanAssertion(types, 1, 6, true); [EOL]         list1 = (List<Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 1, false); [EOL] //        list2 = list2; [EOL]         delegateBooleanAssertion(types, 2, 2, true); [EOL]         list2 = list3; [EOL]         delegateBooleanAssertion(types, 2, 3, false); [EOL]         list2 = list4; [EOL]         delegateBooleanAssertion(types, 3, 2, true); [EOL]         list3 = (List<? super Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 4, false); [EOL]         list2 = list5; [EOL]         delegateBooleanAssertion(types, 4, 2, true); [EOL]         list4 = (List<String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 5, false); [EOL]         list2 = list6; [EOL]         delegateBooleanAssertion(types, 5, 2, true); [EOL]         list5 = (List<? extends String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 6, false); [EOL] //        list3 = list3; [EOL]         delegateBooleanAssertion(types, 6, 2, true); [EOL]         list6 = (List<? super String>) list2; [EOL]         delegateBooleanAssertion(types, 3, 3, true); [EOL]         // list4 = list3; [EOL]         delegateBooleanAssertion(types, 3, 4, false); [EOL]         // list3 = list4; [EOL]         delegateBooleanAssertion(types, 4, 3, false); [EOL]         // list5 = list3; [EOL]         delegateBooleanAssertion(types, 3, 5, false); [EOL]         // list3 = list5; [EOL]         delegateBooleanAssertion(types, 5, 3, false); [EOL]         list6 = list3; [EOL]         delegateBooleanAssertion(types, 3, 6, true); [EOL]         list3 = (List<? super Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 3, false); [EOL] //        list4 = list4; [EOL]         delegateBooleanAssertion(types, 4, 4, true); [EOL]         list5 = list4; [EOL]         delegateBooleanAssertion(types, 4, 5, true); [EOL]         list4 = (List<String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 4, false); [EOL]         list6 = list4; [EOL]         delegateBooleanAssertion(types, 4, 6, true); [EOL]         list4 = (List<String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 4, false); [EOL] //        list5 = list5; [EOL]         delegateBooleanAssertion(types, 5, 5, true); [EOL]         list6 = (List<? super String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 6, false); [EOL]         list5 = (List<? extends String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 5, false); [EOL] //        list6 = list6; [EOL]         delegateBooleanAssertion(types, 6, 6, true); [EOL]  [EOL] //        list7 = list7; [EOL]         delegateBooleanAssertion(types, 7, 7, true); [EOL]         list8 = list7; [EOL]         delegateBooleanAssertion(types, 7, 8, true); [EOL]         list7 = list8; [EOL]         delegateBooleanAssertion(types, 8, 7, true); [EOL]         list9 = list7; [EOL]         delegateBooleanAssertion(types, 7, 9, true); [EOL]         list7 = list9; [EOL]         delegateBooleanAssertion(types, 9, 7, true); [EOL]         list10 = list7; [EOL]         delegateBooleanAssertion(types, 7, 10, true); [EOL]         list7 = list10; [EOL]         delegateBooleanAssertion(types, 10, 7, true); [EOL]         list11 = list7; [EOL]         delegateBooleanAssertion(types, 7, 11, true); [EOL]         list7 = list11; [EOL]         delegateBooleanAssertion(types, 11, 7, true); [EOL]         list12 = list7; [EOL]         delegateBooleanAssertion(types, 7, 12, true); [EOL]         list7 = list12; [EOL]         delegateBooleanAssertion(types, 12, 7, true); [EOL]         list13 = list7; [EOL]         delegateBooleanAssertion(types, 7, 13, true); [EOL]         list7 = list13; [EOL]         delegateBooleanAssertion(types, 13, 7, true); [EOL] //        list8 = list8; [EOL]         delegateBooleanAssertion(types, 8, 8, true); [EOL]         list9 = list8; [EOL]         delegateBooleanAssertion(types, 8, 9, true); [EOL]         list8 = (List<Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 8, false); [EOL]         list10 = list8; [EOL]         delegateBooleanAssertion(types, 8, 10, true); [EOL]         list8 = (List<Object>[]) list10; // NOTE cast is required by Sun Java, but not by Eclipse [EOL]         delegateBooleanAssertion(types, 10, 8, false); [EOL]         // list11 = list8; [EOL]         delegateBooleanAssertion(types, 8, 11, false); [EOL]         // list8 = list11; [EOL]         delegateBooleanAssertion(types, 11, 8, false); [EOL]         // list12 = list8; [EOL]         delegateBooleanAssertion(types, 8, 12, false); [EOL]         // list8 = list12; [EOL]         delegateBooleanAssertion(types, 12, 8, false); [EOL]         list13 = list8; [EOL]         delegateBooleanAssertion(types, 8, 13, true); [EOL]         list8 = (List<Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 8, false); [EOL] //        list9 = list9; [EOL]         delegateBooleanAssertion(types, 9, 9, true); [EOL]         list10 = (List<? super Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 10, false); [EOL]         list9 = list10; [EOL]         delegateBooleanAssertion(types, 10, 9, true); [EOL]         list11 = (List<String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 11, false); [EOL]         list9 = list11; [EOL]         delegateBooleanAssertion(types, 11, 9, true); [EOL]         list12 = (List<? extends String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 12, false); [EOL]         list9 = list12; [EOL]         delegateBooleanAssertion(types, 12, 9, true); [EOL]         list13 = (List<? super String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 13, false); [EOL]         list9 = list13; [EOL]         delegateBooleanAssertion(types, 13, 9, true); [EOL] //        list10 = list10; [EOL]         delegateBooleanAssertion(types, 10, 10, true); [EOL]         // list11 = list10; [EOL]         delegateBooleanAssertion(types, 10, 11, false); [EOL]         // list10 = list11; [EOL]         delegateBooleanAssertion(types, 11, 10, false); [EOL]         // list12 = list10; [EOL]         delegateBooleanAssertion(types, 10, 12, false); [EOL]         // list10 = list12; [EOL]         delegateBooleanAssertion(types, 12, 10, false); [EOL]         list13 = list10; [EOL]         delegateBooleanAssertion(types, 10, 13, true); [EOL]         list10 = (List<? super Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 10, false); [EOL] //        list11 = list11; [EOL]         delegateBooleanAssertion(types, 11, 11, true); [EOL]         list12 = list11; [EOL]         delegateBooleanAssertion(types, 11, 12, true); [EOL]         list11 = (List<String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 11, false); [EOL]         list13 = list11; [EOL]         delegateBooleanAssertion(types, 11, 13, true); [EOL]         list11 = (List<String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 11, false); [EOL] //        list12 = list12; [EOL]         delegateBooleanAssertion(types, 12, 12, true); [EOL]         list13 = (List<? super String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 13, false); [EOL]         list12 = (List<? extends String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 12, false); [EOL] //        list13 = list13; [EOL]         delegateBooleanAssertion(types, 13, 13, true); [EOL]         final Type disType = getClass().getField("dis").getGenericType(); [EOL]         // Reporter.log( ( ( ParameterizedType ) disType [EOL]         // ).getOwnerType().getClass().toString() ); [EOL]         final Type datType = getClass().getField("dat").getGenericType(); [EOL]         final Type daType = getClass().getField("da").getGenericType(); [EOL]         final Type uhderType = getClass().getField("uhder").getGenericType(); [EOL]         final Type dingType = getClass().getField("ding").getGenericType(); [EOL]         final Type testerType = getClass().getField("tester").getGenericType(); [EOL]         final Type tester2Type = getClass().getField("tester2").getGenericType(); [EOL]         final Type dat2Type = getClass().getField("dat2").getGenericType(); [EOL]         final Type dat3Type = getClass().getField("dat3").getGenericType(); [EOL]         dis = dat; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(datType, disType)); [EOL]         // dis = da; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(daType, disType)); [EOL]         dis = uhder; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(uhderType, disType)); [EOL]         dis = ding; [EOL]         Assert.assertFalse(String.format("type %s not assignable to %s!", dingType, disType), [EOL]                 TypeUtils.isAssignable(dingType, disType)); [EOL]         dis = tester; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(testerType, disType)); [EOL]         // dis = tester2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(tester2Type, disType)); [EOL]         // dat = dat2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat2Type, datType)); [EOL]         // dat2 = dat; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(datType, dat2Type)); [EOL]         // dat = dat3; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat3Type, datType)); [EOL]         final char ch = 0; [EOL]         final boolean bo = false; [EOL]         final byte by = 0; [EOL]         final short sh = 0; [EOL]         int in = 0; [EOL]         long lo = 0; [EOL]         final float fl = 0; [EOL]         double du = 0; [EOL]         du = ch; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(char.class, double.class)); [EOL]         du = by; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(byte.class, double.class)); [EOL]         du = sh; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(short.class, double.class)); [EOL]         du = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, double.class)); [EOL]         du = lo; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(long.class, double.class)); [EOL]         du = fl; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(float.class, double.class)); [EOL]         lo = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, long.class)); [EOL]         lo = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, long.class)); [EOL]         // Long lngW = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, Long.class)); [EOL]         // lngW = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, Long.class)); [EOL]         in = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, int.class)); [EOL]         final Integer inte = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Integer.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Number.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Object.class)); [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, intComparableType)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Comparable.class)); [EOL]         final Serializable ser = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Serializable.class)); [EOL]         final Type longComparableType = getClass().getField("longComparable").getGenericType(); [EOL]         // longComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, longComparableType)); [EOL]         // longComparable = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, longComparableType)); [EOL]         // int[] ia; [EOL]         // long[] la = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, long[].class)); [EOL]         final Integer[] ia = null; [EOL]         final Type caType = getClass().getField("intWildcardComparable").getGenericType(); [EOL]         intWildcardComparable = ia; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, caType)); [EOL]         // int[] ina = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer[].class, int[].class)); [EOL]         final int[] ina = null; [EOL]         Object[] oa; [EOL]         // oa = ina; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, Object[].class)); [EOL]         oa = new Integer[0]; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, Object[].class)); [EOL]         final Type bClassType = AClass.class.getField("bClass").getGenericType(); [EOL]         final Type cClassType = AClass.class.getField("cClass").getGenericType(); [EOL]         final Type dClassType = AClass.class.getField("dClass").getGenericType(); [EOL]         final Type eClassType = AClass.class.getField("eClass").getGenericType(); [EOL]         final Type fClassType = AClass.class.getField("fClass").getGenericType(); [EOL]         final AClass aClass = new AClass(new AAClass<String>()); [EOL]         aClass.bClass = aClass.cClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(cClassType, bClassType)); [EOL]         aClass.bClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, bClassType)); [EOL]         aClass.bClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, bClassType)); [EOL]         aClass.bClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, bClassType)); [EOL]         aClass.cClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, cClassType)); [EOL]         aClass.cClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, cClassType)); [EOL]         aClass.cClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, cClassType)); [EOL]         aClass.dClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, dClassType)); [EOL]         aClass.dClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, dClassType)); [EOL]         aClass.eClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, eClassType)); [EOL]     } [EOL]  [EOL]     public void delegateBooleanAssertion(final Type[] types, final int i2, final int i1, final boolean expected) { [EOL]         final Type type1 = types[i1]; [EOL]         final Type type2 = types[i2]; [EOL]         final boolean isAssignable = TypeUtils.isAssignable(type2, type1); [EOL]  [EOL]         if (expected) { [EOL]             Assert.assertTrue("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } else { [EOL]             Assert.assertFalse("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } [EOL]     } [EOL]  [EOL]     @SuppressWarnings("boxing") // boxing is deliberate here [EOL]
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [EOL]         final Type[] types = method.getGenericParameterTypes(); [EOL] //        list0 = list0; [EOL]         delegateBooleanAssertion(types, 0, 0, true); [EOL]         list1 = list0; [EOL]         delegateBooleanAssertion(types, 0, 1, true); [EOL]         list0 = list1; [EOL]         delegateBooleanAssertion(types, 1, 0, true); [EOL]         list2 = list0; [EOL]         delegateBooleanAssertion(types, 0, 2, true); [EOL]         list0 = list2; [EOL]         delegateBooleanAssertion(types, 2, 0, true); [EOL]         list3 = list0; [EOL]         delegateBooleanAssertion(types, 0, 3, true); [EOL]         list0 = list3; [EOL]         delegateBooleanAssertion(types, 3, 0, true); [EOL]         list4 = list0; [EOL]         delegateBooleanAssertion(types, 0, 4, true); [EOL]         list0 = list4; [EOL]         delegateBooleanAssertion(types, 4, 0, true); [EOL]         list5 = list0; [EOL]         delegateBooleanAssertion(types, 0, 5, true); [EOL]         list0 = list5; [EOL]         delegateBooleanAssertion(types, 5, 0, true); [EOL]         list6 = list0; [EOL]         delegateBooleanAssertion(types, 0, 6, true); [EOL]         list0 = list6; [EOL]         delegateBooleanAssertion(types, 6, 0, true); [EOL] //        list1 = list1; [EOL]         delegateBooleanAssertion(types, 1, 1, true); [EOL]         list2 = list1; [EOL]         delegateBooleanAssertion(types, 1, 2, true); [EOL]         list1 = (List<Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 1, false); [EOL]         list3 = list1; [EOL]         delegateBooleanAssertion(types, 1, 3, true); [EOL]         list1 = (List<Object>) list3; [EOL]         delegateBooleanAssertion(types, 3, 1, false); [EOL]         // list4 = list1; [EOL]         delegateBooleanAssertion(types, 1, 4, false); [EOL]         // list1 = list4; [EOL]         delegateBooleanAssertion(types, 4, 1, false); [EOL]         // list5 = list1; [EOL]         delegateBooleanAssertion(types, 1, 5, false); [EOL]         // list1 = list5; [EOL]         delegateBooleanAssertion(types, 5, 1, false); [EOL]         list6 = list1; [EOL]         delegateBooleanAssertion(types, 1, 6, true); [EOL]         list1 = (List<Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 1, false); [EOL] //        list2 = list2; [EOL]         delegateBooleanAssertion(types, 2, 2, true); [EOL]         list2 = list3; [EOL]         delegateBooleanAssertion(types, 2, 3, false); [EOL]         list2 = list4; [EOL]         delegateBooleanAssertion(types, 3, 2, true); [EOL]         list3 = (List<? super Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 4, false); [EOL]         list2 = list5; [EOL]         delegateBooleanAssertion(types, 4, 2, true); [EOL]         list4 = (List<String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 5, false); [EOL]         list2 = list6; [EOL]         delegateBooleanAssertion(types, 5, 2, true); [EOL]         list5 = (List<? extends String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 6, false); [EOL] //        list3 = list3; [EOL]         delegateBooleanAssertion(types, 6, 2, true); [EOL]         list6 = (List<? super String>) list2; [EOL]         delegateBooleanAssertion(types, 3, 3, true); [EOL]         // list4 = list3; [EOL]         delegateBooleanAssertion(types, 3, 4, false); [EOL]         // list3 = list4; [EOL]         delegateBooleanAssertion(types, 4, 3, false); [EOL]         // list5 = list3; [EOL]         delegateBooleanAssertion(types, 3, 5, false); [EOL]         // list3 = list5; [EOL]         delegateBooleanAssertion(types, 5, 3, false); [EOL]         list6 = list3; [EOL]         delegateBooleanAssertion(types, 3, 6, true); [EOL]         list3 = (List<? super Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 3, false); [EOL] //        list4 = list4; [EOL]         delegateBooleanAssertion(types, 4, 4, true); [EOL]         list5 = list4; [EOL]         delegateBooleanAssertion(types, 4, 5, true); [EOL]         list4 = (List<String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 4, false); [EOL]         list6 = list4; [EOL]         delegateBooleanAssertion(types, 4, 6, true); [EOL]         list4 = (List<String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 4, false); [EOL] //        list5 = list5; [EOL]         delegateBooleanAssertion(types, 5, 5, true); [EOL]         list6 = (List<? super String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 6, false); [EOL]         list5 = (List<? extends String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 5, false); [EOL] //        list6 = list6; [EOL]         delegateBooleanAssertion(types, 6, 6, true); [EOL]  [EOL] //        list7 = list7; [EOL]         delegateBooleanAssertion(types, 7, 7, true); [EOL]         list8 = list7; [EOL]         delegateBooleanAssertion(types, 7, 8, true); [EOL]         list7 = list8; [EOL]         delegateBooleanAssertion(types, 8, 7, true); [EOL]         list9 = list7; [EOL]         delegateBooleanAssertion(types, 7, 9, true); [EOL]         list7 = list9; [EOL]         delegateBooleanAssertion(types, 9, 7, true); [EOL]         list10 = list7; [EOL]         delegateBooleanAssertion(types, 7, 10, true); [EOL]         list7 = list10; [EOL]         delegateBooleanAssertion(types, 10, 7, true); [EOL]         list11 = list7; [EOL]         delegateBooleanAssertion(types, 7, 11, true); [EOL]         list7 = list11; [EOL]         delegateBooleanAssertion(types, 11, 7, true); [EOL]         list12 = list7; [EOL]         delegateBooleanAssertion(types, 7, 12, true); [EOL]         list7 = list12; [EOL]         delegateBooleanAssertion(types, 12, 7, true); [EOL]         list13 = list7; [EOL]         delegateBooleanAssertion(types, 7, 13, true); [EOL]         list7 = list13; [EOL]         delegateBooleanAssertion(types, 13, 7, true); [EOL] //        list8 = list8; [EOL]         delegateBooleanAssertion(types, 8, 8, true); [EOL]         list9 = list8; [EOL]         delegateBooleanAssertion(types, 8, 9, true); [EOL]         list8 = (List<Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 8, false); [EOL]         list10 = list8; [EOL]         delegateBooleanAssertion(types, 8, 10, true); [EOL]         list8 = (List<Object>[]) list10; // NOTE cast is required by Sun Java, but not by Eclipse [EOL]         delegateBooleanAssertion(types, 10, 8, false); [EOL]         // list11 = list8; [EOL]         delegateBooleanAssertion(types, 8, 11, false); [EOL]         // list8 = list11; [EOL]         delegateBooleanAssertion(types, 11, 8, false); [EOL]         // list12 = list8; [EOL]         delegateBooleanAssertion(types, 8, 12, false); [EOL]         // list8 = list12; [EOL]         delegateBooleanAssertion(types, 12, 8, false); [EOL]         list13 = list8; [EOL]         delegateBooleanAssertion(types, 8, 13, true); [EOL]         list8 = (List<Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 8, false); [EOL] //        list9 = list9; [EOL]         delegateBooleanAssertion(types, 9, 9, true); [EOL]         list10 = (List<? super Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 10, false); [EOL]         list9 = list10; [EOL]         delegateBooleanAssertion(types, 10, 9, true); [EOL]         list11 = (List<String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 11, false); [EOL]         list9 = list11; [EOL]         delegateBooleanAssertion(types, 11, 9, true); [EOL]         list12 = (List<? extends String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 12, false); [EOL]         list9 = list12; [EOL]         delegateBooleanAssertion(types, 12, 9, true); [EOL]         list13 = (List<? super String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 13, false); [EOL]         list9 = list13; [EOL]         delegateBooleanAssertion(types, 13, 9, true); [EOL] //        list10 = list10; [EOL]         delegateBooleanAssertion(types, 10, 10, true); [EOL]         // list11 = list10; [EOL]         delegateBooleanAssertion(types, 10, 11, false); [EOL]         // list10 = list11; [EOL]         delegateBooleanAssertion(types, 11, 10, false); [EOL]         // list12 = list10; [EOL]         delegateBooleanAssertion(types, 10, 12, false); [EOL]         // list10 = list12; [EOL]         delegateBooleanAssertion(types, 12, 10, false); [EOL]         list13 = list10; [EOL]         delegateBooleanAssertion(types, 10, 13, true); [EOL]         list10 = (List<? super Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 10, false); [EOL] //        list11 = list11; [EOL]         delegateBooleanAssertion(types, 11, 11, true); [EOL]         list12 = list11; [EOL]         delegateBooleanAssertion(types, 11, 12, true); [EOL]         list11 = (List<String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 11, false); [EOL]         list13 = list11; [EOL]         delegateBooleanAssertion(types, 11, 13, true); [EOL]         list11 = (List<String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 11, false); [EOL] //        list12 = list12; [EOL]         delegateBooleanAssertion(types, 12, 12, true); [EOL]         list13 = (List<? super String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 13, false); [EOL]         list12 = (List<? extends String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 12, false); [EOL] //        list13 = list13; [EOL]         delegateBooleanAssertion(types, 13, 13, true); [EOL]         final Type disType = getClass().getField("dis").getGenericType(); [EOL]         // Reporter.log( ( ( ParameterizedType ) disType [EOL]         // ).getOwnerType().getClass().toString() ); [EOL]         final Type datType = getClass().getField("dat").getGenericType(); [EOL]         final Type daType = getClass().getField("da").getGenericType(); [EOL]         final Type uhderType = getClass().getField("uhder").getGenericType(); [EOL]         final Type dingType = getClass().getField("ding").getGenericType(); [EOL]         final Type testerType = getClass().getField("tester").getGenericType(); [EOL]         final Type tester2Type = getClass().getField("tester2").getGenericType(); [EOL]         final Type dat2Type = getClass().getField("dat2").getGenericType(); [EOL]         final Type dat3Type = getClass().getField("dat3").getGenericType(); [EOL]         dis = dat; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(datType, disType)); [EOL]         // dis = da; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(daType, disType)); [EOL]         dis = uhder; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(uhderType, disType)); [EOL]         dis = ding; [EOL]         Assert.assertFalse(String.format("type %s not assignable to %s!", dingType, disType), [EOL]                 TypeUtils.isAssignable(dingType, disType)); [EOL]         dis = tester; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(testerType, disType)); [EOL]         // dis = tester2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(tester2Type, disType)); [EOL]         // dat = dat2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat2Type, datType)); [EOL]         // dat2 = dat; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(datType, dat2Type)); [EOL]         // dat = dat3; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat3Type, datType)); [EOL]         final char ch = 0; [EOL]         final boolean bo = false; [EOL]         final byte by = 0; [EOL]         final short sh = 0; [EOL]         int in = 0; [EOL]         long lo = 0; [EOL]         final float fl = 0; [EOL]         double du = 0; [EOL]         du = ch; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(char.class, double.class)); [EOL]         du = by; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(byte.class, double.class)); [EOL]         du = sh; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(short.class, double.class)); [EOL]         du = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, double.class)); [EOL]         du = lo; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(long.class, double.class)); [EOL]         du = fl; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(float.class, double.class)); [EOL]         lo = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, long.class)); [EOL]         lo = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, long.class)); [EOL]         // Long lngW = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, Long.class)); [EOL]         // lngW = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, Long.class)); [EOL]         in = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, int.class)); [EOL]         final Integer inte = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Integer.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Number.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Object.class)); [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, intComparableType)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Comparable.class)); [EOL]         final Serializable ser = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Serializable.class)); [EOL]         final Type longComparableType = getClass().getField("longComparable").getGenericType(); [EOL]         // longComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, longComparableType)); [EOL]         // longComparable = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, longComparableType)); [EOL]         // int[] ia; [EOL]         // long[] la = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, long[].class)); [EOL]         final Integer[] ia = null; [EOL]         final Type caType = getClass().getField("intWildcardComparable").getGenericType(); [EOL]         intWildcardComparable = ia; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, caType)); [EOL]         // int[] ina = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer[].class, int[].class)); [EOL]         final int[] ina = null; [EOL]         Object[] oa; [EOL]         // oa = ina; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, Object[].class)); [EOL]         oa = new Integer[0]; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, Object[].class)); [EOL]         final Type bClassType = AClass.class.getField("bClass").getGenericType(); [EOL]         final Type cClassType = AClass.class.getField("cClass").getGenericType(); [EOL]         final Type dClassType = AClass.class.getField("dClass").getGenericType(); [EOL]         final Type eClassType = AClass.class.getField("eClass").getGenericType(); [EOL]         final Type fClassType = AClass.class.getField("fClass").getGenericType(); [EOL]         final AClass aClass = new AClass(new AAClass<String>()); [EOL]         aClass.bClass = aClass.cClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(cClassType, bClassType)); [EOL]         aClass.bClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, bClassType)); [EOL]         aClass.bClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, bClassType)); [EOL]         aClass.bClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, bClassType)); [EOL]         aClass.cClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, cClassType)); [EOL]         aClass.cClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, cClassType)); [EOL]         aClass.cClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, cClassType)); [EOL]         aClass.dClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, dClassType)); [EOL]         aClass.dClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, dClassType)); [EOL]         aClass.eClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, eClassType)); [EOL]     } [EOL]  [EOL]     public void delegateBooleanAssertion(final Type[] types, final int i2, final int i1, final boolean expected) { [EOL]         final Type type1 = types[i1]; [EOL]         final Type type2 = types[i2]; [EOL]         final boolean isAssignable = TypeUtils.isAssignable(type2, type1); [EOL]  [EOL]         if (expected) { [EOL]             Assert.assertTrue("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } else { [EOL]             Assert.assertFalse("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } [EOL]     } [EOL]  [EOL]     @SuppressWarnings("boxing") // boxing is deliberate here [EOL]
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [EOL]         final Type[] types = method.getGenericParameterTypes(); [EOL] //        list0 = list0; [EOL]         delegateBooleanAssertion(types, 0, 0, true); [EOL]         list1 = list0; [EOL]         delegateBooleanAssertion(types, 0, 1, true); [EOL]         list0 = list1; [EOL]         delegateBooleanAssertion(types, 1, 0, true); [EOL]         list2 = list0; [EOL]         delegateBooleanAssertion(types, 0, 2, true); [EOL]         list0 = list2; [EOL]         delegateBooleanAssertion(types, 2, 0, true); [EOL]         list3 = list0; [EOL]         delegateBooleanAssertion(types, 0, 3, true); [EOL]         list0 = list3; [EOL]         delegateBooleanAssertion(types, 3, 0, true); [EOL]         list4 = list0; [EOL]         delegateBooleanAssertion(types, 0, 4, true); [EOL]         list0 = list4; [EOL]         delegateBooleanAssertion(types, 4, 0, true); [EOL]         list5 = list0; [EOL]         delegateBooleanAssertion(types, 0, 5, true); [EOL]         list0 = list5; [EOL]         delegateBooleanAssertion(types, 5, 0, true); [EOL]         list6 = list0; [EOL]         delegateBooleanAssertion(types, 0, 6, true); [EOL]         list0 = list6; [EOL]         delegateBooleanAssertion(types, 6, 0, true); [EOL] //        list1 = list1; [EOL]         delegateBooleanAssertion(types, 1, 1, true); [EOL]         list2 = list1; [EOL]         delegateBooleanAssertion(types, 1, 2, true); [EOL]         list1 = (List<Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 1, false); [EOL]         list3 = list1; [EOL]         delegateBooleanAssertion(types, 1, 3, true); [EOL]         list1 = (List<Object>) list3; [EOL]         delegateBooleanAssertion(types, 3, 1, false); [EOL]         // list4 = list1; [EOL]         delegateBooleanAssertion(types, 1, 4, false); [EOL]         // list1 = list4; [EOL]         delegateBooleanAssertion(types, 4, 1, false); [EOL]         // list5 = list1; [EOL]         delegateBooleanAssertion(types, 1, 5, false); [EOL]         // list1 = list5; [EOL]         delegateBooleanAssertion(types, 5, 1, false); [EOL]         list6 = list1; [EOL]         delegateBooleanAssertion(types, 1, 6, true); [EOL]         list1 = (List<Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 1, false); [EOL] //        list2 = list2; [EOL]         delegateBooleanAssertion(types, 2, 2, true); [EOL]         list2 = list3; [EOL]         delegateBooleanAssertion(types, 2, 3, false); [EOL]         list2 = list4; [EOL]         delegateBooleanAssertion(types, 3, 2, true); [EOL]         list3 = (List<? super Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 4, false); [EOL]         list2 = list5; [EOL]         delegateBooleanAssertion(types, 4, 2, true); [EOL]         list4 = (List<String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 5, false); [EOL]         list2 = list6; [EOL]         delegateBooleanAssertion(types, 5, 2, true); [EOL]         list5 = (List<? extends String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 6, false); [EOL] //        list3 = list3; [EOL]         delegateBooleanAssertion(types, 6, 2, true); [EOL]         list6 = (List<? super String>) list2; [EOL]         delegateBooleanAssertion(types, 3, 3, true); [EOL]         // list4 = list3; [EOL]         delegateBooleanAssertion(types, 3, 4, false); [EOL]         // list3 = list4; [EOL]         delegateBooleanAssertion(types, 4, 3, false); [EOL]         // list5 = list3; [EOL]         delegateBooleanAssertion(types, 3, 5, false); [EOL]         // list3 = list5; [EOL]         delegateBooleanAssertion(types, 5, 3, false); [EOL]         list6 = list3; [EOL]         delegateBooleanAssertion(types, 3, 6, true); [EOL]         list3 = (List<? super Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 3, false); [EOL] //        list4 = list4; [EOL]         delegateBooleanAssertion(types, 4, 4, true); [EOL]         list5 = list4; [EOL]         delegateBooleanAssertion(types, 4, 5, true); [EOL]         list4 = (List<String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 4, false); [EOL]         list6 = list4; [EOL]         delegateBooleanAssertion(types, 4, 6, true); [EOL]         list4 = (List<String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 4, false); [EOL] //        list5 = list5; [EOL]         delegateBooleanAssertion(types, 5, 5, true); [EOL]         list6 = (List<? super String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 6, false); [EOL]         list5 = (List<? extends String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 5, false); [EOL] //        list6 = list6; [EOL]         delegateBooleanAssertion(types, 6, 6, true); [EOL]  [EOL] //        list7 = list7; [EOL]         delegateBooleanAssertion(types, 7, 7, true); [EOL]         list8 = list7; [EOL]         delegateBooleanAssertion(types, 7, 8, true); [EOL]         list7 = list8; [EOL]         delegateBooleanAssertion(types, 8, 7, true); [EOL]         list9 = list7; [EOL]         delegateBooleanAssertion(types, 7, 9, true); [EOL]         list7 = list9; [EOL]         delegateBooleanAssertion(types, 9, 7, true); [EOL]         list10 = list7; [EOL]         delegateBooleanAssertion(types, 7, 10, true); [EOL]         list7 = list10; [EOL]         delegateBooleanAssertion(types, 10, 7, true); [EOL]         list11 = list7; [EOL]         delegateBooleanAssertion(types, 7, 11, true); [EOL]         list7 = list11; [EOL]         delegateBooleanAssertion(types, 11, 7, true); [EOL]         list12 = list7; [EOL]         delegateBooleanAssertion(types, 7, 12, true); [EOL]         list7 = list12; [EOL]         delegateBooleanAssertion(types, 12, 7, true); [EOL]         list13 = list7; [EOL]         delegateBooleanAssertion(types, 7, 13, true); [EOL]         list7 = list13; [EOL]         delegateBooleanAssertion(types, 13, 7, true); [EOL] //        list8 = list8; [EOL]         delegateBooleanAssertion(types, 8, 8, true); [EOL]         list9 = list8; [EOL]         delegateBooleanAssertion(types, 8, 9, true); [EOL]         list8 = (List<Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 8, false); [EOL]         list10 = list8; [EOL]         delegateBooleanAssertion(types, 8, 10, true); [EOL]         list8 = (List<Object>[]) list10; // NOTE cast is required by Sun Java, but not by Eclipse [EOL]         delegateBooleanAssertion(types, 10, 8, false); [EOL]         // list11 = list8; [EOL]         delegateBooleanAssertion(types, 8, 11, false); [EOL]         // list8 = list11; [EOL]         delegateBooleanAssertion(types, 11, 8, false); [EOL]         // list12 = list8; [EOL]         delegateBooleanAssertion(types, 8, 12, false); [EOL]         // list8 = list12; [EOL]         delegateBooleanAssertion(types, 12, 8, false); [EOL]         list13 = list8; [EOL]         delegateBooleanAssertion(types, 8, 13, true); [EOL]         list8 = (List<Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 8, false); [EOL] //        list9 = list9; [EOL]         delegateBooleanAssertion(types, 9, 9, true); [EOL]         list10 = (List<? super Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 10, false); [EOL]         list9 = list10; [EOL]         delegateBooleanAssertion(types, 10, 9, true); [EOL]         list11 = (List<String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 11, false); [EOL]         list9 = list11; [EOL]         delegateBooleanAssertion(types, 11, 9, true); [EOL]         list12 = (List<? extends String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 12, false); [EOL]         list9 = list12; [EOL]         delegateBooleanAssertion(types, 12, 9, true); [EOL]         list13 = (List<? super String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 13, false); [EOL]         list9 = list13; [EOL]         delegateBooleanAssertion(types, 13, 9, true); [EOL] //        list10 = list10; [EOL]         delegateBooleanAssertion(types, 10, 10, true); [EOL]         // list11 = list10; [EOL]         delegateBooleanAssertion(types, 10, 11, false); [EOL]         // list10 = list11; [EOL]         delegateBooleanAssertion(types, 11, 10, false); [EOL]         // list12 = list10; [EOL]         delegateBooleanAssertion(types, 10, 12, false); [EOL]         // list10 = list12; [EOL]         delegateBooleanAssertion(types, 12, 10, false); [EOL]         list13 = list10; [EOL]         delegateBooleanAssertion(types, 10, 13, true); [EOL]         list10 = (List<? super Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 10, false); [EOL] //        list11 = list11; [EOL]         delegateBooleanAssertion(types, 11, 11, true); [EOL]         list12 = list11; [EOL]         delegateBooleanAssertion(types, 11, 12, true); [EOL]         list11 = (List<String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 11, false); [EOL]         list13 = list11; [EOL]         delegateBooleanAssertion(types, 11, 13, true); [EOL]         list11 = (List<String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 11, false); [EOL] //        list12 = list12; [EOL]         delegateBooleanAssertion(types, 12, 12, true); [EOL]         list13 = (List<? super String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 13, false); [EOL]         list12 = (List<? extends String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 12, false); [EOL] //        list13 = list13; [EOL]         delegateBooleanAssertion(types, 13, 13, true); [EOL]         final Type disType = getClass().getField("dis").getGenericType(); [EOL]         // Reporter.log( ( ( ParameterizedType ) disType [EOL]         // ).getOwnerType().getClass().toString() ); [EOL]         final Type datType = getClass().getField("dat").getGenericType(); [EOL]         final Type daType = getClass().getField("da").getGenericType(); [EOL]         final Type uhderType = getClass().getField("uhder").getGenericType(); [EOL]         final Type dingType = getClass().getField("ding").getGenericType(); [EOL]         final Type testerType = getClass().getField("tester").getGenericType(); [EOL]         final Type tester2Type = getClass().getField("tester2").getGenericType(); [EOL]         final Type dat2Type = getClass().getField("dat2").getGenericType(); [EOL]         final Type dat3Type = getClass().getField("dat3").getGenericType(); [EOL]         dis = dat; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(datType, disType)); [EOL]         // dis = da; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(daType, disType)); [EOL]         dis = uhder; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(uhderType, disType)); [EOL]         dis = ding; [EOL]         Assert.assertFalse(String.format("type %s not assignable to %s!", dingType, disType), [EOL]                 TypeUtils.isAssignable(dingType, disType)); [EOL]         dis = tester; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(testerType, disType)); [EOL]         // dis = tester2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(tester2Type, disType)); [EOL]         // dat = dat2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat2Type, datType)); [EOL]         // dat2 = dat; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(datType, dat2Type)); [EOL]         // dat = dat3; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat3Type, datType)); [EOL]         final char ch = 0; [EOL]         final boolean bo = false; [EOL]         final byte by = 0; [EOL]         final short sh = 0; [EOL]         int in = 0; [EOL]         long lo = 0; [EOL]         final float fl = 0; [EOL]         double du = 0; [EOL]         du = ch; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(char.class, double.class)); [EOL]         du = by; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(byte.class, double.class)); [EOL]         du = sh; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(short.class, double.class)); [EOL]         du = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, double.class)); [EOL]         du = lo; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(long.class, double.class)); [EOL]         du = fl; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(float.class, double.class)); [EOL]         lo = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, long.class)); [EOL]         lo = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, long.class)); [EOL]         // Long lngW = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, Long.class)); [EOL]         // lngW = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, Long.class)); [EOL]         in = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, int.class)); [EOL]         final Integer inte = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Integer.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Number.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Object.class)); [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, intComparableType)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Comparable.class)); [EOL]         final Serializable ser = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Serializable.class)); [EOL]         final Type longComparableType = getClass().getField("longComparable").getGenericType(); [EOL]         // longComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, longComparableType)); [EOL]         // longComparable = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, longComparableType)); [EOL]         // int[] ia; [EOL]         // long[] la = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, long[].class)); [EOL]         final Integer[] ia = null; [EOL]         final Type caType = getClass().getField("intWildcardComparable").getGenericType(); [EOL]         intWildcardComparable = ia; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, caType)); [EOL]         // int[] ina = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer[].class, int[].class)); [EOL]         final int[] ina = null; [EOL]         Object[] oa; [EOL]         // oa = ina; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, Object[].class)); [EOL]         oa = new Integer[0]; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, Object[].class)); [EOL]         final Type bClassType = AClass.class.getField("bClass").getGenericType(); [EOL]         final Type cClassType = AClass.class.getField("cClass").getGenericType(); [EOL]         final Type dClassType = AClass.class.getField("dClass").getGenericType(); [EOL]         final Type eClassType = AClass.class.getField("eClass").getGenericType(); [EOL]         final Type fClassType = AClass.class.getField("fClass").getGenericType(); [EOL]         final AClass aClass = new AClass(new AAClass<String>()); [EOL]         aClass.bClass = aClass.cClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(cClassType, bClassType)); [EOL]         aClass.bClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, bClassType)); [EOL]         aClass.bClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, bClassType)); [EOL]         aClass.bClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, bClassType)); [EOL]         aClass.cClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, cClassType)); [EOL]         aClass.cClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, cClassType)); [EOL]         aClass.cClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, cClassType)); [EOL]         aClass.dClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, dClassType)); [EOL]         aClass.dClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, dClassType)); [EOL]         aClass.eClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, eClassType)); [EOL]     } [EOL]  [EOL]     public void delegateBooleanAssertion(final Type[] types, final int i2, final int i1, final boolean expected) { [EOL]         final Type type1 = types[i1]; [EOL]         final Type type2 = types[i2]; [EOL]         final boolean isAssignable = TypeUtils.isAssignable(type2, type1); [EOL]  [EOL]         if (expected) { [EOL]             Assert.assertTrue("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } else { [EOL]             Assert.assertFalse("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } [EOL]     } [EOL]  [EOL]     @SuppressWarnings("boxing") // boxing is deliberate here [EOL]
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [EOL]         final Type[] types = method.getGenericParameterTypes(); [EOL] //        list0 = list0; [EOL]         delegateBooleanAssertion(types, 0, 0, true); [EOL]         list1 = list0; [EOL]         delegateBooleanAssertion(types, 0, 1, true); [EOL]         list0 = list1; [EOL]         delegateBooleanAssertion(types, 1, 0, true); [EOL]         list2 = list0; [EOL]         delegateBooleanAssertion(types, 0, 2, true); [EOL]         list0 = list2; [EOL]         delegateBooleanAssertion(types, 2, 0, true); [EOL]         list3 = list0; [EOL]         delegateBooleanAssertion(types, 0, 3, true); [EOL]         list0 = list3; [EOL]         delegateBooleanAssertion(types, 3, 0, true); [EOL]         list4 = list0; [EOL]         delegateBooleanAssertion(types, 0, 4, true); [EOL]         list0 = list4; [EOL]         delegateBooleanAssertion(types, 4, 0, true); [EOL]         list5 = list0; [EOL]         delegateBooleanAssertion(types, 0, 5, true); [EOL]         list0 = list5; [EOL]         delegateBooleanAssertion(types, 5, 0, true); [EOL]         list6 = list0; [EOL]         delegateBooleanAssertion(types, 0, 6, true); [EOL]         list0 = list6; [EOL]         delegateBooleanAssertion(types, 6, 0, true); [EOL] //        list1 = list1; [EOL]         delegateBooleanAssertion(types, 1, 1, true); [EOL]         list2 = list1; [EOL]         delegateBooleanAssertion(types, 1, 2, true); [EOL]         list1 = (List<Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 1, false); [EOL]         list3 = list1; [EOL]         delegateBooleanAssertion(types, 1, 3, true); [EOL]         list1 = (List<Object>) list3; [EOL]         delegateBooleanAssertion(types, 3, 1, false); [EOL]         // list4 = list1; [EOL]         delegateBooleanAssertion(types, 1, 4, false); [EOL]         // list1 = list4; [EOL]         delegateBooleanAssertion(types, 4, 1, false); [EOL]         // list5 = list1; [EOL]         delegateBooleanAssertion(types, 1, 5, false); [EOL]         // list1 = list5; [EOL]         delegateBooleanAssertion(types, 5, 1, false); [EOL]         list6 = list1; [EOL]         delegateBooleanAssertion(types, 1, 6, true); [EOL]         list1 = (List<Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 1, false); [EOL] //        list2 = list2; [EOL]         delegateBooleanAssertion(types, 2, 2, true); [EOL]         list2 = list3; [EOL]         delegateBooleanAssertion(types, 2, 3, false); [EOL]         list2 = list4; [EOL]         delegateBooleanAssertion(types, 3, 2, true); [EOL]         list3 = (List<? super Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 4, false); [EOL]         list2 = list5; [EOL]         delegateBooleanAssertion(types, 4, 2, true); [EOL]         list4 = (List<String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 5, false); [EOL]         list2 = list6; [EOL]         delegateBooleanAssertion(types, 5, 2, true); [EOL]         list5 = (List<? extends String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 6, false); [EOL] //        list3 = list3; [EOL]         delegateBooleanAssertion(types, 6, 2, true); [EOL]         list6 = (List<? super String>) list2; [EOL]         delegateBooleanAssertion(types, 3, 3, true); [EOL]         // list4 = list3; [EOL]         delegateBooleanAssertion(types, 3, 4, false); [EOL]         // list3 = list4; [EOL]         delegateBooleanAssertion(types, 4, 3, false); [EOL]         // list5 = list3; [EOL]         delegateBooleanAssertion(types, 3, 5, false); [EOL]         // list3 = list5; [EOL]         delegateBooleanAssertion(types, 5, 3, false); [EOL]         list6 = list3; [EOL]         delegateBooleanAssertion(types, 3, 6, true); [EOL]         list3 = (List<? super Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 3, false); [EOL] //        list4 = list4; [EOL]         delegateBooleanAssertion(types, 4, 4, true); [EOL]         list5 = list4; [EOL]         delegateBooleanAssertion(types, 4, 5, true); [EOL]         list4 = (List<String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 4, false); [EOL]         list6 = list4; [EOL]         delegateBooleanAssertion(types, 4, 6, true); [EOL]         list4 = (List<String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 4, false); [EOL] //        list5 = list5; [EOL]         delegateBooleanAssertion(types, 5, 5, true); [EOL]         list6 = (List<? super String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 6, false); [EOL]         list5 = (List<? extends String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 5, false); [EOL] //        list6 = list6; [EOL]         delegateBooleanAssertion(types, 6, 6, true); [EOL]  [EOL] //        list7 = list7; [EOL]         delegateBooleanAssertion(types, 7, 7, true); [EOL]         list8 = list7; [EOL]         delegateBooleanAssertion(types, 7, 8, true); [EOL]         list7 = list8; [EOL]         delegateBooleanAssertion(types, 8, 7, true); [EOL]         list9 = list7; [EOL]         delegateBooleanAssertion(types, 7, 9, true); [EOL]         list7 = list9; [EOL]         delegateBooleanAssertion(types, 9, 7, true); [EOL]         list10 = list7; [EOL]         delegateBooleanAssertion(types, 7, 10, true); [EOL]         list7 = list10; [EOL]         delegateBooleanAssertion(types, 10, 7, true); [EOL]         list11 = list7; [EOL]         delegateBooleanAssertion(types, 7, 11, true); [EOL]         list7 = list11; [EOL]         delegateBooleanAssertion(types, 11, 7, true); [EOL]         list12 = list7; [EOL]         delegateBooleanAssertion(types, 7, 12, true); [EOL]         list7 = list12; [EOL]         delegateBooleanAssertion(types, 12, 7, true); [EOL]         list13 = list7; [EOL]         delegateBooleanAssertion(types, 7, 13, true); [EOL]         list7 = list13; [EOL]         delegateBooleanAssertion(types, 13, 7, true); [EOL] //        list8 = list8; [EOL]         delegateBooleanAssertion(types, 8, 8, true); [EOL]         list9 = list8; [EOL]         delegateBooleanAssertion(types, 8, 9, true); [EOL]         list8 = (List<Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 8, false); [EOL]         list10 = list8; [EOL]         delegateBooleanAssertion(types, 8, 10, true); [EOL]         list8 = (List<Object>[]) list10; // NOTE cast is required by Sun Java, but not by Eclipse [EOL]         delegateBooleanAssertion(types, 10, 8, false); [EOL]         // list11 = list8; [EOL]         delegateBooleanAssertion(types, 8, 11, false); [EOL]         // list8 = list11; [EOL]         delegateBooleanAssertion(types, 11, 8, false); [EOL]         // list12 = list8; [EOL]         delegateBooleanAssertion(types, 8, 12, false); [EOL]         // list8 = list12; [EOL]         delegateBooleanAssertion(types, 12, 8, false); [EOL]         list13 = list8; [EOL]         delegateBooleanAssertion(types, 8, 13, true); [EOL]         list8 = (List<Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 8, false); [EOL] //        list9 = list9; [EOL]         delegateBooleanAssertion(types, 9, 9, true); [EOL]         list10 = (List<? super Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 10, false); [EOL]         list9 = list10; [EOL]         delegateBooleanAssertion(types, 10, 9, true); [EOL]         list11 = (List<String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 11, false); [EOL]         list9 = list11; [EOL]         delegateBooleanAssertion(types, 11, 9, true); [EOL]         list12 = (List<? extends String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 12, false); [EOL]         list9 = list12; [EOL]         delegateBooleanAssertion(types, 12, 9, true); [EOL]         list13 = (List<? super String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 13, false); [EOL]         list9 = list13; [EOL]         delegateBooleanAssertion(types, 13, 9, true); [EOL] //        list10 = list10; [EOL]         delegateBooleanAssertion(types, 10, 10, true); [EOL]         // list11 = list10; [EOL]         delegateBooleanAssertion(types, 10, 11, false); [EOL]         // list10 = list11; [EOL]         delegateBooleanAssertion(types, 11, 10, false); [EOL]         // list12 = list10; [EOL]         delegateBooleanAssertion(types, 10, 12, false); [EOL]         // list10 = list12; [EOL]         delegateBooleanAssertion(types, 12, 10, false); [EOL]         list13 = list10; [EOL]         delegateBooleanAssertion(types, 10, 13, true); [EOL]         list10 = (List<? super Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 10, false); [EOL] //        list11 = list11; [EOL]         delegateBooleanAssertion(types, 11, 11, true); [EOL]         list12 = list11; [EOL]         delegateBooleanAssertion(types, 11, 12, true); [EOL]         list11 = (List<String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 11, false); [EOL]         list13 = list11; [EOL]         delegateBooleanAssertion(types, 11, 13, true); [EOL]         list11 = (List<String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 11, false); [EOL] //        list12 = list12; [EOL]         delegateBooleanAssertion(types, 12, 12, true); [EOL]         list13 = (List<? super String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 13, false); [EOL]         list12 = (List<? extends String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 12, false); [EOL] //        list13 = list13; [EOL]         delegateBooleanAssertion(types, 13, 13, true); [EOL]         final Type disType = getClass().getField("dis").getGenericType(); [EOL]         // Reporter.log( ( ( ParameterizedType ) disType [EOL]         // ).getOwnerType().getClass().toString() ); [EOL]         final Type datType = getClass().getField("dat").getGenericType(); [EOL]         final Type daType = getClass().getField("da").getGenericType(); [EOL]         final Type uhderType = getClass().getField("uhder").getGenericType(); [EOL]         final Type dingType = getClass().getField("ding").getGenericType(); [EOL]         final Type testerType = getClass().getField("tester").getGenericType(); [EOL]         final Type tester2Type = getClass().getField("tester2").getGenericType(); [EOL]         final Type dat2Type = getClass().getField("dat2").getGenericType(); [EOL]         final Type dat3Type = getClass().getField("dat3").getGenericType(); [EOL]         dis = dat; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(datType, disType)); [EOL]         // dis = da; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(daType, disType)); [EOL]         dis = uhder; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(uhderType, disType)); [EOL]         dis = ding; [EOL]         Assert.assertFalse(String.format("type %s not assignable to %s!", dingType, disType), [EOL]                 TypeUtils.isAssignable(dingType, disType)); [EOL]         dis = tester; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(testerType, disType)); [EOL]         // dis = tester2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(tester2Type, disType)); [EOL]         // dat = dat2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat2Type, datType)); [EOL]         // dat2 = dat; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(datType, dat2Type)); [EOL]         // dat = dat3; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat3Type, datType)); [EOL]         final char ch = 0; [EOL]         final boolean bo = false; [EOL]         final byte by = 0; [EOL]         final short sh = 0; [EOL]         int in = 0; [EOL]         long lo = 0; [EOL]         final float fl = 0; [EOL]         double du = 0; [EOL]         du = ch; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(char.class, double.class)); [EOL]         du = by; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(byte.class, double.class)); [EOL]         du = sh; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(short.class, double.class)); [EOL]         du = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, double.class)); [EOL]         du = lo; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(long.class, double.class)); [EOL]         du = fl; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(float.class, double.class)); [EOL]         lo = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, long.class)); [EOL]         lo = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, long.class)); [EOL]         // Long lngW = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, Long.class)); [EOL]         // lngW = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, Long.class)); [EOL]         in = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, int.class)); [EOL]         final Integer inte = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Integer.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Number.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Object.class)); [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, intComparableType)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Comparable.class)); [EOL]         final Serializable ser = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Serializable.class)); [EOL]         final Type longComparableType = getClass().getField("longComparable").getGenericType(); [EOL]         // longComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, longComparableType)); [EOL]         // longComparable = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, longComparableType)); [EOL]         // int[] ia; [EOL]         // long[] la = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, long[].class)); [EOL]         final Integer[] ia = null; [EOL]         final Type caType = getClass().getField("intWildcardComparable").getGenericType(); [EOL]         intWildcardComparable = ia; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, caType)); [EOL]         // int[] ina = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer[].class, int[].class)); [EOL]         final int[] ina = null; [EOL]         Object[] oa; [EOL]         // oa = ina; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, Object[].class)); [EOL]         oa = new Integer[0]; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, Object[].class)); [EOL]         final Type bClassType = AClass.class.getField("bClass").getGenericType(); [EOL]         final Type cClassType = AClass.class.getField("cClass").getGenericType(); [EOL]         final Type dClassType = AClass.class.getField("dClass").getGenericType(); [EOL]         final Type eClassType = AClass.class.getField("eClass").getGenericType(); [EOL]         final Type fClassType = AClass.class.getField("fClass").getGenericType(); [EOL]         final AClass aClass = new AClass(new AAClass<String>()); [EOL]         aClass.bClass = aClass.cClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(cClassType, bClassType)); [EOL]         aClass.bClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, bClassType)); [EOL]         aClass.bClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, bClassType)); [EOL]         aClass.bClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, bClassType)); [EOL]         aClass.cClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, cClassType)); [EOL]         aClass.cClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, cClassType)); [EOL]         aClass.cClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, cClassType)); [EOL]         aClass.dClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, dClassType)); [EOL]         aClass.dClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, dClassType)); [EOL]         aClass.eClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, eClassType)); [EOL]     } [EOL]  [EOL]     public void delegateBooleanAssertion(final Type[] types, final int i2, final int i1, final boolean expected) { [EOL]         final Type type1 = types[i1]; [EOL]         final Type type2 = types[i2]; [EOL]         final boolean isAssignable = TypeUtils.isAssignable(type2, type1); [EOL]  [EOL]         if (expected) { [EOL]             Assert.assertTrue("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } else { [EOL]             Assert.assertFalse("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } [EOL]     } [EOL]  [EOL]     @SuppressWarnings("boxing") // boxing is deliberate here [EOL]
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [EOL]         final Type[] types = method.getGenericParameterTypes(); [EOL] //        list0 = list0; [EOL]         delegateBooleanAssertion(types, 0, 0, true); [EOL]         list1 = list0; [EOL]         delegateBooleanAssertion(types, 0, 1, true); [EOL]         list0 = list1; [EOL]         delegateBooleanAssertion(types, 1, 0, true); [EOL]         list2 = list0; [EOL]         delegateBooleanAssertion(types, 0, 2, true); [EOL]         list0 = list2; [EOL]         delegateBooleanAssertion(types, 2, 0, true); [EOL]         list3 = list0; [EOL]         delegateBooleanAssertion(types, 0, 3, true); [EOL]         list0 = list3; [EOL]         delegateBooleanAssertion(types, 3, 0, true); [EOL]         list4 = list0; [EOL]         delegateBooleanAssertion(types, 0, 4, true); [EOL]         list0 = list4; [EOL]         delegateBooleanAssertion(types, 4, 0, true); [EOL]         list5 = list0; [EOL]         delegateBooleanAssertion(types, 0, 5, true); [EOL]         list0 = list5; [EOL]         delegateBooleanAssertion(types, 5, 0, true); [EOL]         list6 = list0; [EOL]         delegateBooleanAssertion(types, 0, 6, true); [EOL]         list0 = list6; [EOL]         delegateBooleanAssertion(types, 6, 0, true); [EOL] //        list1 = list1; [EOL]         delegateBooleanAssertion(types, 1, 1, true); [EOL]         list2 = list1; [EOL]         delegateBooleanAssertion(types, 1, 2, true); [EOL]         list1 = (List<Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 1, false); [EOL]         list3 = list1; [EOL]         delegateBooleanAssertion(types, 1, 3, true); [EOL]         list1 = (List<Object>) list3; [EOL]         delegateBooleanAssertion(types, 3, 1, false); [EOL]         // list4 = list1; [EOL]         delegateBooleanAssertion(types, 1, 4, false); [EOL]         // list1 = list4; [EOL]         delegateBooleanAssertion(types, 4, 1, false); [EOL]         // list5 = list1; [EOL]         delegateBooleanAssertion(types, 1, 5, false); [EOL]         // list1 = list5; [EOL]         delegateBooleanAssertion(types, 5, 1, false); [EOL]         list6 = list1; [EOL]         delegateBooleanAssertion(types, 1, 6, true); [EOL]         list1 = (List<Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 1, false); [EOL] //        list2 = list2; [EOL]         delegateBooleanAssertion(types, 2, 2, true); [EOL]         list2 = list3; [EOL]         delegateBooleanAssertion(types, 2, 3, false); [EOL]         list2 = list4; [EOL]         delegateBooleanAssertion(types, 3, 2, true); [EOL]         list3 = (List<? super Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 4, false); [EOL]         list2 = list5; [EOL]         delegateBooleanAssertion(types, 4, 2, true); [EOL]         list4 = (List<String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 5, false); [EOL]         list2 = list6; [EOL]         delegateBooleanAssertion(types, 5, 2, true); [EOL]         list5 = (List<? extends String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 6, false); [EOL] //        list3 = list3; [EOL]         delegateBooleanAssertion(types, 6, 2, true); [EOL]         list6 = (List<? super String>) list2; [EOL]         delegateBooleanAssertion(types, 3, 3, true); [EOL]         // list4 = list3; [EOL]         delegateBooleanAssertion(types, 3, 4, false); [EOL]         // list3 = list4; [EOL]         delegateBooleanAssertion(types, 4, 3, false); [EOL]         // list5 = list3; [EOL]         delegateBooleanAssertion(types, 3, 5, false); [EOL]         // list3 = list5; [EOL]         delegateBooleanAssertion(types, 5, 3, false); [EOL]         list6 = list3; [EOL]         delegateBooleanAssertion(types, 3, 6, true); [EOL]         list3 = (List<? super Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 3, false); [EOL] //        list4 = list4; [EOL]         delegateBooleanAssertion(types, 4, 4, true); [EOL]         list5 = list4; [EOL]         delegateBooleanAssertion(types, 4, 5, true); [EOL]         list4 = (List<String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 4, false); [EOL]         list6 = list4; [EOL]         delegateBooleanAssertion(types, 4, 6, true); [EOL]         list4 = (List<String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 4, false); [EOL] //        list5 = list5; [EOL]         delegateBooleanAssertion(types, 5, 5, true); [EOL]         list6 = (List<? super String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 6, false); [EOL]         list5 = (List<? extends String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 5, false); [EOL] //        list6 = list6; [EOL]         delegateBooleanAssertion(types, 6, 6, true); [EOL]  [EOL] //        list7 = list7; [EOL]         delegateBooleanAssertion(types, 7, 7, true); [EOL]         list8 = list7; [EOL]         delegateBooleanAssertion(types, 7, 8, true); [EOL]         list7 = list8; [EOL]         delegateBooleanAssertion(types, 8, 7, true); [EOL]         list9 = list7; [EOL]         delegateBooleanAssertion(types, 7, 9, true); [EOL]         list7 = list9; [EOL]         delegateBooleanAssertion(types, 9, 7, true); [EOL]         list10 = list7; [EOL]         delegateBooleanAssertion(types, 7, 10, true); [EOL]         list7 = list10; [EOL]         delegateBooleanAssertion(types, 10, 7, true); [EOL]         list11 = list7; [EOL]         delegateBooleanAssertion(types, 7, 11, true); [EOL]         list7 = list11; [EOL]         delegateBooleanAssertion(types, 11, 7, true); [EOL]         list12 = list7; [EOL]         delegateBooleanAssertion(types, 7, 12, true); [EOL]         list7 = list12; [EOL]         delegateBooleanAssertion(types, 12, 7, true); [EOL]         list13 = list7; [EOL]         delegateBooleanAssertion(types, 7, 13, true); [EOL]         list7 = list13; [EOL]         delegateBooleanAssertion(types, 13, 7, true); [EOL] //        list8 = list8; [EOL]         delegateBooleanAssertion(types, 8, 8, true); [EOL]         list9 = list8; [EOL]         delegateBooleanAssertion(types, 8, 9, true); [EOL]         list8 = (List<Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 8, false); [EOL]         list10 = list8; [EOL]         delegateBooleanAssertion(types, 8, 10, true); [EOL]         list8 = (List<Object>[]) list10; // NOTE cast is required by Sun Java, but not by Eclipse [EOL]         delegateBooleanAssertion(types, 10, 8, false); [EOL]         // list11 = list8; [EOL]         delegateBooleanAssertion(types, 8, 11, false); [EOL]         // list8 = list11; [EOL]         delegateBooleanAssertion(types, 11, 8, false); [EOL]         // list12 = list8; [EOL]         delegateBooleanAssertion(types, 8, 12, false); [EOL]         // list8 = list12; [EOL]         delegateBooleanAssertion(types, 12, 8, false); [EOL]         list13 = list8; [EOL]         delegateBooleanAssertion(types, 8, 13, true); [EOL]         list8 = (List<Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 8, false); [EOL] //        list9 = list9; [EOL]         delegateBooleanAssertion(types, 9, 9, true); [EOL]         list10 = (List<? super Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 10, false); [EOL]         list9 = list10; [EOL]         delegateBooleanAssertion(types, 10, 9, true); [EOL]         list11 = (List<String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 11, false); [EOL]         list9 = list11; [EOL]         delegateBooleanAssertion(types, 11, 9, true); [EOL]         list12 = (List<? extends String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 12, false); [EOL]         list9 = list12; [EOL]         delegateBooleanAssertion(types, 12, 9, true); [EOL]         list13 = (List<? super String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 13, false); [EOL]         list9 = list13; [EOL]         delegateBooleanAssertion(types, 13, 9, true); [EOL] //        list10 = list10; [EOL]         delegateBooleanAssertion(types, 10, 10, true); [EOL]         // list11 = list10; [EOL]         delegateBooleanAssertion(types, 10, 11, false); [EOL]         // list10 = list11; [EOL]         delegateBooleanAssertion(types, 11, 10, false); [EOL]         // list12 = list10; [EOL]         delegateBooleanAssertion(types, 10, 12, false); [EOL]         // list10 = list12; [EOL]         delegateBooleanAssertion(types, 12, 10, false); [EOL]         list13 = list10; [EOL]         delegateBooleanAssertion(types, 10, 13, true); [EOL]         list10 = (List<? super Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 10, false); [EOL] //        list11 = list11; [EOL]         delegateBooleanAssertion(types, 11, 11, true); [EOL]         list12 = list11; [EOL]         delegateBooleanAssertion(types, 11, 12, true); [EOL]         list11 = (List<String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 11, false); [EOL]         list13 = list11; [EOL]         delegateBooleanAssertion(types, 11, 13, true); [EOL]         list11 = (List<String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 11, false); [EOL] //        list12 = list12; [EOL]         delegateBooleanAssertion(types, 12, 12, true); [EOL]         list13 = (List<? super String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 13, false); [EOL]         list12 = (List<? extends String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 12, false); [EOL] //        list13 = list13; [EOL]         delegateBooleanAssertion(types, 13, 13, true); [EOL]         final Type disType = getClass().getField("dis").getGenericType(); [EOL]         // Reporter.log( ( ( ParameterizedType ) disType [EOL]         // ).getOwnerType().getClass().toString() ); [EOL]         final Type datType = getClass().getField("dat").getGenericType(); [EOL]         final Type daType = getClass().getField("da").getGenericType(); [EOL]         final Type uhderType = getClass().getField("uhder").getGenericType(); [EOL]         final Type dingType = getClass().getField("ding").getGenericType(); [EOL]         final Type testerType = getClass().getField("tester").getGenericType(); [EOL]         final Type tester2Type = getClass().getField("tester2").getGenericType(); [EOL]         final Type dat2Type = getClass().getField("dat2").getGenericType(); [EOL]         final Type dat3Type = getClass().getField("dat3").getGenericType(); [EOL]         dis = dat; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(datType, disType)); [EOL]         // dis = da; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(daType, disType)); [EOL]         dis = uhder; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(uhderType, disType)); [EOL]         dis = ding; [EOL]         Assert.assertFalse(String.format("type %s not assignable to %s!", dingType, disType), [EOL]                 TypeUtils.isAssignable(dingType, disType)); [EOL]         dis = tester; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(testerType, disType)); [EOL]         // dis = tester2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(tester2Type, disType)); [EOL]         // dat = dat2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat2Type, datType)); [EOL]         // dat2 = dat; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(datType, dat2Type)); [EOL]         // dat = dat3; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat3Type, datType)); [EOL]         final char ch = 0; [EOL]         final boolean bo = false; [EOL]         final byte by = 0; [EOL]         final short sh = 0; [EOL]         int in = 0; [EOL]         long lo = 0; [EOL]         final float fl = 0; [EOL]         double du = 0; [EOL]         du = ch; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(char.class, double.class)); [EOL]         du = by; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(byte.class, double.class)); [EOL]         du = sh; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(short.class, double.class)); [EOL]         du = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, double.class)); [EOL]         du = lo; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(long.class, double.class)); [EOL]         du = fl; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(float.class, double.class)); [EOL]         lo = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, long.class)); [EOL]         lo = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, long.class)); [EOL]         // Long lngW = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, Long.class)); [EOL]         // lngW = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, Long.class)); [EOL]         in = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, int.class)); [EOL]         final Integer inte = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Integer.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Number.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Object.class)); [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, intComparableType)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Comparable.class)); [EOL]         final Serializable ser = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Serializable.class)); [EOL]         final Type longComparableType = getClass().getField("longComparable").getGenericType(); [EOL]         // longComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, longComparableType)); [EOL]         // longComparable = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, longComparableType)); [EOL]         // int[] ia; [EOL]         // long[] la = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, long[].class)); [EOL]         final Integer[] ia = null; [EOL]         final Type caType = getClass().getField("intWildcardComparable").getGenericType(); [EOL]         intWildcardComparable = ia; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, caType)); [EOL]         // int[] ina = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer[].class, int[].class)); [EOL]         final int[] ina = null; [EOL]         Object[] oa; [EOL]         // oa = ina; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, Object[].class)); [EOL]         oa = new Integer[0]; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, Object[].class)); [EOL]         final Type bClassType = AClass.class.getField("bClass").getGenericType(); [EOL]         final Type cClassType = AClass.class.getField("cClass").getGenericType(); [EOL]         final Type dClassType = AClass.class.getField("dClass").getGenericType(); [EOL]         final Type eClassType = AClass.class.getField("eClass").getGenericType(); [EOL]         final Type fClassType = AClass.class.getField("fClass").getGenericType(); [EOL]         final AClass aClass = new AClass(new AAClass<String>()); [EOL]         aClass.bClass = aClass.cClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(cClassType, bClassType)); [EOL]         aClass.bClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, bClassType)); [EOL]         aClass.bClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, bClassType)); [EOL]         aClass.bClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, bClassType)); [EOL]         aClass.cClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, cClassType)); [EOL]         aClass.cClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, cClassType)); [EOL]         aClass.cClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, cClassType)); [EOL]         aClass.dClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, dClassType)); [EOL]         aClass.dClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, dClassType)); [EOL]         aClass.eClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, eClassType)); [EOL]     } [EOL]  [EOL]     public void delegateBooleanAssertion(final Type[] types, final int i2, final int i1, final boolean expected) { [EOL]         final Type type1 = types[i1]; [EOL]         final Type type2 = types[i2]; [EOL]         final boolean isAssignable = TypeUtils.isAssignable(type2, type1); [EOL]  [EOL]         if (expected) { [EOL]             Assert.assertTrue("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } else { [EOL]             Assert.assertFalse("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } [EOL]     } [EOL]  [EOL]     @SuppressWarnings("boxing") // boxing is deliberate here [EOL]
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [EOL]         final Type[] types = method.getGenericParameterTypes(); [EOL] //        list0 = list0; [EOL]         delegateBooleanAssertion(types, 0, 0, true); [EOL]         list1 = list0; [EOL]         delegateBooleanAssertion(types, 0, 1, true); [EOL]         list0 = list1; [EOL]         delegateBooleanAssertion(types, 1, 0, true); [EOL]         list2 = list0; [EOL]         delegateBooleanAssertion(types, 0, 2, true); [EOL]         list0 = list2; [EOL]         delegateBooleanAssertion(types, 2, 0, true); [EOL]         list3 = list0; [EOL]         delegateBooleanAssertion(types, 0, 3, true); [EOL]         list0 = list3; [EOL]         delegateBooleanAssertion(types, 3, 0, true); [EOL]         list4 = list0; [EOL]         delegateBooleanAssertion(types, 0, 4, true); [EOL]         list0 = list4; [EOL]         delegateBooleanAssertion(types, 4, 0, true); [EOL]         list5 = list0; [EOL]         delegateBooleanAssertion(types, 0, 5, true); [EOL]         list0 = list5; [EOL]         delegateBooleanAssertion(types, 5, 0, true); [EOL]         list6 = list0; [EOL]         delegateBooleanAssertion(types, 0, 6, true); [EOL]         list0 = list6; [EOL]         delegateBooleanAssertion(types, 6, 0, true); [EOL] //        list1 = list1; [EOL]         delegateBooleanAssertion(types, 1, 1, true); [EOL]         list2 = list1; [EOL]         delegateBooleanAssertion(types, 1, 2, true); [EOL]         list1 = (List<Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 1, false); [EOL]         list3 = list1; [EOL]         delegateBooleanAssertion(types, 1, 3, true); [EOL]         list1 = (List<Object>) list3; [EOL]         delegateBooleanAssertion(types, 3, 1, false); [EOL]         // list4 = list1; [EOL]         delegateBooleanAssertion(types, 1, 4, false); [EOL]         // list1 = list4; [EOL]         delegateBooleanAssertion(types, 4, 1, false); [EOL]         // list5 = list1; [EOL]         delegateBooleanAssertion(types, 1, 5, false); [EOL]         // list1 = list5; [EOL]         delegateBooleanAssertion(types, 5, 1, false); [EOL]         list6 = list1; [EOL]         delegateBooleanAssertion(types, 1, 6, true); [EOL]         list1 = (List<Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 1, false); [EOL] //        list2 = list2; [EOL]         delegateBooleanAssertion(types, 2, 2, true); [EOL]         list2 = list3; [EOL]         delegateBooleanAssertion(types, 2, 3, false); [EOL]         list2 = list4; [EOL]         delegateBooleanAssertion(types, 3, 2, true); [EOL]         list3 = (List<? super Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 4, false); [EOL]         list2 = list5; [EOL]         delegateBooleanAssertion(types, 4, 2, true); [EOL]         list4 = (List<String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 5, false); [EOL]         list2 = list6; [EOL]         delegateBooleanAssertion(types, 5, 2, true); [EOL]         list5 = (List<? extends String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 6, false); [EOL] //        list3 = list3; [EOL]         delegateBooleanAssertion(types, 6, 2, true); [EOL]         list6 = (List<? super String>) list2; [EOL]         delegateBooleanAssertion(types, 3, 3, true); [EOL]         // list4 = list3; [EOL]         delegateBooleanAssertion(types, 3, 4, false); [EOL]         // list3 = list4; [EOL]         delegateBooleanAssertion(types, 4, 3, false); [EOL]         // list5 = list3; [EOL]         delegateBooleanAssertion(types, 3, 5, false); [EOL]         // list3 = list5; [EOL]         delegateBooleanAssertion(types, 5, 3, false); [EOL]         list6 = list3; [EOL]         delegateBooleanAssertion(types, 3, 6, true); [EOL]         list3 = (List<? super Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 3, false); [EOL] //        list4 = list4; [EOL]         delegateBooleanAssertion(types, 4, 4, true); [EOL]         list5 = list4; [EOL]         delegateBooleanAssertion(types, 4, 5, true); [EOL]         list4 = (List<String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 4, false); [EOL]         list6 = list4; [EOL]         delegateBooleanAssertion(types, 4, 6, true); [EOL]         list4 = (List<String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 4, false); [EOL] //        list5 = list5; [EOL]         delegateBooleanAssertion(types, 5, 5, true); [EOL]         list6 = (List<? super String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 6, false); [EOL]         list5 = (List<? extends String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 5, false); [EOL] //        list6 = list6; [EOL]         delegateBooleanAssertion(types, 6, 6, true); [EOL]  [EOL] //        list7 = list7; [EOL]         delegateBooleanAssertion(types, 7, 7, true); [EOL]         list8 = list7; [EOL]         delegateBooleanAssertion(types, 7, 8, true); [EOL]         list7 = list8; [EOL]         delegateBooleanAssertion(types, 8, 7, true); [EOL]         list9 = list7; [EOL]         delegateBooleanAssertion(types, 7, 9, true); [EOL]         list7 = list9; [EOL]         delegateBooleanAssertion(types, 9, 7, true); [EOL]         list10 = list7; [EOL]         delegateBooleanAssertion(types, 7, 10, true); [EOL]         list7 = list10; [EOL]         delegateBooleanAssertion(types, 10, 7, true); [EOL]         list11 = list7; [EOL]         delegateBooleanAssertion(types, 7, 11, true); [EOL]         list7 = list11; [EOL]         delegateBooleanAssertion(types, 11, 7, true); [EOL]         list12 = list7; [EOL]         delegateBooleanAssertion(types, 7, 12, true); [EOL]         list7 = list12; [EOL]         delegateBooleanAssertion(types, 12, 7, true); [EOL]         list13 = list7; [EOL]         delegateBooleanAssertion(types, 7, 13, true); [EOL]         list7 = list13; [EOL]         delegateBooleanAssertion(types, 13, 7, true); [EOL] //        list8 = list8; [EOL]         delegateBooleanAssertion(types, 8, 8, true); [EOL]         list9 = list8; [EOL]         delegateBooleanAssertion(types, 8, 9, true); [EOL]         list8 = (List<Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 8, false); [EOL]         list10 = list8; [EOL]         delegateBooleanAssertion(types, 8, 10, true); [EOL]         list8 = (List<Object>[]) list10; // NOTE cast is required by Sun Java, but not by Eclipse [EOL]         delegateBooleanAssertion(types, 10, 8, false); [EOL]         // list11 = list8; [EOL]         delegateBooleanAssertion(types, 8, 11, false); [EOL]         // list8 = list11; [EOL]         delegateBooleanAssertion(types, 11, 8, false); [EOL]         // list12 = list8; [EOL]         delegateBooleanAssertion(types, 8, 12, false); [EOL]         // list8 = list12; [EOL]         delegateBooleanAssertion(types, 12, 8, false); [EOL]         list13 = list8; [EOL]         delegateBooleanAssertion(types, 8, 13, true); [EOL]         list8 = (List<Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 8, false); [EOL] //        list9 = list9; [EOL]         delegateBooleanAssertion(types, 9, 9, true); [EOL]         list10 = (List<? super Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 10, false); [EOL]         list9 = list10; [EOL]         delegateBooleanAssertion(types, 10, 9, true); [EOL]         list11 = (List<String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 11, false); [EOL]         list9 = list11; [EOL]         delegateBooleanAssertion(types, 11, 9, true); [EOL]         list12 = (List<? extends String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 12, false); [EOL]         list9 = list12; [EOL]         delegateBooleanAssertion(types, 12, 9, true); [EOL]         list13 = (List<? super String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 13, false); [EOL]         list9 = list13; [EOL]         delegateBooleanAssertion(types, 13, 9, true); [EOL] //        list10 = list10; [EOL]         delegateBooleanAssertion(types, 10, 10, true); [EOL]         // list11 = list10; [EOL]         delegateBooleanAssertion(types, 10, 11, false); [EOL]         // list10 = list11; [EOL]         delegateBooleanAssertion(types, 11, 10, false); [EOL]         // list12 = list10; [EOL]         delegateBooleanAssertion(types, 10, 12, false); [EOL]         // list10 = list12; [EOL]         delegateBooleanAssertion(types, 12, 10, false); [EOL]         list13 = list10; [EOL]         delegateBooleanAssertion(types, 10, 13, true); [EOL]         list10 = (List<? super Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 10, false); [EOL] //        list11 = list11; [EOL]         delegateBooleanAssertion(types, 11, 11, true); [EOL]         list12 = list11; [EOL]         delegateBooleanAssertion(types, 11, 12, true); [EOL]         list11 = (List<String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 11, false); [EOL]         list13 = list11; [EOL]         delegateBooleanAssertion(types, 11, 13, true); [EOL]         list11 = (List<String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 11, false); [EOL] //        list12 = list12; [EOL]         delegateBooleanAssertion(types, 12, 12, true); [EOL]         list13 = (List<? super String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 13, false); [EOL]         list12 = (List<? extends String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 12, false); [EOL] //        list13 = list13; [EOL]         delegateBooleanAssertion(types, 13, 13, true); [EOL]         final Type disType = getClass().getField("dis").getGenericType(); [EOL]         // Reporter.log( ( ( ParameterizedType ) disType [EOL]         // ).getOwnerType().getClass().toString() ); [EOL]         final Type datType = getClass().getField("dat").getGenericType(); [EOL]         final Type daType = getClass().getField("da").getGenericType(); [EOL]         final Type uhderType = getClass().getField("uhder").getGenericType(); [EOL]         final Type dingType = getClass().getField("ding").getGenericType(); [EOL]         final Type testerType = getClass().getField("tester").getGenericType(); [EOL]         final Type tester2Type = getClass().getField("tester2").getGenericType(); [EOL]         final Type dat2Type = getClass().getField("dat2").getGenericType(); [EOL]         final Type dat3Type = getClass().getField("dat3").getGenericType(); [EOL]         dis = dat; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(datType, disType)); [EOL]         // dis = da; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(daType, disType)); [EOL]         dis = uhder; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(uhderType, disType)); [EOL]         dis = ding; [EOL]         Assert.assertFalse(String.format("type %s not assignable to %s!", dingType, disType), [EOL]                 TypeUtils.isAssignable(dingType, disType)); [EOL]         dis = tester; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(testerType, disType)); [EOL]         // dis = tester2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(tester2Type, disType)); [EOL]         // dat = dat2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat2Type, datType)); [EOL]         // dat2 = dat; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(datType, dat2Type)); [EOL]         // dat = dat3; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat3Type, datType)); [EOL]         final char ch = 0; [EOL]         final boolean bo = false; [EOL]         final byte by = 0; [EOL]         final short sh = 0; [EOL]         int in = 0; [EOL]         long lo = 0; [EOL]         final float fl = 0; [EOL]         double du = 0; [EOL]         du = ch; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(char.class, double.class)); [EOL]         du = by; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(byte.class, double.class)); [EOL]         du = sh; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(short.class, double.class)); [EOL]         du = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, double.class)); [EOL]         du = lo; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(long.class, double.class)); [EOL]         du = fl; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(float.class, double.class)); [EOL]         lo = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, long.class)); [EOL]         lo = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, long.class)); [EOL]         // Long lngW = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, Long.class)); [EOL]         // lngW = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, Long.class)); [EOL]         in = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, int.class)); [EOL]         final Integer inte = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Integer.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Number.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Object.class)); [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, intComparableType)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Comparable.class)); [EOL]         final Serializable ser = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Serializable.class)); [EOL]         final Type longComparableType = getClass().getField("longComparable").getGenericType(); [EOL]         // longComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, longComparableType)); [EOL]         // longComparable = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, longComparableType)); [EOL]         // int[] ia; [EOL]         // long[] la = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, long[].class)); [EOL]         final Integer[] ia = null; [EOL]         final Type caType = getClass().getField("intWildcardComparable").getGenericType(); [EOL]         intWildcardComparable = ia; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, caType)); [EOL]         // int[] ina = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer[].class, int[].class)); [EOL]         final int[] ina = null; [EOL]         Object[] oa; [EOL]         // oa = ina; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, Object[].class)); [EOL]         oa = new Integer[0]; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, Object[].class)); [EOL]         final Type bClassType = AClass.class.getField("bClass").getGenericType(); [EOL]         final Type cClassType = AClass.class.getField("cClass").getGenericType(); [EOL]         final Type dClassType = AClass.class.getField("dClass").getGenericType(); [EOL]         final Type eClassType = AClass.class.getField("eClass").getGenericType(); [EOL]         final Type fClassType = AClass.class.getField("fClass").getGenericType(); [EOL]         final AClass aClass = new AClass(new AAClass<String>()); [EOL]         aClass.bClass = aClass.cClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(cClassType, bClassType)); [EOL]         aClass.bClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, bClassType)); [EOL]         aClass.bClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, bClassType)); [EOL]         aClass.bClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, bClassType)); [EOL]         aClass.cClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, cClassType)); [EOL]         aClass.cClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, cClassType)); [EOL]         aClass.cClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, cClassType)); [EOL]         aClass.dClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, dClassType)); [EOL]         aClass.dClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, dClassType)); [EOL]         aClass.eClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, eClassType)); [EOL]     } [EOL]  [EOL]     public void delegateBooleanAssertion(final Type[] types, final int i2, final int i1, final boolean expected) { [EOL]         final Type type1 = types[i1]; [EOL]         final Type type2 = types[i2]; [EOL]         final boolean isAssignable = TypeUtils.isAssignable(type2, type1); [EOL]  [EOL]         if (expected) { [EOL]             Assert.assertTrue("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } else { [EOL]             Assert.assertFalse("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } [EOL]     } [EOL]  [EOL]     @SuppressWarnings("boxing") // boxing is deliberate here [EOL]
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [EOL]         final Type[] types = method.getGenericParameterTypes(); [EOL] //        list0 = list0; [EOL]         delegateBooleanAssertion(types, 0, 0, true); [EOL]         list1 = list0; [EOL]         delegateBooleanAssertion(types, 0, 1, true); [EOL]         list0 = list1; [EOL]         delegateBooleanAssertion(types, 1, 0, true); [EOL]         list2 = list0; [EOL]         delegateBooleanAssertion(types, 0, 2, true); [EOL]         list0 = list2; [EOL]         delegateBooleanAssertion(types, 2, 0, true); [EOL]         list3 = list0; [EOL]         delegateBooleanAssertion(types, 0, 3, true); [EOL]         list0 = list3; [EOL]         delegateBooleanAssertion(types, 3, 0, true); [EOL]         list4 = list0; [EOL]         delegateBooleanAssertion(types, 0, 4, true); [EOL]         list0 = list4; [EOL]         delegateBooleanAssertion(types, 4, 0, true); [EOL]         list5 = list0; [EOL]         delegateBooleanAssertion(types, 0, 5, true); [EOL]         list0 = list5; [EOL]         delegateBooleanAssertion(types, 5, 0, true); [EOL]         list6 = list0; [EOL]         delegateBooleanAssertion(types, 0, 6, true); [EOL]         list0 = list6; [EOL]         delegateBooleanAssertion(types, 6, 0, true); [EOL] //        list1 = list1; [EOL]         delegateBooleanAssertion(types, 1, 1, true); [EOL]         list2 = list1; [EOL]         delegateBooleanAssertion(types, 1, 2, true); [EOL]         list1 = (List<Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 1, false); [EOL]         list3 = list1; [EOL]         delegateBooleanAssertion(types, 1, 3, true); [EOL]         list1 = (List<Object>) list3; [EOL]         delegateBooleanAssertion(types, 3, 1, false); [EOL]         // list4 = list1; [EOL]         delegateBooleanAssertion(types, 1, 4, false); [EOL]         // list1 = list4; [EOL]         delegateBooleanAssertion(types, 4, 1, false); [EOL]         // list5 = list1; [EOL]         delegateBooleanAssertion(types, 1, 5, false); [EOL]         // list1 = list5; [EOL]         delegateBooleanAssertion(types, 5, 1, false); [EOL]         list6 = list1; [EOL]         delegateBooleanAssertion(types, 1, 6, true); [EOL]         list1 = (List<Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 1, false); [EOL] //        list2 = list2; [EOL]         delegateBooleanAssertion(types, 2, 2, true); [EOL]         list2 = list3; [EOL]         delegateBooleanAssertion(types, 2, 3, false); [EOL]         list2 = list4; [EOL]         delegateBooleanAssertion(types, 3, 2, true); [EOL]         list3 = (List<? super Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 4, false); [EOL]         list2 = list5; [EOL]         delegateBooleanAssertion(types, 4, 2, true); [EOL]         list4 = (List<String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 5, false); [EOL]         list2 = list6; [EOL]         delegateBooleanAssertion(types, 5, 2, true); [EOL]         list5 = (List<? extends String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 6, false); [EOL] //        list3 = list3; [EOL]         delegateBooleanAssertion(types, 6, 2, true); [EOL]         list6 = (List<? super String>) list2; [EOL]         delegateBooleanAssertion(types, 3, 3, true); [EOL]         // list4 = list3; [EOL]         delegateBooleanAssertion(types, 3, 4, false); [EOL]         // list3 = list4; [EOL]         delegateBooleanAssertion(types, 4, 3, false); [EOL]         // list5 = list3; [EOL]         delegateBooleanAssertion(types, 3, 5, false); [EOL]         // list3 = list5; [EOL]         delegateBooleanAssertion(types, 5, 3, false); [EOL]         list6 = list3; [EOL]         delegateBooleanAssertion(types, 3, 6, true); [EOL]         list3 = (List<? super Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 3, false); [EOL] //        list4 = list4; [EOL]         delegateBooleanAssertion(types, 4, 4, true); [EOL]         list5 = list4; [EOL]         delegateBooleanAssertion(types, 4, 5, true); [EOL]         list4 = (List<String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 4, false); [EOL]         list6 = list4; [EOL]         delegateBooleanAssertion(types, 4, 6, true); [EOL]         list4 = (List<String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 4, false); [EOL] //        list5 = list5; [EOL]         delegateBooleanAssertion(types, 5, 5, true); [EOL]         list6 = (List<? super String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 6, false); [EOL]         list5 = (List<? extends String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 5, false); [EOL] //        list6 = list6; [EOL]         delegateBooleanAssertion(types, 6, 6, true); [EOL]  [EOL] //        list7 = list7; [EOL]         delegateBooleanAssertion(types, 7, 7, true); [EOL]         list8 = list7; [EOL]         delegateBooleanAssertion(types, 7, 8, true); [EOL]         list7 = list8; [EOL]         delegateBooleanAssertion(types, 8, 7, true); [EOL]         list9 = list7; [EOL]         delegateBooleanAssertion(types, 7, 9, true); [EOL]         list7 = list9; [EOL]         delegateBooleanAssertion(types, 9, 7, true); [EOL]         list10 = list7; [EOL]         delegateBooleanAssertion(types, 7, 10, true); [EOL]         list7 = list10; [EOL]         delegateBooleanAssertion(types, 10, 7, true); [EOL]         list11 = list7; [EOL]         delegateBooleanAssertion(types, 7, 11, true); [EOL]         list7 = list11; [EOL]         delegateBooleanAssertion(types, 11, 7, true); [EOL]         list12 = list7; [EOL]         delegateBooleanAssertion(types, 7, 12, true); [EOL]         list7 = list12; [EOL]         delegateBooleanAssertion(types, 12, 7, true); [EOL]         list13 = list7; [EOL]         delegateBooleanAssertion(types, 7, 13, true); [EOL]         list7 = list13; [EOL]         delegateBooleanAssertion(types, 13, 7, true); [EOL] //        list8 = list8; [EOL]         delegateBooleanAssertion(types, 8, 8, true); [EOL]         list9 = list8; [EOL]         delegateBooleanAssertion(types, 8, 9, true); [EOL]         list8 = (List<Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 8, false); [EOL]         list10 = list8; [EOL]         delegateBooleanAssertion(types, 8, 10, true); [EOL]         list8 = (List<Object>[]) list10; // NOTE cast is required by Sun Java, but not by Eclipse [EOL]         delegateBooleanAssertion(types, 10, 8, false); [EOL]         // list11 = list8; [EOL]         delegateBooleanAssertion(types, 8, 11, false); [EOL]         // list8 = list11; [EOL]         delegateBooleanAssertion(types, 11, 8, false); [EOL]         // list12 = list8; [EOL]         delegateBooleanAssertion(types, 8, 12, false); [EOL]         // list8 = list12; [EOL]         delegateBooleanAssertion(types, 12, 8, false); [EOL]         list13 = list8; [EOL]         delegateBooleanAssertion(types, 8, 13, true); [EOL]         list8 = (List<Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 8, false); [EOL] //        list9 = list9; [EOL]         delegateBooleanAssertion(types, 9, 9, true); [EOL]         list10 = (List<? super Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 10, false); [EOL]         list9 = list10; [EOL]         delegateBooleanAssertion(types, 10, 9, true); [EOL]         list11 = (List<String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 11, false); [EOL]         list9 = list11; [EOL]         delegateBooleanAssertion(types, 11, 9, true); [EOL]         list12 = (List<? extends String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 12, false); [EOL]         list9 = list12; [EOL]         delegateBooleanAssertion(types, 12, 9, true); [EOL]         list13 = (List<? super String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 13, false); [EOL]         list9 = list13; [EOL]         delegateBooleanAssertion(types, 13, 9, true); [EOL] //        list10 = list10; [EOL]         delegateBooleanAssertion(types, 10, 10, true); [EOL]         // list11 = list10; [EOL]         delegateBooleanAssertion(types, 10, 11, false); [EOL]         // list10 = list11; [EOL]         delegateBooleanAssertion(types, 11, 10, false); [EOL]         // list12 = list10; [EOL]         delegateBooleanAssertion(types, 10, 12, false); [EOL]         // list10 = list12; [EOL]         delegateBooleanAssertion(types, 12, 10, false); [EOL]         list13 = list10; [EOL]         delegateBooleanAssertion(types, 10, 13, true); [EOL]         list10 = (List<? super Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 10, false); [EOL] //        list11 = list11; [EOL]         delegateBooleanAssertion(types, 11, 11, true); [EOL]         list12 = list11; [EOL]         delegateBooleanAssertion(types, 11, 12, true); [EOL]         list11 = (List<String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 11, false); [EOL]         list13 = list11; [EOL]         delegateBooleanAssertion(types, 11, 13, true); [EOL]         list11 = (List<String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 11, false); [EOL] //        list12 = list12; [EOL]         delegateBooleanAssertion(types, 12, 12, true); [EOL]         list13 = (List<? super String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 13, false); [EOL]         list12 = (List<? extends String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 12, false); [EOL] //        list13 = list13; [EOL]         delegateBooleanAssertion(types, 13, 13, true); [EOL]         final Type disType = getClass().getField("dis").getGenericType(); [EOL]         // Reporter.log( ( ( ParameterizedType ) disType [EOL]         // ).getOwnerType().getClass().toString() ); [EOL]         final Type datType = getClass().getField("dat").getGenericType(); [EOL]         final Type daType = getClass().getField("da").getGenericType(); [EOL]         final Type uhderType = getClass().getField("uhder").getGenericType(); [EOL]         final Type dingType = getClass().getField("ding").getGenericType(); [EOL]         final Type testerType = getClass().getField("tester").getGenericType(); [EOL]         final Type tester2Type = getClass().getField("tester2").getGenericType(); [EOL]         final Type dat2Type = getClass().getField("dat2").getGenericType(); [EOL]         final Type dat3Type = getClass().getField("dat3").getGenericType(); [EOL]         dis = dat; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(datType, disType)); [EOL]         // dis = da; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(daType, disType)); [EOL]         dis = uhder; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(uhderType, disType)); [EOL]         dis = ding; [EOL]         Assert.assertFalse(String.format("type %s not assignable to %s!", dingType, disType), [EOL]                 TypeUtils.isAssignable(dingType, disType)); [EOL]         dis = tester; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(testerType, disType)); [EOL]         // dis = tester2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(tester2Type, disType)); [EOL]         // dat = dat2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat2Type, datType)); [EOL]         // dat2 = dat; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(datType, dat2Type)); [EOL]         // dat = dat3; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat3Type, datType)); [EOL]         final char ch = 0; [EOL]         final boolean bo = false; [EOL]         final byte by = 0; [EOL]         final short sh = 0; [EOL]         int in = 0; [EOL]         long lo = 0; [EOL]         final float fl = 0; [EOL]         double du = 0; [EOL]         du = ch; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(char.class, double.class)); [EOL]         du = by; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(byte.class, double.class)); [EOL]         du = sh; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(short.class, double.class)); [EOL]         du = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, double.class)); [EOL]         du = lo; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(long.class, double.class)); [EOL]         du = fl; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(float.class, double.class)); [EOL]         lo = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, long.class)); [EOL]         lo = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, long.class)); [EOL]         // Long lngW = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, Long.class)); [EOL]         // lngW = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, Long.class)); [EOL]         in = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, int.class)); [EOL]         final Integer inte = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Integer.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Number.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Object.class)); [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, intComparableType)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Comparable.class)); [EOL]         final Serializable ser = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Serializable.class)); [EOL]         final Type longComparableType = getClass().getField("longComparable").getGenericType(); [EOL]         // longComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, longComparableType)); [EOL]         // longComparable = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, longComparableType)); [EOL]         // int[] ia; [EOL]         // long[] la = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, long[].class)); [EOL]         final Integer[] ia = null; [EOL]         final Type caType = getClass().getField("intWildcardComparable").getGenericType(); [EOL]         intWildcardComparable = ia; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, caType)); [EOL]         // int[] ina = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer[].class, int[].class)); [EOL]         final int[] ina = null; [EOL]         Object[] oa; [EOL]         // oa = ina; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, Object[].class)); [EOL]         oa = new Integer[0]; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, Object[].class)); [EOL]         final Type bClassType = AClass.class.getField("bClass").getGenericType(); [EOL]         final Type cClassType = AClass.class.getField("cClass").getGenericType(); [EOL]         final Type dClassType = AClass.class.getField("dClass").getGenericType(); [EOL]         final Type eClassType = AClass.class.getField("eClass").getGenericType(); [EOL]         final Type fClassType = AClass.class.getField("fClass").getGenericType(); [EOL]         final AClass aClass = new AClass(new AAClass<String>()); [EOL]         aClass.bClass = aClass.cClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(cClassType, bClassType)); [EOL]         aClass.bClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, bClassType)); [EOL]         aClass.bClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, bClassType)); [EOL]         aClass.bClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, bClassType)); [EOL]         aClass.cClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, cClassType)); [EOL]         aClass.cClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, cClassType)); [EOL]         aClass.cClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, cClassType)); [EOL]         aClass.dClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, dClassType)); [EOL]         aClass.dClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, dClassType)); [EOL]         aClass.eClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, eClassType)); [EOL]     } [EOL]  [EOL]     public void delegateBooleanAssertion(final Type[] types, final int i2, final int i1, final boolean expected) { [EOL]         final Type type1 = types[i1]; [EOL]         final Type type2 = types[i2]; [EOL]         final boolean isAssignable = TypeUtils.isAssignable(type2, type1); [EOL]  [EOL]         if (expected) { [EOL]             Assert.assertTrue("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } else { [EOL]             Assert.assertFalse("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } [EOL]     } [EOL]  [EOL]     @SuppressWarnings("boxing") // boxing is deliberate here [EOL]
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [EOL]         final Type[] types = method.getGenericParameterTypes(); [EOL] //        list0 = list0; [EOL]         delegateBooleanAssertion(types, 0, 0, true); [EOL]         list1 = list0; [EOL]         delegateBooleanAssertion(types, 0, 1, true); [EOL]         list0 = list1; [EOL]         delegateBooleanAssertion(types, 1, 0, true); [EOL]         list2 = list0; [EOL]         delegateBooleanAssertion(types, 0, 2, true); [EOL]         list0 = list2; [EOL]         delegateBooleanAssertion(types, 2, 0, true); [EOL]         list3 = list0; [EOL]         delegateBooleanAssertion(types, 0, 3, true); [EOL]         list0 = list3; [EOL]         delegateBooleanAssertion(types, 3, 0, true); [EOL]         list4 = list0; [EOL]         delegateBooleanAssertion(types, 0, 4, true); [EOL]         list0 = list4; [EOL]         delegateBooleanAssertion(types, 4, 0, true); [EOL]         list5 = list0; [EOL]         delegateBooleanAssertion(types, 0, 5, true); [EOL]         list0 = list5; [EOL]         delegateBooleanAssertion(types, 5, 0, true); [EOL]         list6 = list0; [EOL]         delegateBooleanAssertion(types, 0, 6, true); [EOL]         list0 = list6; [EOL]         delegateBooleanAssertion(types, 6, 0, true); [EOL] //        list1 = list1; [EOL]         delegateBooleanAssertion(types, 1, 1, true); [EOL]         list2 = list1; [EOL]         delegateBooleanAssertion(types, 1, 2, true); [EOL]         list1 = (List<Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 1, false); [EOL]         list3 = list1; [EOL]         delegateBooleanAssertion(types, 1, 3, true); [EOL]         list1 = (List<Object>) list3; [EOL]         delegateBooleanAssertion(types, 3, 1, false); [EOL]         // list4 = list1; [EOL]         delegateBooleanAssertion(types, 1, 4, false); [EOL]         // list1 = list4; [EOL]         delegateBooleanAssertion(types, 4, 1, false); [EOL]         // list5 = list1; [EOL]         delegateBooleanAssertion(types, 1, 5, false); [EOL]         // list1 = list5; [EOL]         delegateBooleanAssertion(types, 5, 1, false); [EOL]         list6 = list1; [EOL]         delegateBooleanAssertion(types, 1, 6, true); [EOL]         list1 = (List<Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 1, false); [EOL] //        list2 = list2; [EOL]         delegateBooleanAssertion(types, 2, 2, true); [EOL]         list2 = list3; [EOL]         delegateBooleanAssertion(types, 2, 3, false); [EOL]         list2 = list4; [EOL]         delegateBooleanAssertion(types, 3, 2, true); [EOL]         list3 = (List<? super Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 4, false); [EOL]         list2 = list5; [EOL]         delegateBooleanAssertion(types, 4, 2, true); [EOL]         list4 = (List<String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 5, false); [EOL]         list2 = list6; [EOL]         delegateBooleanAssertion(types, 5, 2, true); [EOL]         list5 = (List<? extends String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 6, false); [EOL] //        list3 = list3; [EOL]         delegateBooleanAssertion(types, 6, 2, true); [EOL]         list6 = (List<? super String>) list2; [EOL]         delegateBooleanAssertion(types, 3, 3, true); [EOL]         // list4 = list3; [EOL]         delegateBooleanAssertion(types, 3, 4, false); [EOL]         // list3 = list4; [EOL]         delegateBooleanAssertion(types, 4, 3, false); [EOL]         // list5 = list3; [EOL]         delegateBooleanAssertion(types, 3, 5, false); [EOL]         // list3 = list5; [EOL]         delegateBooleanAssertion(types, 5, 3, false); [EOL]         list6 = list3; [EOL]         delegateBooleanAssertion(types, 3, 6, true); [EOL]         list3 = (List<? super Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 3, false); [EOL] //        list4 = list4; [EOL]         delegateBooleanAssertion(types, 4, 4, true); [EOL]         list5 = list4; [EOL]         delegateBooleanAssertion(types, 4, 5, true); [EOL]         list4 = (List<String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 4, false); [EOL]         list6 = list4; [EOL]         delegateBooleanAssertion(types, 4, 6, true); [EOL]         list4 = (List<String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 4, false); [EOL] //        list5 = list5; [EOL]         delegateBooleanAssertion(types, 5, 5, true); [EOL]         list6 = (List<? super String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 6, false); [EOL]         list5 = (List<? extends String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 5, false); [EOL] //        list6 = list6; [EOL]         delegateBooleanAssertion(types, 6, 6, true); [EOL]  [EOL] //        list7 = list7; [EOL]         delegateBooleanAssertion(types, 7, 7, true); [EOL]         list8 = list7; [EOL]         delegateBooleanAssertion(types, 7, 8, true); [EOL]         list7 = list8; [EOL]         delegateBooleanAssertion(types, 8, 7, true); [EOL]         list9 = list7; [EOL]         delegateBooleanAssertion(types, 7, 9, true); [EOL]         list7 = list9; [EOL]         delegateBooleanAssertion(types, 9, 7, true); [EOL]         list10 = list7; [EOL]         delegateBooleanAssertion(types, 7, 10, true); [EOL]         list7 = list10; [EOL]         delegateBooleanAssertion(types, 10, 7, true); [EOL]         list11 = list7; [EOL]         delegateBooleanAssertion(types, 7, 11, true); [EOL]         list7 = list11; [EOL]         delegateBooleanAssertion(types, 11, 7, true); [EOL]         list12 = list7; [EOL]         delegateBooleanAssertion(types, 7, 12, true); [EOL]         list7 = list12; [EOL]         delegateBooleanAssertion(types, 12, 7, true); [EOL]         list13 = list7; [EOL]         delegateBooleanAssertion(types, 7, 13, true); [EOL]         list7 = list13; [EOL]         delegateBooleanAssertion(types, 13, 7, true); [EOL] //        list8 = list8; [EOL]         delegateBooleanAssertion(types, 8, 8, true); [EOL]         list9 = list8; [EOL]         delegateBooleanAssertion(types, 8, 9, true); [EOL]         list8 = (List<Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 8, false); [EOL]         list10 = list8; [EOL]         delegateBooleanAssertion(types, 8, 10, true); [EOL]         list8 = (List<Object>[]) list10; // NOTE cast is required by Sun Java, but not by Eclipse [EOL]         delegateBooleanAssertion(types, 10, 8, false); [EOL]         // list11 = list8; [EOL]         delegateBooleanAssertion(types, 8, 11, false); [EOL]         // list8 = list11; [EOL]         delegateBooleanAssertion(types, 11, 8, false); [EOL]         // list12 = list8; [EOL]         delegateBooleanAssertion(types, 8, 12, false); [EOL]         // list8 = list12; [EOL]         delegateBooleanAssertion(types, 12, 8, false); [EOL]         list13 = list8; [EOL]         delegateBooleanAssertion(types, 8, 13, true); [EOL]         list8 = (List<Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 8, false); [EOL] //        list9 = list9; [EOL]         delegateBooleanAssertion(types, 9, 9, true); [EOL]         list10 = (List<? super Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 10, false); [EOL]         list9 = list10; [EOL]         delegateBooleanAssertion(types, 10, 9, true); [EOL]         list11 = (List<String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 11, false); [EOL]         list9 = list11; [EOL]         delegateBooleanAssertion(types, 11, 9, true); [EOL]         list12 = (List<? extends String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 12, false); [EOL]         list9 = list12; [EOL]         delegateBooleanAssertion(types, 12, 9, true); [EOL]         list13 = (List<? super String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 13, false); [EOL]         list9 = list13; [EOL]         delegateBooleanAssertion(types, 13, 9, true); [EOL] //        list10 = list10; [EOL]         delegateBooleanAssertion(types, 10, 10, true); [EOL]         // list11 = list10; [EOL]         delegateBooleanAssertion(types, 10, 11, false); [EOL]         // list10 = list11; [EOL]         delegateBooleanAssertion(types, 11, 10, false); [EOL]         // list12 = list10; [EOL]         delegateBooleanAssertion(types, 10, 12, false); [EOL]         // list10 = list12; [EOL]         delegateBooleanAssertion(types, 12, 10, false); [EOL]         list13 = list10; [EOL]         delegateBooleanAssertion(types, 10, 13, true); [EOL]         list10 = (List<? super Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 10, false); [EOL] //        list11 = list11; [EOL]         delegateBooleanAssertion(types, 11, 11, true); [EOL]         list12 = list11; [EOL]         delegateBooleanAssertion(types, 11, 12, true); [EOL]         list11 = (List<String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 11, false); [EOL]         list13 = list11; [EOL]         delegateBooleanAssertion(types, 11, 13, true); [EOL]         list11 = (List<String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 11, false); [EOL] //        list12 = list12; [EOL]         delegateBooleanAssertion(types, 12, 12, true); [EOL]         list13 = (List<? super String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 13, false); [EOL]         list12 = (List<? extends String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 12, false); [EOL] //        list13 = list13; [EOL]         delegateBooleanAssertion(types, 13, 13, true); [EOL]         final Type disType = getClass().getField("dis").getGenericType(); [EOL]         // Reporter.log( ( ( ParameterizedType ) disType [EOL]         // ).getOwnerType().getClass().toString() ); [EOL]         final Type datType = getClass().getField("dat").getGenericType(); [EOL]         final Type daType = getClass().getField("da").getGenericType(); [EOL]         final Type uhderType = getClass().getField("uhder").getGenericType(); [EOL]         final Type dingType = getClass().getField("ding").getGenericType(); [EOL]         final Type testerType = getClass().getField("tester").getGenericType(); [EOL]         final Type tester2Type = getClass().getField("tester2").getGenericType(); [EOL]         final Type dat2Type = getClass().getField("dat2").getGenericType(); [EOL]         final Type dat3Type = getClass().getField("dat3").getGenericType(); [EOL]         dis = dat; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(datType, disType)); [EOL]         // dis = da; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(daType, disType)); [EOL]         dis = uhder; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(uhderType, disType)); [EOL]         dis = ding; [EOL]         Assert.assertFalse(String.format("type %s not assignable to %s!", dingType, disType), [EOL]                 TypeUtils.isAssignable(dingType, disType)); [EOL]         dis = tester; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(testerType, disType)); [EOL]         // dis = tester2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(tester2Type, disType)); [EOL]         // dat = dat2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat2Type, datType)); [EOL]         // dat2 = dat; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(datType, dat2Type)); [EOL]         // dat = dat3; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat3Type, datType)); [EOL]         final char ch = 0; [EOL]         final boolean bo = false; [EOL]         final byte by = 0; [EOL]         final short sh = 0; [EOL]         int in = 0; [EOL]         long lo = 0; [EOL]         final float fl = 0; [EOL]         double du = 0; [EOL]         du = ch; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(char.class, double.class)); [EOL]         du = by; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(byte.class, double.class)); [EOL]         du = sh; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(short.class, double.class)); [EOL]         du = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, double.class)); [EOL]         du = lo; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(long.class, double.class)); [EOL]         du = fl; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(float.class, double.class)); [EOL]         lo = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, long.class)); [EOL]         lo = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, long.class)); [EOL]         // Long lngW = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, Long.class)); [EOL]         // lngW = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, Long.class)); [EOL]         in = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, int.class)); [EOL]         final Integer inte = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Integer.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Number.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Object.class)); [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, intComparableType)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Comparable.class)); [EOL]         final Serializable ser = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Serializable.class)); [EOL]         final Type longComparableType = getClass().getField("longComparable").getGenericType(); [EOL]         // longComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, longComparableType)); [EOL]         // longComparable = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, longComparableType)); [EOL]         // int[] ia; [EOL]         // long[] la = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, long[].class)); [EOL]         final Integer[] ia = null; [EOL]         final Type caType = getClass().getField("intWildcardComparable").getGenericType(); [EOL]         intWildcardComparable = ia; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, caType)); [EOL]         // int[] ina = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer[].class, int[].class)); [EOL]         final int[] ina = null; [EOL]         Object[] oa; [EOL]         // oa = ina; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, Object[].class)); [EOL]         oa = new Integer[0]; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, Object[].class)); [EOL]         final Type bClassType = AClass.class.getField("bClass").getGenericType(); [EOL]         final Type cClassType = AClass.class.getField("cClass").getGenericType(); [EOL]         final Type dClassType = AClass.class.getField("dClass").getGenericType(); [EOL]         final Type eClassType = AClass.class.getField("eClass").getGenericType(); [EOL]         final Type fClassType = AClass.class.getField("fClass").getGenericType(); [EOL]         final AClass aClass = new AClass(new AAClass<String>()); [EOL]         aClass.bClass = aClass.cClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(cClassType, bClassType)); [EOL]         aClass.bClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, bClassType)); [EOL]         aClass.bClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, bClassType)); [EOL]         aClass.bClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, bClassType)); [EOL]         aClass.cClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, cClassType)); [EOL]         aClass.cClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, cClassType)); [EOL]         aClass.cClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, cClassType)); [EOL]         aClass.dClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, dClassType)); [EOL]         aClass.dClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, dClassType)); [EOL]         aClass.eClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, eClassType)); [EOL]     } [EOL]  [EOL]     public void delegateBooleanAssertion(final Type[] types, final int i2, final int i1, final boolean expected) { [EOL]         final Type type1 = types[i1]; [EOL]         final Type type2 = types[i2]; [EOL]         final boolean isAssignable = TypeUtils.isAssignable(type2, type1); [EOL]  [EOL]         if (expected) { [EOL]             Assert.assertTrue("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } else { [EOL]             Assert.assertFalse("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } [EOL]     } [EOL]  [EOL]     @SuppressWarnings("boxing") // boxing is deliberate here [EOL]
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [EOL]         final Type[] types = method.getGenericParameterTypes(); [EOL] //        list0 = list0; [EOL]         delegateBooleanAssertion(types, 0, 0, true); [EOL]         list1 = list0; [EOL]         delegateBooleanAssertion(types, 0, 1, true); [EOL]         list0 = list1; [EOL]         delegateBooleanAssertion(types, 1, 0, true); [EOL]         list2 = list0; [EOL]         delegateBooleanAssertion(types, 0, 2, true); [EOL]         list0 = list2; [EOL]         delegateBooleanAssertion(types, 2, 0, true); [EOL]         list3 = list0; [EOL]         delegateBooleanAssertion(types, 0, 3, true); [EOL]         list0 = list3; [EOL]         delegateBooleanAssertion(types, 3, 0, true); [EOL]         list4 = list0; [EOL]         delegateBooleanAssertion(types, 0, 4, true); [EOL]         list0 = list4; [EOL]         delegateBooleanAssertion(types, 4, 0, true); [EOL]         list5 = list0; [EOL]         delegateBooleanAssertion(types, 0, 5, true); [EOL]         list0 = list5; [EOL]         delegateBooleanAssertion(types, 5, 0, true); [EOL]         list6 = list0; [EOL]         delegateBooleanAssertion(types, 0, 6, true); [EOL]         list0 = list6; [EOL]         delegateBooleanAssertion(types, 6, 0, true); [EOL] //        list1 = list1; [EOL]         delegateBooleanAssertion(types, 1, 1, true); [EOL]         list2 = list1; [EOL]         delegateBooleanAssertion(types, 1, 2, true); [EOL]         list1 = (List<Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 1, false); [EOL]         list3 = list1; [EOL]         delegateBooleanAssertion(types, 1, 3, true); [EOL]         list1 = (List<Object>) list3; [EOL]         delegateBooleanAssertion(types, 3, 1, false); [EOL]         // list4 = list1; [EOL]         delegateBooleanAssertion(types, 1, 4, false); [EOL]         // list1 = list4; [EOL]         delegateBooleanAssertion(types, 4, 1, false); [EOL]         // list5 = list1; [EOL]         delegateBooleanAssertion(types, 1, 5, false); [EOL]         // list1 = list5; [EOL]         delegateBooleanAssertion(types, 5, 1, false); [EOL]         list6 = list1; [EOL]         delegateBooleanAssertion(types, 1, 6, true); [EOL]         list1 = (List<Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 1, false); [EOL] //        list2 = list2; [EOL]         delegateBooleanAssertion(types, 2, 2, true); [EOL]         list2 = list3; [EOL]         delegateBooleanAssertion(types, 2, 3, false); [EOL]         list2 = list4; [EOL]         delegateBooleanAssertion(types, 3, 2, true); [EOL]         list3 = (List<? super Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 4, false); [EOL]         list2 = list5; [EOL]         delegateBooleanAssertion(types, 4, 2, true); [EOL]         list4 = (List<String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 5, false); [EOL]         list2 = list6; [EOL]         delegateBooleanAssertion(types, 5, 2, true); [EOL]         list5 = (List<? extends String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 6, false); [EOL] //        list3 = list3; [EOL]         delegateBooleanAssertion(types, 6, 2, true); [EOL]         list6 = (List<? super String>) list2; [EOL]         delegateBooleanAssertion(types, 3, 3, true); [EOL]         // list4 = list3; [EOL]         delegateBooleanAssertion(types, 3, 4, false); [EOL]         // list3 = list4; [EOL]         delegateBooleanAssertion(types, 4, 3, false); [EOL]         // list5 = list3; [EOL]         delegateBooleanAssertion(types, 3, 5, false); [EOL]         // list3 = list5; [EOL]         delegateBooleanAssertion(types, 5, 3, false); [EOL]         list6 = list3; [EOL]         delegateBooleanAssertion(types, 3, 6, true); [EOL]         list3 = (List<? super Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 3, false); [EOL] //        list4 = list4; [EOL]         delegateBooleanAssertion(types, 4, 4, true); [EOL]         list5 = list4; [EOL]         delegateBooleanAssertion(types, 4, 5, true); [EOL]         list4 = (List<String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 4, false); [EOL]         list6 = list4; [EOL]         delegateBooleanAssertion(types, 4, 6, true); [EOL]         list4 = (List<String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 4, false); [EOL] //        list5 = list5; [EOL]         delegateBooleanAssertion(types, 5, 5, true); [EOL]         list6 = (List<? super String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 6, false); [EOL]         list5 = (List<? extends String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 5, false); [EOL] //        list6 = list6; [EOL]         delegateBooleanAssertion(types, 6, 6, true); [EOL]  [EOL] //        list7 = list7; [EOL]         delegateBooleanAssertion(types, 7, 7, true); [EOL]         list8 = list7; [EOL]         delegateBooleanAssertion(types, 7, 8, true); [EOL]         list7 = list8; [EOL]         delegateBooleanAssertion(types, 8, 7, true); [EOL]         list9 = list7; [EOL]         delegateBooleanAssertion(types, 7, 9, true); [EOL]         list7 = list9; [EOL]         delegateBooleanAssertion(types, 9, 7, true); [EOL]         list10 = list7; [EOL]         delegateBooleanAssertion(types, 7, 10, true); [EOL]         list7 = list10; [EOL]         delegateBooleanAssertion(types, 10, 7, true); [EOL]         list11 = list7; [EOL]         delegateBooleanAssertion(types, 7, 11, true); [EOL]         list7 = list11; [EOL]         delegateBooleanAssertion(types, 11, 7, true); [EOL]         list12 = list7; [EOL]         delegateBooleanAssertion(types, 7, 12, true); [EOL]         list7 = list12; [EOL]         delegateBooleanAssertion(types, 12, 7, true); [EOL]         list13 = list7; [EOL]         delegateBooleanAssertion(types, 7, 13, true); [EOL]         list7 = list13; [EOL]         delegateBooleanAssertion(types, 13, 7, true); [EOL] //        list8 = list8; [EOL]         delegateBooleanAssertion(types, 8, 8, true); [EOL]         list9 = list8; [EOL]         delegateBooleanAssertion(types, 8, 9, true); [EOL]         list8 = (List<Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 8, false); [EOL]         list10 = list8; [EOL]         delegateBooleanAssertion(types, 8, 10, true); [EOL]         list8 = (List<Object>[]) list10; // NOTE cast is required by Sun Java, but not by Eclipse [EOL]         delegateBooleanAssertion(types, 10, 8, false); [EOL]         // list11 = list8; [EOL]         delegateBooleanAssertion(types, 8, 11, false); [EOL]         // list8 = list11; [EOL]         delegateBooleanAssertion(types, 11, 8, false); [EOL]         // list12 = list8; [EOL]         delegateBooleanAssertion(types, 8, 12, false); [EOL]         // list8 = list12; [EOL]         delegateBooleanAssertion(types, 12, 8, false); [EOL]         list13 = list8; [EOL]         delegateBooleanAssertion(types, 8, 13, true); [EOL]         list8 = (List<Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 8, false); [EOL] //        list9 = list9; [EOL]         delegateBooleanAssertion(types, 9, 9, true); [EOL]         list10 = (List<? super Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 10, false); [EOL]         list9 = list10; [EOL]         delegateBooleanAssertion(types, 10, 9, true); [EOL]         list11 = (List<String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 11, false); [EOL]         list9 = list11; [EOL]         delegateBooleanAssertion(types, 11, 9, true); [EOL]         list12 = (List<? extends String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 12, false); [EOL]         list9 = list12; [EOL]         delegateBooleanAssertion(types, 12, 9, true); [EOL]         list13 = (List<? super String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 13, false); [EOL]         list9 = list13; [EOL]         delegateBooleanAssertion(types, 13, 9, true); [EOL] //        list10 = list10; [EOL]         delegateBooleanAssertion(types, 10, 10, true); [EOL]         // list11 = list10; [EOL]         delegateBooleanAssertion(types, 10, 11, false); [EOL]         // list10 = list11; [EOL]         delegateBooleanAssertion(types, 11, 10, false); [EOL]         // list12 = list10; [EOL]         delegateBooleanAssertion(types, 10, 12, false); [EOL]         // list10 = list12; [EOL]         delegateBooleanAssertion(types, 12, 10, false); [EOL]         list13 = list10; [EOL]         delegateBooleanAssertion(types, 10, 13, true); [EOL]         list10 = (List<? super Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 10, false); [EOL] //        list11 = list11; [EOL]         delegateBooleanAssertion(types, 11, 11, true); [EOL]         list12 = list11; [EOL]         delegateBooleanAssertion(types, 11, 12, true); [EOL]         list11 = (List<String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 11, false); [EOL]         list13 = list11; [EOL]         delegateBooleanAssertion(types, 11, 13, true); [EOL]         list11 = (List<String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 11, false); [EOL] //        list12 = list12; [EOL]         delegateBooleanAssertion(types, 12, 12, true); [EOL]         list13 = (List<? super String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 13, false); [EOL]         list12 = (List<? extends String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 12, false); [EOL] //        list13 = list13; [EOL]         delegateBooleanAssertion(types, 13, 13, true); [EOL]         final Type disType = getClass().getField("dis").getGenericType(); [EOL]         // Reporter.log( ( ( ParameterizedType ) disType [EOL]         // ).getOwnerType().getClass().toString() ); [EOL]         final Type datType = getClass().getField("dat").getGenericType(); [EOL]         final Type daType = getClass().getField("da").getGenericType(); [EOL]         final Type uhderType = getClass().getField("uhder").getGenericType(); [EOL]         final Type dingType = getClass().getField("ding").getGenericType(); [EOL]         final Type testerType = getClass().getField("tester").getGenericType(); [EOL]         final Type tester2Type = getClass().getField("tester2").getGenericType(); [EOL]         final Type dat2Type = getClass().getField("dat2").getGenericType(); [EOL]         final Type dat3Type = getClass().getField("dat3").getGenericType(); [EOL]         dis = dat; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(datType, disType)); [EOL]         // dis = da; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(daType, disType)); [EOL]         dis = uhder; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(uhderType, disType)); [EOL]         dis = ding; [EOL]         Assert.assertFalse(String.format("type %s not assignable to %s!", dingType, disType), [EOL]                 TypeUtils.isAssignable(dingType, disType)); [EOL]         dis = tester; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(testerType, disType)); [EOL]         // dis = tester2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(tester2Type, disType)); [EOL]         // dat = dat2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat2Type, datType)); [EOL]         // dat2 = dat; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(datType, dat2Type)); [EOL]         // dat = dat3; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat3Type, datType)); [EOL]         final char ch = 0; [EOL]         final boolean bo = false; [EOL]         final byte by = 0; [EOL]         final short sh = 0; [EOL]         int in = 0; [EOL]         long lo = 0; [EOL]         final float fl = 0; [EOL]         double du = 0; [EOL]         du = ch; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(char.class, double.class)); [EOL]         du = by; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(byte.class, double.class)); [EOL]         du = sh; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(short.class, double.class)); [EOL]         du = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, double.class)); [EOL]         du = lo; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(long.class, double.class)); [EOL]         du = fl; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(float.class, double.class)); [EOL]         lo = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, long.class)); [EOL]         lo = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, long.class)); [EOL]         // Long lngW = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, Long.class)); [EOL]         // lngW = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, Long.class)); [EOL]         in = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, int.class)); [EOL]         final Integer inte = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Integer.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Number.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Object.class)); [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, intComparableType)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Comparable.class)); [EOL]         final Serializable ser = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Serializable.class)); [EOL]         final Type longComparableType = getClass().getField("longComparable").getGenericType(); [EOL]         // longComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, longComparableType)); [EOL]         // longComparable = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, longComparableType)); [EOL]         // int[] ia; [EOL]         // long[] la = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, long[].class)); [EOL]         final Integer[] ia = null; [EOL]         final Type caType = getClass().getField("intWildcardComparable").getGenericType(); [EOL]         intWildcardComparable = ia; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, caType)); [EOL]         // int[] ina = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer[].class, int[].class)); [EOL]         final int[] ina = null; [EOL]         Object[] oa; [EOL]         // oa = ina; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, Object[].class)); [EOL]         oa = new Integer[0]; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, Object[].class)); [EOL]         final Type bClassType = AClass.class.getField("bClass").getGenericType(); [EOL]         final Type cClassType = AClass.class.getField("cClass").getGenericType(); [EOL]         final Type dClassType = AClass.class.getField("dClass").getGenericType(); [EOL]         final Type eClassType = AClass.class.getField("eClass").getGenericType(); [EOL]         final Type fClassType = AClass.class.getField("fClass").getGenericType(); [EOL]         final AClass aClass = new AClass(new AAClass<String>()); [EOL]         aClass.bClass = aClass.cClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(cClassType, bClassType)); [EOL]         aClass.bClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, bClassType)); [EOL]         aClass.bClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, bClassType)); [EOL]         aClass.bClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, bClassType)); [EOL]         aClass.cClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, cClassType)); [EOL]         aClass.cClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, cClassType)); [EOL]         aClass.cClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, cClassType)); [EOL]         aClass.dClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, dClassType)); [EOL]         aClass.dClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, dClassType)); [EOL]         aClass.eClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, eClassType)); [EOL]     } [EOL]  [EOL]     public void delegateBooleanAssertion(final Type[] types, final int i2, final int i1, final boolean expected) { [EOL]         final Type type1 = types[i1]; [EOL]         final Type type2 = types[i2]; [EOL]         final boolean isAssignable = TypeUtils.isAssignable(type2, type1); [EOL]  [EOL]         if (expected) { [EOL]             Assert.assertTrue("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } else { [EOL]             Assert.assertFalse("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } [EOL]     } [EOL]  [EOL]     @SuppressWarnings("boxing") // boxing is deliberate here [EOL]
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [EOL]         final Type[] types = method.getGenericParameterTypes(); [EOL] //        list0 = list0; [EOL]         delegateBooleanAssertion(types, 0, 0, true); [EOL]         list1 = list0; [EOL]         delegateBooleanAssertion(types, 0, 1, true); [EOL]         list0 = list1; [EOL]         delegateBooleanAssertion(types, 1, 0, true); [EOL]         list2 = list0; [EOL]         delegateBooleanAssertion(types, 0, 2, true); [EOL]         list0 = list2; [EOL]         delegateBooleanAssertion(types, 2, 0, true); [EOL]         list3 = list0; [EOL]         delegateBooleanAssertion(types, 0, 3, true); [EOL]         list0 = list3; [EOL]         delegateBooleanAssertion(types, 3, 0, true); [EOL]         list4 = list0; [EOL]         delegateBooleanAssertion(types, 0, 4, true); [EOL]         list0 = list4; [EOL]         delegateBooleanAssertion(types, 4, 0, true); [EOL]         list5 = list0; [EOL]         delegateBooleanAssertion(types, 0, 5, true); [EOL]         list0 = list5; [EOL]         delegateBooleanAssertion(types, 5, 0, true); [EOL]         list6 = list0; [EOL]         delegateBooleanAssertion(types, 0, 6, true); [EOL]         list0 = list6; [EOL]         delegateBooleanAssertion(types, 6, 0, true); [EOL] //        list1 = list1; [EOL]         delegateBooleanAssertion(types, 1, 1, true); [EOL]         list2 = list1; [EOL]         delegateBooleanAssertion(types, 1, 2, true); [EOL]         list1 = (List<Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 1, false); [EOL]         list3 = list1; [EOL]         delegateBooleanAssertion(types, 1, 3, true); [EOL]         list1 = (List<Object>) list3; [EOL]         delegateBooleanAssertion(types, 3, 1, false); [EOL]         // list4 = list1; [EOL]         delegateBooleanAssertion(types, 1, 4, false); [EOL]         // list1 = list4; [EOL]         delegateBooleanAssertion(types, 4, 1, false); [EOL]         // list5 = list1; [EOL]         delegateBooleanAssertion(types, 1, 5, false); [EOL]         // list1 = list5; [EOL]         delegateBooleanAssertion(types, 5, 1, false); [EOL]         list6 = list1; [EOL]         delegateBooleanAssertion(types, 1, 6, true); [EOL]         list1 = (List<Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 1, false); [EOL] //        list2 = list2; [EOL]         delegateBooleanAssertion(types, 2, 2, true); [EOL]         list2 = list3; [EOL]         delegateBooleanAssertion(types, 2, 3, false); [EOL]         list2 = list4; [EOL]         delegateBooleanAssertion(types, 3, 2, true); [EOL]         list3 = (List<? super Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 4, false); [EOL]         list2 = list5; [EOL]         delegateBooleanAssertion(types, 4, 2, true); [EOL]         list4 = (List<String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 5, false); [EOL]         list2 = list6; [EOL]         delegateBooleanAssertion(types, 5, 2, true); [EOL]         list5 = (List<? extends String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 6, false); [EOL] //        list3 = list3; [EOL]         delegateBooleanAssertion(types, 6, 2, true); [EOL]         list6 = (List<? super String>) list2; [EOL]         delegateBooleanAssertion(types, 3, 3, true); [EOL]         // list4 = list3; [EOL]         delegateBooleanAssertion(types, 3, 4, false); [EOL]         // list3 = list4; [EOL]         delegateBooleanAssertion(types, 4, 3, false); [EOL]         // list5 = list3; [EOL]         delegateBooleanAssertion(types, 3, 5, false); [EOL]         // list3 = list5; [EOL]         delegateBooleanAssertion(types, 5, 3, false); [EOL]         list6 = list3; [EOL]         delegateBooleanAssertion(types, 3, 6, true); [EOL]         list3 = (List<? super Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 3, false); [EOL] //        list4 = list4; [EOL]         delegateBooleanAssertion(types, 4, 4, true); [EOL]         list5 = list4; [EOL]         delegateBooleanAssertion(types, 4, 5, true); [EOL]         list4 = (List<String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 4, false); [EOL]         list6 = list4; [EOL]         delegateBooleanAssertion(types, 4, 6, true); [EOL]         list4 = (List<String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 4, false); [EOL] //        list5 = list5; [EOL]         delegateBooleanAssertion(types, 5, 5, true); [EOL]         list6 = (List<? super String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 6, false); [EOL]         list5 = (List<? extends String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 5, false); [EOL] //        list6 = list6; [EOL]         delegateBooleanAssertion(types, 6, 6, true); [EOL]  [EOL] //        list7 = list7; [EOL]         delegateBooleanAssertion(types, 7, 7, true); [EOL]         list8 = list7; [EOL]         delegateBooleanAssertion(types, 7, 8, true); [EOL]         list7 = list8; [EOL]         delegateBooleanAssertion(types, 8, 7, true); [EOL]         list9 = list7; [EOL]         delegateBooleanAssertion(types, 7, 9, true); [EOL]         list7 = list9; [EOL]         delegateBooleanAssertion(types, 9, 7, true); [EOL]         list10 = list7; [EOL]         delegateBooleanAssertion(types, 7, 10, true); [EOL]         list7 = list10; [EOL]         delegateBooleanAssertion(types, 10, 7, true); [EOL]         list11 = list7; [EOL]         delegateBooleanAssertion(types, 7, 11, true); [EOL]         list7 = list11; [EOL]         delegateBooleanAssertion(types, 11, 7, true); [EOL]         list12 = list7; [EOL]         delegateBooleanAssertion(types, 7, 12, true); [EOL]         list7 = list12; [EOL]         delegateBooleanAssertion(types, 12, 7, true); [EOL]         list13 = list7; [EOL]         delegateBooleanAssertion(types, 7, 13, true); [EOL]         list7 = list13; [EOL]         delegateBooleanAssertion(types, 13, 7, true); [EOL] //        list8 = list8; [EOL]         delegateBooleanAssertion(types, 8, 8, true); [EOL]         list9 = list8; [EOL]         delegateBooleanAssertion(types, 8, 9, true); [EOL]         list8 = (List<Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 8, false); [EOL]         list10 = list8; [EOL]         delegateBooleanAssertion(types, 8, 10, true); [EOL]         list8 = (List<Object>[]) list10; // NOTE cast is required by Sun Java, but not by Eclipse [EOL]         delegateBooleanAssertion(types, 10, 8, false); [EOL]         // list11 = list8; [EOL]         delegateBooleanAssertion(types, 8, 11, false); [EOL]         // list8 = list11; [EOL]         delegateBooleanAssertion(types, 11, 8, false); [EOL]         // list12 = list8; [EOL]         delegateBooleanAssertion(types, 8, 12, false); [EOL]         // list8 = list12; [EOL]         delegateBooleanAssertion(types, 12, 8, false); [EOL]         list13 = list8; [EOL]         delegateBooleanAssertion(types, 8, 13, true); [EOL]         list8 = (List<Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 8, false); [EOL] //        list9 = list9; [EOL]         delegateBooleanAssertion(types, 9, 9, true); [EOL]         list10 = (List<? super Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 10, false); [EOL]         list9 = list10; [EOL]         delegateBooleanAssertion(types, 10, 9, true); [EOL]         list11 = (List<String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 11, false); [EOL]         list9 = list11; [EOL]         delegateBooleanAssertion(types, 11, 9, true); [EOL]         list12 = (List<? extends String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 12, false); [EOL]         list9 = list12; [EOL]         delegateBooleanAssertion(types, 12, 9, true); [EOL]         list13 = (List<? super String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 13, false); [EOL]         list9 = list13; [EOL]         delegateBooleanAssertion(types, 13, 9, true); [EOL] //        list10 = list10; [EOL]         delegateBooleanAssertion(types, 10, 10, true); [EOL]         // list11 = list10; [EOL]         delegateBooleanAssertion(types, 10, 11, false); [EOL]         // list10 = list11; [EOL]         delegateBooleanAssertion(types, 11, 10, false); [EOL]         // list12 = list10; [EOL]         delegateBooleanAssertion(types, 10, 12, false); [EOL]         // list10 = list12; [EOL]         delegateBooleanAssertion(types, 12, 10, false); [EOL]         list13 = list10; [EOL]         delegateBooleanAssertion(types, 10, 13, true); [EOL]         list10 = (List<? super Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 10, false); [EOL] //        list11 = list11; [EOL]         delegateBooleanAssertion(types, 11, 11, true); [EOL]         list12 = list11; [EOL]         delegateBooleanAssertion(types, 11, 12, true); [EOL]         list11 = (List<String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 11, false); [EOL]         list13 = list11; [EOL]         delegateBooleanAssertion(types, 11, 13, true); [EOL]         list11 = (List<String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 11, false); [EOL] //        list12 = list12; [EOL]         delegateBooleanAssertion(types, 12, 12, true); [EOL]         list13 = (List<? super String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 13, false); [EOL]         list12 = (List<? extends String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 12, false); [EOL] //        list13 = list13; [EOL]         delegateBooleanAssertion(types, 13, 13, true); [EOL]         final Type disType = getClass().getField("dis").getGenericType(); [EOL]         // Reporter.log( ( ( ParameterizedType ) disType [EOL]         // ).getOwnerType().getClass().toString() ); [EOL]         final Type datType = getClass().getField("dat").getGenericType(); [EOL]         final Type daType = getClass().getField("da").getGenericType(); [EOL]         final Type uhderType = getClass().getField("uhder").getGenericType(); [EOL]         final Type dingType = getClass().getField("ding").getGenericType(); [EOL]         final Type testerType = getClass().getField("tester").getGenericType(); [EOL]         final Type tester2Type = getClass().getField("tester2").getGenericType(); [EOL]         final Type dat2Type = getClass().getField("dat2").getGenericType(); [EOL]         final Type dat3Type = getClass().getField("dat3").getGenericType(); [EOL]         dis = dat; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(datType, disType)); [EOL]         // dis = da; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(daType, disType)); [EOL]         dis = uhder; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(uhderType, disType)); [EOL]         dis = ding; [EOL]         Assert.assertFalse(String.format("type %s not assignable to %s!", dingType, disType), [EOL]                 TypeUtils.isAssignable(dingType, disType)); [EOL]         dis = tester; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(testerType, disType)); [EOL]         // dis = tester2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(tester2Type, disType)); [EOL]         // dat = dat2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat2Type, datType)); [EOL]         // dat2 = dat; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(datType, dat2Type)); [EOL]         // dat = dat3; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat3Type, datType)); [EOL]         final char ch = 0; [EOL]         final boolean bo = false; [EOL]         final byte by = 0; [EOL]         final short sh = 0; [EOL]         int in = 0; [EOL]         long lo = 0; [EOL]         final float fl = 0; [EOL]         double du = 0; [EOL]         du = ch; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(char.class, double.class)); [EOL]         du = by; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(byte.class, double.class)); [EOL]         du = sh; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(short.class, double.class)); [EOL]         du = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, double.class)); [EOL]         du = lo; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(long.class, double.class)); [EOL]         du = fl; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(float.class, double.class)); [EOL]         lo = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, long.class)); [EOL]         lo = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, long.class)); [EOL]         // Long lngW = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, Long.class)); [EOL]         // lngW = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, Long.class)); [EOL]         in = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, int.class)); [EOL]         final Integer inte = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Integer.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Number.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Object.class)); [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, intComparableType)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Comparable.class)); [EOL]         final Serializable ser = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Serializable.class)); [EOL]         final Type longComparableType = getClass().getField("longComparable").getGenericType(); [EOL]         // longComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, longComparableType)); [EOL]         // longComparable = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, longComparableType)); [EOL]         // int[] ia; [EOL]         // long[] la = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, long[].class)); [EOL]         final Integer[] ia = null; [EOL]         final Type caType = getClass().getField("intWildcardComparable").getGenericType(); [EOL]         intWildcardComparable = ia; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, caType)); [EOL]         // int[] ina = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer[].class, int[].class)); [EOL]         final int[] ina = null; [EOL]         Object[] oa; [EOL]         // oa = ina; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, Object[].class)); [EOL]         oa = new Integer[0]; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, Object[].class)); [EOL]         final Type bClassType = AClass.class.getField("bClass").getGenericType(); [EOL]         final Type cClassType = AClass.class.getField("cClass").getGenericType(); [EOL]         final Type dClassType = AClass.class.getField("dClass").getGenericType(); [EOL]         final Type eClassType = AClass.class.getField("eClass").getGenericType(); [EOL]         final Type fClassType = AClass.class.getField("fClass").getGenericType(); [EOL]         final AClass aClass = new AClass(new AAClass<String>()); [EOL]         aClass.bClass = aClass.cClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(cClassType, bClassType)); [EOL]         aClass.bClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, bClassType)); [EOL]         aClass.bClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, bClassType)); [EOL]         aClass.bClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, bClassType)); [EOL]         aClass.cClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, cClassType)); [EOL]         aClass.cClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, cClassType)); [EOL]         aClass.cClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, cClassType)); [EOL]         aClass.dClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, dClassType)); [EOL]         aClass.dClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, dClassType)); [EOL]         aClass.eClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, eClassType)); [EOL]     } [EOL]  [EOL]     public void delegateBooleanAssertion(final Type[] types, final int i2, final int i1, final boolean expected) { [EOL]         final Type type1 = types[i1]; [EOL]         final Type type2 = types[i2]; [EOL]         final boolean isAssignable = TypeUtils.isAssignable(type2, type1); [EOL]  [EOL]         if (expected) { [EOL]             Assert.assertTrue("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } else { [EOL]             Assert.assertFalse("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } [EOL]     } [EOL]  [EOL]     @SuppressWarnings("boxing") // boxing is deliberate here [EOL]
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [EOL]         final Type[] types = method.getGenericParameterTypes(); [EOL] //        list0 = list0; [EOL]         delegateBooleanAssertion(types, 0, 0, true); [EOL]         list1 = list0; [EOL]         delegateBooleanAssertion(types, 0, 1, true); [EOL]         list0 = list1; [EOL]         delegateBooleanAssertion(types, 1, 0, true); [EOL]         list2 = list0; [EOL]         delegateBooleanAssertion(types, 0, 2, true); [EOL]         list0 = list2; [EOL]         delegateBooleanAssertion(types, 2, 0, true); [EOL]         list3 = list0; [EOL]         delegateBooleanAssertion(types, 0, 3, true); [EOL]         list0 = list3; [EOL]         delegateBooleanAssertion(types, 3, 0, true); [EOL]         list4 = list0; [EOL]         delegateBooleanAssertion(types, 0, 4, true); [EOL]         list0 = list4; [EOL]         delegateBooleanAssertion(types, 4, 0, true); [EOL]         list5 = list0; [EOL]         delegateBooleanAssertion(types, 0, 5, true); [EOL]         list0 = list5; [EOL]         delegateBooleanAssertion(types, 5, 0, true); [EOL]         list6 = list0; [EOL]         delegateBooleanAssertion(types, 0, 6, true); [EOL]         list0 = list6; [EOL]         delegateBooleanAssertion(types, 6, 0, true); [EOL] //        list1 = list1; [EOL]         delegateBooleanAssertion(types, 1, 1, true); [EOL]         list2 = list1; [EOL]         delegateBooleanAssertion(types, 1, 2, true); [EOL]         list1 = (List<Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 1, false); [EOL]         list3 = list1; [EOL]         delegateBooleanAssertion(types, 1, 3, true); [EOL]         list1 = (List<Object>) list3; [EOL]         delegateBooleanAssertion(types, 3, 1, false); [EOL]         // list4 = list1; [EOL]         delegateBooleanAssertion(types, 1, 4, false); [EOL]         // list1 = list4; [EOL]         delegateBooleanAssertion(types, 4, 1, false); [EOL]         // list5 = list1; [EOL]         delegateBooleanAssertion(types, 1, 5, false); [EOL]         // list1 = list5; [EOL]         delegateBooleanAssertion(types, 5, 1, false); [EOL]         list6 = list1; [EOL]         delegateBooleanAssertion(types, 1, 6, true); [EOL]         list1 = (List<Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 1, false); [EOL] //        list2 = list2; [EOL]         delegateBooleanAssertion(types, 2, 2, true); [EOL]         list2 = list3; [EOL]         delegateBooleanAssertion(types, 2, 3, false); [EOL]         list2 = list4; [EOL]         delegateBooleanAssertion(types, 3, 2, true); [EOL]         list3 = (List<? super Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 4, false); [EOL]         list2 = list5; [EOL]         delegateBooleanAssertion(types, 4, 2, true); [EOL]         list4 = (List<String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 5, false); [EOL]         list2 = list6; [EOL]         delegateBooleanAssertion(types, 5, 2, true); [EOL]         list5 = (List<? extends String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 6, false); [EOL] //        list3 = list3; [EOL]         delegateBooleanAssertion(types, 6, 2, true); [EOL]         list6 = (List<? super String>) list2; [EOL]         delegateBooleanAssertion(types, 3, 3, true); [EOL]         // list4 = list3; [EOL]         delegateBooleanAssertion(types, 3, 4, false); [EOL]         // list3 = list4; [EOL]         delegateBooleanAssertion(types, 4, 3, false); [EOL]         // list5 = list3; [EOL]         delegateBooleanAssertion(types, 3, 5, false); [EOL]         // list3 = list5; [EOL]         delegateBooleanAssertion(types, 5, 3, false); [EOL]         list6 = list3; [EOL]         delegateBooleanAssertion(types, 3, 6, true); [EOL]         list3 = (List<? super Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 3, false); [EOL] //        list4 = list4; [EOL]         delegateBooleanAssertion(types, 4, 4, true); [EOL]         list5 = list4; [EOL]         delegateBooleanAssertion(types, 4, 5, true); [EOL]         list4 = (List<String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 4, false); [EOL]         list6 = list4; [EOL]         delegateBooleanAssertion(types, 4, 6, true); [EOL]         list4 = (List<String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 4, false); [EOL] //        list5 = list5; [EOL]         delegateBooleanAssertion(types, 5, 5, true); [EOL]         list6 = (List<? super String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 6, false); [EOL]         list5 = (List<? extends String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 5, false); [EOL] //        list6 = list6; [EOL]         delegateBooleanAssertion(types, 6, 6, true); [EOL]  [EOL] //        list7 = list7; [EOL]         delegateBooleanAssertion(types, 7, 7, true); [EOL]         list8 = list7; [EOL]         delegateBooleanAssertion(types, 7, 8, true); [EOL]         list7 = list8; [EOL]         delegateBooleanAssertion(types, 8, 7, true); [EOL]         list9 = list7; [EOL]         delegateBooleanAssertion(types, 7, 9, true); [EOL]         list7 = list9; [EOL]         delegateBooleanAssertion(types, 9, 7, true); [EOL]         list10 = list7; [EOL]         delegateBooleanAssertion(types, 7, 10, true); [EOL]         list7 = list10; [EOL]         delegateBooleanAssertion(types, 10, 7, true); [EOL]         list11 = list7; [EOL]         delegateBooleanAssertion(types, 7, 11, true); [EOL]         list7 = list11; [EOL]         delegateBooleanAssertion(types, 11, 7, true); [EOL]         list12 = list7; [EOL]         delegateBooleanAssertion(types, 7, 12, true); [EOL]         list7 = list12; [EOL]         delegateBooleanAssertion(types, 12, 7, true); [EOL]         list13 = list7; [EOL]         delegateBooleanAssertion(types, 7, 13, true); [EOL]         list7 = list13; [EOL]         delegateBooleanAssertion(types, 13, 7, true); [EOL] //        list8 = list8; [EOL]         delegateBooleanAssertion(types, 8, 8, true); [EOL]         list9 = list8; [EOL]         delegateBooleanAssertion(types, 8, 9, true); [EOL]         list8 = (List<Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 8, false); [EOL]         list10 = list8; [EOL]         delegateBooleanAssertion(types, 8, 10, true); [EOL]         list8 = (List<Object>[]) list10; // NOTE cast is required by Sun Java, but not by Eclipse [EOL]         delegateBooleanAssertion(types, 10, 8, false); [EOL]         // list11 = list8; [EOL]         delegateBooleanAssertion(types, 8, 11, false); [EOL]         // list8 = list11; [EOL]         delegateBooleanAssertion(types, 11, 8, false); [EOL]         // list12 = list8; [EOL]         delegateBooleanAssertion(types, 8, 12, false); [EOL]         // list8 = list12; [EOL]         delegateBooleanAssertion(types, 12, 8, false); [EOL]         list13 = list8; [EOL]         delegateBooleanAssertion(types, 8, 13, true); [EOL]         list8 = (List<Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 8, false); [EOL] //        list9 = list9; [EOL]         delegateBooleanAssertion(types, 9, 9, true); [EOL]         list10 = (List<? super Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 10, false); [EOL]         list9 = list10; [EOL]         delegateBooleanAssertion(types, 10, 9, true); [EOL]         list11 = (List<String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 11, false); [EOL]         list9 = list11; [EOL]         delegateBooleanAssertion(types, 11, 9, true); [EOL]         list12 = (List<? extends String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 12, false); [EOL]         list9 = list12; [EOL]         delegateBooleanAssertion(types, 12, 9, true); [EOL]         list13 = (List<? super String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 13, false); [EOL]         list9 = list13; [EOL]         delegateBooleanAssertion(types, 13, 9, true); [EOL] //        list10 = list10; [EOL]         delegateBooleanAssertion(types, 10, 10, true); [EOL]         // list11 = list10; [EOL]         delegateBooleanAssertion(types, 10, 11, false); [EOL]         // list10 = list11; [EOL]         delegateBooleanAssertion(types, 11, 10, false); [EOL]         // list12 = list10; [EOL]         delegateBooleanAssertion(types, 10, 12, false); [EOL]         // list10 = list12; [EOL]         delegateBooleanAssertion(types, 12, 10, false); [EOL]         list13 = list10; [EOL]         delegateBooleanAssertion(types, 10, 13, true); [EOL]         list10 = (List<? super Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 10, false); [EOL] //        list11 = list11; [EOL]         delegateBooleanAssertion(types, 11, 11, true); [EOL]         list12 = list11; [EOL]         delegateBooleanAssertion(types, 11, 12, true); [EOL]         list11 = (List<String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 11, false); [EOL]         list13 = list11; [EOL]         delegateBooleanAssertion(types, 11, 13, true); [EOL]         list11 = (List<String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 11, false); [EOL] //        list12 = list12; [EOL]         delegateBooleanAssertion(types, 12, 12, true); [EOL]         list13 = (List<? super String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 13, false); [EOL]         list12 = (List<? extends String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 12, false); [EOL] //        list13 = list13; [EOL]         delegateBooleanAssertion(types, 13, 13, true); [EOL]         final Type disType = getClass().getField("dis").getGenericType(); [EOL]         // Reporter.log( ( ( ParameterizedType ) disType [EOL]         // ).getOwnerType().getClass().toString() ); [EOL]         final Type datType = getClass().getField("dat").getGenericType(); [EOL]         final Type daType = getClass().getField("da").getGenericType(); [EOL]         final Type uhderType = getClass().getField("uhder").getGenericType(); [EOL]         final Type dingType = getClass().getField("ding").getGenericType(); [EOL]         final Type testerType = getClass().getField("tester").getGenericType(); [EOL]         final Type tester2Type = getClass().getField("tester2").getGenericType(); [EOL]         final Type dat2Type = getClass().getField("dat2").getGenericType(); [EOL]         final Type dat3Type = getClass().getField("dat3").getGenericType(); [EOL]         dis = dat; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(datType, disType)); [EOL]         // dis = da; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(daType, disType)); [EOL]         dis = uhder; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(uhderType, disType)); [EOL]         dis = ding; [EOL]         Assert.assertFalse(String.format("type %s not assignable to %s!", dingType, disType), [EOL]                 TypeUtils.isAssignable(dingType, disType)); [EOL]         dis = tester; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(testerType, disType)); [EOL]         // dis = tester2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(tester2Type, disType)); [EOL]         // dat = dat2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat2Type, datType)); [EOL]         // dat2 = dat; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(datType, dat2Type)); [EOL]         // dat = dat3; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat3Type, datType)); [EOL]         final char ch = 0; [EOL]         final boolean bo = false; [EOL]         final byte by = 0; [EOL]         final short sh = 0; [EOL]         int in = 0; [EOL]         long lo = 0; [EOL]         final float fl = 0; [EOL]         double du = 0; [EOL]         du = ch; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(char.class, double.class)); [EOL]         du = by; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(byte.class, double.class)); [EOL]         du = sh; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(short.class, double.class)); [EOL]         du = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, double.class)); [EOL]         du = lo; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(long.class, double.class)); [EOL]         du = fl; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(float.class, double.class)); [EOL]         lo = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, long.class)); [EOL]         lo = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, long.class)); [EOL]         // Long lngW = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, Long.class)); [EOL]         // lngW = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, Long.class)); [EOL]         in = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, int.class)); [EOL]         final Integer inte = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Integer.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Number.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Object.class)); [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, intComparableType)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Comparable.class)); [EOL]         final Serializable ser = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Serializable.class)); [EOL]         final Type longComparableType = getClass().getField("longComparable").getGenericType(); [EOL]         // longComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, longComparableType)); [EOL]         // longComparable = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, longComparableType)); [EOL]         // int[] ia; [EOL]         // long[] la = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, long[].class)); [EOL]         final Integer[] ia = null; [EOL]         final Type caType = getClass().getField("intWildcardComparable").getGenericType(); [EOL]         intWildcardComparable = ia; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, caType)); [EOL]         // int[] ina = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer[].class, int[].class)); [EOL]         final int[] ina = null; [EOL]         Object[] oa; [EOL]         // oa = ina; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, Object[].class)); [EOL]         oa = new Integer[0]; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, Object[].class)); [EOL]         final Type bClassType = AClass.class.getField("bClass").getGenericType(); [EOL]         final Type cClassType = AClass.class.getField("cClass").getGenericType(); [EOL]         final Type dClassType = AClass.class.getField("dClass").getGenericType(); [EOL]         final Type eClassType = AClass.class.getField("eClass").getGenericType(); [EOL]         final Type fClassType = AClass.class.getField("fClass").getGenericType(); [EOL]         final AClass aClass = new AClass(new AAClass<String>()); [EOL]         aClass.bClass = aClass.cClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(cClassType, bClassType)); [EOL]         aClass.bClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, bClassType)); [EOL]         aClass.bClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, bClassType)); [EOL]         aClass.bClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, bClassType)); [EOL]         aClass.cClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, cClassType)); [EOL]         aClass.cClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, cClassType)); [EOL]         aClass.cClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, cClassType)); [EOL]         aClass.dClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, dClassType)); [EOL]         aClass.dClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, dClassType)); [EOL]         aClass.eClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, eClassType)); [EOL]     } [EOL]  [EOL]     public void delegateBooleanAssertion(final Type[] types, final int i2, final int i1, final boolean expected) { [EOL]         final Type type1 = types[i1]; [EOL]         final Type type2 = types[i2]; [EOL]         final boolean isAssignable = TypeUtils.isAssignable(type2, type1); [EOL]  [EOL]         if (expected) { [EOL]             Assert.assertTrue("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } else { [EOL]             Assert.assertFalse("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } [EOL]     } [EOL]  [EOL]     @SuppressWarnings("boxing") // boxing is deliberate here [EOL]
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [EOL]         final Type[] types = method.getGenericParameterTypes(); [EOL] //        list0 = list0; [EOL]         delegateBooleanAssertion(types, 0, 0, true); [EOL]         list1 = list0; [EOL]         delegateBooleanAssertion(types, 0, 1, true); [EOL]         list0 = list1; [EOL]         delegateBooleanAssertion(types, 1, 0, true); [EOL]         list2 = list0; [EOL]         delegateBooleanAssertion(types, 0, 2, true); [EOL]         list0 = list2; [EOL]         delegateBooleanAssertion(types, 2, 0, true); [EOL]         list3 = list0; [EOL]         delegateBooleanAssertion(types, 0, 3, true); [EOL]         list0 = list3; [EOL]         delegateBooleanAssertion(types, 3, 0, true); [EOL]         list4 = list0; [EOL]         delegateBooleanAssertion(types, 0, 4, true); [EOL]         list0 = list4; [EOL]         delegateBooleanAssertion(types, 4, 0, true); [EOL]         list5 = list0; [EOL]         delegateBooleanAssertion(types, 0, 5, true); [EOL]         list0 = list5; [EOL]         delegateBooleanAssertion(types, 5, 0, true); [EOL]         list6 = list0; [EOL]         delegateBooleanAssertion(types, 0, 6, true); [EOL]         list0 = list6; [EOL]         delegateBooleanAssertion(types, 6, 0, true); [EOL] //        list1 = list1; [EOL]         delegateBooleanAssertion(types, 1, 1, true); [EOL]         list2 = list1; [EOL]         delegateBooleanAssertion(types, 1, 2, true); [EOL]         list1 = (List<Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 1, false); [EOL]         list3 = list1; [EOL]         delegateBooleanAssertion(types, 1, 3, true); [EOL]         list1 = (List<Object>) list3; [EOL]         delegateBooleanAssertion(types, 3, 1, false); [EOL]         // list4 = list1; [EOL]         delegateBooleanAssertion(types, 1, 4, false); [EOL]         // list1 = list4; [EOL]         delegateBooleanAssertion(types, 4, 1, false); [EOL]         // list5 = list1; [EOL]         delegateBooleanAssertion(types, 1, 5, false); [EOL]         // list1 = list5; [EOL]         delegateBooleanAssertion(types, 5, 1, false); [EOL]         list6 = list1; [EOL]         delegateBooleanAssertion(types, 1, 6, true); [EOL]         list1 = (List<Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 1, false); [EOL] //        list2 = list2; [EOL]         delegateBooleanAssertion(types, 2, 2, true); [EOL]         list2 = list3; [EOL]         delegateBooleanAssertion(types, 2, 3, false); [EOL]         list2 = list4; [EOL]         delegateBooleanAssertion(types, 3, 2, true); [EOL]         list3 = (List<? super Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 4, false); [EOL]         list2 = list5; [EOL]         delegateBooleanAssertion(types, 4, 2, true); [EOL]         list4 = (List<String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 5, false); [EOL]         list2 = list6; [EOL]         delegateBooleanAssertion(types, 5, 2, true); [EOL]         list5 = (List<? extends String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 6, false); [EOL] //        list3 = list3; [EOL]         delegateBooleanAssertion(types, 6, 2, true); [EOL]         list6 = (List<? super String>) list2; [EOL]         delegateBooleanAssertion(types, 3, 3, true); [EOL]         // list4 = list3; [EOL]         delegateBooleanAssertion(types, 3, 4, false); [EOL]         // list3 = list4; [EOL]         delegateBooleanAssertion(types, 4, 3, false); [EOL]         // list5 = list3; [EOL]         delegateBooleanAssertion(types, 3, 5, false); [EOL]         // list3 = list5; [EOL]         delegateBooleanAssertion(types, 5, 3, false); [EOL]         list6 = list3; [EOL]         delegateBooleanAssertion(types, 3, 6, true); [EOL]         list3 = (List<? super Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 3, false); [EOL] //        list4 = list4; [EOL]         delegateBooleanAssertion(types, 4, 4, true); [EOL]         list5 = list4; [EOL]         delegateBooleanAssertion(types, 4, 5, true); [EOL]         list4 = (List<String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 4, false); [EOL]         list6 = list4; [EOL]         delegateBooleanAssertion(types, 4, 6, true); [EOL]         list4 = (List<String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 4, false); [EOL] //        list5 = list5; [EOL]         delegateBooleanAssertion(types, 5, 5, true); [EOL]         list6 = (List<? super String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 6, false); [EOL]         list5 = (List<? extends String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 5, false); [EOL] //        list6 = list6; [EOL]         delegateBooleanAssertion(types, 6, 6, true); [EOL]  [EOL] //        list7 = list7; [EOL]         delegateBooleanAssertion(types, 7, 7, true); [EOL]         list8 = list7; [EOL]         delegateBooleanAssertion(types, 7, 8, true); [EOL]         list7 = list8; [EOL]         delegateBooleanAssertion(types, 8, 7, true); [EOL]         list9 = list7; [EOL]         delegateBooleanAssertion(types, 7, 9, true); [EOL]         list7 = list9; [EOL]         delegateBooleanAssertion(types, 9, 7, true); [EOL]         list10 = list7; [EOL]         delegateBooleanAssertion(types, 7, 10, true); [EOL]         list7 = list10; [EOL]         delegateBooleanAssertion(types, 10, 7, true); [EOL]         list11 = list7; [EOL]         delegateBooleanAssertion(types, 7, 11, true); [EOL]         list7 = list11; [EOL]         delegateBooleanAssertion(types, 11, 7, true); [EOL]         list12 = list7; [EOL]         delegateBooleanAssertion(types, 7, 12, true); [EOL]         list7 = list12; [EOL]         delegateBooleanAssertion(types, 12, 7, true); [EOL]         list13 = list7; [EOL]         delegateBooleanAssertion(types, 7, 13, true); [EOL]         list7 = list13; [EOL]         delegateBooleanAssertion(types, 13, 7, true); [EOL] //        list8 = list8; [EOL]         delegateBooleanAssertion(types, 8, 8, true); [EOL]         list9 = list8; [EOL]         delegateBooleanAssertion(types, 8, 9, true); [EOL]         list8 = (List<Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 8, false); [EOL]         list10 = list8; [EOL]         delegateBooleanAssertion(types, 8, 10, true); [EOL]         list8 = (List<Object>[]) list10; // NOTE cast is required by Sun Java, but not by Eclipse [EOL]         delegateBooleanAssertion(types, 10, 8, false); [EOL]         // list11 = list8; [EOL]         delegateBooleanAssertion(types, 8, 11, false); [EOL]         // list8 = list11; [EOL]         delegateBooleanAssertion(types, 11, 8, false); [EOL]         // list12 = list8; [EOL]         delegateBooleanAssertion(types, 8, 12, false); [EOL]         // list8 = list12; [EOL]         delegateBooleanAssertion(types, 12, 8, false); [EOL]         list13 = list8; [EOL]         delegateBooleanAssertion(types, 8, 13, true); [EOL]         list8 = (List<Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 8, false); [EOL] //        list9 = list9; [EOL]         delegateBooleanAssertion(types, 9, 9, true); [EOL]         list10 = (List<? super Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 10, false); [EOL]         list9 = list10; [EOL]         delegateBooleanAssertion(types, 10, 9, true); [EOL]         list11 = (List<String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 11, false); [EOL]         list9 = list11; [EOL]         delegateBooleanAssertion(types, 11, 9, true); [EOL]         list12 = (List<? extends String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 12, false); [EOL]         list9 = list12; [EOL]         delegateBooleanAssertion(types, 12, 9, true); [EOL]         list13 = (List<? super String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 13, false); [EOL]         list9 = list13; [EOL]         delegateBooleanAssertion(types, 13, 9, true); [EOL] //        list10 = list10; [EOL]         delegateBooleanAssertion(types, 10, 10, true); [EOL]         // list11 = list10; [EOL]         delegateBooleanAssertion(types, 10, 11, false); [EOL]         // list10 = list11; [EOL]         delegateBooleanAssertion(types, 11, 10, false); [EOL]         // list12 = list10; [EOL]         delegateBooleanAssertion(types, 10, 12, false); [EOL]         // list10 = list12; [EOL]         delegateBooleanAssertion(types, 12, 10, false); [EOL]         list13 = list10; [EOL]         delegateBooleanAssertion(types, 10, 13, true); [EOL]         list10 = (List<? super Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 10, false); [EOL] //        list11 = list11; [EOL]         delegateBooleanAssertion(types, 11, 11, true); [EOL]         list12 = list11; [EOL]         delegateBooleanAssertion(types, 11, 12, true); [EOL]         list11 = (List<String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 11, false); [EOL]         list13 = list11; [EOL]         delegateBooleanAssertion(types, 11, 13, true); [EOL]         list11 = (List<String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 11, false); [EOL] //        list12 = list12; [EOL]         delegateBooleanAssertion(types, 12, 12, true); [EOL]         list13 = (List<? super String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 13, false); [EOL]         list12 = (List<? extends String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 12, false); [EOL] //        list13 = list13; [EOL]         delegateBooleanAssertion(types, 13, 13, true); [EOL]         final Type disType = getClass().getField("dis").getGenericType(); [EOL]         // Reporter.log( ( ( ParameterizedType ) disType [EOL]         // ).getOwnerType().getClass().toString() ); [EOL]         final Type datType = getClass().getField("dat").getGenericType(); [EOL]         final Type daType = getClass().getField("da").getGenericType(); [EOL]         final Type uhderType = getClass().getField("uhder").getGenericType(); [EOL]         final Type dingType = getClass().getField("ding").getGenericType(); [EOL]         final Type testerType = getClass().getField("tester").getGenericType(); [EOL]         final Type tester2Type = getClass().getField("tester2").getGenericType(); [EOL]         final Type dat2Type = getClass().getField("dat2").getGenericType(); [EOL]         final Type dat3Type = getClass().getField("dat3").getGenericType(); [EOL]         dis = dat; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(datType, disType)); [EOL]         // dis = da; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(daType, disType)); [EOL]         dis = uhder; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(uhderType, disType)); [EOL]         dis = ding; [EOL]         Assert.assertFalse(String.format("type %s not assignable to %s!", dingType, disType), [EOL]                 TypeUtils.isAssignable(dingType, disType)); [EOL]         dis = tester; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(testerType, disType)); [EOL]         // dis = tester2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(tester2Type, disType)); [EOL]         // dat = dat2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat2Type, datType)); [EOL]         // dat2 = dat; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(datType, dat2Type)); [EOL]         // dat = dat3; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat3Type, datType)); [EOL]         final char ch = 0; [EOL]         final boolean bo = false; [EOL]         final byte by = 0; [EOL]         final short sh = 0; [EOL]         int in = 0; [EOL]         long lo = 0; [EOL]         final float fl = 0; [EOL]         double du = 0; [EOL]         du = ch; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(char.class, double.class)); [EOL]         du = by; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(byte.class, double.class)); [EOL]         du = sh; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(short.class, double.class)); [EOL]         du = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, double.class)); [EOL]         du = lo; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(long.class, double.class)); [EOL]         du = fl; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(float.class, double.class)); [EOL]         lo = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, long.class)); [EOL]         lo = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, long.class)); [EOL]         // Long lngW = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, Long.class)); [EOL]         // lngW = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, Long.class)); [EOL]         in = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, int.class)); [EOL]         final Integer inte = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Integer.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Number.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Object.class)); [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, intComparableType)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Comparable.class)); [EOL]         final Serializable ser = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Serializable.class)); [EOL]         final Type longComparableType = getClass().getField("longComparable").getGenericType(); [EOL]         // longComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, longComparableType)); [EOL]         // longComparable = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, longComparableType)); [EOL]         // int[] ia; [EOL]         // long[] la = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, long[].class)); [EOL]         final Integer[] ia = null; [EOL]         final Type caType = getClass().getField("intWildcardComparable").getGenericType(); [EOL]         intWildcardComparable = ia; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, caType)); [EOL]         // int[] ina = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer[].class, int[].class)); [EOL]         final int[] ina = null; [EOL]         Object[] oa; [EOL]         // oa = ina; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, Object[].class)); [EOL]         oa = new Integer[0]; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, Object[].class)); [EOL]         final Type bClassType = AClass.class.getField("bClass").getGenericType(); [EOL]         final Type cClassType = AClass.class.getField("cClass").getGenericType(); [EOL]         final Type dClassType = AClass.class.getField("dClass").getGenericType(); [EOL]         final Type eClassType = AClass.class.getField("eClass").getGenericType(); [EOL]         final Type fClassType = AClass.class.getField("fClass").getGenericType(); [EOL]         final AClass aClass = new AClass(new AAClass<String>()); [EOL]         aClass.bClass = aClass.cClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(cClassType, bClassType)); [EOL]         aClass.bClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, bClassType)); [EOL]         aClass.bClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, bClassType)); [EOL]         aClass.bClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, bClassType)); [EOL]         aClass.cClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, cClassType)); [EOL]         aClass.cClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, cClassType)); [EOL]         aClass.cClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, cClassType)); [EOL]         aClass.dClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, dClassType)); [EOL]         aClass.dClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, dClassType)); [EOL]         aClass.eClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, eClassType)); [EOL]     } [EOL]  [EOL]     public void delegateBooleanAssertion(final Type[] types, final int i2, final int i1, final boolean expected) { [EOL]         final Type type1 = types[i1]; [EOL]         final Type type2 = types[i2]; [EOL]         final boolean isAssignable = TypeUtils.isAssignable(type2, type1); [EOL]  [EOL]         if (expected) { [EOL]             Assert.assertTrue("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } else { [EOL]             Assert.assertFalse("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } [EOL]     } [EOL]  [EOL]     @SuppressWarnings("boxing") // boxing is deliberate here [EOL]
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [EOL]         final Type[] types = method.getGenericParameterTypes(); [EOL] //        list0 = list0; [EOL]         delegateBooleanAssertion(types, 0, 0, true); [EOL]         list1 = list0; [EOL]         delegateBooleanAssertion(types, 0, 1, true); [EOL]         list0 = list1; [EOL]         delegateBooleanAssertion(types, 1, 0, true); [EOL]         list2 = list0; [EOL]         delegateBooleanAssertion(types, 0, 2, true); [EOL]         list0 = list2; [EOL]         delegateBooleanAssertion(types, 2, 0, true); [EOL]         list3 = list0; [EOL]         delegateBooleanAssertion(types, 0, 3, true); [EOL]         list0 = list3; [EOL]         delegateBooleanAssertion(types, 3, 0, true); [EOL]         list4 = list0; [EOL]         delegateBooleanAssertion(types, 0, 4, true); [EOL]         list0 = list4; [EOL]         delegateBooleanAssertion(types, 4, 0, true); [EOL]         list5 = list0; [EOL]         delegateBooleanAssertion(types, 0, 5, true); [EOL]         list0 = list5; [EOL]         delegateBooleanAssertion(types, 5, 0, true); [EOL]         list6 = list0; [EOL]         delegateBooleanAssertion(types, 0, 6, true); [EOL]         list0 = list6; [EOL]         delegateBooleanAssertion(types, 6, 0, true); [EOL] //        list1 = list1; [EOL]         delegateBooleanAssertion(types, 1, 1, true); [EOL]         list2 = list1; [EOL]         delegateBooleanAssertion(types, 1, 2, true); [EOL]         list1 = (List<Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 1, false); [EOL]         list3 = list1; [EOL]         delegateBooleanAssertion(types, 1, 3, true); [EOL]         list1 = (List<Object>) list3; [EOL]         delegateBooleanAssertion(types, 3, 1, false); [EOL]         // list4 = list1; [EOL]         delegateBooleanAssertion(types, 1, 4, false); [EOL]         // list1 = list4; [EOL]         delegateBooleanAssertion(types, 4, 1, false); [EOL]         // list5 = list1; [EOL]         delegateBooleanAssertion(types, 1, 5, false); [EOL]         // list1 = list5; [EOL]         delegateBooleanAssertion(types, 5, 1, false); [EOL]         list6 = list1; [EOL]         delegateBooleanAssertion(types, 1, 6, true); [EOL]         list1 = (List<Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 1, false); [EOL] //        list2 = list2; [EOL]         delegateBooleanAssertion(types, 2, 2, true); [EOL]         list2 = list3; [EOL]         delegateBooleanAssertion(types, 2, 3, false); [EOL]         list2 = list4; [EOL]         delegateBooleanAssertion(types, 3, 2, true); [EOL]         list3 = (List<? super Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 4, false); [EOL]         list2 = list5; [EOL]         delegateBooleanAssertion(types, 4, 2, true); [EOL]         list4 = (List<String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 5, false); [EOL]         list2 = list6; [EOL]         delegateBooleanAssertion(types, 5, 2, true); [EOL]         list5 = (List<? extends String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 6, false); [EOL] //        list3 = list3; [EOL]         delegateBooleanAssertion(types, 6, 2, true); [EOL]         list6 = (List<? super String>) list2; [EOL]         delegateBooleanAssertion(types, 3, 3, true); [EOL]         // list4 = list3; [EOL]         delegateBooleanAssertion(types, 3, 4, false); [EOL]         // list3 = list4; [EOL]         delegateBooleanAssertion(types, 4, 3, false); [EOL]         // list5 = list3; [EOL]         delegateBooleanAssertion(types, 3, 5, false); [EOL]         // list3 = list5; [EOL]         delegateBooleanAssertion(types, 5, 3, false); [EOL]         list6 = list3; [EOL]         delegateBooleanAssertion(types, 3, 6, true); [EOL]         list3 = (List<? super Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 3, false); [EOL] //        list4 = list4; [EOL]         delegateBooleanAssertion(types, 4, 4, true); [EOL]         list5 = list4; [EOL]         delegateBooleanAssertion(types, 4, 5, true); [EOL]         list4 = (List<String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 4, false); [EOL]         list6 = list4; [EOL]         delegateBooleanAssertion(types, 4, 6, true); [EOL]         list4 = (List<String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 4, false); [EOL] //        list5 = list5; [EOL]         delegateBooleanAssertion(types, 5, 5, true); [EOL]         list6 = (List<? super String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 6, false); [EOL]         list5 = (List<? extends String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 5, false); [EOL] //        list6 = list6; [EOL]         delegateBooleanAssertion(types, 6, 6, true); [EOL]  [EOL] //        list7 = list7; [EOL]         delegateBooleanAssertion(types, 7, 7, true); [EOL]         list8 = list7; [EOL]         delegateBooleanAssertion(types, 7, 8, true); [EOL]         list7 = list8; [EOL]         delegateBooleanAssertion(types, 8, 7, true); [EOL]         list9 = list7; [EOL]         delegateBooleanAssertion(types, 7, 9, true); [EOL]         list7 = list9; [EOL]         delegateBooleanAssertion(types, 9, 7, true); [EOL]         list10 = list7; [EOL]         delegateBooleanAssertion(types, 7, 10, true); [EOL]         list7 = list10; [EOL]         delegateBooleanAssertion(types, 10, 7, true); [EOL]         list11 = list7; [EOL]         delegateBooleanAssertion(types, 7, 11, true); [EOL]         list7 = list11; [EOL]         delegateBooleanAssertion(types, 11, 7, true); [EOL]         list12 = list7; [EOL]         delegateBooleanAssertion(types, 7, 12, true); [EOL]         list7 = list12; [EOL]         delegateBooleanAssertion(types, 12, 7, true); [EOL]         list13 = list7; [EOL]         delegateBooleanAssertion(types, 7, 13, true); [EOL]         list7 = list13; [EOL]         delegateBooleanAssertion(types, 13, 7, true); [EOL] //        list8 = list8; [EOL]         delegateBooleanAssertion(types, 8, 8, true); [EOL]         list9 = list8; [EOL]         delegateBooleanAssertion(types, 8, 9, true); [EOL]         list8 = (List<Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 8, false); [EOL]         list10 = list8; [EOL]         delegateBooleanAssertion(types, 8, 10, true); [EOL]         list8 = (List<Object>[]) list10; // NOTE cast is required by Sun Java, but not by Eclipse [EOL]         delegateBooleanAssertion(types, 10, 8, false); [EOL]         // list11 = list8; [EOL]         delegateBooleanAssertion(types, 8, 11, false); [EOL]         // list8 = list11; [EOL]         delegateBooleanAssertion(types, 11, 8, false); [EOL]         // list12 = list8; [EOL]         delegateBooleanAssertion(types, 8, 12, false); [EOL]         // list8 = list12; [EOL]         delegateBooleanAssertion(types, 12, 8, false); [EOL]         list13 = list8; [EOL]         delegateBooleanAssertion(types, 8, 13, true); [EOL]         list8 = (List<Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 8, false); [EOL] //        list9 = list9; [EOL]         delegateBooleanAssertion(types, 9, 9, true); [EOL]         list10 = (List<? super Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 10, false); [EOL]         list9 = list10; [EOL]         delegateBooleanAssertion(types, 10, 9, true); [EOL]         list11 = (List<String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 11, false); [EOL]         list9 = list11; [EOL]         delegateBooleanAssertion(types, 11, 9, true); [EOL]         list12 = (List<? extends String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 12, false); [EOL]         list9 = list12; [EOL]         delegateBooleanAssertion(types, 12, 9, true); [EOL]         list13 = (List<? super String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 13, false); [EOL]         list9 = list13; [EOL]         delegateBooleanAssertion(types, 13, 9, true); [EOL] //        list10 = list10; [EOL]         delegateBooleanAssertion(types, 10, 10, true); [EOL]         // list11 = list10; [EOL]         delegateBooleanAssertion(types, 10, 11, false); [EOL]         // list10 = list11; [EOL]         delegateBooleanAssertion(types, 11, 10, false); [EOL]         // list12 = list10; [EOL]         delegateBooleanAssertion(types, 10, 12, false); [EOL]         // list10 = list12; [EOL]         delegateBooleanAssertion(types, 12, 10, false); [EOL]         list13 = list10; [EOL]         delegateBooleanAssertion(types, 10, 13, true); [EOL]         list10 = (List<? super Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 10, false); [EOL] //        list11 = list11; [EOL]         delegateBooleanAssertion(types, 11, 11, true); [EOL]         list12 = list11; [EOL]         delegateBooleanAssertion(types, 11, 12, true); [EOL]         list11 = (List<String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 11, false); [EOL]         list13 = list11; [EOL]         delegateBooleanAssertion(types, 11, 13, true); [EOL]         list11 = (List<String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 11, false); [EOL] //        list12 = list12; [EOL]         delegateBooleanAssertion(types, 12, 12, true); [EOL]         list13 = (List<? super String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 13, false); [EOL]         list12 = (List<? extends String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 12, false); [EOL] //        list13 = list13; [EOL]         delegateBooleanAssertion(types, 13, 13, true); [EOL]         final Type disType = getClass().getField("dis").getGenericType(); [EOL]         // Reporter.log( ( ( ParameterizedType ) disType [EOL]         // ).getOwnerType().getClass().toString() ); [EOL]         final Type datType = getClass().getField("dat").getGenericType(); [EOL]         final Type daType = getClass().getField("da").getGenericType(); [EOL]         final Type uhderType = getClass().getField("uhder").getGenericType(); [EOL]         final Type dingType = getClass().getField("ding").getGenericType(); [EOL]         final Type testerType = getClass().getField("tester").getGenericType(); [EOL]         final Type tester2Type = getClass().getField("tester2").getGenericType(); [EOL]         final Type dat2Type = getClass().getField("dat2").getGenericType(); [EOL]         final Type dat3Type = getClass().getField("dat3").getGenericType(); [EOL]         dis = dat; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(datType, disType)); [EOL]         // dis = da; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(daType, disType)); [EOL]         dis = uhder; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(uhderType, disType)); [EOL]         dis = ding; [EOL]         Assert.assertFalse(String.format("type %s not assignable to %s!", dingType, disType), [EOL]                 TypeUtils.isAssignable(dingType, disType)); [EOL]         dis = tester; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(testerType, disType)); [EOL]         // dis = tester2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(tester2Type, disType)); [EOL]         // dat = dat2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat2Type, datType)); [EOL]         // dat2 = dat; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(datType, dat2Type)); [EOL]         // dat = dat3; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat3Type, datType)); [EOL]         final char ch = 0; [EOL]         final boolean bo = false; [EOL]         final byte by = 0; [EOL]         final short sh = 0; [EOL]         int in = 0; [EOL]         long lo = 0; [EOL]         final float fl = 0; [EOL]         double du = 0; [EOL]         du = ch; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(char.class, double.class)); [EOL]         du = by; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(byte.class, double.class)); [EOL]         du = sh; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(short.class, double.class)); [EOL]         du = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, double.class)); [EOL]         du = lo; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(long.class, double.class)); [EOL]         du = fl; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(float.class, double.class)); [EOL]         lo = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, long.class)); [EOL]         lo = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, long.class)); [EOL]         // Long lngW = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, Long.class)); [EOL]         // lngW = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, Long.class)); [EOL]         in = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, int.class)); [EOL]         final Integer inte = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Integer.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Number.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Object.class)); [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, intComparableType)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Comparable.class)); [EOL]         final Serializable ser = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Serializable.class)); [EOL]         final Type longComparableType = getClass().getField("longComparable").getGenericType(); [EOL]         // longComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, longComparableType)); [EOL]         // longComparable = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, longComparableType)); [EOL]         // int[] ia; [EOL]         // long[] la = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, long[].class)); [EOL]         final Integer[] ia = null; [EOL]         final Type caType = getClass().getField("intWildcardComparable").getGenericType(); [EOL]         intWildcardComparable = ia; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, caType)); [EOL]         // int[] ina = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer[].class, int[].class)); [EOL]         final int[] ina = null; [EOL]         Object[] oa; [EOL]         // oa = ina; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, Object[].class)); [EOL]         oa = new Integer[0]; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, Object[].class)); [EOL]         final Type bClassType = AClass.class.getField("bClass").getGenericType(); [EOL]         final Type cClassType = AClass.class.getField("cClass").getGenericType(); [EOL]         final Type dClassType = AClass.class.getField("dClass").getGenericType(); [EOL]         final Type eClassType = AClass.class.getField("eClass").getGenericType(); [EOL]         final Type fClassType = AClass.class.getField("fClass").getGenericType(); [EOL]         final AClass aClass = new AClass(new AAClass<String>()); [EOL]         aClass.bClass = aClass.cClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(cClassType, bClassType)); [EOL]         aClass.bClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, bClassType)); [EOL]         aClass.bClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, bClassType)); [EOL]         aClass.bClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, bClassType)); [EOL]         aClass.cClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, cClassType)); [EOL]         aClass.cClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, cClassType)); [EOL]         aClass.cClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, cClassType)); [EOL]         aClass.dClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, dClassType)); [EOL]         aClass.dClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, dClassType)); [EOL]         aClass.eClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, eClassType)); [EOL]     } [EOL]  [EOL]     public void delegateBooleanAssertion(final Type[] types, final int i2, final int i1, final boolean expected) { [EOL]         final Type type1 = types[i1]; [EOL]         final Type type2 = types[i2]; [EOL]         final boolean isAssignable = TypeUtils.isAssignable(type2, type1); [EOL]  [EOL]         if (expected) { [EOL]             Assert.assertTrue("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } else { [EOL]             Assert.assertFalse("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } [EOL]     } [EOL]  [EOL]     @SuppressWarnings("boxing") // boxing is deliberate here [EOL]
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [EOL]         final Type[] types = method.getGenericParameterTypes(); [EOL] //        list0 = list0; [EOL]         delegateBooleanAssertion(types, 0, 0, true); [EOL]         list1 = list0; [EOL]         delegateBooleanAssertion(types, 0, 1, true); [EOL]         list0 = list1; [EOL]         delegateBooleanAssertion(types, 1, 0, true); [EOL]         list2 = list0; [EOL]         delegateBooleanAssertion(types, 0, 2, true); [EOL]         list0 = list2; [EOL]         delegateBooleanAssertion(types, 2, 0, true); [EOL]         list3 = list0; [EOL]         delegateBooleanAssertion(types, 0, 3, true); [EOL]         list0 = list3; [EOL]         delegateBooleanAssertion(types, 3, 0, true); [EOL]         list4 = list0; [EOL]         delegateBooleanAssertion(types, 0, 4, true); [EOL]         list0 = list4; [EOL]         delegateBooleanAssertion(types, 4, 0, true); [EOL]         list5 = list0; [EOL]         delegateBooleanAssertion(types, 0, 5, true); [EOL]         list0 = list5; [EOL]         delegateBooleanAssertion(types, 5, 0, true); [EOL]         list6 = list0; [EOL]         delegateBooleanAssertion(types, 0, 6, true); [EOL]         list0 = list6; [EOL]         delegateBooleanAssertion(types, 6, 0, true); [EOL] //        list1 = list1; [EOL]         delegateBooleanAssertion(types, 1, 1, true); [EOL]         list2 = list1; [EOL]         delegateBooleanAssertion(types, 1, 2, true); [EOL]         list1 = (List<Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 1, false); [EOL]         list3 = list1; [EOL]         delegateBooleanAssertion(types, 1, 3, true); [EOL]         list1 = (List<Object>) list3; [EOL]         delegateBooleanAssertion(types, 3, 1, false); [EOL]         // list4 = list1; [EOL]         delegateBooleanAssertion(types, 1, 4, false); [EOL]         // list1 = list4; [EOL]         delegateBooleanAssertion(types, 4, 1, false); [EOL]         // list5 = list1; [EOL]         delegateBooleanAssertion(types, 1, 5, false); [EOL]         // list1 = list5; [EOL]         delegateBooleanAssertion(types, 5, 1, false); [EOL]         list6 = list1; [EOL]         delegateBooleanAssertion(types, 1, 6, true); [EOL]         list1 = (List<Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 1, false); [EOL] //        list2 = list2; [EOL]         delegateBooleanAssertion(types, 2, 2, true); [EOL]         list2 = list3; [EOL]         delegateBooleanAssertion(types, 2, 3, false); [EOL]         list2 = list4; [EOL]         delegateBooleanAssertion(types, 3, 2, true); [EOL]         list3 = (List<? super Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 4, false); [EOL]         list2 = list5; [EOL]         delegateBooleanAssertion(types, 4, 2, true); [EOL]         list4 = (List<String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 5, false); [EOL]         list2 = list6; [EOL]         delegateBooleanAssertion(types, 5, 2, true); [EOL]         list5 = (List<? extends String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 6, false); [EOL] //        list3 = list3; [EOL]         delegateBooleanAssertion(types, 6, 2, true); [EOL]         list6 = (List<? super String>) list2; [EOL]         delegateBooleanAssertion(types, 3, 3, true); [EOL]         // list4 = list3; [EOL]         delegateBooleanAssertion(types, 3, 4, false); [EOL]         // list3 = list4; [EOL]         delegateBooleanAssertion(types, 4, 3, false); [EOL]         // list5 = list3; [EOL]         delegateBooleanAssertion(types, 3, 5, false); [EOL]         // list3 = list5; [EOL]         delegateBooleanAssertion(types, 5, 3, false); [EOL]         list6 = list3; [EOL]         delegateBooleanAssertion(types, 3, 6, true); [EOL]         list3 = (List<? super Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 3, false); [EOL] //        list4 = list4; [EOL]         delegateBooleanAssertion(types, 4, 4, true); [EOL]         list5 = list4; [EOL]         delegateBooleanAssertion(types, 4, 5, true); [EOL]         list4 = (List<String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 4, false); [EOL]         list6 = list4; [EOL]         delegateBooleanAssertion(types, 4, 6, true); [EOL]         list4 = (List<String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 4, false); [EOL] //        list5 = list5; [EOL]         delegateBooleanAssertion(types, 5, 5, true); [EOL]         list6 = (List<? super String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 6, false); [EOL]         list5 = (List<? extends String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 5, false); [EOL] //        list6 = list6; [EOL]         delegateBooleanAssertion(types, 6, 6, true); [EOL]  [EOL] //        list7 = list7; [EOL]         delegateBooleanAssertion(types, 7, 7, true); [EOL]         list8 = list7; [EOL]         delegateBooleanAssertion(types, 7, 8, true); [EOL]         list7 = list8; [EOL]         delegateBooleanAssertion(types, 8, 7, true); [EOL]         list9 = list7; [EOL]         delegateBooleanAssertion(types, 7, 9, true); [EOL]         list7 = list9; [EOL]         delegateBooleanAssertion(types, 9, 7, true); [EOL]         list10 = list7; [EOL]         delegateBooleanAssertion(types, 7, 10, true); [EOL]         list7 = list10; [EOL]         delegateBooleanAssertion(types, 10, 7, true); [EOL]         list11 = list7; [EOL]         delegateBooleanAssertion(types, 7, 11, true); [EOL]         list7 = list11; [EOL]         delegateBooleanAssertion(types, 11, 7, true); [EOL]         list12 = list7; [EOL]         delegateBooleanAssertion(types, 7, 12, true); [EOL]         list7 = list12; [EOL]         delegateBooleanAssertion(types, 12, 7, true); [EOL]         list13 = list7; [EOL]         delegateBooleanAssertion(types, 7, 13, true); [EOL]         list7 = list13; [EOL]         delegateBooleanAssertion(types, 13, 7, true); [EOL] //        list8 = list8; [EOL]         delegateBooleanAssertion(types, 8, 8, true); [EOL]         list9 = list8; [EOL]         delegateBooleanAssertion(types, 8, 9, true); [EOL]         list8 = (List<Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 8, false); [EOL]         list10 = list8; [EOL]         delegateBooleanAssertion(types, 8, 10, true); [EOL]         list8 = (List<Object>[]) list10; // NOTE cast is required by Sun Java, but not by Eclipse [EOL]         delegateBooleanAssertion(types, 10, 8, false); [EOL]         // list11 = list8; [EOL]         delegateBooleanAssertion(types, 8, 11, false); [EOL]         // list8 = list11; [EOL]         delegateBooleanAssertion(types, 11, 8, false); [EOL]         // list12 = list8; [EOL]         delegateBooleanAssertion(types, 8, 12, false); [EOL]         // list8 = list12; [EOL]         delegateBooleanAssertion(types, 12, 8, false); [EOL]         list13 = list8; [EOL]         delegateBooleanAssertion(types, 8, 13, true); [EOL]         list8 = (List<Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 8, false); [EOL] //        list9 = list9; [EOL]         delegateBooleanAssertion(types, 9, 9, true); [EOL]         list10 = (List<? super Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 10, false); [EOL]         list9 = list10; [EOL]         delegateBooleanAssertion(types, 10, 9, true); [EOL]         list11 = (List<String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 11, false); [EOL]         list9 = list11; [EOL]         delegateBooleanAssertion(types, 11, 9, true); [EOL]         list12 = (List<? extends String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 12, false); [EOL]         list9 = list12; [EOL]         delegateBooleanAssertion(types, 12, 9, true); [EOL]         list13 = (List<? super String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 13, false); [EOL]         list9 = list13; [EOL]         delegateBooleanAssertion(types, 13, 9, true); [EOL] //        list10 = list10; [EOL]         delegateBooleanAssertion(types, 10, 10, true); [EOL]         // list11 = list10; [EOL]         delegateBooleanAssertion(types, 10, 11, false); [EOL]         // list10 = list11; [EOL]         delegateBooleanAssertion(types, 11, 10, false); [EOL]         // list12 = list10; [EOL]         delegateBooleanAssertion(types, 10, 12, false); [EOL]         // list10 = list12; [EOL]         delegateBooleanAssertion(types, 12, 10, false); [EOL]         list13 = list10; [EOL]         delegateBooleanAssertion(types, 10, 13, true); [EOL]         list10 = (List<? super Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 10, false); [EOL] //        list11 = list11; [EOL]         delegateBooleanAssertion(types, 11, 11, true); [EOL]         list12 = list11; [EOL]         delegateBooleanAssertion(types, 11, 12, true); [EOL]         list11 = (List<String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 11, false); [EOL]         list13 = list11; [EOL]         delegateBooleanAssertion(types, 11, 13, true); [EOL]         list11 = (List<String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 11, false); [EOL] //        list12 = list12; [EOL]         delegateBooleanAssertion(types, 12, 12, true); [EOL]         list13 = (List<? super String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 13, false); [EOL]         list12 = (List<? extends String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 12, false); [EOL] //        list13 = list13; [EOL]         delegateBooleanAssertion(types, 13, 13, true); [EOL]         final Type disType = getClass().getField("dis").getGenericType(); [EOL]         // Reporter.log( ( ( ParameterizedType ) disType [EOL]         // ).getOwnerType().getClass().toString() ); [EOL]         final Type datType = getClass().getField("dat").getGenericType(); [EOL]         final Type daType = getClass().getField("da").getGenericType(); [EOL]         final Type uhderType = getClass().getField("uhder").getGenericType(); [EOL]         final Type dingType = getClass().getField("ding").getGenericType(); [EOL]         final Type testerType = getClass().getField("tester").getGenericType(); [EOL]         final Type tester2Type = getClass().getField("tester2").getGenericType(); [EOL]         final Type dat2Type = getClass().getField("dat2").getGenericType(); [EOL]         final Type dat3Type = getClass().getField("dat3").getGenericType(); [EOL]         dis = dat; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(datType, disType)); [EOL]         // dis = da; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(daType, disType)); [EOL]         dis = uhder; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(uhderType, disType)); [EOL]         dis = ding; [EOL]         Assert.assertFalse(String.format("type %s not assignable to %s!", dingType, disType), [EOL]                 TypeUtils.isAssignable(dingType, disType)); [EOL]         dis = tester; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(testerType, disType)); [EOL]         // dis = tester2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(tester2Type, disType)); [EOL]         // dat = dat2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat2Type, datType)); [EOL]         // dat2 = dat; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(datType, dat2Type)); [EOL]         // dat = dat3; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat3Type, datType)); [EOL]         final char ch = 0; [EOL]         final boolean bo = false; [EOL]         final byte by = 0; [EOL]         final short sh = 0; [EOL]         int in = 0; [EOL]         long lo = 0; [EOL]         final float fl = 0; [EOL]         double du = 0; [EOL]         du = ch; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(char.class, double.class)); [EOL]         du = by; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(byte.class, double.class)); [EOL]         du = sh; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(short.class, double.class)); [EOL]         du = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, double.class)); [EOL]         du = lo; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(long.class, double.class)); [EOL]         du = fl; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(float.class, double.class)); [EOL]         lo = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, long.class)); [EOL]         lo = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, long.class)); [EOL]         // Long lngW = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, Long.class)); [EOL]         // lngW = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, Long.class)); [EOL]         in = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, int.class)); [EOL]         final Integer inte = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Integer.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Number.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Object.class)); [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, intComparableType)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Comparable.class)); [EOL]         final Serializable ser = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Serializable.class)); [EOL]         final Type longComparableType = getClass().getField("longComparable").getGenericType(); [EOL]         // longComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, longComparableType)); [EOL]         // longComparable = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, longComparableType)); [EOL]         // int[] ia; [EOL]         // long[] la = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, long[].class)); [EOL]         final Integer[] ia = null; [EOL]         final Type caType = getClass().getField("intWildcardComparable").getGenericType(); [EOL]         intWildcardComparable = ia; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, caType)); [EOL]         // int[] ina = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer[].class, int[].class)); [EOL]         final int[] ina = null; [EOL]         Object[] oa; [EOL]         // oa = ina; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, Object[].class)); [EOL]         oa = new Integer[0]; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, Object[].class)); [EOL]         final Type bClassType = AClass.class.getField("bClass").getGenericType(); [EOL]         final Type cClassType = AClass.class.getField("cClass").getGenericType(); [EOL]         final Type dClassType = AClass.class.getField("dClass").getGenericType(); [EOL]         final Type eClassType = AClass.class.getField("eClass").getGenericType(); [EOL]         final Type fClassType = AClass.class.getField("fClass").getGenericType(); [EOL]         final AClass aClass = new AClass(new AAClass<String>()); [EOL]         aClass.bClass = aClass.cClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(cClassType, bClassType)); [EOL]         aClass.bClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, bClassType)); [EOL]         aClass.bClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, bClassType)); [EOL]         aClass.bClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, bClassType)); [EOL]         aClass.cClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, cClassType)); [EOL]         aClass.cClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, cClassType)); [EOL]         aClass.cClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, cClassType)); [EOL]         aClass.dClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, dClassType)); [EOL]         aClass.dClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, dClassType)); [EOL]         aClass.eClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, eClassType)); [EOL]     } [EOL]  [EOL]     public void delegateBooleanAssertion(final Type[] types, final int i2, final int i1, final boolean expected) { [EOL]         final Type type1 = types[i1]; [EOL]         final Type type2 = types[i2]; [EOL]         final boolean isAssignable = TypeUtils.isAssignable(type2, type1); [EOL]  [EOL]         if (expected) { [EOL]             Assert.assertTrue("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } else { [EOL]             Assert.assertFalse("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } [EOL]     } [EOL]  [EOL]     @SuppressWarnings("boxing") // boxing is deliberate here [EOL]
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [EOL]         final Type[] types = method.getGenericParameterTypes(); [EOL] //        list0 = list0; [EOL]         delegateBooleanAssertion(types, 0, 0, true); [EOL]         list1 = list0; [EOL]         delegateBooleanAssertion(types, 0, 1, true); [EOL]         list0 = list1; [EOL]         delegateBooleanAssertion(types, 1, 0, true); [EOL]         list2 = list0; [EOL]         delegateBooleanAssertion(types, 0, 2, true); [EOL]         list0 = list2; [EOL]         delegateBooleanAssertion(types, 2, 0, true); [EOL]         list3 = list0; [EOL]         delegateBooleanAssertion(types, 0, 3, true); [EOL]         list0 = list3; [EOL]         delegateBooleanAssertion(types, 3, 0, true); [EOL]         list4 = list0; [EOL]         delegateBooleanAssertion(types, 0, 4, true); [EOL]         list0 = list4; [EOL]         delegateBooleanAssertion(types, 4, 0, true); [EOL]         list5 = list0; [EOL]         delegateBooleanAssertion(types, 0, 5, true); [EOL]         list0 = list5; [EOL]         delegateBooleanAssertion(types, 5, 0, true); [EOL]         list6 = list0; [EOL]         delegateBooleanAssertion(types, 0, 6, true); [EOL]         list0 = list6; [EOL]         delegateBooleanAssertion(types, 6, 0, true); [EOL] //        list1 = list1; [EOL]         delegateBooleanAssertion(types, 1, 1, true); [EOL]         list2 = list1; [EOL]         delegateBooleanAssertion(types, 1, 2, true); [EOL]         list1 = (List<Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 1, false); [EOL]         list3 = list1; [EOL]         delegateBooleanAssertion(types, 1, 3, true); [EOL]         list1 = (List<Object>) list3; [EOL]         delegateBooleanAssertion(types, 3, 1, false); [EOL]         // list4 = list1; [EOL]         delegateBooleanAssertion(types, 1, 4, false); [EOL]         // list1 = list4; [EOL]         delegateBooleanAssertion(types, 4, 1, false); [EOL]         // list5 = list1; [EOL]         delegateBooleanAssertion(types, 1, 5, false); [EOL]         // list1 = list5; [EOL]         delegateBooleanAssertion(types, 5, 1, false); [EOL]         list6 = list1; [EOL]         delegateBooleanAssertion(types, 1, 6, true); [EOL]         list1 = (List<Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 1, false); [EOL] //        list2 = list2; [EOL]         delegateBooleanAssertion(types, 2, 2, true); [EOL]         list2 = list3; [EOL]         delegateBooleanAssertion(types, 2, 3, false); [EOL]         list2 = list4; [EOL]         delegateBooleanAssertion(types, 3, 2, true); [EOL]         list3 = (List<? super Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 4, false); [EOL]         list2 = list5; [EOL]         delegateBooleanAssertion(types, 4, 2, true); [EOL]         list4 = (List<String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 5, false); [EOL]         list2 = list6; [EOL]         delegateBooleanAssertion(types, 5, 2, true); [EOL]         list5 = (List<? extends String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 6, false); [EOL] //        list3 = list3; [EOL]         delegateBooleanAssertion(types, 6, 2, true); [EOL]         list6 = (List<? super String>) list2; [EOL]         delegateBooleanAssertion(types, 3, 3, true); [EOL]         // list4 = list3; [EOL]         delegateBooleanAssertion(types, 3, 4, false); [EOL]         // list3 = list4; [EOL]         delegateBooleanAssertion(types, 4, 3, false); [EOL]         // list5 = list3; [EOL]         delegateBooleanAssertion(types, 3, 5, false); [EOL]         // list3 = list5; [EOL]         delegateBooleanAssertion(types, 5, 3, false); [EOL]         list6 = list3; [EOL]         delegateBooleanAssertion(types, 3, 6, true); [EOL]         list3 = (List<? super Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 3, false); [EOL] //        list4 = list4; [EOL]         delegateBooleanAssertion(types, 4, 4, true); [EOL]         list5 = list4; [EOL]         delegateBooleanAssertion(types, 4, 5, true); [EOL]         list4 = (List<String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 4, false); [EOL]         list6 = list4; [EOL]         delegateBooleanAssertion(types, 4, 6, true); [EOL]         list4 = (List<String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 4, false); [EOL] //        list5 = list5; [EOL]         delegateBooleanAssertion(types, 5, 5, true); [EOL]         list6 = (List<? super String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 6, false); [EOL]         list5 = (List<? extends String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 5, false); [EOL] //        list6 = list6; [EOL]         delegateBooleanAssertion(types, 6, 6, true); [EOL]  [EOL] //        list7 = list7; [EOL]         delegateBooleanAssertion(types, 7, 7, true); [EOL]         list8 = list7; [EOL]         delegateBooleanAssertion(types, 7, 8, true); [EOL]         list7 = list8; [EOL]         delegateBooleanAssertion(types, 8, 7, true); [EOL]         list9 = list7; [EOL]         delegateBooleanAssertion(types, 7, 9, true); [EOL]         list7 = list9; [EOL]         delegateBooleanAssertion(types, 9, 7, true); [EOL]         list10 = list7; [EOL]         delegateBooleanAssertion(types, 7, 10, true); [EOL]         list7 = list10; [EOL]         delegateBooleanAssertion(types, 10, 7, true); [EOL]         list11 = list7; [EOL]         delegateBooleanAssertion(types, 7, 11, true); [EOL]         list7 = list11; [EOL]         delegateBooleanAssertion(types, 11, 7, true); [EOL]         list12 = list7; [EOL]         delegateBooleanAssertion(types, 7, 12, true); [EOL]         list7 = list12; [EOL]         delegateBooleanAssertion(types, 12, 7, true); [EOL]         list13 = list7; [EOL]         delegateBooleanAssertion(types, 7, 13, true); [EOL]         list7 = list13; [EOL]         delegateBooleanAssertion(types, 13, 7, true); [EOL] //        list8 = list8; [EOL]         delegateBooleanAssertion(types, 8, 8, true); [EOL]         list9 = list8; [EOL]         delegateBooleanAssertion(types, 8, 9, true); [EOL]         list8 = (List<Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 8, false); [EOL]         list10 = list8; [EOL]         delegateBooleanAssertion(types, 8, 10, true); [EOL]         list8 = (List<Object>[]) list10; // NOTE cast is required by Sun Java, but not by Eclipse [EOL]         delegateBooleanAssertion(types, 10, 8, false); [EOL]         // list11 = list8; [EOL]         delegateBooleanAssertion(types, 8, 11, false); [EOL]         // list8 = list11; [EOL]         delegateBooleanAssertion(types, 11, 8, false); [EOL]         // list12 = list8; [EOL]         delegateBooleanAssertion(types, 8, 12, false); [EOL]         // list8 = list12; [EOL]         delegateBooleanAssertion(types, 12, 8, false); [EOL]         list13 = list8; [EOL]         delegateBooleanAssertion(types, 8, 13, true); [EOL]         list8 = (List<Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 8, false); [EOL] //        list9 = list9; [EOL]         delegateBooleanAssertion(types, 9, 9, true); [EOL]         list10 = (List<? super Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 10, false); [EOL]         list9 = list10; [EOL]         delegateBooleanAssertion(types, 10, 9, true); [EOL]         list11 = (List<String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 11, false); [EOL]         list9 = list11; [EOL]         delegateBooleanAssertion(types, 11, 9, true); [EOL]         list12 = (List<? extends String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 12, false); [EOL]         list9 = list12; [EOL]         delegateBooleanAssertion(types, 12, 9, true); [EOL]         list13 = (List<? super String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 13, false); [EOL]         list9 = list13; [EOL]         delegateBooleanAssertion(types, 13, 9, true); [EOL] //        list10 = list10; [EOL]         delegateBooleanAssertion(types, 10, 10, true); [EOL]         // list11 = list10; [EOL]         delegateBooleanAssertion(types, 10, 11, false); [EOL]         // list10 = list11; [EOL]         delegateBooleanAssertion(types, 11, 10, false); [EOL]         // list12 = list10; [EOL]         delegateBooleanAssertion(types, 10, 12, false); [EOL]         // list10 = list12; [EOL]         delegateBooleanAssertion(types, 12, 10, false); [EOL]         list13 = list10; [EOL]         delegateBooleanAssertion(types, 10, 13, true); [EOL]         list10 = (List<? super Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 10, false); [EOL] //        list11 = list11; [EOL]         delegateBooleanAssertion(types, 11, 11, true); [EOL]         list12 = list11; [EOL]         delegateBooleanAssertion(types, 11, 12, true); [EOL]         list11 = (List<String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 11, false); [EOL]         list13 = list11; [EOL]         delegateBooleanAssertion(types, 11, 13, true); [EOL]         list11 = (List<String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 11, false); [EOL] //        list12 = list12; [EOL]         delegateBooleanAssertion(types, 12, 12, true); [EOL]         list13 = (List<? super String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 13, false); [EOL]         list12 = (List<? extends String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 12, false); [EOL] //        list13 = list13; [EOL]         delegateBooleanAssertion(types, 13, 13, true); [EOL]         final Type disType = getClass().getField("dis").getGenericType(); [EOL]         // Reporter.log( ( ( ParameterizedType ) disType [EOL]         // ).getOwnerType().getClass().toString() ); [EOL]         final Type datType = getClass().getField("dat").getGenericType(); [EOL]         final Type daType = getClass().getField("da").getGenericType(); [EOL]         final Type uhderType = getClass().getField("uhder").getGenericType(); [EOL]         final Type dingType = getClass().getField("ding").getGenericType(); [EOL]         final Type testerType = getClass().getField("tester").getGenericType(); [EOL]         final Type tester2Type = getClass().getField("tester2").getGenericType(); [EOL]         final Type dat2Type = getClass().getField("dat2").getGenericType(); [EOL]         final Type dat3Type = getClass().getField("dat3").getGenericType(); [EOL]         dis = dat; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(datType, disType)); [EOL]         // dis = da; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(daType, disType)); [EOL]         dis = uhder; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(uhderType, disType)); [EOL]         dis = ding; [EOL]         Assert.assertFalse(String.format("type %s not assignable to %s!", dingType, disType), [EOL]                 TypeUtils.isAssignable(dingType, disType)); [EOL]         dis = tester; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(testerType, disType)); [EOL]         // dis = tester2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(tester2Type, disType)); [EOL]         // dat = dat2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat2Type, datType)); [EOL]         // dat2 = dat; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(datType, dat2Type)); [EOL]         // dat = dat3; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat3Type, datType)); [EOL]         final char ch = 0; [EOL]         final boolean bo = false; [EOL]         final byte by = 0; [EOL]         final short sh = 0; [EOL]         int in = 0; [EOL]         long lo = 0; [EOL]         final float fl = 0; [EOL]         double du = 0; [EOL]         du = ch; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(char.class, double.class)); [EOL]         du = by; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(byte.class, double.class)); [EOL]         du = sh; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(short.class, double.class)); [EOL]         du = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, double.class)); [EOL]         du = lo; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(long.class, double.class)); [EOL]         du = fl; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(float.class, double.class)); [EOL]         lo = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, long.class)); [EOL]         lo = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, long.class)); [EOL]         // Long lngW = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, Long.class)); [EOL]         // lngW = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, Long.class)); [EOL]         in = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, int.class)); [EOL]         final Integer inte = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Integer.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Number.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Object.class)); [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, intComparableType)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Comparable.class)); [EOL]         final Serializable ser = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Serializable.class)); [EOL]         final Type longComparableType = getClass().getField("longComparable").getGenericType(); [EOL]         // longComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, longComparableType)); [EOL]         // longComparable = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, longComparableType)); [EOL]         // int[] ia; [EOL]         // long[] la = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, long[].class)); [EOL]         final Integer[] ia = null; [EOL]         final Type caType = getClass().getField("intWildcardComparable").getGenericType(); [EOL]         intWildcardComparable = ia; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, caType)); [EOL]         // int[] ina = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer[].class, int[].class)); [EOL]         final int[] ina = null; [EOL]         Object[] oa; [EOL]         // oa = ina; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, Object[].class)); [EOL]         oa = new Integer[0]; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, Object[].class)); [EOL]         final Type bClassType = AClass.class.getField("bClass").getGenericType(); [EOL]         final Type cClassType = AClass.class.getField("cClass").getGenericType(); [EOL]         final Type dClassType = AClass.class.getField("dClass").getGenericType(); [EOL]         final Type eClassType = AClass.class.getField("eClass").getGenericType(); [EOL]         final Type fClassType = AClass.class.getField("fClass").getGenericType(); [EOL]         final AClass aClass = new AClass(new AAClass<String>()); [EOL]         aClass.bClass = aClass.cClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(cClassType, bClassType)); [EOL]         aClass.bClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, bClassType)); [EOL]         aClass.bClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, bClassType)); [EOL]         aClass.bClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, bClassType)); [EOL]         aClass.cClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, cClassType)); [EOL]         aClass.cClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, cClassType)); [EOL]         aClass.cClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, cClassType)); [EOL]         aClass.dClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, dClassType)); [EOL]         aClass.dClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, dClassType)); [EOL]         aClass.eClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, eClassType)); [EOL]     } [EOL]  [EOL]     public void delegateBooleanAssertion(final Type[] types, final int i2, final int i1, final boolean expected) { [EOL]         final Type type1 = types[i1]; [EOL]         final Type type2 = types[i2]; [EOL]         final boolean isAssignable = TypeUtils.isAssignable(type2, type1); [EOL]  [EOL]         if (expected) { [EOL]             Assert.assertTrue("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } else { [EOL]             Assert.assertFalse("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } [EOL]     } [EOL]  [EOL]     @SuppressWarnings("boxing") // boxing is deliberate here [EOL]
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchMethodException, [EOL]             NoSuchFieldException { [EOL]         List list0 = null; [EOL]         List<Object> list1 = null; [EOL]         List<?> list2 = null; [EOL]         List<? super Object> list3 = null; [EOL]         List<String> list4 = null; [EOL]         List<? extends String> list5 = null; [EOL]         List<? super String> list6 = null; [EOL]         List[] list7 = null; [EOL]         List<Object>[] list8 = null; [EOL]         List<?>[] list9 = null; [EOL]         List<? super Object>[] list10 = null; [EOL]         List<String>[] list11 = null; [EOL]         List<? extends String>[] list12 = null; [EOL]         List<? super String>[] list13; [EOL]         final Class<?> clazz = getClass(); [EOL]         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [EOL]         final Type[] types = method.getGenericParameterTypes(); [EOL] //        list0 = list0; [EOL]         delegateBooleanAssertion(types, 0, 0, true); [EOL]         list1 = list0; [EOL]         delegateBooleanAssertion(types, 0, 1, true); [EOL]         list0 = list1; [EOL]         delegateBooleanAssertion(types, 1, 0, true); [EOL]         list2 = list0; [EOL]         delegateBooleanAssertion(types, 0, 2, true); [EOL]         list0 = list2; [EOL]         delegateBooleanAssertion(types, 2, 0, true); [EOL]         list3 = list0; [EOL]         delegateBooleanAssertion(types, 0, 3, true); [EOL]         list0 = list3; [EOL]         delegateBooleanAssertion(types, 3, 0, true); [EOL]         list4 = list0; [EOL]         delegateBooleanAssertion(types, 0, 4, true); [EOL]         list0 = list4; [EOL]         delegateBooleanAssertion(types, 4, 0, true); [EOL]         list5 = list0; [EOL]         delegateBooleanAssertion(types, 0, 5, true); [EOL]         list0 = list5; [EOL]         delegateBooleanAssertion(types, 5, 0, true); [EOL]         list6 = list0; [EOL]         delegateBooleanAssertion(types, 0, 6, true); [EOL]         list0 = list6; [EOL]         delegateBooleanAssertion(types, 6, 0, true); [EOL] //        list1 = list1; [EOL]         delegateBooleanAssertion(types, 1, 1, true); [EOL]         list2 = list1; [EOL]         delegateBooleanAssertion(types, 1, 2, true); [EOL]         list1 = (List<Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 1, false); [EOL]         list3 = list1; [EOL]         delegateBooleanAssertion(types, 1, 3, true); [EOL]         list1 = (List<Object>) list3; [EOL]         delegateBooleanAssertion(types, 3, 1, false); [EOL]         // list4 = list1; [EOL]         delegateBooleanAssertion(types, 1, 4, false); [EOL]         // list1 = list4; [EOL]         delegateBooleanAssertion(types, 4, 1, false); [EOL]         // list5 = list1; [EOL]         delegateBooleanAssertion(types, 1, 5, false); [EOL]         // list1 = list5; [EOL]         delegateBooleanAssertion(types, 5, 1, false); [EOL]         list6 = list1; [EOL]         delegateBooleanAssertion(types, 1, 6, true); [EOL]         list1 = (List<Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 1, false); [EOL] //        list2 = list2; [EOL]         delegateBooleanAssertion(types, 2, 2, true); [EOL]         list2 = list3; [EOL]         delegateBooleanAssertion(types, 2, 3, false); [EOL]         list2 = list4; [EOL]         delegateBooleanAssertion(types, 3, 2, true); [EOL]         list3 = (List<? super Object>) list2; [EOL]         delegateBooleanAssertion(types, 2, 4, false); [EOL]         list2 = list5; [EOL]         delegateBooleanAssertion(types, 4, 2, true); [EOL]         list4 = (List<String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 5, false); [EOL]         list2 = list6; [EOL]         delegateBooleanAssertion(types, 5, 2, true); [EOL]         list5 = (List<? extends String>) list2; [EOL]         delegateBooleanAssertion(types, 2, 6, false); [EOL] //        list3 = list3; [EOL]         delegateBooleanAssertion(types, 6, 2, true); [EOL]         list6 = (List<? super String>) list2; [EOL]         delegateBooleanAssertion(types, 3, 3, true); [EOL]         // list4 = list3; [EOL]         delegateBooleanAssertion(types, 3, 4, false); [EOL]         // list3 = list4; [EOL]         delegateBooleanAssertion(types, 4, 3, false); [EOL]         // list5 = list3; [EOL]         delegateBooleanAssertion(types, 3, 5, false); [EOL]         // list3 = list5; [EOL]         delegateBooleanAssertion(types, 5, 3, false); [EOL]         list6 = list3; [EOL]         delegateBooleanAssertion(types, 3, 6, true); [EOL]         list3 = (List<? super Object>) list6; [EOL]         delegateBooleanAssertion(types, 6, 3, false); [EOL] //        list4 = list4; [EOL]         delegateBooleanAssertion(types, 4, 4, true); [EOL]         list5 = list4; [EOL]         delegateBooleanAssertion(types, 4, 5, true); [EOL]         list4 = (List<String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 4, false); [EOL]         list6 = list4; [EOL]         delegateBooleanAssertion(types, 4, 6, true); [EOL]         list4 = (List<String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 4, false); [EOL] //        list5 = list5; [EOL]         delegateBooleanAssertion(types, 5, 5, true); [EOL]         list6 = (List<? super String>) list5; [EOL]         delegateBooleanAssertion(types, 5, 6, false); [EOL]         list5 = (List<? extends String>) list6; [EOL]         delegateBooleanAssertion(types, 6, 5, false); [EOL] //        list6 = list6; [EOL]         delegateBooleanAssertion(types, 6, 6, true); [EOL]  [EOL] //        list7 = list7; [EOL]         delegateBooleanAssertion(types, 7, 7, true); [EOL]         list8 = list7; [EOL]         delegateBooleanAssertion(types, 7, 8, true); [EOL]         list7 = list8; [EOL]         delegateBooleanAssertion(types, 8, 7, true); [EOL]         list9 = list7; [EOL]         delegateBooleanAssertion(types, 7, 9, true); [EOL]         list7 = list9; [EOL]         delegateBooleanAssertion(types, 9, 7, true); [EOL]         list10 = list7; [EOL]         delegateBooleanAssertion(types, 7, 10, true); [EOL]         list7 = list10; [EOL]         delegateBooleanAssertion(types, 10, 7, true); [EOL]         list11 = list7; [EOL]         delegateBooleanAssertion(types, 7, 11, true); [EOL]         list7 = list11; [EOL]         delegateBooleanAssertion(types, 11, 7, true); [EOL]         list12 = list7; [EOL]         delegateBooleanAssertion(types, 7, 12, true); [EOL]         list7 = list12; [EOL]         delegateBooleanAssertion(types, 12, 7, true); [EOL]         list13 = list7; [EOL]         delegateBooleanAssertion(types, 7, 13, true); [EOL]         list7 = list13; [EOL]         delegateBooleanAssertion(types, 13, 7, true); [EOL] //        list8 = list8; [EOL]         delegateBooleanAssertion(types, 8, 8, true); [EOL]         list9 = list8; [EOL]         delegateBooleanAssertion(types, 8, 9, true); [EOL]         list8 = (List<Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 8, false); [EOL]         list10 = list8; [EOL]         delegateBooleanAssertion(types, 8, 10, true); [EOL]         list8 = (List<Object>[]) list10; // NOTE cast is required by Sun Java, but not by Eclipse [EOL]         delegateBooleanAssertion(types, 10, 8, false); [EOL]         // list11 = list8; [EOL]         delegateBooleanAssertion(types, 8, 11, false); [EOL]         // list8 = list11; [EOL]         delegateBooleanAssertion(types, 11, 8, false); [EOL]         // list12 = list8; [EOL]         delegateBooleanAssertion(types, 8, 12, false); [EOL]         // list8 = list12; [EOL]         delegateBooleanAssertion(types, 12, 8, false); [EOL]         list13 = list8; [EOL]         delegateBooleanAssertion(types, 8, 13, true); [EOL]         list8 = (List<Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 8, false); [EOL] //        list9 = list9; [EOL]         delegateBooleanAssertion(types, 9, 9, true); [EOL]         list10 = (List<? super Object>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 10, false); [EOL]         list9 = list10; [EOL]         delegateBooleanAssertion(types, 10, 9, true); [EOL]         list11 = (List<String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 11, false); [EOL]         list9 = list11; [EOL]         delegateBooleanAssertion(types, 11, 9, true); [EOL]         list12 = (List<? extends String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 12, false); [EOL]         list9 = list12; [EOL]         delegateBooleanAssertion(types, 12, 9, true); [EOL]         list13 = (List<? super String>[]) list9; [EOL]         delegateBooleanAssertion(types, 9, 13, false); [EOL]         list9 = list13; [EOL]         delegateBooleanAssertion(types, 13, 9, true); [EOL] //        list10 = list10; [EOL]         delegateBooleanAssertion(types, 10, 10, true); [EOL]         // list11 = list10; [EOL]         delegateBooleanAssertion(types, 10, 11, false); [EOL]         // list10 = list11; [EOL]         delegateBooleanAssertion(types, 11, 10, false); [EOL]         // list12 = list10; [EOL]         delegateBooleanAssertion(types, 10, 12, false); [EOL]         // list10 = list12; [EOL]         delegateBooleanAssertion(types, 12, 10, false); [EOL]         list13 = list10; [EOL]         delegateBooleanAssertion(types, 10, 13, true); [EOL]         list10 = (List<? super Object>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 10, false); [EOL] //        list11 = list11; [EOL]         delegateBooleanAssertion(types, 11, 11, true); [EOL]         list12 = list11; [EOL]         delegateBooleanAssertion(types, 11, 12, true); [EOL]         list11 = (List<String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 11, false); [EOL]         list13 = list11; [EOL]         delegateBooleanAssertion(types, 11, 13, true); [EOL]         list11 = (List<String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 11, false); [EOL] //        list12 = list12; [EOL]         delegateBooleanAssertion(types, 12, 12, true); [EOL]         list13 = (List<? super String>[]) list12; [EOL]         delegateBooleanAssertion(types, 12, 13, false); [EOL]         list12 = (List<? extends String>[]) list13; [EOL]         delegateBooleanAssertion(types, 13, 12, false); [EOL] //        list13 = list13; [EOL]         delegateBooleanAssertion(types, 13, 13, true); [EOL]         final Type disType = getClass().getField("dis").getGenericType(); [EOL]         // Reporter.log( ( ( ParameterizedType ) disType [EOL]         // ).getOwnerType().getClass().toString() ); [EOL]         final Type datType = getClass().getField("dat").getGenericType(); [EOL]         final Type daType = getClass().getField("da").getGenericType(); [EOL]         final Type uhderType = getClass().getField("uhder").getGenericType(); [EOL]         final Type dingType = getClass().getField("ding").getGenericType(); [EOL]         final Type testerType = getClass().getField("tester").getGenericType(); [EOL]         final Type tester2Type = getClass().getField("tester2").getGenericType(); [EOL]         final Type dat2Type = getClass().getField("dat2").getGenericType(); [EOL]         final Type dat3Type = getClass().getField("dat3").getGenericType(); [EOL]         dis = dat; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(datType, disType)); [EOL]         // dis = da; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(daType, disType)); [EOL]         dis = uhder; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(uhderType, disType)); [EOL]         dis = ding; [EOL]         Assert.assertFalse(String.format("type %s not assignable to %s!", dingType, disType), [EOL]                 TypeUtils.isAssignable(dingType, disType)); [EOL]         dis = tester; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(testerType, disType)); [EOL]         // dis = tester2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(tester2Type, disType)); [EOL]         // dat = dat2; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat2Type, datType)); [EOL]         // dat2 = dat; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(datType, dat2Type)); [EOL]         // dat = dat3; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(dat3Type, datType)); [EOL]         final char ch = 0; [EOL]         final boolean bo = false; [EOL]         final byte by = 0; [EOL]         final short sh = 0; [EOL]         int in = 0; [EOL]         long lo = 0; [EOL]         final float fl = 0; [EOL]         double du = 0; [EOL]         du = ch; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(char.class, double.class)); [EOL]         du = by; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(byte.class, double.class)); [EOL]         du = sh; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(short.class, double.class)); [EOL]         du = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, double.class)); [EOL]         du = lo; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(long.class, double.class)); [EOL]         du = fl; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(float.class, double.class)); [EOL]         lo = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, long.class)); [EOL]         lo = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, long.class)); [EOL]         // Long lngW = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, Long.class)); [EOL]         // lngW = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, Long.class)); [EOL]         in = Integer.valueOf(0); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, int.class)); [EOL]         final Integer inte = in; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Integer.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Number.class)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Object.class)); [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, intComparableType)); [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Comparable.class)); [EOL]         final Serializable ser = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(int.class, Serializable.class)); [EOL]         final Type longComparableType = getClass().getField("longComparable").getGenericType(); [EOL]         // longComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int.class, longComparableType)); [EOL]         // longComparable = Integer.valueOf( 0 ); [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, longComparableType)); [EOL]         // int[] ia; [EOL]         // long[] la = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, long[].class)); [EOL]         final Integer[] ia = null; [EOL]         final Type caType = getClass().getField("intWildcardComparable").getGenericType(); [EOL]         intWildcardComparable = ia; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, caType)); [EOL]         // int[] ina = ia; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(Integer[].class, int[].class)); [EOL]         final int[] ina = null; [EOL]         Object[] oa; [EOL]         // oa = ina; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(int[].class, Object[].class)); [EOL]         oa = new Integer[0]; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, Object[].class)); [EOL]         final Type bClassType = AClass.class.getField("bClass").getGenericType(); [EOL]         final Type cClassType = AClass.class.getField("cClass").getGenericType(); [EOL]         final Type dClassType = AClass.class.getField("dClass").getGenericType(); [EOL]         final Type eClassType = AClass.class.getField("eClass").getGenericType(); [EOL]         final Type fClassType = AClass.class.getField("fClass").getGenericType(); [EOL]         final AClass aClass = new AClass(new AAClass<String>()); [EOL]         aClass.bClass = aClass.cClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(cClassType, bClassType)); [EOL]         aClass.bClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, bClassType)); [EOL]         aClass.bClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, bClassType)); [EOL]         aClass.bClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, bClassType)); [EOL]         aClass.cClass = aClass.dClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(dClassType, cClassType)); [EOL]         aClass.cClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, cClassType)); [EOL]         aClass.cClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, cClassType)); [EOL]         aClass.dClass = aClass.eClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(eClassType, dClassType)); [EOL]         aClass.dClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, dClassType)); [EOL]         aClass.eClass = aClass.fClass; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(fClassType, eClassType)); [EOL]     } [EOL]  [EOL]     public void delegateBooleanAssertion(final Type[] types, final int i2, final int i1, final boolean expected) { [EOL]         final Type type1 = types[i1]; [EOL]         final Type type2 = types[i2]; [EOL]         final boolean isAssignable = TypeUtils.isAssignable(type2, type1); [EOL]  [EOL]         if (expected) { [EOL]             Assert.assertTrue("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } else { [EOL]             Assert.assertFalse("[" + i1 + ", " + i2 + "]: From " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " [EOL]                     + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); [EOL]         } [EOL]     } [EOL]  [EOL]     @SuppressWarnings("boxing") // boxing is deliberate here [EOL]
@Test [EOL]     public void testGetTypeArguments() { [EOL]         Map<TypeVariable<?>, Type> typeVarAssigns; [EOL]         TypeVariable<?> treeSetTypeVar; [EOL]         Type typeArg; [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Integer.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from Integer: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]         Assert.assertEquals("Type argument of Comparable from Integer: " + typeArg, Integer.class, [EOL]                 typeVarAssigns.get(treeSetTypeVar)); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(int.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from int: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]         Assert.assertEquals("Type argument of Comparable from int: " + typeArg, Integer.class, [EOL]                 typeVarAssigns.get(treeSetTypeVar)); [EOL]  [EOL]         final Collection<Integer> col = Arrays.asList(new Integer[0]); [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(List.class, Collection.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertFalse("Type var assigns for Collection from List: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(AAAClass.BBBClass.class, AAClass.BBClass.class); [EOL]         Assert.assertTrue(typeVarAssigns.size() == 2); [EOL]         Assert.assertEquals(String.class, typeVarAssigns.get(AAClass.class.getTypeParameters()[0])); [EOL]         Assert.assertEquals(String.class, typeVarAssigns.get(AAClass.BBClass.class.getTypeParameters()[0])); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Other.class, This.class); [EOL]         Assert.assertEquals(2, typeVarAssigns.size()); [EOL]         Assert.assertEquals(String.class, typeVarAssigns.get(This.class.getTypeParameters()[0])); [EOL]         Assert.assertEquals(Other.class.getTypeParameters()[0], typeVarAssigns.get(This.class.getTypeParameters()[1])); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(And.class, This.class); [EOL]         Assert.assertEquals(2, typeVarAssigns.size()); [EOL]         Assert.assertEquals(Number.class, typeVarAssigns.get(This.class.getTypeParameters()[0])); [EOL]         Assert.assertEquals(Number.class, typeVarAssigns.get(This.class.getTypeParameters()[1])); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Thing.class, Other.class); [EOL]         Assert.assertEquals(2, typeVarAssigns.size()); [EOL]         Assert.assertEquals(getClass().getTypeParameters()[0], typeVarAssigns.get(getClass().getTypeParameters()[0])); [EOL]         Assert.assertEquals(getClass().getTypeParameters()[0], typeVarAssigns.get(Other.class.getTypeParameters()[0])); [EOL]     } [EOL]  [EOL] //
@Test [EOL]     public void testGetTypeArguments() { [EOL]         Map<TypeVariable<?>, Type> typeVarAssigns; [EOL]         TypeVariable<?> treeSetTypeVar; [EOL]         Type typeArg; [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Integer.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from Integer: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]         Assert.assertEquals("Type argument of Comparable from Integer: " + typeArg, Integer.class, [EOL]                 typeVarAssigns.get(treeSetTypeVar)); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(int.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from int: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]         Assert.assertEquals("Type argument of Comparable from int: " + typeArg, Integer.class, [EOL]                 typeVarAssigns.get(treeSetTypeVar)); [EOL]  [EOL]         final Collection<Integer> col = Arrays.asList(new Integer[0]); [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(List.class, Collection.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertFalse("Type var assigns for Collection from List: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(AAAClass.BBBClass.class, AAClass.BBClass.class); [EOL]         Assert.assertTrue(typeVarAssigns.size() == 2); [EOL]         Assert.assertEquals(String.class, typeVarAssigns.get(AAClass.class.getTypeParameters()[0])); [EOL]         Assert.assertEquals(String.class, typeVarAssigns.get(AAClass.BBClass.class.getTypeParameters()[0])); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Other.class, This.class); [EOL]         Assert.assertEquals(2, typeVarAssigns.size()); [EOL]         Assert.assertEquals(String.class, typeVarAssigns.get(This.class.getTypeParameters()[0])); [EOL]         Assert.assertEquals(Other.class.getTypeParameters()[0], typeVarAssigns.get(This.class.getTypeParameters()[1])); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(And.class, This.class); [EOL]         Assert.assertEquals(2, typeVarAssigns.size()); [EOL]         Assert.assertEquals(Number.class, typeVarAssigns.get(This.class.getTypeParameters()[0])); [EOL]         Assert.assertEquals(Number.class, typeVarAssigns.get(This.class.getTypeParameters()[1])); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Thing.class, Other.class); [EOL]         Assert.assertEquals(2, typeVarAssigns.size()); [EOL]         Assert.assertEquals(getClass().getTypeParameters()[0], typeVarAssigns.get(getClass().getTypeParameters()[0])); [EOL]         Assert.assertEquals(getClass().getTypeParameters()[0], typeVarAssigns.get(Other.class.getTypeParameters()[0])); [EOL]     } [EOL]  [EOL] //
@Test [EOL]     public void testGetTypeArguments() { [EOL]         Map<TypeVariable<?>, Type> typeVarAssigns; [EOL]         TypeVariable<?> treeSetTypeVar; [EOL]         Type typeArg; [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Integer.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from Integer: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]         Assert.assertEquals("Type argument of Comparable from Integer: " + typeArg, Integer.class, [EOL]                 typeVarAssigns.get(treeSetTypeVar)); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(int.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from int: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]         Assert.assertEquals("Type argument of Comparable from int: " + typeArg, Integer.class, [EOL]                 typeVarAssigns.get(treeSetTypeVar)); [EOL]  [EOL]         final Collection<Integer> col = Arrays.asList(new Integer[0]); [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(List.class, Collection.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertFalse("Type var assigns for Collection from List: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(AAAClass.BBBClass.class, AAClass.BBClass.class); [EOL]         Assert.assertTrue(typeVarAssigns.size() == 2); [EOL]         Assert.assertEquals(String.class, typeVarAssigns.get(AAClass.class.getTypeParameters()[0])); [EOL]         Assert.assertEquals(String.class, typeVarAssigns.get(AAClass.BBClass.class.getTypeParameters()[0])); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Other.class, This.class); [EOL]         Assert.assertEquals(2, typeVarAssigns.size()); [EOL]         Assert.assertEquals(String.class, typeVarAssigns.get(This.class.getTypeParameters()[0])); [EOL]         Assert.assertEquals(Other.class.getTypeParameters()[0], typeVarAssigns.get(This.class.getTypeParameters()[1])); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(And.class, This.class); [EOL]         Assert.assertEquals(2, typeVarAssigns.size()); [EOL]         Assert.assertEquals(Number.class, typeVarAssigns.get(This.class.getTypeParameters()[0])); [EOL]         Assert.assertEquals(Number.class, typeVarAssigns.get(This.class.getTypeParameters()[1])); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Thing.class, Other.class); [EOL]         Assert.assertEquals(2, typeVarAssigns.size()); [EOL]         Assert.assertEquals(getClass().getTypeParameters()[0], typeVarAssigns.get(getClass().getTypeParameters()[0])); [EOL]         Assert.assertEquals(getClass().getTypeParameters()[0], typeVarAssigns.get(Other.class.getTypeParameters()[0])); [EOL]     } [EOL]  [EOL] //
@Test [EOL]     public void testGetRawType() throws SecurityException, NoSuchFieldException { [EOL]         final Type stringParentFieldType = GenericTypeHolder.class.getDeclaredField("stringParent") [EOL]                 .getGenericType(); [EOL]         final Type integerParentFieldType = GenericTypeHolder.class.getDeclaredField("integerParent") [EOL]                 .getGenericType(); [EOL]         final Type foosFieldType = GenericTypeHolder.class.getDeclaredField("foos").getGenericType(); [EOL]         final Type genericParentT = GenericParent.class.getTypeParameters()[0]; [EOL]         Assert.assertEquals(GenericParent.class, TypeUtils.getRawType(stringParentFieldType, null)); [EOL]         Assert [EOL]                 .assertEquals(GenericParent.class, TypeUtils.getRawType(integerParentFieldType, [EOL]                         null)); [EOL]         Assert.assertEquals(List.class, TypeUtils.getRawType(foosFieldType, null)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 StringParameterizedChild.class)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 stringParentFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(Iterable.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(List.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertNull(TypeUtils.getRawType(genericParentT, GenericParent.class)); [EOL]         Assert.assertEquals(GenericParent[].class, TypeUtils.getRawType(GenericTypeHolder.class [EOL]                 .getDeclaredField("barParents").getGenericType(), null)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetTypeArguments() { [EOL]         Map<TypeVariable<?>, Type> typeVarAssigns; [EOL]         TypeVariable<?> treeSetTypeVar; [EOL]         Type typeArg; [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Integer.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from Integer: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]         Assert.assertEquals("Type argument of Comparable from Integer: " + typeArg, Integer.class, [EOL]                 typeVarAssigns.get(treeSetTypeVar)); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(int.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from int: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]         Assert.assertEquals("Type argument of Comparable from int: " + typeArg, Integer.class, [EOL]                 typeVarAssigns.get(treeSetTypeVar)); [EOL]  [EOL]         final Collection<Integer> col = Arrays.asList(new Integer[0]); [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(List.class, Collection.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertFalse("Type var assigns for Collection from List: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(AAAClass.BBBClass.class, AAClass.BBClass.class); [EOL]         Assert.assertTrue(typeVarAssigns.size() == 2); [EOL]         Assert.assertEquals(String.class, typeVarAssigns.get(AAClass.class.getTypeParameters()[0])); [EOL]         Assert.assertEquals(String.class, typeVarAssigns.get(AAClass.BBClass.class.getTypeParameters()[0])); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Other.class, This.class); [EOL]         Assert.assertEquals(2, typeVarAssigns.size()); [EOL]         Assert.assertEquals(String.class, typeVarAssigns.get(This.class.getTypeParameters()[0])); [EOL]         Assert.assertEquals(Other.class.getTypeParameters()[0], typeVarAssigns.get(This.class.getTypeParameters()[1])); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(And.class, This.class); [EOL]         Assert.assertEquals(2, typeVarAssigns.size()); [EOL]         Assert.assertEquals(Number.class, typeVarAssigns.get(This.class.getTypeParameters()[0])); [EOL]         Assert.assertEquals(Number.class, typeVarAssigns.get(This.class.getTypeParameters()[1])); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Thing.class, Other.class); [EOL]         Assert.assertEquals(2, typeVarAssigns.size()); [EOL]         Assert.assertEquals(getClass().getTypeParameters()[0], typeVarAssigns.get(getClass().getTypeParameters()[0])); [EOL]         Assert.assertEquals(getClass().getTypeParameters()[0], typeVarAssigns.get(Other.class.getTypeParameters()[0])); [EOL]     } [EOL]  [EOL] //
@Test [EOL]     public void testGetTypeArguments() { [EOL]         Map<TypeVariable<?>, Type> typeVarAssigns; [EOL]         TypeVariable<?> treeSetTypeVar; [EOL]         Type typeArg; [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Integer.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from Integer: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]         Assert.assertEquals("Type argument of Comparable from Integer: " + typeArg, Integer.class, [EOL]                 typeVarAssigns.get(treeSetTypeVar)); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(int.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from int: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]         Assert.assertEquals("Type argument of Comparable from int: " + typeArg, Integer.class, [EOL]                 typeVarAssigns.get(treeSetTypeVar)); [EOL]  [EOL]         final Collection<Integer> col = Arrays.asList(new Integer[0]); [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(List.class, Collection.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertFalse("Type var assigns for Collection from List: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(AAAClass.BBBClass.class, AAClass.BBClass.class); [EOL]         Assert.assertTrue(typeVarAssigns.size() == 2); [EOL]         Assert.assertEquals(String.class, typeVarAssigns.get(AAClass.class.getTypeParameters()[0])); [EOL]         Assert.assertEquals(String.class, typeVarAssigns.get(AAClass.BBClass.class.getTypeParameters()[0])); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Other.class, This.class); [EOL]         Assert.assertEquals(2, typeVarAssigns.size()); [EOL]         Assert.assertEquals(String.class, typeVarAssigns.get(This.class.getTypeParameters()[0])); [EOL]         Assert.assertEquals(Other.class.getTypeParameters()[0], typeVarAssigns.get(This.class.getTypeParameters()[1])); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(And.class, This.class); [EOL]         Assert.assertEquals(2, typeVarAssigns.size()); [EOL]         Assert.assertEquals(Number.class, typeVarAssigns.get(This.class.getTypeParameters()[0])); [EOL]         Assert.assertEquals(Number.class, typeVarAssigns.get(This.class.getTypeParameters()[1])); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Thing.class, Other.class); [EOL]         Assert.assertEquals(2, typeVarAssigns.size()); [EOL]         Assert.assertEquals(getClass().getTypeParameters()[0], typeVarAssigns.get(getClass().getTypeParameters()[0])); [EOL]         Assert.assertEquals(getClass().getTypeParameters()[0], typeVarAssigns.get(Other.class.getTypeParameters()[0])); [EOL]     } [EOL]  [EOL] //
@Test [EOL]     public void testDetermineTypeVariableAssignments() throws SecurityException, [EOL]             NoSuchFieldException, NoSuchMethodException { [EOL]         final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable") [EOL]                 .getGenericType(); [EOL]         final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, [EOL]                 iterableType); [EOL]         final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns [EOL]                 .get(treeSetTypeVar)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testDetermineTypeVariableAssignments() throws SecurityException, [EOL]             NoSuchFieldException, NoSuchMethodException { [EOL]         final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable") [EOL]                 .getGenericType(); [EOL]         final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, [EOL]                 iterableType); [EOL]         final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns [EOL]                 .get(treeSetTypeVar)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testDetermineTypeVariableAssignments() throws SecurityException, [EOL]             NoSuchFieldException, NoSuchMethodException { [EOL]         final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable") [EOL]                 .getGenericType(); [EOL]         final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, [EOL]                 iterableType); [EOL]         final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns [EOL]                 .get(treeSetTypeVar)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testDetermineTypeVariableAssignments() throws SecurityException, [EOL]             NoSuchFieldException, NoSuchMethodException { [EOL]         final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable") [EOL]                 .getGenericType(); [EOL]         final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, [EOL]                 iterableType); [EOL]         final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns [EOL]                 .get(treeSetTypeVar)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testDetermineTypeVariableAssignments() throws SecurityException, [EOL]             NoSuchFieldException, NoSuchMethodException { [EOL]         final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable") [EOL]                 .getGenericType(); [EOL]         final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, [EOL]                 iterableType); [EOL]         final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns [EOL]                 .get(treeSetTypeVar)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testDetermineTypeVariableAssignments() throws SecurityException, [EOL]             NoSuchFieldException, NoSuchMethodException { [EOL]         final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable") [EOL]                 .getGenericType(); [EOL]         final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, [EOL]                 iterableType); [EOL]         final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns [EOL]                 .get(treeSetTypeVar)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testDetermineTypeVariableAssignments() throws SecurityException, [EOL]             NoSuchFieldException, NoSuchMethodException { [EOL]         final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable") [EOL]                 .getGenericType(); [EOL]         final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, [EOL]                 iterableType); [EOL]         final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns [EOL]                 .get(treeSetTypeVar)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testDetermineTypeVariableAssignments() throws SecurityException, [EOL]             NoSuchFieldException, NoSuchMethodException { [EOL]         final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable") [EOL]                 .getGenericType(); [EOL]         final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, [EOL]                 iterableType); [EOL]         final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns [EOL]                 .get(treeSetTypeVar)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testDetermineTypeVariableAssignments() throws SecurityException, [EOL]             NoSuchFieldException, NoSuchMethodException { [EOL]         final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable") [EOL]                 .getGenericType(); [EOL]         final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, [EOL]                 iterableType); [EOL]         final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns [EOL]                 .get(treeSetTypeVar)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testDetermineTypeVariableAssignments() throws SecurityException, [EOL]             NoSuchFieldException, NoSuchMethodException { [EOL]         final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable") [EOL]                 .getGenericType(); [EOL]         final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, [EOL]                 iterableType); [EOL]         final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns [EOL]                 .get(treeSetTypeVar)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testDetermineTypeVariableAssignments() throws SecurityException, [EOL]             NoSuchFieldException, NoSuchMethodException { [EOL]         final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable") [EOL]                 .getGenericType(); [EOL]         final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, [EOL]                 iterableType); [EOL]         final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns [EOL]                 .get(treeSetTypeVar)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testDetermineTypeVariableAssignments() throws SecurityException, [EOL]             NoSuchFieldException, NoSuchMethodException { [EOL]         final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable") [EOL]                 .getGenericType(); [EOL]         final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, [EOL]                 iterableType); [EOL]         final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns [EOL]                 .get(treeSetTypeVar)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testDetermineTypeVariableAssignments() throws SecurityException, [EOL]             NoSuchFieldException, NoSuchMethodException { [EOL]         final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable") [EOL]                 .getGenericType(); [EOL]         final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, [EOL]                 iterableType); [EOL]         final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns [EOL]                 .get(treeSetTypeVar)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testDetermineTypeVariableAssignments() throws SecurityException, [EOL]             NoSuchFieldException, NoSuchMethodException { [EOL]         final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable") [EOL]                 .getGenericType(); [EOL]         final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, [EOL]                 iterableType); [EOL]         final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns [EOL]                 .get(treeSetTypeVar)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testDetermineTypeVariableAssignments() throws SecurityException, [EOL]             NoSuchFieldException, NoSuchMethodException { [EOL]         final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable") [EOL]                 .getGenericType(); [EOL]         final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, [EOL]                 iterableType); [EOL]         final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns [EOL]                 .get(treeSetTypeVar)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testDetermineTypeVariableAssignments() throws SecurityException, [EOL]             NoSuchFieldException, NoSuchMethodException { [EOL]         final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable") [EOL]                 .getGenericType(); [EOL]         final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, [EOL]                 iterableType); [EOL]         final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns [EOL]                 .get(treeSetTypeVar)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testDetermineTypeVariableAssignments() throws SecurityException, [EOL]             NoSuchFieldException, NoSuchMethodException { [EOL]         final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable") [EOL]                 .getGenericType(); [EOL]         final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, [EOL]                 iterableType); [EOL]         final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns [EOL]                 .get(treeSetTypeVar)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testDetermineTypeVariableAssignments() throws SecurityException, [EOL]             NoSuchFieldException, NoSuchMethodException { [EOL]         final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable") [EOL]                 .getGenericType(); [EOL]         final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, [EOL]                 iterableType); [EOL]         final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns [EOL]                 .get(treeSetTypeVar)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetTypeArguments() { [EOL]         Map<TypeVariable<?>, Type> typeVarAssigns; [EOL]         TypeVariable<?> treeSetTypeVar; [EOL]         Type typeArg; [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Integer.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from Integer: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]         Assert.assertEquals("Type argument of Comparable from Integer: " + typeArg, Integer.class, [EOL]                 typeVarAssigns.get(treeSetTypeVar)); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(int.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from int: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]         Assert.assertEquals("Type argument of Comparable from int: " + typeArg, Integer.class, [EOL]                 typeVarAssigns.get(treeSetTypeVar)); [EOL]  [EOL]         final Collection<Integer> col = Arrays.asList(new Integer[0]); [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(List.class, Collection.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertFalse("Type var assigns for Collection from List: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(AAAClass.BBBClass.class, AAClass.BBClass.class); [EOL]         Assert.assertTrue(typeVarAssigns.size() == 2); [EOL]         Assert.assertEquals(String.class, typeVarAssigns.get(AAClass.class.getTypeParameters()[0])); [EOL]         Assert.assertEquals(String.class, typeVarAssigns.get(AAClass.BBClass.class.getTypeParameters()[0])); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Other.class, This.class); [EOL]         Assert.assertEquals(2, typeVarAssigns.size()); [EOL]         Assert.assertEquals(String.class, typeVarAssigns.get(This.class.getTypeParameters()[0])); [EOL]         Assert.assertEquals(Other.class.getTypeParameters()[0], typeVarAssigns.get(This.class.getTypeParameters()[1])); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(And.class, This.class); [EOL]         Assert.assertEquals(2, typeVarAssigns.size()); [EOL]         Assert.assertEquals(Number.class, typeVarAssigns.get(This.class.getTypeParameters()[0])); [EOL]         Assert.assertEquals(Number.class, typeVarAssigns.get(This.class.getTypeParameters()[1])); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Thing.class, Other.class); [EOL]         Assert.assertEquals(2, typeVarAssigns.size()); [EOL]         Assert.assertEquals(getClass().getTypeParameters()[0], typeVarAssigns.get(getClass().getTypeParameters()[0])); [EOL]         Assert.assertEquals(getClass().getTypeParameters()[0], typeVarAssigns.get(Other.class.getTypeParameters()[0])); [EOL]     } [EOL]  [EOL] //
@Test [EOL]     public void testGetTypeArguments() { [EOL]         Map<TypeVariable<?>, Type> typeVarAssigns; [EOL]         TypeVariable<?> treeSetTypeVar; [EOL]         Type typeArg; [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Integer.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from Integer: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]         Assert.assertEquals("Type argument of Comparable from Integer: " + typeArg, Integer.class, [EOL]                 typeVarAssigns.get(treeSetTypeVar)); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(int.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from int: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]         Assert.assertEquals("Type argument of Comparable from int: " + typeArg, Integer.class, [EOL]                 typeVarAssigns.get(treeSetTypeVar)); [EOL]  [EOL]         final Collection<Integer> col = Arrays.asList(new Integer[0]); [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(List.class, Collection.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertFalse("Type var assigns for Collection from List: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(AAAClass.BBBClass.class, AAClass.BBClass.class); [EOL]         Assert.assertTrue(typeVarAssigns.size() == 2); [EOL]         Assert.assertEquals(String.class, typeVarAssigns.get(AAClass.class.getTypeParameters()[0])); [EOL]         Assert.assertEquals(String.class, typeVarAssigns.get(AAClass.BBClass.class.getTypeParameters()[0])); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Other.class, This.class); [EOL]         Assert.assertEquals(2, typeVarAssigns.size()); [EOL]         Assert.assertEquals(String.class, typeVarAssigns.get(This.class.getTypeParameters()[0])); [EOL]         Assert.assertEquals(Other.class.getTypeParameters()[0], typeVarAssigns.get(This.class.getTypeParameters()[1])); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(And.class, This.class); [EOL]         Assert.assertEquals(2, typeVarAssigns.size()); [EOL]         Assert.assertEquals(Number.class, typeVarAssigns.get(This.class.getTypeParameters()[0])); [EOL]         Assert.assertEquals(Number.class, typeVarAssigns.get(This.class.getTypeParameters()[1])); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Thing.class, Other.class); [EOL]         Assert.assertEquals(2, typeVarAssigns.size()); [EOL]         Assert.assertEquals(getClass().getTypeParameters()[0], typeVarAssigns.get(getClass().getTypeParameters()[0])); [EOL]         Assert.assertEquals(getClass().getTypeParameters()[0], typeVarAssigns.get(Other.class.getTypeParameters()[0])); [EOL]     } [EOL]  [EOL] //
@Test [EOL]     public void testGetTypeArguments() { [EOL]         Map<TypeVariable<?>, Type> typeVarAssigns; [EOL]         TypeVariable<?> treeSetTypeVar; [EOL]         Type typeArg; [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Integer.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from Integer: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]         Assert.assertEquals("Type argument of Comparable from Integer: " + typeArg, Integer.class, [EOL]                 typeVarAssigns.get(treeSetTypeVar)); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(int.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from int: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]         Assert.assertEquals("Type argument of Comparable from int: " + typeArg, Integer.class, [EOL]                 typeVarAssigns.get(treeSetTypeVar)); [EOL]  [EOL]         final Collection<Integer> col = Arrays.asList(new Integer[0]); [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(List.class, Collection.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertFalse("Type var assigns for Collection from List: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(AAAClass.BBBClass.class, AAClass.BBClass.class); [EOL]         Assert.assertTrue(typeVarAssigns.size() == 2); [EOL]         Assert.assertEquals(String.class, typeVarAssigns.get(AAClass.class.getTypeParameters()[0])); [EOL]         Assert.assertEquals(String.class, typeVarAssigns.get(AAClass.BBClass.class.getTypeParameters()[0])); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Other.class, This.class); [EOL]         Assert.assertEquals(2, typeVarAssigns.size()); [EOL]         Assert.assertEquals(String.class, typeVarAssigns.get(This.class.getTypeParameters()[0])); [EOL]         Assert.assertEquals(Other.class.getTypeParameters()[0], typeVarAssigns.get(This.class.getTypeParameters()[1])); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(And.class, This.class); [EOL]         Assert.assertEquals(2, typeVarAssigns.size()); [EOL]         Assert.assertEquals(Number.class, typeVarAssigns.get(This.class.getTypeParameters()[0])); [EOL]         Assert.assertEquals(Number.class, typeVarAssigns.get(This.class.getTypeParameters()[1])); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Thing.class, Other.class); [EOL]         Assert.assertEquals(2, typeVarAssigns.size()); [EOL]         Assert.assertEquals(getClass().getTypeParameters()[0], typeVarAssigns.get(getClass().getTypeParameters()[0])); [EOL]         Assert.assertEquals(getClass().getTypeParameters()[0], typeVarAssigns.get(Other.class.getTypeParameters()[0])); [EOL]     } [EOL]  [EOL] //
@Test [EOL]     public void testGetTypeArguments() { [EOL]         Map<TypeVariable<?>, Type> typeVarAssigns; [EOL]         TypeVariable<?> treeSetTypeVar; [EOL]         Type typeArg; [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Integer.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from Integer: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]         Assert.assertEquals("Type argument of Comparable from Integer: " + typeArg, Integer.class, [EOL]                 typeVarAssigns.get(treeSetTypeVar)); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(int.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from int: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]         Assert.assertEquals("Type argument of Comparable from int: " + typeArg, Integer.class, [EOL]                 typeVarAssigns.get(treeSetTypeVar)); [EOL]  [EOL]         final Collection<Integer> col = Arrays.asList(new Integer[0]); [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(List.class, Collection.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertFalse("Type var assigns for Collection from List: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(AAAClass.BBBClass.class, AAClass.BBClass.class); [EOL]         Assert.assertTrue(typeVarAssigns.size() == 2); [EOL]         Assert.assertEquals(String.class, typeVarAssigns.get(AAClass.class.getTypeParameters()[0])); [EOL]         Assert.assertEquals(String.class, typeVarAssigns.get(AAClass.BBClass.class.getTypeParameters()[0])); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Other.class, This.class); [EOL]         Assert.assertEquals(2, typeVarAssigns.size()); [EOL]         Assert.assertEquals(String.class, typeVarAssigns.get(This.class.getTypeParameters()[0])); [EOL]         Assert.assertEquals(Other.class.getTypeParameters()[0], typeVarAssigns.get(This.class.getTypeParameters()[1])); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(And.class, This.class); [EOL]         Assert.assertEquals(2, typeVarAssigns.size()); [EOL]         Assert.assertEquals(Number.class, typeVarAssigns.get(This.class.getTypeParameters()[0])); [EOL]         Assert.assertEquals(Number.class, typeVarAssigns.get(This.class.getTypeParameters()[1])); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Thing.class, Other.class); [EOL]         Assert.assertEquals(2, typeVarAssigns.size()); [EOL]         Assert.assertEquals(getClass().getTypeParameters()[0], typeVarAssigns.get(getClass().getTypeParameters()[0])); [EOL]         Assert.assertEquals(getClass().getTypeParameters()[0], typeVarAssigns.get(Other.class.getTypeParameters()[0])); [EOL]     } [EOL]  [EOL] //
@Test [EOL]     public void testGetTypeArguments() { [EOL]         Map<TypeVariable<?>, Type> typeVarAssigns; [EOL]         TypeVariable<?> treeSetTypeVar; [EOL]         Type typeArg; [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Integer.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from Integer: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]         Assert.assertEquals("Type argument of Comparable from Integer: " + typeArg, Integer.class, [EOL]                 typeVarAssigns.get(treeSetTypeVar)); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(int.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from int: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]         Assert.assertEquals("Type argument of Comparable from int: " + typeArg, Integer.class, [EOL]                 typeVarAssigns.get(treeSetTypeVar)); [EOL]  [EOL]         final Collection<Integer> col = Arrays.asList(new Integer[0]); [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(List.class, Collection.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertFalse("Type var assigns for Collection from List: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(AAAClass.BBBClass.class, AAClass.BBClass.class); [EOL]         Assert.assertTrue(typeVarAssigns.size() == 2); [EOL]         Assert.assertEquals(String.class, typeVarAssigns.get(AAClass.class.getTypeParameters()[0])); [EOL]         Assert.assertEquals(String.class, typeVarAssigns.get(AAClass.BBClass.class.getTypeParameters()[0])); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Other.class, This.class); [EOL]         Assert.assertEquals(2, typeVarAssigns.size()); [EOL]         Assert.assertEquals(String.class, typeVarAssigns.get(This.class.getTypeParameters()[0])); [EOL]         Assert.assertEquals(Other.class.getTypeParameters()[0], typeVarAssigns.get(This.class.getTypeParameters()[1])); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(And.class, This.class); [EOL]         Assert.assertEquals(2, typeVarAssigns.size()); [EOL]         Assert.assertEquals(Number.class, typeVarAssigns.get(This.class.getTypeParameters()[0])); [EOL]         Assert.assertEquals(Number.class, typeVarAssigns.get(This.class.getTypeParameters()[1])); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Thing.class, Other.class); [EOL]         Assert.assertEquals(2, typeVarAssigns.size()); [EOL]         Assert.assertEquals(getClass().getTypeParameters()[0], typeVarAssigns.get(getClass().getTypeParameters()[0])); [EOL]         Assert.assertEquals(getClass().getTypeParameters()[0], typeVarAssigns.get(Other.class.getTypeParameters()[0])); [EOL]     } [EOL]  [EOL] //
@Test [EOL]     public void testGetTypeArguments() { [EOL]         Map<TypeVariable<?>, Type> typeVarAssigns; [EOL]         TypeVariable<?> treeSetTypeVar; [EOL]         Type typeArg; [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Integer.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from Integer: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]         Assert.assertEquals("Type argument of Comparable from Integer: " + typeArg, Integer.class, [EOL]                 typeVarAssigns.get(treeSetTypeVar)); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(int.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from int: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]         Assert.assertEquals("Type argument of Comparable from int: " + typeArg, Integer.class, [EOL]                 typeVarAssigns.get(treeSetTypeVar)); [EOL]  [EOL]         final Collection<Integer> col = Arrays.asList(new Integer[0]); [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(List.class, Collection.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertFalse("Type var assigns for Collection from List: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(AAAClass.BBBClass.class, AAClass.BBClass.class); [EOL]         Assert.assertTrue(typeVarAssigns.size() == 2); [EOL]         Assert.assertEquals(String.class, typeVarAssigns.get(AAClass.class.getTypeParameters()[0])); [EOL]         Assert.assertEquals(String.class, typeVarAssigns.get(AAClass.BBClass.class.getTypeParameters()[0])); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Other.class, This.class); [EOL]         Assert.assertEquals(2, typeVarAssigns.size()); [EOL]         Assert.assertEquals(String.class, typeVarAssigns.get(This.class.getTypeParameters()[0])); [EOL]         Assert.assertEquals(Other.class.getTypeParameters()[0], typeVarAssigns.get(This.class.getTypeParameters()[1])); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(And.class, This.class); [EOL]         Assert.assertEquals(2, typeVarAssigns.size()); [EOL]         Assert.assertEquals(Number.class, typeVarAssigns.get(This.class.getTypeParameters()[0])); [EOL]         Assert.assertEquals(Number.class, typeVarAssigns.get(This.class.getTypeParameters()[1])); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Thing.class, Other.class); [EOL]         Assert.assertEquals(2, typeVarAssigns.size()); [EOL]         Assert.assertEquals(getClass().getTypeParameters()[0], typeVarAssigns.get(getClass().getTypeParameters()[0])); [EOL]         Assert.assertEquals(getClass().getTypeParameters()[0], typeVarAssigns.get(Other.class.getTypeParameters()[0])); [EOL]     } [EOL]  [EOL] //
@Test [EOL]     public void testDetermineTypeVariableAssignments() throws SecurityException, [EOL]             NoSuchFieldException, NoSuchMethodException { [EOL]         final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable") [EOL]                 .getGenericType(); [EOL]         final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, [EOL]                 iterableType); [EOL]         final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns [EOL]                 .get(treeSetTypeVar)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testDetermineTypeVariableAssignments() throws SecurityException, [EOL]             NoSuchFieldException, NoSuchMethodException { [EOL]         final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable") [EOL]                 .getGenericType(); [EOL]         final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, [EOL]                 iterableType); [EOL]         final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns [EOL]                 .get(treeSetTypeVar)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetTypeArguments() { [EOL]         Map<TypeVariable<?>, Type> typeVarAssigns; [EOL]         TypeVariable<?> treeSetTypeVar; [EOL]         Type typeArg; [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Integer.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from Integer: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]         Assert.assertEquals("Type argument of Comparable from Integer: " + typeArg, Integer.class, [EOL]                 typeVarAssigns.get(treeSetTypeVar)); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(int.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from int: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]         Assert.assertEquals("Type argument of Comparable from int: " + typeArg, Integer.class, [EOL]                 typeVarAssigns.get(treeSetTypeVar)); [EOL]  [EOL]         final Collection<Integer> col = Arrays.asList(new Integer[0]); [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(List.class, Collection.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertFalse("Type var assigns for Collection from List: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(AAAClass.BBBClass.class, AAClass.BBClass.class); [EOL]         Assert.assertTrue(typeVarAssigns.size() == 2); [EOL]         Assert.assertEquals(String.class, typeVarAssigns.get(AAClass.class.getTypeParameters()[0])); [EOL]         Assert.assertEquals(String.class, typeVarAssigns.get(AAClass.BBClass.class.getTypeParameters()[0])); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Other.class, This.class); [EOL]         Assert.assertEquals(2, typeVarAssigns.size()); [EOL]         Assert.assertEquals(String.class, typeVarAssigns.get(This.class.getTypeParameters()[0])); [EOL]         Assert.assertEquals(Other.class.getTypeParameters()[0], typeVarAssigns.get(This.class.getTypeParameters()[1])); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(And.class, This.class); [EOL]         Assert.assertEquals(2, typeVarAssigns.size()); [EOL]         Assert.assertEquals(Number.class, typeVarAssigns.get(This.class.getTypeParameters()[0])); [EOL]         Assert.assertEquals(Number.class, typeVarAssigns.get(This.class.getTypeParameters()[1])); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Thing.class, Other.class); [EOL]         Assert.assertEquals(2, typeVarAssigns.size()); [EOL]         Assert.assertEquals(getClass().getTypeParameters()[0], typeVarAssigns.get(getClass().getTypeParameters()[0])); [EOL]         Assert.assertEquals(getClass().getTypeParameters()[0], typeVarAssigns.get(Other.class.getTypeParameters()[0])); [EOL]     } [EOL]  [EOL] //
@Test [EOL]     public void testGetTypeArguments() { [EOL]         Map<TypeVariable<?>, Type> typeVarAssigns; [EOL]         TypeVariable<?> treeSetTypeVar; [EOL]         Type typeArg; [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Integer.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from Integer: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]         Assert.assertEquals("Type argument of Comparable from Integer: " + typeArg, Integer.class, [EOL]                 typeVarAssigns.get(treeSetTypeVar)); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(int.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from int: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]         Assert.assertEquals("Type argument of Comparable from int: " + typeArg, Integer.class, [EOL]                 typeVarAssigns.get(treeSetTypeVar)); [EOL]  [EOL]         final Collection<Integer> col = Arrays.asList(new Integer[0]); [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(List.class, Collection.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertFalse("Type var assigns for Collection from List: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(AAAClass.BBBClass.class, AAClass.BBClass.class); [EOL]         Assert.assertTrue(typeVarAssigns.size() == 2); [EOL]         Assert.assertEquals(String.class, typeVarAssigns.get(AAClass.class.getTypeParameters()[0])); [EOL]         Assert.assertEquals(String.class, typeVarAssigns.get(AAClass.BBClass.class.getTypeParameters()[0])); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Other.class, This.class); [EOL]         Assert.assertEquals(2, typeVarAssigns.size()); [EOL]         Assert.assertEquals(String.class, typeVarAssigns.get(This.class.getTypeParameters()[0])); [EOL]         Assert.assertEquals(Other.class.getTypeParameters()[0], typeVarAssigns.get(This.class.getTypeParameters()[1])); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(And.class, This.class); [EOL]         Assert.assertEquals(2, typeVarAssigns.size()); [EOL]         Assert.assertEquals(Number.class, typeVarAssigns.get(This.class.getTypeParameters()[0])); [EOL]         Assert.assertEquals(Number.class, typeVarAssigns.get(This.class.getTypeParameters()[1])); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Thing.class, Other.class); [EOL]         Assert.assertEquals(2, typeVarAssigns.size()); [EOL]         Assert.assertEquals(getClass().getTypeParameters()[0], typeVarAssigns.get(getClass().getTypeParameters()[0])); [EOL]         Assert.assertEquals(getClass().getTypeParameters()[0], typeVarAssigns.get(Other.class.getTypeParameters()[0])); [EOL]     } [EOL]  [EOL] //
@Test [EOL]     public void testGetTypeArguments() { [EOL]         Map<TypeVariable<?>, Type> typeVarAssigns; [EOL]         TypeVariable<?> treeSetTypeVar; [EOL]         Type typeArg; [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Integer.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from Integer: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]         Assert.assertEquals("Type argument of Comparable from Integer: " + typeArg, Integer.class, [EOL]                 typeVarAssigns.get(treeSetTypeVar)); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(int.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from int: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]         Assert.assertEquals("Type argument of Comparable from int: " + typeArg, Integer.class, [EOL]                 typeVarAssigns.get(treeSetTypeVar)); [EOL]  [EOL]         final Collection<Integer> col = Arrays.asList(new Integer[0]); [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(List.class, Collection.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertFalse("Type var assigns for Collection from List: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(AAAClass.BBBClass.class, AAClass.BBClass.class); [EOL]         Assert.assertTrue(typeVarAssigns.size() == 2); [EOL]         Assert.assertEquals(String.class, typeVarAssigns.get(AAClass.class.getTypeParameters()[0])); [EOL]         Assert.assertEquals(String.class, typeVarAssigns.get(AAClass.BBClass.class.getTypeParameters()[0])); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Other.class, This.class); [EOL]         Assert.assertEquals(2, typeVarAssigns.size()); [EOL]         Assert.assertEquals(String.class, typeVarAssigns.get(This.class.getTypeParameters()[0])); [EOL]         Assert.assertEquals(Other.class.getTypeParameters()[0], typeVarAssigns.get(This.class.getTypeParameters()[1])); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(And.class, This.class); [EOL]         Assert.assertEquals(2, typeVarAssigns.size()); [EOL]         Assert.assertEquals(Number.class, typeVarAssigns.get(This.class.getTypeParameters()[0])); [EOL]         Assert.assertEquals(Number.class, typeVarAssigns.get(This.class.getTypeParameters()[1])); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Thing.class, Other.class); [EOL]         Assert.assertEquals(2, typeVarAssigns.size()); [EOL]         Assert.assertEquals(getClass().getTypeParameters()[0], typeVarAssigns.get(getClass().getTypeParameters()[0])); [EOL]         Assert.assertEquals(getClass().getTypeParameters()[0], typeVarAssigns.get(Other.class.getTypeParameters()[0])); [EOL]     } [EOL]  [EOL] //
@Test [EOL]     public void testGetTypeArguments() { [EOL]         Map<TypeVariable<?>, Type> typeVarAssigns; [EOL]         TypeVariable<?> treeSetTypeVar; [EOL]         Type typeArg; [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Integer.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from Integer: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]         Assert.assertEquals("Type argument of Comparable from Integer: " + typeArg, Integer.class, [EOL]                 typeVarAssigns.get(treeSetTypeVar)); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(int.class, Comparable.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue("Type var assigns for Comparable from int: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         typeArg = typeVarAssigns.get(treeSetTypeVar); [EOL]         Assert.assertEquals("Type argument of Comparable from int: " + typeArg, Integer.class, [EOL]                 typeVarAssigns.get(treeSetTypeVar)); [EOL]  [EOL]         final Collection<Integer> col = Arrays.asList(new Integer[0]); [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(List.class, Collection.class); [EOL]         treeSetTypeVar = Comparable.class.getTypeParameters()[0]; [EOL]         Assert.assertFalse("Type var assigns for Collection from List: " + typeVarAssigns, [EOL]                 typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(AAAClass.BBBClass.class, AAClass.BBClass.class); [EOL]         Assert.assertTrue(typeVarAssigns.size() == 2); [EOL]         Assert.assertEquals(String.class, typeVarAssigns.get(AAClass.class.getTypeParameters()[0])); [EOL]         Assert.assertEquals(String.class, typeVarAssigns.get(AAClass.BBClass.class.getTypeParameters()[0])); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Other.class, This.class); [EOL]         Assert.assertEquals(2, typeVarAssigns.size()); [EOL]         Assert.assertEquals(String.class, typeVarAssigns.get(This.class.getTypeParameters()[0])); [EOL]         Assert.assertEquals(Other.class.getTypeParameters()[0], typeVarAssigns.get(This.class.getTypeParameters()[1])); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(And.class, This.class); [EOL]         Assert.assertEquals(2, typeVarAssigns.size()); [EOL]         Assert.assertEquals(Number.class, typeVarAssigns.get(This.class.getTypeParameters()[0])); [EOL]         Assert.assertEquals(Number.class, typeVarAssigns.get(This.class.getTypeParameters()[1])); [EOL]  [EOL]         typeVarAssigns = TypeUtils.getTypeArguments(Thing.class, Other.class); [EOL]         Assert.assertEquals(2, typeVarAssigns.size()); [EOL]         Assert.assertEquals(getClass().getTypeParameters()[0], typeVarAssigns.get(getClass().getTypeParameters()[0])); [EOL]         Assert.assertEquals(getClass().getTypeParameters()[0], typeVarAssigns.get(Other.class.getTypeParameters()[0])); [EOL]     } [EOL]  [EOL] //
@Test [EOL]     public void testGetRawType() throws SecurityException, NoSuchFieldException { [EOL]         final Type stringParentFieldType = GenericTypeHolder.class.getDeclaredField("stringParent") [EOL]                 .getGenericType(); [EOL]         final Type integerParentFieldType = GenericTypeHolder.class.getDeclaredField("integerParent") [EOL]                 .getGenericType(); [EOL]         final Type foosFieldType = GenericTypeHolder.class.getDeclaredField("foos").getGenericType(); [EOL]         final Type genericParentT = GenericParent.class.getTypeParameters()[0]; [EOL]         Assert.assertEquals(GenericParent.class, TypeUtils.getRawType(stringParentFieldType, null)); [EOL]         Assert [EOL]                 .assertEquals(GenericParent.class, TypeUtils.getRawType(integerParentFieldType, [EOL]                         null)); [EOL]         Assert.assertEquals(List.class, TypeUtils.getRawType(foosFieldType, null)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 StringParameterizedChild.class)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 stringParentFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(Iterable.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(List.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertNull(TypeUtils.getRawType(genericParentT, GenericParent.class)); [EOL]         Assert.assertEquals(GenericParent[].class, TypeUtils.getRawType(GenericTypeHolder.class [EOL]                 .getDeclaredField("barParents").getGenericType(), null)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetRawType() throws SecurityException, NoSuchFieldException { [EOL]         final Type stringParentFieldType = GenericTypeHolder.class.getDeclaredField("stringParent") [EOL]                 .getGenericType(); [EOL]         final Type integerParentFieldType = GenericTypeHolder.class.getDeclaredField("integerParent") [EOL]                 .getGenericType(); [EOL]         final Type foosFieldType = GenericTypeHolder.class.getDeclaredField("foos").getGenericType(); [EOL]         final Type genericParentT = GenericParent.class.getTypeParameters()[0]; [EOL]         Assert.assertEquals(GenericParent.class, TypeUtils.getRawType(stringParentFieldType, null)); [EOL]         Assert [EOL]                 .assertEquals(GenericParent.class, TypeUtils.getRawType(integerParentFieldType, [EOL]                         null)); [EOL]         Assert.assertEquals(List.class, TypeUtils.getRawType(foosFieldType, null)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 StringParameterizedChild.class)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 stringParentFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(Iterable.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(List.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertNull(TypeUtils.getRawType(genericParentT, GenericParent.class)); [EOL]         Assert.assertEquals(GenericParent[].class, TypeUtils.getRawType(GenericTypeHolder.class [EOL]                 .getDeclaredField("barParents").getGenericType(), null)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetRawType() throws SecurityException, NoSuchFieldException { [EOL]         final Type stringParentFieldType = GenericTypeHolder.class.getDeclaredField("stringParent") [EOL]                 .getGenericType(); [EOL]         final Type integerParentFieldType = GenericTypeHolder.class.getDeclaredField("integerParent") [EOL]                 .getGenericType(); [EOL]         final Type foosFieldType = GenericTypeHolder.class.getDeclaredField("foos").getGenericType(); [EOL]         final Type genericParentT = GenericParent.class.getTypeParameters()[0]; [EOL]         Assert.assertEquals(GenericParent.class, TypeUtils.getRawType(stringParentFieldType, null)); [EOL]         Assert [EOL]                 .assertEquals(GenericParent.class, TypeUtils.getRawType(integerParentFieldType, [EOL]                         null)); [EOL]         Assert.assertEquals(List.class, TypeUtils.getRawType(foosFieldType, null)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 StringParameterizedChild.class)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 stringParentFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(Iterable.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(List.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertNull(TypeUtils.getRawType(genericParentT, GenericParent.class)); [EOL]         Assert.assertEquals(GenericParent[].class, TypeUtils.getRawType(GenericTypeHolder.class [EOL]                 .getDeclaredField("barParents").getGenericType(), null)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetRawType() throws SecurityException, NoSuchFieldException { [EOL]         final Type stringParentFieldType = GenericTypeHolder.class.getDeclaredField("stringParent") [EOL]                 .getGenericType(); [EOL]         final Type integerParentFieldType = GenericTypeHolder.class.getDeclaredField("integerParent") [EOL]                 .getGenericType(); [EOL]         final Type foosFieldType = GenericTypeHolder.class.getDeclaredField("foos").getGenericType(); [EOL]         final Type genericParentT = GenericParent.class.getTypeParameters()[0]; [EOL]         Assert.assertEquals(GenericParent.class, TypeUtils.getRawType(stringParentFieldType, null)); [EOL]         Assert [EOL]                 .assertEquals(GenericParent.class, TypeUtils.getRawType(integerParentFieldType, [EOL]                         null)); [EOL]         Assert.assertEquals(List.class, TypeUtils.getRawType(foosFieldType, null)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 StringParameterizedChild.class)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 stringParentFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(Iterable.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(List.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertNull(TypeUtils.getRawType(genericParentT, GenericParent.class)); [EOL]         Assert.assertEquals(GenericParent[].class, TypeUtils.getRawType(GenericTypeHolder.class [EOL]                 .getDeclaredField("barParents").getGenericType(), null)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetRawType() throws SecurityException, NoSuchFieldException { [EOL]         final Type stringParentFieldType = GenericTypeHolder.class.getDeclaredField("stringParent") [EOL]                 .getGenericType(); [EOL]         final Type integerParentFieldType = GenericTypeHolder.class.getDeclaredField("integerParent") [EOL]                 .getGenericType(); [EOL]         final Type foosFieldType = GenericTypeHolder.class.getDeclaredField("foos").getGenericType(); [EOL]         final Type genericParentT = GenericParent.class.getTypeParameters()[0]; [EOL]         Assert.assertEquals(GenericParent.class, TypeUtils.getRawType(stringParentFieldType, null)); [EOL]         Assert [EOL]                 .assertEquals(GenericParent.class, TypeUtils.getRawType(integerParentFieldType, [EOL]                         null)); [EOL]         Assert.assertEquals(List.class, TypeUtils.getRawType(foosFieldType, null)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 StringParameterizedChild.class)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 stringParentFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(Iterable.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(List.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertNull(TypeUtils.getRawType(genericParentT, GenericParent.class)); [EOL]         Assert.assertEquals(GenericParent[].class, TypeUtils.getRawType(GenericTypeHolder.class [EOL]                 .getDeclaredField("barParents").getGenericType(), null)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetRawType() throws SecurityException, NoSuchFieldException { [EOL]         final Type stringParentFieldType = GenericTypeHolder.class.getDeclaredField("stringParent") [EOL]                 .getGenericType(); [EOL]         final Type integerParentFieldType = GenericTypeHolder.class.getDeclaredField("integerParent") [EOL]                 .getGenericType(); [EOL]         final Type foosFieldType = GenericTypeHolder.class.getDeclaredField("foos").getGenericType(); [EOL]         final Type genericParentT = GenericParent.class.getTypeParameters()[0]; [EOL]         Assert.assertEquals(GenericParent.class, TypeUtils.getRawType(stringParentFieldType, null)); [EOL]         Assert [EOL]                 .assertEquals(GenericParent.class, TypeUtils.getRawType(integerParentFieldType, [EOL]                         null)); [EOL]         Assert.assertEquals(List.class, TypeUtils.getRawType(foosFieldType, null)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 StringParameterizedChild.class)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 stringParentFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(Iterable.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(List.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertNull(TypeUtils.getRawType(genericParentT, GenericParent.class)); [EOL]         Assert.assertEquals(GenericParent[].class, TypeUtils.getRawType(GenericTypeHolder.class [EOL]                 .getDeclaredField("barParents").getGenericType(), null)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetRawType() throws SecurityException, NoSuchFieldException { [EOL]         final Type stringParentFieldType = GenericTypeHolder.class.getDeclaredField("stringParent") [EOL]                 .getGenericType(); [EOL]         final Type integerParentFieldType = GenericTypeHolder.class.getDeclaredField("integerParent") [EOL]                 .getGenericType(); [EOL]         final Type foosFieldType = GenericTypeHolder.class.getDeclaredField("foos").getGenericType(); [EOL]         final Type genericParentT = GenericParent.class.getTypeParameters()[0]; [EOL]         Assert.assertEquals(GenericParent.class, TypeUtils.getRawType(stringParentFieldType, null)); [EOL]         Assert [EOL]                 .assertEquals(GenericParent.class, TypeUtils.getRawType(integerParentFieldType, [EOL]                         null)); [EOL]         Assert.assertEquals(List.class, TypeUtils.getRawType(foosFieldType, null)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 StringParameterizedChild.class)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 stringParentFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(Iterable.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(List.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertNull(TypeUtils.getRawType(genericParentT, GenericParent.class)); [EOL]         Assert.assertEquals(GenericParent[].class, TypeUtils.getRawType(GenericTypeHolder.class [EOL]                 .getDeclaredField("barParents").getGenericType(), null)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetRawType() throws SecurityException, NoSuchFieldException { [EOL]         final Type stringParentFieldType = GenericTypeHolder.class.getDeclaredField("stringParent") [EOL]                 .getGenericType(); [EOL]         final Type integerParentFieldType = GenericTypeHolder.class.getDeclaredField("integerParent") [EOL]                 .getGenericType(); [EOL]         final Type foosFieldType = GenericTypeHolder.class.getDeclaredField("foos").getGenericType(); [EOL]         final Type genericParentT = GenericParent.class.getTypeParameters()[0]; [EOL]         Assert.assertEquals(GenericParent.class, TypeUtils.getRawType(stringParentFieldType, null)); [EOL]         Assert [EOL]                 .assertEquals(GenericParent.class, TypeUtils.getRawType(integerParentFieldType, [EOL]                         null)); [EOL]         Assert.assertEquals(List.class, TypeUtils.getRawType(foosFieldType, null)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 StringParameterizedChild.class)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 stringParentFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(Iterable.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(List.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertNull(TypeUtils.getRawType(genericParentT, GenericParent.class)); [EOL]         Assert.assertEquals(GenericParent[].class, TypeUtils.getRawType(GenericTypeHolder.class [EOL]                 .getDeclaredField("barParents").getGenericType(), null)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetRawType() throws SecurityException, NoSuchFieldException { [EOL]         final Type stringParentFieldType = GenericTypeHolder.class.getDeclaredField("stringParent") [EOL]                 .getGenericType(); [EOL]         final Type integerParentFieldType = GenericTypeHolder.class.getDeclaredField("integerParent") [EOL]                 .getGenericType(); [EOL]         final Type foosFieldType = GenericTypeHolder.class.getDeclaredField("foos").getGenericType(); [EOL]         final Type genericParentT = GenericParent.class.getTypeParameters()[0]; [EOL]         Assert.assertEquals(GenericParent.class, TypeUtils.getRawType(stringParentFieldType, null)); [EOL]         Assert [EOL]                 .assertEquals(GenericParent.class, TypeUtils.getRawType(integerParentFieldType, [EOL]                         null)); [EOL]         Assert.assertEquals(List.class, TypeUtils.getRawType(foosFieldType, null)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 StringParameterizedChild.class)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 stringParentFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(Iterable.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(List.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertNull(TypeUtils.getRawType(genericParentT, GenericParent.class)); [EOL]         Assert.assertEquals(GenericParent[].class, TypeUtils.getRawType(GenericTypeHolder.class [EOL]                 .getDeclaredField("barParents").getGenericType(), null)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetRawType() throws SecurityException, NoSuchFieldException { [EOL]         final Type stringParentFieldType = GenericTypeHolder.class.getDeclaredField("stringParent") [EOL]                 .getGenericType(); [EOL]         final Type integerParentFieldType = GenericTypeHolder.class.getDeclaredField("integerParent") [EOL]                 .getGenericType(); [EOL]         final Type foosFieldType = GenericTypeHolder.class.getDeclaredField("foos").getGenericType(); [EOL]         final Type genericParentT = GenericParent.class.getTypeParameters()[0]; [EOL]         Assert.assertEquals(GenericParent.class, TypeUtils.getRawType(stringParentFieldType, null)); [EOL]         Assert [EOL]                 .assertEquals(GenericParent.class, TypeUtils.getRawType(integerParentFieldType, [EOL]                         null)); [EOL]         Assert.assertEquals(List.class, TypeUtils.getRawType(foosFieldType, null)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 StringParameterizedChild.class)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 stringParentFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(Iterable.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(List.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertNull(TypeUtils.getRawType(genericParentT, GenericParent.class)); [EOL]         Assert.assertEquals(GenericParent[].class, TypeUtils.getRawType(GenericTypeHolder.class [EOL]                 .getDeclaredField("barParents").getGenericType(), null)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetRawType() throws SecurityException, NoSuchFieldException { [EOL]         final Type stringParentFieldType = GenericTypeHolder.class.getDeclaredField("stringParent") [EOL]                 .getGenericType(); [EOL]         final Type integerParentFieldType = GenericTypeHolder.class.getDeclaredField("integerParent") [EOL]                 .getGenericType(); [EOL]         final Type foosFieldType = GenericTypeHolder.class.getDeclaredField("foos").getGenericType(); [EOL]         final Type genericParentT = GenericParent.class.getTypeParameters()[0]; [EOL]         Assert.assertEquals(GenericParent.class, TypeUtils.getRawType(stringParentFieldType, null)); [EOL]         Assert [EOL]                 .assertEquals(GenericParent.class, TypeUtils.getRawType(integerParentFieldType, [EOL]                         null)); [EOL]         Assert.assertEquals(List.class, TypeUtils.getRawType(foosFieldType, null)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 StringParameterizedChild.class)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 stringParentFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(Iterable.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(List.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertNull(TypeUtils.getRawType(genericParentT, GenericParent.class)); [EOL]         Assert.assertEquals(GenericParent[].class, TypeUtils.getRawType(GenericTypeHolder.class [EOL]                 .getDeclaredField("barParents").getGenericType(), null)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetArrayComponentType() throws Exception { [EOL]         final Method method = getClass().getMethod("dummyMethod", List.class, List.class, List.class, [EOL]                 List.class, List.class, List.class, List.class, List[].class, List[].class, [EOL]                 List[].class, List[].class, List[].class, List[].class, List[].class); [EOL]  [EOL]         final Type[] types = method.getGenericParameterTypes(); [EOL]  [EOL]         Assert.assertNull(TypeUtils.getArrayComponentType(types[0])); [EOL]         Assert.assertNull(TypeUtils.getArrayComponentType(types[1])); [EOL]         Assert.assertNull(TypeUtils.getArrayComponentType(types[2])); [EOL]         Assert.assertNull(TypeUtils.getArrayComponentType(types[3])); [EOL]         Assert.assertNull(TypeUtils.getArrayComponentType(types[4])); [EOL]         Assert.assertNull(TypeUtils.getArrayComponentType(types[5])); [EOL]         Assert.assertNull(TypeUtils.getArrayComponentType(types[6])); [EOL]         Assert.assertEquals(types[0], TypeUtils.getArrayComponentType(types[7])); [EOL]         Assert.assertEquals(types[1], TypeUtils.getArrayComponentType(types[8])); [EOL]         Assert.assertEquals(types[2], TypeUtils.getArrayComponentType(types[9])); [EOL]         Assert.assertEquals(types[3], TypeUtils.getArrayComponentType(types[10])); [EOL]         Assert.assertEquals(types[4], TypeUtils.getArrayComponentType(types[11])); [EOL]         Assert.assertEquals(types[5], TypeUtils.getArrayComponentType(types[12])); [EOL]         Assert.assertEquals(types[6], TypeUtils.getArrayComponentType(types[13])); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testUnfinishedEntity() { [EOL]         // parse it [EOL]         NumericEntityUnescaper neu = new NumericEntityUnescaper(NumericEntityUnescaper.OPTION.semiColonOptional); [EOL]         String input = "Test &#x30 not test"; [EOL]         String expected = "Test \u0030 not test"; [EOL]  [EOL]         String result = neu.translate(input); [EOL]         assertEquals("Failed to support unfinished entities (i.e. missing semi-colon)", expected, result); [EOL]  [EOL]         // ignore it [EOL]         neu = new NumericEntityUnescaper(); [EOL]         input = "Test &#x30 not test"; [EOL]         expected = input; [EOL]  [EOL]         result = neu.translate(input); [EOL]         assertEquals("Failed to ignore unfinished entities (i.e. missing semi-colon)", expected, result); [EOL]  [EOL]         // fail it [EOL]         neu = new NumericEntityUnescaper(NumericEntityUnescaper.OPTION.errorIfNoSemiColon); [EOL]         input = "Test &#x30 not test"; [EOL]  [EOL]         try { [EOL]             result = neu.translate(input); [EOL]             fail("IllegalArgumentException expected"); [EOL]         } catch(final IllegalArgumentException iae) { [EOL]             // expected [EOL]         } [EOL]     } [EOL]  [EOL] } [EOL]
@Test [EOL]     public void testUnfinishedEntity() { [EOL]         // parse it [EOL]         NumericEntityUnescaper neu = new NumericEntityUnescaper(NumericEntityUnescaper.OPTION.semiColonOptional); [EOL]         String input = "Test &#x30 not test"; [EOL]         String expected = "Test \u0030 not test"; [EOL]  [EOL]         String result = neu.translate(input); [EOL]         assertEquals("Failed to support unfinished entities (i.e. missing semi-colon)", expected, result); [EOL]  [EOL]         // ignore it [EOL]         neu = new NumericEntityUnescaper(); [EOL]         input = "Test &#x30 not test"; [EOL]         expected = input; [EOL]  [EOL]         result = neu.translate(input); [EOL]         assertEquals("Failed to ignore unfinished entities (i.e. missing semi-colon)", expected, result); [EOL]  [EOL]         // fail it [EOL]         neu = new NumericEntityUnescaper(NumericEntityUnescaper.OPTION.errorIfNoSemiColon); [EOL]         input = "Test &#x30 not test"; [EOL]  [EOL]         try { [EOL]             result = neu.translate(input); [EOL]             fail("IllegalArgumentException expected"); [EOL]         } catch(final IllegalArgumentException iae) { [EOL]             // expected [EOL]         } [EOL]     } [EOL]  [EOL] } [EOL]
@Test [EOL]     public void testUnfinishedEntity() { [EOL]         // parse it [EOL]         NumericEntityUnescaper neu = new NumericEntityUnescaper(NumericEntityUnescaper.OPTION.semiColonOptional); [EOL]         String input = "Test &#x30 not test"; [EOL]         String expected = "Test \u0030 not test"; [EOL]  [EOL]         String result = neu.translate(input); [EOL]         assertEquals("Failed to support unfinished entities (i.e. missing semi-colon)", expected, result); [EOL]  [EOL]         // ignore it [EOL]         neu = new NumericEntityUnescaper(); [EOL]         input = "Test &#x30 not test"; [EOL]         expected = input; [EOL]  [EOL]         result = neu.translate(input); [EOL]         assertEquals("Failed to ignore unfinished entities (i.e. missing semi-colon)", expected, result); [EOL]  [EOL]         // fail it [EOL]         neu = new NumericEntityUnescaper(NumericEntityUnescaper.OPTION.errorIfNoSemiColon); [EOL]         input = "Test &#x30 not test"; [EOL]  [EOL]         try { [EOL]             result = neu.translate(input); [EOL]             fail("IllegalArgumentException expected"); [EOL]         } catch(final IllegalArgumentException iae) { [EOL]             // expected [EOL]         } [EOL]     } [EOL]  [EOL] } [EOL]
@Test [EOL]     public void testOutOfBounds() { [EOL]         final NumericEntityUnescaper neu = new NumericEntityUnescaper(); [EOL]  [EOL]         assertEquals("Failed to ignore when last character is &", "Test &", neu.translate("Test &")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#", neu.translate("Test &#")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#x", neu.translate("Test &#x")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#X", neu.translate("Test &#X")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testOutOfBounds() { [EOL]         final NumericEntityUnescaper neu = new NumericEntityUnescaper(); [EOL]  [EOL]         assertEquals("Failed to ignore when last character is &", "Test &", neu.translate("Test &")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#", neu.translate("Test &#")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#x", neu.translate("Test &#x")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#X", neu.translate("Test &#X")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testOutOfBounds() { [EOL]         final NumericEntityUnescaper neu = new NumericEntityUnescaper(); [EOL]  [EOL]         assertEquals("Failed to ignore when last character is &", "Test &", neu.translate("Test &")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#", neu.translate("Test &#")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#x", neu.translate("Test &#x")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#X", neu.translate("Test &#X")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testOutOfBounds() { [EOL]         final NumericEntityUnescaper neu = new NumericEntityUnescaper(); [EOL]  [EOL]         assertEquals("Failed to ignore when last character is &", "Test &", neu.translate("Test &")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#", neu.translate("Test &#")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#x", neu.translate("Test &#x")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#X", neu.translate("Test &#X")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testOutOfBounds() { [EOL]         final NumericEntityUnescaper neu = new NumericEntityUnescaper(); [EOL]  [EOL]         assertEquals("Failed to ignore when last character is &", "Test &", neu.translate("Test &")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#", neu.translate("Test &#")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#x", neu.translate("Test &#x")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#X", neu.translate("Test &#X")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testOutOfBounds() { [EOL]         final NumericEntityUnescaper neu = new NumericEntityUnescaper(); [EOL]  [EOL]         assertEquals("Failed to ignore when last character is &", "Test &", neu.translate("Test &")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#", neu.translate("Test &#")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#x", neu.translate("Test &#x")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#X", neu.translate("Test &#X")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testOutOfBounds() { [EOL]         final NumericEntityUnescaper neu = new NumericEntityUnescaper(); [EOL]  [EOL]         assertEquals("Failed to ignore when last character is &", "Test &", neu.translate("Test &")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#", neu.translate("Test &#")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#x", neu.translate("Test &#x")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#X", neu.translate("Test &#X")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testOutOfBounds() { [EOL]         final NumericEntityUnescaper neu = new NumericEntityUnescaper(); [EOL]  [EOL]         assertEquals("Failed to ignore when last character is &", "Test &", neu.translate("Test &")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#", neu.translate("Test &#")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#x", neu.translate("Test &#x")); [EOL]         assertEquals("Failed to ignore when last character is &", "Test &#X", neu.translate("Test &#X")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSupplementaryUnescaping() { [EOL]         final NumericEntityUnescaper neu = new NumericEntityUnescaper(); [EOL]         final String input = "&#68642;"; [EOL]         final String expected = "\uD803\uDC22"; [EOL]  [EOL]         final String result = neu.translate(input); [EOL]         assertEquals("Failed to unescape numeric entities supplementary characters", expected, result); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSupplementaryUnescaping() { [EOL]         final NumericEntityUnescaper neu = new NumericEntityUnescaper(); [EOL]         final String input = "&#68642;"; [EOL]         final String expected = "\uD803\uDC22"; [EOL]  [EOL]         final String result = neu.translate(input); [EOL]         assertEquals("Failed to unescape numeric entities supplementary characters", expected, result); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSupplementaryUnescaping() { [EOL]         final NumericEntityUnescaper neu = new NumericEntityUnescaper(); [EOL]         final String input = "&#68642;"; [EOL]         final String expected = "\uD803\uDC22"; [EOL]  [EOL]         final String result = neu.translate(input); [EOL]         assertEquals("Failed to unescape numeric entities supplementary characters", expected, result); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSupplementaryUnescaping() { [EOL]         final NumericEntityUnescaper neu = new NumericEntityUnescaper(); [EOL]         final String input = "&#68642;"; [EOL]         final String expected = "\uD803\uDC22"; [EOL]  [EOL]         final String result = neu.translate(input); [EOL]         assertEquals("Failed to unescape numeric entities supplementary characters", expected, result); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSupplementaryUnescaping() { [EOL]         final NumericEntityUnescaper neu = new NumericEntityUnescaper(); [EOL]         final String input = "&#68642;"; [EOL]         final String expected = "\uD803\uDC22"; [EOL]  [EOL]         final String result = neu.translate(input); [EOL]         assertEquals("Failed to unescape numeric entities supplementary characters", expected, result); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testUnfinishedEntity() { [EOL]         // parse it [EOL]         NumericEntityUnescaper neu = new NumericEntityUnescaper(NumericEntityUnescaper.OPTION.semiColonOptional); [EOL]         String input = "Test &#x30 not test"; [EOL]         String expected = "Test \u0030 not test"; [EOL]  [EOL]         String result = neu.translate(input); [EOL]         assertEquals("Failed to support unfinished entities (i.e. missing semi-colon)", expected, result); [EOL]  [EOL]         // ignore it [EOL]         neu = new NumericEntityUnescaper(); [EOL]         input = "Test &#x30 not test"; [EOL]         expected = input; [EOL]  [EOL]         result = neu.translate(input); [EOL]         assertEquals("Failed to ignore unfinished entities (i.e. missing semi-colon)", expected, result); [EOL]  [EOL]         // fail it [EOL]         neu = new NumericEntityUnescaper(NumericEntityUnescaper.OPTION.errorIfNoSemiColon); [EOL]         input = "Test &#x30 not test"; [EOL]  [EOL]         try { [EOL]             result = neu.translate(input); [EOL]             fail("IllegalArgumentException expected"); [EOL]         } catch(final IllegalArgumentException iae) { [EOL]             // expected [EOL]         } [EOL]     } [EOL]  [EOL] } [EOL]
@Test [EOL]     public void testUnfinishedEntity() { [EOL]         // parse it [EOL]         NumericEntityUnescaper neu = new NumericEntityUnescaper(NumericEntityUnescaper.OPTION.semiColonOptional); [EOL]         String input = "Test &#x30 not test"; [EOL]         String expected = "Test \u0030 not test"; [EOL]  [EOL]         String result = neu.translate(input); [EOL]         assertEquals("Failed to support unfinished entities (i.e. missing semi-colon)", expected, result); [EOL]  [EOL]         // ignore it [EOL]         neu = new NumericEntityUnescaper(); [EOL]         input = "Test &#x30 not test"; [EOL]         expected = input; [EOL]  [EOL]         result = neu.translate(input); [EOL]         assertEquals("Failed to ignore unfinished entities (i.e. missing semi-colon)", expected, result); [EOL]  [EOL]         // fail it [EOL]         neu = new NumericEntityUnescaper(NumericEntityUnescaper.OPTION.errorIfNoSemiColon); [EOL]         input = "Test &#x30 not test"; [EOL]  [EOL]         try { [EOL]             result = neu.translate(input); [EOL]             fail("IllegalArgumentException expected"); [EOL]         } catch(final IllegalArgumentException iae) { [EOL]             // expected [EOL]         } [EOL]     } [EOL]  [EOL] } [EOL]
@Test [EOL]     public void testUnfinishedEntity() { [EOL]         // parse it [EOL]         NumericEntityUnescaper neu = new NumericEntityUnescaper(NumericEntityUnescaper.OPTION.semiColonOptional); [EOL]         String input = "Test &#x30 not test"; [EOL]         String expected = "Test \u0030 not test"; [EOL]  [EOL]         String result = neu.translate(input); [EOL]         assertEquals("Failed to support unfinished entities (i.e. missing semi-colon)", expected, result); [EOL]  [EOL]         // ignore it [EOL]         neu = new NumericEntityUnescaper(); [EOL]         input = "Test &#x30 not test"; [EOL]         expected = input; [EOL]  [EOL]         result = neu.translate(input); [EOL]         assertEquals("Failed to ignore unfinished entities (i.e. missing semi-colon)", expected, result); [EOL]  [EOL]         // fail it [EOL]         neu = new NumericEntityUnescaper(NumericEntityUnescaper.OPTION.errorIfNoSemiColon); [EOL]         input = "Test &#x30 not test"; [EOL]  [EOL]         try { [EOL]             result = neu.translate(input); [EOL]             fail("IllegalArgumentException expected"); [EOL]         } catch(final IllegalArgumentException iae) { [EOL]             // expected [EOL]         } [EOL]     } [EOL]  [EOL] } [EOL]
@Test [EOL]     public void testUnfinishedEntity() { [EOL]         // parse it [EOL]         NumericEntityUnescaper neu = new NumericEntityUnescaper(NumericEntityUnescaper.OPTION.semiColonOptional); [EOL]         String input = "Test &#x30 not test"; [EOL]         String expected = "Test \u0030 not test"; [EOL]  [EOL]         String result = neu.translate(input); [EOL]         assertEquals("Failed to support unfinished entities (i.e. missing semi-colon)", expected, result); [EOL]  [EOL]         // ignore it [EOL]         neu = new NumericEntityUnescaper(); [EOL]         input = "Test &#x30 not test"; [EOL]         expected = input; [EOL]  [EOL]         result = neu.translate(input); [EOL]         assertEquals("Failed to ignore unfinished entities (i.e. missing semi-colon)", expected, result); [EOL]  [EOL]         // fail it [EOL]         neu = new NumericEntityUnescaper(NumericEntityUnescaper.OPTION.errorIfNoSemiColon); [EOL]         input = "Test &#x30 not test"; [EOL]  [EOL]         try { [EOL]             result = neu.translate(input); [EOL]             fail("IllegalArgumentException expected"); [EOL]         } catch(final IllegalArgumentException iae) { [EOL]             // expected [EOL]         } [EOL]     } [EOL]  [EOL] } [EOL]
@Test [EOL]     public void testSupplementaryUnescaping() { [EOL]         final NumericEntityUnescaper neu = new NumericEntityUnescaper(); [EOL]         final String input = "&#68642;"; [EOL]         final String expected = "\uD803\uDC22"; [EOL]  [EOL]         final String result = neu.translate(input); [EOL]         assertEquals("Failed to unescape numeric entities supplementary characters", expected, result); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSupplementaryUnescaping() { [EOL]         final NumericEntityUnescaper neu = new NumericEntityUnescaper(); [EOL]         final String input = "&#68642;"; [EOL]         final String expected = "\uD803\uDC22"; [EOL]  [EOL]         final String result = neu.translate(input); [EOL]         assertEquals("Failed to unescape numeric entities supplementary characters", expected, result); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSupplementaryUnescaping() { [EOL]         final NumericEntityUnescaper neu = new NumericEntityUnescaper(); [EOL]         final String input = "&#68642;"; [EOL]         final String expected = "\uD803\uDC22"; [EOL]  [EOL]         final String result = neu.translate(input); [EOL]         assertEquals("Failed to unescape numeric entities supplementary characters", expected, result); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testUnfinishedEntity() { [EOL]         // parse it [EOL]         NumericEntityUnescaper neu = new NumericEntityUnescaper(NumericEntityUnescaper.OPTION.semiColonOptional); [EOL]         String input = "Test &#x30 not test"; [EOL]         String expected = "Test \u0030 not test"; [EOL]  [EOL]         String result = neu.translate(input); [EOL]         assertEquals("Failed to support unfinished entities (i.e. missing semi-colon)", expected, result); [EOL]  [EOL]         // ignore it [EOL]         neu = new NumericEntityUnescaper(); [EOL]         input = "Test &#x30 not test"; [EOL]         expected = input; [EOL]  [EOL]         result = neu.translate(input); [EOL]         assertEquals("Failed to ignore unfinished entities (i.e. missing semi-colon)", expected, result); [EOL]  [EOL]         // fail it [EOL]         neu = new NumericEntityUnescaper(NumericEntityUnescaper.OPTION.errorIfNoSemiColon); [EOL]         input = "Test &#x30 not test"; [EOL]  [EOL]         try { [EOL]             result = neu.translate(input); [EOL]             fail("IllegalArgumentException expected"); [EOL]         } catch(final IllegalArgumentException iae) { [EOL]             // expected [EOL]         } [EOL]     } [EOL]  [EOL] } [EOL]
@Test [EOL]     public void testSupplementaryUnescaping() { [EOL]         final NumericEntityUnescaper neu = new NumericEntityUnescaper(); [EOL]         final String input = "&#68642;"; [EOL]         final String expected = "\uD803\uDC22"; [EOL]  [EOL]         final String result = neu.translate(input); [EOL]         assertEquals("Failed to unescape numeric entities supplementary characters", expected, result); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testUnescapeHtml4() { [EOL]         for (int i = 0; i < HTML_ESCAPES.length; ++i) { [EOL]             final String message = HTML_ESCAPES[i][0]; [EOL]             final String expected = HTML_ESCAPES[i][2]; [EOL]             final String original = HTML_ESCAPES[i][1]; [EOL]             assertEquals(message, expected, StringEscapeUtils.unescapeHtml4(original)); [EOL]              [EOL]             final StringWriter sw = new StringWriter(); [EOL]             try { [EOL]                 StringEscapeUtils.UNESCAPE_HTML4.translate(original, sw); [EOL]             } catch (final IOException e) { [EOL]             } [EOL]             final String actual = original == null ? null : sw.toString(); [EOL]             assertEquals(message, expected, actual); [EOL]         } [EOL]         // \u00E7 is a cedilla (c with wiggle under) [EOL]         // note that the test string must be 7-bit-clean (Unicode escaped) or else it will compile incorrectly [EOL]         // on some locales         [EOL]         assertEquals("funny chars pass through OK", "Fran\u00E7ais", StringEscapeUtils.unescapeHtml4("Fran\u00E7ais")); [EOL]          [EOL]         assertEquals("Hello&;World", StringEscapeUtils.unescapeHtml4("Hello&;World")); [EOL]         assertEquals("Hello&#;World", StringEscapeUtils.unescapeHtml4("Hello&#;World")); [EOL]         assertEquals("Hello&# ;World", StringEscapeUtils.unescapeHtml4("Hello&# ;World")); [EOL]         assertEquals("Hello&##;World", StringEscapeUtils.unescapeHtml4("Hello&##;World")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSupplementaryUnescaping() { [EOL]         final NumericEntityUnescaper neu = new NumericEntityUnescaper(); [EOL]         final String input = "&#68642;"; [EOL]         final String expected = "\uD803\uDC22"; [EOL]  [EOL]         final String result = neu.translate(input); [EOL]         assertEquals("Failed to unescape numeric entities supplementary characters", expected, result); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSupplementaryUnescaping() { [EOL]         final NumericEntityUnescaper neu = new NumericEntityUnescaper(); [EOL]         final String input = "&#68642;"; [EOL]         final String expected = "\uD803\uDC22"; [EOL]  [EOL]         final String result = neu.translate(input); [EOL]         assertEquals("Failed to unescape numeric entities supplementary characters", expected, result); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSupplementaryUnescaping() { [EOL]         final NumericEntityUnescaper neu = new NumericEntityUnescaper(); [EOL]         final String input = "&#68642;"; [EOL]         final String expected = "\uD803\uDC22"; [EOL]  [EOL]         final String result = neu.translate(input); [EOL]         assertEquals("Failed to unescape numeric entities supplementary characters", expected, result); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSupplementaryUnescaping() { [EOL]         final NumericEntityUnescaper neu = new NumericEntityUnescaper(); [EOL]         final String input = "&#68642;"; [EOL]         final String expected = "\uD803\uDC22"; [EOL]  [EOL]         final String result = neu.translate(input); [EOL]         assertEquals("Failed to unescape numeric entities supplementary characters", expected, result); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testUnfinishedEntity() { [EOL]         // parse it [EOL]         NumericEntityUnescaper neu = new NumericEntityUnescaper(NumericEntityUnescaper.OPTION.semiColonOptional); [EOL]         String input = "Test &#x30 not test"; [EOL]         String expected = "Test \u0030 not test"; [EOL]  [EOL]         String result = neu.translate(input); [EOL]         assertEquals("Failed to support unfinished entities (i.e. missing semi-colon)", expected, result); [EOL]  [EOL]         // ignore it [EOL]         neu = new NumericEntityUnescaper(); [EOL]         input = "Test &#x30 not test"; [EOL]         expected = input; [EOL]  [EOL]         result = neu.translate(input); [EOL]         assertEquals("Failed to ignore unfinished entities (i.e. missing semi-colon)", expected, result); [EOL]  [EOL]         // fail it [EOL]         neu = new NumericEntityUnescaper(NumericEntityUnescaper.OPTION.errorIfNoSemiColon); [EOL]         input = "Test &#x30 not test"; [EOL]  [EOL]         try { [EOL]             result = neu.translate(input); [EOL]             fail("IllegalArgumentException expected"); [EOL]         } catch(final IllegalArgumentException iae) { [EOL]             // expected [EOL]         } [EOL]     } [EOL]  [EOL] } [EOL]
@Test [EOL]     public void testSupplementaryUnescaping() { [EOL]         final NumericEntityUnescaper neu = new NumericEntityUnescaper(); [EOL]         final String input = "&#68642;"; [EOL]         final String expected = "\uD803\uDC22"; [EOL]  [EOL]         final String result = neu.translate(input); [EOL]         assertEquals("Failed to unescape numeric entities supplementary characters", expected, result); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGet() throws ConcurrentException { [EOL]         assertNotNull("No managed object", createInitializer().get()); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether sequential get() invocations always return the same [EOL]      * instance. [EOL]      */ [EOL]
@Test [EOL]     public void testGet() throws ConcurrentException { [EOL]         assertNotNull("No managed object", createInitializer().get()); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether sequential get() invocations always return the same [EOL]      * instance. [EOL]      */ [EOL]
@Test [EOL]     public void testGet() throws ConcurrentException { [EOL]         assertNotNull("No managed object", createInitializer().get()); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether sequential get() invocations always return the same [EOL]      * instance. [EOL]      */ [EOL]
@Test [EOL]     public void testGet() throws ConcurrentException { [EOL]         assertNotNull("No managed object", createInitializer().get()); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether sequential get() invocations always return the same [EOL]      * instance. [EOL]      */ [EOL]
@Test [EOL]     public void testGet() throws ConcurrentException { [EOL]         assertNotNull("No managed object", createInitializer().get()); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether sequential get() invocations always return the same [EOL]      * instance. [EOL]      */ [EOL]
@Test [EOL]     public void testGet() throws ConcurrentException { [EOL]         assertNotNull("No managed object", createInitializer().get()); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether sequential get() invocations always return the same [EOL]      * instance. [EOL]      */ [EOL]
@Test [EOL]     public void testUnescapeCsvString() throws Exception { [EOL]         assertEquals("foo.bar",          StringEscapeUtils.unescapeCsv("foo.bar")); [EOL]         assertEquals("foo,bar",      StringEscapeUtils.unescapeCsv("\"foo,bar\"")); [EOL]         assertEquals("foo\nbar",     StringEscapeUtils.unescapeCsv("\"foo\nbar\"")); [EOL]         assertEquals("foo\rbar",     StringEscapeUtils.unescapeCsv("\"foo\rbar\"")); [EOL]         assertEquals("foo\"bar",   StringEscapeUtils.unescapeCsv("\"foo\"\"bar\"")); [EOL]         assertEquals("",   StringEscapeUtils.unescapeCsv("")); [EOL]         assertEquals(null, StringEscapeUtils.unescapeCsv(null)); [EOL]  [EOL]         assertEquals("\"foo.bar\"",          StringEscapeUtils.unescapeCsv("\"foo.bar\"")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testAsWriter() throws Exception { [EOL]         final StrBuilder sb = new StrBuilder("base"); [EOL]         final Writer writer = sb.asWriter(); [EOL]          [EOL]         writer.write('l'); [EOL]         assertEquals("basel", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'i', 'n'}); [EOL]         assertEquals("baselin", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'n', 'e', 'r'}, 1, 2); [EOL]         assertEquals("baseliner", sb.toString()); [EOL]          [EOL]         writer.write(" rout"); [EOL]         assertEquals("baseliner rout", sb.toString()); [EOL]          [EOL]         writer.write("ping that server", 1, 3); [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.flush();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.close();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.write(" hi");  // works after close [EOL]         assertEquals("baseliner routing hi", sb.toString()); [EOL]          [EOL]         sb.setLength(4);  // mix and match [EOL]         writer.write('d'); [EOL]         assertEquals("based", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testToCharArray() { [EOL]         final StrBuilder sb = new StrBuilder(); [EOL]         assertEquals(ArrayUtils.EMPTY_CHAR_ARRAY, sb.toCharArray()); [EOL]  [EOL]         char[] a = sb.toCharArray(); [EOL]         assertNotNull("toCharArray() result is null", a); [EOL]         assertEquals("toCharArray() result is too large", 0, a.length); [EOL]  [EOL]         sb.append("junit"); [EOL]         a = sb.toCharArray(); [EOL]         assertEquals("toCharArray() result incorrect length", 5, a.length); [EOL]         assertTrue("toCharArray() result does not match", Arrays.equals("junit".toCharArray(), a)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testToCharArrayIntInt() { [EOL]         final StrBuilder sb = new StrBuilder(); [EOL]         assertEquals(ArrayUtils.EMPTY_CHAR_ARRAY, sb.toCharArray(0, 0)); [EOL]  [EOL]         sb.append("junit"); [EOL]         char[] a = sb.toCharArray(0, 20); // too large test [EOL]         assertEquals("toCharArray(int,int) result incorrect length", 5, a.length); [EOL]         assertTrue("toCharArray(int,int) result does not match", Arrays.equals("junit".toCharArray(), a)); [EOL]  [EOL]         a = sb.toCharArray(0, 4); [EOL]         assertEquals("toCharArray(int,int) result incorrect length", 4, a.length); [EOL]         assertTrue("toCharArray(int,int) result does not match", Arrays.equals("juni".toCharArray(), a)); [EOL]  [EOL]         a = sb.toCharArray(0, 4); [EOL]         assertEquals("toCharArray(int,int) result incorrect length", 4, a.length); [EOL]         assertTrue("toCharArray(int,int) result does not match", Arrays.equals("juni".toCharArray(), a)); [EOL]  [EOL]         a = sb.toCharArray(0, 1); [EOL]         assertNotNull("toCharArray(int,int) result is null", a); [EOL]  [EOL]         try { [EOL]             sb.toCharArray(-1, 5); [EOL]             fail("no string index out of bound on -1"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.toCharArray(6, 5); [EOL]             fail("no string index out of bound on -1"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testAppend_StringBuffer() { [EOL]         StrBuilder sb = new StrBuilder(); [EOL]         sb.setNullText("NULL").append((StringBuffer) null); [EOL]         assertEquals("NULL", sb.toString()); [EOL]  [EOL]         sb = new StrBuilder(); [EOL]         sb.append(new StringBuffer("foo")); [EOL]         assertEquals("foo", sb.toString()); [EOL]  [EOL]         sb.append(new StringBuffer("")); [EOL]         assertEquals("foo", sb.toString()); [EOL]  [EOL]         sb.append(new StringBuffer("bar")); [EOL]         assertEquals("foobar", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAppend_StrBuilder_int_int() { [EOL]         StrBuilder sb = new StrBuilder(); [EOL]         sb.setNullText("NULL").append((StrBuilder) null, 0, 1); [EOL]         assertEquals("NULL", sb.toString()); [EOL]  [EOL]         sb = new StrBuilder(); [EOL]         sb.append(new StrBuilder("foo"), 0, 3); [EOL]         assertEquals("foo", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.append(new StrBuilder("bar"), -1, 1); [EOL]             fail("append(char[], -1,) expected IndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.append(new StrBuilder("bar"), 3, 1); [EOL]             fail("append(char[], 3,) expected IndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.append(new StrBuilder("bar"), 1, -1); [EOL]             fail("append(char[],, -1) expected IndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.append(new StrBuilder("bar"), 1, 3); [EOL]             fail("append(char[], 1, 3) expected IndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.append(new StrBuilder("bar"), -1, 3); [EOL]             fail("append(char[], -1, 3) expected IndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.append(new StrBuilder("bar"), 4, 0); [EOL]             fail("append(char[], 4, 0) expected IndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.append(new StrBuilder("bar"), 3, 0); [EOL]         assertEquals("foo", sb.toString()); [EOL]  [EOL]         sb.append(new StrBuilder("abcbardef"), 3, 3); [EOL]         assertEquals("foobar", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAppendWithSeparators_Iterator() { [EOL]         final StrBuilder sb = new StrBuilder(); [EOL]         sb.appendWithSeparators((Iterator<?>) null, ","); [EOL]         assertEquals("", sb.toString()); [EOL]  [EOL]         sb.clear(); [EOL]         sb.appendWithSeparators(Collections.EMPTY_LIST.iterator(), ","); [EOL]         assertEquals("", sb.toString()); [EOL]  [EOL]         sb.clear(); [EOL]         sb.appendWithSeparators(Arrays.asList(new Object[]{"foo", "bar", "baz"}).iterator(), ","); [EOL]         assertEquals("foo,bar,baz", sb.toString()); [EOL]  [EOL]         sb.clear(); [EOL]         sb.appendWithSeparators(Arrays.asList(new Object[]{"foo", "bar", "baz"}).iterator(), null); [EOL]         assertEquals("foobarbaz", sb.toString()); [EOL]  [EOL]         sb.clear(); [EOL]         sb.appendWithSeparators(Arrays.asList(new Object[]{"foo", null, "baz"}).iterator(), ","); [EOL]         assertEquals("foo,,baz", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testLang412Right() { [EOL]         final StrBuilder sb = new StrBuilder(); [EOL]         sb.appendFixedWidthPadRight(null, 10, '*'); [EOL]         assertEquals( "Failed to invoke appendFixedWidthPadRight correctly", "**********", sb.toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testInsertWithNullText() { [EOL]         final StrBuilder sb = new StrBuilder(); [EOL]         sb.setNullText("null"); [EOL]         sb.append("barbaz"); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(-1, FOO); [EOL]             fail("insert(-1, Object) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(7, FOO); [EOL]             fail("insert(7, Object) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, (Object) null); [EOL]         assertEquals("nullbarbaz", sb.toString()); [EOL]  [EOL]         sb.insert(0, FOO); [EOL]         assertEquals("foonullbarbaz", sb.toString()); [EOL]  [EOL]         sb.clear(); [EOL]         sb.append("barbaz"); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(-1, "foo"); [EOL]             fail("insert(-1, String) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(7, "foo"); [EOL]             fail("insert(7, String) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, (String) null); [EOL]         assertEquals("nullbarbaz", sb.toString()); [EOL]  [EOL]         sb.insert(0, "foo"); [EOL]         assertEquals("foonullbarbaz", sb.toString()); [EOL]  [EOL]         sb.insert(0, (char[]) null); [EOL]         assertEquals("nullfoonullbarbaz", sb.toString()); [EOL]  [EOL]         sb.insert(0, (char[]) null, 0, 0); [EOL]         assertEquals("nullnullfoonullbarbaz", sb.toString()); [EOL]     } [EOL] } [EOL]
@Test [EOL]     public void testInsertWithNullText() { [EOL]         final StrBuilder sb = new StrBuilder(); [EOL]         sb.setNullText("null"); [EOL]         sb.append("barbaz"); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(-1, FOO); [EOL]             fail("insert(-1, Object) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(7, FOO); [EOL]             fail("insert(7, Object) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, (Object) null); [EOL]         assertEquals("nullbarbaz", sb.toString()); [EOL]  [EOL]         sb.insert(0, FOO); [EOL]         assertEquals("foonullbarbaz", sb.toString()); [EOL]  [EOL]         sb.clear(); [EOL]         sb.append("barbaz"); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(-1, "foo"); [EOL]             fail("insert(-1, String) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(7, "foo"); [EOL]             fail("insert(7, String) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, (String) null); [EOL]         assertEquals("nullbarbaz", sb.toString()); [EOL]  [EOL]         sb.insert(0, "foo"); [EOL]         assertEquals("foonullbarbaz", sb.toString()); [EOL]  [EOL]         sb.insert(0, (char[]) null); [EOL]         assertEquals("nullfoonullbarbaz", sb.toString()); [EOL]  [EOL]         sb.insert(0, (char[]) null, 0, 0); [EOL]         assertEquals("nullnullfoonullbarbaz", sb.toString()); [EOL]     } [EOL] } [EOL]
@Test [EOL]     public void testInsertWithNullText() { [EOL]         final StrBuilder sb = new StrBuilder(); [EOL]         sb.setNullText("null"); [EOL]         sb.append("barbaz"); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(-1, FOO); [EOL]             fail("insert(-1, Object) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(7, FOO); [EOL]             fail("insert(7, Object) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, (Object) null); [EOL]         assertEquals("nullbarbaz", sb.toString()); [EOL]  [EOL]         sb.insert(0, FOO); [EOL]         assertEquals("foonullbarbaz", sb.toString()); [EOL]  [EOL]         sb.clear(); [EOL]         sb.append("barbaz"); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(-1, "foo"); [EOL]             fail("insert(-1, String) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(7, "foo"); [EOL]             fail("insert(7, String) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, (String) null); [EOL]         assertEquals("nullbarbaz", sb.toString()); [EOL]  [EOL]         sb.insert(0, "foo"); [EOL]         assertEquals("foonullbarbaz", sb.toString()); [EOL]  [EOL]         sb.insert(0, (char[]) null); [EOL]         assertEquals("nullfoonullbarbaz", sb.toString()); [EOL]  [EOL]         sb.insert(0, (char[]) null, 0, 0); [EOL]         assertEquals("nullnullfoonullbarbaz", sb.toString()); [EOL]     } [EOL] } [EOL]
@Test [EOL]     public void testInsertWithNullText() { [EOL]         final StrBuilder sb = new StrBuilder(); [EOL]         sb.setNullText("null"); [EOL]         sb.append("barbaz"); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(-1, FOO); [EOL]             fail("insert(-1, Object) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(7, FOO); [EOL]             fail("insert(7, Object) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, (Object) null); [EOL]         assertEquals("nullbarbaz", sb.toString()); [EOL]  [EOL]         sb.insert(0, FOO); [EOL]         assertEquals("foonullbarbaz", sb.toString()); [EOL]  [EOL]         sb.clear(); [EOL]         sb.append("barbaz"); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(-1, "foo"); [EOL]             fail("insert(-1, String) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(7, "foo"); [EOL]             fail("insert(7, String) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, (String) null); [EOL]         assertEquals("nullbarbaz", sb.toString()); [EOL]  [EOL]         sb.insert(0, "foo"); [EOL]         assertEquals("foonullbarbaz", sb.toString()); [EOL]  [EOL]         sb.insert(0, (char[]) null); [EOL]         assertEquals("nullfoonullbarbaz", sb.toString()); [EOL]  [EOL]         sb.insert(0, (char[]) null, 0, 0); [EOL]         assertEquals("nullnullfoonullbarbaz", sb.toString()); [EOL]     } [EOL] } [EOL]
@Test [EOL]     public void testInsert() { [EOL]  [EOL]         final StrBuilder sb = new StrBuilder(); [EOL]         sb.append("barbaz"); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(-1, FOO); [EOL]             fail("insert(-1, Object) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(7, FOO); [EOL]             fail("insert(7, Object) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, (Object) null); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         sb.insert(0, FOO); [EOL]         assertEquals("foobarbaz", sb.toString()); [EOL]  [EOL]         sb.clear(); [EOL]         sb.append("barbaz"); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(-1, "foo"); [EOL]             fail("insert(-1, String) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(7, "foo"); [EOL]             fail("insert(7, String) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, (String) null); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         sb.insert(0, "foo"); [EOL]         assertEquals("foobarbaz", sb.toString()); [EOL]  [EOL]         sb.clear(); [EOL]         sb.append("barbaz"); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(-1, new char[]{'f', 'o', 'o'}); [EOL]             fail("insert(-1, char[]) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(7, new char[]{'f', 'o', 'o'}); [EOL]             fail("insert(7, char[]) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, (char[]) null); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         sb.insert(0, new char[0]); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         sb.insert(0, new char[]{'f', 'o', 'o'}); [EOL]         assertEquals("foobarbaz", sb.toString()); [EOL]  [EOL]         sb.clear(); [EOL]         sb.append("barbaz"); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(-1, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 3, 3); [EOL]             fail("insert(-1, char[], 3, 3) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(7, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 3, 3); [EOL]             fail("insert(7, char[], 3, 3) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, (char[]) null, 0, 0); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         sb.insert(0, new char[0], 0, 0); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(0, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, -1, 3); [EOL]             fail("insert(0, char[], -1, 3) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(0, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 10, 3); [EOL]             fail("insert(0, char[], 10, 3) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(0, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 0, -1); [EOL]             fail("insert(0, char[], 0, -1) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(0, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 0, 10); [EOL]             fail("insert(0, char[], 0, 10) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 0, 0); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         sb.insert(0, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 3, 3); [EOL]         assertEquals("foobarbaz", sb.toString()); [EOL]  [EOL]         sb.clear(); [EOL]         sb.append("barbaz"); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(-1, true); [EOL]             fail("insert(-1, boolean) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(7, true); [EOL]             fail("insert(7, boolean) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, true); [EOL]         assertEquals("truebarbaz", sb.toString()); [EOL]  [EOL]         sb.insert(0, false); [EOL]         assertEquals("falsetruebarbaz", sb.toString()); [EOL]  [EOL]         sb.clear(); [EOL]         sb.append("barbaz"); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(-1, '!'); [EOL]             fail("insert(-1, char) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(7, '!'); [EOL]             fail("insert(7, char) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, '!'); [EOL]         assertEquals("!barbaz", sb.toString()); [EOL]  [EOL]         sb.clear(); [EOL]         sb.append("barbaz"); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(-1, 0); [EOL]             fail("insert(-1, int) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(7, 0); [EOL]             fail("insert(7, int) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, '0'); [EOL]         assertEquals("0barbaz", sb.toString()); [EOL]  [EOL]         sb.clear(); [EOL]         sb.append("barbaz"); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(-1, 1L); [EOL]             fail("insert(-1, long) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(7, 1L); [EOL]             fail("insert(7, long) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, 1L); [EOL]         assertEquals("1barbaz", sb.toString()); [EOL]  [EOL]         sb.clear(); [EOL]         sb.append("barbaz"); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(-1, 2.3F); [EOL]             fail("insert(-1, float) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(7, 2.3F); [EOL]             fail("insert(7, float) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, 2.3F); [EOL]         assertEquals("2.3barbaz", sb.toString()); [EOL]  [EOL]         sb.clear(); [EOL]         sb.append("barbaz"); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(-1, 4.5D); [EOL]             fail("insert(-1, double) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(7, 4.5D); [EOL]             fail("insert(7, double) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, 4.5D); [EOL]         assertEquals("4.5barbaz", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testInsert() { [EOL]  [EOL]         final StrBuilder sb = new StrBuilder(); [EOL]         sb.append("barbaz"); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(-1, FOO); [EOL]             fail("insert(-1, Object) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(7, FOO); [EOL]             fail("insert(7, Object) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, (Object) null); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         sb.insert(0, FOO); [EOL]         assertEquals("foobarbaz", sb.toString()); [EOL]  [EOL]         sb.clear(); [EOL]         sb.append("barbaz"); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(-1, "foo"); [EOL]             fail("insert(-1, String) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(7, "foo"); [EOL]             fail("insert(7, String) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, (String) null); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         sb.insert(0, "foo"); [EOL]         assertEquals("foobarbaz", sb.toString()); [EOL]  [EOL]         sb.clear(); [EOL]         sb.append("barbaz"); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(-1, new char[]{'f', 'o', 'o'}); [EOL]             fail("insert(-1, char[]) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(7, new char[]{'f', 'o', 'o'}); [EOL]             fail("insert(7, char[]) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, (char[]) null); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         sb.insert(0, new char[0]); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         sb.insert(0, new char[]{'f', 'o', 'o'}); [EOL]         assertEquals("foobarbaz", sb.toString()); [EOL]  [EOL]         sb.clear(); [EOL]         sb.append("barbaz"); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(-1, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 3, 3); [EOL]             fail("insert(-1, char[], 3, 3) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(7, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 3, 3); [EOL]             fail("insert(7, char[], 3, 3) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, (char[]) null, 0, 0); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         sb.insert(0, new char[0], 0, 0); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(0, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, -1, 3); [EOL]             fail("insert(0, char[], -1, 3) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(0, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 10, 3); [EOL]             fail("insert(0, char[], 10, 3) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(0, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 0, -1); [EOL]             fail("insert(0, char[], 0, -1) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(0, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 0, 10); [EOL]             fail("insert(0, char[], 0, 10) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 0, 0); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         sb.insert(0, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 3, 3); [EOL]         assertEquals("foobarbaz", sb.toString()); [EOL]  [EOL]         sb.clear(); [EOL]         sb.append("barbaz"); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(-1, true); [EOL]             fail("insert(-1, boolean) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(7, true); [EOL]             fail("insert(7, boolean) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, true); [EOL]         assertEquals("truebarbaz", sb.toString()); [EOL]  [EOL]         sb.insert(0, false); [EOL]         assertEquals("falsetruebarbaz", sb.toString()); [EOL]  [EOL]         sb.clear(); [EOL]         sb.append("barbaz"); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(-1, '!'); [EOL]             fail("insert(-1, char) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(7, '!'); [EOL]             fail("insert(7, char) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, '!'); [EOL]         assertEquals("!barbaz", sb.toString()); [EOL]  [EOL]         sb.clear(); [EOL]         sb.append("barbaz"); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(-1, 0); [EOL]             fail("insert(-1, int) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(7, 0); [EOL]             fail("insert(7, int) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, '0'); [EOL]         assertEquals("0barbaz", sb.toString()); [EOL]  [EOL]         sb.clear(); [EOL]         sb.append("barbaz"); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(-1, 1L); [EOL]             fail("insert(-1, long) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(7, 1L); [EOL]             fail("insert(7, long) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, 1L); [EOL]         assertEquals("1barbaz", sb.toString()); [EOL]  [EOL]         sb.clear(); [EOL]         sb.append("barbaz"); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(-1, 2.3F); [EOL]             fail("insert(-1, float) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(7, 2.3F); [EOL]             fail("insert(7, float) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, 2.3F); [EOL]         assertEquals("2.3barbaz", sb.toString()); [EOL]  [EOL]         sb.clear(); [EOL]         sb.append("barbaz"); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(-1, 4.5D); [EOL]             fail("insert(-1, double) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(7, 4.5D); [EOL]             fail("insert(7, double) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, 4.5D); [EOL]         assertEquals("4.5barbaz", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testInsert() { [EOL]  [EOL]         final StrBuilder sb = new StrBuilder(); [EOL]         sb.append("barbaz"); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(-1, FOO); [EOL]             fail("insert(-1, Object) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(7, FOO); [EOL]             fail("insert(7, Object) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, (Object) null); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         sb.insert(0, FOO); [EOL]         assertEquals("foobarbaz", sb.toString()); [EOL]  [EOL]         sb.clear(); [EOL]         sb.append("barbaz"); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(-1, "foo"); [EOL]             fail("insert(-1, String) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(7, "foo"); [EOL]             fail("insert(7, String) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, (String) null); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         sb.insert(0, "foo"); [EOL]         assertEquals("foobarbaz", sb.toString()); [EOL]  [EOL]         sb.clear(); [EOL]         sb.append("barbaz"); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(-1, new char[]{'f', 'o', 'o'}); [EOL]             fail("insert(-1, char[]) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(7, new char[]{'f', 'o', 'o'}); [EOL]             fail("insert(7, char[]) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, (char[]) null); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         sb.insert(0, new char[0]); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         sb.insert(0, new char[]{'f', 'o', 'o'}); [EOL]         assertEquals("foobarbaz", sb.toString()); [EOL]  [EOL]         sb.clear(); [EOL]         sb.append("barbaz"); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(-1, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 3, 3); [EOL]             fail("insert(-1, char[], 3, 3) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(7, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 3, 3); [EOL]             fail("insert(7, char[], 3, 3) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, (char[]) null, 0, 0); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         sb.insert(0, new char[0], 0, 0); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(0, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, -1, 3); [EOL]             fail("insert(0, char[], -1, 3) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(0, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 10, 3); [EOL]             fail("insert(0, char[], 10, 3) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(0, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 0, -1); [EOL]             fail("insert(0, char[], 0, -1) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(0, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 0, 10); [EOL]             fail("insert(0, char[], 0, 10) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 0, 0); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         sb.insert(0, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 3, 3); [EOL]         assertEquals("foobarbaz", sb.toString()); [EOL]  [EOL]         sb.clear(); [EOL]         sb.append("barbaz"); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(-1, true); [EOL]             fail("insert(-1, boolean) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(7, true); [EOL]             fail("insert(7, boolean) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, true); [EOL]         assertEquals("truebarbaz", sb.toString()); [EOL]  [EOL]         sb.insert(0, false); [EOL]         assertEquals("falsetruebarbaz", sb.toString()); [EOL]  [EOL]         sb.clear(); [EOL]         sb.append("barbaz"); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(-1, '!'); [EOL]             fail("insert(-1, char) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(7, '!'); [EOL]             fail("insert(7, char) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, '!'); [EOL]         assertEquals("!barbaz", sb.toString()); [EOL]  [EOL]         sb.clear(); [EOL]         sb.append("barbaz"); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(-1, 0); [EOL]             fail("insert(-1, int) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(7, 0); [EOL]             fail("insert(7, int) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, '0'); [EOL]         assertEquals("0barbaz", sb.toString()); [EOL]  [EOL]         sb.clear(); [EOL]         sb.append("barbaz"); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(-1, 1L); [EOL]             fail("insert(-1, long) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(7, 1L); [EOL]             fail("insert(7, long) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, 1L); [EOL]         assertEquals("1barbaz", sb.toString()); [EOL]  [EOL]         sb.clear(); [EOL]         sb.append("barbaz"); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(-1, 2.3F); [EOL]             fail("insert(-1, float) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(7, 2.3F); [EOL]             fail("insert(7, float) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, 2.3F); [EOL]         assertEquals("2.3barbaz", sb.toString()); [EOL]  [EOL]         sb.clear(); [EOL]         sb.append("barbaz"); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(-1, 4.5D); [EOL]             fail("insert(-1, double) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(7, 4.5D); [EOL]             fail("insert(7, double) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, 4.5D); [EOL]         assertEquals("4.5barbaz", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testInsert() { [EOL]  [EOL]         final StrBuilder sb = new StrBuilder(); [EOL]         sb.append("barbaz"); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(-1, FOO); [EOL]             fail("insert(-1, Object) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(7, FOO); [EOL]             fail("insert(7, Object) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, (Object) null); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         sb.insert(0, FOO); [EOL]         assertEquals("foobarbaz", sb.toString()); [EOL]  [EOL]         sb.clear(); [EOL]         sb.append("barbaz"); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(-1, "foo"); [EOL]             fail("insert(-1, String) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(7, "foo"); [EOL]             fail("insert(7, String) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, (String) null); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         sb.insert(0, "foo"); [EOL]         assertEquals("foobarbaz", sb.toString()); [EOL]  [EOL]         sb.clear(); [EOL]         sb.append("barbaz"); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(-1, new char[]{'f', 'o', 'o'}); [EOL]             fail("insert(-1, char[]) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(7, new char[]{'f', 'o', 'o'}); [EOL]             fail("insert(7, char[]) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, (char[]) null); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         sb.insert(0, new char[0]); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         sb.insert(0, new char[]{'f', 'o', 'o'}); [EOL]         assertEquals("foobarbaz", sb.toString()); [EOL]  [EOL]         sb.clear(); [EOL]         sb.append("barbaz"); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(-1, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 3, 3); [EOL]             fail("insert(-1, char[], 3, 3) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(7, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 3, 3); [EOL]             fail("insert(7, char[], 3, 3) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, (char[]) null, 0, 0); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         sb.insert(0, new char[0], 0, 0); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(0, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, -1, 3); [EOL]             fail("insert(0, char[], -1, 3) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(0, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 10, 3); [EOL]             fail("insert(0, char[], 10, 3) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(0, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 0, -1); [EOL]             fail("insert(0, char[], 0, -1) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(0, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 0, 10); [EOL]             fail("insert(0, char[], 0, 10) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 0, 0); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         sb.insert(0, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 3, 3); [EOL]         assertEquals("foobarbaz", sb.toString()); [EOL]  [EOL]         sb.clear(); [EOL]         sb.append("barbaz"); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(-1, true); [EOL]             fail("insert(-1, boolean) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(7, true); [EOL]             fail("insert(7, boolean) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, true); [EOL]         assertEquals("truebarbaz", sb.toString()); [EOL]  [EOL]         sb.insert(0, false); [EOL]         assertEquals("falsetruebarbaz", sb.toString()); [EOL]  [EOL]         sb.clear(); [EOL]         sb.append("barbaz"); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(-1, '!'); [EOL]             fail("insert(-1, char) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(7, '!'); [EOL]             fail("insert(7, char) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, '!'); [EOL]         assertEquals("!barbaz", sb.toString()); [EOL]  [EOL]         sb.clear(); [EOL]         sb.append("barbaz"); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(-1, 0); [EOL]             fail("insert(-1, int) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(7, 0); [EOL]             fail("insert(7, int) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, '0'); [EOL]         assertEquals("0barbaz", sb.toString()); [EOL]  [EOL]         sb.clear(); [EOL]         sb.append("barbaz"); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(-1, 1L); [EOL]             fail("insert(-1, long) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(7, 1L); [EOL]             fail("insert(7, long) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, 1L); [EOL]         assertEquals("1barbaz", sb.toString()); [EOL]  [EOL]         sb.clear(); [EOL]         sb.append("barbaz"); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(-1, 2.3F); [EOL]             fail("insert(-1, float) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(7, 2.3F); [EOL]             fail("insert(7, float) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, 2.3F); [EOL]         assertEquals("2.3barbaz", sb.toString()); [EOL]  [EOL]         sb.clear(); [EOL]         sb.append("barbaz"); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(-1, 4.5D); [EOL]             fail("insert(-1, double) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(7, 4.5D); [EOL]             fail("insert(7, double) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, 4.5D); [EOL]         assertEquals("4.5barbaz", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testInsert() { [EOL]  [EOL]         final StrBuilder sb = new StrBuilder(); [EOL]         sb.append("barbaz"); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(-1, FOO); [EOL]             fail("insert(-1, Object) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(7, FOO); [EOL]             fail("insert(7, Object) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, (Object) null); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         sb.insert(0, FOO); [EOL]         assertEquals("foobarbaz", sb.toString()); [EOL]  [EOL]         sb.clear(); [EOL]         sb.append("barbaz"); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(-1, "foo"); [EOL]             fail("insert(-1, String) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(7, "foo"); [EOL]             fail("insert(7, String) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, (String) null); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         sb.insert(0, "foo"); [EOL]         assertEquals("foobarbaz", sb.toString()); [EOL]  [EOL]         sb.clear(); [EOL]         sb.append("barbaz"); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(-1, new char[]{'f', 'o', 'o'}); [EOL]             fail("insert(-1, char[]) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(7, new char[]{'f', 'o', 'o'}); [EOL]             fail("insert(7, char[]) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, (char[]) null); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         sb.insert(0, new char[0]); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         sb.insert(0, new char[]{'f', 'o', 'o'}); [EOL]         assertEquals("foobarbaz", sb.toString()); [EOL]  [EOL]         sb.clear(); [EOL]         sb.append("barbaz"); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(-1, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 3, 3); [EOL]             fail("insert(-1, char[], 3, 3) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(7, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 3, 3); [EOL]             fail("insert(7, char[], 3, 3) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, (char[]) null, 0, 0); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         sb.insert(0, new char[0], 0, 0); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(0, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, -1, 3); [EOL]             fail("insert(0, char[], -1, 3) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(0, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 10, 3); [EOL]             fail("insert(0, char[], 10, 3) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(0, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 0, -1); [EOL]             fail("insert(0, char[], 0, -1) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(0, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 0, 10); [EOL]             fail("insert(0, char[], 0, 10) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 0, 0); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         sb.insert(0, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 3, 3); [EOL]         assertEquals("foobarbaz", sb.toString()); [EOL]  [EOL]         sb.clear(); [EOL]         sb.append("barbaz"); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(-1, true); [EOL]             fail("insert(-1, boolean) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(7, true); [EOL]             fail("insert(7, boolean) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, true); [EOL]         assertEquals("truebarbaz", sb.toString()); [EOL]  [EOL]         sb.insert(0, false); [EOL]         assertEquals("falsetruebarbaz", sb.toString()); [EOL]  [EOL]         sb.clear(); [EOL]         sb.append("barbaz"); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(-1, '!'); [EOL]             fail("insert(-1, char) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(7, '!'); [EOL]             fail("insert(7, char) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, '!'); [EOL]         assertEquals("!barbaz", sb.toString()); [EOL]  [EOL]         sb.clear(); [EOL]         sb.append("barbaz"); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(-1, 0); [EOL]             fail("insert(-1, int) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(7, 0); [EOL]             fail("insert(7, int) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, '0'); [EOL]         assertEquals("0barbaz", sb.toString()); [EOL]  [EOL]         sb.clear(); [EOL]         sb.append("barbaz"); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(-1, 1L); [EOL]             fail("insert(-1, long) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(7, 1L); [EOL]             fail("insert(7, long) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, 1L); [EOL]         assertEquals("1barbaz", sb.toString()); [EOL]  [EOL]         sb.clear(); [EOL]         sb.append("barbaz"); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(-1, 2.3F); [EOL]             fail("insert(-1, float) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(7, 2.3F); [EOL]             fail("insert(7, float) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, 2.3F); [EOL]         assertEquals("2.3barbaz", sb.toString()); [EOL]  [EOL]         sb.clear(); [EOL]         sb.append("barbaz"); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(-1, 4.5D); [EOL]             fail("insert(-1, double) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(7, 4.5D); [EOL]             fail("insert(7, double) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, 4.5D); [EOL]         assertEquals("4.5barbaz", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testInsert() { [EOL]  [EOL]         final StrBuilder sb = new StrBuilder(); [EOL]         sb.append("barbaz"); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(-1, FOO); [EOL]             fail("insert(-1, Object) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(7, FOO); [EOL]             fail("insert(7, Object) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, (Object) null); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         sb.insert(0, FOO); [EOL]         assertEquals("foobarbaz", sb.toString()); [EOL]  [EOL]         sb.clear(); [EOL]         sb.append("barbaz"); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(-1, "foo"); [EOL]             fail("insert(-1, String) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(7, "foo"); [EOL]             fail("insert(7, String) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, (String) null); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         sb.insert(0, "foo"); [EOL]         assertEquals("foobarbaz", sb.toString()); [EOL]  [EOL]         sb.clear(); [EOL]         sb.append("barbaz"); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(-1, new char[]{'f', 'o', 'o'}); [EOL]             fail("insert(-1, char[]) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(7, new char[]{'f', 'o', 'o'}); [EOL]             fail("insert(7, char[]) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, (char[]) null); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         sb.insert(0, new char[0]); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         sb.insert(0, new char[]{'f', 'o', 'o'}); [EOL]         assertEquals("foobarbaz", sb.toString()); [EOL]  [EOL]         sb.clear(); [EOL]         sb.append("barbaz"); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(-1, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 3, 3); [EOL]             fail("insert(-1, char[], 3, 3) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(7, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 3, 3); [EOL]             fail("insert(7, char[], 3, 3) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, (char[]) null, 0, 0); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         sb.insert(0, new char[0], 0, 0); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(0, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, -1, 3); [EOL]             fail("insert(0, char[], -1, 3) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(0, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 10, 3); [EOL]             fail("insert(0, char[], 10, 3) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(0, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 0, -1); [EOL]             fail("insert(0, char[], 0, -1) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(0, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 0, 10); [EOL]             fail("insert(0, char[], 0, 10) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 0, 0); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         sb.insert(0, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 3, 3); [EOL]         assertEquals("foobarbaz", sb.toString()); [EOL]  [EOL]         sb.clear(); [EOL]         sb.append("barbaz"); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(-1, true); [EOL]             fail("insert(-1, boolean) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(7, true); [EOL]             fail("insert(7, boolean) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, true); [EOL]         assertEquals("truebarbaz", sb.toString()); [EOL]  [EOL]         sb.insert(0, false); [EOL]         assertEquals("falsetruebarbaz", sb.toString()); [EOL]  [EOL]         sb.clear(); [EOL]         sb.append("barbaz"); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(-1, '!'); [EOL]             fail("insert(-1, char) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(7, '!'); [EOL]             fail("insert(7, char) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, '!'); [EOL]         assertEquals("!barbaz", sb.toString()); [EOL]  [EOL]         sb.clear(); [EOL]         sb.append("barbaz"); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(-1, 0); [EOL]             fail("insert(-1, int) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(7, 0); [EOL]             fail("insert(7, int) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, '0'); [EOL]         assertEquals("0barbaz", sb.toString()); [EOL]  [EOL]         sb.clear(); [EOL]         sb.append("barbaz"); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(-1, 1L); [EOL]             fail("insert(-1, long) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(7, 1L); [EOL]             fail("insert(7, long) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, 1L); [EOL]         assertEquals("1barbaz", sb.toString()); [EOL]  [EOL]         sb.clear(); [EOL]         sb.append("barbaz"); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(-1, 2.3F); [EOL]             fail("insert(-1, float) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(7, 2.3F); [EOL]             fail("insert(7, float) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, 2.3F); [EOL]         assertEquals("2.3barbaz", sb.toString()); [EOL]  [EOL]         sb.clear(); [EOL]         sb.append("barbaz"); [EOL]         assertEquals("barbaz", sb.toString()); [EOL]  [EOL]         try { [EOL]             sb.insert(-1, 4.5D); [EOL]             fail("insert(-1, double) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             sb.insert(7, 4.5D); [EOL]             fail("insert(7, double) expected StringIndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         sb.insert(0, 4.5D); [EOL]         assertEquals("4.5barbaz", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testDeleteAll_char() { [EOL]         StrBuilder sb = new StrBuilder("abcbccba"); [EOL]         sb.deleteAll('X'); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.deleteAll('a'); [EOL]         assertEquals("bcbccb", sb.toString()); [EOL]         sb.deleteAll('c'); [EOL]         assertEquals("bbb", sb.toString()); [EOL]         sb.deleteAll('b'); [EOL]         assertEquals("", sb.toString()); [EOL]  [EOL]         sb = new StrBuilder(""); [EOL]         sb.deleteAll('b'); [EOL]         assertEquals("", sb.toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testDeleteAll_char() { [EOL]         StrBuilder sb = new StrBuilder("abcbccba"); [EOL]         sb.deleteAll('X'); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.deleteAll('a'); [EOL]         assertEquals("bcbccb", sb.toString()); [EOL]         sb.deleteAll('c'); [EOL]         assertEquals("bbb", sb.toString()); [EOL]         sb.deleteAll('b'); [EOL]         assertEquals("", sb.toString()); [EOL]  [EOL]         sb = new StrBuilder(""); [EOL]         sb.deleteAll('b'); [EOL]         assertEquals("", sb.toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testDeleteAll_char() { [EOL]         StrBuilder sb = new StrBuilder("abcbccba"); [EOL]         sb.deleteAll('X'); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.deleteAll('a'); [EOL]         assertEquals("bcbccb", sb.toString()); [EOL]         sb.deleteAll('c'); [EOL]         assertEquals("bbb", sb.toString()); [EOL]         sb.deleteAll('b'); [EOL]         assertEquals("", sb.toString()); [EOL]  [EOL]         sb = new StrBuilder(""); [EOL]         sb.deleteAll('b'); [EOL]         assertEquals("", sb.toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testDeleteAll_char() { [EOL]         StrBuilder sb = new StrBuilder("abcbccba"); [EOL]         sb.deleteAll('X'); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.deleteAll('a'); [EOL]         assertEquals("bcbccb", sb.toString()); [EOL]         sb.deleteAll('c'); [EOL]         assertEquals("bbb", sb.toString()); [EOL]         sb.deleteAll('b'); [EOL]         assertEquals("", sb.toString()); [EOL]  [EOL]         sb = new StrBuilder(""); [EOL]         sb.deleteAll('b'); [EOL]         assertEquals("", sb.toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testDeleteAll_char() { [EOL]         StrBuilder sb = new StrBuilder("abcbccba"); [EOL]         sb.deleteAll('X'); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.deleteAll('a'); [EOL]         assertEquals("bcbccb", sb.toString()); [EOL]         sb.deleteAll('c'); [EOL]         assertEquals("bbb", sb.toString()); [EOL]         sb.deleteAll('b'); [EOL]         assertEquals("", sb.toString()); [EOL]  [EOL]         sb = new StrBuilder(""); [EOL]         sb.deleteAll('b'); [EOL]         assertEquals("", sb.toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testDeleteAll_char() { [EOL]         StrBuilder sb = new StrBuilder("abcbccba"); [EOL]         sb.deleteAll('X'); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.deleteAll('a'); [EOL]         assertEquals("bcbccb", sb.toString()); [EOL]         sb.deleteAll('c'); [EOL]         assertEquals("bbb", sb.toString()); [EOL]         sb.deleteAll('b'); [EOL]         assertEquals("", sb.toString()); [EOL]  [EOL]         sb = new StrBuilder(""); [EOL]         sb.deleteAll('b'); [EOL]         assertEquals("", sb.toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testDeleteAll_char() { [EOL]         StrBuilder sb = new StrBuilder("abcbccba"); [EOL]         sb.deleteAll('X'); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.deleteAll('a'); [EOL]         assertEquals("bcbccb", sb.toString()); [EOL]         sb.deleteAll('c'); [EOL]         assertEquals("bbb", sb.toString()); [EOL]         sb.deleteAll('b'); [EOL]         assertEquals("", sb.toString()); [EOL]  [EOL]         sb = new StrBuilder(""); [EOL]         sb.deleteAll('b'); [EOL]         assertEquals("", sb.toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReplaceAll_char_char() { [EOL]         final StrBuilder sb = new StrBuilder("abcbccba"); [EOL]         sb.replaceAll('x', 'y'); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll('a', 'd'); [EOL]         assertEquals("dbcbccbd", sb.toString()); [EOL]         sb.replaceAll('b', 'e'); [EOL]         assertEquals("dececced", sb.toString()); [EOL]         sb.replaceAll('c', 'f'); [EOL]         assertEquals("defeffed", sb.toString()); [EOL]         sb.replaceAll('d', 'd'); [EOL]         assertEquals("defeffed", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testReplaceFirst_char_char() { [EOL]         final StrBuilder sb = new StrBuilder("abcbccba"); [EOL]         sb.replaceFirst('x', 'y'); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceFirst('a', 'd'); [EOL]         assertEquals("dbcbccba", sb.toString()); [EOL]         sb.replaceFirst('b', 'e'); [EOL]         assertEquals("decbccba", sb.toString()); [EOL]         sb.replaceFirst('c', 'f'); [EOL]         assertEquals("defbccba", sb.toString()); [EOL]         sb.replaceFirst('d', 'd'); [EOL]         assertEquals("defbccba", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testReplaceFirst_char_char() { [EOL]         final StrBuilder sb = new StrBuilder("abcbccba"); [EOL]         sb.replaceFirst('x', 'y'); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceFirst('a', 'd'); [EOL]         assertEquals("dbcbccba", sb.toString()); [EOL]         sb.replaceFirst('b', 'e'); [EOL]         assertEquals("decbccba", sb.toString()); [EOL]         sb.replaceFirst('c', 'f'); [EOL]         assertEquals("defbccba", sb.toString()); [EOL]         sb.replaceFirst('d', 'd'); [EOL]         assertEquals("defbccba", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testTrim() { [EOL]         final StrBuilder sb = new StrBuilder(); [EOL]         assertEquals("", sb.reverse().toString()); [EOL]          [EOL]         sb.clear().append(" \u0000 "); [EOL]         assertEquals("", sb.trim().toString()); [EOL]          [EOL]         sb.clear().append(" \u0000 a b c"); [EOL]         assertEquals("a b c", sb.trim().toString()); [EOL]          [EOL]         sb.clear().append("a b c \u0000 "); [EOL]         assertEquals("a b c", sb.trim().toString()); [EOL]          [EOL]         sb.clear().append(" \u0000 a b c \u0000 "); [EOL]         assertEquals("a b c", sb.trim().toString()); [EOL]          [EOL]         sb.clear().append("a b c"); [EOL]         assertEquals("a b c", sb.trim().toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testTrim() { [EOL]         final StrBuilder sb = new StrBuilder(); [EOL]         assertEquals("", sb.reverse().toString()); [EOL]          [EOL]         sb.clear().append(" \u0000 "); [EOL]         assertEquals("", sb.trim().toString()); [EOL]          [EOL]         sb.clear().append(" \u0000 a b c"); [EOL]         assertEquals("a b c", sb.trim().toString()); [EOL]          [EOL]         sb.clear().append("a b c \u0000 "); [EOL]         assertEquals("a b c", sb.trim().toString()); [EOL]          [EOL]         sb.clear().append(" \u0000 a b c \u0000 "); [EOL]         assertEquals("a b c", sb.trim().toString()); [EOL]          [EOL]         sb.clear().append("a b c"); [EOL]         assertEquals("a b c", sb.trim().toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testStartsWith() { [EOL]         final StrBuilder sb = new StrBuilder(); [EOL]         assertFalse(sb.startsWith("a")); [EOL]         assertFalse(sb.startsWith(null)); [EOL]         assertTrue(sb.startsWith("")); [EOL]         sb.append("abc"); [EOL]         assertTrue(sb.startsWith("a")); [EOL]         assertTrue(sb.startsWith("ab")); [EOL]         assertTrue(sb.startsWith("abc")); [EOL]         assertFalse(sb.startsWith("cba")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEndsWith() { [EOL]         final StrBuilder sb = new StrBuilder(); [EOL]         assertFalse(sb.endsWith("a")); [EOL]         assertFalse(sb.endsWith("c")); [EOL]         assertTrue(sb.endsWith("")); [EOL]         assertFalse(sb.endsWith(null)); [EOL]         sb.append("abc"); [EOL]         assertTrue(sb.endsWith("c")); [EOL]         assertTrue(sb.endsWith("bc")); [EOL]         assertTrue(sb.endsWith("abc")); [EOL]         assertFalse(sb.endsWith("cba")); [EOL]         assertFalse(sb.endsWith("abcd")); [EOL]         assertFalse(sb.endsWith(" abc")); [EOL]         assertFalse(sb.endsWith("abc ")); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testEndsWith() { [EOL]         final StrBuilder sb = new StrBuilder(); [EOL]         assertFalse(sb.endsWith("a")); [EOL]         assertFalse(sb.endsWith("c")); [EOL]         assertTrue(sb.endsWith("")); [EOL]         assertFalse(sb.endsWith(null)); [EOL]         sb.append("abc"); [EOL]         assertTrue(sb.endsWith("c")); [EOL]         assertTrue(sb.endsWith("bc")); [EOL]         assertTrue(sb.endsWith("abc")); [EOL]         assertFalse(sb.endsWith("cba")); [EOL]         assertFalse(sb.endsWith("abcd")); [EOL]         assertFalse(sb.endsWith(" abc")); [EOL]         assertFalse(sb.endsWith("abc ")); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testEndsWith() { [EOL]         final StrBuilder sb = new StrBuilder(); [EOL]         assertFalse(sb.endsWith("a")); [EOL]         assertFalse(sb.endsWith("c")); [EOL]         assertTrue(sb.endsWith("")); [EOL]         assertFalse(sb.endsWith(null)); [EOL]         sb.append("abc"); [EOL]         assertTrue(sb.endsWith("c")); [EOL]         assertTrue(sb.endsWith("bc")); [EOL]         assertTrue(sb.endsWith("abc")); [EOL]         assertFalse(sb.endsWith("cba")); [EOL]         assertFalse(sb.endsWith("abcd")); [EOL]         assertFalse(sb.endsWith(" abc")); [EOL]         assertFalse(sb.endsWith("abc ")); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testEndsWith() { [EOL]         final StrBuilder sb = new StrBuilder(); [EOL]         assertFalse(sb.endsWith("a")); [EOL]         assertFalse(sb.endsWith("c")); [EOL]         assertTrue(sb.endsWith("")); [EOL]         assertFalse(sb.endsWith(null)); [EOL]         sb.append("abc"); [EOL]         assertTrue(sb.endsWith("c")); [EOL]         assertTrue(sb.endsWith("bc")); [EOL]         assertTrue(sb.endsWith("abc")); [EOL]         assertFalse(sb.endsWith("cba")); [EOL]         assertFalse(sb.endsWith("abcd")); [EOL]         assertFalse(sb.endsWith(" abc")); [EOL]         assertFalse(sb.endsWith("abc ")); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testEndsWith() { [EOL]         final StrBuilder sb = new StrBuilder(); [EOL]         assertFalse(sb.endsWith("a")); [EOL]         assertFalse(sb.endsWith("c")); [EOL]         assertTrue(sb.endsWith("")); [EOL]         assertFalse(sb.endsWith(null)); [EOL]         sb.append("abc"); [EOL]         assertTrue(sb.endsWith("c")); [EOL]         assertTrue(sb.endsWith("bc")); [EOL]         assertTrue(sb.endsWith("abc")); [EOL]         assertFalse(sb.endsWith("cba")); [EOL]         assertFalse(sb.endsWith("abcd")); [EOL]         assertFalse(sb.endsWith(" abc")); [EOL]         assertFalse(sb.endsWith("abc ")); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testEndsWith() { [EOL]         final StrBuilder sb = new StrBuilder(); [EOL]         assertFalse(sb.endsWith("a")); [EOL]         assertFalse(sb.endsWith("c")); [EOL]         assertTrue(sb.endsWith("")); [EOL]         assertFalse(sb.endsWith(null)); [EOL]         sb.append("abc"); [EOL]         assertTrue(sb.endsWith("c")); [EOL]         assertTrue(sb.endsWith("bc")); [EOL]         assertTrue(sb.endsWith("abc")); [EOL]         assertFalse(sb.endsWith("cba")); [EOL]         assertFalse(sb.endsWith("abcd")); [EOL]         assertFalse(sb.endsWith(" abc")); [EOL]         assertFalse(sb.endsWith("abc ")); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testEndsWith() { [EOL]         final StrBuilder sb = new StrBuilder(); [EOL]         assertFalse(sb.endsWith("a")); [EOL]         assertFalse(sb.endsWith("c")); [EOL]         assertTrue(sb.endsWith("")); [EOL]         assertFalse(sb.endsWith(null)); [EOL]         sb.append("abc"); [EOL]         assertTrue(sb.endsWith("c")); [EOL]         assertTrue(sb.endsWith("bc")); [EOL]         assertTrue(sb.endsWith("abc")); [EOL]         assertFalse(sb.endsWith("cba")); [EOL]         assertFalse(sb.endsWith("abcd")); [EOL]         assertFalse(sb.endsWith(" abc")); [EOL]         assertFalse(sb.endsWith("abc ")); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testEndsWith() { [EOL]         final StrBuilder sb = new StrBuilder(); [EOL]         assertFalse(sb.endsWith("a")); [EOL]         assertFalse(sb.endsWith("c")); [EOL]         assertTrue(sb.endsWith("")); [EOL]         assertFalse(sb.endsWith(null)); [EOL]         sb.append("abc"); [EOL]         assertTrue(sb.endsWith("c")); [EOL]         assertTrue(sb.endsWith("bc")); [EOL]         assertTrue(sb.endsWith("abc")); [EOL]         assertFalse(sb.endsWith("cba")); [EOL]         assertFalse(sb.endsWith("abcd")); [EOL]         assertFalse(sb.endsWith(" abc")); [EOL]         assertFalse(sb.endsWith("abc ")); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testEndsWith() { [EOL]         final StrBuilder sb = new StrBuilder(); [EOL]         assertFalse(sb.endsWith("a")); [EOL]         assertFalse(sb.endsWith("c")); [EOL]         assertTrue(sb.endsWith("")); [EOL]         assertFalse(sb.endsWith(null)); [EOL]         sb.append("abc"); [EOL]         assertTrue(sb.endsWith("c")); [EOL]         assertTrue(sb.endsWith("bc")); [EOL]         assertTrue(sb.endsWith("abc")); [EOL]         assertFalse(sb.endsWith("cba")); [EOL]         assertFalse(sb.endsWith("abcd")); [EOL]         assertFalse(sb.endsWith(" abc")); [EOL]         assertFalse(sb.endsWith("abc ")); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testEndsWith() { [EOL]         final StrBuilder sb = new StrBuilder(); [EOL]         assertFalse(sb.endsWith("a")); [EOL]         assertFalse(sb.endsWith("c")); [EOL]         assertTrue(sb.endsWith("")); [EOL]         assertFalse(sb.endsWith(null)); [EOL]         sb.append("abc"); [EOL]         assertTrue(sb.endsWith("c")); [EOL]         assertTrue(sb.endsWith("bc")); [EOL]         assertTrue(sb.endsWith("abc")); [EOL]         assertFalse(sb.endsWith("cba")); [EOL]         assertFalse(sb.endsWith("abcd")); [EOL]         assertFalse(sb.endsWith(" abc")); [EOL]         assertFalse(sb.endsWith("abc ")); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testEndsWith() { [EOL]         final StrBuilder sb = new StrBuilder(); [EOL]         assertFalse(sb.endsWith("a")); [EOL]         assertFalse(sb.endsWith("c")); [EOL]         assertTrue(sb.endsWith("")); [EOL]         assertFalse(sb.endsWith(null)); [EOL]         sb.append("abc"); [EOL]         assertTrue(sb.endsWith("c")); [EOL]         assertTrue(sb.endsWith("bc")); [EOL]         assertTrue(sb.endsWith("abc")); [EOL]         assertFalse(sb.endsWith("cba")); [EOL]         assertFalse(sb.endsWith("abcd")); [EOL]         assertFalse(sb.endsWith(" abc")); [EOL]         assertFalse(sb.endsWith("abc ")); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testEndsWith() { [EOL]         final StrBuilder sb = new StrBuilder(); [EOL]         assertFalse(sb.endsWith("a")); [EOL]         assertFalse(sb.endsWith("c")); [EOL]         assertTrue(sb.endsWith("")); [EOL]         assertFalse(sb.endsWith(null)); [EOL]         sb.append("abc"); [EOL]         assertTrue(sb.endsWith("c")); [EOL]         assertTrue(sb.endsWith("bc")); [EOL]         assertTrue(sb.endsWith("abc")); [EOL]         assertFalse(sb.endsWith("cba")); [EOL]         assertFalse(sb.endsWith("abcd")); [EOL]         assertFalse(sb.endsWith(" abc")); [EOL]         assertFalse(sb.endsWith("abc ")); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testEndsWith() { [EOL]         final StrBuilder sb = new StrBuilder(); [EOL]         assertFalse(sb.endsWith("a")); [EOL]         assertFalse(sb.endsWith("c")); [EOL]         assertTrue(sb.endsWith("")); [EOL]         assertFalse(sb.endsWith(null)); [EOL]         sb.append("abc"); [EOL]         assertTrue(sb.endsWith("c")); [EOL]         assertTrue(sb.endsWith("bc")); [EOL]         assertTrue(sb.endsWith("abc")); [EOL]         assertFalse(sb.endsWith("cba")); [EOL]         assertFalse(sb.endsWith("abcd")); [EOL]         assertFalse(sb.endsWith(" abc")); [EOL]         assertFalse(sb.endsWith("abc ")); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testMidString() { [EOL]         final StrBuilder sb = new StrBuilder("hello goodbye hello"); [EOL]         assertEquals("goodbye", sb.midString(6, 7)); [EOL]         assertEquals("hello", sb.midString(0, 5)); [EOL]         assertEquals("hello", sb.midString(-5, 5)); [EOL]         assertEquals("", sb.midString(0, -1)); [EOL]         assertEquals("", sb.midString(20, 2)); [EOL]         assertEquals("hello", sb.midString(14, 22)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReplaceAll_String_String() { [EOL]         StrBuilder sb = new StrBuilder("abcbccba"); [EOL]         sb.replaceAll((String) null, null); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll((String) null, "anything"); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll("", null); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll("", "anything"); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]          [EOL]         sb.replaceAll("x", "y"); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll("a", "d"); [EOL]         assertEquals("dbcbccbd", sb.toString()); [EOL]         sb.replaceAll("d", null); [EOL]         assertEquals("bcbccb", sb.toString()); [EOL]         sb.replaceAll("cb", "-"); [EOL]         assertEquals("b-c-", sb.toString()); [EOL]          [EOL]         sb = new StrBuilder("abcba"); [EOL]         sb.replaceAll("b", "xbx"); [EOL]         assertEquals("axbxcxbxa", sb.toString()); [EOL]          [EOL]         sb = new StrBuilder("bb"); [EOL]         sb.replaceAll("b", "xbx"); [EOL]         assertEquals("xbxxbx", sb.toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLastIndexOf_String() { [EOL]         final StrBuilder sb = new StrBuilder("abab"); [EOL]          [EOL]         assertEquals(2, sb.lastIndexOf("a")); [EOL]         //should work like String#lastIndexOf [EOL]         assertEquals("abab".lastIndexOf("a"), sb.lastIndexOf("a")); [EOL]          [EOL]         assertEquals(2, sb.lastIndexOf("ab")); [EOL]         //should work like String#lastIndexOf [EOL]         assertEquals("abab".lastIndexOf("ab"), sb.lastIndexOf("ab")); [EOL]          [EOL]         assertEquals(3, sb.lastIndexOf("b")); [EOL]         assertEquals("abab".lastIndexOf("b"), sb.lastIndexOf("b")); [EOL]          [EOL]         assertEquals(1, sb.lastIndexOf("ba")); [EOL]         assertEquals("abab".lastIndexOf("ba"), sb.lastIndexOf("ba")); [EOL]          [EOL]         assertEquals(-1, sb.lastIndexOf("z")); [EOL]          [EOL]         assertEquals(-1, sb.lastIndexOf((String) null)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEqualsIgnoreCase() { [EOL]         final StrBuilder sb1 = new StrBuilder(); [EOL]         final StrBuilder sb2 = new StrBuilder(); [EOL]         assertTrue(sb1.equalsIgnoreCase(sb1)); [EOL]         assertTrue(sb1.equalsIgnoreCase(sb2)); [EOL]         assertTrue(sb2.equalsIgnoreCase(sb2)); [EOL]          [EOL]         sb1.append("abc"); [EOL]         assertFalse(sb1.equalsIgnoreCase(sb2)); [EOL]          [EOL]         sb2.append("ABC"); [EOL]         assertTrue(sb1.equalsIgnoreCase(sb2)); [EOL]          [EOL]         sb2.clear().append("abc"); [EOL]         assertTrue(sb1.equalsIgnoreCase(sb2)); [EOL]         assertTrue(sb1.equalsIgnoreCase(sb1)); [EOL]         assertTrue(sb2.equalsIgnoreCase(sb2)); [EOL]          [EOL]         sb2.clear().append("aBc"); [EOL]         assertTrue(sb1.equalsIgnoreCase(sb2)); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testEqualsIgnoreCase() { [EOL]         final StrBuilder sb1 = new StrBuilder(); [EOL]         final StrBuilder sb2 = new StrBuilder(); [EOL]         assertTrue(sb1.equalsIgnoreCase(sb1)); [EOL]         assertTrue(sb1.equalsIgnoreCase(sb2)); [EOL]         assertTrue(sb2.equalsIgnoreCase(sb2)); [EOL]          [EOL]         sb1.append("abc"); [EOL]         assertFalse(sb1.equalsIgnoreCase(sb2)); [EOL]          [EOL]         sb2.append("ABC"); [EOL]         assertTrue(sb1.equalsIgnoreCase(sb2)); [EOL]          [EOL]         sb2.clear().append("abc"); [EOL]         assertTrue(sb1.equalsIgnoreCase(sb2)); [EOL]         assertTrue(sb1.equalsIgnoreCase(sb1)); [EOL]         assertTrue(sb2.equalsIgnoreCase(sb2)); [EOL]          [EOL]         sb2.clear().append("aBc"); [EOL]         assertTrue(sb1.equalsIgnoreCase(sb2)); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testEqualsIgnoreCase() { [EOL]         final StrBuilder sb1 = new StrBuilder(); [EOL]         final StrBuilder sb2 = new StrBuilder(); [EOL]         assertTrue(sb1.equalsIgnoreCase(sb1)); [EOL]         assertTrue(sb1.equalsIgnoreCase(sb2)); [EOL]         assertTrue(sb2.equalsIgnoreCase(sb2)); [EOL]          [EOL]         sb1.append("abc"); [EOL]         assertFalse(sb1.equalsIgnoreCase(sb2)); [EOL]          [EOL]         sb2.append("ABC"); [EOL]         assertTrue(sb1.equalsIgnoreCase(sb2)); [EOL]          [EOL]         sb2.clear().append("abc"); [EOL]         assertTrue(sb1.equalsIgnoreCase(sb2)); [EOL]         assertTrue(sb1.equalsIgnoreCase(sb1)); [EOL]         assertTrue(sb2.equalsIgnoreCase(sb2)); [EOL]          [EOL]         sb2.clear().append("aBc"); [EOL]         assertTrue(sb1.equalsIgnoreCase(sb2)); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testEqualsIgnoreCase() { [EOL]         final StrBuilder sb1 = new StrBuilder(); [EOL]         final StrBuilder sb2 = new StrBuilder(); [EOL]         assertTrue(sb1.equalsIgnoreCase(sb1)); [EOL]         assertTrue(sb1.equalsIgnoreCase(sb2)); [EOL]         assertTrue(sb2.equalsIgnoreCase(sb2)); [EOL]          [EOL]         sb1.append("abc"); [EOL]         assertFalse(sb1.equalsIgnoreCase(sb2)); [EOL]          [EOL]         sb2.append("ABC"); [EOL]         assertTrue(sb1.equalsIgnoreCase(sb2)); [EOL]          [EOL]         sb2.clear().append("abc"); [EOL]         assertTrue(sb1.equalsIgnoreCase(sb2)); [EOL]         assertTrue(sb1.equalsIgnoreCase(sb1)); [EOL]         assertTrue(sb2.equalsIgnoreCase(sb2)); [EOL]          [EOL]         sb2.clear().append("aBc"); [EOL]         assertTrue(sb1.equalsIgnoreCase(sb2)); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testEqualsIgnoreCase() { [EOL]         final StrBuilder sb1 = new StrBuilder(); [EOL]         final StrBuilder sb2 = new StrBuilder(); [EOL]         assertTrue(sb1.equalsIgnoreCase(sb1)); [EOL]         assertTrue(sb1.equalsIgnoreCase(sb2)); [EOL]         assertTrue(sb2.equalsIgnoreCase(sb2)); [EOL]          [EOL]         sb1.append("abc"); [EOL]         assertFalse(sb1.equalsIgnoreCase(sb2)); [EOL]          [EOL]         sb2.append("ABC"); [EOL]         assertTrue(sb1.equalsIgnoreCase(sb2)); [EOL]          [EOL]         sb2.clear().append("abc"); [EOL]         assertTrue(sb1.equalsIgnoreCase(sb2)); [EOL]         assertTrue(sb1.equalsIgnoreCase(sb1)); [EOL]         assertTrue(sb2.equalsIgnoreCase(sb2)); [EOL]          [EOL]         sb2.clear().append("aBc"); [EOL]         assertTrue(sb1.equalsIgnoreCase(sb2)); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final StrBuilder sb1 = new StrBuilder(); [EOL]         final StrBuilder sb2 = new StrBuilder(); [EOL]         assertTrue(sb1.equals(sb2)); [EOL]         assertTrue(sb1.equals(sb1)); [EOL]         assertTrue(sb2.equals(sb2)); [EOL]         assertTrue(sb1.equals((Object) sb2)); [EOL]          [EOL]         sb1.append("abc"); [EOL]         assertFalse(sb1.equals(sb2)); [EOL]         assertFalse(sb1.equals((Object) sb2)); [EOL]          [EOL]         sb2.append("ABC"); [EOL]         assertFalse(sb1.equals(sb2)); [EOL]         assertFalse(sb1.equals((Object) sb2)); [EOL]          [EOL]         sb2.clear().append("abc"); [EOL]         assertTrue(sb1.equals(sb2)); [EOL]         assertTrue(sb1.equals((Object) sb2)); [EOL]          [EOL]         assertFalse(sb1.equals(Integer.valueOf(1))); [EOL]         assertFalse(sb1.equals("abc")); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final StrBuilder sb1 = new StrBuilder(); [EOL]         final StrBuilder sb2 = new StrBuilder(); [EOL]         assertTrue(sb1.equals(sb2)); [EOL]         assertTrue(sb1.equals(sb1)); [EOL]         assertTrue(sb2.equals(sb2)); [EOL]         assertTrue(sb1.equals((Object) sb2)); [EOL]          [EOL]         sb1.append("abc"); [EOL]         assertFalse(sb1.equals(sb2)); [EOL]         assertFalse(sb1.equals((Object) sb2)); [EOL]          [EOL]         sb2.append("ABC"); [EOL]         assertFalse(sb1.equals(sb2)); [EOL]         assertFalse(sb1.equals((Object) sb2)); [EOL]          [EOL]         sb2.clear().append("abc"); [EOL]         assertTrue(sb1.equals(sb2)); [EOL]         assertTrue(sb1.equals((Object) sb2)); [EOL]          [EOL]         assertFalse(sb1.equals(Integer.valueOf(1))); [EOL]         assertFalse(sb1.equals("abc")); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAsReader() throws Exception { [EOL]         final StrBuilder sb = new StrBuilder("some text"); [EOL]         Reader reader = sb.asReader(); [EOL]         assertTrue(reader.ready()); [EOL]         final char[] buf = new char[40]; [EOL]         assertEquals(9, reader.read(buf)); [EOL]         assertEquals("some text", new String(buf, 0, 9)); [EOL]          [EOL]         assertEquals(-1, reader.read()); [EOL]         assertFalse(reader.ready()); [EOL]         assertEquals(0, reader.skip(2)); [EOL]         assertEquals(0, reader.skip(-1)); [EOL]          [EOL]         assertTrue(reader.markSupported()); [EOL]         reader = sb.asReader(); [EOL]         assertEquals('s', reader.read()); [EOL]         reader.mark(-1); [EOL]         char[] array = new char[3]; [EOL]         assertEquals(3, reader.read(array, 0, 3)); [EOL]         assertEquals('o', array[0]); [EOL]         assertEquals('m', array[1]); [EOL]         assertEquals('e', array[2]); [EOL]         reader.reset(); [EOL]         assertEquals(1, reader.read(array, 1, 1)); [EOL]         assertEquals('o', array[0]); [EOL]         assertEquals('o', array[1]); [EOL]         assertEquals('e', array[2]); [EOL]         assertEquals(2, reader.skip(2)); [EOL]         assertEquals(' ', reader.read()); [EOL]          [EOL]         assertTrue(reader.ready()); [EOL]         reader.close(); [EOL]         assertTrue(reader.ready()); [EOL]          [EOL]         reader = sb.asReader(); [EOL]         array = new char[3]; [EOL]         try { [EOL]             reader.read(array, -1, 0); [EOL]             fail(); [EOL]         } catch (final IndexOutOfBoundsException ex) {} [EOL]         try { [EOL]             reader.read(array, 0, -1); [EOL]             fail(); [EOL]         } catch (final IndexOutOfBoundsException ex) {} [EOL]         try { [EOL]             reader.read(array, 100, 1); [EOL]             fail(); [EOL]         } catch (final IndexOutOfBoundsException ex) {} [EOL]         try { [EOL]             reader.read(array, 0, 100); [EOL]             fail(); [EOL]         } catch (final IndexOutOfBoundsException ex) {} [EOL]         try { [EOL]             reader.read(array, Integer.MAX_VALUE, Integer.MAX_VALUE); [EOL]             fail(); [EOL]         } catch (final IndexOutOfBoundsException ex) {} [EOL]          [EOL]         assertEquals(0, reader.read(array, 0, 0)); [EOL]         assertEquals(0, array[0]); [EOL]         assertEquals(0, array[1]); [EOL]         assertEquals(0, array[2]); [EOL]          [EOL]         reader.skip(9); [EOL]         assertEquals(-1, reader.read(array, 0, 1)); [EOL]          [EOL]         reader.reset(); [EOL]         array = new char[30]; [EOL]         assertEquals(9, reader.read(array, 0, 30)); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAsReader() throws Exception { [EOL]         final StrBuilder sb = new StrBuilder("some text"); [EOL]         Reader reader = sb.asReader(); [EOL]         assertTrue(reader.ready()); [EOL]         final char[] buf = new char[40]; [EOL]         assertEquals(9, reader.read(buf)); [EOL]         assertEquals("some text", new String(buf, 0, 9)); [EOL]          [EOL]         assertEquals(-1, reader.read()); [EOL]         assertFalse(reader.ready()); [EOL]         assertEquals(0, reader.skip(2)); [EOL]         assertEquals(0, reader.skip(-1)); [EOL]          [EOL]         assertTrue(reader.markSupported()); [EOL]         reader = sb.asReader(); [EOL]         assertEquals('s', reader.read()); [EOL]         reader.mark(-1); [EOL]         char[] array = new char[3]; [EOL]         assertEquals(3, reader.read(array, 0, 3)); [EOL]         assertEquals('o', array[0]); [EOL]         assertEquals('m', array[1]); [EOL]         assertEquals('e', array[2]); [EOL]         reader.reset(); [EOL]         assertEquals(1, reader.read(array, 1, 1)); [EOL]         assertEquals('o', array[0]); [EOL]         assertEquals('o', array[1]); [EOL]         assertEquals('e', array[2]); [EOL]         assertEquals(2, reader.skip(2)); [EOL]         assertEquals(' ', reader.read()); [EOL]          [EOL]         assertTrue(reader.ready()); [EOL]         reader.close(); [EOL]         assertTrue(reader.ready()); [EOL]          [EOL]         reader = sb.asReader(); [EOL]         array = new char[3]; [EOL]         try { [EOL]             reader.read(array, -1, 0); [EOL]             fail(); [EOL]         } catch (final IndexOutOfBoundsException ex) {} [EOL]         try { [EOL]             reader.read(array, 0, -1); [EOL]             fail(); [EOL]         } catch (final IndexOutOfBoundsException ex) {} [EOL]         try { [EOL]             reader.read(array, 100, 1); [EOL]             fail(); [EOL]         } catch (final IndexOutOfBoundsException ex) {} [EOL]         try { [EOL]             reader.read(array, 0, 100); [EOL]             fail(); [EOL]         } catch (final IndexOutOfBoundsException ex) {} [EOL]         try { [EOL]             reader.read(array, Integer.MAX_VALUE, Integer.MAX_VALUE); [EOL]             fail(); [EOL]         } catch (final IndexOutOfBoundsException ex) {} [EOL]          [EOL]         assertEquals(0, reader.read(array, 0, 0)); [EOL]         assertEquals(0, array[0]); [EOL]         assertEquals(0, array[1]); [EOL]         assertEquals(0, array[2]); [EOL]          [EOL]         reader.skip(9); [EOL]         assertEquals(-1, reader.read(array, 0, 1)); [EOL]          [EOL]         reader.reset(); [EOL]         array = new char[30]; [EOL]         assertEquals(9, reader.read(array, 0, 30)); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testReplaceEmptyKeys() { [EOL]         doTestReplace("The ${} jumps over the lazy dog.", "The ${} jumps over the ${target}.", true); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests replace creates output same as input. [EOL]      */ [EOL]
@Test [EOL]     public void testReplaceEmptyKeys() { [EOL]         doTestReplace("The ${} jumps over the lazy dog.", "The ${} jumps over the ${target}.", true); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests replace creates output same as input. [EOL]      */ [EOL]
@Test [EOL]     public void testReplaceInVariable() { [EOL]         values.put("animal.1", "fox"); [EOL]         values.put("animal.2", "mouse"); [EOL]         values.put("species", "2"); [EOL]         final StrSubstitutor sub = new StrSubstitutor(values); [EOL]         sub.setEnableSubstitutionInVariables(true); [EOL]         assertEquals( [EOL]                 "Wrong result (1)", [EOL]                 "The mouse jumps over the lazy dog.", [EOL]                 sub.replace("The ${animal.${species}} jumps over the ${target}.")); [EOL]         values.put("species", "1"); [EOL]         assertEquals( [EOL]                 "Wrong result (2)", [EOL]                 "The fox jumps over the lazy dog.", [EOL]                 sub.replace("The ${animal.${species}} jumps over the ${target}.")); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether substitution in variable names is disabled per default. [EOL]      */ [EOL]
@Test [EOL]     public void testReplaceInVariable() { [EOL]         values.put("animal.1", "fox"); [EOL]         values.put("animal.2", "mouse"); [EOL]         values.put("species", "2"); [EOL]         final StrSubstitutor sub = new StrSubstitutor(values); [EOL]         sub.setEnableSubstitutionInVariables(true); [EOL]         assertEquals( [EOL]                 "Wrong result (1)", [EOL]                 "The mouse jumps over the lazy dog.", [EOL]                 sub.replace("The ${animal.${species}} jumps over the ${target}.")); [EOL]         values.put("species", "1"); [EOL]         assertEquals( [EOL]                 "Wrong result (2)", [EOL]                 "The fox jumps over the lazy dog.", [EOL]                 sub.replace("The ${animal.${species}} jumps over the ${target}.")); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether substitution in variable names is disabled per default. [EOL]      */ [EOL]
@Test [EOL]     public void testReplaceInVariable() { [EOL]         values.put("animal.1", "fox"); [EOL]         values.put("animal.2", "mouse"); [EOL]         values.put("species", "2"); [EOL]         final StrSubstitutor sub = new StrSubstitutor(values); [EOL]         sub.setEnableSubstitutionInVariables(true); [EOL]         assertEquals( [EOL]                 "Wrong result (1)", [EOL]                 "The mouse jumps over the lazy dog.", [EOL]                 sub.replace("The ${animal.${species}} jumps over the ${target}.")); [EOL]         values.put("species", "1"); [EOL]         assertEquals( [EOL]                 "Wrong result (2)", [EOL]                 "The fox jumps over the lazy dog.", [EOL]                 sub.replace("The ${animal.${species}} jumps over the ${target}.")); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether substitution in variable names is disabled per default. [EOL]      */ [EOL]
@Test [EOL]     public void testReplaceInVariable() { [EOL]         values.put("animal.1", "fox"); [EOL]         values.put("animal.2", "mouse"); [EOL]         values.put("species", "2"); [EOL]         final StrSubstitutor sub = new StrSubstitutor(values); [EOL]         sub.setEnableSubstitutionInVariables(true); [EOL]         assertEquals( [EOL]                 "Wrong result (1)", [EOL]                 "The mouse jumps over the lazy dog.", [EOL]                 sub.replace("The ${animal.${species}} jumps over the ${target}.")); [EOL]         values.put("species", "1"); [EOL]         assertEquals( [EOL]                 "Wrong result (2)", [EOL]                 "The fox jumps over the lazy dog.", [EOL]                 sub.replace("The ${animal.${species}} jumps over the ${target}.")); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether substitution in variable names is disabled per default. [EOL]      */ [EOL]
@Test [EOL]     public void testReplaceInVariable() { [EOL]         values.put("animal.1", "fox"); [EOL]         values.put("animal.2", "mouse"); [EOL]         values.put("species", "2"); [EOL]         final StrSubstitutor sub = new StrSubstitutor(values); [EOL]         sub.setEnableSubstitutionInVariables(true); [EOL]         assertEquals( [EOL]                 "Wrong result (1)", [EOL]                 "The mouse jumps over the lazy dog.", [EOL]                 sub.replace("The ${animal.${species}} jumps over the ${target}.")); [EOL]         values.put("species", "1"); [EOL]         assertEquals( [EOL]                 "Wrong result (2)", [EOL]                 "The fox jumps over the lazy dog.", [EOL]                 sub.replace("The ${animal.${species}} jumps over the ${target}.")); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether substitution in variable names is disabled per default. [EOL]      */ [EOL]
@Test [EOL]     public void testCyclicReplacement() { [EOL]         final Map<String, String> map = new HashMap<String, String>(); [EOL]         map.put("animal", "${critter}"); [EOL]         map.put("target", "${pet}"); [EOL]         map.put("pet", "${petCharacteristic} dog"); [EOL]         map.put("petCharacteristic", "lazy"); [EOL]         map.put("critter", "${critterSpeed} ${critterColor} ${critterType}"); [EOL]         map.put("critterSpeed", "quick"); [EOL]         map.put("critterColor", "brown"); [EOL]         map.put("critterType", "${animal}"); [EOL]         final StrSubstitutor sub = new StrSubstitutor(map); [EOL]         try { [EOL]             sub.replace("The ${animal} jumps over the ${target}."); [EOL]             fail("Cyclic replacement was not detected!"); [EOL]         } catch (final IllegalStateException ex) { [EOL]             // expected [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests interpolation with weird boundary patterns. [EOL]      */ [EOL]
@Test [EOL]     public void testCyclicReplacement() { [EOL]         final Map<String, String> map = new HashMap<String, String>(); [EOL]         map.put("animal", "${critter}"); [EOL]         map.put("target", "${pet}"); [EOL]         map.put("pet", "${petCharacteristic} dog"); [EOL]         map.put("petCharacteristic", "lazy"); [EOL]         map.put("critter", "${critterSpeed} ${critterColor} ${critterType}"); [EOL]         map.put("critterSpeed", "quick"); [EOL]         map.put("critterColor", "brown"); [EOL]         map.put("critterType", "${animal}"); [EOL]         final StrSubstitutor sub = new StrSubstitutor(map); [EOL]         try { [EOL]             sub.replace("The ${animal} jumps over the ${target}."); [EOL]             fail("Cyclic replacement was not detected!"); [EOL]         } catch (final IllegalStateException ex) { [EOL]             // expected [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests interpolation with weird boundary patterns. [EOL]      */ [EOL]
@Test [EOL]     public void testCyclicReplacement() { [EOL]         final Map<String, String> map = new HashMap<String, String>(); [EOL]         map.put("animal", "${critter}"); [EOL]         map.put("target", "${pet}"); [EOL]         map.put("pet", "${petCharacteristic} dog"); [EOL]         map.put("petCharacteristic", "lazy"); [EOL]         map.put("critter", "${critterSpeed} ${critterColor} ${critterType}"); [EOL]         map.put("critterSpeed", "quick"); [EOL]         map.put("critterColor", "brown"); [EOL]         map.put("critterType", "${animal}"); [EOL]         final StrSubstitutor sub = new StrSubstitutor(map); [EOL]         try { [EOL]             sub.replace("The ${animal} jumps over the ${target}."); [EOL]             fail("Cyclic replacement was not detected!"); [EOL]         } catch (final IllegalStateException ex) { [EOL]             // expected [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests interpolation with weird boundary patterns. [EOL]      */ [EOL]
@Test [EOL]     public void testCyclicReplacement() { [EOL]         final Map<String, String> map = new HashMap<String, String>(); [EOL]         map.put("animal", "${critter}"); [EOL]         map.put("target", "${pet}"); [EOL]         map.put("pet", "${petCharacteristic} dog"); [EOL]         map.put("petCharacteristic", "lazy"); [EOL]         map.put("critter", "${critterSpeed} ${critterColor} ${critterType}"); [EOL]         map.put("critterSpeed", "quick"); [EOL]         map.put("critterColor", "brown"); [EOL]         map.put("critterType", "${animal}"); [EOL]         final StrSubstitutor sub = new StrSubstitutor(map); [EOL]         try { [EOL]             sub.replace("The ${animal} jumps over the ${target}."); [EOL]             fail("Cyclic replacement was not detected!"); [EOL]         } catch (final IllegalStateException ex) { [EOL]             // expected [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests interpolation with weird boundary patterns. [EOL]      */ [EOL]
@Test [EOL]     public void testCyclicReplacement() { [EOL]         final Map<String, String> map = new HashMap<String, String>(); [EOL]         map.put("animal", "${critter}"); [EOL]         map.put("target", "${pet}"); [EOL]         map.put("pet", "${petCharacteristic} dog"); [EOL]         map.put("petCharacteristic", "lazy"); [EOL]         map.put("critter", "${critterSpeed} ${critterColor} ${critterType}"); [EOL]         map.put("critterSpeed", "quick"); [EOL]         map.put("critterColor", "brown"); [EOL]         map.put("critterType", "${animal}"); [EOL]         final StrSubstitutor sub = new StrSubstitutor(map); [EOL]         try { [EOL]             sub.replace("The ${animal} jumps over the ${target}."); [EOL]             fail("Cyclic replacement was not detected!"); [EOL]         } catch (final IllegalStateException ex) { [EOL]             // expected [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests interpolation with weird boundary patterns. [EOL]      */ [EOL]
@Test [EOL]     public void testCyclicReplacement() { [EOL]         final Map<String, String> map = new HashMap<String, String>(); [EOL]         map.put("animal", "${critter}"); [EOL]         map.put("target", "${pet}"); [EOL]         map.put("pet", "${petCharacteristic} dog"); [EOL]         map.put("petCharacteristic", "lazy"); [EOL]         map.put("critter", "${critterSpeed} ${critterColor} ${critterType}"); [EOL]         map.put("critterSpeed", "quick"); [EOL]         map.put("critterColor", "brown"); [EOL]         map.put("critterType", "${animal}"); [EOL]         final StrSubstitutor sub = new StrSubstitutor(map); [EOL]         try { [EOL]             sub.replace("The ${animal} jumps over the ${target}."); [EOL]             fail("Cyclic replacement was not detected!"); [EOL]         } catch (final IllegalStateException ex) { [EOL]             // expected [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests interpolation with weird boundary patterns. [EOL]      */ [EOL]
@Test [EOL]     public void testGetSetSuffix() { [EOL]         final StrSubstitutor sub = new StrSubstitutor(); [EOL]         assertTrue(sub.getVariableSuffixMatcher() instanceof StrMatcher.StringMatcher); [EOL]         sub.setVariableSuffix('<'); [EOL]         assertTrue(sub.getVariableSuffixMatcher() instanceof StrMatcher.CharMatcher); [EOL]  [EOL]         sub.setVariableSuffix("<<"); [EOL]         assertTrue(sub.getVariableSuffixMatcher() instanceof StrMatcher.StringMatcher); [EOL]         try { [EOL]             sub.setVariableSuffix((String) null); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) { [EOL]             // expected [EOL]         } [EOL]         assertTrue(sub.getVariableSuffixMatcher() instanceof StrMatcher.StringMatcher); [EOL]  [EOL]         final StrMatcher matcher = StrMatcher.commaMatcher(); [EOL]         sub.setVariableSuffixMatcher(matcher); [EOL]         assertSame(matcher, sub.getVariableSuffixMatcher()); [EOL]         try { [EOL]             sub.setVariableSuffixMatcher((StrMatcher) null); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) { [EOL]             // expected [EOL]         } [EOL]         assertSame(matcher, sub.getVariableSuffixMatcher()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]     /** [EOL]      * Tests static. [EOL]      */ [EOL]
@Test [EOL]     public void testMultiLongArray() { [EOL]         final long[][] array1 = new long[2][2]; [EOL]         final long[][] array2 = new long[2][2]; [EOL]         final long[][] array3 = new long[2][3]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]                 array3[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         array3[1][2] = 100; [EOL]         array3[1][2] = 100; [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0); [EOL]         array1[1][1] = 200; [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMultiIntArray() { [EOL]         final int[][] array1 = new int[2][2]; [EOL]         final int[][] array2 = new int[2][2]; [EOL]         final int[][] array3 = new int[2][3]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]                 array3[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         array3[1][2] = 100; [EOL]         array3[1][2] = 100; [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0); [EOL]         array1[1][1] = 200; [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMultiShortArray() { [EOL]         final short[][] array1 = new short[2][2]; [EOL]         final short[][] array2 = new short[2][2]; [EOL]         final short[][] array3 = new short[2][3]; [EOL]         for (short i = 0; i < array1.length; ++i) { [EOL]             for (short j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (short)((i + 1) * (j + 1)); [EOL]                 array2[i][j] = (short)((i + 1) * (j + 1)); [EOL]                 array3[i][j] = (short)((i + 1) * (j + 1)); [EOL]             } [EOL]         } [EOL]         array3[1][2] = 100; [EOL]         array3[1][2] = 100; [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0); [EOL]         array1[1][1] = 200; [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMultiDoubleArray() { [EOL]         final double[][] array1 = new double[2][2]; [EOL]         final double[][] array2 = new double[2][2]; [EOL]         final double[][] array3 = new double[2][3]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]                 array3[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         array3[1][2] = 100; [EOL]         array3[1][2] = 100; [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0); [EOL]         array1[1][1] = 127; [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testByteArrayHiddenByObject() { [EOL]         final byte[] array1 = new byte[2]; [EOL]         array1[0] = 5; [EOL]         array1[1] = 6; [EOL]         final byte[] array2 = new byte[2]; [EOL]         array2[0] = 5; [EOL]         array2[1] = 6; [EOL]         final byte[] array3 = new byte[3]; [EOL]         array3[0] = 5; [EOL]         array3[1] = 6; [EOL]         array3[2] = 7; [EOL]         final Object obj1 = array1; [EOL]         final Object obj2 = array2; [EOL]         final Object obj3 = array3; [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]  [EOL]         array1[1] = 7; [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMultiDoubleArray() { [EOL]         final double[][] array1 = new double[2][2]; [EOL]         final double[][] array2 = new double[2][2]; [EOL]         final double[][] array3 = new double[2][3]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]                 array3[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         array3[1][2] = 100; [EOL]         array3[1][2] = 100; [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0); [EOL]         array1[1][1] = 127; [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMultiDoubleArray() { [EOL]         final double[][] array1 = new double[2][2]; [EOL]         final double[][] array2 = new double[2][2]; [EOL]         final double[][] array3 = new double[2][3]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]                 array3[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         array3[1][2] = 100; [EOL]         array3[1][2] = 100; [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0); [EOL]         array1[1][1] = 127; [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testObjectArrayHiddenByObject() { [EOL]         final TestObject[] array1 = new TestObject[2]; [EOL]         array1[0] = new TestObject(4); [EOL]         array1[1] = new TestObject(5); [EOL]         final TestObject[] array2 = new TestObject[2]; [EOL]         array2[0] = new TestObject(4); [EOL]         array2[1] = new TestObject(5); [EOL]         final TestObject[] array3 = new TestObject[3]; [EOL]         array3[0] = new TestObject(4); [EOL]         array3[1] = new TestObject(5); [EOL]         array3[2] = new TestObject(6); [EOL]          [EOL]         final Object obj1 = array1; [EOL]         final Object obj2 = array2; [EOL]         final Object obj3 = array3; [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]  [EOL]         array1[1] = new TestObject(7); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMultiFloatArray() { [EOL]         final float[][] array1 = new float[2][2]; [EOL]         final float[][] array2 = new float[2][2]; [EOL]         final float[][] array3 = new float[2][3]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]                 array3[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         array3[1][2] = 100; [EOL]         array3[1][2] = 100; [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0); [EOL]         array1[1][1] = 127; [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testObjectArrayHiddenByObject() { [EOL]         final TestObject[] array1 = new TestObject[2]; [EOL]         array1[0] = new TestObject(4); [EOL]         array1[1] = new TestObject(5); [EOL]         final TestObject[] array2 = new TestObject[2]; [EOL]         array2[0] = new TestObject(4); [EOL]         array2[1] = new TestObject(5); [EOL]         final TestObject[] array3 = new TestObject[3]; [EOL]         array3[0] = new TestObject(4); [EOL]         array3[1] = new TestObject(5); [EOL]         array3[2] = new TestObject(6); [EOL]          [EOL]         final Object obj1 = array1; [EOL]         final Object obj2 = array2; [EOL]         final Object obj3 = array3; [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]  [EOL]         array1[1] = new TestObject(7); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMultiBooleanArray() { [EOL]         final boolean[][] array1 = new boolean[2][2]; [EOL]         final boolean[][] array2 = new boolean[2][2]; [EOL]         final boolean[][] array3 = new boolean[2][3]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = i == 1 ^ j == 1; [EOL]                 array2[i][j] = i == 1 ^ j == 1; [EOL]                 array3[i][j] = i == 1 ^ j == 1; [EOL]             } [EOL]         } [EOL]         array3[1][2] = false; [EOL]         array3[1][2] = false; [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0); [EOL]         array1[1][1] = true; [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testObjectArrayHiddenByObject() { [EOL]         final TestObject[] array1 = new TestObject[2]; [EOL]         array1[0] = new TestObject(4); [EOL]         array1[1] = new TestObject(5); [EOL]         final TestObject[] array2 = new TestObject[2]; [EOL]         array2[0] = new TestObject(4); [EOL]         array2[1] = new TestObject(5); [EOL]         final TestObject[] array3 = new TestObject[3]; [EOL]         array3[0] = new TestObject(4); [EOL]         array3[1] = new TestObject(5); [EOL]         array3[2] = new TestObject(6); [EOL]          [EOL]         final Object obj1 = array1; [EOL]         final Object obj2 = array2; [EOL]         final Object obj3 = array3; [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]  [EOL]         array1[1] = new TestObject(7); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testObjectArray() { [EOL]         final TestObject[] obj1 = new TestObject[2]; [EOL]         obj1[0] = new TestObject(4); [EOL]         obj1[1] = new TestObject(5); [EOL]         final TestObject[] obj2 = new TestObject[2]; [EOL]         obj2[0] = new TestObject(4); [EOL]         obj2[1] = new TestObject(5); [EOL]         final TestObject[] obj3 = new TestObject[3]; [EOL]         obj3[0] = new TestObject(4); [EOL]         obj3[1] = new TestObject(5); [EOL]         obj3[2] = new TestObject(6); [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]          [EOL]         obj1[1] = new TestObject(7); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append((Object[]) null, (Object[]) null).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testObjectArray() { [EOL]         final TestObject[] obj1 = new TestObject[2]; [EOL]         obj1[0] = new TestObject(4); [EOL]         obj1[1] = new TestObject(5); [EOL]         final TestObject[] obj2 = new TestObject[2]; [EOL]         obj2[0] = new TestObject(4); [EOL]         obj2[1] = new TestObject(5); [EOL]         final TestObject[] obj3 = new TestObject[3]; [EOL]         obj3[0] = new TestObject(4); [EOL]         obj3[1] = new TestObject(5); [EOL]         obj3[2] = new TestObject(6); [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]          [EOL]         obj1[1] = new TestObject(7); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append((Object[]) null, (Object[]) null).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLongArray() { [EOL]         final long[] obj1 = new long[2]; [EOL]         obj1[0] = 5L; [EOL]         obj1[1] = 6L; [EOL]         final long[] obj2 = new long[2]; [EOL]         obj2[0] = 5L; [EOL]         obj2[1] = 6L; [EOL]         final long[] obj3 = new long[3]; [EOL]         obj3[0] = 5L; [EOL]         obj3[1] = 6L; [EOL]         obj3[2] = 7L; [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]  [EOL]         obj1[1] = 7; [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append((long[]) null, (long[]) null).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLongArray() { [EOL]         final long[] obj1 = new long[2]; [EOL]         obj1[0] = 5L; [EOL]         obj1[1] = 6L; [EOL]         final long[] obj2 = new long[2]; [EOL]         obj2[0] = 5L; [EOL]         obj2[1] = 6L; [EOL]         final long[] obj3 = new long[3]; [EOL]         obj3[0] = 5L; [EOL]         obj3[1] = 6L; [EOL]         obj3[2] = 7L; [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]  [EOL]         obj1[1] = 7; [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append((long[]) null, (long[]) null).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLongArray() { [EOL]         final long[] obj1 = new long[2]; [EOL]         obj1[0] = 5L; [EOL]         obj1[1] = 6L; [EOL]         final long[] obj2 = new long[2]; [EOL]         obj2[0] = 5L; [EOL]         obj2[1] = 6L; [EOL]         final long[] obj3 = new long[3]; [EOL]         obj3[0] = 5L; [EOL]         obj3[1] = 6L; [EOL]         obj3[2] = 7L; [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]  [EOL]         obj1[1] = 7; [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append((long[]) null, (long[]) null).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLongArray() { [EOL]         final long[] obj1 = new long[2]; [EOL]         obj1[0] = 5L; [EOL]         obj1[1] = 6L; [EOL]         final long[] obj2 = new long[2]; [EOL]         obj2[0] = 5L; [EOL]         obj2[1] = 6L; [EOL]         final long[] obj3 = new long[3]; [EOL]         obj3[0] = 5L; [EOL]         obj3[1] = 6L; [EOL]         obj3[2] = 7L; [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]  [EOL]         obj1[1] = 7; [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append((long[]) null, (long[]) null).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIntArray() { [EOL]         final int[] obj1 = new int[2]; [EOL]         obj1[0] = 5; [EOL]         obj1[1] = 6; [EOL]         final int[] obj2 = new int[2]; [EOL]         obj2[0] = 5; [EOL]         obj2[1] = 6; [EOL]         final int[] obj3 = new int[3]; [EOL]         obj3[0] = 5; [EOL]         obj3[1] = 6; [EOL]         obj3[2] = 7; [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]  [EOL]         obj1[1] = 7; [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append((int[]) null, (int[]) null).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIntArray() { [EOL]         final int[] obj1 = new int[2]; [EOL]         obj1[0] = 5; [EOL]         obj1[1] = 6; [EOL]         final int[] obj2 = new int[2]; [EOL]         obj2[0] = 5; [EOL]         obj2[1] = 6; [EOL]         final int[] obj3 = new int[3]; [EOL]         obj3[0] = 5; [EOL]         obj3[1] = 6; [EOL]         obj3[2] = 7; [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]  [EOL]         obj1[1] = 7; [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append((int[]) null, (int[]) null).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMultiIntArray() { [EOL]         final int[][] array1 = new int[2][2]; [EOL]         final int[][] array2 = new int[2][2]; [EOL]         final int[][] array3 = new int[2][3]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]                 array3[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         array3[1][2] = 100; [EOL]         array3[1][2] = 100; [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0); [EOL]         array1[1][1] = 200; [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMultiIntArray() { [EOL]         final int[][] array1 = new int[2][2]; [EOL]         final int[][] array2 = new int[2][2]; [EOL]         final int[][] array3 = new int[2][3]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]                 array3[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         array3[1][2] = 100; [EOL]         array3[1][2] = 100; [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0); [EOL]         array1[1][1] = 200; [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMultiIntArray() { [EOL]         final int[][] array1 = new int[2][2]; [EOL]         final int[][] array2 = new int[2][2]; [EOL]         final int[][] array3 = new int[2][3]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]                 array3[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         array3[1][2] = 100; [EOL]         array3[1][2] = 100; [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0); [EOL]         array1[1][1] = 200; [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testShortArray() { [EOL]         final short[] obj1 = new short[2]; [EOL]         obj1[0] = 5; [EOL]         obj1[1] = 6; [EOL]         final short[] obj2 = new short[2]; [EOL]         obj2[0] = 5; [EOL]         obj2[1] = 6; [EOL]         final short[] obj3 = new short[3]; [EOL]         obj3[0] = 5; [EOL]         obj3[1] = 6; [EOL]         obj3[2] = 7; [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]  [EOL]         obj1[1] = 7; [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append((short[]) null, (short[]) null).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testShortArray() { [EOL]         final short[] obj1 = new short[2]; [EOL]         obj1[0] = 5; [EOL]         obj1[1] = 6; [EOL]         final short[] obj2 = new short[2]; [EOL]         obj2[0] = 5; [EOL]         obj2[1] = 6; [EOL]         final short[] obj3 = new short[3]; [EOL]         obj3[0] = 5; [EOL]         obj3[1] = 6; [EOL]         obj3[2] = 7; [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]  [EOL]         obj1[1] = 7; [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append((short[]) null, (short[]) null).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testCharArray() { [EOL]         final char[] obj1 = new char[2]; [EOL]         obj1[0] = 5; [EOL]         obj1[1] = 6; [EOL]         final char[] obj2 = new char[2]; [EOL]         obj2[0] = 5; [EOL]         obj2[1] = 6; [EOL]         final char[] obj3 = new char[3]; [EOL]         obj3[0] = 5; [EOL]         obj3[1] = 6; [EOL]         obj3[2] = 7; [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]  [EOL]         obj1[1] = 7; [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append((char[]) null, (char[]) null).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testCharArray() { [EOL]         final char[] obj1 = new char[2]; [EOL]         obj1[0] = 5; [EOL]         obj1[1] = 6; [EOL]         final char[] obj2 = new char[2]; [EOL]         obj2[0] = 5; [EOL]         obj2[1] = 6; [EOL]         final char[] obj3 = new char[3]; [EOL]         obj3[0] = 5; [EOL]         obj3[1] = 6; [EOL]         obj3[2] = 7; [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]  [EOL]         obj1[1] = 7; [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append((char[]) null, (char[]) null).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testCharArray() { [EOL]         final char[] obj1 = new char[2]; [EOL]         obj1[0] = 5; [EOL]         obj1[1] = 6; [EOL]         final char[] obj2 = new char[2]; [EOL]         obj2[0] = 5; [EOL]         obj2[1] = 6; [EOL]         final char[] obj3 = new char[3]; [EOL]         obj3[0] = 5; [EOL]         obj3[1] = 6; [EOL]         obj3[2] = 7; [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]  [EOL]         obj1[1] = 7; [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append((char[]) null, (char[]) null).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testCharArray() { [EOL]         final char[] obj1 = new char[2]; [EOL]         obj1[0] = 5; [EOL]         obj1[1] = 6; [EOL]         final char[] obj2 = new char[2]; [EOL]         obj2[0] = 5; [EOL]         obj2[1] = 6; [EOL]         final char[] obj3 = new char[3]; [EOL]         obj3[0] = 5; [EOL]         obj3[1] = 6; [EOL]         obj3[2] = 7; [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]  [EOL]         obj1[1] = 7; [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append((char[]) null, (char[]) null).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testByteArray() { [EOL]         final byte[] obj1 = new byte[2]; [EOL]         obj1[0] = 5; [EOL]         obj1[1] = 6; [EOL]         final byte[] obj2 = new byte[2]; [EOL]         obj2[0] = 5; [EOL]         obj2[1] = 6; [EOL]         final byte[] obj3 = new byte[3]; [EOL]         obj3[0] = 5; [EOL]         obj3[1] = 6; [EOL]         obj3[2] = 7; [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]  [EOL]         obj1[1] = 7; [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append((byte[]) null, (byte[]) null).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testByteArray() { [EOL]         final byte[] obj1 = new byte[2]; [EOL]         obj1[0] = 5; [EOL]         obj1[1] = 6; [EOL]         final byte[] obj2 = new byte[2]; [EOL]         obj2[0] = 5; [EOL]         obj2[1] = 6; [EOL]         final byte[] obj3 = new byte[3]; [EOL]         obj3[0] = 5; [EOL]         obj3[1] = 6; [EOL]         obj3[2] = 7; [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]  [EOL]         obj1[1] = 7; [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append((byte[]) null, (byte[]) null).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testByteArray() { [EOL]         final byte[] obj1 = new byte[2]; [EOL]         obj1[0] = 5; [EOL]         obj1[1] = 6; [EOL]         final byte[] obj2 = new byte[2]; [EOL]         obj2[0] = 5; [EOL]         obj2[1] = 6; [EOL]         final byte[] obj3 = new byte[3]; [EOL]         obj3[0] = 5; [EOL]         obj3[1] = 6; [EOL]         obj3[2] = 7; [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]  [EOL]         obj1[1] = 7; [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append((byte[]) null, (byte[]) null).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testByteArray() { [EOL]         final byte[] obj1 = new byte[2]; [EOL]         obj1[0] = 5; [EOL]         obj1[1] = 6; [EOL]         final byte[] obj2 = new byte[2]; [EOL]         obj2[0] = 5; [EOL]         obj2[1] = 6; [EOL]         final byte[] obj3 = new byte[3]; [EOL]         obj3[0] = 5; [EOL]         obj3[1] = 6; [EOL]         obj3[2] = 7; [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]  [EOL]         obj1[1] = 7; [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append((byte[]) null, (byte[]) null).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMultiDoubleArray() { [EOL]         final double[][] array1 = new double[2][2]; [EOL]         final double[][] array2 = new double[2][2]; [EOL]         final double[][] array3 = new double[2][3]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]                 array3[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         array3[1][2] = 100; [EOL]         array3[1][2] = 100; [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0); [EOL]         array1[1][1] = 127; [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMultiDoubleArray() { [EOL]         final double[][] array1 = new double[2][2]; [EOL]         final double[][] array2 = new double[2][2]; [EOL]         final double[][] array3 = new double[2][3]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]                 array3[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         array3[1][2] = 100; [EOL]         array3[1][2] = 100; [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0); [EOL]         array1[1][1] = 127; [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMultiDoubleArray() { [EOL]         final double[][] array1 = new double[2][2]; [EOL]         final double[][] array2 = new double[2][2]; [EOL]         final double[][] array3 = new double[2][3]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]                 array3[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         array3[1][2] = 100; [EOL]         array3[1][2] = 100; [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0); [EOL]         array1[1][1] = 127; [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testFloatArray() { [EOL]         final float[] obj1 = new float[2]; [EOL]         obj1[0] = 5; [EOL]         obj1[1] = 6; [EOL]         final float[] obj2 = new float[2]; [EOL]         obj2[0] = 5; [EOL]         obj2[1] = 6; [EOL]         final float[] obj3 = new float[3]; [EOL]         obj3[0] = 5; [EOL]         obj3[1] = 6; [EOL]         obj3[2] = 7; [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]  [EOL]         obj1[1] = 7; [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append((float[]) null, (float[]) null).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testFloatArray() { [EOL]         final float[] obj1 = new float[2]; [EOL]         obj1[0] = 5; [EOL]         obj1[1] = 6; [EOL]         final float[] obj2 = new float[2]; [EOL]         obj2[0] = 5; [EOL]         obj2[1] = 6; [EOL]         final float[] obj3 = new float[3]; [EOL]         obj3[0] = 5; [EOL]         obj3[1] = 6; [EOL]         obj3[2] = 7; [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]  [EOL]         obj1[1] = 7; [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append((float[]) null, (float[]) null).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMultiFloatArray() { [EOL]         final float[][] array1 = new float[2][2]; [EOL]         final float[][] array2 = new float[2][2]; [EOL]         final float[][] array3 = new float[2][3]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]                 array3[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         array3[1][2] = 100; [EOL]         array3[1][2] = 100; [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0); [EOL]         array1[1][1] = 127; [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMultiFloatArray() { [EOL]         final float[][] array1 = new float[2][2]; [EOL]         final float[][] array2 = new float[2][2]; [EOL]         final float[][] array3 = new float[2][3]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]                 array3[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         array3[1][2] = 100; [EOL]         array3[1][2] = 100; [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0); [EOL]         array1[1][1] = 127; [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMultiFloatArray() { [EOL]         final float[][] array1 = new float[2][2]; [EOL]         final float[][] array2 = new float[2][2]; [EOL]         final float[][] array3 = new float[2][3]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]                 array3[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         array3[1][2] = 100; [EOL]         array3[1][2] = 100; [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0); [EOL]         array1[1][1] = 127; [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testBooleanArray() { [EOL]         final boolean[] obj1 = new boolean[2]; [EOL]         obj1[0] = true; [EOL]         obj1[1] = false; [EOL]         final boolean[] obj2 = new boolean[2]; [EOL]         obj2[0] = true; [EOL]         obj2[1] = false; [EOL]         final boolean[] obj3 = new boolean[3]; [EOL]         obj3[0] = true; [EOL]         obj3[1] = false; [EOL]         obj3[2] = true; [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]  [EOL]         obj1[1] = true; [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append((boolean[]) null, (boolean[]) null).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testBooleanArray() { [EOL]         final boolean[] obj1 = new boolean[2]; [EOL]         obj1[0] = true; [EOL]         obj1[1] = false; [EOL]         final boolean[] obj2 = new boolean[2]; [EOL]         obj2[0] = true; [EOL]         obj2[1] = false; [EOL]         final boolean[] obj3 = new boolean[3]; [EOL]         obj3[0] = true; [EOL]         obj3[1] = false; [EOL]         obj3[2] = true; [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]  [EOL]         obj1[1] = true; [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append((boolean[]) null, (boolean[]) null).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testBooleanArray() { [EOL]         final boolean[] obj1 = new boolean[2]; [EOL]         obj1[0] = true; [EOL]         obj1[1] = false; [EOL]         final boolean[] obj2 = new boolean[2]; [EOL]         obj2[0] = true; [EOL]         obj2[1] = false; [EOL]         final boolean[] obj3 = new boolean[3]; [EOL]         obj3[0] = true; [EOL]         obj3[1] = false; [EOL]         obj3[2] = true; [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]  [EOL]         obj1[1] = true; [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append((boolean[]) null, (boolean[]) null).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testBooleanArray() { [EOL]         final boolean[] obj1 = new boolean[2]; [EOL]         obj1[0] = true; [EOL]         obj1[1] = false; [EOL]         final boolean[] obj2 = new boolean[2]; [EOL]         obj2[0] = true; [EOL]         obj2[1] = false; [EOL]         final boolean[] obj3 = new boolean[3]; [EOL]         obj3[0] = true; [EOL]         obj3[1] = false; [EOL]         obj3[2] = true; [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]  [EOL]         obj1[1] = true; [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append((boolean[]) null, (boolean[]) null).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testBooleanArray() { [EOL]         final boolean[] obj1 = new boolean[2]; [EOL]         obj1[0] = true; [EOL]         obj1[1] = false; [EOL]         final boolean[] obj2 = new boolean[2]; [EOL]         obj2[0] = true; [EOL]         obj2[1] = false; [EOL]         final boolean[] obj3 = new boolean[3]; [EOL]         obj3[0] = true; [EOL]         obj3[1] = false; [EOL]         obj3[2] = true; [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]  [EOL]         obj1[1] = true; [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append((boolean[]) null, (boolean[]) null).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testInitializeEx() throws ConcurrentException { [EOL]         final ChildBackgroundInitializer child = new ChildBackgroundInitializer(); [EOL]         child.ex = new Exception(); [EOL]         initializer.addInitializer(CHILD_INIT, child); [EOL]         initializer.start(); [EOL]         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer [EOL]                 .get(); [EOL]         assertTrue("No exception flag", res.isException(CHILD_INIT)); [EOL]         assertNull("Got a results object", res.getResultObject(CHILD_INIT)); [EOL]         final ConcurrentException cex = res.getException(CHILD_INIT); [EOL]         assertEquals("Wrong cause", child.ex, cex.getCause()); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the isSuccessful() method of the result object if no child [EOL]      * initializer has thrown an exception. [EOL]      */ [EOL]
@Test(expected = NoSuchElementException.class) [EOL]     public void testResultGetInitializerUnknown() throws ConcurrentException { [EOL]         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize(); [EOL]         res.getInitializer("unknown"); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tries to query the results of an unknown child initializer from the [EOL]      * results object. This should cause an exception. [EOL]      */ [EOL]
@Test(expected = NoSuchElementException.class) [EOL]     public void testResultGetInitializerUnknown() throws ConcurrentException { [EOL]         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize(); [EOL]         res.getInitializer("unknown"); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tries to query the results of an unknown child initializer from the [EOL]      * results object. This should cause an exception. [EOL]      */ [EOL]
@Test(expected = NoSuchElementException.class) [EOL]     public void testResultGetInitializerUnknown() throws ConcurrentException { [EOL]         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize(); [EOL]         res.getInitializer("unknown"); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tries to query the results of an unknown child initializer from the [EOL]      * results object. This should cause an exception. [EOL]      */ [EOL]
@Test [EOL]     public void testBelow() { [EOL]         final UnicodeEscaper ue = UnicodeEscaper.below('F'); [EOL]  [EOL]         final String input = "ADFGZ"; [EOL]         final String result = ue.translate(input); [EOL]         assertEquals("Failed to escape Unicode characters via the below method", "\\u0041\\u0044FGZ", result); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testBelow() { [EOL]         final UnicodeEscaper ue = UnicodeEscaper.below('F'); [EOL]  [EOL]         final String input = "ADFGZ"; [EOL]         final String result = ue.translate(input); [EOL]         assertEquals("Failed to escape Unicode characters via the below method", "\\u0041\\u0044FGZ", result); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testAbove() { [EOL]         final UnicodeEscaper ue = UnicodeEscaper.above('F'); [EOL]  [EOL]         final String input = "ADFGZ"; [EOL]         final String result = ue.translate(input); [EOL]         assertEquals("Failed to escape Unicode characters via the above method", "ADF\\u0047\\u005A", result); [EOL]     } [EOL] } [EOL]
@Test [EOL]     public void testAbove() { [EOL]         final UnicodeEscaper ue = UnicodeEscaper.above('F'); [EOL]  [EOL]         final String input = "ADFGZ"; [EOL]         final String result = ue.translate(input); [EOL]         assertEquals("Failed to escape Unicode characters via the above method", "ADF\\u0047\\u005A", result); [EOL]     } [EOL] } [EOL]
@Test [EOL]     public void testAbove() { [EOL]         final UnicodeEscaper ue = UnicodeEscaper.above('F'); [EOL]  [EOL]         final String input = "ADFGZ"; [EOL]         final String result = ue.translate(input); [EOL]         assertEquals("Failed to escape Unicode characters via the above method", "ADF\\u0047\\u005A", result); [EOL]     } [EOL] } [EOL]
@Test [EOL]     public void testAbove() { [EOL]         final UnicodeEscaper ue = UnicodeEscaper.above('F'); [EOL]  [EOL]         final String input = "ADFGZ"; [EOL]         final String result = ue.translate(input); [EOL]         assertEquals("Failed to escape Unicode characters via the above method", "ADF\\u0047\\u005A", result); [EOL]     } [EOL] } [EOL]
@Test [EOL]     public void testBetween() { [EOL]         final UnicodeEscaper ue = UnicodeEscaper.between('F', 'L'); [EOL]  [EOL]         final String input = "ADFGZ"; [EOL]         final String result = ue.translate(input); [EOL]         assertEquals("Failed to escape Unicode characters via the between method", "AD\\u0046\\u0047Z", result); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testBetween() { [EOL]         final UnicodeEscaper ue = UnicodeEscaper.between('F', 'L'); [EOL]  [EOL]         final String input = "ADFGZ"; [EOL]         final String result = ue.translate(input); [EOL]         assertEquals("Failed to escape Unicode characters via the between method", "AD\\u0046\\u0047Z", result); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testBetween() { [EOL]         final UnicodeEscaper ue = UnicodeEscaper.between('F', 'L'); [EOL]  [EOL]         final String input = "ADFGZ"; [EOL]         final String result = ue.translate(input); [EOL]         assertEquals("Failed to escape Unicode characters via the between method", "AD\\u0046\\u0047Z", result); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testBetween() { [EOL]         final UnicodeEscaper ue = UnicodeEscaper.between('F', 'L'); [EOL]  [EOL]         final String input = "ADFGZ"; [EOL]         final String result = ue.translate(input); [EOL]         assertEquals("Failed to escape Unicode characters via the between method", "AD\\u0046\\u0047Z", result); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testBetween() { [EOL]         final UnicodeEscaper ue = UnicodeEscaper.between('F', 'L'); [EOL]  [EOL]         final String input = "ADFGZ"; [EOL]         final String result = ue.translate(input); [EOL]         assertEquals("Failed to escape Unicode characters via the between method", "AD\\u0046\\u0047Z", result); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEscapeSurrogatePairsLang858() throws Exception { [EOL]         assertEquals("\\uDBFF\\uDFFD", StringEscapeUtils.escapeJava("\uDBFF\uDFFD"));       //fail LANG-858 [EOL]         assertEquals("\\uDBFF\\uDFFD", StringEscapeUtils.escapeEcmaScript("\uDBFF\uDFFD")); //fail LANG-858 [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testBetween() { [EOL]         final UnicodeEscaper ue = UnicodeEscaper.between('F', 'L'); [EOL]  [EOL]         final String input = "ADFGZ"; [EOL]         final String result = ue.translate(input); [EOL]         assertEquals("Failed to escape Unicode characters via the between method", "AD\\u0046\\u0047Z", result); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEscapeJava() throws IOException { [EOL]         assertEquals(null, StringEscapeUtils.escapeJava(null)); [EOL]         try { [EOL]             StringEscapeUtils.ESCAPE_JAVA.translate(null, null); [EOL]             fail(); [EOL]         } catch (final IOException ex) { [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) { [EOL]         } [EOL]         try { [EOL]             StringEscapeUtils.ESCAPE_JAVA.translate("", null); [EOL]             fail(); [EOL]         } catch (final IOException ex) { [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) { [EOL]         } [EOL]          [EOL]         assertEscapeJava("empty string", "", ""); [EOL]         assertEscapeJava(FOO, FOO); [EOL]         assertEscapeJava("tab", "\\t", "\t"); [EOL]         assertEscapeJava("backslash", "\\\\", "\\"); [EOL]         assertEscapeJava("single quote should not be escaped", "'", "'"); [EOL]         assertEscapeJava("\\\\\\b\\t\\r", "\\\b\t\r"); [EOL]         assertEscapeJava("\\u1234", "\u1234"); [EOL]         assertEscapeJava("\\u0234", "\u0234"); [EOL]         assertEscapeJava("\\u00EF", "\u00ef"); [EOL]         assertEscapeJava("\\u0001", "\u0001"); [EOL]         assertEscapeJava("Should use capitalized Unicode hex", "\\uABCD", "\uabcd"); [EOL]  [EOL]         assertEscapeJava("He didn't say, \\\"stop!\\\"", [EOL]                 "He didn't say, \"stop!\""); [EOL]         assertEscapeJava("non-breaking space", "This space is non-breaking:" + "\\u00A0", [EOL]                 "This space is non-breaking:\u00a0"); [EOL]         assertEscapeJava("\\uABCD\\u1234\\u012C", [EOL]                 "\uABCD\u1234\u012C"); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests https://issues.apache.org/jira/browse/LANG-421 [EOL]      */ [EOL]
@Test [EOL]     public void testBetween() { [EOL]         final UnicodeEscaper ue = UnicodeEscaper.between('F', 'L'); [EOL]  [EOL]         final String input = "ADFGZ"; [EOL]         final String result = ue.translate(input); [EOL]         assertEquals("Failed to escape Unicode characters via the between method", "AD\\u0046\\u0047Z", result); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEscapeJava() throws IOException { [EOL]         assertEquals(null, StringEscapeUtils.escapeJava(null)); [EOL]         try { [EOL]             StringEscapeUtils.ESCAPE_JAVA.translate(null, null); [EOL]             fail(); [EOL]         } catch (final IOException ex) { [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) { [EOL]         } [EOL]         try { [EOL]             StringEscapeUtils.ESCAPE_JAVA.translate("", null); [EOL]             fail(); [EOL]         } catch (final IOException ex) { [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) { [EOL]         } [EOL]          [EOL]         assertEscapeJava("empty string", "", ""); [EOL]         assertEscapeJava(FOO, FOO); [EOL]         assertEscapeJava("tab", "\\t", "\t"); [EOL]         assertEscapeJava("backslash", "\\\\", "\\"); [EOL]         assertEscapeJava("single quote should not be escaped", "'", "'"); [EOL]         assertEscapeJava("\\\\\\b\\t\\r", "\\\b\t\r"); [EOL]         assertEscapeJava("\\u1234", "\u1234"); [EOL]         assertEscapeJava("\\u0234", "\u0234"); [EOL]         assertEscapeJava("\\u00EF", "\u00ef"); [EOL]         assertEscapeJava("\\u0001", "\u0001"); [EOL]         assertEscapeJava("Should use capitalized Unicode hex", "\\uABCD", "\uabcd"); [EOL]  [EOL]         assertEscapeJava("He didn't say, \\\"stop!\\\"", [EOL]                 "He didn't say, \"stop!\""); [EOL]         assertEscapeJava("non-breaking space", "This space is non-breaking:" + "\\u00A0", [EOL]                 "This space is non-breaking:\u00a0"); [EOL]         assertEscapeJava("\\uABCD\\u1234\\u012C", [EOL]                 "\uABCD\u1234\u012C"); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests https://issues.apache.org/jira/browse/LANG-421 [EOL]      */ [EOL]
@Test [EOL]     public void testBetween() { [EOL]         final UnicodeEscaper ue = UnicodeEscaper.between('F', 'L'); [EOL]  [EOL]         final String input = "ADFGZ"; [EOL]         final String result = ue.translate(input); [EOL]         assertEquals("Failed to escape Unicode characters via the between method", "AD\\u0046\\u0047Z", result); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testBetween() { [EOL]         final UnicodeEscaper ue = UnicodeEscaper.between('F', 'L'); [EOL]  [EOL]         final String input = "ADFGZ"; [EOL]         final String result = ue.translate(input); [EOL]         assertEquals("Failed to escape Unicode characters via the between method", "AD\\u0046\\u0047Z", result); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEscapeJava() throws IOException { [EOL]         assertEquals(null, StringEscapeUtils.escapeJava(null)); [EOL]         try { [EOL]             StringEscapeUtils.ESCAPE_JAVA.translate(null, null); [EOL]             fail(); [EOL]         } catch (final IOException ex) { [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) { [EOL]         } [EOL]         try { [EOL]             StringEscapeUtils.ESCAPE_JAVA.translate("", null); [EOL]             fail(); [EOL]         } catch (final IOException ex) { [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) { [EOL]         } [EOL]          [EOL]         assertEscapeJava("empty string", "", ""); [EOL]         assertEscapeJava(FOO, FOO); [EOL]         assertEscapeJava("tab", "\\t", "\t"); [EOL]         assertEscapeJava("backslash", "\\\\", "\\"); [EOL]         assertEscapeJava("single quote should not be escaped", "'", "'"); [EOL]         assertEscapeJava("\\\\\\b\\t\\r", "\\\b\t\r"); [EOL]         assertEscapeJava("\\u1234", "\u1234"); [EOL]         assertEscapeJava("\\u0234", "\u0234"); [EOL]         assertEscapeJava("\\u00EF", "\u00ef"); [EOL]         assertEscapeJava("\\u0001", "\u0001"); [EOL]         assertEscapeJava("Should use capitalized Unicode hex", "\\uABCD", "\uabcd"); [EOL]  [EOL]         assertEscapeJava("He didn't say, \\\"stop!\\\"", [EOL]                 "He didn't say, \"stop!\""); [EOL]         assertEscapeJava("non-breaking space", "This space is non-breaking:" + "\\u00A0", [EOL]                 "This space is non-breaking:\u00a0"); [EOL]         assertEscapeJava("\\uABCD\\u1234\\u012C", [EOL]                 "\uABCD\u1234\u012C"); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests https://issues.apache.org/jira/browse/LANG-421 [EOL]      */ [EOL]
@Test [EOL]     public void testBetween() { [EOL]         final UnicodeEscaper ue = UnicodeEscaper.between('F', 'L'); [EOL]  [EOL]         final String input = "ADFGZ"; [EOL]         final String result = ue.translate(input); [EOL]         assertEquals("Failed to escape Unicode characters via the between method", "AD\\u0046\\u0047Z", result); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLang381() { [EOL]         assertEquals(1.2, IEEE754rUtils.min(1.2, 2.5, Double.NaN), 0.01); [EOL]         assertEquals(2.5, IEEE754rUtils.max(1.2, 2.5, Double.NaN), 0.01); [EOL]         assertTrue(Double.isNaN(IEEE754rUtils.max(Double.NaN, Double.NaN, Double.NaN))); [EOL]         assertEquals(1.2f, IEEE754rUtils.min(1.2f, 2.5f, Float.NaN), 0.01); [EOL]         assertEquals(2.5f, IEEE754rUtils.max(1.2f, 2.5f, Float.NaN), 0.01); [EOL]         assertTrue(Float.isNaN(IEEE754rUtils.max(Float.NaN, Float.NaN, Float.NaN))); [EOL]  [EOL]         final double[] a = new double[] { 1.2, Double.NaN, 3.7, 27.0, 42.0, Double.NaN }; [EOL]         assertEquals(42.0, IEEE754rUtils.max(a), 0.01); [EOL]         assertEquals(1.2, IEEE754rUtils.min(a), 0.01); [EOL]  [EOL]         final double[] b = new double[] { Double.NaN, 1.2, Double.NaN, 3.7, 27.0, 42.0, Double.NaN }; [EOL]         assertEquals(42.0, IEEE754rUtils.max(b), 0.01); [EOL]         assertEquals(1.2, IEEE754rUtils.min(b), 0.01); [EOL]  [EOL]         final float[] aF = new float[] { 1.2f, Float.NaN, 3.7f, 27.0f, 42.0f, Float.NaN }; [EOL]         assertEquals(1.2f, IEEE754rUtils.min(aF), 0.01); [EOL]         assertEquals(42.0f, IEEE754rUtils.max(aF), 0.01); [EOL]  [EOL]         final float[] bF = new float[] { Float.NaN, 1.2f, Float.NaN, 3.7f, 27.0f, 42.0f, Float.NaN }; [EOL]         assertEquals(1.2f, IEEE754rUtils.min(bF), 0.01); [EOL]         assertEquals(42.0f, IEEE754rUtils.max(bF), 0.01); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLang381() { [EOL]         assertEquals(1.2, IEEE754rUtils.min(1.2, 2.5, Double.NaN), 0.01); [EOL]         assertEquals(2.5, IEEE754rUtils.max(1.2, 2.5, Double.NaN), 0.01); [EOL]         assertTrue(Double.isNaN(IEEE754rUtils.max(Double.NaN, Double.NaN, Double.NaN))); [EOL]         assertEquals(1.2f, IEEE754rUtils.min(1.2f, 2.5f, Float.NaN), 0.01); [EOL]         assertEquals(2.5f, IEEE754rUtils.max(1.2f, 2.5f, Float.NaN), 0.01); [EOL]         assertTrue(Float.isNaN(IEEE754rUtils.max(Float.NaN, Float.NaN, Float.NaN))); [EOL]  [EOL]         final double[] a = new double[] { 1.2, Double.NaN, 3.7, 27.0, 42.0, Double.NaN }; [EOL]         assertEquals(42.0, IEEE754rUtils.max(a), 0.01); [EOL]         assertEquals(1.2, IEEE754rUtils.min(a), 0.01); [EOL]  [EOL]         final double[] b = new double[] { Double.NaN, 1.2, Double.NaN, 3.7, 27.0, 42.0, Double.NaN }; [EOL]         assertEquals(42.0, IEEE754rUtils.max(b), 0.01); [EOL]         assertEquals(1.2, IEEE754rUtils.min(b), 0.01); [EOL]  [EOL]         final float[] aF = new float[] { 1.2f, Float.NaN, 3.7f, 27.0f, 42.0f, Float.NaN }; [EOL]         assertEquals(1.2f, IEEE754rUtils.min(aF), 0.01); [EOL]         assertEquals(42.0f, IEEE754rUtils.max(aF), 0.01); [EOL]  [EOL]         final float[] bF = new float[] { Float.NaN, 1.2f, Float.NaN, 3.7f, 27.0f, 42.0f, Float.NaN }; [EOL]         assertEquals(1.2f, IEEE754rUtils.min(bF), 0.01); [EOL]         assertEquals(42.0f, IEEE754rUtils.max(bF), 0.01); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLang381() { [EOL]         assertEquals(1.2, IEEE754rUtils.min(1.2, 2.5, Double.NaN), 0.01); [EOL]         assertEquals(2.5, IEEE754rUtils.max(1.2, 2.5, Double.NaN), 0.01); [EOL]         assertTrue(Double.isNaN(IEEE754rUtils.max(Double.NaN, Double.NaN, Double.NaN))); [EOL]         assertEquals(1.2f, IEEE754rUtils.min(1.2f, 2.5f, Float.NaN), 0.01); [EOL]         assertEquals(2.5f, IEEE754rUtils.max(1.2f, 2.5f, Float.NaN), 0.01); [EOL]         assertTrue(Float.isNaN(IEEE754rUtils.max(Float.NaN, Float.NaN, Float.NaN))); [EOL]  [EOL]         final double[] a = new double[] { 1.2, Double.NaN, 3.7, 27.0, 42.0, Double.NaN }; [EOL]         assertEquals(42.0, IEEE754rUtils.max(a), 0.01); [EOL]         assertEquals(1.2, IEEE754rUtils.min(a), 0.01); [EOL]  [EOL]         final double[] b = new double[] { Double.NaN, 1.2, Double.NaN, 3.7, 27.0, 42.0, Double.NaN }; [EOL]         assertEquals(42.0, IEEE754rUtils.max(b), 0.01); [EOL]         assertEquals(1.2, IEEE754rUtils.min(b), 0.01); [EOL]  [EOL]         final float[] aF = new float[] { 1.2f, Float.NaN, 3.7f, 27.0f, 42.0f, Float.NaN }; [EOL]         assertEquals(1.2f, IEEE754rUtils.min(aF), 0.01); [EOL]         assertEquals(42.0f, IEEE754rUtils.max(aF), 0.01); [EOL]  [EOL]         final float[] bF = new float[] { Float.NaN, 1.2f, Float.NaN, 3.7f, 27.0f, 42.0f, Float.NaN }; [EOL]         assertEquals(1.2f, IEEE754rUtils.min(bF), 0.01); [EOL]         assertEquals(42.0f, IEEE754rUtils.max(bF), 0.01); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLang381() { [EOL]         assertEquals(1.2, IEEE754rUtils.min(1.2, 2.5, Double.NaN), 0.01); [EOL]         assertEquals(2.5, IEEE754rUtils.max(1.2, 2.5, Double.NaN), 0.01); [EOL]         assertTrue(Double.isNaN(IEEE754rUtils.max(Double.NaN, Double.NaN, Double.NaN))); [EOL]         assertEquals(1.2f, IEEE754rUtils.min(1.2f, 2.5f, Float.NaN), 0.01); [EOL]         assertEquals(2.5f, IEEE754rUtils.max(1.2f, 2.5f, Float.NaN), 0.01); [EOL]         assertTrue(Float.isNaN(IEEE754rUtils.max(Float.NaN, Float.NaN, Float.NaN))); [EOL]  [EOL]         final double[] a = new double[] { 1.2, Double.NaN, 3.7, 27.0, 42.0, Double.NaN }; [EOL]         assertEquals(42.0, IEEE754rUtils.max(a), 0.01); [EOL]         assertEquals(1.2, IEEE754rUtils.min(a), 0.01); [EOL]  [EOL]         final double[] b = new double[] { Double.NaN, 1.2, Double.NaN, 3.7, 27.0, 42.0, Double.NaN }; [EOL]         assertEquals(42.0, IEEE754rUtils.max(b), 0.01); [EOL]         assertEquals(1.2, IEEE754rUtils.min(b), 0.01); [EOL]  [EOL]         final float[] aF = new float[] { 1.2f, Float.NaN, 3.7f, 27.0f, 42.0f, Float.NaN }; [EOL]         assertEquals(1.2f, IEEE754rUtils.min(aF), 0.01); [EOL]         assertEquals(42.0f, IEEE754rUtils.max(aF), 0.01); [EOL]  [EOL]         final float[] bF = new float[] { Float.NaN, 1.2f, Float.NaN, 3.7f, 27.0f, 42.0f, Float.NaN }; [EOL]         assertEquals(1.2f, IEEE754rUtils.min(bF), 0.01); [EOL]         assertEquals(42.0f, IEEE754rUtils.max(bF), 0.01); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLang381() { [EOL]         assertEquals(1.2, IEEE754rUtils.min(1.2, 2.5, Double.NaN), 0.01); [EOL]         assertEquals(2.5, IEEE754rUtils.max(1.2, 2.5, Double.NaN), 0.01); [EOL]         assertTrue(Double.isNaN(IEEE754rUtils.max(Double.NaN, Double.NaN, Double.NaN))); [EOL]         assertEquals(1.2f, IEEE754rUtils.min(1.2f, 2.5f, Float.NaN), 0.01); [EOL]         assertEquals(2.5f, IEEE754rUtils.max(1.2f, 2.5f, Float.NaN), 0.01); [EOL]         assertTrue(Float.isNaN(IEEE754rUtils.max(Float.NaN, Float.NaN, Float.NaN))); [EOL]  [EOL]         final double[] a = new double[] { 1.2, Double.NaN, 3.7, 27.0, 42.0, Double.NaN }; [EOL]         assertEquals(42.0, IEEE754rUtils.max(a), 0.01); [EOL]         assertEquals(1.2, IEEE754rUtils.min(a), 0.01); [EOL]  [EOL]         final double[] b = new double[] { Double.NaN, 1.2, Double.NaN, 3.7, 27.0, 42.0, Double.NaN }; [EOL]         assertEquals(42.0, IEEE754rUtils.max(b), 0.01); [EOL]         assertEquals(1.2, IEEE754rUtils.min(b), 0.01); [EOL]  [EOL]         final float[] aF = new float[] { 1.2f, Float.NaN, 3.7f, 27.0f, 42.0f, Float.NaN }; [EOL]         assertEquals(1.2f, IEEE754rUtils.min(aF), 0.01); [EOL]         assertEquals(42.0f, IEEE754rUtils.max(aF), 0.01); [EOL]  [EOL]         final float[] bF = new float[] { Float.NaN, 1.2f, Float.NaN, 3.7f, 27.0f, 42.0f, Float.NaN }; [EOL]         assertEquals(1.2f, IEEE754rUtils.min(bF), 0.01); [EOL]         assertEquals(42.0f, IEEE754rUtils.max(bF), 0.01); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLang381() { [EOL]         assertEquals(1.2, IEEE754rUtils.min(1.2, 2.5, Double.NaN), 0.01); [EOL]         assertEquals(2.5, IEEE754rUtils.max(1.2, 2.5, Double.NaN), 0.01); [EOL]         assertTrue(Double.isNaN(IEEE754rUtils.max(Double.NaN, Double.NaN, Double.NaN))); [EOL]         assertEquals(1.2f, IEEE754rUtils.min(1.2f, 2.5f, Float.NaN), 0.01); [EOL]         assertEquals(2.5f, IEEE754rUtils.max(1.2f, 2.5f, Float.NaN), 0.01); [EOL]         assertTrue(Float.isNaN(IEEE754rUtils.max(Float.NaN, Float.NaN, Float.NaN))); [EOL]  [EOL]         final double[] a = new double[] { 1.2, Double.NaN, 3.7, 27.0, 42.0, Double.NaN }; [EOL]         assertEquals(42.0, IEEE754rUtils.max(a), 0.01); [EOL]         assertEquals(1.2, IEEE754rUtils.min(a), 0.01); [EOL]  [EOL]         final double[] b = new double[] { Double.NaN, 1.2, Double.NaN, 3.7, 27.0, 42.0, Double.NaN }; [EOL]         assertEquals(42.0, IEEE754rUtils.max(b), 0.01); [EOL]         assertEquals(1.2, IEEE754rUtils.min(b), 0.01); [EOL]  [EOL]         final float[] aF = new float[] { 1.2f, Float.NaN, 3.7f, 27.0f, 42.0f, Float.NaN }; [EOL]         assertEquals(1.2f, IEEE754rUtils.min(aF), 0.01); [EOL]         assertEquals(42.0f, IEEE754rUtils.max(aF), 0.01); [EOL]  [EOL]         final float[] bF = new float[] { Float.NaN, 1.2f, Float.NaN, 3.7f, 27.0f, 42.0f, Float.NaN }; [EOL]         assertEquals(1.2f, IEEE754rUtils.min(bF), 0.01); [EOL]         assertEquals(42.0f, IEEE754rUtils.max(bF), 0.01); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLang381() { [EOL]         assertEquals(1.2, IEEE754rUtils.min(1.2, 2.5, Double.NaN), 0.01); [EOL]         assertEquals(2.5, IEEE754rUtils.max(1.2, 2.5, Double.NaN), 0.01); [EOL]         assertTrue(Double.isNaN(IEEE754rUtils.max(Double.NaN, Double.NaN, Double.NaN))); [EOL]         assertEquals(1.2f, IEEE754rUtils.min(1.2f, 2.5f, Float.NaN), 0.01); [EOL]         assertEquals(2.5f, IEEE754rUtils.max(1.2f, 2.5f, Float.NaN), 0.01); [EOL]         assertTrue(Float.isNaN(IEEE754rUtils.max(Float.NaN, Float.NaN, Float.NaN))); [EOL]  [EOL]         final double[] a = new double[] { 1.2, Double.NaN, 3.7, 27.0, 42.0, Double.NaN }; [EOL]         assertEquals(42.0, IEEE754rUtils.max(a), 0.01); [EOL]         assertEquals(1.2, IEEE754rUtils.min(a), 0.01); [EOL]  [EOL]         final double[] b = new double[] { Double.NaN, 1.2, Double.NaN, 3.7, 27.0, 42.0, Double.NaN }; [EOL]         assertEquals(42.0, IEEE754rUtils.max(b), 0.01); [EOL]         assertEquals(1.2, IEEE754rUtils.min(b), 0.01); [EOL]  [EOL]         final float[] aF = new float[] { 1.2f, Float.NaN, 3.7f, 27.0f, 42.0f, Float.NaN }; [EOL]         assertEquals(1.2f, IEEE754rUtils.min(aF), 0.01); [EOL]         assertEquals(42.0f, IEEE754rUtils.max(aF), 0.01); [EOL]  [EOL]         final float[] bF = new float[] { Float.NaN, 1.2f, Float.NaN, 3.7f, 27.0f, 42.0f, Float.NaN }; [EOL]         assertEquals(1.2f, IEEE754rUtils.min(bF), 0.01); [EOL]         assertEquals(42.0f, IEEE754rUtils.max(bF), 0.01); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLang381() { [EOL]         assertEquals(1.2, IEEE754rUtils.min(1.2, 2.5, Double.NaN), 0.01); [EOL]         assertEquals(2.5, IEEE754rUtils.max(1.2, 2.5, Double.NaN), 0.01); [EOL]         assertTrue(Double.isNaN(IEEE754rUtils.max(Double.NaN, Double.NaN, Double.NaN))); [EOL]         assertEquals(1.2f, IEEE754rUtils.min(1.2f, 2.5f, Float.NaN), 0.01); [EOL]         assertEquals(2.5f, IEEE754rUtils.max(1.2f, 2.5f, Float.NaN), 0.01); [EOL]         assertTrue(Float.isNaN(IEEE754rUtils.max(Float.NaN, Float.NaN, Float.NaN))); [EOL]  [EOL]         final double[] a = new double[] { 1.2, Double.NaN, 3.7, 27.0, 42.0, Double.NaN }; [EOL]         assertEquals(42.0, IEEE754rUtils.max(a), 0.01); [EOL]         assertEquals(1.2, IEEE754rUtils.min(a), 0.01); [EOL]  [EOL]         final double[] b = new double[] { Double.NaN, 1.2, Double.NaN, 3.7, 27.0, 42.0, Double.NaN }; [EOL]         assertEquals(42.0, IEEE754rUtils.max(b), 0.01); [EOL]         assertEquals(1.2, IEEE754rUtils.min(b), 0.01); [EOL]  [EOL]         final float[] aF = new float[] { 1.2f, Float.NaN, 3.7f, 27.0f, 42.0f, Float.NaN }; [EOL]         assertEquals(1.2f, IEEE754rUtils.min(aF), 0.01); [EOL]         assertEquals(42.0f, IEEE754rUtils.max(aF), 0.01); [EOL]  [EOL]         final float[] bF = new float[] { Float.NaN, 1.2f, Float.NaN, 3.7f, 27.0f, 42.0f, Float.NaN }; [EOL]         assertEquals(1.2f, IEEE754rUtils.min(bF), 0.01); [EOL]         assertEquals(42.0f, IEEE754rUtils.max(bF), 0.01); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessageFormat("{0,date}", locale); [EOL]             final String pattern = "{0,date,short}"; [EOL]             final ExtendedMessageFormat dateShort = new ExtendedMessageFormat(pattern, locale, registry); [EOL]             assertEquals("overridden date,short format", dateDefault.format(args), dateShort.format(args)); [EOL]             assertEquals("overridden date,short pattern", pattern, dateShort.toPattern()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test the built in number formats. [EOL]      */ [EOL]
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessageFormat("{0,date}", locale); [EOL]             final String pattern = "{0,date,short}"; [EOL]             final ExtendedMessageFormat dateShort = new ExtendedMessageFormat(pattern, locale, registry); [EOL]             assertEquals("overridden date,short format", dateDefault.format(args), dateShort.format(args)); [EOL]             assertEquals("overridden date,short pattern", pattern, dateShort.toPattern()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test the built in number formats. [EOL]      */ [EOL]
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessageFormat("{0,date}", locale); [EOL]             final String pattern = "{0,date,short}"; [EOL]             final ExtendedMessageFormat dateShort = new ExtendedMessageFormat(pattern, locale, registry); [EOL]             assertEquals("overridden date,short format", dateDefault.format(args), dateShort.format(args)); [EOL]             assertEquals("overridden date,short pattern", pattern, dateShort.toPattern()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test the built in number formats. [EOL]      */ [EOL]
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessageFormat("{0,date}", locale); [EOL]             final String pattern = "{0,date,short}"; [EOL]             final ExtendedMessageFormat dateShort = new ExtendedMessageFormat(pattern, locale, registry); [EOL]             assertEquals("overridden date,short format", dateDefault.format(args), dateShort.format(args)); [EOL]             assertEquals("overridden date,short pattern", pattern, dateShort.toPattern()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test the built in number formats. [EOL]      */ [EOL]
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessageFormat("{0,date}", locale); [EOL]             final String pattern = "{0,date,short}"; [EOL]             final ExtendedMessageFormat dateShort = new ExtendedMessageFormat(pattern, locale, registry); [EOL]             assertEquals("overridden date,short format", dateDefault.format(args), dateShort.format(args)); [EOL]             assertEquals("overridden date,short pattern", pattern, dateShort.toPattern()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test the built in number formats. [EOL]      */ [EOL]
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessageFormat("{0,date}", locale); [EOL]             final String pattern = "{0,date,short}"; [EOL]             final ExtendedMessageFormat dateShort = new ExtendedMessageFormat(pattern, locale, registry); [EOL]             assertEquals("overridden date,short format", dateDefault.format(args), dateShort.format(args)); [EOL]             assertEquals("overridden date,short pattern", pattern, dateShort.toPattern()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test the built in number formats. [EOL]      */ [EOL]
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessageFormat("{0,date}", locale); [EOL]             final String pattern = "{0,date,short}"; [EOL]             final ExtendedMessageFormat dateShort = new ExtendedMessageFormat(pattern, locale, registry); [EOL]             assertEquals("overridden date,short format", dateDefault.format(args), dateShort.format(args)); [EOL]             assertEquals("overridden date,short pattern", pattern, dateShort.toPattern()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test the built in number formats. [EOL]      */ [EOL]
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessageFormat("{0,date}", locale); [EOL]             final String pattern = "{0,date,short}"; [EOL]             final ExtendedMessageFormat dateShort = new ExtendedMessageFormat(pattern, locale, registry); [EOL]             assertEquals("overridden date,short format", dateDefault.format(args), dateShort.format(args)); [EOL]             assertEquals("overridden date,short pattern", pattern, dateShort.toPattern()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test the built in number formats. [EOL]      */ [EOL]
@Test [EOL]     public void testExtendedAndBuiltInFormats() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23, 18, 33, 05); [EOL]         final Object[] args = new Object[] {"John Doe", cal.getTime(), Double.valueOf("12345.67")}; [EOL]         final String builtinsPattern = "DOB: {1,date,short} Salary: {2,number,currency}"; [EOL]         final String extendedPattern = "Name: {0,upper} "; [EOL]         final String pattern = extendedPattern + builtinsPattern; [EOL]  [EOL]         final HashSet<Locale> testLocales = new HashSet<Locale>(); [EOL]         testLocales.addAll(Arrays.asList(DateFormat.getAvailableLocales())); [EOL]         testLocales.retainAll(Arrays.asList(NumberFormat.getAvailableLocales())); [EOL]         testLocales.add(null); [EOL]  [EOL]         for (final Locale locale : testLocales) { [EOL]             final MessageFormat builtins = createMessageFormat(builtinsPattern, locale); [EOL]             final String expectedPattern = extendedPattern + builtins.toPattern(); [EOL]             DateFormat df = null; [EOL]             NumberFormat nf = null; [EOL]             ExtendedMessageFormat emf = null; [EOL]             if (locale == null) { [EOL]                 df = DateFormat.getDateInstance(DateFormat.SHORT); [EOL]                 nf = NumberFormat.getCurrencyInstance(); [EOL]                 emf = new ExtendedMessageFormat(pattern, registry); [EOL]             } else { [EOL]                 df = DateFormat.getDateInstance(DateFormat.SHORT, locale); [EOL]                 nf = NumberFormat.getCurrencyInstance(locale); [EOL]                 emf = new ExtendedMessageFormat(pattern, locale, registry); [EOL]             } [EOL]             final StringBuilder expected = new StringBuilder(); [EOL]             expected.append("Name: "); [EOL]             expected.append(args[0].toString().toUpperCase()); [EOL]             expected.append(" DOB: "); [EOL]             expected.append(df.format(args[1])); [EOL]             expected.append(" Salary: "); [EOL]             expected.append(nf.format(args[2])); [EOL]             assertPatternsEqual("pattern comparison for locale " + locale, expectedPattern, emf.toPattern()); [EOL]             assertEquals(String.valueOf(locale), expected.toString(), emf.format(args)); [EOL]         } [EOL]     } [EOL]  [EOL] //    /** [EOL] //     * Test extended formats with choice format. [EOL] //     * [EOL] //     * NOTE: FAILING - currently sub-formats not supported [EOL] //     */ [EOL] //    public void testExtendedWithChoiceFormat() { [EOL] //        String pattern = "Choice: {0,choice,1.0#{1,lower}|2.0#{1,upper}}"; [EOL] //        ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL] //        assertPatterns(null, pattern, emf.toPattern()); [EOL] //        try { [EOL] //            assertEquals("one", emf.format(new Object[] {Integer.valueOf(1), "ONE"})); [EOL] //            assertEquals("TWO", emf.format(new Object[] {Integer.valueOf(2), "two"})); [EOL] //        } catch (IllegalArgumentException e) { [EOL] //            // currently sub-formats not supported [EOL] //        } [EOL] //    } [EOL]  [EOL] //    /** [EOL] //     * Test mixed extended and built-in formats with choice format. [EOL] //     * [EOL] //     * NOTE: FAILING - currently sub-formats not supported [EOL] //     */ [EOL] //    public void testExtendedAndBuiltInWithChoiceFormat() { [EOL] //        String pattern = "Choice: {0,choice,1.0#{0} {1,lower} {2,number}|2.0#{0} {1,upper} {2,number,currency}}"; [EOL] //        Object[] lowArgs  = new Object[] {Integer.valueOf(1), "Low",  Double.valueOf("1234.56")}; [EOL] //        Object[] highArgs = new Object[] {Integer.valueOf(2), "High", Double.valueOf("9876.54")}; [EOL] //        Locale[] availableLocales = ChoiceFormat.getAvailableLocales(); [EOL] //        Locale[] testLocales = new Locale[availableLocales.length + 1]; [EOL] //        testLocales[0] = null; [EOL] //        System.arraycopy(availableLocales, 0, testLocales, 1, availableLocales.length); [EOL] //        for (int i = 0; i < testLocales.length; i++) { [EOL] //            NumberFormat nf = null; [EOL] //            NumberFormat cf = null; [EOL] //            ExtendedMessageFormat emf = null; [EOL] //            if (testLocales[i] == null) { [EOL] //                nf = NumberFormat.getNumberInstance(); [EOL] //                cf = NumberFormat.getCurrencyInstance(); [EOL] //                emf = new ExtendedMessageFormat(pattern, registry); [EOL] //            } else { [EOL] //                nf = NumberFormat.getNumberInstance(testLocales[i]); [EOL] //                cf = NumberFormat.getCurrencyInstance(testLocales[i]); [EOL] //                emf = new ExtendedMessageFormat(pattern, testLocales[i], registry); [EOL] //            } [EOL] //            assertPatterns(null, pattern, emf.toPattern()); [EOL] //            try { [EOL] //                String lowExpected = lowArgs[0] + " low "    + nf.format(lowArgs[2]); [EOL] //                String highExpected = highArgs[0] + " HIGH "  + cf.format(highArgs[2]); [EOL] //                assertEquals(lowExpected,  emf.format(lowArgs)); [EOL] //                assertEquals(highExpected, emf.format(highArgs)); [EOL] //            } catch (IllegalArgumentException e) { [EOL] //                // currently sub-formats not supported [EOL] //            } [EOL] //        } [EOL] //    } [EOL]  [EOL]     /** [EOL]      * Test the built in choice format. [EOL]      */ [EOL]
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessageFormat("{0,date}", locale); [EOL]             final String pattern = "{0,date,short}"; [EOL]             final ExtendedMessageFormat dateShort = new ExtendedMessageFormat(pattern, locale, registry); [EOL]             assertEquals("overridden date,short format", dateDefault.format(args), dateShort.format(args)); [EOL]             assertEquals("overridden date,short pattern", pattern, dateShort.toPattern()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test the built in number formats. [EOL]      */ [EOL]
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessageFormat("{0,date}", locale); [EOL]             final String pattern = "{0,date,short}"; [EOL]             final ExtendedMessageFormat dateShort = new ExtendedMessageFormat(pattern, locale, registry); [EOL]             assertEquals("overridden date,short format", dateDefault.format(args), dateShort.format(args)); [EOL]             assertEquals("overridden date,short pattern", pattern, dateShort.toPattern()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test the built in number formats. [EOL]      */ [EOL]
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessageFormat("{0,date}", locale); [EOL]             final String pattern = "{0,date,short}"; [EOL]             final ExtendedMessageFormat dateShort = new ExtendedMessageFormat(pattern, locale, registry); [EOL]             assertEquals("overridden date,short format", dateDefault.format(args), dateShort.format(args)); [EOL]             assertEquals("overridden date,short pattern", pattern, dateShort.toPattern()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test the built in number formats. [EOL]      */ [EOL]
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessageFormat("{0,date}", locale); [EOL]             final String pattern = "{0,date,short}"; [EOL]             final ExtendedMessageFormat dateShort = new ExtendedMessageFormat(pattern, locale, registry); [EOL]             assertEquals("overridden date,short format", dateDefault.format(args), dateShort.format(args)); [EOL]             assertEquals("overridden date,short pattern", pattern, dateShort.toPattern()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test the built in number formats. [EOL]      */ [EOL]
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessageFormat("{0,date}", locale); [EOL]             final String pattern = "{0,date,short}"; [EOL]             final ExtendedMessageFormat dateShort = new ExtendedMessageFormat(pattern, locale, registry); [EOL]             assertEquals("overridden date,short format", dateDefault.format(args), dateShort.format(args)); [EOL]             assertEquals("overridden date,short pattern", pattern, dateShort.toPattern()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test the built in number formats. [EOL]      */ [EOL]
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessageFormat("{0,date}", locale); [EOL]             final String pattern = "{0,date,short}"; [EOL]             final ExtendedMessageFormat dateShort = new ExtendedMessageFormat(pattern, locale, registry); [EOL]             assertEquals("overridden date,short format", dateDefault.format(args), dateShort.format(args)); [EOL]             assertEquals("overridden date,short pattern", pattern, dateShort.toPattern()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test the built in number formats. [EOL]      */ [EOL]
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessageFormat("{0,date}", locale); [EOL]             final String pattern = "{0,date,short}"; [EOL]             final ExtendedMessageFormat dateShort = new ExtendedMessageFormat(pattern, locale, registry); [EOL]             assertEquals("overridden date,short format", dateDefault.format(args), dateShort.format(args)); [EOL]             assertEquals("overridden date,short pattern", pattern, dateShort.toPattern()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test the built in number formats. [EOL]      */ [EOL]
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessageFormat("{0,date}", locale); [EOL]             final String pattern = "{0,date,short}"; [EOL]             final ExtendedMessageFormat dateShort = new ExtendedMessageFormat(pattern, locale, registry); [EOL]             assertEquals("overridden date,short format", dateDefault.format(args), dateShort.format(args)); [EOL]             assertEquals("overridden date,short pattern", pattern, dateShort.toPattern()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test the built in number formats. [EOL]      */ [EOL]
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessageFormat("{0,date}", locale); [EOL]             final String pattern = "{0,date,short}"; [EOL]             final ExtendedMessageFormat dateShort = new ExtendedMessageFormat(pattern, locale, registry); [EOL]             assertEquals("overridden date,short format", dateDefault.format(args), dateShort.format(args)); [EOL]             assertEquals("overridden date,short pattern", pattern, dateShort.toPattern()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test the built in number formats. [EOL]      */ [EOL]
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessageFormat("{0,date}", locale); [EOL]             final String pattern = "{0,date,short}"; [EOL]             final ExtendedMessageFormat dateShort = new ExtendedMessageFormat(pattern, locale, registry); [EOL]             assertEquals("overridden date,short format", dateDefault.format(args), dateShort.format(args)); [EOL]             assertEquals("overridden date,short pattern", pattern, dateShort.toPattern()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test the built in number formats. [EOL]      */ [EOL]
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessageFormat("{0,date}", locale); [EOL]             final String pattern = "{0,date,short}"; [EOL]             final ExtendedMessageFormat dateShort = new ExtendedMessageFormat(pattern, locale, registry); [EOL]             assertEquals("overridden date,short format", dateDefault.format(args), dateShort.format(args)); [EOL]             assertEquals("overridden date,short pattern", pattern, dateShort.toPattern()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test the built in number formats. [EOL]      */ [EOL]
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessageFormat("{0,date}", locale); [EOL]             final String pattern = "{0,date,short}"; [EOL]             final ExtendedMessageFormat dateShort = new ExtendedMessageFormat(pattern, locale, registry); [EOL]             assertEquals("overridden date,short format", dateDefault.format(args), dateShort.format(args)); [EOL]             assertEquals("overridden date,short pattern", pattern, dateShort.toPattern()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test the built in number formats. [EOL]      */ [EOL]
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessageFormat("{0,date}", locale); [EOL]             final String pattern = "{0,date,short}"; [EOL]             final ExtendedMessageFormat dateShort = new ExtendedMessageFormat(pattern, locale, registry); [EOL]             assertEquals("overridden date,short format", dateDefault.format(args), dateShort.format(args)); [EOL]             assertEquals("overridden date,short pattern", pattern, dateShort.toPattern()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test the built in number formats. [EOL]      */ [EOL]
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessageFormat("{0,date}", locale); [EOL]             final String pattern = "{0,date,short}"; [EOL]             final ExtendedMessageFormat dateShort = new ExtendedMessageFormat(pattern, locale, registry); [EOL]             assertEquals("overridden date,short format", dateDefault.format(args), dateShort.format(args)); [EOL]             assertEquals("overridden date,short pattern", pattern, dateShort.toPattern()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test the built in number formats. [EOL]      */ [EOL]
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessageFormat("{0,date}", locale); [EOL]             final String pattern = "{0,date,short}"; [EOL]             final ExtendedMessageFormat dateShort = new ExtendedMessageFormat(pattern, locale, registry); [EOL]             assertEquals("overridden date,short format", dateDefault.format(args), dateShort.format(args)); [EOL]             assertEquals("overridden date,short pattern", pattern, dateShort.toPattern()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test the built in number formats. [EOL]      */ [EOL]
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessageFormat("{0,date}", locale); [EOL]             final String pattern = "{0,date,short}"; [EOL]             final ExtendedMessageFormat dateShort = new ExtendedMessageFormat(pattern, locale, registry); [EOL]             assertEquals("overridden date,short format", dateDefault.format(args), dateShort.format(args)); [EOL]             assertEquals("overridden date,short pattern", pattern, dateShort.toPattern()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test the built in number formats. [EOL]      */ [EOL]
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessageFormat("{0,date}", locale); [EOL]             final String pattern = "{0,date,short}"; [EOL]             final ExtendedMessageFormat dateShort = new ExtendedMessageFormat(pattern, locale, registry); [EOL]             assertEquals("overridden date,short format", dateDefault.format(args), dateShort.format(args)); [EOL]             assertEquals("overridden date,short pattern", pattern, dateShort.toPattern()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test the built in number formats. [EOL]      */ [EOL]
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessageFormat("{0,date}", locale); [EOL]             final String pattern = "{0,date,short}"; [EOL]             final ExtendedMessageFormat dateShort = new ExtendedMessageFormat(pattern, locale, registry); [EOL]             assertEquals("overridden date,short format", dateDefault.format(args), dateShort.format(args)); [EOL]             assertEquals("overridden date,short pattern", pattern, dateShort.toPattern()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test the built in number formats. [EOL]      */ [EOL]
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessageFormat("{0,date}", locale); [EOL]             final String pattern = "{0,date,short}"; [EOL]             final ExtendedMessageFormat dateShort = new ExtendedMessageFormat(pattern, locale, registry); [EOL]             assertEquals("overridden date,short format", dateDefault.format(args), dateShort.format(args)); [EOL]             assertEquals("overridden date,short pattern", pattern, dateShort.toPattern()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test the built in number formats. [EOL]      */ [EOL]
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessageFormat("{0,date}", locale); [EOL]             final String pattern = "{0,date,short}"; [EOL]             final ExtendedMessageFormat dateShort = new ExtendedMessageFormat(pattern, locale, registry); [EOL]             assertEquals("overridden date,short format", dateDefault.format(args), dateShort.format(args)); [EOL]             assertEquals("overridden date,short pattern", pattern, dateShort.toPattern()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test the built in number formats. [EOL]      */ [EOL]
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessageFormat("{0,date}", locale); [EOL]             final String pattern = "{0,date,short}"; [EOL]             final ExtendedMessageFormat dateShort = new ExtendedMessageFormat(pattern, locale, registry); [EOL]             assertEquals("overridden date,short format", dateDefault.format(args), dateShort.format(args)); [EOL]             assertEquals("overridden date,short pattern", pattern, dateShort.toPattern()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test the built in number formats. [EOL]      */ [EOL]
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessageFormat("{0,date}", locale); [EOL]             final String pattern = "{0,date,short}"; [EOL]             final ExtendedMessageFormat dateShort = new ExtendedMessageFormat(pattern, locale, registry); [EOL]             assertEquals("overridden date,short format", dateDefault.format(args), dateShort.format(args)); [EOL]             assertEquals("overridden date,short pattern", pattern, dateShort.toPattern()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test the built in number formats. [EOL]      */ [EOL]
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessageFormat("{0,date}", locale); [EOL]             final String pattern = "{0,date,short}"; [EOL]             final ExtendedMessageFormat dateShort = new ExtendedMessageFormat(pattern, locale, registry); [EOL]             assertEquals("overridden date,short format", dateDefault.format(args), dateShort.format(args)); [EOL]             assertEquals("overridden date,short pattern", pattern, dateShort.toPattern()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test the built in number formats. [EOL]      */ [EOL]
@Test [EOL]     public void testExtendedAndBuiltInFormats() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23, 18, 33, 05); [EOL]         final Object[] args = new Object[] {"John Doe", cal.getTime(), Double.valueOf("12345.67")}; [EOL]         final String builtinsPattern = "DOB: {1,date,short} Salary: {2,number,currency}"; [EOL]         final String extendedPattern = "Name: {0,upper} "; [EOL]         final String pattern = extendedPattern + builtinsPattern; [EOL]  [EOL]         final HashSet<Locale> testLocales = new HashSet<Locale>(); [EOL]         testLocales.addAll(Arrays.asList(DateFormat.getAvailableLocales())); [EOL]         testLocales.retainAll(Arrays.asList(NumberFormat.getAvailableLocales())); [EOL]         testLocales.add(null); [EOL]  [EOL]         for (final Locale locale : testLocales) { [EOL]             final MessageFormat builtins = createMessageFormat(builtinsPattern, locale); [EOL]             final String expectedPattern = extendedPattern + builtins.toPattern(); [EOL]             DateFormat df = null; [EOL]             NumberFormat nf = null; [EOL]             ExtendedMessageFormat emf = null; [EOL]             if (locale == null) { [EOL]                 df = DateFormat.getDateInstance(DateFormat.SHORT); [EOL]                 nf = NumberFormat.getCurrencyInstance(); [EOL]                 emf = new ExtendedMessageFormat(pattern, registry); [EOL]             } else { [EOL]                 df = DateFormat.getDateInstance(DateFormat.SHORT, locale); [EOL]                 nf = NumberFormat.getCurrencyInstance(locale); [EOL]                 emf = new ExtendedMessageFormat(pattern, locale, registry); [EOL]             } [EOL]             final StringBuilder expected = new StringBuilder(); [EOL]             expected.append("Name: "); [EOL]             expected.append(args[0].toString().toUpperCase()); [EOL]             expected.append(" DOB: "); [EOL]             expected.append(df.format(args[1])); [EOL]             expected.append(" Salary: "); [EOL]             expected.append(nf.format(args[2])); [EOL]             assertPatternsEqual("pattern comparison for locale " + locale, expectedPattern, emf.toPattern()); [EOL]             assertEquals(String.valueOf(locale), expected.toString(), emf.format(args)); [EOL]         } [EOL]     } [EOL]  [EOL] //    /** [EOL] //     * Test extended formats with choice format. [EOL] //     * [EOL] //     * NOTE: FAILING - currently sub-formats not supported [EOL] //     */ [EOL] //    public void testExtendedWithChoiceFormat() { [EOL] //        String pattern = "Choice: {0,choice,1.0#{1,lower}|2.0#{1,upper}}"; [EOL] //        ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL] //        assertPatterns(null, pattern, emf.toPattern()); [EOL] //        try { [EOL] //            assertEquals("one", emf.format(new Object[] {Integer.valueOf(1), "ONE"})); [EOL] //            assertEquals("TWO", emf.format(new Object[] {Integer.valueOf(2), "two"})); [EOL] //        } catch (IllegalArgumentException e) { [EOL] //            // currently sub-formats not supported [EOL] //        } [EOL] //    } [EOL]  [EOL] //    /** [EOL] //     * Test mixed extended and built-in formats with choice format. [EOL] //     * [EOL] //     * NOTE: FAILING - currently sub-formats not supported [EOL] //     */ [EOL] //    public void testExtendedAndBuiltInWithChoiceFormat() { [EOL] //        String pattern = "Choice: {0,choice,1.0#{0} {1,lower} {2,number}|2.0#{0} {1,upper} {2,number,currency}}"; [EOL] //        Object[] lowArgs  = new Object[] {Integer.valueOf(1), "Low",  Double.valueOf("1234.56")}; [EOL] //        Object[] highArgs = new Object[] {Integer.valueOf(2), "High", Double.valueOf("9876.54")}; [EOL] //        Locale[] availableLocales = ChoiceFormat.getAvailableLocales(); [EOL] //        Locale[] testLocales = new Locale[availableLocales.length + 1]; [EOL] //        testLocales[0] = null; [EOL] //        System.arraycopy(availableLocales, 0, testLocales, 1, availableLocales.length); [EOL] //        for (int i = 0; i < testLocales.length; i++) { [EOL] //            NumberFormat nf = null; [EOL] //            NumberFormat cf = null; [EOL] //            ExtendedMessageFormat emf = null; [EOL] //            if (testLocales[i] == null) { [EOL] //                nf = NumberFormat.getNumberInstance(); [EOL] //                cf = NumberFormat.getCurrencyInstance(); [EOL] //                emf = new ExtendedMessageFormat(pattern, registry); [EOL] //            } else { [EOL] //                nf = NumberFormat.getNumberInstance(testLocales[i]); [EOL] //                cf = NumberFormat.getCurrencyInstance(testLocales[i]); [EOL] //                emf = new ExtendedMessageFormat(pattern, testLocales[i], registry); [EOL] //            } [EOL] //            assertPatterns(null, pattern, emf.toPattern()); [EOL] //            try { [EOL] //                String lowExpected = lowArgs[0] + " low "    + nf.format(lowArgs[2]); [EOL] //                String highExpected = highArgs[0] + " HIGH "  + cf.format(highArgs[2]); [EOL] //                assertEquals(lowExpected,  emf.format(lowArgs)); [EOL] //                assertEquals(highExpected, emf.format(highArgs)); [EOL] //            } catch (IllegalArgumentException e) { [EOL] //                // currently sub-formats not supported [EOL] //            } [EOL] //        } [EOL] //    } [EOL]  [EOL]     /** [EOL]      * Test the built in choice format. [EOL]      */ [EOL]
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessageFormat("{0,date}", locale); [EOL]             final String pattern = "{0,date,short}"; [EOL]             final ExtendedMessageFormat dateShort = new ExtendedMessageFormat(pattern, locale, registry); [EOL]             assertEquals("overridden date,short format", dateDefault.format(args), dateShort.format(args)); [EOL]             assertEquals("overridden date,short pattern", pattern, dateShort.toPattern()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test the built in number formats. [EOL]      */ [EOL]
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessageFormat("{0,date}", locale); [EOL]             final String pattern = "{0,date,short}"; [EOL]             final ExtendedMessageFormat dateShort = new ExtendedMessageFormat(pattern, locale, registry); [EOL]             assertEquals("overridden date,short format", dateDefault.format(args), dateShort.format(args)); [EOL]             assertEquals("overridden date,short pattern", pattern, dateShort.toPattern()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test the built in number formats. [EOL]      */ [EOL]
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessageFormat("{0,date}", locale); [EOL]             final String pattern = "{0,date,short}"; [EOL]             final ExtendedMessageFormat dateShort = new ExtendedMessageFormat(pattern, locale, registry); [EOL]             assertEquals("overridden date,short format", dateDefault.format(args), dateShort.format(args)); [EOL]             assertEquals("overridden date,short pattern", pattern, dateShort.toPattern()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test the built in number formats. [EOL]      */ [EOL]
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessageFormat("{0,date}", locale); [EOL]             final String pattern = "{0,date,short}"; [EOL]             final ExtendedMessageFormat dateShort = new ExtendedMessageFormat(pattern, locale, registry); [EOL]             assertEquals("overridden date,short format", dateDefault.format(args), dateShort.format(args)); [EOL]             assertEquals("overridden date,short pattern", pattern, dateShort.toPattern()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test the built in number formats. [EOL]      */ [EOL]
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessageFormat("{0,date}", locale); [EOL]             final String pattern = "{0,date,short}"; [EOL]             final ExtendedMessageFormat dateShort = new ExtendedMessageFormat(pattern, locale, registry); [EOL]             assertEquals("overridden date,short format", dateDefault.format(args), dateShort.format(args)); [EOL]             assertEquals("overridden date,short pattern", pattern, dateShort.toPattern()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test the built in number formats. [EOL]      */ [EOL]
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessageFormat("{0,date}", locale); [EOL]             final String pattern = "{0,date,short}"; [EOL]             final ExtendedMessageFormat dateShort = new ExtendedMessageFormat(pattern, locale, registry); [EOL]             assertEquals("overridden date,short format", dateDefault.format(args), dateShort.format(args)); [EOL]             assertEquals("overridden date,short pattern", pattern, dateShort.toPattern()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test the built in number formats. [EOL]      */ [EOL]
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessageFormat("{0,date}", locale); [EOL]             final String pattern = "{0,date,short}"; [EOL]             final ExtendedMessageFormat dateShort = new ExtendedMessageFormat(pattern, locale, registry); [EOL]             assertEquals("overridden date,short format", dateDefault.format(args), dateShort.format(args)); [EOL]             assertEquals("overridden date,short pattern", pattern, dateShort.toPattern()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test the built in number formats. [EOL]      */ [EOL]
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessageFormat("{0,date}", locale); [EOL]             final String pattern = "{0,date,short}"; [EOL]             final ExtendedMessageFormat dateShort = new ExtendedMessageFormat(pattern, locale, registry); [EOL]             assertEquals("overridden date,short format", dateDefault.format(args), dateShort.format(args)); [EOL]             assertEquals("overridden date,short pattern", pattern, dateShort.toPattern()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test the built in number formats. [EOL]      */ [EOL]
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessageFormat("{0,date}", locale); [EOL]             final String pattern = "{0,date,short}"; [EOL]             final ExtendedMessageFormat dateShort = new ExtendedMessageFormat(pattern, locale, registry); [EOL]             assertEquals("overridden date,short format", dateDefault.format(args), dateShort.format(args)); [EOL]             assertEquals("overridden date,short pattern", pattern, dateShort.toPattern()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test the built in number formats. [EOL]      */ [EOL]
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessageFormat("{0,date}", locale); [EOL]             final String pattern = "{0,date,short}"; [EOL]             final ExtendedMessageFormat dateShort = new ExtendedMessageFormat(pattern, locale, registry); [EOL]             assertEquals("overridden date,short format", dateDefault.format(args), dateShort.format(args)); [EOL]             assertEquals("overridden date,short pattern", pattern, dateShort.toPattern()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test the built in number formats. [EOL]      */ [EOL]
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessageFormat("{0,date}", locale); [EOL]             final String pattern = "{0,date,short}"; [EOL]             final ExtendedMessageFormat dateShort = new ExtendedMessageFormat(pattern, locale, registry); [EOL]             assertEquals("overridden date,short format", dateDefault.format(args), dateShort.format(args)); [EOL]             assertEquals("overridden date,short pattern", pattern, dateShort.toPattern()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test the built in number formats. [EOL]      */ [EOL]
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessageFormat("{0,date}", locale); [EOL]             final String pattern = "{0,date,short}"; [EOL]             final ExtendedMessageFormat dateShort = new ExtendedMessageFormat(pattern, locale, registry); [EOL]             assertEquals("overridden date,short format", dateDefault.format(args), dateShort.format(args)); [EOL]             assertEquals("overridden date,short pattern", pattern, dateShort.toPattern()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test the built in number formats. [EOL]      */ [EOL]
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessageFormat("{0,date}", locale); [EOL]             final String pattern = "{0,date,short}"; [EOL]             final ExtendedMessageFormat dateShort = new ExtendedMessageFormat(pattern, locale, registry); [EOL]             assertEquals("overridden date,short format", dateDefault.format(args), dateShort.format(args)); [EOL]             assertEquals("overridden date,short pattern", pattern, dateShort.toPattern()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test the built in number formats. [EOL]      */ [EOL]
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessageFormat("{0,date}", locale); [EOL]             final String pattern = "{0,date,short}"; [EOL]             final ExtendedMessageFormat dateShort = new ExtendedMessageFormat(pattern, locale, registry); [EOL]             assertEquals("overridden date,short format", dateDefault.format(args), dateShort.format(args)); [EOL]             assertEquals("overridden date,short pattern", pattern, dateShort.toPattern()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test the built in number formats. [EOL]      */ [EOL]
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessageFormat("{0,date}", locale); [EOL]             final String pattern = "{0,date,short}"; [EOL]             final ExtendedMessageFormat dateShort = new ExtendedMessageFormat(pattern, locale, registry); [EOL]             assertEquals("overridden date,short format", dateDefault.format(args), dateShort.format(args)); [EOL]             assertEquals("overridden date,short pattern", pattern, dateShort.toPattern()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test the built in number formats. [EOL]      */ [EOL]
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessageFormat("{0,date}", locale); [EOL]             final String pattern = "{0,date,short}"; [EOL]             final ExtendedMessageFormat dateShort = new ExtendedMessageFormat(pattern, locale, registry); [EOL]             assertEquals("overridden date,short format", dateDefault.format(args), dateShort.format(args)); [EOL]             assertEquals("overridden date,short pattern", pattern, dateShort.toPattern()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test the built in number formats. [EOL]      */ [EOL]
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessageFormat("{0,date}", locale); [EOL]             final String pattern = "{0,date,short}"; [EOL]             final ExtendedMessageFormat dateShort = new ExtendedMessageFormat(pattern, locale, registry); [EOL]             assertEquals("overridden date,short format", dateDefault.format(args), dateShort.format(args)); [EOL]             assertEquals("overridden date,short pattern", pattern, dateShort.toPattern()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test the built in number formats. [EOL]      */ [EOL]
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessageFormat("{0,date}", locale); [EOL]             final String pattern = "{0,date,short}"; [EOL]             final ExtendedMessageFormat dateShort = new ExtendedMessageFormat(pattern, locale, registry); [EOL]             assertEquals("overridden date,short format", dateDefault.format(args), dateShort.format(args)); [EOL]             assertEquals("overridden date,short pattern", pattern, dateShort.toPattern()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test the built in number formats. [EOL]      */ [EOL]
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessageFormat("{0,date}", locale); [EOL]             final String pattern = "{0,date,short}"; [EOL]             final ExtendedMessageFormat dateShort = new ExtendedMessageFormat(pattern, locale, registry); [EOL]             assertEquals("overridden date,short format", dateDefault.format(args), dateShort.format(args)); [EOL]             assertEquals("overridden date,short pattern", pattern, dateShort.toPattern()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test the built in number formats. [EOL]      */ [EOL]
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessageFormat("{0,date}", locale); [EOL]             final String pattern = "{0,date,short}"; [EOL]             final ExtendedMessageFormat dateShort = new ExtendedMessageFormat(pattern, locale, registry); [EOL]             assertEquals("overridden date,short format", dateDefault.format(args), dateShort.format(args)); [EOL]             assertEquals("overridden date,short pattern", pattern, dateShort.toPattern()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test the built in number formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessageFormat("{0,date}", locale); [EOL]             final String pattern = "{0,date,short}"; [EOL]             final ExtendedMessageFormat dateShort = new ExtendedMessageFormat(pattern, locale, registry); [EOL]             assertEquals("overridden date,short format", dateDefault.format(args), dateShort.format(args)); [EOL]             assertEquals("overridden date,short pattern", pattern, dateShort.toPattern()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test the built in number formats. [EOL]      */ [EOL]
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessageFormat("{0,date}", locale); [EOL]             final String pattern = "{0,date,short}"; [EOL]             final ExtendedMessageFormat dateShort = new ExtendedMessageFormat(pattern, locale, registry); [EOL]             assertEquals("overridden date,short format", dateDefault.format(args), dateShort.format(args)); [EOL]             assertEquals("overridden date,short pattern", pattern, dateShort.toPattern()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test the built in number formats. [EOL]      */ [EOL]
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessageFormat("{0,date}", locale); [EOL]             final String pattern = "{0,date,short}"; [EOL]             final ExtendedMessageFormat dateShort = new ExtendedMessageFormat(pattern, locale, registry); [EOL]             assertEquals("overridden date,short format", dateDefault.format(args), dateShort.format(args)); [EOL]             assertEquals("overridden date,short pattern", pattern, dateShort.toPattern()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test the built in number formats. [EOL]      */ [EOL]
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessageFormat("{0,date}", locale); [EOL]             final String pattern = "{0,date,short}"; [EOL]             final ExtendedMessageFormat dateShort = new ExtendedMessageFormat(pattern, locale, registry); [EOL]             assertEquals("overridden date,short format", dateDefault.format(args), dateShort.format(args)); [EOL]             assertEquals("overridden date,short pattern", pattern, dateShort.toPattern()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test the built in number formats. [EOL]      */ [EOL]
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessageFormat("{0,date}", locale); [EOL]             final String pattern = "{0,date,short}"; [EOL]             final ExtendedMessageFormat dateShort = new ExtendedMessageFormat(pattern, locale, registry); [EOL]             assertEquals("overridden date,short format", dateDefault.format(args), dateShort.format(args)); [EOL]             assertEquals("overridden date,short pattern", pattern, dateShort.toPattern()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test the built in number formats. [EOL]      */ [EOL]
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessageFormat("{0,date}", locale); [EOL]             final String pattern = "{0,date,short}"; [EOL]             final ExtendedMessageFormat dateShort = new ExtendedMessageFormat(pattern, locale, registry); [EOL]             assertEquals("overridden date,short format", dateDefault.format(args), dateShort.format(args)); [EOL]             assertEquals("overridden date,short pattern", pattern, dateShort.toPattern()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test the built in number formats. [EOL]      */ [EOL]
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessageFormat("{0,date}", locale); [EOL]             final String pattern = "{0,date,short}"; [EOL]             final ExtendedMessageFormat dateShort = new ExtendedMessageFormat(pattern, locale, registry); [EOL]             assertEquals("overridden date,short format", dateDefault.format(args), dateShort.format(args)); [EOL]             assertEquals("overridden date,short pattern", pattern, dateShort.toPattern()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test the built in number formats. [EOL]      */ [EOL]
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessageFormat("{0,date}", locale); [EOL]             final String pattern = "{0,date,short}"; [EOL]             final ExtendedMessageFormat dateShort = new ExtendedMessageFormat(pattern, locale, registry); [EOL]             assertEquals("overridden date,short format", dateDefault.format(args), dateShort.format(args)); [EOL]             assertEquals("overridden date,short pattern", pattern, dateShort.toPattern()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test the built in number formats. [EOL]      */ [EOL]
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessageFormat("{0,date}", locale); [EOL]             final String pattern = "{0,date,short}"; [EOL]             final ExtendedMessageFormat dateShort = new ExtendedMessageFormat(pattern, locale, registry); [EOL]             assertEquals("overridden date,short format", dateDefault.format(args), dateShort.format(args)); [EOL]             assertEquals("overridden date,short pattern", pattern, dateShort.toPattern()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test the built in number formats. [EOL]      */ [EOL]
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessageFormat("{0,date}", locale); [EOL]             final String pattern = "{0,date,short}"; [EOL]             final ExtendedMessageFormat dateShort = new ExtendedMessageFormat(pattern, locale, registry); [EOL]             assertEquals("overridden date,short format", dateDefault.format(args), dateShort.format(args)); [EOL]             assertEquals("overridden date,short pattern", pattern, dateShort.toPattern()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test the built in number formats. [EOL]      */ [EOL]
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessageFormat("{0,date}", locale); [EOL]             final String pattern = "{0,date,short}"; [EOL]             final ExtendedMessageFormat dateShort = new ExtendedMessageFormat(pattern, locale, registry); [EOL]             assertEquals("overridden date,short format", dateDefault.format(args), dateShort.format(args)); [EOL]             assertEquals("overridden date,short pattern", pattern, dateShort.toPattern()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test the built in number formats. [EOL]      */ [EOL]
@Test [EOL]     public void testExtendedAndBuiltInFormats() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23, 18, 33, 05); [EOL]         final Object[] args = new Object[] {"John Doe", cal.getTime(), Double.valueOf("12345.67")}; [EOL]         final String builtinsPattern = "DOB: {1,date,short} Salary: {2,number,currency}"; [EOL]         final String extendedPattern = "Name: {0,upper} "; [EOL]         final String pattern = extendedPattern + builtinsPattern; [EOL]  [EOL]         final HashSet<Locale> testLocales = new HashSet<Locale>(); [EOL]         testLocales.addAll(Arrays.asList(DateFormat.getAvailableLocales())); [EOL]         testLocales.retainAll(Arrays.asList(NumberFormat.getAvailableLocales())); [EOL]         testLocales.add(null); [EOL]  [EOL]         for (final Locale locale : testLocales) { [EOL]             final MessageFormat builtins = createMessageFormat(builtinsPattern, locale); [EOL]             final String expectedPattern = extendedPattern + builtins.toPattern(); [EOL]             DateFormat df = null; [EOL]             NumberFormat nf = null; [EOL]             ExtendedMessageFormat emf = null; [EOL]             if (locale == null) { [EOL]                 df = DateFormat.getDateInstance(DateFormat.SHORT); [EOL]                 nf = NumberFormat.getCurrencyInstance(); [EOL]                 emf = new ExtendedMessageFormat(pattern, registry); [EOL]             } else { [EOL]                 df = DateFormat.getDateInstance(DateFormat.SHORT, locale); [EOL]                 nf = NumberFormat.getCurrencyInstance(locale); [EOL]                 emf = new ExtendedMessageFormat(pattern, locale, registry); [EOL]             } [EOL]             final StringBuilder expected = new StringBuilder(); [EOL]             expected.append("Name: "); [EOL]             expected.append(args[0].toString().toUpperCase()); [EOL]             expected.append(" DOB: "); [EOL]             expected.append(df.format(args[1])); [EOL]             expected.append(" Salary: "); [EOL]             expected.append(nf.format(args[2])); [EOL]             assertPatternsEqual("pattern comparison for locale " + locale, expectedPattern, emf.toPattern()); [EOL]             assertEquals(String.valueOf(locale), expected.toString(), emf.format(args)); [EOL]         } [EOL]     } [EOL]  [EOL] //    /** [EOL] //     * Test extended formats with choice format. [EOL] //     * [EOL] //     * NOTE: FAILING - currently sub-formats not supported [EOL] //     */ [EOL] //    public void testExtendedWithChoiceFormat() { [EOL] //        String pattern = "Choice: {0,choice,1.0#{1,lower}|2.0#{1,upper}}"; [EOL] //        ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL] //        assertPatterns(null, pattern, emf.toPattern()); [EOL] //        try { [EOL] //            assertEquals("one", emf.format(new Object[] {Integer.valueOf(1), "ONE"})); [EOL] //            assertEquals("TWO", emf.format(new Object[] {Integer.valueOf(2), "two"})); [EOL] //        } catch (IllegalArgumentException e) { [EOL] //            // currently sub-formats not supported [EOL] //        } [EOL] //    } [EOL]  [EOL] //    /** [EOL] //     * Test mixed extended and built-in formats with choice format. [EOL] //     * [EOL] //     * NOTE: FAILING - currently sub-formats not supported [EOL] //     */ [EOL] //    public void testExtendedAndBuiltInWithChoiceFormat() { [EOL] //        String pattern = "Choice: {0,choice,1.0#{0} {1,lower} {2,number}|2.0#{0} {1,upper} {2,number,currency}}"; [EOL] //        Object[] lowArgs  = new Object[] {Integer.valueOf(1), "Low",  Double.valueOf("1234.56")}; [EOL] //        Object[] highArgs = new Object[] {Integer.valueOf(2), "High", Double.valueOf("9876.54")}; [EOL] //        Locale[] availableLocales = ChoiceFormat.getAvailableLocales(); [EOL] //        Locale[] testLocales = new Locale[availableLocales.length + 1]; [EOL] //        testLocales[0] = null; [EOL] //        System.arraycopy(availableLocales, 0, testLocales, 1, availableLocales.length); [EOL] //        for (int i = 0; i < testLocales.length; i++) { [EOL] //            NumberFormat nf = null; [EOL] //            NumberFormat cf = null; [EOL] //            ExtendedMessageFormat emf = null; [EOL] //            if (testLocales[i] == null) { [EOL] //                nf = NumberFormat.getNumberInstance(); [EOL] //                cf = NumberFormat.getCurrencyInstance(); [EOL] //                emf = new ExtendedMessageFormat(pattern, registry); [EOL] //            } else { [EOL] //                nf = NumberFormat.getNumberInstance(testLocales[i]); [EOL] //                cf = NumberFormat.getCurrencyInstance(testLocales[i]); [EOL] //                emf = new ExtendedMessageFormat(pattern, testLocales[i], registry); [EOL] //            } [EOL] //            assertPatterns(null, pattern, emf.toPattern()); [EOL] //            try { [EOL] //                String lowExpected = lowArgs[0] + " low "    + nf.format(lowArgs[2]); [EOL] //                String highExpected = highArgs[0] + " HIGH "  + cf.format(highArgs[2]); [EOL] //                assertEquals(lowExpected,  emf.format(lowArgs)); [EOL] //                assertEquals(highExpected, emf.format(highArgs)); [EOL] //            } catch (IllegalArgumentException e) { [EOL] //                // currently sub-formats not supported [EOL] //            } [EOL] //        } [EOL] //    } [EOL]  [EOL]     /** [EOL]      * Test the built in choice format. [EOL]      */ [EOL]
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessageFormat("{0,date}", locale); [EOL]             final String pattern = "{0,date,short}"; [EOL]             final ExtendedMessageFormat dateShort = new ExtendedMessageFormat(pattern, locale, registry); [EOL]             assertEquals("overridden date,short format", dateDefault.format(args), dateShort.format(args)); [EOL]             assertEquals("overridden date,short pattern", pattern, dateShort.toPattern()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test the built in number formats. [EOL]      */ [EOL]
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessageFormat("{0,date}", locale); [EOL]             final String pattern = "{0,date,short}"; [EOL]             final ExtendedMessageFormat dateShort = new ExtendedMessageFormat(pattern, locale, registry); [EOL]             assertEquals("overridden date,short format", dateDefault.format(args), dateShort.format(args)); [EOL]             assertEquals("overridden date,short pattern", pattern, dateShort.toPattern()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test the built in number formats. [EOL]      */ [EOL]
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessageFormat("{0,date}", locale); [EOL]             final String pattern = "{0,date,short}"; [EOL]             final ExtendedMessageFormat dateShort = new ExtendedMessageFormat(pattern, locale, registry); [EOL]             assertEquals("overridden date,short format", dateDefault.format(args), dateShort.format(args)); [EOL]             assertEquals("overridden date,short pattern", pattern, dateShort.toPattern()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test the built in number formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessageFormat("{0,date}", locale); [EOL]             final String pattern = "{0,date,short}"; [EOL]             final ExtendedMessageFormat dateShort = new ExtendedMessageFormat(pattern, locale, registry); [EOL]             assertEquals("overridden date,short format", dateDefault.format(args), dateShort.format(args)); [EOL]             assertEquals("overridden date,short pattern", pattern, dateShort.toPattern()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test the built in number formats. [EOL]      */ [EOL]
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessageFormat("{0,date}", locale); [EOL]             final String pattern = "{0,date,short}"; [EOL]             final ExtendedMessageFormat dateShort = new ExtendedMessageFormat(pattern, locale, registry); [EOL]             assertEquals("overridden date,short format", dateDefault.format(args), dateShort.format(args)); [EOL]             assertEquals("overridden date,short pattern", pattern, dateShort.toPattern()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test the built in number formats. [EOL]      */ [EOL]
@Test [EOL]     public void testOverriddenBuiltinFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2007, Calendar.JANUARY, 23); [EOL]         final Object[] args = new Object[] {cal.getTime()}; [EOL]         final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]  [EOL]         //check the non-overridden builtins: [EOL]         checkBuiltInFormat("1: {0,date}", registry,          args, availableLocales); [EOL]         checkBuiltInFormat("2: {0,date,medium}", registry,   args, availableLocales); [EOL]         checkBuiltInFormat("3: {0,date,long}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("4: {0,date,full}", registry,     args, availableLocales); [EOL]         checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]  [EOL]         //check the overridden format: [EOL]         for (int i = -1; i < availableLocales.length; i++) { [EOL]             final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]             final MessageFormat dateDefault = createMessageFormat("{0,date}", locale); [EOL]             final String pattern = "{0,date,short}"; [EOL]             final ExtendedMessageFormat dateShort = new ExtendedMessageFormat(pattern, locale, registry); [EOL]             assertEquals("overridden date,short format", dateDefault.format(args), dateShort.format(args)); [EOL]             assertEquals("overridden date,short pattern", pattern, dateShort.toPattern()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test the built in number formats. [EOL]      */ [EOL]
@Test [EOL]     public void test_getShortClassName_Class() { [EOL]         assertEquals("ClassUtils", ClassUtils.getShortClassName(ClassUtils.class)); [EOL]         assertEquals("Map.Entry", ClassUtils.getShortClassName(Map.Entry.class)); [EOL]         assertEquals("", ClassUtils.getShortClassName((Class<?>) null)); [EOL]  [EOL]         // LANG-535 [EOL]         assertEquals("String[]", ClassUtils.getShortClassName(String[].class)); [EOL]         assertEquals("Map.Entry[]", ClassUtils.getShortClassName(Map.Entry[].class)); [EOL]  [EOL]         // Primitives [EOL]         assertEquals("boolean", ClassUtils.getShortClassName(boolean.class)); [EOL]         assertEquals("byte", ClassUtils.getShortClassName(byte.class)); [EOL]         assertEquals("char", ClassUtils.getShortClassName(char.class)); [EOL]         assertEquals("short", ClassUtils.getShortClassName(short.class)); [EOL]         assertEquals("int", ClassUtils.getShortClassName(int.class)); [EOL]         assertEquals("long", ClassUtils.getShortClassName(long.class)); [EOL]         assertEquals("float", ClassUtils.getShortClassName(float.class)); [EOL]         assertEquals("double", ClassUtils.getShortClassName(double.class)); [EOL]  [EOL]         // Primitive Arrays [EOL]         assertEquals("boolean[]", ClassUtils.getShortClassName(boolean[].class)); [EOL]         assertEquals("byte[]", ClassUtils.getShortClassName(byte[].class)); [EOL]         assertEquals("char[]", ClassUtils.getShortClassName(char[].class)); [EOL]         assertEquals("short[]", ClassUtils.getShortClassName(short[].class)); [EOL]         assertEquals("int[]", ClassUtils.getShortClassName(int[].class)); [EOL]         assertEquals("long[]", ClassUtils.getShortClassName(long[].class)); [EOL]         assertEquals("float[]", ClassUtils.getShortClassName(float[].class)); [EOL]         assertEquals("double[]", ClassUtils.getShortClassName(double[].class)); [EOL]  [EOL]         // Arrays of arrays of ... [EOL]         assertEquals("String[][]", ClassUtils.getShortClassName(String[][].class)); [EOL]         assertEquals("String[][][]", ClassUtils.getShortClassName(String[][][].class)); [EOL]         assertEquals("String[][][][]", ClassUtils.getShortClassName(String[][][][].class)); [EOL]          [EOL]         // Inner types [EOL]         class Named extends Object {} [EOL]         assertEquals("ClassUtilsTest.2", ClassUtils.getShortClassName(new Object(){}.getClass())); [EOL]         assertEquals("ClassUtilsTest.2Named", ClassUtils.getShortClassName(Named.class)); [EOL]         assertEquals("ClassUtilsTest.Inner", ClassUtils.getShortClassName(Inner.class)); [EOL]     } [EOL]  [EOL]  [EOL]  [EOL]
@Test [EOL]     public void test_getShortClassName_Class() { [EOL]         assertEquals("ClassUtils", ClassUtils.getShortClassName(ClassUtils.class)); [EOL]         assertEquals("Map.Entry", ClassUtils.getShortClassName(Map.Entry.class)); [EOL]         assertEquals("", ClassUtils.getShortClassName((Class<?>) null)); [EOL]  [EOL]         // LANG-535 [EOL]         assertEquals("String[]", ClassUtils.getShortClassName(String[].class)); [EOL]         assertEquals("Map.Entry[]", ClassUtils.getShortClassName(Map.Entry[].class)); [EOL]  [EOL]         // Primitives [EOL]         assertEquals("boolean", ClassUtils.getShortClassName(boolean.class)); [EOL]         assertEquals("byte", ClassUtils.getShortClassName(byte.class)); [EOL]         assertEquals("char", ClassUtils.getShortClassName(char.class)); [EOL]         assertEquals("short", ClassUtils.getShortClassName(short.class)); [EOL]         assertEquals("int", ClassUtils.getShortClassName(int.class)); [EOL]         assertEquals("long", ClassUtils.getShortClassName(long.class)); [EOL]         assertEquals("float", ClassUtils.getShortClassName(float.class)); [EOL]         assertEquals("double", ClassUtils.getShortClassName(double.class)); [EOL]  [EOL]         // Primitive Arrays [EOL]         assertEquals("boolean[]", ClassUtils.getShortClassName(boolean[].class)); [EOL]         assertEquals("byte[]", ClassUtils.getShortClassName(byte[].class)); [EOL]         assertEquals("char[]", ClassUtils.getShortClassName(char[].class)); [EOL]         assertEquals("short[]", ClassUtils.getShortClassName(short[].class)); [EOL]         assertEquals("int[]", ClassUtils.getShortClassName(int[].class)); [EOL]         assertEquals("long[]", ClassUtils.getShortClassName(long[].class)); [EOL]         assertEquals("float[]", ClassUtils.getShortClassName(float[].class)); [EOL]         assertEquals("double[]", ClassUtils.getShortClassName(double[].class)); [EOL]  [EOL]         // Arrays of arrays of ... [EOL]         assertEquals("String[][]", ClassUtils.getShortClassName(String[][].class)); [EOL]         assertEquals("String[][][]", ClassUtils.getShortClassName(String[][][].class)); [EOL]         assertEquals("String[][][][]", ClassUtils.getShortClassName(String[][][][].class)); [EOL]          [EOL]         // Inner types [EOL]         class Named extends Object {} [EOL]         assertEquals("ClassUtilsTest.2", ClassUtils.getShortClassName(new Object(){}.getClass())); [EOL]         assertEquals("ClassUtilsTest.2Named", ClassUtils.getShortClassName(Named.class)); [EOL]         assertEquals("ClassUtilsTest.Inner", ClassUtils.getShortClassName(Inner.class)); [EOL]     } [EOL]  [EOL]  [EOL]  [EOL]
@Test [EOL]     public void test_getSimpleName_Class() { [EOL]         assertEquals("ClassUtils", ClassUtils.getSimpleName(ClassUtils.class)); [EOL]         assertEquals("Entry", ClassUtils.getSimpleName(Map.Entry.class)); [EOL]         assertEquals("", ClassUtils.getSimpleName((Class<?>) null)); [EOL]  [EOL]         // LANG-535 [EOL]         assertEquals("String[]", ClassUtils.getSimpleName(String[].class)); [EOL]         assertEquals("Entry[]", ClassUtils.getSimpleName(Map.Entry[].class)); [EOL]  [EOL]         // Primitives [EOL]         assertEquals("boolean", ClassUtils.getSimpleName(boolean.class)); [EOL]         assertEquals("byte", ClassUtils.getSimpleName(byte.class)); [EOL]         assertEquals("char", ClassUtils.getSimpleName(char.class)); [EOL]         assertEquals("short", ClassUtils.getSimpleName(short.class)); [EOL]         assertEquals("int", ClassUtils.getSimpleName(int.class)); [EOL]         assertEquals("long", ClassUtils.getSimpleName(long.class)); [EOL]         assertEquals("float", ClassUtils.getSimpleName(float.class)); [EOL]         assertEquals("double", ClassUtils.getSimpleName(double.class)); [EOL]  [EOL]         // Primitive Arrays [EOL]         assertEquals("boolean[]", ClassUtils.getSimpleName(boolean[].class)); [EOL]         assertEquals("byte[]", ClassUtils.getSimpleName(byte[].class)); [EOL]         assertEquals("char[]", ClassUtils.getSimpleName(char[].class)); [EOL]         assertEquals("short[]", ClassUtils.getSimpleName(short[].class)); [EOL]         assertEquals("int[]", ClassUtils.getSimpleName(int[].class)); [EOL]         assertEquals("long[]", ClassUtils.getSimpleName(long[].class)); [EOL]         assertEquals("float[]", ClassUtils.getSimpleName(float[].class)); [EOL]         assertEquals("double[]", ClassUtils.getSimpleName(double[].class)); [EOL]  [EOL]         // Arrays of arrays of ... [EOL]         assertEquals("String[][]", ClassUtils.getSimpleName(String[][].class)); [EOL]         assertEquals("String[][][]", ClassUtils.getSimpleName(String[][][].class)); [EOL]         assertEquals("String[][][][]", ClassUtils.getSimpleName(String[][][][].class)); [EOL]          [EOL]         // On-the-fly types [EOL]         class Named extends Object {} [EOL]         assertEquals("", ClassUtils.getSimpleName(new Object(){}.getClass())); [EOL]         assertEquals("Named", ClassUtils.getSimpleName(Named.class)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void test_getPackageName_Class() { [EOL]         assertEquals("java.lang", ClassUtils.getPackageName(String.class)); [EOL]         assertEquals("java.util", ClassUtils.getPackageName(Map.Entry.class)); [EOL]         assertEquals("", ClassUtils.getPackageName((Class<?>)null)); [EOL]  [EOL]         // LANG-535 [EOL]         assertEquals("java.lang", ClassUtils.getPackageName(String[].class)); [EOL]  [EOL]         // Primitive Arrays [EOL]         assertEquals("", ClassUtils.getPackageName(boolean[].class)); [EOL]         assertEquals("", ClassUtils.getPackageName(byte[].class)); [EOL]         assertEquals("", ClassUtils.getPackageName(char[].class)); [EOL]         assertEquals("", ClassUtils.getPackageName(short[].class)); [EOL]         assertEquals("", ClassUtils.getPackageName(int[].class)); [EOL]         assertEquals("", ClassUtils.getPackageName(long[].class)); [EOL]         assertEquals("", ClassUtils.getPackageName(float[].class)); [EOL]         assertEquals("", ClassUtils.getPackageName(double[].class)); [EOL]  [EOL]         // Arrays of arrays of ... [EOL]         assertEquals("java.lang", ClassUtils.getPackageName(String[][].class)); [EOL]         assertEquals("java.lang", ClassUtils.getPackageName(String[][][].class)); [EOL]         assertEquals("java.lang", ClassUtils.getPackageName(String[][][][].class)); [EOL]          [EOL]         // On-the-fly types [EOL]         class Named extends Object {} [EOL]         assertEquals("org.apache.commons.lang3", ClassUtils.getPackageName(new Object(){}.getClass())); [EOL]         assertEquals("org.apache.commons.lang3", ClassUtils.getPackageName(Named.class)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void test_getPackageName_Class() { [EOL]         assertEquals("java.lang", ClassUtils.getPackageName(String.class)); [EOL]         assertEquals("java.util", ClassUtils.getPackageName(Map.Entry.class)); [EOL]         assertEquals("", ClassUtils.getPackageName((Class<?>)null)); [EOL]  [EOL]         // LANG-535 [EOL]         assertEquals("java.lang", ClassUtils.getPackageName(String[].class)); [EOL]  [EOL]         // Primitive Arrays [EOL]         assertEquals("", ClassUtils.getPackageName(boolean[].class)); [EOL]         assertEquals("", ClassUtils.getPackageName(byte[].class)); [EOL]         assertEquals("", ClassUtils.getPackageName(char[].class)); [EOL]         assertEquals("", ClassUtils.getPackageName(short[].class)); [EOL]         assertEquals("", ClassUtils.getPackageName(int[].class)); [EOL]         assertEquals("", ClassUtils.getPackageName(long[].class)); [EOL]         assertEquals("", ClassUtils.getPackageName(float[].class)); [EOL]         assertEquals("", ClassUtils.getPackageName(double[].class)); [EOL]  [EOL]         // Arrays of arrays of ... [EOL]         assertEquals("java.lang", ClassUtils.getPackageName(String[][].class)); [EOL]         assertEquals("java.lang", ClassUtils.getPackageName(String[][][].class)); [EOL]         assertEquals("java.lang", ClassUtils.getPackageName(String[][][][].class)); [EOL]          [EOL]         // On-the-fly types [EOL]         class Named extends Object {} [EOL]         assertEquals("org.apache.commons.lang3", ClassUtils.getPackageName(new Object(){}.getClass())); [EOL]         assertEquals("org.apache.commons.lang3", ClassUtils.getPackageName(Named.class)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void test_convertClassesToClassNames_List() { [EOL]         final List<Class<?>> list = new ArrayList<Class<?>>(); [EOL]         List<String> result = ClassUtils.convertClassesToClassNames(list); [EOL]         assertEquals(0, result.size()); [EOL]  [EOL]         list.add(String.class); [EOL]         list.add(null); [EOL]         list.add(Object.class); [EOL]         result = ClassUtils.convertClassesToClassNames(list); [EOL]         assertEquals(3, result.size()); [EOL]         assertEquals("java.lang.String", result.get(0)); [EOL]         assertEquals(null, result.get(1)); [EOL]         assertEquals("java.lang.Object", result.get(2)); [EOL]  [EOL]         @SuppressWarnings("unchecked") // test what happens when non-generic code adds wrong type of element [EOL]         final [EOL]         List<Object> olist = (List<Object>)(List<?>)list; [EOL]         olist.add(new Object()); [EOL]         try { [EOL]             ClassUtils.convertClassesToClassNames(list); [EOL]             fail("Should not have been able to convert list"); [EOL]         } catch (final ClassCastException expected) {} [EOL]         assertEquals(null, ClassUtils.convertClassesToClassNames(null)); [EOL]     } [EOL]  [EOL]     // ------------------------------------------------------------------------- [EOL]
@Test [EOL]     public void test_isAssignable_DefaultUnboxing_Widening() throws Exception { [EOL]         final boolean autoboxing = SystemUtils.isJavaVersionAtLeast(JAVA_1_5); [EOL]  [EOL]         // test byte conversions [EOL]         assertFalse("byte -> char", ClassUtils.isAssignable(Byte.class, Character.TYPE)); [EOL]         assertEquals("byte -> byte", autoboxing, ClassUtils.isAssignable(Byte.class, Byte.TYPE)); [EOL]         assertEquals("byte -> short", autoboxing, ClassUtils.isAssignable(Byte.class, Short.TYPE)); [EOL]         assertEquals("byte -> int", autoboxing, ClassUtils.isAssignable(Byte.class, Integer.TYPE)); [EOL]         assertEquals("byte -> long", autoboxing, ClassUtils.isAssignable(Byte.class, Long.TYPE)); [EOL]         assertEquals("byte -> float", autoboxing, ClassUtils.isAssignable(Byte.class, Float.TYPE)); [EOL]         assertEquals("byte -> double", autoboxing, ClassUtils.isAssignable(Byte.class, Double.TYPE)); [EOL]         assertFalse("byte -> boolean", ClassUtils.isAssignable(Byte.class, Boolean.TYPE)); [EOL]  [EOL]         // test short conversions [EOL]         assertFalse("short -> char", ClassUtils.isAssignable(Short.class, Character.TYPE)); [EOL]         assertFalse("short -> byte", ClassUtils.isAssignable(Short.class, Byte.TYPE)); [EOL]         assertEquals("short -> short", autoboxing, ClassUtils.isAssignable(Short.class, Short.TYPE)); [EOL]         assertEquals("short -> int", autoboxing, ClassUtils.isAssignable(Short.class, Integer.TYPE)); [EOL]         assertEquals("short -> long", autoboxing, ClassUtils.isAssignable(Short.class, Long.TYPE)); [EOL]         assertEquals("short -> float", autoboxing, ClassUtils.isAssignable(Short.class, Float.TYPE)); [EOL]         assertEquals("short -> double", autoboxing, ClassUtils.isAssignable(Short.class, Double.TYPE)); [EOL]         assertFalse("short -> boolean", ClassUtils.isAssignable(Short.class, Boolean.TYPE)); [EOL]  [EOL]         // test char conversions [EOL]         assertEquals("char -> char", autoboxing, ClassUtils.isAssignable(Character.class, Character.TYPE)); [EOL]         assertFalse("char -> byte", ClassUtils.isAssignable(Character.class, Byte.TYPE)); [EOL]         assertFalse("char -> short", ClassUtils.isAssignable(Character.class, Short.TYPE)); [EOL]         assertEquals("char -> int", autoboxing, ClassUtils.isAssignable(Character.class, Integer.TYPE)); [EOL]         assertEquals("char -> long", autoboxing, ClassUtils.isAssignable(Character.class, Long.TYPE)); [EOL]         assertEquals("char -> float", autoboxing, ClassUtils.isAssignable(Character.class, Float.TYPE)); [EOL]         assertEquals("char -> double", autoboxing, ClassUtils.isAssignable(Character.class, Double.TYPE)); [EOL]         assertFalse("char -> boolean", ClassUtils.isAssignable(Character.class, Boolean.TYPE)); [EOL]  [EOL]         // test int conversions [EOL]         assertFalse("int -> char", ClassUtils.isAssignable(Integer.class, Character.TYPE)); [EOL]         assertFalse("int -> byte", ClassUtils.isAssignable(Integer.class, Byte.TYPE)); [EOL]         assertFalse("int -> short", ClassUtils.isAssignable(Integer.class, Short.TYPE)); [EOL]         assertEquals("int -> int", autoboxing, ClassUtils.isAssignable(Integer.class, Integer.TYPE)); [EOL]         assertEquals("int -> long", autoboxing, ClassUtils.isAssignable(Integer.class, Long.TYPE)); [EOL]         assertEquals("int -> float", autoboxing, ClassUtils.isAssignable(Integer.class, Float.TYPE)); [EOL]         assertEquals("int -> double", autoboxing, ClassUtils.isAssignable(Integer.class, Double.TYPE)); [EOL]         assertFalse("int -> boolean", ClassUtils.isAssignable(Integer.class, Boolean.TYPE)); [EOL]  [EOL]         // test long conversions [EOL]         assertFalse("long -> char", ClassUtils.isAssignable(Long.class, Character.TYPE)); [EOL]         assertFalse("long -> byte", ClassUtils.isAssignable(Long.class, Byte.TYPE)); [EOL]         assertFalse("long -> short", ClassUtils.isAssignable(Long.class, Short.TYPE)); [EOL]         assertFalse("long -> int", ClassUtils.isAssignable(Long.class, Integer.TYPE)); [EOL]         assertEquals("long -> long", autoboxing, ClassUtils.isAssignable(Long.class, Long.TYPE)); [EOL]         assertEquals("long -> float", autoboxing, ClassUtils.isAssignable(Long.class, Float.TYPE)); [EOL]         assertEquals("long -> double", autoboxing, ClassUtils.isAssignable(Long.class, Double.TYPE)); [EOL]         assertFalse("long -> boolean", ClassUtils.isAssignable(Long.class, Boolean.TYPE)); [EOL]  [EOL]         // test float conversions [EOL]         assertFalse("float -> char", ClassUtils.isAssignable(Float.class, Character.TYPE)); [EOL]         assertFalse("float -> byte", ClassUtils.isAssignable(Float.class, Byte.TYPE)); [EOL]         assertFalse("float -> short", ClassUtils.isAssignable(Float.class, Short.TYPE)); [EOL]         assertFalse("float -> int", ClassUtils.isAssignable(Float.class, Integer.TYPE)); [EOL]         assertFalse("float -> long", ClassUtils.isAssignable(Float.class, Long.TYPE)); [EOL]         assertEquals("float -> float", autoboxing, ClassUtils.isAssignable(Float.class, Float.TYPE)); [EOL]         assertEquals("float -> double", autoboxing, ClassUtils.isAssignable(Float.class, Double.TYPE)); [EOL]         assertFalse("float -> boolean", ClassUtils.isAssignable(Float.class, Boolean.TYPE)); [EOL]  [EOL]         // test double conversions [EOL]         assertFalse("double -> char", ClassUtils.isAssignable(Double.class, Character.TYPE)); [EOL]         assertFalse("double -> byte", ClassUtils.isAssignable(Double.class, Byte.TYPE)); [EOL]         assertFalse("double -> short", ClassUtils.isAssignable(Double.class, Short.TYPE)); [EOL]         assertFalse("double -> int", ClassUtils.isAssignable(Double.class, Integer.TYPE)); [EOL]         assertFalse("double -> long", ClassUtils.isAssignable(Double.class, Long.TYPE)); [EOL]         assertFalse("double -> float", ClassUtils.isAssignable(Double.class, Float.TYPE)); [EOL]         assertEquals("double -> double", autoboxing, ClassUtils.isAssignable(Double.class, Double.TYPE)); [EOL]         assertFalse("double -> boolean", ClassUtils.isAssignable(Double.class, Boolean.TYPE)); [EOL]  [EOL]         // test boolean conversions [EOL]         assertFalse("boolean -> char", ClassUtils.isAssignable(Boolean.class, Character.TYPE)); [EOL]         assertFalse("boolean -> byte", ClassUtils.isAssignable(Boolean.class, Byte.TYPE)); [EOL]         assertFalse("boolean -> short", ClassUtils.isAssignable(Boolean.class, Short.TYPE)); [EOL]         assertFalse("boolean -> int", ClassUtils.isAssignable(Boolean.class, Integer.TYPE)); [EOL]         assertFalse("boolean -> long", ClassUtils.isAssignable(Boolean.class, Long.TYPE)); [EOL]         assertFalse("boolean -> float", ClassUtils.isAssignable(Boolean.class, Float.TYPE)); [EOL]         assertFalse("boolean -> double", ClassUtils.isAssignable(Boolean.class, Double.TYPE)); [EOL]         assertEquals("boolean -> boolean", autoboxing, ClassUtils.isAssignable(Boolean.class, Boolean.TYPE)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void test_isAssignable_DefaultUnboxing_Widening() throws Exception { [EOL]         final boolean autoboxing = SystemUtils.isJavaVersionAtLeast(JAVA_1_5); [EOL]  [EOL]         // test byte conversions [EOL]         assertFalse("byte -> char", ClassUtils.isAssignable(Byte.class, Character.TYPE)); [EOL]         assertEquals("byte -> byte", autoboxing, ClassUtils.isAssignable(Byte.class, Byte.TYPE)); [EOL]         assertEquals("byte -> short", autoboxing, ClassUtils.isAssignable(Byte.class, Short.TYPE)); [EOL]         assertEquals("byte -> int", autoboxing, ClassUtils.isAssignable(Byte.class, Integer.TYPE)); [EOL]         assertEquals("byte -> long", autoboxing, ClassUtils.isAssignable(Byte.class, Long.TYPE)); [EOL]         assertEquals("byte -> float", autoboxing, ClassUtils.isAssignable(Byte.class, Float.TYPE)); [EOL]         assertEquals("byte -> double", autoboxing, ClassUtils.isAssignable(Byte.class, Double.TYPE)); [EOL]         assertFalse("byte -> boolean", ClassUtils.isAssignable(Byte.class, Boolean.TYPE)); [EOL]  [EOL]         // test short conversions [EOL]         assertFalse("short -> char", ClassUtils.isAssignable(Short.class, Character.TYPE)); [EOL]         assertFalse("short -> byte", ClassUtils.isAssignable(Short.class, Byte.TYPE)); [EOL]         assertEquals("short -> short", autoboxing, ClassUtils.isAssignable(Short.class, Short.TYPE)); [EOL]         assertEquals("short -> int", autoboxing, ClassUtils.isAssignable(Short.class, Integer.TYPE)); [EOL]         assertEquals("short -> long", autoboxing, ClassUtils.isAssignable(Short.class, Long.TYPE)); [EOL]         assertEquals("short -> float", autoboxing, ClassUtils.isAssignable(Short.class, Float.TYPE)); [EOL]         assertEquals("short -> double", autoboxing, ClassUtils.isAssignable(Short.class, Double.TYPE)); [EOL]         assertFalse("short -> boolean", ClassUtils.isAssignable(Short.class, Boolean.TYPE)); [EOL]  [EOL]         // test char conversions [EOL]         assertEquals("char -> char", autoboxing, ClassUtils.isAssignable(Character.class, Character.TYPE)); [EOL]         assertFalse("char -> byte", ClassUtils.isAssignable(Character.class, Byte.TYPE)); [EOL]         assertFalse("char -> short", ClassUtils.isAssignable(Character.class, Short.TYPE)); [EOL]         assertEquals("char -> int", autoboxing, ClassUtils.isAssignable(Character.class, Integer.TYPE)); [EOL]         assertEquals("char -> long", autoboxing, ClassUtils.isAssignable(Character.class, Long.TYPE)); [EOL]         assertEquals("char -> float", autoboxing, ClassUtils.isAssignable(Character.class, Float.TYPE)); [EOL]         assertEquals("char -> double", autoboxing, ClassUtils.isAssignable(Character.class, Double.TYPE)); [EOL]         assertFalse("char -> boolean", ClassUtils.isAssignable(Character.class, Boolean.TYPE)); [EOL]  [EOL]         // test int conversions [EOL]         assertFalse("int -> char", ClassUtils.isAssignable(Integer.class, Character.TYPE)); [EOL]         assertFalse("int -> byte", ClassUtils.isAssignable(Integer.class, Byte.TYPE)); [EOL]         assertFalse("int -> short", ClassUtils.isAssignable(Integer.class, Short.TYPE)); [EOL]         assertEquals("int -> int", autoboxing, ClassUtils.isAssignable(Integer.class, Integer.TYPE)); [EOL]         assertEquals("int -> long", autoboxing, ClassUtils.isAssignable(Integer.class, Long.TYPE)); [EOL]         assertEquals("int -> float", autoboxing, ClassUtils.isAssignable(Integer.class, Float.TYPE)); [EOL]         assertEquals("int -> double", autoboxing, ClassUtils.isAssignable(Integer.class, Double.TYPE)); [EOL]         assertFalse("int -> boolean", ClassUtils.isAssignable(Integer.class, Boolean.TYPE)); [EOL]  [EOL]         // test long conversions [EOL]         assertFalse("long -> char", ClassUtils.isAssignable(Long.class, Character.TYPE)); [EOL]         assertFalse("long -> byte", ClassUtils.isAssignable(Long.class, Byte.TYPE)); [EOL]         assertFalse("long -> short", ClassUtils.isAssignable(Long.class, Short.TYPE)); [EOL]         assertFalse("long -> int", ClassUtils.isAssignable(Long.class, Integer.TYPE)); [EOL]         assertEquals("long -> long", autoboxing, ClassUtils.isAssignable(Long.class, Long.TYPE)); [EOL]         assertEquals("long -> float", autoboxing, ClassUtils.isAssignable(Long.class, Float.TYPE)); [EOL]         assertEquals("long -> double", autoboxing, ClassUtils.isAssignable(Long.class, Double.TYPE)); [EOL]         assertFalse("long -> boolean", ClassUtils.isAssignable(Long.class, Boolean.TYPE)); [EOL]  [EOL]         // test float conversions [EOL]         assertFalse("float -> char", ClassUtils.isAssignable(Float.class, Character.TYPE)); [EOL]         assertFalse("float -> byte", ClassUtils.isAssignable(Float.class, Byte.TYPE)); [EOL]         assertFalse("float -> short", ClassUtils.isAssignable(Float.class, Short.TYPE)); [EOL]         assertFalse("float -> int", ClassUtils.isAssignable(Float.class, Integer.TYPE)); [EOL]         assertFalse("float -> long", ClassUtils.isAssignable(Float.class, Long.TYPE)); [EOL]         assertEquals("float -> float", autoboxing, ClassUtils.isAssignable(Float.class, Float.TYPE)); [EOL]         assertEquals("float -> double", autoboxing, ClassUtils.isAssignable(Float.class, Double.TYPE)); [EOL]         assertFalse("float -> boolean", ClassUtils.isAssignable(Float.class, Boolean.TYPE)); [EOL]  [EOL]         // test double conversions [EOL]         assertFalse("double -> char", ClassUtils.isAssignable(Double.class, Character.TYPE)); [EOL]         assertFalse("double -> byte", ClassUtils.isAssignable(Double.class, Byte.TYPE)); [EOL]         assertFalse("double -> short", ClassUtils.isAssignable(Double.class, Short.TYPE)); [EOL]         assertFalse("double -> int", ClassUtils.isAssignable(Double.class, Integer.TYPE)); [EOL]         assertFalse("double -> long", ClassUtils.isAssignable(Double.class, Long.TYPE)); [EOL]         assertFalse("double -> float", ClassUtils.isAssignable(Double.class, Float.TYPE)); [EOL]         assertEquals("double -> double", autoboxing, ClassUtils.isAssignable(Double.class, Double.TYPE)); [EOL]         assertFalse("double -> boolean", ClassUtils.isAssignable(Double.class, Boolean.TYPE)); [EOL]  [EOL]         // test boolean conversions [EOL]         assertFalse("boolean -> char", ClassUtils.isAssignable(Boolean.class, Character.TYPE)); [EOL]         assertFalse("boolean -> byte", ClassUtils.isAssignable(Boolean.class, Byte.TYPE)); [EOL]         assertFalse("boolean -> short", ClassUtils.isAssignable(Boolean.class, Short.TYPE)); [EOL]         assertFalse("boolean -> int", ClassUtils.isAssignable(Boolean.class, Integer.TYPE)); [EOL]         assertFalse("boolean -> long", ClassUtils.isAssignable(Boolean.class, Long.TYPE)); [EOL]         assertFalse("boolean -> float", ClassUtils.isAssignable(Boolean.class, Float.TYPE)); [EOL]         assertFalse("boolean -> double", ClassUtils.isAssignable(Boolean.class, Double.TYPE)); [EOL]         assertEquals("boolean -> boolean", autoboxing, ClassUtils.isAssignable(Boolean.class, Boolean.TYPE)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void test_isAssignable_DefaultUnboxing_Widening() throws Exception { [EOL]         final boolean autoboxing = SystemUtils.isJavaVersionAtLeast(JAVA_1_5); [EOL]  [EOL]         // test byte conversions [EOL]         assertFalse("byte -> char", ClassUtils.isAssignable(Byte.class, Character.TYPE)); [EOL]         assertEquals("byte -> byte", autoboxing, ClassUtils.isAssignable(Byte.class, Byte.TYPE)); [EOL]         assertEquals("byte -> short", autoboxing, ClassUtils.isAssignable(Byte.class, Short.TYPE)); [EOL]         assertEquals("byte -> int", autoboxing, ClassUtils.isAssignable(Byte.class, Integer.TYPE)); [EOL]         assertEquals("byte -> long", autoboxing, ClassUtils.isAssignable(Byte.class, Long.TYPE)); [EOL]         assertEquals("byte -> float", autoboxing, ClassUtils.isAssignable(Byte.class, Float.TYPE)); [EOL]         assertEquals("byte -> double", autoboxing, ClassUtils.isAssignable(Byte.class, Double.TYPE)); [EOL]         assertFalse("byte -> boolean", ClassUtils.isAssignable(Byte.class, Boolean.TYPE)); [EOL]  [EOL]         // test short conversions [EOL]         assertFalse("short -> char", ClassUtils.isAssignable(Short.class, Character.TYPE)); [EOL]         assertFalse("short -> byte", ClassUtils.isAssignable(Short.class, Byte.TYPE)); [EOL]         assertEquals("short -> short", autoboxing, ClassUtils.isAssignable(Short.class, Short.TYPE)); [EOL]         assertEquals("short -> int", autoboxing, ClassUtils.isAssignable(Short.class, Integer.TYPE)); [EOL]         assertEquals("short -> long", autoboxing, ClassUtils.isAssignable(Short.class, Long.TYPE)); [EOL]         assertEquals("short -> float", autoboxing, ClassUtils.isAssignable(Short.class, Float.TYPE)); [EOL]         assertEquals("short -> double", autoboxing, ClassUtils.isAssignable(Short.class, Double.TYPE)); [EOL]         assertFalse("short -> boolean", ClassUtils.isAssignable(Short.class, Boolean.TYPE)); [EOL]  [EOL]         // test char conversions [EOL]         assertEquals("char -> char", autoboxing, ClassUtils.isAssignable(Character.class, Character.TYPE)); [EOL]         assertFalse("char -> byte", ClassUtils.isAssignable(Character.class, Byte.TYPE)); [EOL]         assertFalse("char -> short", ClassUtils.isAssignable(Character.class, Short.TYPE)); [EOL]         assertEquals("char -> int", autoboxing, ClassUtils.isAssignable(Character.class, Integer.TYPE)); [EOL]         assertEquals("char -> long", autoboxing, ClassUtils.isAssignable(Character.class, Long.TYPE)); [EOL]         assertEquals("char -> float", autoboxing, ClassUtils.isAssignable(Character.class, Float.TYPE)); [EOL]         assertEquals("char -> double", autoboxing, ClassUtils.isAssignable(Character.class, Double.TYPE)); [EOL]         assertFalse("char -> boolean", ClassUtils.isAssignable(Character.class, Boolean.TYPE)); [EOL]  [EOL]         // test int conversions [EOL]         assertFalse("int -> char", ClassUtils.isAssignable(Integer.class, Character.TYPE)); [EOL]         assertFalse("int -> byte", ClassUtils.isAssignable(Integer.class, Byte.TYPE)); [EOL]         assertFalse("int -> short", ClassUtils.isAssignable(Integer.class, Short.TYPE)); [EOL]         assertEquals("int -> int", autoboxing, ClassUtils.isAssignable(Integer.class, Integer.TYPE)); [EOL]         assertEquals("int -> long", autoboxing, ClassUtils.isAssignable(Integer.class, Long.TYPE)); [EOL]         assertEquals("int -> float", autoboxing, ClassUtils.isAssignable(Integer.class, Float.TYPE)); [EOL]         assertEquals("int -> double", autoboxing, ClassUtils.isAssignable(Integer.class, Double.TYPE)); [EOL]         assertFalse("int -> boolean", ClassUtils.isAssignable(Integer.class, Boolean.TYPE)); [EOL]  [EOL]         // test long conversions [EOL]         assertFalse("long -> char", ClassUtils.isAssignable(Long.class, Character.TYPE)); [EOL]         assertFalse("long -> byte", ClassUtils.isAssignable(Long.class, Byte.TYPE)); [EOL]         assertFalse("long -> short", ClassUtils.isAssignable(Long.class, Short.TYPE)); [EOL]         assertFalse("long -> int", ClassUtils.isAssignable(Long.class, Integer.TYPE)); [EOL]         assertEquals("long -> long", autoboxing, ClassUtils.isAssignable(Long.class, Long.TYPE)); [EOL]         assertEquals("long -> float", autoboxing, ClassUtils.isAssignable(Long.class, Float.TYPE)); [EOL]         assertEquals("long -> double", autoboxing, ClassUtils.isAssignable(Long.class, Double.TYPE)); [EOL]         assertFalse("long -> boolean", ClassUtils.isAssignable(Long.class, Boolean.TYPE)); [EOL]  [EOL]         // test float conversions [EOL]         assertFalse("float -> char", ClassUtils.isAssignable(Float.class, Character.TYPE)); [EOL]         assertFalse("float -> byte", ClassUtils.isAssignable(Float.class, Byte.TYPE)); [EOL]         assertFalse("float -> short", ClassUtils.isAssignable(Float.class, Short.TYPE)); [EOL]         assertFalse("float -> int", ClassUtils.isAssignable(Float.class, Integer.TYPE)); [EOL]         assertFalse("float -> long", ClassUtils.isAssignable(Float.class, Long.TYPE)); [EOL]         assertEquals("float -> float", autoboxing, ClassUtils.isAssignable(Float.class, Float.TYPE)); [EOL]         assertEquals("float -> double", autoboxing, ClassUtils.isAssignable(Float.class, Double.TYPE)); [EOL]         assertFalse("float -> boolean", ClassUtils.isAssignable(Float.class, Boolean.TYPE)); [EOL]  [EOL]         // test double conversions [EOL]         assertFalse("double -> char", ClassUtils.isAssignable(Double.class, Character.TYPE)); [EOL]         assertFalse("double -> byte", ClassUtils.isAssignable(Double.class, Byte.TYPE)); [EOL]         assertFalse("double -> short", ClassUtils.isAssignable(Double.class, Short.TYPE)); [EOL]         assertFalse("double -> int", ClassUtils.isAssignable(Double.class, Integer.TYPE)); [EOL]         assertFalse("double -> long", ClassUtils.isAssignable(Double.class, Long.TYPE)); [EOL]         assertFalse("double -> float", ClassUtils.isAssignable(Double.class, Float.TYPE)); [EOL]         assertEquals("double -> double", autoboxing, ClassUtils.isAssignable(Double.class, Double.TYPE)); [EOL]         assertFalse("double -> boolean", ClassUtils.isAssignable(Double.class, Boolean.TYPE)); [EOL]  [EOL]         // test boolean conversions [EOL]         assertFalse("boolean -> char", ClassUtils.isAssignable(Boolean.class, Character.TYPE)); [EOL]         assertFalse("boolean -> byte", ClassUtils.isAssignable(Boolean.class, Byte.TYPE)); [EOL]         assertFalse("boolean -> short", ClassUtils.isAssignable(Boolean.class, Short.TYPE)); [EOL]         assertFalse("boolean -> int", ClassUtils.isAssignable(Boolean.class, Integer.TYPE)); [EOL]         assertFalse("boolean -> long", ClassUtils.isAssignable(Boolean.class, Long.TYPE)); [EOL]         assertFalse("boolean -> float", ClassUtils.isAssignable(Boolean.class, Float.TYPE)); [EOL]         assertFalse("boolean -> double", ClassUtils.isAssignable(Boolean.class, Double.TYPE)); [EOL]         assertEquals("boolean -> boolean", autoboxing, ClassUtils.isAssignable(Boolean.class, Boolean.TYPE)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void test_isAssignable_DefaultUnboxing_Widening() throws Exception { [EOL]         final boolean autoboxing = SystemUtils.isJavaVersionAtLeast(JAVA_1_5); [EOL]  [EOL]         // test byte conversions [EOL]         assertFalse("byte -> char", ClassUtils.isAssignable(Byte.class, Character.TYPE)); [EOL]         assertEquals("byte -> byte", autoboxing, ClassUtils.isAssignable(Byte.class, Byte.TYPE)); [EOL]         assertEquals("byte -> short", autoboxing, ClassUtils.isAssignable(Byte.class, Short.TYPE)); [EOL]         assertEquals("byte -> int", autoboxing, ClassUtils.isAssignable(Byte.class, Integer.TYPE)); [EOL]         assertEquals("byte -> long", autoboxing, ClassUtils.isAssignable(Byte.class, Long.TYPE)); [EOL]         assertEquals("byte -> float", autoboxing, ClassUtils.isAssignable(Byte.class, Float.TYPE)); [EOL]         assertEquals("byte -> double", autoboxing, ClassUtils.isAssignable(Byte.class, Double.TYPE)); [EOL]         assertFalse("byte -> boolean", ClassUtils.isAssignable(Byte.class, Boolean.TYPE)); [EOL]  [EOL]         // test short conversions [EOL]         assertFalse("short -> char", ClassUtils.isAssignable(Short.class, Character.TYPE)); [EOL]         assertFalse("short -> byte", ClassUtils.isAssignable(Short.class, Byte.TYPE)); [EOL]         assertEquals("short -> short", autoboxing, ClassUtils.isAssignable(Short.class, Short.TYPE)); [EOL]         assertEquals("short -> int", autoboxing, ClassUtils.isAssignable(Short.class, Integer.TYPE)); [EOL]         assertEquals("short -> long", autoboxing, ClassUtils.isAssignable(Short.class, Long.TYPE)); [EOL]         assertEquals("short -> float", autoboxing, ClassUtils.isAssignable(Short.class, Float.TYPE)); [EOL]         assertEquals("short -> double", autoboxing, ClassUtils.isAssignable(Short.class, Double.TYPE)); [EOL]         assertFalse("short -> boolean", ClassUtils.isAssignable(Short.class, Boolean.TYPE)); [EOL]  [EOL]         // test char conversions [EOL]         assertEquals("char -> char", autoboxing, ClassUtils.isAssignable(Character.class, Character.TYPE)); [EOL]         assertFalse("char -> byte", ClassUtils.isAssignable(Character.class, Byte.TYPE)); [EOL]         assertFalse("char -> short", ClassUtils.isAssignable(Character.class, Short.TYPE)); [EOL]         assertEquals("char -> int", autoboxing, ClassUtils.isAssignable(Character.class, Integer.TYPE)); [EOL]         assertEquals("char -> long", autoboxing, ClassUtils.isAssignable(Character.class, Long.TYPE)); [EOL]         assertEquals("char -> float", autoboxing, ClassUtils.isAssignable(Character.class, Float.TYPE)); [EOL]         assertEquals("char -> double", autoboxing, ClassUtils.isAssignable(Character.class, Double.TYPE)); [EOL]         assertFalse("char -> boolean", ClassUtils.isAssignable(Character.class, Boolean.TYPE)); [EOL]  [EOL]         // test int conversions [EOL]         assertFalse("int -> char", ClassUtils.isAssignable(Integer.class, Character.TYPE)); [EOL]         assertFalse("int -> byte", ClassUtils.isAssignable(Integer.class, Byte.TYPE)); [EOL]         assertFalse("int -> short", ClassUtils.isAssignable(Integer.class, Short.TYPE)); [EOL]         assertEquals("int -> int", autoboxing, ClassUtils.isAssignable(Integer.class, Integer.TYPE)); [EOL]         assertEquals("int -> long", autoboxing, ClassUtils.isAssignable(Integer.class, Long.TYPE)); [EOL]         assertEquals("int -> float", autoboxing, ClassUtils.isAssignable(Integer.class, Float.TYPE)); [EOL]         assertEquals("int -> double", autoboxing, ClassUtils.isAssignable(Integer.class, Double.TYPE)); [EOL]         assertFalse("int -> boolean", ClassUtils.isAssignable(Integer.class, Boolean.TYPE)); [EOL]  [EOL]         // test long conversions [EOL]         assertFalse("long -> char", ClassUtils.isAssignable(Long.class, Character.TYPE)); [EOL]         assertFalse("long -> byte", ClassUtils.isAssignable(Long.class, Byte.TYPE)); [EOL]         assertFalse("long -> short", ClassUtils.isAssignable(Long.class, Short.TYPE)); [EOL]         assertFalse("long -> int", ClassUtils.isAssignable(Long.class, Integer.TYPE)); [EOL]         assertEquals("long -> long", autoboxing, ClassUtils.isAssignable(Long.class, Long.TYPE)); [EOL]         assertEquals("long -> float", autoboxing, ClassUtils.isAssignable(Long.class, Float.TYPE)); [EOL]         assertEquals("long -> double", autoboxing, ClassUtils.isAssignable(Long.class, Double.TYPE)); [EOL]         assertFalse("long -> boolean", ClassUtils.isAssignable(Long.class, Boolean.TYPE)); [EOL]  [EOL]         // test float conversions [EOL]         assertFalse("float -> char", ClassUtils.isAssignable(Float.class, Character.TYPE)); [EOL]         assertFalse("float -> byte", ClassUtils.isAssignable(Float.class, Byte.TYPE)); [EOL]         assertFalse("float -> short", ClassUtils.isAssignable(Float.class, Short.TYPE)); [EOL]         assertFalse("float -> int", ClassUtils.isAssignable(Float.class, Integer.TYPE)); [EOL]         assertFalse("float -> long", ClassUtils.isAssignable(Float.class, Long.TYPE)); [EOL]         assertEquals("float -> float", autoboxing, ClassUtils.isAssignable(Float.class, Float.TYPE)); [EOL]         assertEquals("float -> double", autoboxing, ClassUtils.isAssignable(Float.class, Double.TYPE)); [EOL]         assertFalse("float -> boolean", ClassUtils.isAssignable(Float.class, Boolean.TYPE)); [EOL]  [EOL]         // test double conversions [EOL]         assertFalse("double -> char", ClassUtils.isAssignable(Double.class, Character.TYPE)); [EOL]         assertFalse("double -> byte", ClassUtils.isAssignable(Double.class, Byte.TYPE)); [EOL]         assertFalse("double -> short", ClassUtils.isAssignable(Double.class, Short.TYPE)); [EOL]         assertFalse("double -> int", ClassUtils.isAssignable(Double.class, Integer.TYPE)); [EOL]         assertFalse("double -> long", ClassUtils.isAssignable(Double.class, Long.TYPE)); [EOL]         assertFalse("double -> float", ClassUtils.isAssignable(Double.class, Float.TYPE)); [EOL]         assertEquals("double -> double", autoboxing, ClassUtils.isAssignable(Double.class, Double.TYPE)); [EOL]         assertFalse("double -> boolean", ClassUtils.isAssignable(Double.class, Boolean.TYPE)); [EOL]  [EOL]         // test boolean conversions [EOL]         assertFalse("boolean -> char", ClassUtils.isAssignable(Boolean.class, Character.TYPE)); [EOL]         assertFalse("boolean -> byte", ClassUtils.isAssignable(Boolean.class, Byte.TYPE)); [EOL]         assertFalse("boolean -> short", ClassUtils.isAssignable(Boolean.class, Short.TYPE)); [EOL]         assertFalse("boolean -> int", ClassUtils.isAssignable(Boolean.class, Integer.TYPE)); [EOL]         assertFalse("boolean -> long", ClassUtils.isAssignable(Boolean.class, Long.TYPE)); [EOL]         assertFalse("boolean -> float", ClassUtils.isAssignable(Boolean.class, Float.TYPE)); [EOL]         assertFalse("boolean -> double", ClassUtils.isAssignable(Boolean.class, Double.TYPE)); [EOL]         assertEquals("boolean -> boolean", autoboxing, ClassUtils.isAssignable(Boolean.class, Boolean.TYPE)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void test_isAssignable_DefaultUnboxing_Widening() throws Exception { [EOL]         final boolean autoboxing = SystemUtils.isJavaVersionAtLeast(JAVA_1_5); [EOL]  [EOL]         // test byte conversions [EOL]         assertFalse("byte -> char", ClassUtils.isAssignable(Byte.class, Character.TYPE)); [EOL]         assertEquals("byte -> byte", autoboxing, ClassUtils.isAssignable(Byte.class, Byte.TYPE)); [EOL]         assertEquals("byte -> short", autoboxing, ClassUtils.isAssignable(Byte.class, Short.TYPE)); [EOL]         assertEquals("byte -> int", autoboxing, ClassUtils.isAssignable(Byte.class, Integer.TYPE)); [EOL]         assertEquals("byte -> long", autoboxing, ClassUtils.isAssignable(Byte.class, Long.TYPE)); [EOL]         assertEquals("byte -> float", autoboxing, ClassUtils.isAssignable(Byte.class, Float.TYPE)); [EOL]         assertEquals("byte -> double", autoboxing, ClassUtils.isAssignable(Byte.class, Double.TYPE)); [EOL]         assertFalse("byte -> boolean", ClassUtils.isAssignable(Byte.class, Boolean.TYPE)); [EOL]  [EOL]         // test short conversions [EOL]         assertFalse("short -> char", ClassUtils.isAssignable(Short.class, Character.TYPE)); [EOL]         assertFalse("short -> byte", ClassUtils.isAssignable(Short.class, Byte.TYPE)); [EOL]         assertEquals("short -> short", autoboxing, ClassUtils.isAssignable(Short.class, Short.TYPE)); [EOL]         assertEquals("short -> int", autoboxing, ClassUtils.isAssignable(Short.class, Integer.TYPE)); [EOL]         assertEquals("short -> long", autoboxing, ClassUtils.isAssignable(Short.class, Long.TYPE)); [EOL]         assertEquals("short -> float", autoboxing, ClassUtils.isAssignable(Short.class, Float.TYPE)); [EOL]         assertEquals("short -> double", autoboxing, ClassUtils.isAssignable(Short.class, Double.TYPE)); [EOL]         assertFalse("short -> boolean", ClassUtils.isAssignable(Short.class, Boolean.TYPE)); [EOL]  [EOL]         // test char conversions [EOL]         assertEquals("char -> char", autoboxing, ClassUtils.isAssignable(Character.class, Character.TYPE)); [EOL]         assertFalse("char -> byte", ClassUtils.isAssignable(Character.class, Byte.TYPE)); [EOL]         assertFalse("char -> short", ClassUtils.isAssignable(Character.class, Short.TYPE)); [EOL]         assertEquals("char -> int", autoboxing, ClassUtils.isAssignable(Character.class, Integer.TYPE)); [EOL]         assertEquals("char -> long", autoboxing, ClassUtils.isAssignable(Character.class, Long.TYPE)); [EOL]         assertEquals("char -> float", autoboxing, ClassUtils.isAssignable(Character.class, Float.TYPE)); [EOL]         assertEquals("char -> double", autoboxing, ClassUtils.isAssignable(Character.class, Double.TYPE)); [EOL]         assertFalse("char -> boolean", ClassUtils.isAssignable(Character.class, Boolean.TYPE)); [EOL]  [EOL]         // test int conversions [EOL]         assertFalse("int -> char", ClassUtils.isAssignable(Integer.class, Character.TYPE)); [EOL]         assertFalse("int -> byte", ClassUtils.isAssignable(Integer.class, Byte.TYPE)); [EOL]         assertFalse("int -> short", ClassUtils.isAssignable(Integer.class, Short.TYPE)); [EOL]         assertEquals("int -> int", autoboxing, ClassUtils.isAssignable(Integer.class, Integer.TYPE)); [EOL]         assertEquals("int -> long", autoboxing, ClassUtils.isAssignable(Integer.class, Long.TYPE)); [EOL]         assertEquals("int -> float", autoboxing, ClassUtils.isAssignable(Integer.class, Float.TYPE)); [EOL]         assertEquals("int -> double", autoboxing, ClassUtils.isAssignable(Integer.class, Double.TYPE)); [EOL]         assertFalse("int -> boolean", ClassUtils.isAssignable(Integer.class, Boolean.TYPE)); [EOL]  [EOL]         // test long conversions [EOL]         assertFalse("long -> char", ClassUtils.isAssignable(Long.class, Character.TYPE)); [EOL]         assertFalse("long -> byte", ClassUtils.isAssignable(Long.class, Byte.TYPE)); [EOL]         assertFalse("long -> short", ClassUtils.isAssignable(Long.class, Short.TYPE)); [EOL]         assertFalse("long -> int", ClassUtils.isAssignable(Long.class, Integer.TYPE)); [EOL]         assertEquals("long -> long", autoboxing, ClassUtils.isAssignable(Long.class, Long.TYPE)); [EOL]         assertEquals("long -> float", autoboxing, ClassUtils.isAssignable(Long.class, Float.TYPE)); [EOL]         assertEquals("long -> double", autoboxing, ClassUtils.isAssignable(Long.class, Double.TYPE)); [EOL]         assertFalse("long -> boolean", ClassUtils.isAssignable(Long.class, Boolean.TYPE)); [EOL]  [EOL]         // test float conversions [EOL]         assertFalse("float -> char", ClassUtils.isAssignable(Float.class, Character.TYPE)); [EOL]         assertFalse("float -> byte", ClassUtils.isAssignable(Float.class, Byte.TYPE)); [EOL]         assertFalse("float -> short", ClassUtils.isAssignable(Float.class, Short.TYPE)); [EOL]         assertFalse("float -> int", ClassUtils.isAssignable(Float.class, Integer.TYPE)); [EOL]         assertFalse("float -> long", ClassUtils.isAssignable(Float.class, Long.TYPE)); [EOL]         assertEquals("float -> float", autoboxing, ClassUtils.isAssignable(Float.class, Float.TYPE)); [EOL]         assertEquals("float -> double", autoboxing, ClassUtils.isAssignable(Float.class, Double.TYPE)); [EOL]         assertFalse("float -> boolean", ClassUtils.isAssignable(Float.class, Boolean.TYPE)); [EOL]  [EOL]         // test double conversions [EOL]         assertFalse("double -> char", ClassUtils.isAssignable(Double.class, Character.TYPE)); [EOL]         assertFalse("double -> byte", ClassUtils.isAssignable(Double.class, Byte.TYPE)); [EOL]         assertFalse("double -> short", ClassUtils.isAssignable(Double.class, Short.TYPE)); [EOL]         assertFalse("double -> int", ClassUtils.isAssignable(Double.class, Integer.TYPE)); [EOL]         assertFalse("double -> long", ClassUtils.isAssignable(Double.class, Long.TYPE)); [EOL]         assertFalse("double -> float", ClassUtils.isAssignable(Double.class, Float.TYPE)); [EOL]         assertEquals("double -> double", autoboxing, ClassUtils.isAssignable(Double.class, Double.TYPE)); [EOL]         assertFalse("double -> boolean", ClassUtils.isAssignable(Double.class, Boolean.TYPE)); [EOL]  [EOL]         // test boolean conversions [EOL]         assertFalse("boolean -> char", ClassUtils.isAssignable(Boolean.class, Character.TYPE)); [EOL]         assertFalse("boolean -> byte", ClassUtils.isAssignable(Boolean.class, Byte.TYPE)); [EOL]         assertFalse("boolean -> short", ClassUtils.isAssignable(Boolean.class, Short.TYPE)); [EOL]         assertFalse("boolean -> int", ClassUtils.isAssignable(Boolean.class, Integer.TYPE)); [EOL]         assertFalse("boolean -> long", ClassUtils.isAssignable(Boolean.class, Long.TYPE)); [EOL]         assertFalse("boolean -> float", ClassUtils.isAssignable(Boolean.class, Float.TYPE)); [EOL]         assertFalse("boolean -> double", ClassUtils.isAssignable(Boolean.class, Double.TYPE)); [EOL]         assertEquals("boolean -> boolean", autoboxing, ClassUtils.isAssignable(Boolean.class, Boolean.TYPE)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void test_isAssignable_DefaultUnboxing_Widening() throws Exception { [EOL]         final boolean autoboxing = SystemUtils.isJavaVersionAtLeast(JAVA_1_5); [EOL]  [EOL]         // test byte conversions [EOL]         assertFalse("byte -> char", ClassUtils.isAssignable(Byte.class, Character.TYPE)); [EOL]         assertEquals("byte -> byte", autoboxing, ClassUtils.isAssignable(Byte.class, Byte.TYPE)); [EOL]         assertEquals("byte -> short", autoboxing, ClassUtils.isAssignable(Byte.class, Short.TYPE)); [EOL]         assertEquals("byte -> int", autoboxing, ClassUtils.isAssignable(Byte.class, Integer.TYPE)); [EOL]         assertEquals("byte -> long", autoboxing, ClassUtils.isAssignable(Byte.class, Long.TYPE)); [EOL]         assertEquals("byte -> float", autoboxing, ClassUtils.isAssignable(Byte.class, Float.TYPE)); [EOL]         assertEquals("byte -> double", autoboxing, ClassUtils.isAssignable(Byte.class, Double.TYPE)); [EOL]         assertFalse("byte -> boolean", ClassUtils.isAssignable(Byte.class, Boolean.TYPE)); [EOL]  [EOL]         // test short conversions [EOL]         assertFalse("short -> char", ClassUtils.isAssignable(Short.class, Character.TYPE)); [EOL]         assertFalse("short -> byte", ClassUtils.isAssignable(Short.class, Byte.TYPE)); [EOL]         assertEquals("short -> short", autoboxing, ClassUtils.isAssignable(Short.class, Short.TYPE)); [EOL]         assertEquals("short -> int", autoboxing, ClassUtils.isAssignable(Short.class, Integer.TYPE)); [EOL]         assertEquals("short -> long", autoboxing, ClassUtils.isAssignable(Short.class, Long.TYPE)); [EOL]         assertEquals("short -> float", autoboxing, ClassUtils.isAssignable(Short.class, Float.TYPE)); [EOL]         assertEquals("short -> double", autoboxing, ClassUtils.isAssignable(Short.class, Double.TYPE)); [EOL]         assertFalse("short -> boolean", ClassUtils.isAssignable(Short.class, Boolean.TYPE)); [EOL]  [EOL]         // test char conversions [EOL]         assertEquals("char -> char", autoboxing, ClassUtils.isAssignable(Character.class, Character.TYPE)); [EOL]         assertFalse("char -> byte", ClassUtils.isAssignable(Character.class, Byte.TYPE)); [EOL]         assertFalse("char -> short", ClassUtils.isAssignable(Character.class, Short.TYPE)); [EOL]         assertEquals("char -> int", autoboxing, ClassUtils.isAssignable(Character.class, Integer.TYPE)); [EOL]         assertEquals("char -> long", autoboxing, ClassUtils.isAssignable(Character.class, Long.TYPE)); [EOL]         assertEquals("char -> float", autoboxing, ClassUtils.isAssignable(Character.class, Float.TYPE)); [EOL]         assertEquals("char -> double", autoboxing, ClassUtils.isAssignable(Character.class, Double.TYPE)); [EOL]         assertFalse("char -> boolean", ClassUtils.isAssignable(Character.class, Boolean.TYPE)); [EOL]  [EOL]         // test int conversions [EOL]         assertFalse("int -> char", ClassUtils.isAssignable(Integer.class, Character.TYPE)); [EOL]         assertFalse("int -> byte", ClassUtils.isAssignable(Integer.class, Byte.TYPE)); [EOL]         assertFalse("int -> short", ClassUtils.isAssignable(Integer.class, Short.TYPE)); [EOL]         assertEquals("int -> int", autoboxing, ClassUtils.isAssignable(Integer.class, Integer.TYPE)); [EOL]         assertEquals("int -> long", autoboxing, ClassUtils.isAssignable(Integer.class, Long.TYPE)); [EOL]         assertEquals("int -> float", autoboxing, ClassUtils.isAssignable(Integer.class, Float.TYPE)); [EOL]         assertEquals("int -> double", autoboxing, ClassUtils.isAssignable(Integer.class, Double.TYPE)); [EOL]         assertFalse("int -> boolean", ClassUtils.isAssignable(Integer.class, Boolean.TYPE)); [EOL]  [EOL]         // test long conversions [EOL]         assertFalse("long -> char", ClassUtils.isAssignable(Long.class, Character.TYPE)); [EOL]         assertFalse("long -> byte", ClassUtils.isAssignable(Long.class, Byte.TYPE)); [EOL]         assertFalse("long -> short", ClassUtils.isAssignable(Long.class, Short.TYPE)); [EOL]         assertFalse("long -> int", ClassUtils.isAssignable(Long.class, Integer.TYPE)); [EOL]         assertEquals("long -> long", autoboxing, ClassUtils.isAssignable(Long.class, Long.TYPE)); [EOL]         assertEquals("long -> float", autoboxing, ClassUtils.isAssignable(Long.class, Float.TYPE)); [EOL]         assertEquals("long -> double", autoboxing, ClassUtils.isAssignable(Long.class, Double.TYPE)); [EOL]         assertFalse("long -> boolean", ClassUtils.isAssignable(Long.class, Boolean.TYPE)); [EOL]  [EOL]         // test float conversions [EOL]         assertFalse("float -> char", ClassUtils.isAssignable(Float.class, Character.TYPE)); [EOL]         assertFalse("float -> byte", ClassUtils.isAssignable(Float.class, Byte.TYPE)); [EOL]         assertFalse("float -> short", ClassUtils.isAssignable(Float.class, Short.TYPE)); [EOL]         assertFalse("float -> int", ClassUtils.isAssignable(Float.class, Integer.TYPE)); [EOL]         assertFalse("float -> long", ClassUtils.isAssignable(Float.class, Long.TYPE)); [EOL]         assertEquals("float -> float", autoboxing, ClassUtils.isAssignable(Float.class, Float.TYPE)); [EOL]         assertEquals("float -> double", autoboxing, ClassUtils.isAssignable(Float.class, Double.TYPE)); [EOL]         assertFalse("float -> boolean", ClassUtils.isAssignable(Float.class, Boolean.TYPE)); [EOL]  [EOL]         // test double conversions [EOL]         assertFalse("double -> char", ClassUtils.isAssignable(Double.class, Character.TYPE)); [EOL]         assertFalse("double -> byte", ClassUtils.isAssignable(Double.class, Byte.TYPE)); [EOL]         assertFalse("double -> short", ClassUtils.isAssignable(Double.class, Short.TYPE)); [EOL]         assertFalse("double -> int", ClassUtils.isAssignable(Double.class, Integer.TYPE)); [EOL]         assertFalse("double -> long", ClassUtils.isAssignable(Double.class, Long.TYPE)); [EOL]         assertFalse("double -> float", ClassUtils.isAssignable(Double.class, Float.TYPE)); [EOL]         assertEquals("double -> double", autoboxing, ClassUtils.isAssignable(Double.class, Double.TYPE)); [EOL]         assertFalse("double -> boolean", ClassUtils.isAssignable(Double.class, Boolean.TYPE)); [EOL]  [EOL]         // test boolean conversions [EOL]         assertFalse("boolean -> char", ClassUtils.isAssignable(Boolean.class, Character.TYPE)); [EOL]         assertFalse("boolean -> byte", ClassUtils.isAssignable(Boolean.class, Byte.TYPE)); [EOL]         assertFalse("boolean -> short", ClassUtils.isAssignable(Boolean.class, Short.TYPE)); [EOL]         assertFalse("boolean -> int", ClassUtils.isAssignable(Boolean.class, Integer.TYPE)); [EOL]         assertFalse("boolean -> long", ClassUtils.isAssignable(Boolean.class, Long.TYPE)); [EOL]         assertFalse("boolean -> float", ClassUtils.isAssignable(Boolean.class, Float.TYPE)); [EOL]         assertFalse("boolean -> double", ClassUtils.isAssignable(Boolean.class, Double.TYPE)); [EOL]         assertEquals("boolean -> boolean", autoboxing, ClassUtils.isAssignable(Boolean.class, Boolean.TYPE)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void test_isAssignable_DefaultUnboxing_Widening() throws Exception { [EOL]         final boolean autoboxing = SystemUtils.isJavaVersionAtLeast(JAVA_1_5); [EOL]  [EOL]         // test byte conversions [EOL]         assertFalse("byte -> char", ClassUtils.isAssignable(Byte.class, Character.TYPE)); [EOL]         assertEquals("byte -> byte", autoboxing, ClassUtils.isAssignable(Byte.class, Byte.TYPE)); [EOL]         assertEquals("byte -> short", autoboxing, ClassUtils.isAssignable(Byte.class, Short.TYPE)); [EOL]         assertEquals("byte -> int", autoboxing, ClassUtils.isAssignable(Byte.class, Integer.TYPE)); [EOL]         assertEquals("byte -> long", autoboxing, ClassUtils.isAssignable(Byte.class, Long.TYPE)); [EOL]         assertEquals("byte -> float", autoboxing, ClassUtils.isAssignable(Byte.class, Float.TYPE)); [EOL]         assertEquals("byte -> double", autoboxing, ClassUtils.isAssignable(Byte.class, Double.TYPE)); [EOL]         assertFalse("byte -> boolean", ClassUtils.isAssignable(Byte.class, Boolean.TYPE)); [EOL]  [EOL]         // test short conversions [EOL]         assertFalse("short -> char", ClassUtils.isAssignable(Short.class, Character.TYPE)); [EOL]         assertFalse("short -> byte", ClassUtils.isAssignable(Short.class, Byte.TYPE)); [EOL]         assertEquals("short -> short", autoboxing, ClassUtils.isAssignable(Short.class, Short.TYPE)); [EOL]         assertEquals("short -> int", autoboxing, ClassUtils.isAssignable(Short.class, Integer.TYPE)); [EOL]         assertEquals("short -> long", autoboxing, ClassUtils.isAssignable(Short.class, Long.TYPE)); [EOL]         assertEquals("short -> float", autoboxing, ClassUtils.isAssignable(Short.class, Float.TYPE)); [EOL]         assertEquals("short -> double", autoboxing, ClassUtils.isAssignable(Short.class, Double.TYPE)); [EOL]         assertFalse("short -> boolean", ClassUtils.isAssignable(Short.class, Boolean.TYPE)); [EOL]  [EOL]         // test char conversions [EOL]         assertEquals("char -> char", autoboxing, ClassUtils.isAssignable(Character.class, Character.TYPE)); [EOL]         assertFalse("char -> byte", ClassUtils.isAssignable(Character.class, Byte.TYPE)); [EOL]         assertFalse("char -> short", ClassUtils.isAssignable(Character.class, Short.TYPE)); [EOL]         assertEquals("char -> int", autoboxing, ClassUtils.isAssignable(Character.class, Integer.TYPE)); [EOL]         assertEquals("char -> long", autoboxing, ClassUtils.isAssignable(Character.class, Long.TYPE)); [EOL]         assertEquals("char -> float", autoboxing, ClassUtils.isAssignable(Character.class, Float.TYPE)); [EOL]         assertEquals("char -> double", autoboxing, ClassUtils.isAssignable(Character.class, Double.TYPE)); [EOL]         assertFalse("char -> boolean", ClassUtils.isAssignable(Character.class, Boolean.TYPE)); [EOL]  [EOL]         // test int conversions [EOL]         assertFalse("int -> char", ClassUtils.isAssignable(Integer.class, Character.TYPE)); [EOL]         assertFalse("int -> byte", ClassUtils.isAssignable(Integer.class, Byte.TYPE)); [EOL]         assertFalse("int -> short", ClassUtils.isAssignable(Integer.class, Short.TYPE)); [EOL]         assertEquals("int -> int", autoboxing, ClassUtils.isAssignable(Integer.class, Integer.TYPE)); [EOL]         assertEquals("int -> long", autoboxing, ClassUtils.isAssignable(Integer.class, Long.TYPE)); [EOL]         assertEquals("int -> float", autoboxing, ClassUtils.isAssignable(Integer.class, Float.TYPE)); [EOL]         assertEquals("int -> double", autoboxing, ClassUtils.isAssignable(Integer.class, Double.TYPE)); [EOL]         assertFalse("int -> boolean", ClassUtils.isAssignable(Integer.class, Boolean.TYPE)); [EOL]  [EOL]         // test long conversions [EOL]         assertFalse("long -> char", ClassUtils.isAssignable(Long.class, Character.TYPE)); [EOL]         assertFalse("long -> byte", ClassUtils.isAssignable(Long.class, Byte.TYPE)); [EOL]         assertFalse("long -> short", ClassUtils.isAssignable(Long.class, Short.TYPE)); [EOL]         assertFalse("long -> int", ClassUtils.isAssignable(Long.class, Integer.TYPE)); [EOL]         assertEquals("long -> long", autoboxing, ClassUtils.isAssignable(Long.class, Long.TYPE)); [EOL]         assertEquals("long -> float", autoboxing, ClassUtils.isAssignable(Long.class, Float.TYPE)); [EOL]         assertEquals("long -> double", autoboxing, ClassUtils.isAssignable(Long.class, Double.TYPE)); [EOL]         assertFalse("long -> boolean", ClassUtils.isAssignable(Long.class, Boolean.TYPE)); [EOL]  [EOL]         // test float conversions [EOL]         assertFalse("float -> char", ClassUtils.isAssignable(Float.class, Character.TYPE)); [EOL]         assertFalse("float -> byte", ClassUtils.isAssignable(Float.class, Byte.TYPE)); [EOL]         assertFalse("float -> short", ClassUtils.isAssignable(Float.class, Short.TYPE)); [EOL]         assertFalse("float -> int", ClassUtils.isAssignable(Float.class, Integer.TYPE)); [EOL]         assertFalse("float -> long", ClassUtils.isAssignable(Float.class, Long.TYPE)); [EOL]         assertEquals("float -> float", autoboxing, ClassUtils.isAssignable(Float.class, Float.TYPE)); [EOL]         assertEquals("float -> double", autoboxing, ClassUtils.isAssignable(Float.class, Double.TYPE)); [EOL]         assertFalse("float -> boolean", ClassUtils.isAssignable(Float.class, Boolean.TYPE)); [EOL]  [EOL]         // test double conversions [EOL]         assertFalse("double -> char", ClassUtils.isAssignable(Double.class, Character.TYPE)); [EOL]         assertFalse("double -> byte", ClassUtils.isAssignable(Double.class, Byte.TYPE)); [EOL]         assertFalse("double -> short", ClassUtils.isAssignable(Double.class, Short.TYPE)); [EOL]         assertFalse("double -> int", ClassUtils.isAssignable(Double.class, Integer.TYPE)); [EOL]         assertFalse("double -> long", ClassUtils.isAssignable(Double.class, Long.TYPE)); [EOL]         assertFalse("double -> float", ClassUtils.isAssignable(Double.class, Float.TYPE)); [EOL]         assertEquals("double -> double", autoboxing, ClassUtils.isAssignable(Double.class, Double.TYPE)); [EOL]         assertFalse("double -> boolean", ClassUtils.isAssignable(Double.class, Boolean.TYPE)); [EOL]  [EOL]         // test boolean conversions [EOL]         assertFalse("boolean -> char", ClassUtils.isAssignable(Boolean.class, Character.TYPE)); [EOL]         assertFalse("boolean -> byte", ClassUtils.isAssignable(Boolean.class, Byte.TYPE)); [EOL]         assertFalse("boolean -> short", ClassUtils.isAssignable(Boolean.class, Short.TYPE)); [EOL]         assertFalse("boolean -> int", ClassUtils.isAssignable(Boolean.class, Integer.TYPE)); [EOL]         assertFalse("boolean -> long", ClassUtils.isAssignable(Boolean.class, Long.TYPE)); [EOL]         assertFalse("boolean -> float", ClassUtils.isAssignable(Boolean.class, Float.TYPE)); [EOL]         assertFalse("boolean -> double", ClassUtils.isAssignable(Boolean.class, Double.TYPE)); [EOL]         assertEquals("boolean -> boolean", autoboxing, ClassUtils.isAssignable(Boolean.class, Boolean.TYPE)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void test_isAssignable_DefaultUnboxing_Widening() throws Exception { [EOL]         final boolean autoboxing = SystemUtils.isJavaVersionAtLeast(JAVA_1_5); [EOL]  [EOL]         // test byte conversions [EOL]         assertFalse("byte -> char", ClassUtils.isAssignable(Byte.class, Character.TYPE)); [EOL]         assertEquals("byte -> byte", autoboxing, ClassUtils.isAssignable(Byte.class, Byte.TYPE)); [EOL]         assertEquals("byte -> short", autoboxing, ClassUtils.isAssignable(Byte.class, Short.TYPE)); [EOL]         assertEquals("byte -> int", autoboxing, ClassUtils.isAssignable(Byte.class, Integer.TYPE)); [EOL]         assertEquals("byte -> long", autoboxing, ClassUtils.isAssignable(Byte.class, Long.TYPE)); [EOL]         assertEquals("byte -> float", autoboxing, ClassUtils.isAssignable(Byte.class, Float.TYPE)); [EOL]         assertEquals("byte -> double", autoboxing, ClassUtils.isAssignable(Byte.class, Double.TYPE)); [EOL]         assertFalse("byte -> boolean", ClassUtils.isAssignable(Byte.class, Boolean.TYPE)); [EOL]  [EOL]         // test short conversions [EOL]         assertFalse("short -> char", ClassUtils.isAssignable(Short.class, Character.TYPE)); [EOL]         assertFalse("short -> byte", ClassUtils.isAssignable(Short.class, Byte.TYPE)); [EOL]         assertEquals("short -> short", autoboxing, ClassUtils.isAssignable(Short.class, Short.TYPE)); [EOL]         assertEquals("short -> int", autoboxing, ClassUtils.isAssignable(Short.class, Integer.TYPE)); [EOL]         assertEquals("short -> long", autoboxing, ClassUtils.isAssignable(Short.class, Long.TYPE)); [EOL]         assertEquals("short -> float", autoboxing, ClassUtils.isAssignable(Short.class, Float.TYPE)); [EOL]         assertEquals("short -> double", autoboxing, ClassUtils.isAssignable(Short.class, Double.TYPE)); [EOL]         assertFalse("short -> boolean", ClassUtils.isAssignable(Short.class, Boolean.TYPE)); [EOL]  [EOL]         // test char conversions [EOL]         assertEquals("char -> char", autoboxing, ClassUtils.isAssignable(Character.class, Character.TYPE)); [EOL]         assertFalse("char -> byte", ClassUtils.isAssignable(Character.class, Byte.TYPE)); [EOL]         assertFalse("char -> short", ClassUtils.isAssignable(Character.class, Short.TYPE)); [EOL]         assertEquals("char -> int", autoboxing, ClassUtils.isAssignable(Character.class, Integer.TYPE)); [EOL]         assertEquals("char -> long", autoboxing, ClassUtils.isAssignable(Character.class, Long.TYPE)); [EOL]         assertEquals("char -> float", autoboxing, ClassUtils.isAssignable(Character.class, Float.TYPE)); [EOL]         assertEquals("char -> double", autoboxing, ClassUtils.isAssignable(Character.class, Double.TYPE)); [EOL]         assertFalse("char -> boolean", ClassUtils.isAssignable(Character.class, Boolean.TYPE)); [EOL]  [EOL]         // test int conversions [EOL]         assertFalse("int -> char", ClassUtils.isAssignable(Integer.class, Character.TYPE)); [EOL]         assertFalse("int -> byte", ClassUtils.isAssignable(Integer.class, Byte.TYPE)); [EOL]         assertFalse("int -> short", ClassUtils.isAssignable(Integer.class, Short.TYPE)); [EOL]         assertEquals("int -> int", autoboxing, ClassUtils.isAssignable(Integer.class, Integer.TYPE)); [EOL]         assertEquals("int -> long", autoboxing, ClassUtils.isAssignable(Integer.class, Long.TYPE)); [EOL]         assertEquals("int -> float", autoboxing, ClassUtils.isAssignable(Integer.class, Float.TYPE)); [EOL]         assertEquals("int -> double", autoboxing, ClassUtils.isAssignable(Integer.class, Double.TYPE)); [EOL]         assertFalse("int -> boolean", ClassUtils.isAssignable(Integer.class, Boolean.TYPE)); [EOL]  [EOL]         // test long conversions [EOL]         assertFalse("long -> char", ClassUtils.isAssignable(Long.class, Character.TYPE)); [EOL]         assertFalse("long -> byte", ClassUtils.isAssignable(Long.class, Byte.TYPE)); [EOL]         assertFalse("long -> short", ClassUtils.isAssignable(Long.class, Short.TYPE)); [EOL]         assertFalse("long -> int", ClassUtils.isAssignable(Long.class, Integer.TYPE)); [EOL]         assertEquals("long -> long", autoboxing, ClassUtils.isAssignable(Long.class, Long.TYPE)); [EOL]         assertEquals("long -> float", autoboxing, ClassUtils.isAssignable(Long.class, Float.TYPE)); [EOL]         assertEquals("long -> double", autoboxing, ClassUtils.isAssignable(Long.class, Double.TYPE)); [EOL]         assertFalse("long -> boolean", ClassUtils.isAssignable(Long.class, Boolean.TYPE)); [EOL]  [EOL]         // test float conversions [EOL]         assertFalse("float -> char", ClassUtils.isAssignable(Float.class, Character.TYPE)); [EOL]         assertFalse("float -> byte", ClassUtils.isAssignable(Float.class, Byte.TYPE)); [EOL]         assertFalse("float -> short", ClassUtils.isAssignable(Float.class, Short.TYPE)); [EOL]         assertFalse("float -> int", ClassUtils.isAssignable(Float.class, Integer.TYPE)); [EOL]         assertFalse("float -> long", ClassUtils.isAssignable(Float.class, Long.TYPE)); [EOL]         assertEquals("float -> float", autoboxing, ClassUtils.isAssignable(Float.class, Float.TYPE)); [EOL]         assertEquals("float -> double", autoboxing, ClassUtils.isAssignable(Float.class, Double.TYPE)); [EOL]         assertFalse("float -> boolean", ClassUtils.isAssignable(Float.class, Boolean.TYPE)); [EOL]  [EOL]         // test double conversions [EOL]         assertFalse("double -> char", ClassUtils.isAssignable(Double.class, Character.TYPE)); [EOL]         assertFalse("double -> byte", ClassUtils.isAssignable(Double.class, Byte.TYPE)); [EOL]         assertFalse("double -> short", ClassUtils.isAssignable(Double.class, Short.TYPE)); [EOL]         assertFalse("double -> int", ClassUtils.isAssignable(Double.class, Integer.TYPE)); [EOL]         assertFalse("double -> long", ClassUtils.isAssignable(Double.class, Long.TYPE)); [EOL]         assertFalse("double -> float", ClassUtils.isAssignable(Double.class, Float.TYPE)); [EOL]         assertEquals("double -> double", autoboxing, ClassUtils.isAssignable(Double.class, Double.TYPE)); [EOL]         assertFalse("double -> boolean", ClassUtils.isAssignable(Double.class, Boolean.TYPE)); [EOL]  [EOL]         // test boolean conversions [EOL]         assertFalse("boolean -> char", ClassUtils.isAssignable(Boolean.class, Character.TYPE)); [EOL]         assertFalse("boolean -> byte", ClassUtils.isAssignable(Boolean.class, Byte.TYPE)); [EOL]         assertFalse("boolean -> short", ClassUtils.isAssignable(Boolean.class, Short.TYPE)); [EOL]         assertFalse("boolean -> int", ClassUtils.isAssignable(Boolean.class, Integer.TYPE)); [EOL]         assertFalse("boolean -> long", ClassUtils.isAssignable(Boolean.class, Long.TYPE)); [EOL]         assertFalse("boolean -> float", ClassUtils.isAssignable(Boolean.class, Float.TYPE)); [EOL]         assertFalse("boolean -> double", ClassUtils.isAssignable(Boolean.class, Double.TYPE)); [EOL]         assertEquals("boolean -> boolean", autoboxing, ClassUtils.isAssignable(Boolean.class, Boolean.TYPE)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void test_isAssignable_DefaultUnboxing_Widening() throws Exception { [EOL]         final boolean autoboxing = SystemUtils.isJavaVersionAtLeast(JAVA_1_5); [EOL]  [EOL]         // test byte conversions [EOL]         assertFalse("byte -> char", ClassUtils.isAssignable(Byte.class, Character.TYPE)); [EOL]         assertEquals("byte -> byte", autoboxing, ClassUtils.isAssignable(Byte.class, Byte.TYPE)); [EOL]         assertEquals("byte -> short", autoboxing, ClassUtils.isAssignable(Byte.class, Short.TYPE)); [EOL]         assertEquals("byte -> int", autoboxing, ClassUtils.isAssignable(Byte.class, Integer.TYPE)); [EOL]         assertEquals("byte -> long", autoboxing, ClassUtils.isAssignable(Byte.class, Long.TYPE)); [EOL]         assertEquals("byte -> float", autoboxing, ClassUtils.isAssignable(Byte.class, Float.TYPE)); [EOL]         assertEquals("byte -> double", autoboxing, ClassUtils.isAssignable(Byte.class, Double.TYPE)); [EOL]         assertFalse("byte -> boolean", ClassUtils.isAssignable(Byte.class, Boolean.TYPE)); [EOL]  [EOL]         // test short conversions [EOL]         assertFalse("short -> char", ClassUtils.isAssignable(Short.class, Character.TYPE)); [EOL]         assertFalse("short -> byte", ClassUtils.isAssignable(Short.class, Byte.TYPE)); [EOL]         assertEquals("short -> short", autoboxing, ClassUtils.isAssignable(Short.class, Short.TYPE)); [EOL]         assertEquals("short -> int", autoboxing, ClassUtils.isAssignable(Short.class, Integer.TYPE)); [EOL]         assertEquals("short -> long", autoboxing, ClassUtils.isAssignable(Short.class, Long.TYPE)); [EOL]         assertEquals("short -> float", autoboxing, ClassUtils.isAssignable(Short.class, Float.TYPE)); [EOL]         assertEquals("short -> double", autoboxing, ClassUtils.isAssignable(Short.class, Double.TYPE)); [EOL]         assertFalse("short -> boolean", ClassUtils.isAssignable(Short.class, Boolean.TYPE)); [EOL]  [EOL]         // test char conversions [EOL]         assertEquals("char -> char", autoboxing, ClassUtils.isAssignable(Character.class, Character.TYPE)); [EOL]         assertFalse("char -> byte", ClassUtils.isAssignable(Character.class, Byte.TYPE)); [EOL]         assertFalse("char -> short", ClassUtils.isAssignable(Character.class, Short.TYPE)); [EOL]         assertEquals("char -> int", autoboxing, ClassUtils.isAssignable(Character.class, Integer.TYPE)); [EOL]         assertEquals("char -> long", autoboxing, ClassUtils.isAssignable(Character.class, Long.TYPE)); [EOL]         assertEquals("char -> float", autoboxing, ClassUtils.isAssignable(Character.class, Float.TYPE)); [EOL]         assertEquals("char -> double", autoboxing, ClassUtils.isAssignable(Character.class, Double.TYPE)); [EOL]         assertFalse("char -> boolean", ClassUtils.isAssignable(Character.class, Boolean.TYPE)); [EOL]  [EOL]         // test int conversions [EOL]         assertFalse("int -> char", ClassUtils.isAssignable(Integer.class, Character.TYPE)); [EOL]         assertFalse("int -> byte", ClassUtils.isAssignable(Integer.class, Byte.TYPE)); [EOL]         assertFalse("int -> short", ClassUtils.isAssignable(Integer.class, Short.TYPE)); [EOL]         assertEquals("int -> int", autoboxing, ClassUtils.isAssignable(Integer.class, Integer.TYPE)); [EOL]         assertEquals("int -> long", autoboxing, ClassUtils.isAssignable(Integer.class, Long.TYPE)); [EOL]         assertEquals("int -> float", autoboxing, ClassUtils.isAssignable(Integer.class, Float.TYPE)); [EOL]         assertEquals("int -> double", autoboxing, ClassUtils.isAssignable(Integer.class, Double.TYPE)); [EOL]         assertFalse("int -> boolean", ClassUtils.isAssignable(Integer.class, Boolean.TYPE)); [EOL]  [EOL]         // test long conversions [EOL]         assertFalse("long -> char", ClassUtils.isAssignable(Long.class, Character.TYPE)); [EOL]         assertFalse("long -> byte", ClassUtils.isAssignable(Long.class, Byte.TYPE)); [EOL]         assertFalse("long -> short", ClassUtils.isAssignable(Long.class, Short.TYPE)); [EOL]         assertFalse("long -> int", ClassUtils.isAssignable(Long.class, Integer.TYPE)); [EOL]         assertEquals("long -> long", autoboxing, ClassUtils.isAssignable(Long.class, Long.TYPE)); [EOL]         assertEquals("long -> float", autoboxing, ClassUtils.isAssignable(Long.class, Float.TYPE)); [EOL]         assertEquals("long -> double", autoboxing, ClassUtils.isAssignable(Long.class, Double.TYPE)); [EOL]         assertFalse("long -> boolean", ClassUtils.isAssignable(Long.class, Boolean.TYPE)); [EOL]  [EOL]         // test float conversions [EOL]         assertFalse("float -> char", ClassUtils.isAssignable(Float.class, Character.TYPE)); [EOL]         assertFalse("float -> byte", ClassUtils.isAssignable(Float.class, Byte.TYPE)); [EOL]         assertFalse("float -> short", ClassUtils.isAssignable(Float.class, Short.TYPE)); [EOL]         assertFalse("float -> int", ClassUtils.isAssignable(Float.class, Integer.TYPE)); [EOL]         assertFalse("float -> long", ClassUtils.isAssignable(Float.class, Long.TYPE)); [EOL]         assertEquals("float -> float", autoboxing, ClassUtils.isAssignable(Float.class, Float.TYPE)); [EOL]         assertEquals("float -> double", autoboxing, ClassUtils.isAssignable(Float.class, Double.TYPE)); [EOL]         assertFalse("float -> boolean", ClassUtils.isAssignable(Float.class, Boolean.TYPE)); [EOL]  [EOL]         // test double conversions [EOL]         assertFalse("double -> char", ClassUtils.isAssignable(Double.class, Character.TYPE)); [EOL]         assertFalse("double -> byte", ClassUtils.isAssignable(Double.class, Byte.TYPE)); [EOL]         assertFalse("double -> short", ClassUtils.isAssignable(Double.class, Short.TYPE)); [EOL]         assertFalse("double -> int", ClassUtils.isAssignable(Double.class, Integer.TYPE)); [EOL]         assertFalse("double -> long", ClassUtils.isAssignable(Double.class, Long.TYPE)); [EOL]         assertFalse("double -> float", ClassUtils.isAssignable(Double.class, Float.TYPE)); [EOL]         assertEquals("double -> double", autoboxing, ClassUtils.isAssignable(Double.class, Double.TYPE)); [EOL]         assertFalse("double -> boolean", ClassUtils.isAssignable(Double.class, Boolean.TYPE)); [EOL]  [EOL]         // test boolean conversions [EOL]         assertFalse("boolean -> char", ClassUtils.isAssignable(Boolean.class, Character.TYPE)); [EOL]         assertFalse("boolean -> byte", ClassUtils.isAssignable(Boolean.class, Byte.TYPE)); [EOL]         assertFalse("boolean -> short", ClassUtils.isAssignable(Boolean.class, Short.TYPE)); [EOL]         assertFalse("boolean -> int", ClassUtils.isAssignable(Boolean.class, Integer.TYPE)); [EOL]         assertFalse("boolean -> long", ClassUtils.isAssignable(Boolean.class, Long.TYPE)); [EOL]         assertFalse("boolean -> float", ClassUtils.isAssignable(Boolean.class, Float.TYPE)); [EOL]         assertFalse("boolean -> double", ClassUtils.isAssignable(Boolean.class, Double.TYPE)); [EOL]         assertEquals("boolean -> boolean", autoboxing, ClassUtils.isAssignable(Boolean.class, Boolean.TYPE)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void test_isAssignable_DefaultUnboxing_Widening() throws Exception { [EOL]         final boolean autoboxing = SystemUtils.isJavaVersionAtLeast(JAVA_1_5); [EOL]  [EOL]         // test byte conversions [EOL]         assertFalse("byte -> char", ClassUtils.isAssignable(Byte.class, Character.TYPE)); [EOL]         assertEquals("byte -> byte", autoboxing, ClassUtils.isAssignable(Byte.class, Byte.TYPE)); [EOL]         assertEquals("byte -> short", autoboxing, ClassUtils.isAssignable(Byte.class, Short.TYPE)); [EOL]         assertEquals("byte -> int", autoboxing, ClassUtils.isAssignable(Byte.class, Integer.TYPE)); [EOL]         assertEquals("byte -> long", autoboxing, ClassUtils.isAssignable(Byte.class, Long.TYPE)); [EOL]         assertEquals("byte -> float", autoboxing, ClassUtils.isAssignable(Byte.class, Float.TYPE)); [EOL]         assertEquals("byte -> double", autoboxing, ClassUtils.isAssignable(Byte.class, Double.TYPE)); [EOL]         assertFalse("byte -> boolean", ClassUtils.isAssignable(Byte.class, Boolean.TYPE)); [EOL]  [EOL]         // test short conversions [EOL]         assertFalse("short -> char", ClassUtils.isAssignable(Short.class, Character.TYPE)); [EOL]         assertFalse("short -> byte", ClassUtils.isAssignable(Short.class, Byte.TYPE)); [EOL]         assertEquals("short -> short", autoboxing, ClassUtils.isAssignable(Short.class, Short.TYPE)); [EOL]         assertEquals("short -> int", autoboxing, ClassUtils.isAssignable(Short.class, Integer.TYPE)); [EOL]         assertEquals("short -> long", autoboxing, ClassUtils.isAssignable(Short.class, Long.TYPE)); [EOL]         assertEquals("short -> float", autoboxing, ClassUtils.isAssignable(Short.class, Float.TYPE)); [EOL]         assertEquals("short -> double", autoboxing, ClassUtils.isAssignable(Short.class, Double.TYPE)); [EOL]         assertFalse("short -> boolean", ClassUtils.isAssignable(Short.class, Boolean.TYPE)); [EOL]  [EOL]         // test char conversions [EOL]         assertEquals("char -> char", autoboxing, ClassUtils.isAssignable(Character.class, Character.TYPE)); [EOL]         assertFalse("char -> byte", ClassUtils.isAssignable(Character.class, Byte.TYPE)); [EOL]         assertFalse("char -> short", ClassUtils.isAssignable(Character.class, Short.TYPE)); [EOL]         assertEquals("char -> int", autoboxing, ClassUtils.isAssignable(Character.class, Integer.TYPE)); [EOL]         assertEquals("char -> long", autoboxing, ClassUtils.isAssignable(Character.class, Long.TYPE)); [EOL]         assertEquals("char -> float", autoboxing, ClassUtils.isAssignable(Character.class, Float.TYPE)); [EOL]         assertEquals("char -> double", autoboxing, ClassUtils.isAssignable(Character.class, Double.TYPE)); [EOL]         assertFalse("char -> boolean", ClassUtils.isAssignable(Character.class, Boolean.TYPE)); [EOL]  [EOL]         // test int conversions [EOL]         assertFalse("int -> char", ClassUtils.isAssignable(Integer.class, Character.TYPE)); [EOL]         assertFalse("int -> byte", ClassUtils.isAssignable(Integer.class, Byte.TYPE)); [EOL]         assertFalse("int -> short", ClassUtils.isAssignable(Integer.class, Short.TYPE)); [EOL]         assertEquals("int -> int", autoboxing, ClassUtils.isAssignable(Integer.class, Integer.TYPE)); [EOL]         assertEquals("int -> long", autoboxing, ClassUtils.isAssignable(Integer.class, Long.TYPE)); [EOL]         assertEquals("int -> float", autoboxing, ClassUtils.isAssignable(Integer.class, Float.TYPE)); [EOL]         assertEquals("int -> double", autoboxing, ClassUtils.isAssignable(Integer.class, Double.TYPE)); [EOL]         assertFalse("int -> boolean", ClassUtils.isAssignable(Integer.class, Boolean.TYPE)); [EOL]  [EOL]         // test long conversions [EOL]         assertFalse("long -> char", ClassUtils.isAssignable(Long.class, Character.TYPE)); [EOL]         assertFalse("long -> byte", ClassUtils.isAssignable(Long.class, Byte.TYPE)); [EOL]         assertFalse("long -> short", ClassUtils.isAssignable(Long.class, Short.TYPE)); [EOL]         assertFalse("long -> int", ClassUtils.isAssignable(Long.class, Integer.TYPE)); [EOL]         assertEquals("long -> long", autoboxing, ClassUtils.isAssignable(Long.class, Long.TYPE)); [EOL]         assertEquals("long -> float", autoboxing, ClassUtils.isAssignable(Long.class, Float.TYPE)); [EOL]         assertEquals("long -> double", autoboxing, ClassUtils.isAssignable(Long.class, Double.TYPE)); [EOL]         assertFalse("long -> boolean", ClassUtils.isAssignable(Long.class, Boolean.TYPE)); [EOL]  [EOL]         // test float conversions [EOL]         assertFalse("float -> char", ClassUtils.isAssignable(Float.class, Character.TYPE)); [EOL]         assertFalse("float -> byte", ClassUtils.isAssignable(Float.class, Byte.TYPE)); [EOL]         assertFalse("float -> short", ClassUtils.isAssignable(Float.class, Short.TYPE)); [EOL]         assertFalse("float -> int", ClassUtils.isAssignable(Float.class, Integer.TYPE)); [EOL]         assertFalse("float -> long", ClassUtils.isAssignable(Float.class, Long.TYPE)); [EOL]         assertEquals("float -> float", autoboxing, ClassUtils.isAssignable(Float.class, Float.TYPE)); [EOL]         assertEquals("float -> double", autoboxing, ClassUtils.isAssignable(Float.class, Double.TYPE)); [EOL]         assertFalse("float -> boolean", ClassUtils.isAssignable(Float.class, Boolean.TYPE)); [EOL]  [EOL]         // test double conversions [EOL]         assertFalse("double -> char", ClassUtils.isAssignable(Double.class, Character.TYPE)); [EOL]         assertFalse("double -> byte", ClassUtils.isAssignable(Double.class, Byte.TYPE)); [EOL]         assertFalse("double -> short", ClassUtils.isAssignable(Double.class, Short.TYPE)); [EOL]         assertFalse("double -> int", ClassUtils.isAssignable(Double.class, Integer.TYPE)); [EOL]         assertFalse("double -> long", ClassUtils.isAssignable(Double.class, Long.TYPE)); [EOL]         assertFalse("double -> float", ClassUtils.isAssignable(Double.class, Float.TYPE)); [EOL]         assertEquals("double -> double", autoboxing, ClassUtils.isAssignable(Double.class, Double.TYPE)); [EOL]         assertFalse("double -> boolean", ClassUtils.isAssignable(Double.class, Boolean.TYPE)); [EOL]  [EOL]         // test boolean conversions [EOL]         assertFalse("boolean -> char", ClassUtils.isAssignable(Boolean.class, Character.TYPE)); [EOL]         assertFalse("boolean -> byte", ClassUtils.isAssignable(Boolean.class, Byte.TYPE)); [EOL]         assertFalse("boolean -> short", ClassUtils.isAssignable(Boolean.class, Short.TYPE)); [EOL]         assertFalse("boolean -> int", ClassUtils.isAssignable(Boolean.class, Integer.TYPE)); [EOL]         assertFalse("boolean -> long", ClassUtils.isAssignable(Boolean.class, Long.TYPE)); [EOL]         assertFalse("boolean -> float", ClassUtils.isAssignable(Boolean.class, Float.TYPE)); [EOL]         assertFalse("boolean -> double", ClassUtils.isAssignable(Boolean.class, Double.TYPE)); [EOL]         assertEquals("boolean -> boolean", autoboxing, ClassUtils.isAssignable(Boolean.class, Boolean.TYPE)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void test_isAssignable_DefaultUnboxing_Widening() throws Exception { [EOL]         final boolean autoboxing = SystemUtils.isJavaVersionAtLeast(JAVA_1_5); [EOL]  [EOL]         // test byte conversions [EOL]         assertFalse("byte -> char", ClassUtils.isAssignable(Byte.class, Character.TYPE)); [EOL]         assertEquals("byte -> byte", autoboxing, ClassUtils.isAssignable(Byte.class, Byte.TYPE)); [EOL]         assertEquals("byte -> short", autoboxing, ClassUtils.isAssignable(Byte.class, Short.TYPE)); [EOL]         assertEquals("byte -> int", autoboxing, ClassUtils.isAssignable(Byte.class, Integer.TYPE)); [EOL]         assertEquals("byte -> long", autoboxing, ClassUtils.isAssignable(Byte.class, Long.TYPE)); [EOL]         assertEquals("byte -> float", autoboxing, ClassUtils.isAssignable(Byte.class, Float.TYPE)); [EOL]         assertEquals("byte -> double", autoboxing, ClassUtils.isAssignable(Byte.class, Double.TYPE)); [EOL]         assertFalse("byte -> boolean", ClassUtils.isAssignable(Byte.class, Boolean.TYPE)); [EOL]  [EOL]         // test short conversions [EOL]         assertFalse("short -> char", ClassUtils.isAssignable(Short.class, Character.TYPE)); [EOL]         assertFalse("short -> byte", ClassUtils.isAssignable(Short.class, Byte.TYPE)); [EOL]         assertEquals("short -> short", autoboxing, ClassUtils.isAssignable(Short.class, Short.TYPE)); [EOL]         assertEquals("short -> int", autoboxing, ClassUtils.isAssignable(Short.class, Integer.TYPE)); [EOL]         assertEquals("short -> long", autoboxing, ClassUtils.isAssignable(Short.class, Long.TYPE)); [EOL]         assertEquals("short -> float", autoboxing, ClassUtils.isAssignable(Short.class, Float.TYPE)); [EOL]         assertEquals("short -> double", autoboxing, ClassUtils.isAssignable(Short.class, Double.TYPE)); [EOL]         assertFalse("short -> boolean", ClassUtils.isAssignable(Short.class, Boolean.TYPE)); [EOL]  [EOL]         // test char conversions [EOL]         assertEquals("char -> char", autoboxing, ClassUtils.isAssignable(Character.class, Character.TYPE)); [EOL]         assertFalse("char -> byte", ClassUtils.isAssignable(Character.class, Byte.TYPE)); [EOL]         assertFalse("char -> short", ClassUtils.isAssignable(Character.class, Short.TYPE)); [EOL]         assertEquals("char -> int", autoboxing, ClassUtils.isAssignable(Character.class, Integer.TYPE)); [EOL]         assertEquals("char -> long", autoboxing, ClassUtils.isAssignable(Character.class, Long.TYPE)); [EOL]         assertEquals("char -> float", autoboxing, ClassUtils.isAssignable(Character.class, Float.TYPE)); [EOL]         assertEquals("char -> double", autoboxing, ClassUtils.isAssignable(Character.class, Double.TYPE)); [EOL]         assertFalse("char -> boolean", ClassUtils.isAssignable(Character.class, Boolean.TYPE)); [EOL]  [EOL]         // test int conversions [EOL]         assertFalse("int -> char", ClassUtils.isAssignable(Integer.class, Character.TYPE)); [EOL]         assertFalse("int -> byte", ClassUtils.isAssignable(Integer.class, Byte.TYPE)); [EOL]         assertFalse("int -> short", ClassUtils.isAssignable(Integer.class, Short.TYPE)); [EOL]         assertEquals("int -> int", autoboxing, ClassUtils.isAssignable(Integer.class, Integer.TYPE)); [EOL]         assertEquals("int -> long", autoboxing, ClassUtils.isAssignable(Integer.class, Long.TYPE)); [EOL]         assertEquals("int -> float", autoboxing, ClassUtils.isAssignable(Integer.class, Float.TYPE)); [EOL]         assertEquals("int -> double", autoboxing, ClassUtils.isAssignable(Integer.class, Double.TYPE)); [EOL]         assertFalse("int -> boolean", ClassUtils.isAssignable(Integer.class, Boolean.TYPE)); [EOL]  [EOL]         // test long conversions [EOL]         assertFalse("long -> char", ClassUtils.isAssignable(Long.class, Character.TYPE)); [EOL]         assertFalse("long -> byte", ClassUtils.isAssignable(Long.class, Byte.TYPE)); [EOL]         assertFalse("long -> short", ClassUtils.isAssignable(Long.class, Short.TYPE)); [EOL]         assertFalse("long -> int", ClassUtils.isAssignable(Long.class, Integer.TYPE)); [EOL]         assertEquals("long -> long", autoboxing, ClassUtils.isAssignable(Long.class, Long.TYPE)); [EOL]         assertEquals("long -> float", autoboxing, ClassUtils.isAssignable(Long.class, Float.TYPE)); [EOL]         assertEquals("long -> double", autoboxing, ClassUtils.isAssignable(Long.class, Double.TYPE)); [EOL]         assertFalse("long -> boolean", ClassUtils.isAssignable(Long.class, Boolean.TYPE)); [EOL]  [EOL]         // test float conversions [EOL]         assertFalse("float -> char", ClassUtils.isAssignable(Float.class, Character.TYPE)); [EOL]         assertFalse("float -> byte", ClassUtils.isAssignable(Float.class, Byte.TYPE)); [EOL]         assertFalse("float -> short", ClassUtils.isAssignable(Float.class, Short.TYPE)); [EOL]         assertFalse("float -> int", ClassUtils.isAssignable(Float.class, Integer.TYPE)); [EOL]         assertFalse("float -> long", ClassUtils.isAssignable(Float.class, Long.TYPE)); [EOL]         assertEquals("float -> float", autoboxing, ClassUtils.isAssignable(Float.class, Float.TYPE)); [EOL]         assertEquals("float -> double", autoboxing, ClassUtils.isAssignable(Float.class, Double.TYPE)); [EOL]         assertFalse("float -> boolean", ClassUtils.isAssignable(Float.class, Boolean.TYPE)); [EOL]  [EOL]         // test double conversions [EOL]         assertFalse("double -> char", ClassUtils.isAssignable(Double.class, Character.TYPE)); [EOL]         assertFalse("double -> byte", ClassUtils.isAssignable(Double.class, Byte.TYPE)); [EOL]         assertFalse("double -> short", ClassUtils.isAssignable(Double.class, Short.TYPE)); [EOL]         assertFalse("double -> int", ClassUtils.isAssignable(Double.class, Integer.TYPE)); [EOL]         assertFalse("double -> long", ClassUtils.isAssignable(Double.class, Long.TYPE)); [EOL]         assertFalse("double -> float", ClassUtils.isAssignable(Double.class, Float.TYPE)); [EOL]         assertEquals("double -> double", autoboxing, ClassUtils.isAssignable(Double.class, Double.TYPE)); [EOL]         assertFalse("double -> boolean", ClassUtils.isAssignable(Double.class, Boolean.TYPE)); [EOL]  [EOL]         // test boolean conversions [EOL]         assertFalse("boolean -> char", ClassUtils.isAssignable(Boolean.class, Character.TYPE)); [EOL]         assertFalse("boolean -> byte", ClassUtils.isAssignable(Boolean.class, Byte.TYPE)); [EOL]         assertFalse("boolean -> short", ClassUtils.isAssignable(Boolean.class, Short.TYPE)); [EOL]         assertFalse("boolean -> int", ClassUtils.isAssignable(Boolean.class, Integer.TYPE)); [EOL]         assertFalse("boolean -> long", ClassUtils.isAssignable(Boolean.class, Long.TYPE)); [EOL]         assertFalse("boolean -> float", ClassUtils.isAssignable(Boolean.class, Float.TYPE)); [EOL]         assertFalse("boolean -> double", ClassUtils.isAssignable(Boolean.class, Double.TYPE)); [EOL]         assertEquals("boolean -> boolean", autoboxing, ClassUtils.isAssignable(Boolean.class, Boolean.TYPE)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void test_isAssignable_DefaultUnboxing_Widening() throws Exception { [EOL]         final boolean autoboxing = SystemUtils.isJavaVersionAtLeast(JAVA_1_5); [EOL]  [EOL]         // test byte conversions [EOL]         assertFalse("byte -> char", ClassUtils.isAssignable(Byte.class, Character.TYPE)); [EOL]         assertEquals("byte -> byte", autoboxing, ClassUtils.isAssignable(Byte.class, Byte.TYPE)); [EOL]         assertEquals("byte -> short", autoboxing, ClassUtils.isAssignable(Byte.class, Short.TYPE)); [EOL]         assertEquals("byte -> int", autoboxing, ClassUtils.isAssignable(Byte.class, Integer.TYPE)); [EOL]         assertEquals("byte -> long", autoboxing, ClassUtils.isAssignable(Byte.class, Long.TYPE)); [EOL]         assertEquals("byte -> float", autoboxing, ClassUtils.isAssignable(Byte.class, Float.TYPE)); [EOL]         assertEquals("byte -> double", autoboxing, ClassUtils.isAssignable(Byte.class, Double.TYPE)); [EOL]         assertFalse("byte -> boolean", ClassUtils.isAssignable(Byte.class, Boolean.TYPE)); [EOL]  [EOL]         // test short conversions [EOL]         assertFalse("short -> char", ClassUtils.isAssignable(Short.class, Character.TYPE)); [EOL]         assertFalse("short -> byte", ClassUtils.isAssignable(Short.class, Byte.TYPE)); [EOL]         assertEquals("short -> short", autoboxing, ClassUtils.isAssignable(Short.class, Short.TYPE)); [EOL]         assertEquals("short -> int", autoboxing, ClassUtils.isAssignable(Short.class, Integer.TYPE)); [EOL]         assertEquals("short -> long", autoboxing, ClassUtils.isAssignable(Short.class, Long.TYPE)); [EOL]         assertEquals("short -> float", autoboxing, ClassUtils.isAssignable(Short.class, Float.TYPE)); [EOL]         assertEquals("short -> double", autoboxing, ClassUtils.isAssignable(Short.class, Double.TYPE)); [EOL]         assertFalse("short -> boolean", ClassUtils.isAssignable(Short.class, Boolean.TYPE)); [EOL]  [EOL]         // test char conversions [EOL]         assertEquals("char -> char", autoboxing, ClassUtils.isAssignable(Character.class, Character.TYPE)); [EOL]         assertFalse("char -> byte", ClassUtils.isAssignable(Character.class, Byte.TYPE)); [EOL]         assertFalse("char -> short", ClassUtils.isAssignable(Character.class, Short.TYPE)); [EOL]         assertEquals("char -> int", autoboxing, ClassUtils.isAssignable(Character.class, Integer.TYPE)); [EOL]         assertEquals("char -> long", autoboxing, ClassUtils.isAssignable(Character.class, Long.TYPE)); [EOL]         assertEquals("char -> float", autoboxing, ClassUtils.isAssignable(Character.class, Float.TYPE)); [EOL]         assertEquals("char -> double", autoboxing, ClassUtils.isAssignable(Character.class, Double.TYPE)); [EOL]         assertFalse("char -> boolean", ClassUtils.isAssignable(Character.class, Boolean.TYPE)); [EOL]  [EOL]         // test int conversions [EOL]         assertFalse("int -> char", ClassUtils.isAssignable(Integer.class, Character.TYPE)); [EOL]         assertFalse("int -> byte", ClassUtils.isAssignable(Integer.class, Byte.TYPE)); [EOL]         assertFalse("int -> short", ClassUtils.isAssignable(Integer.class, Short.TYPE)); [EOL]         assertEquals("int -> int", autoboxing, ClassUtils.isAssignable(Integer.class, Integer.TYPE)); [EOL]         assertEquals("int -> long", autoboxing, ClassUtils.isAssignable(Integer.class, Long.TYPE)); [EOL]         assertEquals("int -> float", autoboxing, ClassUtils.isAssignable(Integer.class, Float.TYPE)); [EOL]         assertEquals("int -> double", autoboxing, ClassUtils.isAssignable(Integer.class, Double.TYPE)); [EOL]         assertFalse("int -> boolean", ClassUtils.isAssignable(Integer.class, Boolean.TYPE)); [EOL]  [EOL]         // test long conversions [EOL]         assertFalse("long -> char", ClassUtils.isAssignable(Long.class, Character.TYPE)); [EOL]         assertFalse("long -> byte", ClassUtils.isAssignable(Long.class, Byte.TYPE)); [EOL]         assertFalse("long -> short", ClassUtils.isAssignable(Long.class, Short.TYPE)); [EOL]         assertFalse("long -> int", ClassUtils.isAssignable(Long.class, Integer.TYPE)); [EOL]         assertEquals("long -> long", autoboxing, ClassUtils.isAssignable(Long.class, Long.TYPE)); [EOL]         assertEquals("long -> float", autoboxing, ClassUtils.isAssignable(Long.class, Float.TYPE)); [EOL]         assertEquals("long -> double", autoboxing, ClassUtils.isAssignable(Long.class, Double.TYPE)); [EOL]         assertFalse("long -> boolean", ClassUtils.isAssignable(Long.class, Boolean.TYPE)); [EOL]  [EOL]         // test float conversions [EOL]         assertFalse("float -> char", ClassUtils.isAssignable(Float.class, Character.TYPE)); [EOL]         assertFalse("float -> byte", ClassUtils.isAssignable(Float.class, Byte.TYPE)); [EOL]         assertFalse("float -> short", ClassUtils.isAssignable(Float.class, Short.TYPE)); [EOL]         assertFalse("float -> int", ClassUtils.isAssignable(Float.class, Integer.TYPE)); [EOL]         assertFalse("float -> long", ClassUtils.isAssignable(Float.class, Long.TYPE)); [EOL]         assertEquals("float -> float", autoboxing, ClassUtils.isAssignable(Float.class, Float.TYPE)); [EOL]         assertEquals("float -> double", autoboxing, ClassUtils.isAssignable(Float.class, Double.TYPE)); [EOL]         assertFalse("float -> boolean", ClassUtils.isAssignable(Float.class, Boolean.TYPE)); [EOL]  [EOL]         // test double conversions [EOL]         assertFalse("double -> char", ClassUtils.isAssignable(Double.class, Character.TYPE)); [EOL]         assertFalse("double -> byte", ClassUtils.isAssignable(Double.class, Byte.TYPE)); [EOL]         assertFalse("double -> short", ClassUtils.isAssignable(Double.class, Short.TYPE)); [EOL]         assertFalse("double -> int", ClassUtils.isAssignable(Double.class, Integer.TYPE)); [EOL]         assertFalse("double -> long", ClassUtils.isAssignable(Double.class, Long.TYPE)); [EOL]         assertFalse("double -> float", ClassUtils.isAssignable(Double.class, Float.TYPE)); [EOL]         assertEquals("double -> double", autoboxing, ClassUtils.isAssignable(Double.class, Double.TYPE)); [EOL]         assertFalse("double -> boolean", ClassUtils.isAssignable(Double.class, Boolean.TYPE)); [EOL]  [EOL]         // test boolean conversions [EOL]         assertFalse("boolean -> char", ClassUtils.isAssignable(Boolean.class, Character.TYPE)); [EOL]         assertFalse("boolean -> byte", ClassUtils.isAssignable(Boolean.class, Byte.TYPE)); [EOL]         assertFalse("boolean -> short", ClassUtils.isAssignable(Boolean.class, Short.TYPE)); [EOL]         assertFalse("boolean -> int", ClassUtils.isAssignable(Boolean.class, Integer.TYPE)); [EOL]         assertFalse("boolean -> long", ClassUtils.isAssignable(Boolean.class, Long.TYPE)); [EOL]         assertFalse("boolean -> float", ClassUtils.isAssignable(Boolean.class, Float.TYPE)); [EOL]         assertFalse("boolean -> double", ClassUtils.isAssignable(Boolean.class, Double.TYPE)); [EOL]         assertEquals("boolean -> boolean", autoboxing, ClassUtils.isAssignable(Boolean.class, Boolean.TYPE)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void test_isAssignable_DefaultUnboxing_Widening() throws Exception { [EOL]         final boolean autoboxing = SystemUtils.isJavaVersionAtLeast(JAVA_1_5); [EOL]  [EOL]         // test byte conversions [EOL]         assertFalse("byte -> char", ClassUtils.isAssignable(Byte.class, Character.TYPE)); [EOL]         assertEquals("byte -> byte", autoboxing, ClassUtils.isAssignable(Byte.class, Byte.TYPE)); [EOL]         assertEquals("byte -> short", autoboxing, ClassUtils.isAssignable(Byte.class, Short.TYPE)); [EOL]         assertEquals("byte -> int", autoboxing, ClassUtils.isAssignable(Byte.class, Integer.TYPE)); [EOL]         assertEquals("byte -> long", autoboxing, ClassUtils.isAssignable(Byte.class, Long.TYPE)); [EOL]         assertEquals("byte -> float", autoboxing, ClassUtils.isAssignable(Byte.class, Float.TYPE)); [EOL]         assertEquals("byte -> double", autoboxing, ClassUtils.isAssignable(Byte.class, Double.TYPE)); [EOL]         assertFalse("byte -> boolean", ClassUtils.isAssignable(Byte.class, Boolean.TYPE)); [EOL]  [EOL]         // test short conversions [EOL]         assertFalse("short -> char", ClassUtils.isAssignable(Short.class, Character.TYPE)); [EOL]         assertFalse("short -> byte", ClassUtils.isAssignable(Short.class, Byte.TYPE)); [EOL]         assertEquals("short -> short", autoboxing, ClassUtils.isAssignable(Short.class, Short.TYPE)); [EOL]         assertEquals("short -> int", autoboxing, ClassUtils.isAssignable(Short.class, Integer.TYPE)); [EOL]         assertEquals("short -> long", autoboxing, ClassUtils.isAssignable(Short.class, Long.TYPE)); [EOL]         assertEquals("short -> float", autoboxing, ClassUtils.isAssignable(Short.class, Float.TYPE)); [EOL]         assertEquals("short -> double", autoboxing, ClassUtils.isAssignable(Short.class, Double.TYPE)); [EOL]         assertFalse("short -> boolean", ClassUtils.isAssignable(Short.class, Boolean.TYPE)); [EOL]  [EOL]         // test char conversions [EOL]         assertEquals("char -> char", autoboxing, ClassUtils.isAssignable(Character.class, Character.TYPE)); [EOL]         assertFalse("char -> byte", ClassUtils.isAssignable(Character.class, Byte.TYPE)); [EOL]         assertFalse("char -> short", ClassUtils.isAssignable(Character.class, Short.TYPE)); [EOL]         assertEquals("char -> int", autoboxing, ClassUtils.isAssignable(Character.class, Integer.TYPE)); [EOL]         assertEquals("char -> long", autoboxing, ClassUtils.isAssignable(Character.class, Long.TYPE)); [EOL]         assertEquals("char -> float", autoboxing, ClassUtils.isAssignable(Character.class, Float.TYPE)); [EOL]         assertEquals("char -> double", autoboxing, ClassUtils.isAssignable(Character.class, Double.TYPE)); [EOL]         assertFalse("char -> boolean", ClassUtils.isAssignable(Character.class, Boolean.TYPE)); [EOL]  [EOL]         // test int conversions [EOL]         assertFalse("int -> char", ClassUtils.isAssignable(Integer.class, Character.TYPE)); [EOL]         assertFalse("int -> byte", ClassUtils.isAssignable(Integer.class, Byte.TYPE)); [EOL]         assertFalse("int -> short", ClassUtils.isAssignable(Integer.class, Short.TYPE)); [EOL]         assertEquals("int -> int", autoboxing, ClassUtils.isAssignable(Integer.class, Integer.TYPE)); [EOL]         assertEquals("int -> long", autoboxing, ClassUtils.isAssignable(Integer.class, Long.TYPE)); [EOL]         assertEquals("int -> float", autoboxing, ClassUtils.isAssignable(Integer.class, Float.TYPE)); [EOL]         assertEquals("int -> double", autoboxing, ClassUtils.isAssignable(Integer.class, Double.TYPE)); [EOL]         assertFalse("int -> boolean", ClassUtils.isAssignable(Integer.class, Boolean.TYPE)); [EOL]  [EOL]         // test long conversions [EOL]         assertFalse("long -> char", ClassUtils.isAssignable(Long.class, Character.TYPE)); [EOL]         assertFalse("long -> byte", ClassUtils.isAssignable(Long.class, Byte.TYPE)); [EOL]         assertFalse("long -> short", ClassUtils.isAssignable(Long.class, Short.TYPE)); [EOL]         assertFalse("long -> int", ClassUtils.isAssignable(Long.class, Integer.TYPE)); [EOL]         assertEquals("long -> long", autoboxing, ClassUtils.isAssignable(Long.class, Long.TYPE)); [EOL]         assertEquals("long -> float", autoboxing, ClassUtils.isAssignable(Long.class, Float.TYPE)); [EOL]         assertEquals("long -> double", autoboxing, ClassUtils.isAssignable(Long.class, Double.TYPE)); [EOL]         assertFalse("long -> boolean", ClassUtils.isAssignable(Long.class, Boolean.TYPE)); [EOL]  [EOL]         // test float conversions [EOL]         assertFalse("float -> char", ClassUtils.isAssignable(Float.class, Character.TYPE)); [EOL]         assertFalse("float -> byte", ClassUtils.isAssignable(Float.class, Byte.TYPE)); [EOL]         assertFalse("float -> short", ClassUtils.isAssignable(Float.class, Short.TYPE)); [EOL]         assertFalse("float -> int", ClassUtils.isAssignable(Float.class, Integer.TYPE)); [EOL]         assertFalse("float -> long", ClassUtils.isAssignable(Float.class, Long.TYPE)); [EOL]         assertEquals("float -> float", autoboxing, ClassUtils.isAssignable(Float.class, Float.TYPE)); [EOL]         assertEquals("float -> double", autoboxing, ClassUtils.isAssignable(Float.class, Double.TYPE)); [EOL]         assertFalse("float -> boolean", ClassUtils.isAssignable(Float.class, Boolean.TYPE)); [EOL]  [EOL]         // test double conversions [EOL]         assertFalse("double -> char", ClassUtils.isAssignable(Double.class, Character.TYPE)); [EOL]         assertFalse("double -> byte", ClassUtils.isAssignable(Double.class, Byte.TYPE)); [EOL]         assertFalse("double -> short", ClassUtils.isAssignable(Double.class, Short.TYPE)); [EOL]         assertFalse("double -> int", ClassUtils.isAssignable(Double.class, Integer.TYPE)); [EOL]         assertFalse("double -> long", ClassUtils.isAssignable(Double.class, Long.TYPE)); [EOL]         assertFalse("double -> float", ClassUtils.isAssignable(Double.class, Float.TYPE)); [EOL]         assertEquals("double -> double", autoboxing, ClassUtils.isAssignable(Double.class, Double.TYPE)); [EOL]         assertFalse("double -> boolean", ClassUtils.isAssignable(Double.class, Boolean.TYPE)); [EOL]  [EOL]         // test boolean conversions [EOL]         assertFalse("boolean -> char", ClassUtils.isAssignable(Boolean.class, Character.TYPE)); [EOL]         assertFalse("boolean -> byte", ClassUtils.isAssignable(Boolean.class, Byte.TYPE)); [EOL]         assertFalse("boolean -> short", ClassUtils.isAssignable(Boolean.class, Short.TYPE)); [EOL]         assertFalse("boolean -> int", ClassUtils.isAssignable(Boolean.class, Integer.TYPE)); [EOL]         assertFalse("boolean -> long", ClassUtils.isAssignable(Boolean.class, Long.TYPE)); [EOL]         assertFalse("boolean -> float", ClassUtils.isAssignable(Boolean.class, Float.TYPE)); [EOL]         assertFalse("boolean -> double", ClassUtils.isAssignable(Boolean.class, Double.TYPE)); [EOL]         assertEquals("boolean -> boolean", autoboxing, ClassUtils.isAssignable(Boolean.class, Boolean.TYPE)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void test_isAssignable_DefaultUnboxing_Widening() throws Exception { [EOL]         final boolean autoboxing = SystemUtils.isJavaVersionAtLeast(JAVA_1_5); [EOL]  [EOL]         // test byte conversions [EOL]         assertFalse("byte -> char", ClassUtils.isAssignable(Byte.class, Character.TYPE)); [EOL]         assertEquals("byte -> byte", autoboxing, ClassUtils.isAssignable(Byte.class, Byte.TYPE)); [EOL]         assertEquals("byte -> short", autoboxing, ClassUtils.isAssignable(Byte.class, Short.TYPE)); [EOL]         assertEquals("byte -> int", autoboxing, ClassUtils.isAssignable(Byte.class, Integer.TYPE)); [EOL]         assertEquals("byte -> long", autoboxing, ClassUtils.isAssignable(Byte.class, Long.TYPE)); [EOL]         assertEquals("byte -> float", autoboxing, ClassUtils.isAssignable(Byte.class, Float.TYPE)); [EOL]         assertEquals("byte -> double", autoboxing, ClassUtils.isAssignable(Byte.class, Double.TYPE)); [EOL]         assertFalse("byte -> boolean", ClassUtils.isAssignable(Byte.class, Boolean.TYPE)); [EOL]  [EOL]         // test short conversions [EOL]         assertFalse("short -> char", ClassUtils.isAssignable(Short.class, Character.TYPE)); [EOL]         assertFalse("short -> byte", ClassUtils.isAssignable(Short.class, Byte.TYPE)); [EOL]         assertEquals("short -> short", autoboxing, ClassUtils.isAssignable(Short.class, Short.TYPE)); [EOL]         assertEquals("short -> int", autoboxing, ClassUtils.isAssignable(Short.class, Integer.TYPE)); [EOL]         assertEquals("short -> long", autoboxing, ClassUtils.isAssignable(Short.class, Long.TYPE)); [EOL]         assertEquals("short -> float", autoboxing, ClassUtils.isAssignable(Short.class, Float.TYPE)); [EOL]         assertEquals("short -> double", autoboxing, ClassUtils.isAssignable(Short.class, Double.TYPE)); [EOL]         assertFalse("short -> boolean", ClassUtils.isAssignable(Short.class, Boolean.TYPE)); [EOL]  [EOL]         // test char conversions [EOL]         assertEquals("char -> char", autoboxing, ClassUtils.isAssignable(Character.class, Character.TYPE)); [EOL]         assertFalse("char -> byte", ClassUtils.isAssignable(Character.class, Byte.TYPE)); [EOL]         assertFalse("char -> short", ClassUtils.isAssignable(Character.class, Short.TYPE)); [EOL]         assertEquals("char -> int", autoboxing, ClassUtils.isAssignable(Character.class, Integer.TYPE)); [EOL]         assertEquals("char -> long", autoboxing, ClassUtils.isAssignable(Character.class, Long.TYPE)); [EOL]         assertEquals("char -> float", autoboxing, ClassUtils.isAssignable(Character.class, Float.TYPE)); [EOL]         assertEquals("char -> double", autoboxing, ClassUtils.isAssignable(Character.class, Double.TYPE)); [EOL]         assertFalse("char -> boolean", ClassUtils.isAssignable(Character.class, Boolean.TYPE)); [EOL]  [EOL]         // test int conversions [EOL]         assertFalse("int -> char", ClassUtils.isAssignable(Integer.class, Character.TYPE)); [EOL]         assertFalse("int -> byte", ClassUtils.isAssignable(Integer.class, Byte.TYPE)); [EOL]         assertFalse("int -> short", ClassUtils.isAssignable(Integer.class, Short.TYPE)); [EOL]         assertEquals("int -> int", autoboxing, ClassUtils.isAssignable(Integer.class, Integer.TYPE)); [EOL]         assertEquals("int -> long", autoboxing, ClassUtils.isAssignable(Integer.class, Long.TYPE)); [EOL]         assertEquals("int -> float", autoboxing, ClassUtils.isAssignable(Integer.class, Float.TYPE)); [EOL]         assertEquals("int -> double", autoboxing, ClassUtils.isAssignable(Integer.class, Double.TYPE)); [EOL]         assertFalse("int -> boolean", ClassUtils.isAssignable(Integer.class, Boolean.TYPE)); [EOL]  [EOL]         // test long conversions [EOL]         assertFalse("long -> char", ClassUtils.isAssignable(Long.class, Character.TYPE)); [EOL]         assertFalse("long -> byte", ClassUtils.isAssignable(Long.class, Byte.TYPE)); [EOL]         assertFalse("long -> short", ClassUtils.isAssignable(Long.class, Short.TYPE)); [EOL]         assertFalse("long -> int", ClassUtils.isAssignable(Long.class, Integer.TYPE)); [EOL]         assertEquals("long -> long", autoboxing, ClassUtils.isAssignable(Long.class, Long.TYPE)); [EOL]         assertEquals("long -> float", autoboxing, ClassUtils.isAssignable(Long.class, Float.TYPE)); [EOL]         assertEquals("long -> double", autoboxing, ClassUtils.isAssignable(Long.class, Double.TYPE)); [EOL]         assertFalse("long -> boolean", ClassUtils.isAssignable(Long.class, Boolean.TYPE)); [EOL]  [EOL]         // test float conversions [EOL]         assertFalse("float -> char", ClassUtils.isAssignable(Float.class, Character.TYPE)); [EOL]         assertFalse("float -> byte", ClassUtils.isAssignable(Float.class, Byte.TYPE)); [EOL]         assertFalse("float -> short", ClassUtils.isAssignable(Float.class, Short.TYPE)); [EOL]         assertFalse("float -> int", ClassUtils.isAssignable(Float.class, Integer.TYPE)); [EOL]         assertFalse("float -> long", ClassUtils.isAssignable(Float.class, Long.TYPE)); [EOL]         assertEquals("float -> float", autoboxing, ClassUtils.isAssignable(Float.class, Float.TYPE)); [EOL]         assertEquals("float -> double", autoboxing, ClassUtils.isAssignable(Float.class, Double.TYPE)); [EOL]         assertFalse("float -> boolean", ClassUtils.isAssignable(Float.class, Boolean.TYPE)); [EOL]  [EOL]         // test double conversions [EOL]         assertFalse("double -> char", ClassUtils.isAssignable(Double.class, Character.TYPE)); [EOL]         assertFalse("double -> byte", ClassUtils.isAssignable(Double.class, Byte.TYPE)); [EOL]         assertFalse("double -> short", ClassUtils.isAssignable(Double.class, Short.TYPE)); [EOL]         assertFalse("double -> int", ClassUtils.isAssignable(Double.class, Integer.TYPE)); [EOL]         assertFalse("double -> long", ClassUtils.isAssignable(Double.class, Long.TYPE)); [EOL]         assertFalse("double -> float", ClassUtils.isAssignable(Double.class, Float.TYPE)); [EOL]         assertEquals("double -> double", autoboxing, ClassUtils.isAssignable(Double.class, Double.TYPE)); [EOL]         assertFalse("double -> boolean", ClassUtils.isAssignable(Double.class, Boolean.TYPE)); [EOL]  [EOL]         // test boolean conversions [EOL]         assertFalse("boolean -> char", ClassUtils.isAssignable(Boolean.class, Character.TYPE)); [EOL]         assertFalse("boolean -> byte", ClassUtils.isAssignable(Boolean.class, Byte.TYPE)); [EOL]         assertFalse("boolean -> short", ClassUtils.isAssignable(Boolean.class, Short.TYPE)); [EOL]         assertFalse("boolean -> int", ClassUtils.isAssignable(Boolean.class, Integer.TYPE)); [EOL]         assertFalse("boolean -> long", ClassUtils.isAssignable(Boolean.class, Long.TYPE)); [EOL]         assertFalse("boolean -> float", ClassUtils.isAssignable(Boolean.class, Float.TYPE)); [EOL]         assertFalse("boolean -> double", ClassUtils.isAssignable(Boolean.class, Double.TYPE)); [EOL]         assertEquals("boolean -> boolean", autoboxing, ClassUtils.isAssignable(Boolean.class, Boolean.TYPE)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void test_isAssignable_DefaultUnboxing_Widening() throws Exception { [EOL]         final boolean autoboxing = SystemUtils.isJavaVersionAtLeast(JAVA_1_5); [EOL]  [EOL]         // test byte conversions [EOL]         assertFalse("byte -> char", ClassUtils.isAssignable(Byte.class, Character.TYPE)); [EOL]         assertEquals("byte -> byte", autoboxing, ClassUtils.isAssignable(Byte.class, Byte.TYPE)); [EOL]         assertEquals("byte -> short", autoboxing, ClassUtils.isAssignable(Byte.class, Short.TYPE)); [EOL]         assertEquals("byte -> int", autoboxing, ClassUtils.isAssignable(Byte.class, Integer.TYPE)); [EOL]         assertEquals("byte -> long", autoboxing, ClassUtils.isAssignable(Byte.class, Long.TYPE)); [EOL]         assertEquals("byte -> float", autoboxing, ClassUtils.isAssignable(Byte.class, Float.TYPE)); [EOL]         assertEquals("byte -> double", autoboxing, ClassUtils.isAssignable(Byte.class, Double.TYPE)); [EOL]         assertFalse("byte -> boolean", ClassUtils.isAssignable(Byte.class, Boolean.TYPE)); [EOL]  [EOL]         // test short conversions [EOL]         assertFalse("short -> char", ClassUtils.isAssignable(Short.class, Character.TYPE)); [EOL]         assertFalse("short -> byte", ClassUtils.isAssignable(Short.class, Byte.TYPE)); [EOL]         assertEquals("short -> short", autoboxing, ClassUtils.isAssignable(Short.class, Short.TYPE)); [EOL]         assertEquals("short -> int", autoboxing, ClassUtils.isAssignable(Short.class, Integer.TYPE)); [EOL]         assertEquals("short -> long", autoboxing, ClassUtils.isAssignable(Short.class, Long.TYPE)); [EOL]         assertEquals("short -> float", autoboxing, ClassUtils.isAssignable(Short.class, Float.TYPE)); [EOL]         assertEquals("short -> double", autoboxing, ClassUtils.isAssignable(Short.class, Double.TYPE)); [EOL]         assertFalse("short -> boolean", ClassUtils.isAssignable(Short.class, Boolean.TYPE)); [EOL]  [EOL]         // test char conversions [EOL]         assertEquals("char -> char", autoboxing, ClassUtils.isAssignable(Character.class, Character.TYPE)); [EOL]         assertFalse("char -> byte", ClassUtils.isAssignable(Character.class, Byte.TYPE)); [EOL]         assertFalse("char -> short", ClassUtils.isAssignable(Character.class, Short.TYPE)); [EOL]         assertEquals("char -> int", autoboxing, ClassUtils.isAssignable(Character.class, Integer.TYPE)); [EOL]         assertEquals("char -> long", autoboxing, ClassUtils.isAssignable(Character.class, Long.TYPE)); [EOL]         assertEquals("char -> float", autoboxing, ClassUtils.isAssignable(Character.class, Float.TYPE)); [EOL]         assertEquals("char -> double", autoboxing, ClassUtils.isAssignable(Character.class, Double.TYPE)); [EOL]         assertFalse("char -> boolean", ClassUtils.isAssignable(Character.class, Boolean.TYPE)); [EOL]  [EOL]         // test int conversions [EOL]         assertFalse("int -> char", ClassUtils.isAssignable(Integer.class, Character.TYPE)); [EOL]         assertFalse("int -> byte", ClassUtils.isAssignable(Integer.class, Byte.TYPE)); [EOL]         assertFalse("int -> short", ClassUtils.isAssignable(Integer.class, Short.TYPE)); [EOL]         assertEquals("int -> int", autoboxing, ClassUtils.isAssignable(Integer.class, Integer.TYPE)); [EOL]         assertEquals("int -> long", autoboxing, ClassUtils.isAssignable(Integer.class, Long.TYPE)); [EOL]         assertEquals("int -> float", autoboxing, ClassUtils.isAssignable(Integer.class, Float.TYPE)); [EOL]         assertEquals("int -> double", autoboxing, ClassUtils.isAssignable(Integer.class, Double.TYPE)); [EOL]         assertFalse("int -> boolean", ClassUtils.isAssignable(Integer.class, Boolean.TYPE)); [EOL]  [EOL]         // test long conversions [EOL]         assertFalse("long -> char", ClassUtils.isAssignable(Long.class, Character.TYPE)); [EOL]         assertFalse("long -> byte", ClassUtils.isAssignable(Long.class, Byte.TYPE)); [EOL]         assertFalse("long -> short", ClassUtils.isAssignable(Long.class, Short.TYPE)); [EOL]         assertFalse("long -> int", ClassUtils.isAssignable(Long.class, Integer.TYPE)); [EOL]         assertEquals("long -> long", autoboxing, ClassUtils.isAssignable(Long.class, Long.TYPE)); [EOL]         assertEquals("long -> float", autoboxing, ClassUtils.isAssignable(Long.class, Float.TYPE)); [EOL]         assertEquals("long -> double", autoboxing, ClassUtils.isAssignable(Long.class, Double.TYPE)); [EOL]         assertFalse("long -> boolean", ClassUtils.isAssignable(Long.class, Boolean.TYPE)); [EOL]  [EOL]         // test float conversions [EOL]         assertFalse("float -> char", ClassUtils.isAssignable(Float.class, Character.TYPE)); [EOL]         assertFalse("float -> byte", ClassUtils.isAssignable(Float.class, Byte.TYPE)); [EOL]         assertFalse("float -> short", ClassUtils.isAssignable(Float.class, Short.TYPE)); [EOL]         assertFalse("float -> int", ClassUtils.isAssignable(Float.class, Integer.TYPE)); [EOL]         assertFalse("float -> long", ClassUtils.isAssignable(Float.class, Long.TYPE)); [EOL]         assertEquals("float -> float", autoboxing, ClassUtils.isAssignable(Float.class, Float.TYPE)); [EOL]         assertEquals("float -> double", autoboxing, ClassUtils.isAssignable(Float.class, Double.TYPE)); [EOL]         assertFalse("float -> boolean", ClassUtils.isAssignable(Float.class, Boolean.TYPE)); [EOL]  [EOL]         // test double conversions [EOL]         assertFalse("double -> char", ClassUtils.isAssignable(Double.class, Character.TYPE)); [EOL]         assertFalse("double -> byte", ClassUtils.isAssignable(Double.class, Byte.TYPE)); [EOL]         assertFalse("double -> short", ClassUtils.isAssignable(Double.class, Short.TYPE)); [EOL]         assertFalse("double -> int", ClassUtils.isAssignable(Double.class, Integer.TYPE)); [EOL]         assertFalse("double -> long", ClassUtils.isAssignable(Double.class, Long.TYPE)); [EOL]         assertFalse("double -> float", ClassUtils.isAssignable(Double.class, Float.TYPE)); [EOL]         assertEquals("double -> double", autoboxing, ClassUtils.isAssignable(Double.class, Double.TYPE)); [EOL]         assertFalse("double -> boolean", ClassUtils.isAssignable(Double.class, Boolean.TYPE)); [EOL]  [EOL]         // test boolean conversions [EOL]         assertFalse("boolean -> char", ClassUtils.isAssignable(Boolean.class, Character.TYPE)); [EOL]         assertFalse("boolean -> byte", ClassUtils.isAssignable(Boolean.class, Byte.TYPE)); [EOL]         assertFalse("boolean -> short", ClassUtils.isAssignable(Boolean.class, Short.TYPE)); [EOL]         assertFalse("boolean -> int", ClassUtils.isAssignable(Boolean.class, Integer.TYPE)); [EOL]         assertFalse("boolean -> long", ClassUtils.isAssignable(Boolean.class, Long.TYPE)); [EOL]         assertFalse("boolean -> float", ClassUtils.isAssignable(Boolean.class, Float.TYPE)); [EOL]         assertFalse("boolean -> double", ClassUtils.isAssignable(Boolean.class, Double.TYPE)); [EOL]         assertEquals("boolean -> boolean", autoboxing, ClassUtils.isAssignable(Boolean.class, Boolean.TYPE)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void test_isAssignable_DefaultUnboxing_Widening() throws Exception { [EOL]         final boolean autoboxing = SystemUtils.isJavaVersionAtLeast(JAVA_1_5); [EOL]  [EOL]         // test byte conversions [EOL]         assertFalse("byte -> char", ClassUtils.isAssignable(Byte.class, Character.TYPE)); [EOL]         assertEquals("byte -> byte", autoboxing, ClassUtils.isAssignable(Byte.class, Byte.TYPE)); [EOL]         assertEquals("byte -> short", autoboxing, ClassUtils.isAssignable(Byte.class, Short.TYPE)); [EOL]         assertEquals("byte -> int", autoboxing, ClassUtils.isAssignable(Byte.class, Integer.TYPE)); [EOL]         assertEquals("byte -> long", autoboxing, ClassUtils.isAssignable(Byte.class, Long.TYPE)); [EOL]         assertEquals("byte -> float", autoboxing, ClassUtils.isAssignable(Byte.class, Float.TYPE)); [EOL]         assertEquals("byte -> double", autoboxing, ClassUtils.isAssignable(Byte.class, Double.TYPE)); [EOL]         assertFalse("byte -> boolean", ClassUtils.isAssignable(Byte.class, Boolean.TYPE)); [EOL]  [EOL]         // test short conversions [EOL]         assertFalse("short -> char", ClassUtils.isAssignable(Short.class, Character.TYPE)); [EOL]         assertFalse("short -> byte", ClassUtils.isAssignable(Short.class, Byte.TYPE)); [EOL]         assertEquals("short -> short", autoboxing, ClassUtils.isAssignable(Short.class, Short.TYPE)); [EOL]         assertEquals("short -> int", autoboxing, ClassUtils.isAssignable(Short.class, Integer.TYPE)); [EOL]         assertEquals("short -> long", autoboxing, ClassUtils.isAssignable(Short.class, Long.TYPE)); [EOL]         assertEquals("short -> float", autoboxing, ClassUtils.isAssignable(Short.class, Float.TYPE)); [EOL]         assertEquals("short -> double", autoboxing, ClassUtils.isAssignable(Short.class, Double.TYPE)); [EOL]         assertFalse("short -> boolean", ClassUtils.isAssignable(Short.class, Boolean.TYPE)); [EOL]  [EOL]         // test char conversions [EOL]         assertEquals("char -> char", autoboxing, ClassUtils.isAssignable(Character.class, Character.TYPE)); [EOL]         assertFalse("char -> byte", ClassUtils.isAssignable(Character.class, Byte.TYPE)); [EOL]         assertFalse("char -> short", ClassUtils.isAssignable(Character.class, Short.TYPE)); [EOL]         assertEquals("char -> int", autoboxing, ClassUtils.isAssignable(Character.class, Integer.TYPE)); [EOL]         assertEquals("char -> long", autoboxing, ClassUtils.isAssignable(Character.class, Long.TYPE)); [EOL]         assertEquals("char -> float", autoboxing, ClassUtils.isAssignable(Character.class, Float.TYPE)); [EOL]         assertEquals("char -> double", autoboxing, ClassUtils.isAssignable(Character.class, Double.TYPE)); [EOL]         assertFalse("char -> boolean", ClassUtils.isAssignable(Character.class, Boolean.TYPE)); [EOL]  [EOL]         // test int conversions [EOL]         assertFalse("int -> char", ClassUtils.isAssignable(Integer.class, Character.TYPE)); [EOL]         assertFalse("int -> byte", ClassUtils.isAssignable(Integer.class, Byte.TYPE)); [EOL]         assertFalse("int -> short", ClassUtils.isAssignable(Integer.class, Short.TYPE)); [EOL]         assertEquals("int -> int", autoboxing, ClassUtils.isAssignable(Integer.class, Integer.TYPE)); [EOL]         assertEquals("int -> long", autoboxing, ClassUtils.isAssignable(Integer.class, Long.TYPE)); [EOL]         assertEquals("int -> float", autoboxing, ClassUtils.isAssignable(Integer.class, Float.TYPE)); [EOL]         assertEquals("int -> double", autoboxing, ClassUtils.isAssignable(Integer.class, Double.TYPE)); [EOL]         assertFalse("int -> boolean", ClassUtils.isAssignable(Integer.class, Boolean.TYPE)); [EOL]  [EOL]         // test long conversions [EOL]         assertFalse("long -> char", ClassUtils.isAssignable(Long.class, Character.TYPE)); [EOL]         assertFalse("long -> byte", ClassUtils.isAssignable(Long.class, Byte.TYPE)); [EOL]         assertFalse("long -> short", ClassUtils.isAssignable(Long.class, Short.TYPE)); [EOL]         assertFalse("long -> int", ClassUtils.isAssignable(Long.class, Integer.TYPE)); [EOL]         assertEquals("long -> long", autoboxing, ClassUtils.isAssignable(Long.class, Long.TYPE)); [EOL]         assertEquals("long -> float", autoboxing, ClassUtils.isAssignable(Long.class, Float.TYPE)); [EOL]         assertEquals("long -> double", autoboxing, ClassUtils.isAssignable(Long.class, Double.TYPE)); [EOL]         assertFalse("long -> boolean", ClassUtils.isAssignable(Long.class, Boolean.TYPE)); [EOL]  [EOL]         // test float conversions [EOL]         assertFalse("float -> char", ClassUtils.isAssignable(Float.class, Character.TYPE)); [EOL]         assertFalse("float -> byte", ClassUtils.isAssignable(Float.class, Byte.TYPE)); [EOL]         assertFalse("float -> short", ClassUtils.isAssignable(Float.class, Short.TYPE)); [EOL]         assertFalse("float -> int", ClassUtils.isAssignable(Float.class, Integer.TYPE)); [EOL]         assertFalse("float -> long", ClassUtils.isAssignable(Float.class, Long.TYPE)); [EOL]         assertEquals("float -> float", autoboxing, ClassUtils.isAssignable(Float.class, Float.TYPE)); [EOL]         assertEquals("float -> double", autoboxing, ClassUtils.isAssignable(Float.class, Double.TYPE)); [EOL]         assertFalse("float -> boolean", ClassUtils.isAssignable(Float.class, Boolean.TYPE)); [EOL]  [EOL]         // test double conversions [EOL]         assertFalse("double -> char", ClassUtils.isAssignable(Double.class, Character.TYPE)); [EOL]         assertFalse("double -> byte", ClassUtils.isAssignable(Double.class, Byte.TYPE)); [EOL]         assertFalse("double -> short", ClassUtils.isAssignable(Double.class, Short.TYPE)); [EOL]         assertFalse("double -> int", ClassUtils.isAssignable(Double.class, Integer.TYPE)); [EOL]         assertFalse("double -> long", ClassUtils.isAssignable(Double.class, Long.TYPE)); [EOL]         assertFalse("double -> float", ClassUtils.isAssignable(Double.class, Float.TYPE)); [EOL]         assertEquals("double -> double", autoboxing, ClassUtils.isAssignable(Double.class, Double.TYPE)); [EOL]         assertFalse("double -> boolean", ClassUtils.isAssignable(Double.class, Boolean.TYPE)); [EOL]  [EOL]         // test boolean conversions [EOL]         assertFalse("boolean -> char", ClassUtils.isAssignable(Boolean.class, Character.TYPE)); [EOL]         assertFalse("boolean -> byte", ClassUtils.isAssignable(Boolean.class, Byte.TYPE)); [EOL]         assertFalse("boolean -> short", ClassUtils.isAssignable(Boolean.class, Short.TYPE)); [EOL]         assertFalse("boolean -> int", ClassUtils.isAssignable(Boolean.class, Integer.TYPE)); [EOL]         assertFalse("boolean -> long", ClassUtils.isAssignable(Boolean.class, Long.TYPE)); [EOL]         assertFalse("boolean -> float", ClassUtils.isAssignable(Boolean.class, Float.TYPE)); [EOL]         assertFalse("boolean -> double", ClassUtils.isAssignable(Boolean.class, Double.TYPE)); [EOL]         assertEquals("boolean -> boolean", autoboxing, ClassUtils.isAssignable(Boolean.class, Boolean.TYPE)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetPublicMethod() throws Exception { [EOL]         // Tests with Collections$UnmodifiableSet [EOL]         final Set<?> set = Collections.unmodifiableSet(new HashSet<Object>()); [EOL]         final Method isEmptyMethod = ClassUtils.getPublicMethod(set.getClass(), "isEmpty",  new Class[0]); [EOL]             assertTrue(Modifier.isPublic(isEmptyMethod.getDeclaringClass().getModifiers())); [EOL]  [EOL]         try { [EOL]             isEmptyMethod.invoke(set, new Object[0]); [EOL]         } catch(final java.lang.IllegalAccessException iae) { [EOL]             fail("Should not have thrown IllegalAccessException"); [EOL]         } [EOL]  [EOL]         // Tests with a public Class [EOL]         final Method toStringMethod = ClassUtils.getPublicMethod(Object.class, "toString",  new Class[0]); [EOL]             assertEquals(Object.class.getMethod("toString", new Class[0]), toStringMethod); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetPublicMethod() throws Exception { [EOL]         // Tests with Collections$UnmodifiableSet [EOL]         final Set<?> set = Collections.unmodifiableSet(new HashSet<Object>()); [EOL]         final Method isEmptyMethod = ClassUtils.getPublicMethod(set.getClass(), "isEmpty",  new Class[0]); [EOL]             assertTrue(Modifier.isPublic(isEmptyMethod.getDeclaringClass().getModifiers())); [EOL]  [EOL]         try { [EOL]             isEmptyMethod.invoke(set, new Object[0]); [EOL]         } catch(final java.lang.IllegalAccessException iae) { [EOL]             fail("Should not have thrown IllegalAccessException"); [EOL]         } [EOL]  [EOL]         // Tests with a public Class [EOL]         final Method toStringMethod = ClassUtils.getPublicMethod(Object.class, "toString",  new Class[0]); [EOL]             assertEquals(Object.class.getMethod("toString", new Class[0]), toStringMethod); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetPublicMethod() throws Exception { [EOL]         // Tests with Collections$UnmodifiableSet [EOL]         final Set<?> set = Collections.unmodifiableSet(new HashSet<Object>()); [EOL]         final Method isEmptyMethod = ClassUtils.getPublicMethod(set.getClass(), "isEmpty",  new Class[0]); [EOL]             assertTrue(Modifier.isPublic(isEmptyMethod.getDeclaringClass().getModifiers())); [EOL]  [EOL]         try { [EOL]             isEmptyMethod.invoke(set, new Object[0]); [EOL]         } catch(final java.lang.IllegalAccessException iae) { [EOL]             fail("Should not have thrown IllegalAccessException"); [EOL]         } [EOL]  [EOL]         // Tests with a public Class [EOL]         final Method toStringMethod = ClassUtils.getPublicMethod(Object.class, "toString",  new Class[0]); [EOL]             assertEquals(Object.class.getMethod("toString", new Class[0]), toStringMethod); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetPublicMethod() throws Exception { [EOL]         // Tests with Collections$UnmodifiableSet [EOL]         final Set<?> set = Collections.unmodifiableSet(new HashSet<Object>()); [EOL]         final Method isEmptyMethod = ClassUtils.getPublicMethod(set.getClass(), "isEmpty",  new Class[0]); [EOL]             assertTrue(Modifier.isPublic(isEmptyMethod.getDeclaringClass().getModifiers())); [EOL]  [EOL]         try { [EOL]             isEmptyMethod.invoke(set, new Object[0]); [EOL]         } catch(final java.lang.IllegalAccessException iae) { [EOL]             fail("Should not have thrown IllegalAccessException"); [EOL]         } [EOL]  [EOL]         // Tests with a public Class [EOL]         final Method toStringMethod = ClassUtils.getPublicMethod(Object.class, "toString",  new Class[0]); [EOL]             assertEquals(Object.class.getMethod("toString", new Class[0]), toStringMethod); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetPublicMethod() throws Exception { [EOL]         // Tests with Collections$UnmodifiableSet [EOL]         final Set<?> set = Collections.unmodifiableSet(new HashSet<Object>()); [EOL]         final Method isEmptyMethod = ClassUtils.getPublicMethod(set.getClass(), "isEmpty",  new Class[0]); [EOL]             assertTrue(Modifier.isPublic(isEmptyMethod.getDeclaringClass().getModifiers())); [EOL]  [EOL]         try { [EOL]             isEmptyMethod.invoke(set, new Object[0]); [EOL]         } catch(final java.lang.IllegalAccessException iae) { [EOL]             fail("Should not have thrown IllegalAccessException"); [EOL]         } [EOL]  [EOL]         // Tests with a public Class [EOL]         final Method toStringMethod = ClassUtils.getPublicMethod(Object.class, "toString",  new Class[0]); [EOL]             assertEquals(Object.class.getMethod("toString", new Class[0]), toStringMethod); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetPublicMethod() throws Exception { [EOL]         // Tests with Collections$UnmodifiableSet [EOL]         final Set<?> set = Collections.unmodifiableSet(new HashSet<Object>()); [EOL]         final Method isEmptyMethod = ClassUtils.getPublicMethod(set.getClass(), "isEmpty",  new Class[0]); [EOL]             assertTrue(Modifier.isPublic(isEmptyMethod.getDeclaringClass().getModifiers())); [EOL]  [EOL]         try { [EOL]             isEmptyMethod.invoke(set, new Object[0]); [EOL]         } catch(final java.lang.IllegalAccessException iae) { [EOL]             fail("Should not have thrown IllegalAccessException"); [EOL]         } [EOL]  [EOL]         // Tests with a public Class [EOL]         final Method toStringMethod = ClassUtils.getPublicMethod(Object.class, "toString",  new Class[0]); [EOL]             assertEquals(Object.class.getMethod("toString", new Class[0]), toStringMethod); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetPublicMethod() throws Exception { [EOL]         // Tests with Collections$UnmodifiableSet [EOL]         final Set<?> set = Collections.unmodifiableSet(new HashSet<Object>()); [EOL]         final Method isEmptyMethod = ClassUtils.getPublicMethod(set.getClass(), "isEmpty",  new Class[0]); [EOL]             assertTrue(Modifier.isPublic(isEmptyMethod.getDeclaringClass().getModifiers())); [EOL]  [EOL]         try { [EOL]             isEmptyMethod.invoke(set, new Object[0]); [EOL]         } catch(final java.lang.IllegalAccessException iae) { [EOL]             fail("Should not have thrown IllegalAccessException"); [EOL]         } [EOL]  [EOL]         // Tests with a public Class [EOL]         final Method toStringMethod = ClassUtils.getPublicMethod(Object.class, "toString",  new Class[0]); [EOL]             assertEquals(Object.class.getMethod("toString", new Class[0]), toStringMethod); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetPublicMethod() throws Exception { [EOL]         // Tests with Collections$UnmodifiableSet [EOL]         final Set<?> set = Collections.unmodifiableSet(new HashSet<Object>()); [EOL]         final Method isEmptyMethod = ClassUtils.getPublicMethod(set.getClass(), "isEmpty",  new Class[0]); [EOL]             assertTrue(Modifier.isPublic(isEmptyMethod.getDeclaringClass().getModifiers())); [EOL]  [EOL]         try { [EOL]             isEmptyMethod.invoke(set, new Object[0]); [EOL]         } catch(final java.lang.IllegalAccessException iae) { [EOL]             fail("Should not have thrown IllegalAccessException"); [EOL]         } [EOL]  [EOL]         // Tests with a public Class [EOL]         final Method toStringMethod = ClassUtils.getPublicMethod(Object.class, "toString",  new Class[0]); [EOL]             assertEquals(Object.class.getMethod("toString", new Class[0]), toStringMethod); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetPublicMethod() throws Exception { [EOL]         // Tests with Collections$UnmodifiableSet [EOL]         final Set<?> set = Collections.unmodifiableSet(new HashSet<Object>()); [EOL]         final Method isEmptyMethod = ClassUtils.getPublicMethod(set.getClass(), "isEmpty",  new Class[0]); [EOL]             assertTrue(Modifier.isPublic(isEmptyMethod.getDeclaringClass().getModifiers())); [EOL]  [EOL]         try { [EOL]             isEmptyMethod.invoke(set, new Object[0]); [EOL]         } catch(final java.lang.IllegalAccessException iae) { [EOL]             fail("Should not have thrown IllegalAccessException"); [EOL]         } [EOL]  [EOL]         // Tests with a public Class [EOL]         final Method toStringMethod = ClassUtils.getPublicMethod(Object.class, "toString",  new Class[0]); [EOL]             assertEquals(Object.class.getMethod("toString", new Class[0]), toStringMethod); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetPublicMethod() throws Exception { [EOL]         // Tests with Collections$UnmodifiableSet [EOL]         final Set<?> set = Collections.unmodifiableSet(new HashSet<Object>()); [EOL]         final Method isEmptyMethod = ClassUtils.getPublicMethod(set.getClass(), "isEmpty",  new Class[0]); [EOL]             assertTrue(Modifier.isPublic(isEmptyMethod.getDeclaringClass().getModifiers())); [EOL]  [EOL]         try { [EOL]             isEmptyMethod.invoke(set, new Object[0]); [EOL]         } catch(final java.lang.IllegalAccessException iae) { [EOL]             fail("Should not have thrown IllegalAccessException"); [EOL]         } [EOL]  [EOL]         // Tests with a public Class [EOL]         final Method toStringMethod = ClassUtils.getPublicMethod(Object.class, "toString",  new Class[0]); [EOL]             assertEquals(Object.class.getMethod("toString", new Class[0]), toStringMethod); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetPublicMethod() throws Exception { [EOL]         // Tests with Collections$UnmodifiableSet [EOL]         final Set<?> set = Collections.unmodifiableSet(new HashSet<Object>()); [EOL]         final Method isEmptyMethod = ClassUtils.getPublicMethod(set.getClass(), "isEmpty",  new Class[0]); [EOL]             assertTrue(Modifier.isPublic(isEmptyMethod.getDeclaringClass().getModifiers())); [EOL]  [EOL]         try { [EOL]             isEmptyMethod.invoke(set, new Object[0]); [EOL]         } catch(final java.lang.IllegalAccessException iae) { [EOL]             fail("Should not have thrown IllegalAccessException"); [EOL]         } [EOL]  [EOL]         // Tests with a public Class [EOL]         final Method toStringMethod = ClassUtils.getPublicMethod(Object.class, "toString",  new Class[0]); [EOL]             assertEquals(Object.class.getMethod("toString", new Class[0]), toStringMethod); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetPublicMethod() throws Exception { [EOL]         // Tests with Collections$UnmodifiableSet [EOL]         final Set<?> set = Collections.unmodifiableSet(new HashSet<Object>()); [EOL]         final Method isEmptyMethod = ClassUtils.getPublicMethod(set.getClass(), "isEmpty",  new Class[0]); [EOL]             assertTrue(Modifier.isPublic(isEmptyMethod.getDeclaringClass().getModifiers())); [EOL]  [EOL]         try { [EOL]             isEmptyMethod.invoke(set, new Object[0]); [EOL]         } catch(final java.lang.IllegalAccessException iae) { [EOL]             fail("Should not have thrown IllegalAccessException"); [EOL]         } [EOL]  [EOL]         // Tests with a public Class [EOL]         final Method toStringMethod = ClassUtils.getPublicMethod(Object.class, "toString",  new Class[0]); [EOL]             assertEquals(Object.class.getMethod("toString", new Class[0]), toStringMethod); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetClassByNormalNameArrays2D() throws ClassNotFoundException { [EOL]         assertEquals( int[][].class, ClassUtils.getClass( "int[][]" ) ); [EOL]         assertEquals( long[][].class, ClassUtils.getClass( "long[][]" ) ); [EOL]         assertEquals( short[][].class, ClassUtils.getClass( "short[][]" ) ); [EOL]         assertEquals( byte[][].class, ClassUtils.getClass( "byte[][]" ) ); [EOL]         assertEquals( char[][].class, ClassUtils.getClass( "char[][]" ) ); [EOL]         assertEquals( float[][].class, ClassUtils.getClass( "float[][]" ) ); [EOL]         assertEquals( double[][].class, ClassUtils.getClass( "double[][]" ) ); [EOL]         assertEquals( boolean[][].class, ClassUtils.getClass( "boolean[][]" ) ); [EOL]         assertEquals( String[][].class, ClassUtils.getClass( "java.lang.String[][]" ) ); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void test_getShortCanonicalName_String() { [EOL]         assertEquals("ClassUtils", ClassUtils.getShortCanonicalName("org.apache.commons.lang3.ClassUtils")); [EOL]         assertEquals("ClassUtils[]", ClassUtils.getShortCanonicalName("[Lorg.apache.commons.lang3.ClassUtils;")); [EOL]         assertEquals("ClassUtils[][]", ClassUtils.getShortCanonicalName("[[Lorg.apache.commons.lang3.ClassUtils;")); [EOL]         assertEquals("ClassUtils[]", ClassUtils.getShortCanonicalName("org.apache.commons.lang3.ClassUtils[]")); [EOL]         assertEquals("ClassUtils[][]", ClassUtils.getShortCanonicalName("org.apache.commons.lang3.ClassUtils[][]")); [EOL]         assertEquals("int[]", ClassUtils.getShortCanonicalName("[I")); [EOL]         assertEquals("int[][]", ClassUtils.getShortCanonicalName("[[I")); [EOL]         assertEquals("int[]", ClassUtils.getShortCanonicalName("int[]")); [EOL]         assertEquals("int[][]", ClassUtils.getShortCanonicalName("int[][]")); [EOL]          [EOL]         // Inner types [EOL]         assertEquals("ClassUtilsTest.6", ClassUtils.getShortCanonicalName("org.apache.commons.lang3.ClassUtilsTest$6")); [EOL]         assertEquals("ClassUtilsTest.5Named", ClassUtils.getShortCanonicalName("org.apache.commons.lang3.ClassUtilsTest$5Named")); [EOL]         assertEquals("ClassUtilsTest.Inner", ClassUtils.getShortCanonicalName("org.apache.commons.lang3.ClassUtilsTest$Inner")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void test_getShortCanonicalName_String() { [EOL]         assertEquals("ClassUtils", ClassUtils.getShortCanonicalName("org.apache.commons.lang3.ClassUtils")); [EOL]         assertEquals("ClassUtils[]", ClassUtils.getShortCanonicalName("[Lorg.apache.commons.lang3.ClassUtils;")); [EOL]         assertEquals("ClassUtils[][]", ClassUtils.getShortCanonicalName("[[Lorg.apache.commons.lang3.ClassUtils;")); [EOL]         assertEquals("ClassUtils[]", ClassUtils.getShortCanonicalName("org.apache.commons.lang3.ClassUtils[]")); [EOL]         assertEquals("ClassUtils[][]", ClassUtils.getShortCanonicalName("org.apache.commons.lang3.ClassUtils[][]")); [EOL]         assertEquals("int[]", ClassUtils.getShortCanonicalName("[I")); [EOL]         assertEquals("int[][]", ClassUtils.getShortCanonicalName("[[I")); [EOL]         assertEquals("int[]", ClassUtils.getShortCanonicalName("int[]")); [EOL]         assertEquals("int[][]", ClassUtils.getShortCanonicalName("int[][]")); [EOL]          [EOL]         // Inner types [EOL]         assertEquals("ClassUtilsTest.6", ClassUtils.getShortCanonicalName("org.apache.commons.lang3.ClassUtilsTest$6")); [EOL]         assertEquals("ClassUtilsTest.5Named", ClassUtils.getShortCanonicalName("org.apache.commons.lang3.ClassUtilsTest$5Named")); [EOL]         assertEquals("ClassUtilsTest.Inner", ClassUtils.getShortCanonicalName("org.apache.commons.lang3.ClassUtilsTest$Inner")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void test_getShortCanonicalName_String() { [EOL]         assertEquals("ClassUtils", ClassUtils.getShortCanonicalName("org.apache.commons.lang3.ClassUtils")); [EOL]         assertEquals("ClassUtils[]", ClassUtils.getShortCanonicalName("[Lorg.apache.commons.lang3.ClassUtils;")); [EOL]         assertEquals("ClassUtils[][]", ClassUtils.getShortCanonicalName("[[Lorg.apache.commons.lang3.ClassUtils;")); [EOL]         assertEquals("ClassUtils[]", ClassUtils.getShortCanonicalName("org.apache.commons.lang3.ClassUtils[]")); [EOL]         assertEquals("ClassUtils[][]", ClassUtils.getShortCanonicalName("org.apache.commons.lang3.ClassUtils[][]")); [EOL]         assertEquals("int[]", ClassUtils.getShortCanonicalName("[I")); [EOL]         assertEquals("int[][]", ClassUtils.getShortCanonicalName("[[I")); [EOL]         assertEquals("int[]", ClassUtils.getShortCanonicalName("int[]")); [EOL]         assertEquals("int[][]", ClassUtils.getShortCanonicalName("int[][]")); [EOL]          [EOL]         // Inner types [EOL]         assertEquals("ClassUtilsTest.6", ClassUtils.getShortCanonicalName("org.apache.commons.lang3.ClassUtilsTest$6")); [EOL]         assertEquals("ClassUtilsTest.5Named", ClassUtils.getShortCanonicalName("org.apache.commons.lang3.ClassUtilsTest$5Named")); [EOL]         assertEquals("ClassUtilsTest.Inner", ClassUtils.getShortCanonicalName("org.apache.commons.lang3.ClassUtilsTest$Inner")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void test_getShortCanonicalName_String() { [EOL]         assertEquals("ClassUtils", ClassUtils.getShortCanonicalName("org.apache.commons.lang3.ClassUtils")); [EOL]         assertEquals("ClassUtils[]", ClassUtils.getShortCanonicalName("[Lorg.apache.commons.lang3.ClassUtils;")); [EOL]         assertEquals("ClassUtils[][]", ClassUtils.getShortCanonicalName("[[Lorg.apache.commons.lang3.ClassUtils;")); [EOL]         assertEquals("ClassUtils[]", ClassUtils.getShortCanonicalName("org.apache.commons.lang3.ClassUtils[]")); [EOL]         assertEquals("ClassUtils[][]", ClassUtils.getShortCanonicalName("org.apache.commons.lang3.ClassUtils[][]")); [EOL]         assertEquals("int[]", ClassUtils.getShortCanonicalName("[I")); [EOL]         assertEquals("int[][]", ClassUtils.getShortCanonicalName("[[I")); [EOL]         assertEquals("int[]", ClassUtils.getShortCanonicalName("int[]")); [EOL]         assertEquals("int[][]", ClassUtils.getShortCanonicalName("int[][]")); [EOL]          [EOL]         // Inner types [EOL]         assertEquals("ClassUtilsTest.6", ClassUtils.getShortCanonicalName("org.apache.commons.lang3.ClassUtilsTest$6")); [EOL]         assertEquals("ClassUtilsTest.5Named", ClassUtils.getShortCanonicalName("org.apache.commons.lang3.ClassUtilsTest$5Named")); [EOL]         assertEquals("ClassUtilsTest.Inner", ClassUtils.getShortCanonicalName("org.apache.commons.lang3.ClassUtilsTest$Inner")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void test_getShortCanonicalName_String() { [EOL]         assertEquals("ClassUtils", ClassUtils.getShortCanonicalName("org.apache.commons.lang3.ClassUtils")); [EOL]         assertEquals("ClassUtils[]", ClassUtils.getShortCanonicalName("[Lorg.apache.commons.lang3.ClassUtils;")); [EOL]         assertEquals("ClassUtils[][]", ClassUtils.getShortCanonicalName("[[Lorg.apache.commons.lang3.ClassUtils;")); [EOL]         assertEquals("ClassUtils[]", ClassUtils.getShortCanonicalName("org.apache.commons.lang3.ClassUtils[]")); [EOL]         assertEquals("ClassUtils[][]", ClassUtils.getShortCanonicalName("org.apache.commons.lang3.ClassUtils[][]")); [EOL]         assertEquals("int[]", ClassUtils.getShortCanonicalName("[I")); [EOL]         assertEquals("int[][]", ClassUtils.getShortCanonicalName("[[I")); [EOL]         assertEquals("int[]", ClassUtils.getShortCanonicalName("int[]")); [EOL]         assertEquals("int[][]", ClassUtils.getShortCanonicalName("int[][]")); [EOL]          [EOL]         // Inner types [EOL]         assertEquals("ClassUtilsTest.6", ClassUtils.getShortCanonicalName("org.apache.commons.lang3.ClassUtilsTest$6")); [EOL]         assertEquals("ClassUtilsTest.5Named", ClassUtils.getShortCanonicalName("org.apache.commons.lang3.ClassUtilsTest$5Named")); [EOL]         assertEquals("ClassUtilsTest.Inner", ClassUtils.getShortCanonicalName("org.apache.commons.lang3.ClassUtilsTest$Inner")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void test_toBooleanObject_String() { [EOL]         assertEquals(null, BooleanUtils.toBooleanObject((String) null)); [EOL]         assertEquals(null, BooleanUtils.toBooleanObject("")); [EOL]         assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject("false")); [EOL]         assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject("no")); [EOL]         assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject("off")); [EOL]         assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject("FALSE")); [EOL]         assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject("NO")); [EOL]         assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject("OFF")); [EOL]         assertEquals(null, BooleanUtils.toBooleanObject("oof")); [EOL]         assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject("true")); [EOL]         assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject("yes")); [EOL]         assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject("on")); [EOL]         assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject("TRUE")); [EOL]         assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject("ON")); [EOL]         assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject("YES")); [EOL]         assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject("TruE")); [EOL]         assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject("TruE")); [EOL]  [EOL]         assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject("y")); // yes [EOL]         assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject("Y")); [EOL]         assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject("t")); // true [EOL]         assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject("T")); [EOL]         assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject("f")); // false [EOL]         assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject("F")); [EOL]         assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject("n")); // No [EOL]         assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject("N")); [EOL]         assertEquals(null, BooleanUtils.toBooleanObject("z")); [EOL]  [EOL]         assertEquals(null, BooleanUtils.toBooleanObject("ab")); [EOL]         assertEquals(null, BooleanUtils.toBooleanObject("yoo")); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void test_toBooleanObject_String() { [EOL]         assertEquals(null, BooleanUtils.toBooleanObject((String) null)); [EOL]         assertEquals(null, BooleanUtils.toBooleanObject("")); [EOL]         assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject("false")); [EOL]         assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject("no")); [EOL]         assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject("off")); [EOL]         assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject("FALSE")); [EOL]         assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject("NO")); [EOL]         assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject("OFF")); [EOL]         assertEquals(null, BooleanUtils.toBooleanObject("oof")); [EOL]         assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject("true")); [EOL]         assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject("yes")); [EOL]         assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject("on")); [EOL]         assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject("TRUE")); [EOL]         assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject("ON")); [EOL]         assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject("YES")); [EOL]         assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject("TruE")); [EOL]         assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject("TruE")); [EOL]  [EOL]         assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject("y")); // yes [EOL]         assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject("Y")); [EOL]         assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject("t")); // true [EOL]         assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject("T")); [EOL]         assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject("f")); // false [EOL]         assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject("F")); [EOL]         assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject("n")); // No [EOL]         assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject("N")); [EOL]         assertEquals(null, BooleanUtils.toBooleanObject("z")); [EOL]  [EOL]         assertEquals(null, BooleanUtils.toBooleanObject("ab")); [EOL]         assertEquals(null, BooleanUtils.toBooleanObject("yoo")); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void test_toBoolean_String_String_String() { [EOL]         assertTrue(BooleanUtils.toBoolean((String) null, null, "N")); [EOL]         assertFalse(BooleanUtils.toBoolean((String) null, "Y", null)); [EOL]         assertTrue(BooleanUtils.toBoolean("Y", "Y", "N")); [EOL]         assertTrue(BooleanUtils.toBoolean("Y", new String("Y"), new String("N"))); [EOL]         assertFalse(BooleanUtils.toBoolean("N", "Y", "N")); [EOL]         assertFalse(BooleanUtils.toBoolean("N", new String("Y"), new String("N"))); [EOL]         assertTrue(BooleanUtils.toBoolean((String) null, null, null)); [EOL]         assertTrue(BooleanUtils.toBoolean("Y", "Y", "Y")); [EOL]         assertTrue(BooleanUtils.toBoolean("Y", new String("Y"), new String("Y"))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void test_toBoolean_String_String_String() { [EOL]         assertTrue(BooleanUtils.toBoolean((String) null, null, "N")); [EOL]         assertFalse(BooleanUtils.toBoolean((String) null, "Y", null)); [EOL]         assertTrue(BooleanUtils.toBoolean("Y", "Y", "N")); [EOL]         assertTrue(BooleanUtils.toBoolean("Y", new String("Y"), new String("N"))); [EOL]         assertFalse(BooleanUtils.toBoolean("N", "Y", "N")); [EOL]         assertFalse(BooleanUtils.toBoolean("N", new String("Y"), new String("N"))); [EOL]         assertTrue(BooleanUtils.toBoolean((String) null, null, null)); [EOL]         assertTrue(BooleanUtils.toBoolean("Y", "Y", "Y")); [EOL]         assertTrue(BooleanUtils.toBoolean("Y", new String("Y"), new String("Y"))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSerialization() throws IOException, ClassNotFoundException, PropertyVetoException { [EOL]         final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); [EOL]         listenerSupport.addListener(new VetoableChangeListener() { [EOL]              [EOL]             @Override [EOL]             public void vetoableChange(final PropertyChangeEvent e) { [EOL]             } [EOL]         }); [EOL]         listenerSupport.addListener(EasyMock.createNiceMock(VetoableChangeListener.class)); [EOL]  [EOL]         //serialize: [EOL]         final ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); [EOL]         final ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream); [EOL]  [EOL]         objectOutputStream.writeObject(listenerSupport); [EOL]         objectOutputStream.close(); [EOL]  [EOL]         //deserialize: [EOL]         @SuppressWarnings("unchecked") [EOL]         final [EOL]         EventListenerSupport<VetoableChangeListener> deserializedListenerSupport = (EventListenerSupport<VetoableChangeListener>) new ObjectInputStream( [EOL]                 new ByteArrayInputStream(outputStream.toByteArray())).readObject(); [EOL]  [EOL]         //make sure we get a listener array back, of the correct component type, and that it contains only the serializable mock [EOL]         final VetoableChangeListener[] listeners = deserializedListenerSupport.getListeners(); [EOL]         assertEquals(VetoableChangeListener.class, listeners.getClass().getComponentType()); [EOL]         assertEquals(1, listeners.length); [EOL]  [EOL]         //now verify that the mock still receives events; we can infer that the proxy was correctly reconstituted [EOL]         final VetoableChangeListener listener = listeners[0]; [EOL]         final PropertyChangeEvent evt = new PropertyChangeEvent(new Date(), "Day", 7, 9); [EOL]         listener.vetoableChange(evt); [EOL]         EasyMock.replay(listener); [EOL]         deserializedListenerSupport.fire().vetoableChange(evt); [EOL]         EasyMock.verify(listener); [EOL]  [EOL]         //remove listener and verify we get an empty array of listeners [EOL]         deserializedListenerSupport.removeListener(listener); [EOL]         assertEquals(0, deserializedListenerSupport.getListeners().length); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSerialization() throws IOException, ClassNotFoundException, PropertyVetoException { [EOL]         final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); [EOL]         listenerSupport.addListener(new VetoableChangeListener() { [EOL]              [EOL]             @Override [EOL]             public void vetoableChange(final PropertyChangeEvent e) { [EOL]             } [EOL]         }); [EOL]         listenerSupport.addListener(EasyMock.createNiceMock(VetoableChangeListener.class)); [EOL]  [EOL]         //serialize: [EOL]         final ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); [EOL]         final ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream); [EOL]  [EOL]         objectOutputStream.writeObject(listenerSupport); [EOL]         objectOutputStream.close(); [EOL]  [EOL]         //deserialize: [EOL]         @SuppressWarnings("unchecked") [EOL]         final [EOL]         EventListenerSupport<VetoableChangeListener> deserializedListenerSupport = (EventListenerSupport<VetoableChangeListener>) new ObjectInputStream( [EOL]                 new ByteArrayInputStream(outputStream.toByteArray())).readObject(); [EOL]  [EOL]         //make sure we get a listener array back, of the correct component type, and that it contains only the serializable mock [EOL]         final VetoableChangeListener[] listeners = deserializedListenerSupport.getListeners(); [EOL]         assertEquals(VetoableChangeListener.class, listeners.getClass().getComponentType()); [EOL]         assertEquals(1, listeners.length); [EOL]  [EOL]         //now verify that the mock still receives events; we can infer that the proxy was correctly reconstituted [EOL]         final VetoableChangeListener listener = listeners[0]; [EOL]         final PropertyChangeEvent evt = new PropertyChangeEvent(new Date(), "Day", 7, 9); [EOL]         listener.vetoableChange(evt); [EOL]         EasyMock.replay(listener); [EOL]         deserializedListenerSupport.fire().vetoableChange(evt); [EOL]         EasyMock.verify(listener); [EOL]  [EOL]         //remove listener and verify we get an empty array of listeners [EOL]         deserializedListenerSupport.removeListener(listener); [EOL]         assertEquals(0, deserializedListenerSupport.getListeners().length); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSerialization() throws IOException, ClassNotFoundException, PropertyVetoException { [EOL]         final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); [EOL]         listenerSupport.addListener(new VetoableChangeListener() { [EOL]              [EOL]             @Override [EOL]             public void vetoableChange(final PropertyChangeEvent e) { [EOL]             } [EOL]         }); [EOL]         listenerSupport.addListener(EasyMock.createNiceMock(VetoableChangeListener.class)); [EOL]  [EOL]         //serialize: [EOL]         final ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); [EOL]         final ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream); [EOL]  [EOL]         objectOutputStream.writeObject(listenerSupport); [EOL]         objectOutputStream.close(); [EOL]  [EOL]         //deserialize: [EOL]         @SuppressWarnings("unchecked") [EOL]         final [EOL]         EventListenerSupport<VetoableChangeListener> deserializedListenerSupport = (EventListenerSupport<VetoableChangeListener>) new ObjectInputStream( [EOL]                 new ByteArrayInputStream(outputStream.toByteArray())).readObject(); [EOL]  [EOL]         //make sure we get a listener array back, of the correct component type, and that it contains only the serializable mock [EOL]         final VetoableChangeListener[] listeners = deserializedListenerSupport.getListeners(); [EOL]         assertEquals(VetoableChangeListener.class, listeners.getClass().getComponentType()); [EOL]         assertEquals(1, listeners.length); [EOL]  [EOL]         //now verify that the mock still receives events; we can infer that the proxy was correctly reconstituted [EOL]         final VetoableChangeListener listener = listeners[0]; [EOL]         final PropertyChangeEvent evt = new PropertyChangeEvent(new Date(), "Day", 7, 9); [EOL]         listener.vetoableChange(evt); [EOL]         EasyMock.replay(listener); [EOL]         deserializedListenerSupport.fire().vetoableChange(evt); [EOL]         EasyMock.verify(listener); [EOL]  [EOL]         //remove listener and verify we get an empty array of listeners [EOL]         deserializedListenerSupport.removeListener(listener); [EOL]         assertEquals(0, deserializedListenerSupport.getListeners().length); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSerialization() throws IOException, ClassNotFoundException, PropertyVetoException { [EOL]         final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); [EOL]         listenerSupport.addListener(new VetoableChangeListener() { [EOL]              [EOL]             @Override [EOL]             public void vetoableChange(final PropertyChangeEvent e) { [EOL]             } [EOL]         }); [EOL]         listenerSupport.addListener(EasyMock.createNiceMock(VetoableChangeListener.class)); [EOL]  [EOL]         //serialize: [EOL]         final ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); [EOL]         final ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream); [EOL]  [EOL]         objectOutputStream.writeObject(listenerSupport); [EOL]         objectOutputStream.close(); [EOL]  [EOL]         //deserialize: [EOL]         @SuppressWarnings("unchecked") [EOL]         final [EOL]         EventListenerSupport<VetoableChangeListener> deserializedListenerSupport = (EventListenerSupport<VetoableChangeListener>) new ObjectInputStream( [EOL]                 new ByteArrayInputStream(outputStream.toByteArray())).readObject(); [EOL]  [EOL]         //make sure we get a listener array back, of the correct component type, and that it contains only the serializable mock [EOL]         final VetoableChangeListener[] listeners = deserializedListenerSupport.getListeners(); [EOL]         assertEquals(VetoableChangeListener.class, listeners.getClass().getComponentType()); [EOL]         assertEquals(1, listeners.length); [EOL]  [EOL]         //now verify that the mock still receives events; we can infer that the proxy was correctly reconstituted [EOL]         final VetoableChangeListener listener = listeners[0]; [EOL]         final PropertyChangeEvent evt = new PropertyChangeEvent(new Date(), "Day", 7, 9); [EOL]         listener.vetoableChange(evt); [EOL]         EasyMock.replay(listener); [EOL]         deserializedListenerSupport.fire().vetoableChange(evt); [EOL]         EasyMock.verify(listener); [EOL]  [EOL]         //remove listener and verify we get an empty array of listeners [EOL]         deserializedListenerSupport.removeListener(listener); [EOL]         assertEquals(0, deserializedListenerSupport.getListeners().length); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSerialization() throws IOException, ClassNotFoundException, PropertyVetoException { [EOL]         final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); [EOL]         listenerSupport.addListener(new VetoableChangeListener() { [EOL]              [EOL]             @Override [EOL]             public void vetoableChange(final PropertyChangeEvent e) { [EOL]             } [EOL]         }); [EOL]         listenerSupport.addListener(EasyMock.createNiceMock(VetoableChangeListener.class)); [EOL]  [EOL]         //serialize: [EOL]         final ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); [EOL]         final ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream); [EOL]  [EOL]         objectOutputStream.writeObject(listenerSupport); [EOL]         objectOutputStream.close(); [EOL]  [EOL]         //deserialize: [EOL]         @SuppressWarnings("unchecked") [EOL]         final [EOL]         EventListenerSupport<VetoableChangeListener> deserializedListenerSupport = (EventListenerSupport<VetoableChangeListener>) new ObjectInputStream( [EOL]                 new ByteArrayInputStream(outputStream.toByteArray())).readObject(); [EOL]  [EOL]         //make sure we get a listener array back, of the correct component type, and that it contains only the serializable mock [EOL]         final VetoableChangeListener[] listeners = deserializedListenerSupport.getListeners(); [EOL]         assertEquals(VetoableChangeListener.class, listeners.getClass().getComponentType()); [EOL]         assertEquals(1, listeners.length); [EOL]  [EOL]         //now verify that the mock still receives events; we can infer that the proxy was correctly reconstituted [EOL]         final VetoableChangeListener listener = listeners[0]; [EOL]         final PropertyChangeEvent evt = new PropertyChangeEvent(new Date(), "Day", 7, 9); [EOL]         listener.vetoableChange(evt); [EOL]         EasyMock.replay(listener); [EOL]         deserializedListenerSupport.fire().vetoableChange(evt); [EOL]         EasyMock.verify(listener); [EOL]  [EOL]         //remove listener and verify we get an empty array of listeners [EOL]         deserializedListenerSupport.removeListener(listener); [EOL]         assertEquals(0, deserializedListenerSupport.getListeners().length); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSerialization() throws IOException, ClassNotFoundException, PropertyVetoException { [EOL]         final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); [EOL]         listenerSupport.addListener(new VetoableChangeListener() { [EOL]              [EOL]             @Override [EOL]             public void vetoableChange(final PropertyChangeEvent e) { [EOL]             } [EOL]         }); [EOL]         listenerSupport.addListener(EasyMock.createNiceMock(VetoableChangeListener.class)); [EOL]  [EOL]         //serialize: [EOL]         final ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); [EOL]         final ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream); [EOL]  [EOL]         objectOutputStream.writeObject(listenerSupport); [EOL]         objectOutputStream.close(); [EOL]  [EOL]         //deserialize: [EOL]         @SuppressWarnings("unchecked") [EOL]         final [EOL]         EventListenerSupport<VetoableChangeListener> deserializedListenerSupport = (EventListenerSupport<VetoableChangeListener>) new ObjectInputStream( [EOL]                 new ByteArrayInputStream(outputStream.toByteArray())).readObject(); [EOL]  [EOL]         //make sure we get a listener array back, of the correct component type, and that it contains only the serializable mock [EOL]         final VetoableChangeListener[] listeners = deserializedListenerSupport.getListeners(); [EOL]         assertEquals(VetoableChangeListener.class, listeners.getClass().getComponentType()); [EOL]         assertEquals(1, listeners.length); [EOL]  [EOL]         //now verify that the mock still receives events; we can infer that the proxy was correctly reconstituted [EOL]         final VetoableChangeListener listener = listeners[0]; [EOL]         final PropertyChangeEvent evt = new PropertyChangeEvent(new Date(), "Day", 7, 9); [EOL]         listener.vetoableChange(evt); [EOL]         EasyMock.replay(listener); [EOL]         deserializedListenerSupport.fire().vetoableChange(evt); [EOL]         EasyMock.verify(listener); [EOL]  [EOL]         //remove listener and verify we get an empty array of listeners [EOL]         deserializedListenerSupport.removeListener(listener); [EOL]         assertEquals(0, deserializedListenerSupport.getListeners().length); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSerialization() throws IOException, ClassNotFoundException, PropertyVetoException { [EOL]         final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); [EOL]         listenerSupport.addListener(new VetoableChangeListener() { [EOL]              [EOL]             @Override [EOL]             public void vetoableChange(final PropertyChangeEvent e) { [EOL]             } [EOL]         }); [EOL]         listenerSupport.addListener(EasyMock.createNiceMock(VetoableChangeListener.class)); [EOL]  [EOL]         //serialize: [EOL]         final ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); [EOL]         final ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream); [EOL]  [EOL]         objectOutputStream.writeObject(listenerSupport); [EOL]         objectOutputStream.close(); [EOL]  [EOL]         //deserialize: [EOL]         @SuppressWarnings("unchecked") [EOL]         final [EOL]         EventListenerSupport<VetoableChangeListener> deserializedListenerSupport = (EventListenerSupport<VetoableChangeListener>) new ObjectInputStream( [EOL]                 new ByteArrayInputStream(outputStream.toByteArray())).readObject(); [EOL]  [EOL]         //make sure we get a listener array back, of the correct component type, and that it contains only the serializable mock [EOL]         final VetoableChangeListener[] listeners = deserializedListenerSupport.getListeners(); [EOL]         assertEquals(VetoableChangeListener.class, listeners.getClass().getComponentType()); [EOL]         assertEquals(1, listeners.length); [EOL]  [EOL]         //now verify that the mock still receives events; we can infer that the proxy was correctly reconstituted [EOL]         final VetoableChangeListener listener = listeners[0]; [EOL]         final PropertyChangeEvent evt = new PropertyChangeEvent(new Date(), "Day", 7, 9); [EOL]         listener.vetoableChange(evt); [EOL]         EasyMock.replay(listener); [EOL]         deserializedListenerSupport.fire().vetoableChange(evt); [EOL]         EasyMock.verify(listener); [EOL]  [EOL]         //remove listener and verify we get an empty array of listeners [EOL]         deserializedListenerSupport.removeListener(listener); [EOL]         assertEquals(0, deserializedListenerSupport.getListeners().length); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSerialization() throws IOException, ClassNotFoundException, PropertyVetoException { [EOL]         final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); [EOL]         listenerSupport.addListener(new VetoableChangeListener() { [EOL]              [EOL]             @Override [EOL]             public void vetoableChange(final PropertyChangeEvent e) { [EOL]             } [EOL]         }); [EOL]         listenerSupport.addListener(EasyMock.createNiceMock(VetoableChangeListener.class)); [EOL]  [EOL]         //serialize: [EOL]         final ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); [EOL]         final ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream); [EOL]  [EOL]         objectOutputStream.writeObject(listenerSupport); [EOL]         objectOutputStream.close(); [EOL]  [EOL]         //deserialize: [EOL]         @SuppressWarnings("unchecked") [EOL]         final [EOL]         EventListenerSupport<VetoableChangeListener> deserializedListenerSupport = (EventListenerSupport<VetoableChangeListener>) new ObjectInputStream( [EOL]                 new ByteArrayInputStream(outputStream.toByteArray())).readObject(); [EOL]  [EOL]         //make sure we get a listener array back, of the correct component type, and that it contains only the serializable mock [EOL]         final VetoableChangeListener[] listeners = deserializedListenerSupport.getListeners(); [EOL]         assertEquals(VetoableChangeListener.class, listeners.getClass().getComponentType()); [EOL]         assertEquals(1, listeners.length); [EOL]  [EOL]         //now verify that the mock still receives events; we can infer that the proxy was correctly reconstituted [EOL]         final VetoableChangeListener listener = listeners[0]; [EOL]         final PropertyChangeEvent evt = new PropertyChangeEvent(new Date(), "Day", 7, 9); [EOL]         listener.vetoableChange(evt); [EOL]         EasyMock.replay(listener); [EOL]         deserializedListenerSupport.fire().vetoableChange(evt); [EOL]         EasyMock.verify(listener); [EOL]  [EOL]         //remove listener and verify we get an empty array of listeners [EOL]         deserializedListenerSupport.removeListener(listener); [EOL]         assertEquals(0, deserializedListenerSupport.getListeners().length); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testRemoveListenerDuringEvent() throws PropertyVetoException [EOL]     { [EOL]         final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); [EOL]         for (int i = 0; i < 10; ++i) [EOL]         { [EOL]             addDeregisterListener(listenerSupport); [EOL]         } [EOL]         assertEquals(listenerSupport.getListenerCount(), 10); [EOL]         listenerSupport.fire().vetoableChange(new PropertyChangeEvent(new Date(), "Day", 4, 5)); [EOL]         assertEquals(listenerSupport.getListenerCount(), 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testRemoveListenerDuringEvent() throws PropertyVetoException [EOL]     { [EOL]         final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); [EOL]         for (int i = 0; i < 10; ++i) [EOL]         { [EOL]             addDeregisterListener(listenerSupport); [EOL]         } [EOL]         assertEquals(listenerSupport.getListenerCount(), 10); [EOL]         listenerSupport.fire().vetoableChange(new PropertyChangeEvent(new Date(), "Day", 4, 5)); [EOL]         assertEquals(listenerSupport.getListenerCount(), 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSerialization() throws IOException, ClassNotFoundException, PropertyVetoException { [EOL]         final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); [EOL]         listenerSupport.addListener(new VetoableChangeListener() { [EOL]              [EOL]             @Override [EOL]             public void vetoableChange(final PropertyChangeEvent e) { [EOL]             } [EOL]         }); [EOL]         listenerSupport.addListener(EasyMock.createNiceMock(VetoableChangeListener.class)); [EOL]  [EOL]         //serialize: [EOL]         final ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); [EOL]         final ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream); [EOL]  [EOL]         objectOutputStream.writeObject(listenerSupport); [EOL]         objectOutputStream.close(); [EOL]  [EOL]         //deserialize: [EOL]         @SuppressWarnings("unchecked") [EOL]         final [EOL]         EventListenerSupport<VetoableChangeListener> deserializedListenerSupport = (EventListenerSupport<VetoableChangeListener>) new ObjectInputStream( [EOL]                 new ByteArrayInputStream(outputStream.toByteArray())).readObject(); [EOL]  [EOL]         //make sure we get a listener array back, of the correct component type, and that it contains only the serializable mock [EOL]         final VetoableChangeListener[] listeners = deserializedListenerSupport.getListeners(); [EOL]         assertEquals(VetoableChangeListener.class, listeners.getClass().getComponentType()); [EOL]         assertEquals(1, listeners.length); [EOL]  [EOL]         //now verify that the mock still receives events; we can infer that the proxy was correctly reconstituted [EOL]         final VetoableChangeListener listener = listeners[0]; [EOL]         final PropertyChangeEvent evt = new PropertyChangeEvent(new Date(), "Day", 7, 9); [EOL]         listener.vetoableChange(evt); [EOL]         EasyMock.replay(listener); [EOL]         deserializedListenerSupport.fire().vetoableChange(evt); [EOL]         EasyMock.verify(listener); [EOL]  [EOL]         //remove listener and verify we get an empty array of listeners [EOL]         deserializedListenerSupport.removeListener(listener); [EOL]         assertEquals(0, deserializedListenerSupport.getListeners().length); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSerialization() throws IOException, ClassNotFoundException, PropertyVetoException { [EOL]         final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); [EOL]         listenerSupport.addListener(new VetoableChangeListener() { [EOL]              [EOL]             @Override [EOL]             public void vetoableChange(final PropertyChangeEvent e) { [EOL]             } [EOL]         }); [EOL]         listenerSupport.addListener(EasyMock.createNiceMock(VetoableChangeListener.class)); [EOL]  [EOL]         //serialize: [EOL]         final ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); [EOL]         final ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream); [EOL]  [EOL]         objectOutputStream.writeObject(listenerSupport); [EOL]         objectOutputStream.close(); [EOL]  [EOL]         //deserialize: [EOL]         @SuppressWarnings("unchecked") [EOL]         final [EOL]         EventListenerSupport<VetoableChangeListener> deserializedListenerSupport = (EventListenerSupport<VetoableChangeListener>) new ObjectInputStream( [EOL]                 new ByteArrayInputStream(outputStream.toByteArray())).readObject(); [EOL]  [EOL]         //make sure we get a listener array back, of the correct component type, and that it contains only the serializable mock [EOL]         final VetoableChangeListener[] listeners = deserializedListenerSupport.getListeners(); [EOL]         assertEquals(VetoableChangeListener.class, listeners.getClass().getComponentType()); [EOL]         assertEquals(1, listeners.length); [EOL]  [EOL]         //now verify that the mock still receives events; we can infer that the proxy was correctly reconstituted [EOL]         final VetoableChangeListener listener = listeners[0]; [EOL]         final PropertyChangeEvent evt = new PropertyChangeEvent(new Date(), "Day", 7, 9); [EOL]         listener.vetoableChange(evt); [EOL]         EasyMock.replay(listener); [EOL]         deserializedListenerSupport.fire().vetoableChange(evt); [EOL]         EasyMock.verify(listener); [EOL]  [EOL]         //remove listener and verify we get an empty array of listeners [EOL]         deserializedListenerSupport.removeListener(listener); [EOL]         assertEquals(0, deserializedListenerSupport.getListeners().length); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSerialization() throws IOException, ClassNotFoundException, PropertyVetoException { [EOL]         final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); [EOL]         listenerSupport.addListener(new VetoableChangeListener() { [EOL]              [EOL]             @Override [EOL]             public void vetoableChange(final PropertyChangeEvent e) { [EOL]             } [EOL]         }); [EOL]         listenerSupport.addListener(EasyMock.createNiceMock(VetoableChangeListener.class)); [EOL]  [EOL]         //serialize: [EOL]         final ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); [EOL]         final ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream); [EOL]  [EOL]         objectOutputStream.writeObject(listenerSupport); [EOL]         objectOutputStream.close(); [EOL]  [EOL]         //deserialize: [EOL]         @SuppressWarnings("unchecked") [EOL]         final [EOL]         EventListenerSupport<VetoableChangeListener> deserializedListenerSupport = (EventListenerSupport<VetoableChangeListener>) new ObjectInputStream( [EOL]                 new ByteArrayInputStream(outputStream.toByteArray())).readObject(); [EOL]  [EOL]         //make sure we get a listener array back, of the correct component type, and that it contains only the serializable mock [EOL]         final VetoableChangeListener[] listeners = deserializedListenerSupport.getListeners(); [EOL]         assertEquals(VetoableChangeListener.class, listeners.getClass().getComponentType()); [EOL]         assertEquals(1, listeners.length); [EOL]  [EOL]         //now verify that the mock still receives events; we can infer that the proxy was correctly reconstituted [EOL]         final VetoableChangeListener listener = listeners[0]; [EOL]         final PropertyChangeEvent evt = new PropertyChangeEvent(new Date(), "Day", 7, 9); [EOL]         listener.vetoableChange(evt); [EOL]         EasyMock.replay(listener); [EOL]         deserializedListenerSupport.fire().vetoableChange(evt); [EOL]         EasyMock.verify(listener); [EOL]  [EOL]         //remove listener and verify we get an empty array of listeners [EOL]         deserializedListenerSupport.removeListener(listener); [EOL]         assertEquals(0, deserializedListenerSupport.getListeners().length); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSerialization() throws IOException, ClassNotFoundException, PropertyVetoException { [EOL]         final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); [EOL]         listenerSupport.addListener(new VetoableChangeListener() { [EOL]              [EOL]             @Override [EOL]             public void vetoableChange(final PropertyChangeEvent e) { [EOL]             } [EOL]         }); [EOL]         listenerSupport.addListener(EasyMock.createNiceMock(VetoableChangeListener.class)); [EOL]  [EOL]         //serialize: [EOL]         final ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); [EOL]         final ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream); [EOL]  [EOL]         objectOutputStream.writeObject(listenerSupport); [EOL]         objectOutputStream.close(); [EOL]  [EOL]         //deserialize: [EOL]         @SuppressWarnings("unchecked") [EOL]         final [EOL]         EventListenerSupport<VetoableChangeListener> deserializedListenerSupport = (EventListenerSupport<VetoableChangeListener>) new ObjectInputStream( [EOL]                 new ByteArrayInputStream(outputStream.toByteArray())).readObject(); [EOL]  [EOL]         //make sure we get a listener array back, of the correct component type, and that it contains only the serializable mock [EOL]         final VetoableChangeListener[] listeners = deserializedListenerSupport.getListeners(); [EOL]         assertEquals(VetoableChangeListener.class, listeners.getClass().getComponentType()); [EOL]         assertEquals(1, listeners.length); [EOL]  [EOL]         //now verify that the mock still receives events; we can infer that the proxy was correctly reconstituted [EOL]         final VetoableChangeListener listener = listeners[0]; [EOL]         final PropertyChangeEvent evt = new PropertyChangeEvent(new Date(), "Day", 7, 9); [EOL]         listener.vetoableChange(evt); [EOL]         EasyMock.replay(listener); [EOL]         deserializedListenerSupport.fire().vetoableChange(evt); [EOL]         EasyMock.verify(listener); [EOL]  [EOL]         //remove listener and verify we get an empty array of listeners [EOL]         deserializedListenerSupport.removeListener(listener); [EOL]         assertEquals(0, deserializedListenerSupport.getListeners().length); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSerialization() throws IOException, ClassNotFoundException, PropertyVetoException { [EOL]         final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); [EOL]         listenerSupport.addListener(new VetoableChangeListener() { [EOL]              [EOL]             @Override [EOL]             public void vetoableChange(final PropertyChangeEvent e) { [EOL]             } [EOL]         }); [EOL]         listenerSupport.addListener(EasyMock.createNiceMock(VetoableChangeListener.class)); [EOL]  [EOL]         //serialize: [EOL]         final ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); [EOL]         final ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream); [EOL]  [EOL]         objectOutputStream.writeObject(listenerSupport); [EOL]         objectOutputStream.close(); [EOL]  [EOL]         //deserialize: [EOL]         @SuppressWarnings("unchecked") [EOL]         final [EOL]         EventListenerSupport<VetoableChangeListener> deserializedListenerSupport = (EventListenerSupport<VetoableChangeListener>) new ObjectInputStream( [EOL]                 new ByteArrayInputStream(outputStream.toByteArray())).readObject(); [EOL]  [EOL]         //make sure we get a listener array back, of the correct component type, and that it contains only the serializable mock [EOL]         final VetoableChangeListener[] listeners = deserializedListenerSupport.getListeners(); [EOL]         assertEquals(VetoableChangeListener.class, listeners.getClass().getComponentType()); [EOL]         assertEquals(1, listeners.length); [EOL]  [EOL]         //now verify that the mock still receives events; we can infer that the proxy was correctly reconstituted [EOL]         final VetoableChangeListener listener = listeners[0]; [EOL]         final PropertyChangeEvent evt = new PropertyChangeEvent(new Date(), "Day", 7, 9); [EOL]         listener.vetoableChange(evt); [EOL]         EasyMock.replay(listener); [EOL]         deserializedListenerSupport.fire().vetoableChange(evt); [EOL]         EasyMock.verify(listener); [EOL]  [EOL]         //remove listener and verify we get an empty array of listeners [EOL]         deserializedListenerSupport.removeListener(listener); [EOL]         assertEquals(0, deserializedListenerSupport.getListeners().length); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSerialization() throws IOException, ClassNotFoundException, PropertyVetoException { [EOL]         final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); [EOL]         listenerSupport.addListener(new VetoableChangeListener() { [EOL]              [EOL]             @Override [EOL]             public void vetoableChange(final PropertyChangeEvent e) { [EOL]             } [EOL]         }); [EOL]         listenerSupport.addListener(EasyMock.createNiceMock(VetoableChangeListener.class)); [EOL]  [EOL]         //serialize: [EOL]         final ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); [EOL]         final ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream); [EOL]  [EOL]         objectOutputStream.writeObject(listenerSupport); [EOL]         objectOutputStream.close(); [EOL]  [EOL]         //deserialize: [EOL]         @SuppressWarnings("unchecked") [EOL]         final [EOL]         EventListenerSupport<VetoableChangeListener> deserializedListenerSupport = (EventListenerSupport<VetoableChangeListener>) new ObjectInputStream( [EOL]                 new ByteArrayInputStream(outputStream.toByteArray())).readObject(); [EOL]  [EOL]         //make sure we get a listener array back, of the correct component type, and that it contains only the serializable mock [EOL]         final VetoableChangeListener[] listeners = deserializedListenerSupport.getListeners(); [EOL]         assertEquals(VetoableChangeListener.class, listeners.getClass().getComponentType()); [EOL]         assertEquals(1, listeners.length); [EOL]  [EOL]         //now verify that the mock still receives events; we can infer that the proxy was correctly reconstituted [EOL]         final VetoableChangeListener listener = listeners[0]; [EOL]         final PropertyChangeEvent evt = new PropertyChangeEvent(new Date(), "Day", 7, 9); [EOL]         listener.vetoableChange(evt); [EOL]         EasyMock.replay(listener); [EOL]         deserializedListenerSupport.fire().vetoableChange(evt); [EOL]         EasyMock.verify(listener); [EOL]  [EOL]         //remove listener and verify we get an empty array of listeners [EOL]         deserializedListenerSupport.removeListener(listener); [EOL]         assertEquals(0, deserializedListenerSupport.getListeners().length); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSerialization() throws IOException, ClassNotFoundException, PropertyVetoException { [EOL]         final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); [EOL]         listenerSupport.addListener(new VetoableChangeListener() { [EOL]              [EOL]             @Override [EOL]             public void vetoableChange(final PropertyChangeEvent e) { [EOL]             } [EOL]         }); [EOL]         listenerSupport.addListener(EasyMock.createNiceMock(VetoableChangeListener.class)); [EOL]  [EOL]         //serialize: [EOL]         final ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); [EOL]         final ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream); [EOL]  [EOL]         objectOutputStream.writeObject(listenerSupport); [EOL]         objectOutputStream.close(); [EOL]  [EOL]         //deserialize: [EOL]         @SuppressWarnings("unchecked") [EOL]         final [EOL]         EventListenerSupport<VetoableChangeListener> deserializedListenerSupport = (EventListenerSupport<VetoableChangeListener>) new ObjectInputStream( [EOL]                 new ByteArrayInputStream(outputStream.toByteArray())).readObject(); [EOL]  [EOL]         //make sure we get a listener array back, of the correct component type, and that it contains only the serializable mock [EOL]         final VetoableChangeListener[] listeners = deserializedListenerSupport.getListeners(); [EOL]         assertEquals(VetoableChangeListener.class, listeners.getClass().getComponentType()); [EOL]         assertEquals(1, listeners.length); [EOL]  [EOL]         //now verify that the mock still receives events; we can infer that the proxy was correctly reconstituted [EOL]         final VetoableChangeListener listener = listeners[0]; [EOL]         final PropertyChangeEvent evt = new PropertyChangeEvent(new Date(), "Day", 7, 9); [EOL]         listener.vetoableChange(evt); [EOL]         EasyMock.replay(listener); [EOL]         deserializedListenerSupport.fire().vetoableChange(evt); [EOL]         EasyMock.verify(listener); [EOL]  [EOL]         //remove listener and verify we get an empty array of listeners [EOL]         deserializedListenerSupport.removeListener(listener); [EOL]         assertEquals(0, deserializedListenerSupport.getListeners().length); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSerialization() throws IOException, ClassNotFoundException, PropertyVetoException { [EOL]         final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); [EOL]         listenerSupport.addListener(new VetoableChangeListener() { [EOL]              [EOL]             @Override [EOL]             public void vetoableChange(final PropertyChangeEvent e) { [EOL]             } [EOL]         }); [EOL]         listenerSupport.addListener(EasyMock.createNiceMock(VetoableChangeListener.class)); [EOL]  [EOL]         //serialize: [EOL]         final ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); [EOL]         final ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream); [EOL]  [EOL]         objectOutputStream.writeObject(listenerSupport); [EOL]         objectOutputStream.close(); [EOL]  [EOL]         //deserialize: [EOL]         @SuppressWarnings("unchecked") [EOL]         final [EOL]         EventListenerSupport<VetoableChangeListener> deserializedListenerSupport = (EventListenerSupport<VetoableChangeListener>) new ObjectInputStream( [EOL]                 new ByteArrayInputStream(outputStream.toByteArray())).readObject(); [EOL]  [EOL]         //make sure we get a listener array back, of the correct component type, and that it contains only the serializable mock [EOL]         final VetoableChangeListener[] listeners = deserializedListenerSupport.getListeners(); [EOL]         assertEquals(VetoableChangeListener.class, listeners.getClass().getComponentType()); [EOL]         assertEquals(1, listeners.length); [EOL]  [EOL]         //now verify that the mock still receives events; we can infer that the proxy was correctly reconstituted [EOL]         final VetoableChangeListener listener = listeners[0]; [EOL]         final PropertyChangeEvent evt = new PropertyChangeEvent(new Date(), "Day", 7, 9); [EOL]         listener.vetoableChange(evt); [EOL]         EasyMock.replay(listener); [EOL]         deserializedListenerSupport.fire().vetoableChange(evt); [EOL]         EasyMock.verify(listener); [EOL]  [EOL]         //remove listener and verify we get an empty array of listeners [EOL]         deserializedListenerSupport.removeListener(listener); [EOL]         assertEquals(0, deserializedListenerSupport.getListeners().length); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSerialization() throws IOException, ClassNotFoundException, PropertyVetoException { [EOL]         final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); [EOL]         listenerSupport.addListener(new VetoableChangeListener() { [EOL]              [EOL]             @Override [EOL]             public void vetoableChange(final PropertyChangeEvent e) { [EOL]             } [EOL]         }); [EOL]         listenerSupport.addListener(EasyMock.createNiceMock(VetoableChangeListener.class)); [EOL]  [EOL]         //serialize: [EOL]         final ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); [EOL]         final ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream); [EOL]  [EOL]         objectOutputStream.writeObject(listenerSupport); [EOL]         objectOutputStream.close(); [EOL]  [EOL]         //deserialize: [EOL]         @SuppressWarnings("unchecked") [EOL]         final [EOL]         EventListenerSupport<VetoableChangeListener> deserializedListenerSupport = (EventListenerSupport<VetoableChangeListener>) new ObjectInputStream( [EOL]                 new ByteArrayInputStream(outputStream.toByteArray())).readObject(); [EOL]  [EOL]         //make sure we get a listener array back, of the correct component type, and that it contains only the serializable mock [EOL]         final VetoableChangeListener[] listeners = deserializedListenerSupport.getListeners(); [EOL]         assertEquals(VetoableChangeListener.class, listeners.getClass().getComponentType()); [EOL]         assertEquals(1, listeners.length); [EOL]  [EOL]         //now verify that the mock still receives events; we can infer that the proxy was correctly reconstituted [EOL]         final VetoableChangeListener listener = listeners[0]; [EOL]         final PropertyChangeEvent evt = new PropertyChangeEvent(new Date(), "Day", 7, 9); [EOL]         listener.vetoableChange(evt); [EOL]         EasyMock.replay(listener); [EOL]         deserializedListenerSupport.fire().vetoableChange(evt); [EOL]         EasyMock.verify(listener); [EOL]  [EOL]         //remove listener and verify we get an empty array of listeners [EOL]         deserializedListenerSupport.removeListener(listener); [EOL]         assertEquals(0, deserializedListenerSupport.getListeners().length); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSerialization() throws IOException, ClassNotFoundException, PropertyVetoException { [EOL]         final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); [EOL]         listenerSupport.addListener(new VetoableChangeListener() { [EOL]              [EOL]             @Override [EOL]             public void vetoableChange(final PropertyChangeEvent e) { [EOL]             } [EOL]         }); [EOL]         listenerSupport.addListener(EasyMock.createNiceMock(VetoableChangeListener.class)); [EOL]  [EOL]         //serialize: [EOL]         final ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); [EOL]         final ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream); [EOL]  [EOL]         objectOutputStream.writeObject(listenerSupport); [EOL]         objectOutputStream.close(); [EOL]  [EOL]         //deserialize: [EOL]         @SuppressWarnings("unchecked") [EOL]         final [EOL]         EventListenerSupport<VetoableChangeListener> deserializedListenerSupport = (EventListenerSupport<VetoableChangeListener>) new ObjectInputStream( [EOL]                 new ByteArrayInputStream(outputStream.toByteArray())).readObject(); [EOL]  [EOL]         //make sure we get a listener array back, of the correct component type, and that it contains only the serializable mock [EOL]         final VetoableChangeListener[] listeners = deserializedListenerSupport.getListeners(); [EOL]         assertEquals(VetoableChangeListener.class, listeners.getClass().getComponentType()); [EOL]         assertEquals(1, listeners.length); [EOL]  [EOL]         //now verify that the mock still receives events; we can infer that the proxy was correctly reconstituted [EOL]         final VetoableChangeListener listener = listeners[0]; [EOL]         final PropertyChangeEvent evt = new PropertyChangeEvent(new Date(), "Day", 7, 9); [EOL]         listener.vetoableChange(evt); [EOL]         EasyMock.replay(listener); [EOL]         deserializedListenerSupport.fire().vetoableChange(evt); [EOL]         EasyMock.verify(listener); [EOL]  [EOL]         //remove listener and verify we get an empty array of listeners [EOL]         deserializedListenerSupport.removeListener(listener); [EOL]         assertEquals(0, deserializedListenerSupport.getListeners().length); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSerialization() throws IOException, ClassNotFoundException, PropertyVetoException { [EOL]         final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); [EOL]         listenerSupport.addListener(new VetoableChangeListener() { [EOL]              [EOL]             @Override [EOL]             public void vetoableChange(final PropertyChangeEvent e) { [EOL]             } [EOL]         }); [EOL]         listenerSupport.addListener(EasyMock.createNiceMock(VetoableChangeListener.class)); [EOL]  [EOL]         //serialize: [EOL]         final ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); [EOL]         final ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream); [EOL]  [EOL]         objectOutputStream.writeObject(listenerSupport); [EOL]         objectOutputStream.close(); [EOL]  [EOL]         //deserialize: [EOL]         @SuppressWarnings("unchecked") [EOL]         final [EOL]         EventListenerSupport<VetoableChangeListener> deserializedListenerSupport = (EventListenerSupport<VetoableChangeListener>) new ObjectInputStream( [EOL]                 new ByteArrayInputStream(outputStream.toByteArray())).readObject(); [EOL]  [EOL]         //make sure we get a listener array back, of the correct component type, and that it contains only the serializable mock [EOL]         final VetoableChangeListener[] listeners = deserializedListenerSupport.getListeners(); [EOL]         assertEquals(VetoableChangeListener.class, listeners.getClass().getComponentType()); [EOL]         assertEquals(1, listeners.length); [EOL]  [EOL]         //now verify that the mock still receives events; we can infer that the proxy was correctly reconstituted [EOL]         final VetoableChangeListener listener = listeners[0]; [EOL]         final PropertyChangeEvent evt = new PropertyChangeEvent(new Date(), "Day", 7, 9); [EOL]         listener.vetoableChange(evt); [EOL]         EasyMock.replay(listener); [EOL]         deserializedListenerSupport.fire().vetoableChange(evt); [EOL]         EasyMock.verify(listener); [EOL]  [EOL]         //remove listener and verify we get an empty array of listeners [EOL]         deserializedListenerSupport.removeListener(listener); [EOL]         assertEquals(0, deserializedListenerSupport.getListeners().length); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSerialization() throws IOException, ClassNotFoundException, PropertyVetoException { [EOL]         final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); [EOL]         listenerSupport.addListener(new VetoableChangeListener() { [EOL]              [EOL]             @Override [EOL]             public void vetoableChange(final PropertyChangeEvent e) { [EOL]             } [EOL]         }); [EOL]         listenerSupport.addListener(EasyMock.createNiceMock(VetoableChangeListener.class)); [EOL]  [EOL]         //serialize: [EOL]         final ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); [EOL]         final ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream); [EOL]  [EOL]         objectOutputStream.writeObject(listenerSupport); [EOL]         objectOutputStream.close(); [EOL]  [EOL]         //deserialize: [EOL]         @SuppressWarnings("unchecked") [EOL]         final [EOL]         EventListenerSupport<VetoableChangeListener> deserializedListenerSupport = (EventListenerSupport<VetoableChangeListener>) new ObjectInputStream( [EOL]                 new ByteArrayInputStream(outputStream.toByteArray())).readObject(); [EOL]  [EOL]         //make sure we get a listener array back, of the correct component type, and that it contains only the serializable mock [EOL]         final VetoableChangeListener[] listeners = deserializedListenerSupport.getListeners(); [EOL]         assertEquals(VetoableChangeListener.class, listeners.getClass().getComponentType()); [EOL]         assertEquals(1, listeners.length); [EOL]  [EOL]         //now verify that the mock still receives events; we can infer that the proxy was correctly reconstituted [EOL]         final VetoableChangeListener listener = listeners[0]; [EOL]         final PropertyChangeEvent evt = new PropertyChangeEvent(new Date(), "Day", 7, 9); [EOL]         listener.vetoableChange(evt); [EOL]         EasyMock.replay(listener); [EOL]         deserializedListenerSupport.fire().vetoableChange(evt); [EOL]         EasyMock.verify(listener); [EOL]  [EOL]         //remove listener and verify we get an empty array of listeners [EOL]         deserializedListenerSupport.removeListener(listener); [EOL]         assertEquals(0, deserializedListenerSupport.getListeners().length); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSerialization() throws IOException, ClassNotFoundException, PropertyVetoException { [EOL]         final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); [EOL]         listenerSupport.addListener(new VetoableChangeListener() { [EOL]              [EOL]             @Override [EOL]             public void vetoableChange(final PropertyChangeEvent e) { [EOL]             } [EOL]         }); [EOL]         listenerSupport.addListener(EasyMock.createNiceMock(VetoableChangeListener.class)); [EOL]  [EOL]         //serialize: [EOL]         final ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); [EOL]         final ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream); [EOL]  [EOL]         objectOutputStream.writeObject(listenerSupport); [EOL]         objectOutputStream.close(); [EOL]  [EOL]         //deserialize: [EOL]         @SuppressWarnings("unchecked") [EOL]         final [EOL]         EventListenerSupport<VetoableChangeListener> deserializedListenerSupport = (EventListenerSupport<VetoableChangeListener>) new ObjectInputStream( [EOL]                 new ByteArrayInputStream(outputStream.toByteArray())).readObject(); [EOL]  [EOL]         //make sure we get a listener array back, of the correct component type, and that it contains only the serializable mock [EOL]         final VetoableChangeListener[] listeners = deserializedListenerSupport.getListeners(); [EOL]         assertEquals(VetoableChangeListener.class, listeners.getClass().getComponentType()); [EOL]         assertEquals(1, listeners.length); [EOL]  [EOL]         //now verify that the mock still receives events; we can infer that the proxy was correctly reconstituted [EOL]         final VetoableChangeListener listener = listeners[0]; [EOL]         final PropertyChangeEvent evt = new PropertyChangeEvent(new Date(), "Day", 7, 9); [EOL]         listener.vetoableChange(evt); [EOL]         EasyMock.replay(listener); [EOL]         deserializedListenerSupport.fire().vetoableChange(evt); [EOL]         EasyMock.verify(listener); [EOL]  [EOL]         //remove listener and verify we get an empty array of listeners [EOL]         deserializedListenerSupport.removeListener(listener); [EOL]         assertEquals(0, deserializedListenerSupport.getListeners().length); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSerialization() throws IOException, ClassNotFoundException, PropertyVetoException { [EOL]         final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); [EOL]         listenerSupport.addListener(new VetoableChangeListener() { [EOL]              [EOL]             @Override [EOL]             public void vetoableChange(final PropertyChangeEvent e) { [EOL]             } [EOL]         }); [EOL]         listenerSupport.addListener(EasyMock.createNiceMock(VetoableChangeListener.class)); [EOL]  [EOL]         //serialize: [EOL]         final ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); [EOL]         final ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream); [EOL]  [EOL]         objectOutputStream.writeObject(listenerSupport); [EOL]         objectOutputStream.close(); [EOL]  [EOL]         //deserialize: [EOL]         @SuppressWarnings("unchecked") [EOL]         final [EOL]         EventListenerSupport<VetoableChangeListener> deserializedListenerSupport = (EventListenerSupport<VetoableChangeListener>) new ObjectInputStream( [EOL]                 new ByteArrayInputStream(outputStream.toByteArray())).readObject(); [EOL]  [EOL]         //make sure we get a listener array back, of the correct component type, and that it contains only the serializable mock [EOL]         final VetoableChangeListener[] listeners = deserializedListenerSupport.getListeners(); [EOL]         assertEquals(VetoableChangeListener.class, listeners.getClass().getComponentType()); [EOL]         assertEquals(1, listeners.length); [EOL]  [EOL]         //now verify that the mock still receives events; we can infer that the proxy was correctly reconstituted [EOL]         final VetoableChangeListener listener = listeners[0]; [EOL]         final PropertyChangeEvent evt = new PropertyChangeEvent(new Date(), "Day", 7, 9); [EOL]         listener.vetoableChange(evt); [EOL]         EasyMock.replay(listener); [EOL]         deserializedListenerSupport.fire().vetoableChange(evt); [EOL]         EasyMock.verify(listener); [EOL]  [EOL]         //remove listener and verify we get an empty array of listeners [EOL]         deserializedListenerSupport.removeListener(listener); [EOL]         assertEquals(0, deserializedListenerSupport.getListeners().length); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSerialization() throws IOException, ClassNotFoundException, PropertyVetoException { [EOL]         final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); [EOL]         listenerSupport.addListener(new VetoableChangeListener() { [EOL]              [EOL]             @Override [EOL]             public void vetoableChange(final PropertyChangeEvent e) { [EOL]             } [EOL]         }); [EOL]         listenerSupport.addListener(EasyMock.createNiceMock(VetoableChangeListener.class)); [EOL]  [EOL]         //serialize: [EOL]         final ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); [EOL]         final ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream); [EOL]  [EOL]         objectOutputStream.writeObject(listenerSupport); [EOL]         objectOutputStream.close(); [EOL]  [EOL]         //deserialize: [EOL]         @SuppressWarnings("unchecked") [EOL]         final [EOL]         EventListenerSupport<VetoableChangeListener> deserializedListenerSupport = (EventListenerSupport<VetoableChangeListener>) new ObjectInputStream( [EOL]                 new ByteArrayInputStream(outputStream.toByteArray())).readObject(); [EOL]  [EOL]         //make sure we get a listener array back, of the correct component type, and that it contains only the serializable mock [EOL]         final VetoableChangeListener[] listeners = deserializedListenerSupport.getListeners(); [EOL]         assertEquals(VetoableChangeListener.class, listeners.getClass().getComponentType()); [EOL]         assertEquals(1, listeners.length); [EOL]  [EOL]         //now verify that the mock still receives events; we can infer that the proxy was correctly reconstituted [EOL]         final VetoableChangeListener listener = listeners[0]; [EOL]         final PropertyChangeEvent evt = new PropertyChangeEvent(new Date(), "Day", 7, 9); [EOL]         listener.vetoableChange(evt); [EOL]         EasyMock.replay(listener); [EOL]         deserializedListenerSupport.fire().vetoableChange(evt); [EOL]         EasyMock.verify(listener); [EOL]  [EOL]         //remove listener and verify we get an empty array of listeners [EOL]         deserializedListenerSupport.removeListener(listener); [EOL]         assertEquals(0, deserializedListenerSupport.getListeners().length); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSerialization() throws IOException, ClassNotFoundException, PropertyVetoException { [EOL]         final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); [EOL]         listenerSupport.addListener(new VetoableChangeListener() { [EOL]              [EOL]             @Override [EOL]             public void vetoableChange(final PropertyChangeEvent e) { [EOL]             } [EOL]         }); [EOL]         listenerSupport.addListener(EasyMock.createNiceMock(VetoableChangeListener.class)); [EOL]  [EOL]         //serialize: [EOL]         final ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); [EOL]         final ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream); [EOL]  [EOL]         objectOutputStream.writeObject(listenerSupport); [EOL]         objectOutputStream.close(); [EOL]  [EOL]         //deserialize: [EOL]         @SuppressWarnings("unchecked") [EOL]         final [EOL]         EventListenerSupport<VetoableChangeListener> deserializedListenerSupport = (EventListenerSupport<VetoableChangeListener>) new ObjectInputStream( [EOL]                 new ByteArrayInputStream(outputStream.toByteArray())).readObject(); [EOL]  [EOL]         //make sure we get a listener array back, of the correct component type, and that it contains only the serializable mock [EOL]         final VetoableChangeListener[] listeners = deserializedListenerSupport.getListeners(); [EOL]         assertEquals(VetoableChangeListener.class, listeners.getClass().getComponentType()); [EOL]         assertEquals(1, listeners.length); [EOL]  [EOL]         //now verify that the mock still receives events; we can infer that the proxy was correctly reconstituted [EOL]         final VetoableChangeListener listener = listeners[0]; [EOL]         final PropertyChangeEvent evt = new PropertyChangeEvent(new Date(), "Day", 7, 9); [EOL]         listener.vetoableChange(evt); [EOL]         EasyMock.replay(listener); [EOL]         deserializedListenerSupport.fire().vetoableChange(evt); [EOL]         EasyMock.verify(listener); [EOL]  [EOL]         //remove listener and verify we get an empty array of listeners [EOL]         deserializedListenerSupport.removeListener(listener); [EOL]         assertEquals(0, deserializedListenerSupport.getListeners().length); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSerialization() throws IOException, ClassNotFoundException, PropertyVetoException { [EOL]         final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); [EOL]         listenerSupport.addListener(new VetoableChangeListener() { [EOL]              [EOL]             @Override [EOL]             public void vetoableChange(final PropertyChangeEvent e) { [EOL]             } [EOL]         }); [EOL]         listenerSupport.addListener(EasyMock.createNiceMock(VetoableChangeListener.class)); [EOL]  [EOL]         //serialize: [EOL]         final ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); [EOL]         final ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream); [EOL]  [EOL]         objectOutputStream.writeObject(listenerSupport); [EOL]         objectOutputStream.close(); [EOL]  [EOL]         //deserialize: [EOL]         @SuppressWarnings("unchecked") [EOL]         final [EOL]         EventListenerSupport<VetoableChangeListener> deserializedListenerSupport = (EventListenerSupport<VetoableChangeListener>) new ObjectInputStream( [EOL]                 new ByteArrayInputStream(outputStream.toByteArray())).readObject(); [EOL]  [EOL]         //make sure we get a listener array back, of the correct component type, and that it contains only the serializable mock [EOL]         final VetoableChangeListener[] listeners = deserializedListenerSupport.getListeners(); [EOL]         assertEquals(VetoableChangeListener.class, listeners.getClass().getComponentType()); [EOL]         assertEquals(1, listeners.length); [EOL]  [EOL]         //now verify that the mock still receives events; we can infer that the proxy was correctly reconstituted [EOL]         final VetoableChangeListener listener = listeners[0]; [EOL]         final PropertyChangeEvent evt = new PropertyChangeEvent(new Date(), "Day", 7, 9); [EOL]         listener.vetoableChange(evt); [EOL]         EasyMock.replay(listener); [EOL]         deserializedListenerSupport.fire().vetoableChange(evt); [EOL]         EasyMock.verify(listener); [EOL]  [EOL]         //remove listener and verify we get an empty array of listeners [EOL]         deserializedListenerSupport.removeListener(listener); [EOL]         assertEquals(0, deserializedListenerSupport.getListeners().length); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSerialization() throws IOException, ClassNotFoundException, PropertyVetoException { [EOL]         final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); [EOL]         listenerSupport.addListener(new VetoableChangeListener() { [EOL]              [EOL]             @Override [EOL]             public void vetoableChange(final PropertyChangeEvent e) { [EOL]             } [EOL]         }); [EOL]         listenerSupport.addListener(EasyMock.createNiceMock(VetoableChangeListener.class)); [EOL]  [EOL]         //serialize: [EOL]         final ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); [EOL]         final ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream); [EOL]  [EOL]         objectOutputStream.writeObject(listenerSupport); [EOL]         objectOutputStream.close(); [EOL]  [EOL]         //deserialize: [EOL]         @SuppressWarnings("unchecked") [EOL]         final [EOL]         EventListenerSupport<VetoableChangeListener> deserializedListenerSupport = (EventListenerSupport<VetoableChangeListener>) new ObjectInputStream( [EOL]                 new ByteArrayInputStream(outputStream.toByteArray())).readObject(); [EOL]  [EOL]         //make sure we get a listener array back, of the correct component type, and that it contains only the serializable mock [EOL]         final VetoableChangeListener[] listeners = deserializedListenerSupport.getListeners(); [EOL]         assertEquals(VetoableChangeListener.class, listeners.getClass().getComponentType()); [EOL]         assertEquals(1, listeners.length); [EOL]  [EOL]         //now verify that the mock still receives events; we can infer that the proxy was correctly reconstituted [EOL]         final VetoableChangeListener listener = listeners[0]; [EOL]         final PropertyChangeEvent evt = new PropertyChangeEvent(new Date(), "Day", 7, 9); [EOL]         listener.vetoableChange(evt); [EOL]         EasyMock.replay(listener); [EOL]         deserializedListenerSupport.fire().vetoableChange(evt); [EOL]         EasyMock.verify(listener); [EOL]  [EOL]         //remove listener and verify we get an empty array of listeners [EOL]         deserializedListenerSupport.removeListener(listener); [EOL]         assertEquals(0, deserializedListenerSupport.getListeners().length); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSerialization() throws IOException, ClassNotFoundException, PropertyVetoException { [EOL]         final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); [EOL]         listenerSupport.addListener(new VetoableChangeListener() { [EOL]              [EOL]             @Override [EOL]             public void vetoableChange(final PropertyChangeEvent e) { [EOL]             } [EOL]         }); [EOL]         listenerSupport.addListener(EasyMock.createNiceMock(VetoableChangeListener.class)); [EOL]  [EOL]         //serialize: [EOL]         final ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); [EOL]         final ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream); [EOL]  [EOL]         objectOutputStream.writeObject(listenerSupport); [EOL]         objectOutputStream.close(); [EOL]  [EOL]         //deserialize: [EOL]         @SuppressWarnings("unchecked") [EOL]         final [EOL]         EventListenerSupport<VetoableChangeListener> deserializedListenerSupport = (EventListenerSupport<VetoableChangeListener>) new ObjectInputStream( [EOL]                 new ByteArrayInputStream(outputStream.toByteArray())).readObject(); [EOL]  [EOL]         //make sure we get a listener array back, of the correct component type, and that it contains only the serializable mock [EOL]         final VetoableChangeListener[] listeners = deserializedListenerSupport.getListeners(); [EOL]         assertEquals(VetoableChangeListener.class, listeners.getClass().getComponentType()); [EOL]         assertEquals(1, listeners.length); [EOL]  [EOL]         //now verify that the mock still receives events; we can infer that the proxy was correctly reconstituted [EOL]         final VetoableChangeListener listener = listeners[0]; [EOL]         final PropertyChangeEvent evt = new PropertyChangeEvent(new Date(), "Day", 7, 9); [EOL]         listener.vetoableChange(evt); [EOL]         EasyMock.replay(listener); [EOL]         deserializedListenerSupport.fire().vetoableChange(evt); [EOL]         EasyMock.verify(listener); [EOL]  [EOL]         //remove listener and verify we get an empty array of listeners [EOL]         deserializedListenerSupport.removeListener(listener); [EOL]         assertEquals(0, deserializedListenerSupport.getListeners().length); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSerialization() throws IOException, ClassNotFoundException, PropertyVetoException { [EOL]         final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); [EOL]         listenerSupport.addListener(new VetoableChangeListener() { [EOL]              [EOL]             @Override [EOL]             public void vetoableChange(final PropertyChangeEvent e) { [EOL]             } [EOL]         }); [EOL]         listenerSupport.addListener(EasyMock.createNiceMock(VetoableChangeListener.class)); [EOL]  [EOL]         //serialize: [EOL]         final ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); [EOL]         final ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream); [EOL]  [EOL]         objectOutputStream.writeObject(listenerSupport); [EOL]         objectOutputStream.close(); [EOL]  [EOL]         //deserialize: [EOL]         @SuppressWarnings("unchecked") [EOL]         final [EOL]         EventListenerSupport<VetoableChangeListener> deserializedListenerSupport = (EventListenerSupport<VetoableChangeListener>) new ObjectInputStream( [EOL]                 new ByteArrayInputStream(outputStream.toByteArray())).readObject(); [EOL]  [EOL]         //make sure we get a listener array back, of the correct component type, and that it contains only the serializable mock [EOL]         final VetoableChangeListener[] listeners = deserializedListenerSupport.getListeners(); [EOL]         assertEquals(VetoableChangeListener.class, listeners.getClass().getComponentType()); [EOL]         assertEquals(1, listeners.length); [EOL]  [EOL]         //now verify that the mock still receives events; we can infer that the proxy was correctly reconstituted [EOL]         final VetoableChangeListener listener = listeners[0]; [EOL]         final PropertyChangeEvent evt = new PropertyChangeEvent(new Date(), "Day", 7, 9); [EOL]         listener.vetoableChange(evt); [EOL]         EasyMock.replay(listener); [EOL]         deserializedListenerSupport.fire().vetoableChange(evt); [EOL]         EasyMock.verify(listener); [EOL]  [EOL]         //remove listener and verify we get an empty array of listeners [EOL]         deserializedListenerSupport.removeListener(listener); [EOL]         assertEquals(0, deserializedListenerSupport.getListeners().length); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSerialization() throws IOException, ClassNotFoundException, PropertyVetoException { [EOL]         final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); [EOL]         listenerSupport.addListener(new VetoableChangeListener() { [EOL]              [EOL]             @Override [EOL]             public void vetoableChange(final PropertyChangeEvent e) { [EOL]             } [EOL]         }); [EOL]         listenerSupport.addListener(EasyMock.createNiceMock(VetoableChangeListener.class)); [EOL]  [EOL]         //serialize: [EOL]         final ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); [EOL]         final ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream); [EOL]  [EOL]         objectOutputStream.writeObject(listenerSupport); [EOL]         objectOutputStream.close(); [EOL]  [EOL]         //deserialize: [EOL]         @SuppressWarnings("unchecked") [EOL]         final [EOL]         EventListenerSupport<VetoableChangeListener> deserializedListenerSupport = (EventListenerSupport<VetoableChangeListener>) new ObjectInputStream( [EOL]                 new ByteArrayInputStream(outputStream.toByteArray())).readObject(); [EOL]  [EOL]         //make sure we get a listener array back, of the correct component type, and that it contains only the serializable mock [EOL]         final VetoableChangeListener[] listeners = deserializedListenerSupport.getListeners(); [EOL]         assertEquals(VetoableChangeListener.class, listeners.getClass().getComponentType()); [EOL]         assertEquals(1, listeners.length); [EOL]  [EOL]         //now verify that the mock still receives events; we can infer that the proxy was correctly reconstituted [EOL]         final VetoableChangeListener listener = listeners[0]; [EOL]         final PropertyChangeEvent evt = new PropertyChangeEvent(new Date(), "Day", 7, 9); [EOL]         listener.vetoableChange(evt); [EOL]         EasyMock.replay(listener); [EOL]         deserializedListenerSupport.fire().vetoableChange(evt); [EOL]         EasyMock.verify(listener); [EOL]  [EOL]         //remove listener and verify we get an empty array of listeners [EOL]         deserializedListenerSupport.removeListener(listener); [EOL]         assertEquals(0, deserializedListenerSupport.getListeners().length); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSerialization() throws IOException, ClassNotFoundException, PropertyVetoException { [EOL]         final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); [EOL]         listenerSupport.addListener(new VetoableChangeListener() { [EOL]              [EOL]             @Override [EOL]             public void vetoableChange(final PropertyChangeEvent e) { [EOL]             } [EOL]         }); [EOL]         listenerSupport.addListener(EasyMock.createNiceMock(VetoableChangeListener.class)); [EOL]  [EOL]         //serialize: [EOL]         final ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); [EOL]         final ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream); [EOL]  [EOL]         objectOutputStream.writeObject(listenerSupport); [EOL]         objectOutputStream.close(); [EOL]  [EOL]         //deserialize: [EOL]         @SuppressWarnings("unchecked") [EOL]         final [EOL]         EventListenerSupport<VetoableChangeListener> deserializedListenerSupport = (EventListenerSupport<VetoableChangeListener>) new ObjectInputStream( [EOL]                 new ByteArrayInputStream(outputStream.toByteArray())).readObject(); [EOL]  [EOL]         //make sure we get a listener array back, of the correct component type, and that it contains only the serializable mock [EOL]         final VetoableChangeListener[] listeners = deserializedListenerSupport.getListeners(); [EOL]         assertEquals(VetoableChangeListener.class, listeners.getClass().getComponentType()); [EOL]         assertEquals(1, listeners.length); [EOL]  [EOL]         //now verify that the mock still receives events; we can infer that the proxy was correctly reconstituted [EOL]         final VetoableChangeListener listener = listeners[0]; [EOL]         final PropertyChangeEvent evt = new PropertyChangeEvent(new Date(), "Day", 7, 9); [EOL]         listener.vetoableChange(evt); [EOL]         EasyMock.replay(listener); [EOL]         deserializedListenerSupport.fire().vetoableChange(evt); [EOL]         EasyMock.verify(listener); [EOL]  [EOL]         //remove listener and verify we get an empty array of listeners [EOL]         deserializedListenerSupport.removeListener(listener); [EOL]         assertEquals(0, deserializedListenerSupport.getListeners().length); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSerialization() throws IOException, ClassNotFoundException, PropertyVetoException { [EOL]         final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); [EOL]         listenerSupport.addListener(new VetoableChangeListener() { [EOL]              [EOL]             @Override [EOL]             public void vetoableChange(final PropertyChangeEvent e) { [EOL]             } [EOL]         }); [EOL]         listenerSupport.addListener(EasyMock.createNiceMock(VetoableChangeListener.class)); [EOL]  [EOL]         //serialize: [EOL]         final ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); [EOL]         final ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream); [EOL]  [EOL]         objectOutputStream.writeObject(listenerSupport); [EOL]         objectOutputStream.close(); [EOL]  [EOL]         //deserialize: [EOL]         @SuppressWarnings("unchecked") [EOL]         final [EOL]         EventListenerSupport<VetoableChangeListener> deserializedListenerSupport = (EventListenerSupport<VetoableChangeListener>) new ObjectInputStream( [EOL]                 new ByteArrayInputStream(outputStream.toByteArray())).readObject(); [EOL]  [EOL]         //make sure we get a listener array back, of the correct component type, and that it contains only the serializable mock [EOL]         final VetoableChangeListener[] listeners = deserializedListenerSupport.getListeners(); [EOL]         assertEquals(VetoableChangeListener.class, listeners.getClass().getComponentType()); [EOL]         assertEquals(1, listeners.length); [EOL]  [EOL]         //now verify that the mock still receives events; we can infer that the proxy was correctly reconstituted [EOL]         final VetoableChangeListener listener = listeners[0]; [EOL]         final PropertyChangeEvent evt = new PropertyChangeEvent(new Date(), "Day", 7, 9); [EOL]         listener.vetoableChange(evt); [EOL]         EasyMock.replay(listener); [EOL]         deserializedListenerSupport.fire().vetoableChange(evt); [EOL]         EasyMock.verify(listener); [EOL]  [EOL]         //remove listener and verify we get an empty array of listeners [EOL]         deserializedListenerSupport.removeListener(listener); [EOL]         assertEquals(0, deserializedListenerSupport.getListeners().length); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSerialization() throws IOException, ClassNotFoundException, PropertyVetoException { [EOL]         final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); [EOL]         listenerSupport.addListener(new VetoableChangeListener() { [EOL]              [EOL]             @Override [EOL]             public void vetoableChange(final PropertyChangeEvent e) { [EOL]             } [EOL]         }); [EOL]         listenerSupport.addListener(EasyMock.createNiceMock(VetoableChangeListener.class)); [EOL]  [EOL]         //serialize: [EOL]         final ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); [EOL]         final ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream); [EOL]  [EOL]         objectOutputStream.writeObject(listenerSupport); [EOL]         objectOutputStream.close(); [EOL]  [EOL]         //deserialize: [EOL]         @SuppressWarnings("unchecked") [EOL]         final [EOL]         EventListenerSupport<VetoableChangeListener> deserializedListenerSupport = (EventListenerSupport<VetoableChangeListener>) new ObjectInputStream( [EOL]                 new ByteArrayInputStream(outputStream.toByteArray())).readObject(); [EOL]  [EOL]         //make sure we get a listener array back, of the correct component type, and that it contains only the serializable mock [EOL]         final VetoableChangeListener[] listeners = deserializedListenerSupport.getListeners(); [EOL]         assertEquals(VetoableChangeListener.class, listeners.getClass().getComponentType()); [EOL]         assertEquals(1, listeners.length); [EOL]  [EOL]         //now verify that the mock still receives events; we can infer that the proxy was correctly reconstituted [EOL]         final VetoableChangeListener listener = listeners[0]; [EOL]         final PropertyChangeEvent evt = new PropertyChangeEvent(new Date(), "Day", 7, 9); [EOL]         listener.vetoableChange(evt); [EOL]         EasyMock.replay(listener); [EOL]         deserializedListenerSupport.fire().vetoableChange(evt); [EOL]         EasyMock.verify(listener); [EOL]  [EOL]         //remove listener and verify we get an empty array of listeners [EOL]         deserializedListenerSupport.removeListener(listener); [EOL]         assertEquals(0, deserializedListenerSupport.getListeners().length); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSerialization() throws IOException, ClassNotFoundException, PropertyVetoException { [EOL]         final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); [EOL]         listenerSupport.addListener(new VetoableChangeListener() { [EOL]              [EOL]             @Override [EOL]             public void vetoableChange(final PropertyChangeEvent e) { [EOL]             } [EOL]         }); [EOL]         listenerSupport.addListener(EasyMock.createNiceMock(VetoableChangeListener.class)); [EOL]  [EOL]         //serialize: [EOL]         final ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); [EOL]         final ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream); [EOL]  [EOL]         objectOutputStream.writeObject(listenerSupport); [EOL]         objectOutputStream.close(); [EOL]  [EOL]         //deserialize: [EOL]         @SuppressWarnings("unchecked") [EOL]         final [EOL]         EventListenerSupport<VetoableChangeListener> deserializedListenerSupport = (EventListenerSupport<VetoableChangeListener>) new ObjectInputStream( [EOL]                 new ByteArrayInputStream(outputStream.toByteArray())).readObject(); [EOL]  [EOL]         //make sure we get a listener array back, of the correct component type, and that it contains only the serializable mock [EOL]         final VetoableChangeListener[] listeners = deserializedListenerSupport.getListeners(); [EOL]         assertEquals(VetoableChangeListener.class, listeners.getClass().getComponentType()); [EOL]         assertEquals(1, listeners.length); [EOL]  [EOL]         //now verify that the mock still receives events; we can infer that the proxy was correctly reconstituted [EOL]         final VetoableChangeListener listener = listeners[0]; [EOL]         final PropertyChangeEvent evt = new PropertyChangeEvent(new Date(), "Day", 7, 9); [EOL]         listener.vetoableChange(evt); [EOL]         EasyMock.replay(listener); [EOL]         deserializedListenerSupport.fire().vetoableChange(evt); [EOL]         EasyMock.verify(listener); [EOL]  [EOL]         //remove listener and verify we get an empty array of listeners [EOL]         deserializedListenerSupport.removeListener(listener); [EOL]         assertEquals(0, deserializedListenerSupport.getListeners().length); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSerialization() throws IOException, ClassNotFoundException, PropertyVetoException { [EOL]         final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); [EOL]         listenerSupport.addListener(new VetoableChangeListener() { [EOL]              [EOL]             @Override [EOL]             public void vetoableChange(final PropertyChangeEvent e) { [EOL]             } [EOL]         }); [EOL]         listenerSupport.addListener(EasyMock.createNiceMock(VetoableChangeListener.class)); [EOL]  [EOL]         //serialize: [EOL]         final ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); [EOL]         final ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream); [EOL]  [EOL]         objectOutputStream.writeObject(listenerSupport); [EOL]         objectOutputStream.close(); [EOL]  [EOL]         //deserialize: [EOL]         @SuppressWarnings("unchecked") [EOL]         final [EOL]         EventListenerSupport<VetoableChangeListener> deserializedListenerSupport = (EventListenerSupport<VetoableChangeListener>) new ObjectInputStream( [EOL]                 new ByteArrayInputStream(outputStream.toByteArray())).readObject(); [EOL]  [EOL]         //make sure we get a listener array back, of the correct component type, and that it contains only the serializable mock [EOL]         final VetoableChangeListener[] listeners = deserializedListenerSupport.getListeners(); [EOL]         assertEquals(VetoableChangeListener.class, listeners.getClass().getComponentType()); [EOL]         assertEquals(1, listeners.length); [EOL]  [EOL]         //now verify that the mock still receives events; we can infer that the proxy was correctly reconstituted [EOL]         final VetoableChangeListener listener = listeners[0]; [EOL]         final PropertyChangeEvent evt = new PropertyChangeEvent(new Date(), "Day", 7, 9); [EOL]         listener.vetoableChange(evt); [EOL]         EasyMock.replay(listener); [EOL]         deserializedListenerSupport.fire().vetoableChange(evt); [EOL]         EasyMock.verify(listener); [EOL]  [EOL]         //remove listener and verify we get an empty array of listeners [EOL]         deserializedListenerSupport.removeListener(listener); [EOL]         assertEquals(0, deserializedListenerSupport.getListeners().length); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSerialization() throws IOException, ClassNotFoundException, PropertyVetoException { [EOL]         final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); [EOL]         listenerSupport.addListener(new VetoableChangeListener() { [EOL]              [EOL]             @Override [EOL]             public void vetoableChange(final PropertyChangeEvent e) { [EOL]             } [EOL]         }); [EOL]         listenerSupport.addListener(EasyMock.createNiceMock(VetoableChangeListener.class)); [EOL]  [EOL]         //serialize: [EOL]         final ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); [EOL]         final ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream); [EOL]  [EOL]         objectOutputStream.writeObject(listenerSupport); [EOL]         objectOutputStream.close(); [EOL]  [EOL]         //deserialize: [EOL]         @SuppressWarnings("unchecked") [EOL]         final [EOL]         EventListenerSupport<VetoableChangeListener> deserializedListenerSupport = (EventListenerSupport<VetoableChangeListener>) new ObjectInputStream( [EOL]                 new ByteArrayInputStream(outputStream.toByteArray())).readObject(); [EOL]  [EOL]         //make sure we get a listener array back, of the correct component type, and that it contains only the serializable mock [EOL]         final VetoableChangeListener[] listeners = deserializedListenerSupport.getListeners(); [EOL]         assertEquals(VetoableChangeListener.class, listeners.getClass().getComponentType()); [EOL]         assertEquals(1, listeners.length); [EOL]  [EOL]         //now verify that the mock still receives events; we can infer that the proxy was correctly reconstituted [EOL]         final VetoableChangeListener listener = listeners[0]; [EOL]         final PropertyChangeEvent evt = new PropertyChangeEvent(new Date(), "Day", 7, 9); [EOL]         listener.vetoableChange(evt); [EOL]         EasyMock.replay(listener); [EOL]         deserializedListenerSupport.fire().vetoableChange(evt); [EOL]         EasyMock.verify(listener); [EOL]  [EOL]         //remove listener and verify we get an empty array of listeners [EOL]         deserializedListenerSupport.removeListener(listener); [EOL]         assertEquals(0, deserializedListenerSupport.getListeners().length); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSerialization() throws IOException, ClassNotFoundException, PropertyVetoException { [EOL]         final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); [EOL]         listenerSupport.addListener(new VetoableChangeListener() { [EOL]              [EOL]             @Override [EOL]             public void vetoableChange(final PropertyChangeEvent e) { [EOL]             } [EOL]         }); [EOL]         listenerSupport.addListener(EasyMock.createNiceMock(VetoableChangeListener.class)); [EOL]  [EOL]         //serialize: [EOL]         final ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); [EOL]         final ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream); [EOL]  [EOL]         objectOutputStream.writeObject(listenerSupport); [EOL]         objectOutputStream.close(); [EOL]  [EOL]         //deserialize: [EOL]         @SuppressWarnings("unchecked") [EOL]         final [EOL]         EventListenerSupport<VetoableChangeListener> deserializedListenerSupport = (EventListenerSupport<VetoableChangeListener>) new ObjectInputStream( [EOL]                 new ByteArrayInputStream(outputStream.toByteArray())).readObject(); [EOL]  [EOL]         //make sure we get a listener array back, of the correct component type, and that it contains only the serializable mock [EOL]         final VetoableChangeListener[] listeners = deserializedListenerSupport.getListeners(); [EOL]         assertEquals(VetoableChangeListener.class, listeners.getClass().getComponentType()); [EOL]         assertEquals(1, listeners.length); [EOL]  [EOL]         //now verify that the mock still receives events; we can infer that the proxy was correctly reconstituted [EOL]         final VetoableChangeListener listener = listeners[0]; [EOL]         final PropertyChangeEvent evt = new PropertyChangeEvent(new Date(), "Day", 7, 9); [EOL]         listener.vetoableChange(evt); [EOL]         EasyMock.replay(listener); [EOL]         deserializedListenerSupport.fire().vetoableChange(evt); [EOL]         EasyMock.verify(listener); [EOL]  [EOL]         //remove listener and verify we get an empty array of listeners [EOL]         deserializedListenerSupport.removeListener(listener); [EOL]         assertEquals(0, deserializedListenerSupport.getListeners().length); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSerialization() throws IOException, ClassNotFoundException, PropertyVetoException { [EOL]         final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); [EOL]         listenerSupport.addListener(new VetoableChangeListener() { [EOL]              [EOL]             @Override [EOL]             public void vetoableChange(final PropertyChangeEvent e) { [EOL]             } [EOL]         }); [EOL]         listenerSupport.addListener(EasyMock.createNiceMock(VetoableChangeListener.class)); [EOL]  [EOL]         //serialize: [EOL]         final ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); [EOL]         final ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream); [EOL]  [EOL]         objectOutputStream.writeObject(listenerSupport); [EOL]         objectOutputStream.close(); [EOL]  [EOL]         //deserialize: [EOL]         @SuppressWarnings("unchecked") [EOL]         final [EOL]         EventListenerSupport<VetoableChangeListener> deserializedListenerSupport = (EventListenerSupport<VetoableChangeListener>) new ObjectInputStream( [EOL]                 new ByteArrayInputStream(outputStream.toByteArray())).readObject(); [EOL]  [EOL]         //make sure we get a listener array back, of the correct component type, and that it contains only the serializable mock [EOL]         final VetoableChangeListener[] listeners = deserializedListenerSupport.getListeners(); [EOL]         assertEquals(VetoableChangeListener.class, listeners.getClass().getComponentType()); [EOL]         assertEquals(1, listeners.length); [EOL]  [EOL]         //now verify that the mock still receives events; we can infer that the proxy was correctly reconstituted [EOL]         final VetoableChangeListener listener = listeners[0]; [EOL]         final PropertyChangeEvent evt = new PropertyChangeEvent(new Date(), "Day", 7, 9); [EOL]         listener.vetoableChange(evt); [EOL]         EasyMock.replay(listener); [EOL]         deserializedListenerSupport.fire().vetoableChange(evt); [EOL]         EasyMock.verify(listener); [EOL]  [EOL]         //remove listener and verify we get an empty array of listeners [EOL]         deserializedListenerSupport.removeListener(listener); [EOL]         assertEquals(0, deserializedListenerSupport.getListeners().length); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSerialization() throws IOException, ClassNotFoundException, PropertyVetoException { [EOL]         final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); [EOL]         listenerSupport.addListener(new VetoableChangeListener() { [EOL]              [EOL]             @Override [EOL]             public void vetoableChange(final PropertyChangeEvent e) { [EOL]             } [EOL]         }); [EOL]         listenerSupport.addListener(EasyMock.createNiceMock(VetoableChangeListener.class)); [EOL]  [EOL]         //serialize: [EOL]         final ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); [EOL]         final ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream); [EOL]  [EOL]         objectOutputStream.writeObject(listenerSupport); [EOL]         objectOutputStream.close(); [EOL]  [EOL]         //deserialize: [EOL]         @SuppressWarnings("unchecked") [EOL]         final [EOL]         EventListenerSupport<VetoableChangeListener> deserializedListenerSupport = (EventListenerSupport<VetoableChangeListener>) new ObjectInputStream( [EOL]                 new ByteArrayInputStream(outputStream.toByteArray())).readObject(); [EOL]  [EOL]         //make sure we get a listener array back, of the correct component type, and that it contains only the serializable mock [EOL]         final VetoableChangeListener[] listeners = deserializedListenerSupport.getListeners(); [EOL]         assertEquals(VetoableChangeListener.class, listeners.getClass().getComponentType()); [EOL]         assertEquals(1, listeners.length); [EOL]  [EOL]         //now verify that the mock still receives events; we can infer that the proxy was correctly reconstituted [EOL]         final VetoableChangeListener listener = listeners[0]; [EOL]         final PropertyChangeEvent evt = new PropertyChangeEvent(new Date(), "Day", 7, 9); [EOL]         listener.vetoableChange(evt); [EOL]         EasyMock.replay(listener); [EOL]         deserializedListenerSupport.fire().vetoableChange(evt); [EOL]         EasyMock.verify(listener); [EOL]  [EOL]         //remove listener and verify we get an empty array of listeners [EOL]         deserializedListenerSupport.removeListener(listener); [EOL]         assertEquals(0, deserializedListenerSupport.getListeners().length); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSerialization() throws IOException, ClassNotFoundException, PropertyVetoException { [EOL]         final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); [EOL]         listenerSupport.addListener(new VetoableChangeListener() { [EOL]              [EOL]             @Override [EOL]             public void vetoableChange(final PropertyChangeEvent e) { [EOL]             } [EOL]         }); [EOL]         listenerSupport.addListener(EasyMock.createNiceMock(VetoableChangeListener.class)); [EOL]  [EOL]         //serialize: [EOL]         final ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); [EOL]         final ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream); [EOL]  [EOL]         objectOutputStream.writeObject(listenerSupport); [EOL]         objectOutputStream.close(); [EOL]  [EOL]         //deserialize: [EOL]         @SuppressWarnings("unchecked") [EOL]         final [EOL]         EventListenerSupport<VetoableChangeListener> deserializedListenerSupport = (EventListenerSupport<VetoableChangeListener>) new ObjectInputStream( [EOL]                 new ByteArrayInputStream(outputStream.toByteArray())).readObject(); [EOL]  [EOL]         //make sure we get a listener array back, of the correct component type, and that it contains only the serializable mock [EOL]         final VetoableChangeListener[] listeners = deserializedListenerSupport.getListeners(); [EOL]         assertEquals(VetoableChangeListener.class, listeners.getClass().getComponentType()); [EOL]         assertEquals(1, listeners.length); [EOL]  [EOL]         //now verify that the mock still receives events; we can infer that the proxy was correctly reconstituted [EOL]         final VetoableChangeListener listener = listeners[0]; [EOL]         final PropertyChangeEvent evt = new PropertyChangeEvent(new Date(), "Day", 7, 9); [EOL]         listener.vetoableChange(evt); [EOL]         EasyMock.replay(listener); [EOL]         deserializedListenerSupport.fire().vetoableChange(evt); [EOL]         EasyMock.verify(listener); [EOL]  [EOL]         //remove listener and verify we get an empty array of listeners [EOL]         deserializedListenerSupport.removeListener(listener); [EOL]         assertEquals(0, deserializedListenerSupport.getListeners().length); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsNumber() { [EOL]         String val = "12345"; [EOL]         assertTrue("isNumber(String) 1 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 1 failed", checkCreateNumber(val)); [EOL]         val = "1234.5"; [EOL]         assertTrue("isNumber(String) 2 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 2 failed", checkCreateNumber(val)); [EOL]         val = ".12345"; [EOL]         assertTrue("isNumber(String) 3 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 3 failed", checkCreateNumber(val)); [EOL]         val = "1234E5"; [EOL]         assertTrue("isNumber(String) 4 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 4 failed", checkCreateNumber(val)); [EOL]         val = "1234E+5"; [EOL]         assertTrue("isNumber(String) 5 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 5 failed", checkCreateNumber(val)); [EOL]         val = "1234E-5"; [EOL]         assertTrue("isNumber(String) 6 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 6 failed", checkCreateNumber(val)); [EOL]         val = "123.4E5"; [EOL]         assertTrue("isNumber(String) 7 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 7 failed", checkCreateNumber(val)); [EOL]         val = "-1234"; [EOL]         assertTrue("isNumber(String) 8 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 8 failed", checkCreateNumber(val)); [EOL]         val = "-1234.5"; [EOL]         assertTrue("isNumber(String) 9 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 9 failed", checkCreateNumber(val)); [EOL]         val = "-.12345"; [EOL]         assertTrue("isNumber(String) 10 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 10 failed", checkCreateNumber(val)); [EOL]         val = "-1234E5"; [EOL]         assertTrue("isNumber(String) 11 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 11 failed", checkCreateNumber(val)); [EOL]         val = "0"; [EOL]         assertTrue("isNumber(String) 12 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 12 failed", checkCreateNumber(val)); [EOL]         val = "-0"; [EOL]         assertTrue("isNumber(String) 13 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 13 failed", checkCreateNumber(val)); [EOL]         val = "01234"; [EOL]         assertTrue("isNumber(String) 14 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 14 failed", checkCreateNumber(val)); [EOL]         val = "-01234"; [EOL]         assertTrue("isNumber(String) 15 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 15 failed", checkCreateNumber(val)); [EOL]         val = "0xABC123"; [EOL]         assertTrue("isNumber(String) 16 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 16 failed", checkCreateNumber(val)); [EOL]         val = "0x0"; [EOL]         assertTrue("isNumber(String) 17 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 17 failed", checkCreateNumber(val)); [EOL]         val = "123.4E21D"; [EOL]         assertTrue("isNumber(String) 19 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 19 failed", checkCreateNumber(val)); [EOL]         val = "-221.23F"; [EOL]         assertTrue("isNumber(String) 20 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 20 failed", checkCreateNumber(val)); [EOL]         val = "22338L"; [EOL]         assertTrue("isNumber(String) 21 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 21 failed", checkCreateNumber(val)); [EOL]         val = null; [EOL]         assertTrue("isNumber(String) 1 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 1 Neg failed", !checkCreateNumber(val)); [EOL]         val = ""; [EOL]         assertTrue("isNumber(String) 2 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 2 Neg failed", !checkCreateNumber(val)); [EOL]         val = "--2.3"; [EOL]         assertTrue("isNumber(String) 3 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 3 Neg failed", !checkCreateNumber(val)); [EOL]         val = ".12.3"; [EOL]         assertTrue("isNumber(String) 4 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 4 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-123E"; [EOL]         assertTrue("isNumber(String) 5 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 5 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-123E+-212"; [EOL]         assertTrue("isNumber(String) 6 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 6 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-123E2.12"; [EOL]         assertTrue("isNumber(String) 7 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 7 Neg failed", !checkCreateNumber(val)); [EOL]         val = "0xGF"; [EOL]         assertTrue("isNumber(String) 8 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 8 Neg failed", !checkCreateNumber(val)); [EOL]         val = "0xFAE-1"; [EOL]         assertTrue("isNumber(String) 9 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 9 Neg failed", !checkCreateNumber(val)); [EOL]         val = "."; [EOL]         assertTrue("isNumber(String) 10 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 10 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-0ABC123"; [EOL]         assertTrue("isNumber(String) 11 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 11 Neg failed", !checkCreateNumber(val)); [EOL]         val = "123.4E-D"; [EOL]         assertTrue("isNumber(String) 12 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 12 Neg failed", !checkCreateNumber(val)); [EOL]         val = "123.4ED"; [EOL]         assertTrue("isNumber(String) 13 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 13 Neg failed", !checkCreateNumber(val)); [EOL]         val = "1234E5l"; [EOL]         assertTrue("isNumber(String) 14 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 14 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11a"; [EOL]         assertTrue("isNumber(String) 15 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 15 Neg failed", !checkCreateNumber(val)); [EOL]         val = "1a"; [EOL]         assertTrue("isNumber(String) 16 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 16 Neg failed", !checkCreateNumber(val)); [EOL]         val = "a"; [EOL]         assertTrue("isNumber(String) 17 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 17 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11g"; [EOL]         assertTrue("isNumber(String) 18 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 18 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11z"; [EOL]         assertTrue("isNumber(String) 19 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 19 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11def"; [EOL]         assertTrue("isNumber(String) 20 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 20 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11d11"; [EOL]         assertTrue("isNumber(String) 21 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 21 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11 11"; [EOL]         assertTrue("isNumber(String) 22 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 22 Neg failed", !checkCreateNumber(val)); [EOL]         val = " 1111"; [EOL]         assertTrue("isNumber(String) 23 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 23 Neg failed", !checkCreateNumber(val)); [EOL]         val = "1111 "; [EOL]         assertTrue("isNumber(String) 24 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 24 Neg failed", !checkCreateNumber(val)); [EOL]  [EOL]         // LANG-521 [EOL]         val = "2."; [EOL]         assertTrue("isNumber(String) LANG-521 failed", NumberUtils.isNumber(val)); [EOL]  [EOL]         // LANG-664 [EOL]         val = "1.1L"; [EOL]         assertFalse("isNumber(String) LANG-664 failed", NumberUtils.isNumber(val)); [EOL]     } [EOL]  [EOL]     private boolean checkCreateNumber(final String val) { [EOL]         try { [EOL]             final Object obj = NumberUtils.createNumber(val); [EOL]             if (obj == null) { [EOL]                 return false; [EOL]             } [EOL]             return true; [EOL]         } catch (final NumberFormatException e) { [EOL]             return false; [EOL]        } [EOL]     } [EOL]  [EOL]     @SuppressWarnings("cast") // suppress instanceof warning check [EOL]
@Test [EOL]     public void testCreateNumberMagnitude() { [EOL]         // Test Float.MAX_VALUE, and same with +1 in final digit to check conversion changes to next Number type [EOL]         assertEquals(Float.valueOf(Float.MAX_VALUE),  NumberUtils.createNumber("3.4028235e+38")); [EOL]         assertEquals(Double.valueOf(3.4028236e+38),   NumberUtils.createNumber("3.4028236e+38")); [EOL]  [EOL]         // Test Double.MAX_VALUE [EOL]         assertEquals(Double.valueOf(Double.MAX_VALUE),          NumberUtils.createNumber("1.7976931348623157e+308")); [EOL]         // Test with +2 in final digit (+1 does not cause roll-over to BigDecimal) [EOL]         assertEquals(new BigDecimal("1.7976931348623159e+308"), NumberUtils.createNumber("1.7976931348623159e+308")); [EOL]  [EOL]         assertEquals(Integer.valueOf(0x12345678), NumberUtils.createNumber("0x12345678")); [EOL]         assertEquals(Long.valueOf(0x123456789L),  NumberUtils.createNumber("0x123456789")); [EOL]  [EOL]         assertEquals(Long.valueOf(0x7fffffffffffffffL),      NumberUtils.createNumber("0x7fffffffffffffff")); [EOL]         // Does not appear to be a way to create a literal BigInteger of this magnitude [EOL]         assertEquals(new BigInteger("7fffffffffffffff0",16), NumberUtils.createNumber("0x7fffffffffffffff0")); [EOL]  [EOL]         assertEquals(Long.valueOf(0x7fffffffffffffffL),      NumberUtils.createNumber("#7fffffffffffffff")); [EOL]         assertEquals(new BigInteger("7fffffffffffffff0",16), NumberUtils.createNumber("#7fffffffffffffff0")); [EOL]  [EOL]         assertEquals(Integer.valueOf(017777777777), NumberUtils.createNumber("017777777777")); // 31 bits [EOL]         assertEquals(Long.valueOf(037777777777L),   NumberUtils.createNumber("037777777777")); // 32 bits [EOL]  [EOL]         assertEquals(Long.valueOf(0777777777777777777777L),      NumberUtils.createNumber("0777777777777777777777")); // 63 bits [EOL]         assertEquals(new BigInteger("1777777777777777777777",8), NumberUtils.createNumber("01777777777777777777777"));// 64 bits [EOL]     } [EOL]  [EOL]
@Test(expected=NumberFormatException.class) [EOL]     // Check that the code fails to create a valid number when both e and E are present (no decimal) [EOL]     public void testCreateNumberFailure_3() { [EOL]         NumberUtils.createNumber("-11E+0-7e00"); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsNumber() { [EOL]         String val = "12345"; [EOL]         assertTrue("isNumber(String) 1 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 1 failed", checkCreateNumber(val)); [EOL]         val = "1234.5"; [EOL]         assertTrue("isNumber(String) 2 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 2 failed", checkCreateNumber(val)); [EOL]         val = ".12345"; [EOL]         assertTrue("isNumber(String) 3 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 3 failed", checkCreateNumber(val)); [EOL]         val = "1234E5"; [EOL]         assertTrue("isNumber(String) 4 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 4 failed", checkCreateNumber(val)); [EOL]         val = "1234E+5"; [EOL]         assertTrue("isNumber(String) 5 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 5 failed", checkCreateNumber(val)); [EOL]         val = "1234E-5"; [EOL]         assertTrue("isNumber(String) 6 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 6 failed", checkCreateNumber(val)); [EOL]         val = "123.4E5"; [EOL]         assertTrue("isNumber(String) 7 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 7 failed", checkCreateNumber(val)); [EOL]         val = "-1234"; [EOL]         assertTrue("isNumber(String) 8 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 8 failed", checkCreateNumber(val)); [EOL]         val = "-1234.5"; [EOL]         assertTrue("isNumber(String) 9 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 9 failed", checkCreateNumber(val)); [EOL]         val = "-.12345"; [EOL]         assertTrue("isNumber(String) 10 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 10 failed", checkCreateNumber(val)); [EOL]         val = "-1234E5"; [EOL]         assertTrue("isNumber(String) 11 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 11 failed", checkCreateNumber(val)); [EOL]         val = "0"; [EOL]         assertTrue("isNumber(String) 12 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 12 failed", checkCreateNumber(val)); [EOL]         val = "-0"; [EOL]         assertTrue("isNumber(String) 13 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 13 failed", checkCreateNumber(val)); [EOL]         val = "01234"; [EOL]         assertTrue("isNumber(String) 14 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 14 failed", checkCreateNumber(val)); [EOL]         val = "-01234"; [EOL]         assertTrue("isNumber(String) 15 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 15 failed", checkCreateNumber(val)); [EOL]         val = "0xABC123"; [EOL]         assertTrue("isNumber(String) 16 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 16 failed", checkCreateNumber(val)); [EOL]         val = "0x0"; [EOL]         assertTrue("isNumber(String) 17 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 17 failed", checkCreateNumber(val)); [EOL]         val = "123.4E21D"; [EOL]         assertTrue("isNumber(String) 19 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 19 failed", checkCreateNumber(val)); [EOL]         val = "-221.23F"; [EOL]         assertTrue("isNumber(String) 20 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 20 failed", checkCreateNumber(val)); [EOL]         val = "22338L"; [EOL]         assertTrue("isNumber(String) 21 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 21 failed", checkCreateNumber(val)); [EOL]         val = null; [EOL]         assertTrue("isNumber(String) 1 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 1 Neg failed", !checkCreateNumber(val)); [EOL]         val = ""; [EOL]         assertTrue("isNumber(String) 2 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 2 Neg failed", !checkCreateNumber(val)); [EOL]         val = "--2.3"; [EOL]         assertTrue("isNumber(String) 3 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 3 Neg failed", !checkCreateNumber(val)); [EOL]         val = ".12.3"; [EOL]         assertTrue("isNumber(String) 4 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 4 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-123E"; [EOL]         assertTrue("isNumber(String) 5 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 5 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-123E+-212"; [EOL]         assertTrue("isNumber(String) 6 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 6 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-123E2.12"; [EOL]         assertTrue("isNumber(String) 7 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 7 Neg failed", !checkCreateNumber(val)); [EOL]         val = "0xGF"; [EOL]         assertTrue("isNumber(String) 8 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 8 Neg failed", !checkCreateNumber(val)); [EOL]         val = "0xFAE-1"; [EOL]         assertTrue("isNumber(String) 9 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 9 Neg failed", !checkCreateNumber(val)); [EOL]         val = "."; [EOL]         assertTrue("isNumber(String) 10 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 10 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-0ABC123"; [EOL]         assertTrue("isNumber(String) 11 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 11 Neg failed", !checkCreateNumber(val)); [EOL]         val = "123.4E-D"; [EOL]         assertTrue("isNumber(String) 12 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 12 Neg failed", !checkCreateNumber(val)); [EOL]         val = "123.4ED"; [EOL]         assertTrue("isNumber(String) 13 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 13 Neg failed", !checkCreateNumber(val)); [EOL]         val = "1234E5l"; [EOL]         assertTrue("isNumber(String) 14 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 14 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11a"; [EOL]         assertTrue("isNumber(String) 15 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 15 Neg failed", !checkCreateNumber(val)); [EOL]         val = "1a"; [EOL]         assertTrue("isNumber(String) 16 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 16 Neg failed", !checkCreateNumber(val)); [EOL]         val = "a"; [EOL]         assertTrue("isNumber(String) 17 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 17 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11g"; [EOL]         assertTrue("isNumber(String) 18 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 18 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11z"; [EOL]         assertTrue("isNumber(String) 19 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 19 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11def"; [EOL]         assertTrue("isNumber(String) 20 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 20 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11d11"; [EOL]         assertTrue("isNumber(String) 21 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 21 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11 11"; [EOL]         assertTrue("isNumber(String) 22 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 22 Neg failed", !checkCreateNumber(val)); [EOL]         val = " 1111"; [EOL]         assertTrue("isNumber(String) 23 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 23 Neg failed", !checkCreateNumber(val)); [EOL]         val = "1111 "; [EOL]         assertTrue("isNumber(String) 24 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 24 Neg failed", !checkCreateNumber(val)); [EOL]  [EOL]         // LANG-521 [EOL]         val = "2."; [EOL]         assertTrue("isNumber(String) LANG-521 failed", NumberUtils.isNumber(val)); [EOL]  [EOL]         // LANG-664 [EOL]         val = "1.1L"; [EOL]         assertFalse("isNumber(String) LANG-664 failed", NumberUtils.isNumber(val)); [EOL]     } [EOL]  [EOL]     private boolean checkCreateNumber(final String val) { [EOL]         try { [EOL]             final Object obj = NumberUtils.createNumber(val); [EOL]             if (obj == null) { [EOL]                 return false; [EOL]             } [EOL]             return true; [EOL]         } catch (final NumberFormatException e) { [EOL]             return false; [EOL]        } [EOL]     } [EOL]  [EOL]     @SuppressWarnings("cast") // suppress instanceof warning check [EOL]
@Test [EOL]     public void testIsNumber() { [EOL]         String val = "12345"; [EOL]         assertTrue("isNumber(String) 1 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 1 failed", checkCreateNumber(val)); [EOL]         val = "1234.5"; [EOL]         assertTrue("isNumber(String) 2 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 2 failed", checkCreateNumber(val)); [EOL]         val = ".12345"; [EOL]         assertTrue("isNumber(String) 3 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 3 failed", checkCreateNumber(val)); [EOL]         val = "1234E5"; [EOL]         assertTrue("isNumber(String) 4 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 4 failed", checkCreateNumber(val)); [EOL]         val = "1234E+5"; [EOL]         assertTrue("isNumber(String) 5 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 5 failed", checkCreateNumber(val)); [EOL]         val = "1234E-5"; [EOL]         assertTrue("isNumber(String) 6 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 6 failed", checkCreateNumber(val)); [EOL]         val = "123.4E5"; [EOL]         assertTrue("isNumber(String) 7 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 7 failed", checkCreateNumber(val)); [EOL]         val = "-1234"; [EOL]         assertTrue("isNumber(String) 8 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 8 failed", checkCreateNumber(val)); [EOL]         val = "-1234.5"; [EOL]         assertTrue("isNumber(String) 9 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 9 failed", checkCreateNumber(val)); [EOL]         val = "-.12345"; [EOL]         assertTrue("isNumber(String) 10 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 10 failed", checkCreateNumber(val)); [EOL]         val = "-1234E5"; [EOL]         assertTrue("isNumber(String) 11 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 11 failed", checkCreateNumber(val)); [EOL]         val = "0"; [EOL]         assertTrue("isNumber(String) 12 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 12 failed", checkCreateNumber(val)); [EOL]         val = "-0"; [EOL]         assertTrue("isNumber(String) 13 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 13 failed", checkCreateNumber(val)); [EOL]         val = "01234"; [EOL]         assertTrue("isNumber(String) 14 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 14 failed", checkCreateNumber(val)); [EOL]         val = "-01234"; [EOL]         assertTrue("isNumber(String) 15 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 15 failed", checkCreateNumber(val)); [EOL]         val = "0xABC123"; [EOL]         assertTrue("isNumber(String) 16 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 16 failed", checkCreateNumber(val)); [EOL]         val = "0x0"; [EOL]         assertTrue("isNumber(String) 17 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 17 failed", checkCreateNumber(val)); [EOL]         val = "123.4E21D"; [EOL]         assertTrue("isNumber(String) 19 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 19 failed", checkCreateNumber(val)); [EOL]         val = "-221.23F"; [EOL]         assertTrue("isNumber(String) 20 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 20 failed", checkCreateNumber(val)); [EOL]         val = "22338L"; [EOL]         assertTrue("isNumber(String) 21 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 21 failed", checkCreateNumber(val)); [EOL]         val = null; [EOL]         assertTrue("isNumber(String) 1 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 1 Neg failed", !checkCreateNumber(val)); [EOL]         val = ""; [EOL]         assertTrue("isNumber(String) 2 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 2 Neg failed", !checkCreateNumber(val)); [EOL]         val = "--2.3"; [EOL]         assertTrue("isNumber(String) 3 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 3 Neg failed", !checkCreateNumber(val)); [EOL]         val = ".12.3"; [EOL]         assertTrue("isNumber(String) 4 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 4 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-123E"; [EOL]         assertTrue("isNumber(String) 5 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 5 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-123E+-212"; [EOL]         assertTrue("isNumber(String) 6 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 6 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-123E2.12"; [EOL]         assertTrue("isNumber(String) 7 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 7 Neg failed", !checkCreateNumber(val)); [EOL]         val = "0xGF"; [EOL]         assertTrue("isNumber(String) 8 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 8 Neg failed", !checkCreateNumber(val)); [EOL]         val = "0xFAE-1"; [EOL]         assertTrue("isNumber(String) 9 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 9 Neg failed", !checkCreateNumber(val)); [EOL]         val = "."; [EOL]         assertTrue("isNumber(String) 10 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 10 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-0ABC123"; [EOL]         assertTrue("isNumber(String) 11 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 11 Neg failed", !checkCreateNumber(val)); [EOL]         val = "123.4E-D"; [EOL]         assertTrue("isNumber(String) 12 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 12 Neg failed", !checkCreateNumber(val)); [EOL]         val = "123.4ED"; [EOL]         assertTrue("isNumber(String) 13 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 13 Neg failed", !checkCreateNumber(val)); [EOL]         val = "1234E5l"; [EOL]         assertTrue("isNumber(String) 14 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 14 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11a"; [EOL]         assertTrue("isNumber(String) 15 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 15 Neg failed", !checkCreateNumber(val)); [EOL]         val = "1a"; [EOL]         assertTrue("isNumber(String) 16 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 16 Neg failed", !checkCreateNumber(val)); [EOL]         val = "a"; [EOL]         assertTrue("isNumber(String) 17 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 17 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11g"; [EOL]         assertTrue("isNumber(String) 18 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 18 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11z"; [EOL]         assertTrue("isNumber(String) 19 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 19 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11def"; [EOL]         assertTrue("isNumber(String) 20 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 20 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11d11"; [EOL]         assertTrue("isNumber(String) 21 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 21 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11 11"; [EOL]         assertTrue("isNumber(String) 22 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 22 Neg failed", !checkCreateNumber(val)); [EOL]         val = " 1111"; [EOL]         assertTrue("isNumber(String) 23 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 23 Neg failed", !checkCreateNumber(val)); [EOL]         val = "1111 "; [EOL]         assertTrue("isNumber(String) 24 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 24 Neg failed", !checkCreateNumber(val)); [EOL]  [EOL]         // LANG-521 [EOL]         val = "2."; [EOL]         assertTrue("isNumber(String) LANG-521 failed", NumberUtils.isNumber(val)); [EOL]  [EOL]         // LANG-664 [EOL]         val = "1.1L"; [EOL]         assertFalse("isNumber(String) LANG-664 failed", NumberUtils.isNumber(val)); [EOL]     } [EOL]  [EOL]     private boolean checkCreateNumber(final String val) { [EOL]         try { [EOL]             final Object obj = NumberUtils.createNumber(val); [EOL]             if (obj == null) { [EOL]                 return false; [EOL]             } [EOL]             return true; [EOL]         } catch (final NumberFormatException e) { [EOL]             return false; [EOL]        } [EOL]     } [EOL]  [EOL]     @SuppressWarnings("cast") // suppress instanceof warning check [EOL]
@Test [EOL]     public void testIsNumber() { [EOL]         String val = "12345"; [EOL]         assertTrue("isNumber(String) 1 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 1 failed", checkCreateNumber(val)); [EOL]         val = "1234.5"; [EOL]         assertTrue("isNumber(String) 2 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 2 failed", checkCreateNumber(val)); [EOL]         val = ".12345"; [EOL]         assertTrue("isNumber(String) 3 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 3 failed", checkCreateNumber(val)); [EOL]         val = "1234E5"; [EOL]         assertTrue("isNumber(String) 4 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 4 failed", checkCreateNumber(val)); [EOL]         val = "1234E+5"; [EOL]         assertTrue("isNumber(String) 5 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 5 failed", checkCreateNumber(val)); [EOL]         val = "1234E-5"; [EOL]         assertTrue("isNumber(String) 6 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 6 failed", checkCreateNumber(val)); [EOL]         val = "123.4E5"; [EOL]         assertTrue("isNumber(String) 7 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 7 failed", checkCreateNumber(val)); [EOL]         val = "-1234"; [EOL]         assertTrue("isNumber(String) 8 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 8 failed", checkCreateNumber(val)); [EOL]         val = "-1234.5"; [EOL]         assertTrue("isNumber(String) 9 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 9 failed", checkCreateNumber(val)); [EOL]         val = "-.12345"; [EOL]         assertTrue("isNumber(String) 10 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 10 failed", checkCreateNumber(val)); [EOL]         val = "-1234E5"; [EOL]         assertTrue("isNumber(String) 11 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 11 failed", checkCreateNumber(val)); [EOL]         val = "0"; [EOL]         assertTrue("isNumber(String) 12 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 12 failed", checkCreateNumber(val)); [EOL]         val = "-0"; [EOL]         assertTrue("isNumber(String) 13 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 13 failed", checkCreateNumber(val)); [EOL]         val = "01234"; [EOL]         assertTrue("isNumber(String) 14 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 14 failed", checkCreateNumber(val)); [EOL]         val = "-01234"; [EOL]         assertTrue("isNumber(String) 15 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 15 failed", checkCreateNumber(val)); [EOL]         val = "0xABC123"; [EOL]         assertTrue("isNumber(String) 16 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 16 failed", checkCreateNumber(val)); [EOL]         val = "0x0"; [EOL]         assertTrue("isNumber(String) 17 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 17 failed", checkCreateNumber(val)); [EOL]         val = "123.4E21D"; [EOL]         assertTrue("isNumber(String) 19 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 19 failed", checkCreateNumber(val)); [EOL]         val = "-221.23F"; [EOL]         assertTrue("isNumber(String) 20 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 20 failed", checkCreateNumber(val)); [EOL]         val = "22338L"; [EOL]         assertTrue("isNumber(String) 21 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 21 failed", checkCreateNumber(val)); [EOL]         val = null; [EOL]         assertTrue("isNumber(String) 1 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 1 Neg failed", !checkCreateNumber(val)); [EOL]         val = ""; [EOL]         assertTrue("isNumber(String) 2 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 2 Neg failed", !checkCreateNumber(val)); [EOL]         val = "--2.3"; [EOL]         assertTrue("isNumber(String) 3 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 3 Neg failed", !checkCreateNumber(val)); [EOL]         val = ".12.3"; [EOL]         assertTrue("isNumber(String) 4 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 4 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-123E"; [EOL]         assertTrue("isNumber(String) 5 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 5 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-123E+-212"; [EOL]         assertTrue("isNumber(String) 6 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 6 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-123E2.12"; [EOL]         assertTrue("isNumber(String) 7 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 7 Neg failed", !checkCreateNumber(val)); [EOL]         val = "0xGF"; [EOL]         assertTrue("isNumber(String) 8 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 8 Neg failed", !checkCreateNumber(val)); [EOL]         val = "0xFAE-1"; [EOL]         assertTrue("isNumber(String) 9 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 9 Neg failed", !checkCreateNumber(val)); [EOL]         val = "."; [EOL]         assertTrue("isNumber(String) 10 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 10 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-0ABC123"; [EOL]         assertTrue("isNumber(String) 11 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 11 Neg failed", !checkCreateNumber(val)); [EOL]         val = "123.4E-D"; [EOL]         assertTrue("isNumber(String) 12 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 12 Neg failed", !checkCreateNumber(val)); [EOL]         val = "123.4ED"; [EOL]         assertTrue("isNumber(String) 13 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 13 Neg failed", !checkCreateNumber(val)); [EOL]         val = "1234E5l"; [EOL]         assertTrue("isNumber(String) 14 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 14 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11a"; [EOL]         assertTrue("isNumber(String) 15 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 15 Neg failed", !checkCreateNumber(val)); [EOL]         val = "1a"; [EOL]         assertTrue("isNumber(String) 16 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 16 Neg failed", !checkCreateNumber(val)); [EOL]         val = "a"; [EOL]         assertTrue("isNumber(String) 17 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 17 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11g"; [EOL]         assertTrue("isNumber(String) 18 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 18 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11z"; [EOL]         assertTrue("isNumber(String) 19 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 19 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11def"; [EOL]         assertTrue("isNumber(String) 20 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 20 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11d11"; [EOL]         assertTrue("isNumber(String) 21 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 21 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11 11"; [EOL]         assertTrue("isNumber(String) 22 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 22 Neg failed", !checkCreateNumber(val)); [EOL]         val = " 1111"; [EOL]         assertTrue("isNumber(String) 23 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 23 Neg failed", !checkCreateNumber(val)); [EOL]         val = "1111 "; [EOL]         assertTrue("isNumber(String) 24 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 24 Neg failed", !checkCreateNumber(val)); [EOL]  [EOL]         // LANG-521 [EOL]         val = "2."; [EOL]         assertTrue("isNumber(String) LANG-521 failed", NumberUtils.isNumber(val)); [EOL]  [EOL]         // LANG-664 [EOL]         val = "1.1L"; [EOL]         assertFalse("isNumber(String) LANG-664 failed", NumberUtils.isNumber(val)); [EOL]     } [EOL]  [EOL]     private boolean checkCreateNumber(final String val) { [EOL]         try { [EOL]             final Object obj = NumberUtils.createNumber(val); [EOL]             if (obj == null) { [EOL]                 return false; [EOL]             } [EOL]             return true; [EOL]         } catch (final NumberFormatException e) { [EOL]             return false; [EOL]        } [EOL]     } [EOL]  [EOL]     @SuppressWarnings("cast") // suppress instanceof warning check [EOL]
@Test [EOL]     public void testCreateNumber() { [EOL]         // a lot of things can go wrong [EOL]         assertEquals("createNumber(String) 1 failed", Float.valueOf("1234.5"), NumberUtils.createNumber("1234.5")); [EOL]         assertEquals("createNumber(String) 2 failed", Integer.valueOf("12345"), NumberUtils.createNumber("12345")); [EOL]         assertEquals("createNumber(String) 3 failed", Double.valueOf("1234.5"), NumberUtils.createNumber("1234.5D")); [EOL]         assertEquals("createNumber(String) 3 failed", Double.valueOf("1234.5"), NumberUtils.createNumber("1234.5d")); [EOL]         assertEquals("createNumber(String) 4 failed", Float.valueOf("1234.5"), NumberUtils.createNumber("1234.5F")); [EOL]         assertEquals("createNumber(String) 4 failed", Float.valueOf("1234.5"), NumberUtils.createNumber("1234.5f")); [EOL]         assertEquals("createNumber(String) 5 failed", Long.valueOf(Integer.MAX_VALUE + 1L), NumberUtils.createNumber("" [EOL]             + (Integer.MAX_VALUE + 1L))); [EOL]         assertEquals("createNumber(String) 6 failed", Long.valueOf(12345), NumberUtils.createNumber("12345L")); [EOL]         assertEquals("createNumber(String) 6 failed", Long.valueOf(12345), NumberUtils.createNumber("12345l")); [EOL]         assertEquals("createNumber(String) 7 failed", Float.valueOf("-1234.5"), NumberUtils.createNumber("-1234.5")); [EOL]         assertEquals("createNumber(String) 8 failed", Integer.valueOf("-12345"), NumberUtils.createNumber("-12345")); [EOL]         assertTrue("createNumber(String) 9a failed", 0xFADE == NumberUtils.createNumber("0xFADE").intValue()); [EOL]         assertTrue("createNumber(String) 9b failed", 0xFADE == NumberUtils.createNumber("0Xfade").intValue()); [EOL]         assertTrue("createNumber(String) 10a failed", -0xFADE == NumberUtils.createNumber("-0xFADE").intValue()); [EOL]         assertTrue("createNumber(String) 10b failed", -0xFADE == NumberUtils.createNumber("-0Xfade").intValue()); [EOL]         assertEquals("createNumber(String) 11 failed", Double.valueOf("1.1E200"), NumberUtils.createNumber("1.1E200")); [EOL]         assertEquals("createNumber(String) 12 failed", Float.valueOf("1.1E20"), NumberUtils.createNumber("1.1E20")); [EOL]         assertEquals("createNumber(String) 13 failed", Double.valueOf("-1.1E200"), NumberUtils.createNumber("-1.1E200")); [EOL]         assertEquals("createNumber(String) 14 failed", Double.valueOf("1.1E-200"), NumberUtils.createNumber("1.1E-200")); [EOL]         assertEquals("createNumber(null) failed", null, NumberUtils.createNumber(null)); [EOL]         assertEquals("createNumber(String) failed", new BigInteger("12345678901234567890"), NumberUtils [EOL]                 .createNumber("12345678901234567890L")); [EOL]  [EOL]         assertEquals("createNumber(String) 15 failed", new BigDecimal("1.1E-700"), NumberUtils [EOL]                     .createNumber("1.1E-700F")); [EOL]  [EOL]         assertEquals("createNumber(String) 16 failed", Long.valueOf("10" + Integer.MAX_VALUE), NumberUtils [EOL]                 .createNumber("10" + Integer.MAX_VALUE + "L")); [EOL]         assertEquals("createNumber(String) 17 failed", Long.valueOf("10" + Integer.MAX_VALUE), NumberUtils [EOL]                 .createNumber("10" + Integer.MAX_VALUE)); [EOL]         assertEquals("createNumber(String) 18 failed", new BigInteger("10" + Long.MAX_VALUE), NumberUtils [EOL]                 .createNumber("10" + Long.MAX_VALUE)); [EOL]  [EOL]         // LANG-521 [EOL]         assertEquals("createNumber(String) LANG-521 failed", Float.valueOf("2."), NumberUtils.createNumber("2.")); [EOL]  [EOL]         // LANG-638 [EOL]         assertFalse("createNumber(String) succeeded", checkCreateNumber("1eE")); [EOL]  [EOL]         // LANG-693 [EOL]         assertEquals("createNumber(String) LANG-693 failed", Double.valueOf(Double.MAX_VALUE), NumberUtils [EOL]                     .createNumber("" + Double.MAX_VALUE)); [EOL]  [EOL]         // LANG-822 [EOL]         // ensure that the underlying negative number would create a BigDecimal [EOL]         final Number bigNum = NumberUtils.createNumber("-1.1E-700F"); [EOL]         assertNotNull(bigNum); [EOL]         assertEquals(BigDecimal.class, bigNum.getClass()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsNumber() { [EOL]         String val = "12345"; [EOL]         assertTrue("isNumber(String) 1 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 1 failed", checkCreateNumber(val)); [EOL]         val = "1234.5"; [EOL]         assertTrue("isNumber(String) 2 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 2 failed", checkCreateNumber(val)); [EOL]         val = ".12345"; [EOL]         assertTrue("isNumber(String) 3 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 3 failed", checkCreateNumber(val)); [EOL]         val = "1234E5"; [EOL]         assertTrue("isNumber(String) 4 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 4 failed", checkCreateNumber(val)); [EOL]         val = "1234E+5"; [EOL]         assertTrue("isNumber(String) 5 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 5 failed", checkCreateNumber(val)); [EOL]         val = "1234E-5"; [EOL]         assertTrue("isNumber(String) 6 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 6 failed", checkCreateNumber(val)); [EOL]         val = "123.4E5"; [EOL]         assertTrue("isNumber(String) 7 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 7 failed", checkCreateNumber(val)); [EOL]         val = "-1234"; [EOL]         assertTrue("isNumber(String) 8 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 8 failed", checkCreateNumber(val)); [EOL]         val = "-1234.5"; [EOL]         assertTrue("isNumber(String) 9 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 9 failed", checkCreateNumber(val)); [EOL]         val = "-.12345"; [EOL]         assertTrue("isNumber(String) 10 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 10 failed", checkCreateNumber(val)); [EOL]         val = "-1234E5"; [EOL]         assertTrue("isNumber(String) 11 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 11 failed", checkCreateNumber(val)); [EOL]         val = "0"; [EOL]         assertTrue("isNumber(String) 12 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 12 failed", checkCreateNumber(val)); [EOL]         val = "-0"; [EOL]         assertTrue("isNumber(String) 13 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 13 failed", checkCreateNumber(val)); [EOL]         val = "01234"; [EOL]         assertTrue("isNumber(String) 14 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 14 failed", checkCreateNumber(val)); [EOL]         val = "-01234"; [EOL]         assertTrue("isNumber(String) 15 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 15 failed", checkCreateNumber(val)); [EOL]         val = "0xABC123"; [EOL]         assertTrue("isNumber(String) 16 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 16 failed", checkCreateNumber(val)); [EOL]         val = "0x0"; [EOL]         assertTrue("isNumber(String) 17 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 17 failed", checkCreateNumber(val)); [EOL]         val = "123.4E21D"; [EOL]         assertTrue("isNumber(String) 19 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 19 failed", checkCreateNumber(val)); [EOL]         val = "-221.23F"; [EOL]         assertTrue("isNumber(String) 20 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 20 failed", checkCreateNumber(val)); [EOL]         val = "22338L"; [EOL]         assertTrue("isNumber(String) 21 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 21 failed", checkCreateNumber(val)); [EOL]         val = null; [EOL]         assertTrue("isNumber(String) 1 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 1 Neg failed", !checkCreateNumber(val)); [EOL]         val = ""; [EOL]         assertTrue("isNumber(String) 2 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 2 Neg failed", !checkCreateNumber(val)); [EOL]         val = "--2.3"; [EOL]         assertTrue("isNumber(String) 3 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 3 Neg failed", !checkCreateNumber(val)); [EOL]         val = ".12.3"; [EOL]         assertTrue("isNumber(String) 4 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 4 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-123E"; [EOL]         assertTrue("isNumber(String) 5 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 5 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-123E+-212"; [EOL]         assertTrue("isNumber(String) 6 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 6 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-123E2.12"; [EOL]         assertTrue("isNumber(String) 7 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 7 Neg failed", !checkCreateNumber(val)); [EOL]         val = "0xGF"; [EOL]         assertTrue("isNumber(String) 8 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 8 Neg failed", !checkCreateNumber(val)); [EOL]         val = "0xFAE-1"; [EOL]         assertTrue("isNumber(String) 9 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 9 Neg failed", !checkCreateNumber(val)); [EOL]         val = "."; [EOL]         assertTrue("isNumber(String) 10 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 10 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-0ABC123"; [EOL]         assertTrue("isNumber(String) 11 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 11 Neg failed", !checkCreateNumber(val)); [EOL]         val = "123.4E-D"; [EOL]         assertTrue("isNumber(String) 12 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 12 Neg failed", !checkCreateNumber(val)); [EOL]         val = "123.4ED"; [EOL]         assertTrue("isNumber(String) 13 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 13 Neg failed", !checkCreateNumber(val)); [EOL]         val = "1234E5l"; [EOL]         assertTrue("isNumber(String) 14 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 14 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11a"; [EOL]         assertTrue("isNumber(String) 15 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 15 Neg failed", !checkCreateNumber(val)); [EOL]         val = "1a"; [EOL]         assertTrue("isNumber(String) 16 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 16 Neg failed", !checkCreateNumber(val)); [EOL]         val = "a"; [EOL]         assertTrue("isNumber(String) 17 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 17 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11g"; [EOL]         assertTrue("isNumber(String) 18 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 18 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11z"; [EOL]         assertTrue("isNumber(String) 19 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 19 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11def"; [EOL]         assertTrue("isNumber(String) 20 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 20 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11d11"; [EOL]         assertTrue("isNumber(String) 21 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 21 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11 11"; [EOL]         assertTrue("isNumber(String) 22 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 22 Neg failed", !checkCreateNumber(val)); [EOL]         val = " 1111"; [EOL]         assertTrue("isNumber(String) 23 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 23 Neg failed", !checkCreateNumber(val)); [EOL]         val = "1111 "; [EOL]         assertTrue("isNumber(String) 24 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 24 Neg failed", !checkCreateNumber(val)); [EOL]  [EOL]         // LANG-521 [EOL]         val = "2."; [EOL]         assertTrue("isNumber(String) LANG-521 failed", NumberUtils.isNumber(val)); [EOL]  [EOL]         // LANG-664 [EOL]         val = "1.1L"; [EOL]         assertFalse("isNumber(String) LANG-664 failed", NumberUtils.isNumber(val)); [EOL]     } [EOL]  [EOL]     private boolean checkCreateNumber(final String val) { [EOL]         try { [EOL]             final Object obj = NumberUtils.createNumber(val); [EOL]             if (obj == null) { [EOL]                 return false; [EOL]             } [EOL]             return true; [EOL]         } catch (final NumberFormatException e) { [EOL]             return false; [EOL]        } [EOL]     } [EOL]  [EOL]     @SuppressWarnings("cast") // suppress instanceof warning check [EOL]
@Test [EOL]     public void testIsNumber() { [EOL]         String val = "12345"; [EOL]         assertTrue("isNumber(String) 1 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 1 failed", checkCreateNumber(val)); [EOL]         val = "1234.5"; [EOL]         assertTrue("isNumber(String) 2 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 2 failed", checkCreateNumber(val)); [EOL]         val = ".12345"; [EOL]         assertTrue("isNumber(String) 3 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 3 failed", checkCreateNumber(val)); [EOL]         val = "1234E5"; [EOL]         assertTrue("isNumber(String) 4 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 4 failed", checkCreateNumber(val)); [EOL]         val = "1234E+5"; [EOL]         assertTrue("isNumber(String) 5 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 5 failed", checkCreateNumber(val)); [EOL]         val = "1234E-5"; [EOL]         assertTrue("isNumber(String) 6 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 6 failed", checkCreateNumber(val)); [EOL]         val = "123.4E5"; [EOL]         assertTrue("isNumber(String) 7 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 7 failed", checkCreateNumber(val)); [EOL]         val = "-1234"; [EOL]         assertTrue("isNumber(String) 8 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 8 failed", checkCreateNumber(val)); [EOL]         val = "-1234.5"; [EOL]         assertTrue("isNumber(String) 9 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 9 failed", checkCreateNumber(val)); [EOL]         val = "-.12345"; [EOL]         assertTrue("isNumber(String) 10 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 10 failed", checkCreateNumber(val)); [EOL]         val = "-1234E5"; [EOL]         assertTrue("isNumber(String) 11 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 11 failed", checkCreateNumber(val)); [EOL]         val = "0"; [EOL]         assertTrue("isNumber(String) 12 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 12 failed", checkCreateNumber(val)); [EOL]         val = "-0"; [EOL]         assertTrue("isNumber(String) 13 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 13 failed", checkCreateNumber(val)); [EOL]         val = "01234"; [EOL]         assertTrue("isNumber(String) 14 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 14 failed", checkCreateNumber(val)); [EOL]         val = "-01234"; [EOL]         assertTrue("isNumber(String) 15 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 15 failed", checkCreateNumber(val)); [EOL]         val = "0xABC123"; [EOL]         assertTrue("isNumber(String) 16 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 16 failed", checkCreateNumber(val)); [EOL]         val = "0x0"; [EOL]         assertTrue("isNumber(String) 17 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 17 failed", checkCreateNumber(val)); [EOL]         val = "123.4E21D"; [EOL]         assertTrue("isNumber(String) 19 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 19 failed", checkCreateNumber(val)); [EOL]         val = "-221.23F"; [EOL]         assertTrue("isNumber(String) 20 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 20 failed", checkCreateNumber(val)); [EOL]         val = "22338L"; [EOL]         assertTrue("isNumber(String) 21 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 21 failed", checkCreateNumber(val)); [EOL]         val = null; [EOL]         assertTrue("isNumber(String) 1 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 1 Neg failed", !checkCreateNumber(val)); [EOL]         val = ""; [EOL]         assertTrue("isNumber(String) 2 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 2 Neg failed", !checkCreateNumber(val)); [EOL]         val = "--2.3"; [EOL]         assertTrue("isNumber(String) 3 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 3 Neg failed", !checkCreateNumber(val)); [EOL]         val = ".12.3"; [EOL]         assertTrue("isNumber(String) 4 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 4 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-123E"; [EOL]         assertTrue("isNumber(String) 5 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 5 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-123E+-212"; [EOL]         assertTrue("isNumber(String) 6 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 6 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-123E2.12"; [EOL]         assertTrue("isNumber(String) 7 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 7 Neg failed", !checkCreateNumber(val)); [EOL]         val = "0xGF"; [EOL]         assertTrue("isNumber(String) 8 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 8 Neg failed", !checkCreateNumber(val)); [EOL]         val = "0xFAE-1"; [EOL]         assertTrue("isNumber(String) 9 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 9 Neg failed", !checkCreateNumber(val)); [EOL]         val = "."; [EOL]         assertTrue("isNumber(String) 10 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 10 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-0ABC123"; [EOL]         assertTrue("isNumber(String) 11 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 11 Neg failed", !checkCreateNumber(val)); [EOL]         val = "123.4E-D"; [EOL]         assertTrue("isNumber(String) 12 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 12 Neg failed", !checkCreateNumber(val)); [EOL]         val = "123.4ED"; [EOL]         assertTrue("isNumber(String) 13 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 13 Neg failed", !checkCreateNumber(val)); [EOL]         val = "1234E5l"; [EOL]         assertTrue("isNumber(String) 14 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 14 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11a"; [EOL]         assertTrue("isNumber(String) 15 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 15 Neg failed", !checkCreateNumber(val)); [EOL]         val = "1a"; [EOL]         assertTrue("isNumber(String) 16 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 16 Neg failed", !checkCreateNumber(val)); [EOL]         val = "a"; [EOL]         assertTrue("isNumber(String) 17 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 17 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11g"; [EOL]         assertTrue("isNumber(String) 18 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 18 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11z"; [EOL]         assertTrue("isNumber(String) 19 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 19 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11def"; [EOL]         assertTrue("isNumber(String) 20 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 20 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11d11"; [EOL]         assertTrue("isNumber(String) 21 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 21 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11 11"; [EOL]         assertTrue("isNumber(String) 22 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 22 Neg failed", !checkCreateNumber(val)); [EOL]         val = " 1111"; [EOL]         assertTrue("isNumber(String) 23 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 23 Neg failed", !checkCreateNumber(val)); [EOL]         val = "1111 "; [EOL]         assertTrue("isNumber(String) 24 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 24 Neg failed", !checkCreateNumber(val)); [EOL]  [EOL]         // LANG-521 [EOL]         val = "2."; [EOL]         assertTrue("isNumber(String) LANG-521 failed", NumberUtils.isNumber(val)); [EOL]  [EOL]         // LANG-664 [EOL]         val = "1.1L"; [EOL]         assertFalse("isNumber(String) LANG-664 failed", NumberUtils.isNumber(val)); [EOL]     } [EOL]  [EOL]     private boolean checkCreateNumber(final String val) { [EOL]         try { [EOL]             final Object obj = NumberUtils.createNumber(val); [EOL]             if (obj == null) { [EOL]                 return false; [EOL]             } [EOL]             return true; [EOL]         } catch (final NumberFormatException e) { [EOL]             return false; [EOL]        } [EOL]     } [EOL]  [EOL]     @SuppressWarnings("cast") // suppress instanceof warning check [EOL]
@Test [EOL]     public void testIsNumber() { [EOL]         String val = "12345"; [EOL]         assertTrue("isNumber(String) 1 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 1 failed", checkCreateNumber(val)); [EOL]         val = "1234.5"; [EOL]         assertTrue("isNumber(String) 2 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 2 failed", checkCreateNumber(val)); [EOL]         val = ".12345"; [EOL]         assertTrue("isNumber(String) 3 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 3 failed", checkCreateNumber(val)); [EOL]         val = "1234E5"; [EOL]         assertTrue("isNumber(String) 4 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 4 failed", checkCreateNumber(val)); [EOL]         val = "1234E+5"; [EOL]         assertTrue("isNumber(String) 5 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 5 failed", checkCreateNumber(val)); [EOL]         val = "1234E-5"; [EOL]         assertTrue("isNumber(String) 6 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 6 failed", checkCreateNumber(val)); [EOL]         val = "123.4E5"; [EOL]         assertTrue("isNumber(String) 7 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 7 failed", checkCreateNumber(val)); [EOL]         val = "-1234"; [EOL]         assertTrue("isNumber(String) 8 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 8 failed", checkCreateNumber(val)); [EOL]         val = "-1234.5"; [EOL]         assertTrue("isNumber(String) 9 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 9 failed", checkCreateNumber(val)); [EOL]         val = "-.12345"; [EOL]         assertTrue("isNumber(String) 10 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 10 failed", checkCreateNumber(val)); [EOL]         val = "-1234E5"; [EOL]         assertTrue("isNumber(String) 11 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 11 failed", checkCreateNumber(val)); [EOL]         val = "0"; [EOL]         assertTrue("isNumber(String) 12 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 12 failed", checkCreateNumber(val)); [EOL]         val = "-0"; [EOL]         assertTrue("isNumber(String) 13 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 13 failed", checkCreateNumber(val)); [EOL]         val = "01234"; [EOL]         assertTrue("isNumber(String) 14 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 14 failed", checkCreateNumber(val)); [EOL]         val = "-01234"; [EOL]         assertTrue("isNumber(String) 15 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 15 failed", checkCreateNumber(val)); [EOL]         val = "0xABC123"; [EOL]         assertTrue("isNumber(String) 16 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 16 failed", checkCreateNumber(val)); [EOL]         val = "0x0"; [EOL]         assertTrue("isNumber(String) 17 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 17 failed", checkCreateNumber(val)); [EOL]         val = "123.4E21D"; [EOL]         assertTrue("isNumber(String) 19 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 19 failed", checkCreateNumber(val)); [EOL]         val = "-221.23F"; [EOL]         assertTrue("isNumber(String) 20 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 20 failed", checkCreateNumber(val)); [EOL]         val = "22338L"; [EOL]         assertTrue("isNumber(String) 21 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 21 failed", checkCreateNumber(val)); [EOL]         val = null; [EOL]         assertTrue("isNumber(String) 1 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 1 Neg failed", !checkCreateNumber(val)); [EOL]         val = ""; [EOL]         assertTrue("isNumber(String) 2 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 2 Neg failed", !checkCreateNumber(val)); [EOL]         val = "--2.3"; [EOL]         assertTrue("isNumber(String) 3 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 3 Neg failed", !checkCreateNumber(val)); [EOL]         val = ".12.3"; [EOL]         assertTrue("isNumber(String) 4 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 4 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-123E"; [EOL]         assertTrue("isNumber(String) 5 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 5 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-123E+-212"; [EOL]         assertTrue("isNumber(String) 6 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 6 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-123E2.12"; [EOL]         assertTrue("isNumber(String) 7 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 7 Neg failed", !checkCreateNumber(val)); [EOL]         val = "0xGF"; [EOL]         assertTrue("isNumber(String) 8 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 8 Neg failed", !checkCreateNumber(val)); [EOL]         val = "0xFAE-1"; [EOL]         assertTrue("isNumber(String) 9 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 9 Neg failed", !checkCreateNumber(val)); [EOL]         val = "."; [EOL]         assertTrue("isNumber(String) 10 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 10 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-0ABC123"; [EOL]         assertTrue("isNumber(String) 11 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 11 Neg failed", !checkCreateNumber(val)); [EOL]         val = "123.4E-D"; [EOL]         assertTrue("isNumber(String) 12 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 12 Neg failed", !checkCreateNumber(val)); [EOL]         val = "123.4ED"; [EOL]         assertTrue("isNumber(String) 13 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 13 Neg failed", !checkCreateNumber(val)); [EOL]         val = "1234E5l"; [EOL]         assertTrue("isNumber(String) 14 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 14 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11a"; [EOL]         assertTrue("isNumber(String) 15 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 15 Neg failed", !checkCreateNumber(val)); [EOL]         val = "1a"; [EOL]         assertTrue("isNumber(String) 16 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 16 Neg failed", !checkCreateNumber(val)); [EOL]         val = "a"; [EOL]         assertTrue("isNumber(String) 17 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 17 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11g"; [EOL]         assertTrue("isNumber(String) 18 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 18 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11z"; [EOL]         assertTrue("isNumber(String) 19 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 19 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11def"; [EOL]         assertTrue("isNumber(String) 20 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 20 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11d11"; [EOL]         assertTrue("isNumber(String) 21 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 21 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11 11"; [EOL]         assertTrue("isNumber(String) 22 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 22 Neg failed", !checkCreateNumber(val)); [EOL]         val = " 1111"; [EOL]         assertTrue("isNumber(String) 23 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 23 Neg failed", !checkCreateNumber(val)); [EOL]         val = "1111 "; [EOL]         assertTrue("isNumber(String) 24 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 24 Neg failed", !checkCreateNumber(val)); [EOL]  [EOL]         // LANG-521 [EOL]         val = "2."; [EOL]         assertTrue("isNumber(String) LANG-521 failed", NumberUtils.isNumber(val)); [EOL]  [EOL]         // LANG-664 [EOL]         val = "1.1L"; [EOL]         assertFalse("isNumber(String) LANG-664 failed", NumberUtils.isNumber(val)); [EOL]     } [EOL]  [EOL]     private boolean checkCreateNumber(final String val) { [EOL]         try { [EOL]             final Object obj = NumberUtils.createNumber(val); [EOL]             if (obj == null) { [EOL]                 return false; [EOL]             } [EOL]             return true; [EOL]         } catch (final NumberFormatException e) { [EOL]             return false; [EOL]        } [EOL]     } [EOL]  [EOL]     @SuppressWarnings("cast") // suppress instanceof warning check [EOL]
@Test [EOL]     public void testIsNumber() { [EOL]         String val = "12345"; [EOL]         assertTrue("isNumber(String) 1 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 1 failed", checkCreateNumber(val)); [EOL]         val = "1234.5"; [EOL]         assertTrue("isNumber(String) 2 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 2 failed", checkCreateNumber(val)); [EOL]         val = ".12345"; [EOL]         assertTrue("isNumber(String) 3 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 3 failed", checkCreateNumber(val)); [EOL]         val = "1234E5"; [EOL]         assertTrue("isNumber(String) 4 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 4 failed", checkCreateNumber(val)); [EOL]         val = "1234E+5"; [EOL]         assertTrue("isNumber(String) 5 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 5 failed", checkCreateNumber(val)); [EOL]         val = "1234E-5"; [EOL]         assertTrue("isNumber(String) 6 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 6 failed", checkCreateNumber(val)); [EOL]         val = "123.4E5"; [EOL]         assertTrue("isNumber(String) 7 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 7 failed", checkCreateNumber(val)); [EOL]         val = "-1234"; [EOL]         assertTrue("isNumber(String) 8 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 8 failed", checkCreateNumber(val)); [EOL]         val = "-1234.5"; [EOL]         assertTrue("isNumber(String) 9 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 9 failed", checkCreateNumber(val)); [EOL]         val = "-.12345"; [EOL]         assertTrue("isNumber(String) 10 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 10 failed", checkCreateNumber(val)); [EOL]         val = "-1234E5"; [EOL]         assertTrue("isNumber(String) 11 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 11 failed", checkCreateNumber(val)); [EOL]         val = "0"; [EOL]         assertTrue("isNumber(String) 12 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 12 failed", checkCreateNumber(val)); [EOL]         val = "-0"; [EOL]         assertTrue("isNumber(String) 13 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 13 failed", checkCreateNumber(val)); [EOL]         val = "01234"; [EOL]         assertTrue("isNumber(String) 14 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 14 failed", checkCreateNumber(val)); [EOL]         val = "-01234"; [EOL]         assertTrue("isNumber(String) 15 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 15 failed", checkCreateNumber(val)); [EOL]         val = "0xABC123"; [EOL]         assertTrue("isNumber(String) 16 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 16 failed", checkCreateNumber(val)); [EOL]         val = "0x0"; [EOL]         assertTrue("isNumber(String) 17 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 17 failed", checkCreateNumber(val)); [EOL]         val = "123.4E21D"; [EOL]         assertTrue("isNumber(String) 19 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 19 failed", checkCreateNumber(val)); [EOL]         val = "-221.23F"; [EOL]         assertTrue("isNumber(String) 20 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 20 failed", checkCreateNumber(val)); [EOL]         val = "22338L"; [EOL]         assertTrue("isNumber(String) 21 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 21 failed", checkCreateNumber(val)); [EOL]         val = null; [EOL]         assertTrue("isNumber(String) 1 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 1 Neg failed", !checkCreateNumber(val)); [EOL]         val = ""; [EOL]         assertTrue("isNumber(String) 2 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 2 Neg failed", !checkCreateNumber(val)); [EOL]         val = "--2.3"; [EOL]         assertTrue("isNumber(String) 3 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 3 Neg failed", !checkCreateNumber(val)); [EOL]         val = ".12.3"; [EOL]         assertTrue("isNumber(String) 4 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 4 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-123E"; [EOL]         assertTrue("isNumber(String) 5 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 5 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-123E+-212"; [EOL]         assertTrue("isNumber(String) 6 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 6 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-123E2.12"; [EOL]         assertTrue("isNumber(String) 7 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 7 Neg failed", !checkCreateNumber(val)); [EOL]         val = "0xGF"; [EOL]         assertTrue("isNumber(String) 8 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 8 Neg failed", !checkCreateNumber(val)); [EOL]         val = "0xFAE-1"; [EOL]         assertTrue("isNumber(String) 9 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 9 Neg failed", !checkCreateNumber(val)); [EOL]         val = "."; [EOL]         assertTrue("isNumber(String) 10 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 10 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-0ABC123"; [EOL]         assertTrue("isNumber(String) 11 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 11 Neg failed", !checkCreateNumber(val)); [EOL]         val = "123.4E-D"; [EOL]         assertTrue("isNumber(String) 12 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 12 Neg failed", !checkCreateNumber(val)); [EOL]         val = "123.4ED"; [EOL]         assertTrue("isNumber(String) 13 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 13 Neg failed", !checkCreateNumber(val)); [EOL]         val = "1234E5l"; [EOL]         assertTrue("isNumber(String) 14 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 14 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11a"; [EOL]         assertTrue("isNumber(String) 15 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 15 Neg failed", !checkCreateNumber(val)); [EOL]         val = "1a"; [EOL]         assertTrue("isNumber(String) 16 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 16 Neg failed", !checkCreateNumber(val)); [EOL]         val = "a"; [EOL]         assertTrue("isNumber(String) 17 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 17 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11g"; [EOL]         assertTrue("isNumber(String) 18 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 18 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11z"; [EOL]         assertTrue("isNumber(String) 19 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 19 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11def"; [EOL]         assertTrue("isNumber(String) 20 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 20 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11d11"; [EOL]         assertTrue("isNumber(String) 21 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 21 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11 11"; [EOL]         assertTrue("isNumber(String) 22 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 22 Neg failed", !checkCreateNumber(val)); [EOL]         val = " 1111"; [EOL]         assertTrue("isNumber(String) 23 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 23 Neg failed", !checkCreateNumber(val)); [EOL]         val = "1111 "; [EOL]         assertTrue("isNumber(String) 24 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 24 Neg failed", !checkCreateNumber(val)); [EOL]  [EOL]         // LANG-521 [EOL]         val = "2."; [EOL]         assertTrue("isNumber(String) LANG-521 failed", NumberUtils.isNumber(val)); [EOL]  [EOL]         // LANG-664 [EOL]         val = "1.1L"; [EOL]         assertFalse("isNumber(String) LANG-664 failed", NumberUtils.isNumber(val)); [EOL]     } [EOL]  [EOL]     private boolean checkCreateNumber(final String val) { [EOL]         try { [EOL]             final Object obj = NumberUtils.createNumber(val); [EOL]             if (obj == null) { [EOL]                 return false; [EOL]             } [EOL]             return true; [EOL]         } catch (final NumberFormatException e) { [EOL]             return false; [EOL]        } [EOL]     } [EOL]  [EOL]     @SuppressWarnings("cast") // suppress instanceof warning check [EOL]
@Test [EOL]     public void testIsNumber() { [EOL]         String val = "12345"; [EOL]         assertTrue("isNumber(String) 1 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 1 failed", checkCreateNumber(val)); [EOL]         val = "1234.5"; [EOL]         assertTrue("isNumber(String) 2 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 2 failed", checkCreateNumber(val)); [EOL]         val = ".12345"; [EOL]         assertTrue("isNumber(String) 3 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 3 failed", checkCreateNumber(val)); [EOL]         val = "1234E5"; [EOL]         assertTrue("isNumber(String) 4 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 4 failed", checkCreateNumber(val)); [EOL]         val = "1234E+5"; [EOL]         assertTrue("isNumber(String) 5 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 5 failed", checkCreateNumber(val)); [EOL]         val = "1234E-5"; [EOL]         assertTrue("isNumber(String) 6 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 6 failed", checkCreateNumber(val)); [EOL]         val = "123.4E5"; [EOL]         assertTrue("isNumber(String) 7 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 7 failed", checkCreateNumber(val)); [EOL]         val = "-1234"; [EOL]         assertTrue("isNumber(String) 8 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 8 failed", checkCreateNumber(val)); [EOL]         val = "-1234.5"; [EOL]         assertTrue("isNumber(String) 9 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 9 failed", checkCreateNumber(val)); [EOL]         val = "-.12345"; [EOL]         assertTrue("isNumber(String) 10 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 10 failed", checkCreateNumber(val)); [EOL]         val = "-1234E5"; [EOL]         assertTrue("isNumber(String) 11 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 11 failed", checkCreateNumber(val)); [EOL]         val = "0"; [EOL]         assertTrue("isNumber(String) 12 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 12 failed", checkCreateNumber(val)); [EOL]         val = "-0"; [EOL]         assertTrue("isNumber(String) 13 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 13 failed", checkCreateNumber(val)); [EOL]         val = "01234"; [EOL]         assertTrue("isNumber(String) 14 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 14 failed", checkCreateNumber(val)); [EOL]         val = "-01234"; [EOL]         assertTrue("isNumber(String) 15 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 15 failed", checkCreateNumber(val)); [EOL]         val = "0xABC123"; [EOL]         assertTrue("isNumber(String) 16 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 16 failed", checkCreateNumber(val)); [EOL]         val = "0x0"; [EOL]         assertTrue("isNumber(String) 17 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 17 failed", checkCreateNumber(val)); [EOL]         val = "123.4E21D"; [EOL]         assertTrue("isNumber(String) 19 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 19 failed", checkCreateNumber(val)); [EOL]         val = "-221.23F"; [EOL]         assertTrue("isNumber(String) 20 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 20 failed", checkCreateNumber(val)); [EOL]         val = "22338L"; [EOL]         assertTrue("isNumber(String) 21 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 21 failed", checkCreateNumber(val)); [EOL]         val = null; [EOL]         assertTrue("isNumber(String) 1 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 1 Neg failed", !checkCreateNumber(val)); [EOL]         val = ""; [EOL]         assertTrue("isNumber(String) 2 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 2 Neg failed", !checkCreateNumber(val)); [EOL]         val = "--2.3"; [EOL]         assertTrue("isNumber(String) 3 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 3 Neg failed", !checkCreateNumber(val)); [EOL]         val = ".12.3"; [EOL]         assertTrue("isNumber(String) 4 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 4 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-123E"; [EOL]         assertTrue("isNumber(String) 5 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 5 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-123E+-212"; [EOL]         assertTrue("isNumber(String) 6 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 6 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-123E2.12"; [EOL]         assertTrue("isNumber(String) 7 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 7 Neg failed", !checkCreateNumber(val)); [EOL]         val = "0xGF"; [EOL]         assertTrue("isNumber(String) 8 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 8 Neg failed", !checkCreateNumber(val)); [EOL]         val = "0xFAE-1"; [EOL]         assertTrue("isNumber(String) 9 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 9 Neg failed", !checkCreateNumber(val)); [EOL]         val = "."; [EOL]         assertTrue("isNumber(String) 10 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 10 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-0ABC123"; [EOL]         assertTrue("isNumber(String) 11 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 11 Neg failed", !checkCreateNumber(val)); [EOL]         val = "123.4E-D"; [EOL]         assertTrue("isNumber(String) 12 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 12 Neg failed", !checkCreateNumber(val)); [EOL]         val = "123.4ED"; [EOL]         assertTrue("isNumber(String) 13 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 13 Neg failed", !checkCreateNumber(val)); [EOL]         val = "1234E5l"; [EOL]         assertTrue("isNumber(String) 14 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 14 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11a"; [EOL]         assertTrue("isNumber(String) 15 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 15 Neg failed", !checkCreateNumber(val)); [EOL]         val = "1a"; [EOL]         assertTrue("isNumber(String) 16 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 16 Neg failed", !checkCreateNumber(val)); [EOL]         val = "a"; [EOL]         assertTrue("isNumber(String) 17 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 17 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11g"; [EOL]         assertTrue("isNumber(String) 18 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 18 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11z"; [EOL]         assertTrue("isNumber(String) 19 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 19 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11def"; [EOL]         assertTrue("isNumber(String) 20 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 20 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11d11"; [EOL]         assertTrue("isNumber(String) 21 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 21 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11 11"; [EOL]         assertTrue("isNumber(String) 22 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 22 Neg failed", !checkCreateNumber(val)); [EOL]         val = " 1111"; [EOL]         assertTrue("isNumber(String) 23 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 23 Neg failed", !checkCreateNumber(val)); [EOL]         val = "1111 "; [EOL]         assertTrue("isNumber(String) 24 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 24 Neg failed", !checkCreateNumber(val)); [EOL]  [EOL]         // LANG-521 [EOL]         val = "2."; [EOL]         assertTrue("isNumber(String) LANG-521 failed", NumberUtils.isNumber(val)); [EOL]  [EOL]         // LANG-664 [EOL]         val = "1.1L"; [EOL]         assertFalse("isNumber(String) LANG-664 failed", NumberUtils.isNumber(val)); [EOL]     } [EOL]  [EOL]     private boolean checkCreateNumber(final String val) { [EOL]         try { [EOL]             final Object obj = NumberUtils.createNumber(val); [EOL]             if (obj == null) { [EOL]                 return false; [EOL]             } [EOL]             return true; [EOL]         } catch (final NumberFormatException e) { [EOL]             return false; [EOL]        } [EOL]     } [EOL]  [EOL]     @SuppressWarnings("cast") // suppress instanceof warning check [EOL]
@Test [EOL]     public void testIsNumber() { [EOL]         String val = "12345"; [EOL]         assertTrue("isNumber(String) 1 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 1 failed", checkCreateNumber(val)); [EOL]         val = "1234.5"; [EOL]         assertTrue("isNumber(String) 2 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 2 failed", checkCreateNumber(val)); [EOL]         val = ".12345"; [EOL]         assertTrue("isNumber(String) 3 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 3 failed", checkCreateNumber(val)); [EOL]         val = "1234E5"; [EOL]         assertTrue("isNumber(String) 4 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 4 failed", checkCreateNumber(val)); [EOL]         val = "1234E+5"; [EOL]         assertTrue("isNumber(String) 5 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 5 failed", checkCreateNumber(val)); [EOL]         val = "1234E-5"; [EOL]         assertTrue("isNumber(String) 6 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 6 failed", checkCreateNumber(val)); [EOL]         val = "123.4E5"; [EOL]         assertTrue("isNumber(String) 7 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 7 failed", checkCreateNumber(val)); [EOL]         val = "-1234"; [EOL]         assertTrue("isNumber(String) 8 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 8 failed", checkCreateNumber(val)); [EOL]         val = "-1234.5"; [EOL]         assertTrue("isNumber(String) 9 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 9 failed", checkCreateNumber(val)); [EOL]         val = "-.12345"; [EOL]         assertTrue("isNumber(String) 10 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 10 failed", checkCreateNumber(val)); [EOL]         val = "-1234E5"; [EOL]         assertTrue("isNumber(String) 11 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 11 failed", checkCreateNumber(val)); [EOL]         val = "0"; [EOL]         assertTrue("isNumber(String) 12 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 12 failed", checkCreateNumber(val)); [EOL]         val = "-0"; [EOL]         assertTrue("isNumber(String) 13 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 13 failed", checkCreateNumber(val)); [EOL]         val = "01234"; [EOL]         assertTrue("isNumber(String) 14 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 14 failed", checkCreateNumber(val)); [EOL]         val = "-01234"; [EOL]         assertTrue("isNumber(String) 15 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 15 failed", checkCreateNumber(val)); [EOL]         val = "0xABC123"; [EOL]         assertTrue("isNumber(String) 16 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 16 failed", checkCreateNumber(val)); [EOL]         val = "0x0"; [EOL]         assertTrue("isNumber(String) 17 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 17 failed", checkCreateNumber(val)); [EOL]         val = "123.4E21D"; [EOL]         assertTrue("isNumber(String) 19 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 19 failed", checkCreateNumber(val)); [EOL]         val = "-221.23F"; [EOL]         assertTrue("isNumber(String) 20 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 20 failed", checkCreateNumber(val)); [EOL]         val = "22338L"; [EOL]         assertTrue("isNumber(String) 21 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 21 failed", checkCreateNumber(val)); [EOL]         val = null; [EOL]         assertTrue("isNumber(String) 1 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 1 Neg failed", !checkCreateNumber(val)); [EOL]         val = ""; [EOL]         assertTrue("isNumber(String) 2 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 2 Neg failed", !checkCreateNumber(val)); [EOL]         val = "--2.3"; [EOL]         assertTrue("isNumber(String) 3 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 3 Neg failed", !checkCreateNumber(val)); [EOL]         val = ".12.3"; [EOL]         assertTrue("isNumber(String) 4 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 4 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-123E"; [EOL]         assertTrue("isNumber(String) 5 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 5 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-123E+-212"; [EOL]         assertTrue("isNumber(String) 6 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 6 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-123E2.12"; [EOL]         assertTrue("isNumber(String) 7 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 7 Neg failed", !checkCreateNumber(val)); [EOL]         val = "0xGF"; [EOL]         assertTrue("isNumber(String) 8 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 8 Neg failed", !checkCreateNumber(val)); [EOL]         val = "0xFAE-1"; [EOL]         assertTrue("isNumber(String) 9 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 9 Neg failed", !checkCreateNumber(val)); [EOL]         val = "."; [EOL]         assertTrue("isNumber(String) 10 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 10 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-0ABC123"; [EOL]         assertTrue("isNumber(String) 11 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 11 Neg failed", !checkCreateNumber(val)); [EOL]         val = "123.4E-D"; [EOL]         assertTrue("isNumber(String) 12 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 12 Neg failed", !checkCreateNumber(val)); [EOL]         val = "123.4ED"; [EOL]         assertTrue("isNumber(String) 13 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 13 Neg failed", !checkCreateNumber(val)); [EOL]         val = "1234E5l"; [EOL]         assertTrue("isNumber(String) 14 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 14 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11a"; [EOL]         assertTrue("isNumber(String) 15 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 15 Neg failed", !checkCreateNumber(val)); [EOL]         val = "1a"; [EOL]         assertTrue("isNumber(String) 16 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 16 Neg failed", !checkCreateNumber(val)); [EOL]         val = "a"; [EOL]         assertTrue("isNumber(String) 17 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 17 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11g"; [EOL]         assertTrue("isNumber(String) 18 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 18 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11z"; [EOL]         assertTrue("isNumber(String) 19 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 19 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11def"; [EOL]         assertTrue("isNumber(String) 20 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 20 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11d11"; [EOL]         assertTrue("isNumber(String) 21 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 21 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11 11"; [EOL]         assertTrue("isNumber(String) 22 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 22 Neg failed", !checkCreateNumber(val)); [EOL]         val = " 1111"; [EOL]         assertTrue("isNumber(String) 23 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 23 Neg failed", !checkCreateNumber(val)); [EOL]         val = "1111 "; [EOL]         assertTrue("isNumber(String) 24 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 24 Neg failed", !checkCreateNumber(val)); [EOL]  [EOL]         // LANG-521 [EOL]         val = "2."; [EOL]         assertTrue("isNumber(String) LANG-521 failed", NumberUtils.isNumber(val)); [EOL]  [EOL]         // LANG-664 [EOL]         val = "1.1L"; [EOL]         assertFalse("isNumber(String) LANG-664 failed", NumberUtils.isNumber(val)); [EOL]     } [EOL]  [EOL]     private boolean checkCreateNumber(final String val) { [EOL]         try { [EOL]             final Object obj = NumberUtils.createNumber(val); [EOL]             if (obj == null) { [EOL]                 return false; [EOL]             } [EOL]             return true; [EOL]         } catch (final NumberFormatException e) { [EOL]             return false; [EOL]        } [EOL]     } [EOL]  [EOL]     @SuppressWarnings("cast") // suppress instanceof warning check [EOL]
@Test [EOL]     public void testIsNumber() { [EOL]         String val = "12345"; [EOL]         assertTrue("isNumber(String) 1 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 1 failed", checkCreateNumber(val)); [EOL]         val = "1234.5"; [EOL]         assertTrue("isNumber(String) 2 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 2 failed", checkCreateNumber(val)); [EOL]         val = ".12345"; [EOL]         assertTrue("isNumber(String) 3 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 3 failed", checkCreateNumber(val)); [EOL]         val = "1234E5"; [EOL]         assertTrue("isNumber(String) 4 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 4 failed", checkCreateNumber(val)); [EOL]         val = "1234E+5"; [EOL]         assertTrue("isNumber(String) 5 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 5 failed", checkCreateNumber(val)); [EOL]         val = "1234E-5"; [EOL]         assertTrue("isNumber(String) 6 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 6 failed", checkCreateNumber(val)); [EOL]         val = "123.4E5"; [EOL]         assertTrue("isNumber(String) 7 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 7 failed", checkCreateNumber(val)); [EOL]         val = "-1234"; [EOL]         assertTrue("isNumber(String) 8 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 8 failed", checkCreateNumber(val)); [EOL]         val = "-1234.5"; [EOL]         assertTrue("isNumber(String) 9 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 9 failed", checkCreateNumber(val)); [EOL]         val = "-.12345"; [EOL]         assertTrue("isNumber(String) 10 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 10 failed", checkCreateNumber(val)); [EOL]         val = "-1234E5"; [EOL]         assertTrue("isNumber(String) 11 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 11 failed", checkCreateNumber(val)); [EOL]         val = "0"; [EOL]         assertTrue("isNumber(String) 12 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 12 failed", checkCreateNumber(val)); [EOL]         val = "-0"; [EOL]         assertTrue("isNumber(String) 13 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 13 failed", checkCreateNumber(val)); [EOL]         val = "01234"; [EOL]         assertTrue("isNumber(String) 14 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 14 failed", checkCreateNumber(val)); [EOL]         val = "-01234"; [EOL]         assertTrue("isNumber(String) 15 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 15 failed", checkCreateNumber(val)); [EOL]         val = "0xABC123"; [EOL]         assertTrue("isNumber(String) 16 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 16 failed", checkCreateNumber(val)); [EOL]         val = "0x0"; [EOL]         assertTrue("isNumber(String) 17 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 17 failed", checkCreateNumber(val)); [EOL]         val = "123.4E21D"; [EOL]         assertTrue("isNumber(String) 19 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 19 failed", checkCreateNumber(val)); [EOL]         val = "-221.23F"; [EOL]         assertTrue("isNumber(String) 20 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 20 failed", checkCreateNumber(val)); [EOL]         val = "22338L"; [EOL]         assertTrue("isNumber(String) 21 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 21 failed", checkCreateNumber(val)); [EOL]         val = null; [EOL]         assertTrue("isNumber(String) 1 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 1 Neg failed", !checkCreateNumber(val)); [EOL]         val = ""; [EOL]         assertTrue("isNumber(String) 2 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 2 Neg failed", !checkCreateNumber(val)); [EOL]         val = "--2.3"; [EOL]         assertTrue("isNumber(String) 3 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 3 Neg failed", !checkCreateNumber(val)); [EOL]         val = ".12.3"; [EOL]         assertTrue("isNumber(String) 4 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 4 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-123E"; [EOL]         assertTrue("isNumber(String) 5 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 5 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-123E+-212"; [EOL]         assertTrue("isNumber(String) 6 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 6 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-123E2.12"; [EOL]         assertTrue("isNumber(String) 7 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 7 Neg failed", !checkCreateNumber(val)); [EOL]         val = "0xGF"; [EOL]         assertTrue("isNumber(String) 8 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 8 Neg failed", !checkCreateNumber(val)); [EOL]         val = "0xFAE-1"; [EOL]         assertTrue("isNumber(String) 9 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 9 Neg failed", !checkCreateNumber(val)); [EOL]         val = "."; [EOL]         assertTrue("isNumber(String) 10 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 10 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-0ABC123"; [EOL]         assertTrue("isNumber(String) 11 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 11 Neg failed", !checkCreateNumber(val)); [EOL]         val = "123.4E-D"; [EOL]         assertTrue("isNumber(String) 12 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 12 Neg failed", !checkCreateNumber(val)); [EOL]         val = "123.4ED"; [EOL]         assertTrue("isNumber(String) 13 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 13 Neg failed", !checkCreateNumber(val)); [EOL]         val = "1234E5l"; [EOL]         assertTrue("isNumber(String) 14 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 14 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11a"; [EOL]         assertTrue("isNumber(String) 15 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 15 Neg failed", !checkCreateNumber(val)); [EOL]         val = "1a"; [EOL]         assertTrue("isNumber(String) 16 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 16 Neg failed", !checkCreateNumber(val)); [EOL]         val = "a"; [EOL]         assertTrue("isNumber(String) 17 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 17 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11g"; [EOL]         assertTrue("isNumber(String) 18 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 18 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11z"; [EOL]         assertTrue("isNumber(String) 19 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 19 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11def"; [EOL]         assertTrue("isNumber(String) 20 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 20 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11d11"; [EOL]         assertTrue("isNumber(String) 21 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 21 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11 11"; [EOL]         assertTrue("isNumber(String) 22 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 22 Neg failed", !checkCreateNumber(val)); [EOL]         val = " 1111"; [EOL]         assertTrue("isNumber(String) 23 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 23 Neg failed", !checkCreateNumber(val)); [EOL]         val = "1111 "; [EOL]         assertTrue("isNumber(String) 24 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 24 Neg failed", !checkCreateNumber(val)); [EOL]  [EOL]         // LANG-521 [EOL]         val = "2."; [EOL]         assertTrue("isNumber(String) LANG-521 failed", NumberUtils.isNumber(val)); [EOL]  [EOL]         // LANG-664 [EOL]         val = "1.1L"; [EOL]         assertFalse("isNumber(String) LANG-664 failed", NumberUtils.isNumber(val)); [EOL]     } [EOL]  [EOL]     private boolean checkCreateNumber(final String val) { [EOL]         try { [EOL]             final Object obj = NumberUtils.createNumber(val); [EOL]             if (obj == null) { [EOL]                 return false; [EOL]             } [EOL]             return true; [EOL]         } catch (final NumberFormatException e) { [EOL]             return false; [EOL]        } [EOL]     } [EOL]  [EOL]     @SuppressWarnings("cast") // suppress instanceof warning check [EOL]
@Test [EOL]     public void testStringCreateNumberEnsureNoPrecisionLoss(){ [EOL]         String shouldBeFloat = "1.23"; [EOL]         String shouldBeDouble = "3.40282354e+38"; [EOL]         String shouldBeBigDecimal = "1.797693134862315759e+308"; [EOL]          [EOL]         assertTrue(NumberUtils.createNumber(shouldBeFloat) instanceof Float); [EOL]         assertTrue(NumberUtils.createNumber(shouldBeDouble) instanceof Double); [EOL]         assertTrue(NumberUtils.createNumber(shouldBeBigDecimal) instanceof BigDecimal); [EOL]     } [EOL]     /** [EOL]      * Test for {@link NumberUtils#toDouble(String)}. [EOL]      */ [EOL]
@Test [EOL]     public void testCreateNumberMagnitude() { [EOL]         // Test Float.MAX_VALUE, and same with +1 in final digit to check conversion changes to next Number type [EOL]         assertEquals(Float.valueOf(Float.MAX_VALUE),  NumberUtils.createNumber("3.4028235e+38")); [EOL]         assertEquals(Double.valueOf(3.4028236e+38),   NumberUtils.createNumber("3.4028236e+38")); [EOL]  [EOL]         // Test Double.MAX_VALUE [EOL]         assertEquals(Double.valueOf(Double.MAX_VALUE),          NumberUtils.createNumber("1.7976931348623157e+308")); [EOL]         // Test with +2 in final digit (+1 does not cause roll-over to BigDecimal) [EOL]         assertEquals(new BigDecimal("1.7976931348623159e+308"), NumberUtils.createNumber("1.7976931348623159e+308")); [EOL]  [EOL]         assertEquals(Integer.valueOf(0x12345678), NumberUtils.createNumber("0x12345678")); [EOL]         assertEquals(Long.valueOf(0x123456789L),  NumberUtils.createNumber("0x123456789")); [EOL]  [EOL]         assertEquals(Long.valueOf(0x7fffffffffffffffL),      NumberUtils.createNumber("0x7fffffffffffffff")); [EOL]         // Does not appear to be a way to create a literal BigInteger of this magnitude [EOL]         assertEquals(new BigInteger("7fffffffffffffff0",16), NumberUtils.createNumber("0x7fffffffffffffff0")); [EOL]  [EOL]         assertEquals(Long.valueOf(0x7fffffffffffffffL),      NumberUtils.createNumber("#7fffffffffffffff")); [EOL]         assertEquals(new BigInteger("7fffffffffffffff0",16), NumberUtils.createNumber("#7fffffffffffffff0")); [EOL]  [EOL]         assertEquals(Integer.valueOf(017777777777), NumberUtils.createNumber("017777777777")); // 31 bits [EOL]         assertEquals(Long.valueOf(037777777777L),   NumberUtils.createNumber("037777777777")); // 32 bits [EOL]  [EOL]         assertEquals(Long.valueOf(0777777777777777777777L),      NumberUtils.createNumber("0777777777777777777777")); // 63 bits [EOL]         assertEquals(new BigInteger("1777777777777777777777",8), NumberUtils.createNumber("01777777777777777777777"));// 64 bits [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testCreateNumberMagnitude() { [EOL]         // Test Float.MAX_VALUE, and same with +1 in final digit to check conversion changes to next Number type [EOL]         assertEquals(Float.valueOf(Float.MAX_VALUE),  NumberUtils.createNumber("3.4028235e+38")); [EOL]         assertEquals(Double.valueOf(3.4028236e+38),   NumberUtils.createNumber("3.4028236e+38")); [EOL]  [EOL]         // Test Double.MAX_VALUE [EOL]         assertEquals(Double.valueOf(Double.MAX_VALUE),          NumberUtils.createNumber("1.7976931348623157e+308")); [EOL]         // Test with +2 in final digit (+1 does not cause roll-over to BigDecimal) [EOL]         assertEquals(new BigDecimal("1.7976931348623159e+308"), NumberUtils.createNumber("1.7976931348623159e+308")); [EOL]  [EOL]         assertEquals(Integer.valueOf(0x12345678), NumberUtils.createNumber("0x12345678")); [EOL]         assertEquals(Long.valueOf(0x123456789L),  NumberUtils.createNumber("0x123456789")); [EOL]  [EOL]         assertEquals(Long.valueOf(0x7fffffffffffffffL),      NumberUtils.createNumber("0x7fffffffffffffff")); [EOL]         // Does not appear to be a way to create a literal BigInteger of this magnitude [EOL]         assertEquals(new BigInteger("7fffffffffffffff0",16), NumberUtils.createNumber("0x7fffffffffffffff0")); [EOL]  [EOL]         assertEquals(Long.valueOf(0x7fffffffffffffffL),      NumberUtils.createNumber("#7fffffffffffffff")); [EOL]         assertEquals(new BigInteger("7fffffffffffffff0",16), NumberUtils.createNumber("#7fffffffffffffff0")); [EOL]  [EOL]         assertEquals(Integer.valueOf(017777777777), NumberUtils.createNumber("017777777777")); // 31 bits [EOL]         assertEquals(Long.valueOf(037777777777L),   NumberUtils.createNumber("037777777777")); // 32 bits [EOL]  [EOL]         assertEquals(Long.valueOf(0777777777777777777777L),      NumberUtils.createNumber("0777777777777777777777")); // 63 bits [EOL]         assertEquals(new BigInteger("1777777777777777777777",8), NumberUtils.createNumber("01777777777777777777777"));// 64 bits [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testCreateNumberMagnitude() { [EOL]         // Test Float.MAX_VALUE, and same with +1 in final digit to check conversion changes to next Number type [EOL]         assertEquals(Float.valueOf(Float.MAX_VALUE),  NumberUtils.createNumber("3.4028235e+38")); [EOL]         assertEquals(Double.valueOf(3.4028236e+38),   NumberUtils.createNumber("3.4028236e+38")); [EOL]  [EOL]         // Test Double.MAX_VALUE [EOL]         assertEquals(Double.valueOf(Double.MAX_VALUE),          NumberUtils.createNumber("1.7976931348623157e+308")); [EOL]         // Test with +2 in final digit (+1 does not cause roll-over to BigDecimal) [EOL]         assertEquals(new BigDecimal("1.7976931348623159e+308"), NumberUtils.createNumber("1.7976931348623159e+308")); [EOL]  [EOL]         assertEquals(Integer.valueOf(0x12345678), NumberUtils.createNumber("0x12345678")); [EOL]         assertEquals(Long.valueOf(0x123456789L),  NumberUtils.createNumber("0x123456789")); [EOL]  [EOL]         assertEquals(Long.valueOf(0x7fffffffffffffffL),      NumberUtils.createNumber("0x7fffffffffffffff")); [EOL]         // Does not appear to be a way to create a literal BigInteger of this magnitude [EOL]         assertEquals(new BigInteger("7fffffffffffffff0",16), NumberUtils.createNumber("0x7fffffffffffffff0")); [EOL]  [EOL]         assertEquals(Long.valueOf(0x7fffffffffffffffL),      NumberUtils.createNumber("#7fffffffffffffff")); [EOL]         assertEquals(new BigInteger("7fffffffffffffff0",16), NumberUtils.createNumber("#7fffffffffffffff0")); [EOL]  [EOL]         assertEquals(Integer.valueOf(017777777777), NumberUtils.createNumber("017777777777")); // 31 bits [EOL]         assertEquals(Long.valueOf(037777777777L),   NumberUtils.createNumber("037777777777")); // 32 bits [EOL]  [EOL]         assertEquals(Long.valueOf(0777777777777777777777L),      NumberUtils.createNumber("0777777777777777777777")); // 63 bits [EOL]         assertEquals(new BigInteger("1777777777777777777777",8), NumberUtils.createNumber("01777777777777777777777"));// 64 bits [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testStringCreateNumberEnsureNoPrecisionLoss(){ [EOL]         String shouldBeFloat = "1.23"; [EOL]         String shouldBeDouble = "3.40282354e+38"; [EOL]         String shouldBeBigDecimal = "1.797693134862315759e+308"; [EOL]          [EOL]         assertTrue(NumberUtils.createNumber(shouldBeFloat) instanceof Float); [EOL]         assertTrue(NumberUtils.createNumber(shouldBeDouble) instanceof Double); [EOL]         assertTrue(NumberUtils.createNumber(shouldBeBigDecimal) instanceof BigDecimal); [EOL]     } [EOL]     /** [EOL]      * Test for {@link NumberUtils#toDouble(String)}. [EOL]      */ [EOL]
@Test [EOL]     public void testStringCreateNumberEnsureNoPrecisionLoss(){ [EOL]         String shouldBeFloat = "1.23"; [EOL]         String shouldBeDouble = "3.40282354e+38"; [EOL]         String shouldBeBigDecimal = "1.797693134862315759e+308"; [EOL]          [EOL]         assertTrue(NumberUtils.createNumber(shouldBeFloat) instanceof Float); [EOL]         assertTrue(NumberUtils.createNumber(shouldBeDouble) instanceof Double); [EOL]         assertTrue(NumberUtils.createNumber(shouldBeBigDecimal) instanceof BigDecimal); [EOL]     } [EOL]     /** [EOL]      * Test for {@link NumberUtils#toDouble(String)}. [EOL]      */ [EOL]
@Test [EOL]     public void testStringCreateNumberEnsureNoPrecisionLoss(){ [EOL]         String shouldBeFloat = "1.23"; [EOL]         String shouldBeDouble = "3.40282354e+38"; [EOL]         String shouldBeBigDecimal = "1.797693134862315759e+308"; [EOL]          [EOL]         assertTrue(NumberUtils.createNumber(shouldBeFloat) instanceof Float); [EOL]         assertTrue(NumberUtils.createNumber(shouldBeDouble) instanceof Double); [EOL]         assertTrue(NumberUtils.createNumber(shouldBeBigDecimal) instanceof BigDecimal); [EOL]     } [EOL]     /** [EOL]      * Test for {@link NumberUtils#toDouble(String)}. [EOL]      */ [EOL]
@Test [EOL]     public void testStringCreateNumberEnsureNoPrecisionLoss(){ [EOL]         String shouldBeFloat = "1.23"; [EOL]         String shouldBeDouble = "3.40282354e+38"; [EOL]         String shouldBeBigDecimal = "1.797693134862315759e+308"; [EOL]          [EOL]         assertTrue(NumberUtils.createNumber(shouldBeFloat) instanceof Float); [EOL]         assertTrue(NumberUtils.createNumber(shouldBeDouble) instanceof Double); [EOL]         assertTrue(NumberUtils.createNumber(shouldBeBigDecimal) instanceof BigDecimal); [EOL]     } [EOL]     /** [EOL]      * Test for {@link NumberUtils#toDouble(String)}. [EOL]      */ [EOL]
@Test [EOL]     public void testStringCreateNumberEnsureNoPrecisionLoss(){ [EOL]         String shouldBeFloat = "1.23"; [EOL]         String shouldBeDouble = "3.40282354e+38"; [EOL]         String shouldBeBigDecimal = "1.797693134862315759e+308"; [EOL]          [EOL]         assertTrue(NumberUtils.createNumber(shouldBeFloat) instanceof Float); [EOL]         assertTrue(NumberUtils.createNumber(shouldBeDouble) instanceof Double); [EOL]         assertTrue(NumberUtils.createNumber(shouldBeBigDecimal) instanceof BigDecimal); [EOL]     } [EOL]     /** [EOL]      * Test for {@link NumberUtils#toDouble(String)}. [EOL]      */ [EOL]
@Test [EOL]     public void testIsNumber() { [EOL]         String val = "12345"; [EOL]         assertTrue("isNumber(String) 1 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 1 failed", checkCreateNumber(val)); [EOL]         val = "1234.5"; [EOL]         assertTrue("isNumber(String) 2 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 2 failed", checkCreateNumber(val)); [EOL]         val = ".12345"; [EOL]         assertTrue("isNumber(String) 3 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 3 failed", checkCreateNumber(val)); [EOL]         val = "1234E5"; [EOL]         assertTrue("isNumber(String) 4 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 4 failed", checkCreateNumber(val)); [EOL]         val = "1234E+5"; [EOL]         assertTrue("isNumber(String) 5 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 5 failed", checkCreateNumber(val)); [EOL]         val = "1234E-5"; [EOL]         assertTrue("isNumber(String) 6 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 6 failed", checkCreateNumber(val)); [EOL]         val = "123.4E5"; [EOL]         assertTrue("isNumber(String) 7 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 7 failed", checkCreateNumber(val)); [EOL]         val = "-1234"; [EOL]         assertTrue("isNumber(String) 8 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 8 failed", checkCreateNumber(val)); [EOL]         val = "-1234.5"; [EOL]         assertTrue("isNumber(String) 9 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 9 failed", checkCreateNumber(val)); [EOL]         val = "-.12345"; [EOL]         assertTrue("isNumber(String) 10 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 10 failed", checkCreateNumber(val)); [EOL]         val = "-1234E5"; [EOL]         assertTrue("isNumber(String) 11 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 11 failed", checkCreateNumber(val)); [EOL]         val = "0"; [EOL]         assertTrue("isNumber(String) 12 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 12 failed", checkCreateNumber(val)); [EOL]         val = "-0"; [EOL]         assertTrue("isNumber(String) 13 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 13 failed", checkCreateNumber(val)); [EOL]         val = "01234"; [EOL]         assertTrue("isNumber(String) 14 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 14 failed", checkCreateNumber(val)); [EOL]         val = "-01234"; [EOL]         assertTrue("isNumber(String) 15 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 15 failed", checkCreateNumber(val)); [EOL]         val = "0xABC123"; [EOL]         assertTrue("isNumber(String) 16 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 16 failed", checkCreateNumber(val)); [EOL]         val = "0x0"; [EOL]         assertTrue("isNumber(String) 17 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 17 failed", checkCreateNumber(val)); [EOL]         val = "123.4E21D"; [EOL]         assertTrue("isNumber(String) 19 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 19 failed", checkCreateNumber(val)); [EOL]         val = "-221.23F"; [EOL]         assertTrue("isNumber(String) 20 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 20 failed", checkCreateNumber(val)); [EOL]         val = "22338L"; [EOL]         assertTrue("isNumber(String) 21 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 21 failed", checkCreateNumber(val)); [EOL]         val = null; [EOL]         assertTrue("isNumber(String) 1 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 1 Neg failed", !checkCreateNumber(val)); [EOL]         val = ""; [EOL]         assertTrue("isNumber(String) 2 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 2 Neg failed", !checkCreateNumber(val)); [EOL]         val = "--2.3"; [EOL]         assertTrue("isNumber(String) 3 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 3 Neg failed", !checkCreateNumber(val)); [EOL]         val = ".12.3"; [EOL]         assertTrue("isNumber(String) 4 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 4 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-123E"; [EOL]         assertTrue("isNumber(String) 5 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 5 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-123E+-212"; [EOL]         assertTrue("isNumber(String) 6 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 6 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-123E2.12"; [EOL]         assertTrue("isNumber(String) 7 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 7 Neg failed", !checkCreateNumber(val)); [EOL]         val = "0xGF"; [EOL]         assertTrue("isNumber(String) 8 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 8 Neg failed", !checkCreateNumber(val)); [EOL]         val = "0xFAE-1"; [EOL]         assertTrue("isNumber(String) 9 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 9 Neg failed", !checkCreateNumber(val)); [EOL]         val = "."; [EOL]         assertTrue("isNumber(String) 10 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 10 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-0ABC123"; [EOL]         assertTrue("isNumber(String) 11 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 11 Neg failed", !checkCreateNumber(val)); [EOL]         val = "123.4E-D"; [EOL]         assertTrue("isNumber(String) 12 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 12 Neg failed", !checkCreateNumber(val)); [EOL]         val = "123.4ED"; [EOL]         assertTrue("isNumber(String) 13 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 13 Neg failed", !checkCreateNumber(val)); [EOL]         val = "1234E5l"; [EOL]         assertTrue("isNumber(String) 14 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 14 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11a"; [EOL]         assertTrue("isNumber(String) 15 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 15 Neg failed", !checkCreateNumber(val)); [EOL]         val = "1a"; [EOL]         assertTrue("isNumber(String) 16 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 16 Neg failed", !checkCreateNumber(val)); [EOL]         val = "a"; [EOL]         assertTrue("isNumber(String) 17 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 17 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11g"; [EOL]         assertTrue("isNumber(String) 18 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 18 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11z"; [EOL]         assertTrue("isNumber(String) 19 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 19 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11def"; [EOL]         assertTrue("isNumber(String) 20 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 20 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11d11"; [EOL]         assertTrue("isNumber(String) 21 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 21 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11 11"; [EOL]         assertTrue("isNumber(String) 22 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 22 Neg failed", !checkCreateNumber(val)); [EOL]         val = " 1111"; [EOL]         assertTrue("isNumber(String) 23 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 23 Neg failed", !checkCreateNumber(val)); [EOL]         val = "1111 "; [EOL]         assertTrue("isNumber(String) 24 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 24 Neg failed", !checkCreateNumber(val)); [EOL]  [EOL]         // LANG-521 [EOL]         val = "2."; [EOL]         assertTrue("isNumber(String) LANG-521 failed", NumberUtils.isNumber(val)); [EOL]  [EOL]         // LANG-664 [EOL]         val = "1.1L"; [EOL]         assertFalse("isNumber(String) LANG-664 failed", NumberUtils.isNumber(val)); [EOL]     } [EOL]  [EOL]     private boolean checkCreateNumber(final String val) { [EOL]         try { [EOL]             final Object obj = NumberUtils.createNumber(val); [EOL]             if (obj == null) { [EOL]                 return false; [EOL]             } [EOL]             return true; [EOL]         } catch (final NumberFormatException e) { [EOL]             return false; [EOL]        } [EOL]     } [EOL]  [EOL]     @SuppressWarnings("cast") // suppress instanceof warning check [EOL]
@Test [EOL]     public void testIsDigits() { [EOL]         assertFalse("isDigits(null) failed", NumberUtils.isDigits(null)); [EOL]         assertFalse("isDigits('') failed", NumberUtils.isDigits("")); [EOL]         assertTrue("isDigits(String) failed", NumberUtils.isDigits("12345")); [EOL]         assertFalse("isDigits(String) neg 1 failed", NumberUtils.isDigits("1234.5")); [EOL]         assertFalse("isDigits(String) neg 3 failed", NumberUtils.isDigits("1ab")); [EOL]         assertFalse("isDigits(String) neg 4 failed", NumberUtils.isDigits("abc")); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests isNumber(String) and tests that createNumber(String) returns [EOL]      * a valid number iff isNumber(String) returns false. [EOL]      */ [EOL]
@Test [EOL]     public void testIsNumber() { [EOL]         String val = "12345"; [EOL]         assertTrue("isNumber(String) 1 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 1 failed", checkCreateNumber(val)); [EOL]         val = "1234.5"; [EOL]         assertTrue("isNumber(String) 2 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 2 failed", checkCreateNumber(val)); [EOL]         val = ".12345"; [EOL]         assertTrue("isNumber(String) 3 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 3 failed", checkCreateNumber(val)); [EOL]         val = "1234E5"; [EOL]         assertTrue("isNumber(String) 4 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 4 failed", checkCreateNumber(val)); [EOL]         val = "1234E+5"; [EOL]         assertTrue("isNumber(String) 5 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 5 failed", checkCreateNumber(val)); [EOL]         val = "1234E-5"; [EOL]         assertTrue("isNumber(String) 6 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 6 failed", checkCreateNumber(val)); [EOL]         val = "123.4E5"; [EOL]         assertTrue("isNumber(String) 7 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 7 failed", checkCreateNumber(val)); [EOL]         val = "-1234"; [EOL]         assertTrue("isNumber(String) 8 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 8 failed", checkCreateNumber(val)); [EOL]         val = "-1234.5"; [EOL]         assertTrue("isNumber(String) 9 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 9 failed", checkCreateNumber(val)); [EOL]         val = "-.12345"; [EOL]         assertTrue("isNumber(String) 10 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 10 failed", checkCreateNumber(val)); [EOL]         val = "-1234E5"; [EOL]         assertTrue("isNumber(String) 11 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 11 failed", checkCreateNumber(val)); [EOL]         val = "0"; [EOL]         assertTrue("isNumber(String) 12 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 12 failed", checkCreateNumber(val)); [EOL]         val = "-0"; [EOL]         assertTrue("isNumber(String) 13 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 13 failed", checkCreateNumber(val)); [EOL]         val = "01234"; [EOL]         assertTrue("isNumber(String) 14 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 14 failed", checkCreateNumber(val)); [EOL]         val = "-01234"; [EOL]         assertTrue("isNumber(String) 15 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 15 failed", checkCreateNumber(val)); [EOL]         val = "0xABC123"; [EOL]         assertTrue("isNumber(String) 16 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 16 failed", checkCreateNumber(val)); [EOL]         val = "0x0"; [EOL]         assertTrue("isNumber(String) 17 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 17 failed", checkCreateNumber(val)); [EOL]         val = "123.4E21D"; [EOL]         assertTrue("isNumber(String) 19 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 19 failed", checkCreateNumber(val)); [EOL]         val = "-221.23F"; [EOL]         assertTrue("isNumber(String) 20 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 20 failed", checkCreateNumber(val)); [EOL]         val = "22338L"; [EOL]         assertTrue("isNumber(String) 21 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 21 failed", checkCreateNumber(val)); [EOL]         val = null; [EOL]         assertTrue("isNumber(String) 1 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 1 Neg failed", !checkCreateNumber(val)); [EOL]         val = ""; [EOL]         assertTrue("isNumber(String) 2 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 2 Neg failed", !checkCreateNumber(val)); [EOL]         val = "--2.3"; [EOL]         assertTrue("isNumber(String) 3 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 3 Neg failed", !checkCreateNumber(val)); [EOL]         val = ".12.3"; [EOL]         assertTrue("isNumber(String) 4 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 4 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-123E"; [EOL]         assertTrue("isNumber(String) 5 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 5 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-123E+-212"; [EOL]         assertTrue("isNumber(String) 6 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 6 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-123E2.12"; [EOL]         assertTrue("isNumber(String) 7 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 7 Neg failed", !checkCreateNumber(val)); [EOL]         val = "0xGF"; [EOL]         assertTrue("isNumber(String) 8 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 8 Neg failed", !checkCreateNumber(val)); [EOL]         val = "0xFAE-1"; [EOL]         assertTrue("isNumber(String) 9 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 9 Neg failed", !checkCreateNumber(val)); [EOL]         val = "."; [EOL]         assertTrue("isNumber(String) 10 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 10 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-0ABC123"; [EOL]         assertTrue("isNumber(String) 11 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 11 Neg failed", !checkCreateNumber(val)); [EOL]         val = "123.4E-D"; [EOL]         assertTrue("isNumber(String) 12 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 12 Neg failed", !checkCreateNumber(val)); [EOL]         val = "123.4ED"; [EOL]         assertTrue("isNumber(String) 13 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 13 Neg failed", !checkCreateNumber(val)); [EOL]         val = "1234E5l"; [EOL]         assertTrue("isNumber(String) 14 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 14 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11a"; [EOL]         assertTrue("isNumber(String) 15 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 15 Neg failed", !checkCreateNumber(val)); [EOL]         val = "1a"; [EOL]         assertTrue("isNumber(String) 16 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 16 Neg failed", !checkCreateNumber(val)); [EOL]         val = "a"; [EOL]         assertTrue("isNumber(String) 17 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 17 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11g"; [EOL]         assertTrue("isNumber(String) 18 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 18 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11z"; [EOL]         assertTrue("isNumber(String) 19 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 19 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11def"; [EOL]         assertTrue("isNumber(String) 20 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 20 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11d11"; [EOL]         assertTrue("isNumber(String) 21 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 21 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11 11"; [EOL]         assertTrue("isNumber(String) 22 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 22 Neg failed", !checkCreateNumber(val)); [EOL]         val = " 1111"; [EOL]         assertTrue("isNumber(String) 23 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 23 Neg failed", !checkCreateNumber(val)); [EOL]         val = "1111 "; [EOL]         assertTrue("isNumber(String) 24 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 24 Neg failed", !checkCreateNumber(val)); [EOL]  [EOL]         // LANG-521 [EOL]         val = "2."; [EOL]         assertTrue("isNumber(String) LANG-521 failed", NumberUtils.isNumber(val)); [EOL]  [EOL]         // LANG-664 [EOL]         val = "1.1L"; [EOL]         assertFalse("isNumber(String) LANG-664 failed", NumberUtils.isNumber(val)); [EOL]     } [EOL]  [EOL]     private boolean checkCreateNumber(final String val) { [EOL]         try { [EOL]             final Object obj = NumberUtils.createNumber(val); [EOL]             if (obj == null) { [EOL]                 return false; [EOL]             } [EOL]             return true; [EOL]         } catch (final NumberFormatException e) { [EOL]             return false; [EOL]        } [EOL]     } [EOL]  [EOL]     @SuppressWarnings("cast") // suppress instanceof warning check [EOL]
@Test [EOL]     public void testIsNumber() { [EOL]         String val = "12345"; [EOL]         assertTrue("isNumber(String) 1 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 1 failed", checkCreateNumber(val)); [EOL]         val = "1234.5"; [EOL]         assertTrue("isNumber(String) 2 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 2 failed", checkCreateNumber(val)); [EOL]         val = ".12345"; [EOL]         assertTrue("isNumber(String) 3 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 3 failed", checkCreateNumber(val)); [EOL]         val = "1234E5"; [EOL]         assertTrue("isNumber(String) 4 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 4 failed", checkCreateNumber(val)); [EOL]         val = "1234E+5"; [EOL]         assertTrue("isNumber(String) 5 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 5 failed", checkCreateNumber(val)); [EOL]         val = "1234E-5"; [EOL]         assertTrue("isNumber(String) 6 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 6 failed", checkCreateNumber(val)); [EOL]         val = "123.4E5"; [EOL]         assertTrue("isNumber(String) 7 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 7 failed", checkCreateNumber(val)); [EOL]         val = "-1234"; [EOL]         assertTrue("isNumber(String) 8 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 8 failed", checkCreateNumber(val)); [EOL]         val = "-1234.5"; [EOL]         assertTrue("isNumber(String) 9 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 9 failed", checkCreateNumber(val)); [EOL]         val = "-.12345"; [EOL]         assertTrue("isNumber(String) 10 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 10 failed", checkCreateNumber(val)); [EOL]         val = "-1234E5"; [EOL]         assertTrue("isNumber(String) 11 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 11 failed", checkCreateNumber(val)); [EOL]         val = "0"; [EOL]         assertTrue("isNumber(String) 12 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 12 failed", checkCreateNumber(val)); [EOL]         val = "-0"; [EOL]         assertTrue("isNumber(String) 13 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 13 failed", checkCreateNumber(val)); [EOL]         val = "01234"; [EOL]         assertTrue("isNumber(String) 14 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 14 failed", checkCreateNumber(val)); [EOL]         val = "-01234"; [EOL]         assertTrue("isNumber(String) 15 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 15 failed", checkCreateNumber(val)); [EOL]         val = "0xABC123"; [EOL]         assertTrue("isNumber(String) 16 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 16 failed", checkCreateNumber(val)); [EOL]         val = "0x0"; [EOL]         assertTrue("isNumber(String) 17 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 17 failed", checkCreateNumber(val)); [EOL]         val = "123.4E21D"; [EOL]         assertTrue("isNumber(String) 19 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 19 failed", checkCreateNumber(val)); [EOL]         val = "-221.23F"; [EOL]         assertTrue("isNumber(String) 20 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 20 failed", checkCreateNumber(val)); [EOL]         val = "22338L"; [EOL]         assertTrue("isNumber(String) 21 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 21 failed", checkCreateNumber(val)); [EOL]         val = null; [EOL]         assertTrue("isNumber(String) 1 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 1 Neg failed", !checkCreateNumber(val)); [EOL]         val = ""; [EOL]         assertTrue("isNumber(String) 2 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 2 Neg failed", !checkCreateNumber(val)); [EOL]         val = "--2.3"; [EOL]         assertTrue("isNumber(String) 3 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 3 Neg failed", !checkCreateNumber(val)); [EOL]         val = ".12.3"; [EOL]         assertTrue("isNumber(String) 4 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 4 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-123E"; [EOL]         assertTrue("isNumber(String) 5 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 5 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-123E+-212"; [EOL]         assertTrue("isNumber(String) 6 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 6 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-123E2.12"; [EOL]         assertTrue("isNumber(String) 7 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 7 Neg failed", !checkCreateNumber(val)); [EOL]         val = "0xGF"; [EOL]         assertTrue("isNumber(String) 8 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 8 Neg failed", !checkCreateNumber(val)); [EOL]         val = "0xFAE-1"; [EOL]         assertTrue("isNumber(String) 9 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 9 Neg failed", !checkCreateNumber(val)); [EOL]         val = "."; [EOL]         assertTrue("isNumber(String) 10 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 10 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-0ABC123"; [EOL]         assertTrue("isNumber(String) 11 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 11 Neg failed", !checkCreateNumber(val)); [EOL]         val = "123.4E-D"; [EOL]         assertTrue("isNumber(String) 12 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 12 Neg failed", !checkCreateNumber(val)); [EOL]         val = "123.4ED"; [EOL]         assertTrue("isNumber(String) 13 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 13 Neg failed", !checkCreateNumber(val)); [EOL]         val = "1234E5l"; [EOL]         assertTrue("isNumber(String) 14 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 14 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11a"; [EOL]         assertTrue("isNumber(String) 15 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 15 Neg failed", !checkCreateNumber(val)); [EOL]         val = "1a"; [EOL]         assertTrue("isNumber(String) 16 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 16 Neg failed", !checkCreateNumber(val)); [EOL]         val = "a"; [EOL]         assertTrue("isNumber(String) 17 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 17 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11g"; [EOL]         assertTrue("isNumber(String) 18 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 18 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11z"; [EOL]         assertTrue("isNumber(String) 19 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 19 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11def"; [EOL]         assertTrue("isNumber(String) 20 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 20 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11d11"; [EOL]         assertTrue("isNumber(String) 21 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 21 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11 11"; [EOL]         assertTrue("isNumber(String) 22 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 22 Neg failed", !checkCreateNumber(val)); [EOL]         val = " 1111"; [EOL]         assertTrue("isNumber(String) 23 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 23 Neg failed", !checkCreateNumber(val)); [EOL]         val = "1111 "; [EOL]         assertTrue("isNumber(String) 24 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 24 Neg failed", !checkCreateNumber(val)); [EOL]  [EOL]         // LANG-521 [EOL]         val = "2."; [EOL]         assertTrue("isNumber(String) LANG-521 failed", NumberUtils.isNumber(val)); [EOL]  [EOL]         // LANG-664 [EOL]         val = "1.1L"; [EOL]         assertFalse("isNumber(String) LANG-664 failed", NumberUtils.isNumber(val)); [EOL]     } [EOL]  [EOL]     private boolean checkCreateNumber(final String val) { [EOL]         try { [EOL]             final Object obj = NumberUtils.createNumber(val); [EOL]             if (obj == null) { [EOL]                 return false; [EOL]             } [EOL]             return true; [EOL]         } catch (final NumberFormatException e) { [EOL]             return false; [EOL]        } [EOL]     } [EOL]  [EOL]     @SuppressWarnings("cast") // suppress instanceof warning check [EOL]
@Test [EOL]     public void testIsNumber() { [EOL]         String val = "12345"; [EOL]         assertTrue("isNumber(String) 1 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 1 failed", checkCreateNumber(val)); [EOL]         val = "1234.5"; [EOL]         assertTrue("isNumber(String) 2 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 2 failed", checkCreateNumber(val)); [EOL]         val = ".12345"; [EOL]         assertTrue("isNumber(String) 3 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 3 failed", checkCreateNumber(val)); [EOL]         val = "1234E5"; [EOL]         assertTrue("isNumber(String) 4 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 4 failed", checkCreateNumber(val)); [EOL]         val = "1234E+5"; [EOL]         assertTrue("isNumber(String) 5 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 5 failed", checkCreateNumber(val)); [EOL]         val = "1234E-5"; [EOL]         assertTrue("isNumber(String) 6 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 6 failed", checkCreateNumber(val)); [EOL]         val = "123.4E5"; [EOL]         assertTrue("isNumber(String) 7 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 7 failed", checkCreateNumber(val)); [EOL]         val = "-1234"; [EOL]         assertTrue("isNumber(String) 8 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 8 failed", checkCreateNumber(val)); [EOL]         val = "-1234.5"; [EOL]         assertTrue("isNumber(String) 9 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 9 failed", checkCreateNumber(val)); [EOL]         val = "-.12345"; [EOL]         assertTrue("isNumber(String) 10 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 10 failed", checkCreateNumber(val)); [EOL]         val = "-1234E5"; [EOL]         assertTrue("isNumber(String) 11 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 11 failed", checkCreateNumber(val)); [EOL]         val = "0"; [EOL]         assertTrue("isNumber(String) 12 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 12 failed", checkCreateNumber(val)); [EOL]         val = "-0"; [EOL]         assertTrue("isNumber(String) 13 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 13 failed", checkCreateNumber(val)); [EOL]         val = "01234"; [EOL]         assertTrue("isNumber(String) 14 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 14 failed", checkCreateNumber(val)); [EOL]         val = "-01234"; [EOL]         assertTrue("isNumber(String) 15 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 15 failed", checkCreateNumber(val)); [EOL]         val = "0xABC123"; [EOL]         assertTrue("isNumber(String) 16 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 16 failed", checkCreateNumber(val)); [EOL]         val = "0x0"; [EOL]         assertTrue("isNumber(String) 17 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 17 failed", checkCreateNumber(val)); [EOL]         val = "123.4E21D"; [EOL]         assertTrue("isNumber(String) 19 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 19 failed", checkCreateNumber(val)); [EOL]         val = "-221.23F"; [EOL]         assertTrue("isNumber(String) 20 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 20 failed", checkCreateNumber(val)); [EOL]         val = "22338L"; [EOL]         assertTrue("isNumber(String) 21 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 21 failed", checkCreateNumber(val)); [EOL]         val = null; [EOL]         assertTrue("isNumber(String) 1 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 1 Neg failed", !checkCreateNumber(val)); [EOL]         val = ""; [EOL]         assertTrue("isNumber(String) 2 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 2 Neg failed", !checkCreateNumber(val)); [EOL]         val = "--2.3"; [EOL]         assertTrue("isNumber(String) 3 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 3 Neg failed", !checkCreateNumber(val)); [EOL]         val = ".12.3"; [EOL]         assertTrue("isNumber(String) 4 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 4 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-123E"; [EOL]         assertTrue("isNumber(String) 5 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 5 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-123E+-212"; [EOL]         assertTrue("isNumber(String) 6 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 6 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-123E2.12"; [EOL]         assertTrue("isNumber(String) 7 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 7 Neg failed", !checkCreateNumber(val)); [EOL]         val = "0xGF"; [EOL]         assertTrue("isNumber(String) 8 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 8 Neg failed", !checkCreateNumber(val)); [EOL]         val = "0xFAE-1"; [EOL]         assertTrue("isNumber(String) 9 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 9 Neg failed", !checkCreateNumber(val)); [EOL]         val = "."; [EOL]         assertTrue("isNumber(String) 10 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 10 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-0ABC123"; [EOL]         assertTrue("isNumber(String) 11 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 11 Neg failed", !checkCreateNumber(val)); [EOL]         val = "123.4E-D"; [EOL]         assertTrue("isNumber(String) 12 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 12 Neg failed", !checkCreateNumber(val)); [EOL]         val = "123.4ED"; [EOL]         assertTrue("isNumber(String) 13 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 13 Neg failed", !checkCreateNumber(val)); [EOL]         val = "1234E5l"; [EOL]         assertTrue("isNumber(String) 14 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 14 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11a"; [EOL]         assertTrue("isNumber(String) 15 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 15 Neg failed", !checkCreateNumber(val)); [EOL]         val = "1a"; [EOL]         assertTrue("isNumber(String) 16 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 16 Neg failed", !checkCreateNumber(val)); [EOL]         val = "a"; [EOL]         assertTrue("isNumber(String) 17 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 17 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11g"; [EOL]         assertTrue("isNumber(String) 18 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 18 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11z"; [EOL]         assertTrue("isNumber(String) 19 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 19 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11def"; [EOL]         assertTrue("isNumber(String) 20 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 20 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11d11"; [EOL]         assertTrue("isNumber(String) 21 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 21 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11 11"; [EOL]         assertTrue("isNumber(String) 22 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 22 Neg failed", !checkCreateNumber(val)); [EOL]         val = " 1111"; [EOL]         assertTrue("isNumber(String) 23 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 23 Neg failed", !checkCreateNumber(val)); [EOL]         val = "1111 "; [EOL]         assertTrue("isNumber(String) 24 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 24 Neg failed", !checkCreateNumber(val)); [EOL]  [EOL]         // LANG-521 [EOL]         val = "2."; [EOL]         assertTrue("isNumber(String) LANG-521 failed", NumberUtils.isNumber(val)); [EOL]  [EOL]         // LANG-664 [EOL]         val = "1.1L"; [EOL]         assertFalse("isNumber(String) LANG-664 failed", NumberUtils.isNumber(val)); [EOL]     } [EOL]  [EOL]     private boolean checkCreateNumber(final String val) { [EOL]         try { [EOL]             final Object obj = NumberUtils.createNumber(val); [EOL]             if (obj == null) { [EOL]                 return false; [EOL]             } [EOL]             return true; [EOL]         } catch (final NumberFormatException e) { [EOL]             return false; [EOL]        } [EOL]     } [EOL]  [EOL]     @SuppressWarnings("cast") // suppress instanceof warning check [EOL]
@Test [EOL]     public void testIsNumber() { [EOL]         String val = "12345"; [EOL]         assertTrue("isNumber(String) 1 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 1 failed", checkCreateNumber(val)); [EOL]         val = "1234.5"; [EOL]         assertTrue("isNumber(String) 2 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 2 failed", checkCreateNumber(val)); [EOL]         val = ".12345"; [EOL]         assertTrue("isNumber(String) 3 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 3 failed", checkCreateNumber(val)); [EOL]         val = "1234E5"; [EOL]         assertTrue("isNumber(String) 4 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 4 failed", checkCreateNumber(val)); [EOL]         val = "1234E+5"; [EOL]         assertTrue("isNumber(String) 5 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 5 failed", checkCreateNumber(val)); [EOL]         val = "1234E-5"; [EOL]         assertTrue("isNumber(String) 6 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 6 failed", checkCreateNumber(val)); [EOL]         val = "123.4E5"; [EOL]         assertTrue("isNumber(String) 7 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 7 failed", checkCreateNumber(val)); [EOL]         val = "-1234"; [EOL]         assertTrue("isNumber(String) 8 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 8 failed", checkCreateNumber(val)); [EOL]         val = "-1234.5"; [EOL]         assertTrue("isNumber(String) 9 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 9 failed", checkCreateNumber(val)); [EOL]         val = "-.12345"; [EOL]         assertTrue("isNumber(String) 10 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 10 failed", checkCreateNumber(val)); [EOL]         val = "-1234E5"; [EOL]         assertTrue("isNumber(String) 11 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 11 failed", checkCreateNumber(val)); [EOL]         val = "0"; [EOL]         assertTrue("isNumber(String) 12 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 12 failed", checkCreateNumber(val)); [EOL]         val = "-0"; [EOL]         assertTrue("isNumber(String) 13 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 13 failed", checkCreateNumber(val)); [EOL]         val = "01234"; [EOL]         assertTrue("isNumber(String) 14 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 14 failed", checkCreateNumber(val)); [EOL]         val = "-01234"; [EOL]         assertTrue("isNumber(String) 15 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 15 failed", checkCreateNumber(val)); [EOL]         val = "0xABC123"; [EOL]         assertTrue("isNumber(String) 16 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 16 failed", checkCreateNumber(val)); [EOL]         val = "0x0"; [EOL]         assertTrue("isNumber(String) 17 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 17 failed", checkCreateNumber(val)); [EOL]         val = "123.4E21D"; [EOL]         assertTrue("isNumber(String) 19 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 19 failed", checkCreateNumber(val)); [EOL]         val = "-221.23F"; [EOL]         assertTrue("isNumber(String) 20 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 20 failed", checkCreateNumber(val)); [EOL]         val = "22338L"; [EOL]         assertTrue("isNumber(String) 21 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 21 failed", checkCreateNumber(val)); [EOL]         val = null; [EOL]         assertTrue("isNumber(String) 1 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 1 Neg failed", !checkCreateNumber(val)); [EOL]         val = ""; [EOL]         assertTrue("isNumber(String) 2 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 2 Neg failed", !checkCreateNumber(val)); [EOL]         val = "--2.3"; [EOL]         assertTrue("isNumber(String) 3 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 3 Neg failed", !checkCreateNumber(val)); [EOL]         val = ".12.3"; [EOL]         assertTrue("isNumber(String) 4 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 4 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-123E"; [EOL]         assertTrue("isNumber(String) 5 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 5 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-123E+-212"; [EOL]         assertTrue("isNumber(String) 6 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 6 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-123E2.12"; [EOL]         assertTrue("isNumber(String) 7 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 7 Neg failed", !checkCreateNumber(val)); [EOL]         val = "0xGF"; [EOL]         assertTrue("isNumber(String) 8 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 8 Neg failed", !checkCreateNumber(val)); [EOL]         val = "0xFAE-1"; [EOL]         assertTrue("isNumber(String) 9 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 9 Neg failed", !checkCreateNumber(val)); [EOL]         val = "."; [EOL]         assertTrue("isNumber(String) 10 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 10 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-0ABC123"; [EOL]         assertTrue("isNumber(String) 11 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 11 Neg failed", !checkCreateNumber(val)); [EOL]         val = "123.4E-D"; [EOL]         assertTrue("isNumber(String) 12 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 12 Neg failed", !checkCreateNumber(val)); [EOL]         val = "123.4ED"; [EOL]         assertTrue("isNumber(String) 13 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 13 Neg failed", !checkCreateNumber(val)); [EOL]         val = "1234E5l"; [EOL]         assertTrue("isNumber(String) 14 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 14 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11a"; [EOL]         assertTrue("isNumber(String) 15 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 15 Neg failed", !checkCreateNumber(val)); [EOL]         val = "1a"; [EOL]         assertTrue("isNumber(String) 16 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 16 Neg failed", !checkCreateNumber(val)); [EOL]         val = "a"; [EOL]         assertTrue("isNumber(String) 17 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 17 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11g"; [EOL]         assertTrue("isNumber(String) 18 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 18 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11z"; [EOL]         assertTrue("isNumber(String) 19 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 19 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11def"; [EOL]         assertTrue("isNumber(String) 20 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 20 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11d11"; [EOL]         assertTrue("isNumber(String) 21 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 21 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11 11"; [EOL]         assertTrue("isNumber(String) 22 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 22 Neg failed", !checkCreateNumber(val)); [EOL]         val = " 1111"; [EOL]         assertTrue("isNumber(String) 23 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 23 Neg failed", !checkCreateNumber(val)); [EOL]         val = "1111 "; [EOL]         assertTrue("isNumber(String) 24 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 24 Neg failed", !checkCreateNumber(val)); [EOL]  [EOL]         // LANG-521 [EOL]         val = "2."; [EOL]         assertTrue("isNumber(String) LANG-521 failed", NumberUtils.isNumber(val)); [EOL]  [EOL]         // LANG-664 [EOL]         val = "1.1L"; [EOL]         assertFalse("isNumber(String) LANG-664 failed", NumberUtils.isNumber(val)); [EOL]     } [EOL]  [EOL]     private boolean checkCreateNumber(final String val) { [EOL]         try { [EOL]             final Object obj = NumberUtils.createNumber(val); [EOL]             if (obj == null) { [EOL]                 return false; [EOL]             } [EOL]             return true; [EOL]         } catch (final NumberFormatException e) { [EOL]             return false; [EOL]        } [EOL]     } [EOL]  [EOL]     @SuppressWarnings("cast") // suppress instanceof warning check [EOL]
@Test [EOL]     public void testIsNumber() { [EOL]         String val = "12345"; [EOL]         assertTrue("isNumber(String) 1 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 1 failed", checkCreateNumber(val)); [EOL]         val = "1234.5"; [EOL]         assertTrue("isNumber(String) 2 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 2 failed", checkCreateNumber(val)); [EOL]         val = ".12345"; [EOL]         assertTrue("isNumber(String) 3 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 3 failed", checkCreateNumber(val)); [EOL]         val = "1234E5"; [EOL]         assertTrue("isNumber(String) 4 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 4 failed", checkCreateNumber(val)); [EOL]         val = "1234E+5"; [EOL]         assertTrue("isNumber(String) 5 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 5 failed", checkCreateNumber(val)); [EOL]         val = "1234E-5"; [EOL]         assertTrue("isNumber(String) 6 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 6 failed", checkCreateNumber(val)); [EOL]         val = "123.4E5"; [EOL]         assertTrue("isNumber(String) 7 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 7 failed", checkCreateNumber(val)); [EOL]         val = "-1234"; [EOL]         assertTrue("isNumber(String) 8 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 8 failed", checkCreateNumber(val)); [EOL]         val = "-1234.5"; [EOL]         assertTrue("isNumber(String) 9 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 9 failed", checkCreateNumber(val)); [EOL]         val = "-.12345"; [EOL]         assertTrue("isNumber(String) 10 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 10 failed", checkCreateNumber(val)); [EOL]         val = "-1234E5"; [EOL]         assertTrue("isNumber(String) 11 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 11 failed", checkCreateNumber(val)); [EOL]         val = "0"; [EOL]         assertTrue("isNumber(String) 12 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 12 failed", checkCreateNumber(val)); [EOL]         val = "-0"; [EOL]         assertTrue("isNumber(String) 13 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 13 failed", checkCreateNumber(val)); [EOL]         val = "01234"; [EOL]         assertTrue("isNumber(String) 14 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 14 failed", checkCreateNumber(val)); [EOL]         val = "-01234"; [EOL]         assertTrue("isNumber(String) 15 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 15 failed", checkCreateNumber(val)); [EOL]         val = "0xABC123"; [EOL]         assertTrue("isNumber(String) 16 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 16 failed", checkCreateNumber(val)); [EOL]         val = "0x0"; [EOL]         assertTrue("isNumber(String) 17 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 17 failed", checkCreateNumber(val)); [EOL]         val = "123.4E21D"; [EOL]         assertTrue("isNumber(String) 19 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 19 failed", checkCreateNumber(val)); [EOL]         val = "-221.23F"; [EOL]         assertTrue("isNumber(String) 20 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 20 failed", checkCreateNumber(val)); [EOL]         val = "22338L"; [EOL]         assertTrue("isNumber(String) 21 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 21 failed", checkCreateNumber(val)); [EOL]         val = null; [EOL]         assertTrue("isNumber(String) 1 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 1 Neg failed", !checkCreateNumber(val)); [EOL]         val = ""; [EOL]         assertTrue("isNumber(String) 2 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 2 Neg failed", !checkCreateNumber(val)); [EOL]         val = "--2.3"; [EOL]         assertTrue("isNumber(String) 3 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 3 Neg failed", !checkCreateNumber(val)); [EOL]         val = ".12.3"; [EOL]         assertTrue("isNumber(String) 4 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 4 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-123E"; [EOL]         assertTrue("isNumber(String) 5 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 5 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-123E+-212"; [EOL]         assertTrue("isNumber(String) 6 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 6 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-123E2.12"; [EOL]         assertTrue("isNumber(String) 7 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 7 Neg failed", !checkCreateNumber(val)); [EOL]         val = "0xGF"; [EOL]         assertTrue("isNumber(String) 8 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 8 Neg failed", !checkCreateNumber(val)); [EOL]         val = "0xFAE-1"; [EOL]         assertTrue("isNumber(String) 9 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 9 Neg failed", !checkCreateNumber(val)); [EOL]         val = "."; [EOL]         assertTrue("isNumber(String) 10 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 10 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-0ABC123"; [EOL]         assertTrue("isNumber(String) 11 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 11 Neg failed", !checkCreateNumber(val)); [EOL]         val = "123.4E-D"; [EOL]         assertTrue("isNumber(String) 12 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 12 Neg failed", !checkCreateNumber(val)); [EOL]         val = "123.4ED"; [EOL]         assertTrue("isNumber(String) 13 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 13 Neg failed", !checkCreateNumber(val)); [EOL]         val = "1234E5l"; [EOL]         assertTrue("isNumber(String) 14 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 14 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11a"; [EOL]         assertTrue("isNumber(String) 15 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 15 Neg failed", !checkCreateNumber(val)); [EOL]         val = "1a"; [EOL]         assertTrue("isNumber(String) 16 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 16 Neg failed", !checkCreateNumber(val)); [EOL]         val = "a"; [EOL]         assertTrue("isNumber(String) 17 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 17 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11g"; [EOL]         assertTrue("isNumber(String) 18 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 18 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11z"; [EOL]         assertTrue("isNumber(String) 19 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 19 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11def"; [EOL]         assertTrue("isNumber(String) 20 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 20 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11d11"; [EOL]         assertTrue("isNumber(String) 21 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 21 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11 11"; [EOL]         assertTrue("isNumber(String) 22 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 22 Neg failed", !checkCreateNumber(val)); [EOL]         val = " 1111"; [EOL]         assertTrue("isNumber(String) 23 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 23 Neg failed", !checkCreateNumber(val)); [EOL]         val = "1111 "; [EOL]         assertTrue("isNumber(String) 24 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 24 Neg failed", !checkCreateNumber(val)); [EOL]  [EOL]         // LANG-521 [EOL]         val = "2."; [EOL]         assertTrue("isNumber(String) LANG-521 failed", NumberUtils.isNumber(val)); [EOL]  [EOL]         // LANG-664 [EOL]         val = "1.1L"; [EOL]         assertFalse("isNumber(String) LANG-664 failed", NumberUtils.isNumber(val)); [EOL]     } [EOL]  [EOL]     private boolean checkCreateNumber(final String val) { [EOL]         try { [EOL]             final Object obj = NumberUtils.createNumber(val); [EOL]             if (obj == null) { [EOL]                 return false; [EOL]             } [EOL]             return true; [EOL]         } catch (final NumberFormatException e) { [EOL]             return false; [EOL]        } [EOL]     } [EOL]  [EOL]     @SuppressWarnings("cast") // suppress instanceof warning check [EOL]
@Test [EOL]     public void testIsNumber() { [EOL]         String val = "12345"; [EOL]         assertTrue("isNumber(String) 1 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 1 failed", checkCreateNumber(val)); [EOL]         val = "1234.5"; [EOL]         assertTrue("isNumber(String) 2 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 2 failed", checkCreateNumber(val)); [EOL]         val = ".12345"; [EOL]         assertTrue("isNumber(String) 3 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 3 failed", checkCreateNumber(val)); [EOL]         val = "1234E5"; [EOL]         assertTrue("isNumber(String) 4 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 4 failed", checkCreateNumber(val)); [EOL]         val = "1234E+5"; [EOL]         assertTrue("isNumber(String) 5 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 5 failed", checkCreateNumber(val)); [EOL]         val = "1234E-5"; [EOL]         assertTrue("isNumber(String) 6 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 6 failed", checkCreateNumber(val)); [EOL]         val = "123.4E5"; [EOL]         assertTrue("isNumber(String) 7 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 7 failed", checkCreateNumber(val)); [EOL]         val = "-1234"; [EOL]         assertTrue("isNumber(String) 8 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 8 failed", checkCreateNumber(val)); [EOL]         val = "-1234.5"; [EOL]         assertTrue("isNumber(String) 9 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 9 failed", checkCreateNumber(val)); [EOL]         val = "-.12345"; [EOL]         assertTrue("isNumber(String) 10 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 10 failed", checkCreateNumber(val)); [EOL]         val = "-1234E5"; [EOL]         assertTrue("isNumber(String) 11 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 11 failed", checkCreateNumber(val)); [EOL]         val = "0"; [EOL]         assertTrue("isNumber(String) 12 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 12 failed", checkCreateNumber(val)); [EOL]         val = "-0"; [EOL]         assertTrue("isNumber(String) 13 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 13 failed", checkCreateNumber(val)); [EOL]         val = "01234"; [EOL]         assertTrue("isNumber(String) 14 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 14 failed", checkCreateNumber(val)); [EOL]         val = "-01234"; [EOL]         assertTrue("isNumber(String) 15 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 15 failed", checkCreateNumber(val)); [EOL]         val = "0xABC123"; [EOL]         assertTrue("isNumber(String) 16 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 16 failed", checkCreateNumber(val)); [EOL]         val = "0x0"; [EOL]         assertTrue("isNumber(String) 17 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 17 failed", checkCreateNumber(val)); [EOL]         val = "123.4E21D"; [EOL]         assertTrue("isNumber(String) 19 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 19 failed", checkCreateNumber(val)); [EOL]         val = "-221.23F"; [EOL]         assertTrue("isNumber(String) 20 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 20 failed", checkCreateNumber(val)); [EOL]         val = "22338L"; [EOL]         assertTrue("isNumber(String) 21 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 21 failed", checkCreateNumber(val)); [EOL]         val = null; [EOL]         assertTrue("isNumber(String) 1 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 1 Neg failed", !checkCreateNumber(val)); [EOL]         val = ""; [EOL]         assertTrue("isNumber(String) 2 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 2 Neg failed", !checkCreateNumber(val)); [EOL]         val = "--2.3"; [EOL]         assertTrue("isNumber(String) 3 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 3 Neg failed", !checkCreateNumber(val)); [EOL]         val = ".12.3"; [EOL]         assertTrue("isNumber(String) 4 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 4 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-123E"; [EOL]         assertTrue("isNumber(String) 5 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 5 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-123E+-212"; [EOL]         assertTrue("isNumber(String) 6 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 6 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-123E2.12"; [EOL]         assertTrue("isNumber(String) 7 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 7 Neg failed", !checkCreateNumber(val)); [EOL]         val = "0xGF"; [EOL]         assertTrue("isNumber(String) 8 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 8 Neg failed", !checkCreateNumber(val)); [EOL]         val = "0xFAE-1"; [EOL]         assertTrue("isNumber(String) 9 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 9 Neg failed", !checkCreateNumber(val)); [EOL]         val = "."; [EOL]         assertTrue("isNumber(String) 10 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 10 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-0ABC123"; [EOL]         assertTrue("isNumber(String) 11 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 11 Neg failed", !checkCreateNumber(val)); [EOL]         val = "123.4E-D"; [EOL]         assertTrue("isNumber(String) 12 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 12 Neg failed", !checkCreateNumber(val)); [EOL]         val = "123.4ED"; [EOL]         assertTrue("isNumber(String) 13 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 13 Neg failed", !checkCreateNumber(val)); [EOL]         val = "1234E5l"; [EOL]         assertTrue("isNumber(String) 14 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 14 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11a"; [EOL]         assertTrue("isNumber(String) 15 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 15 Neg failed", !checkCreateNumber(val)); [EOL]         val = "1a"; [EOL]         assertTrue("isNumber(String) 16 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 16 Neg failed", !checkCreateNumber(val)); [EOL]         val = "a"; [EOL]         assertTrue("isNumber(String) 17 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 17 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11g"; [EOL]         assertTrue("isNumber(String) 18 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 18 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11z"; [EOL]         assertTrue("isNumber(String) 19 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 19 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11def"; [EOL]         assertTrue("isNumber(String) 20 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 20 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11d11"; [EOL]         assertTrue("isNumber(String) 21 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 21 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11 11"; [EOL]         assertTrue("isNumber(String) 22 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 22 Neg failed", !checkCreateNumber(val)); [EOL]         val = " 1111"; [EOL]         assertTrue("isNumber(String) 23 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 23 Neg failed", !checkCreateNumber(val)); [EOL]         val = "1111 "; [EOL]         assertTrue("isNumber(String) 24 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 24 Neg failed", !checkCreateNumber(val)); [EOL]  [EOL]         // LANG-521 [EOL]         val = "2."; [EOL]         assertTrue("isNumber(String) LANG-521 failed", NumberUtils.isNumber(val)); [EOL]  [EOL]         // LANG-664 [EOL]         val = "1.1L"; [EOL]         assertFalse("isNumber(String) LANG-664 failed", NumberUtils.isNumber(val)); [EOL]     } [EOL]  [EOL]     private boolean checkCreateNumber(final String val) { [EOL]         try { [EOL]             final Object obj = NumberUtils.createNumber(val); [EOL]             if (obj == null) { [EOL]                 return false; [EOL]             } [EOL]             return true; [EOL]         } catch (final NumberFormatException e) { [EOL]             return false; [EOL]        } [EOL]     } [EOL]  [EOL]     @SuppressWarnings("cast") // suppress instanceof warning check [EOL]
@Test [EOL]     public void testIsNumber() { [EOL]         String val = "12345"; [EOL]         assertTrue("isNumber(String) 1 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 1 failed", checkCreateNumber(val)); [EOL]         val = "1234.5"; [EOL]         assertTrue("isNumber(String) 2 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 2 failed", checkCreateNumber(val)); [EOL]         val = ".12345"; [EOL]         assertTrue("isNumber(String) 3 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 3 failed", checkCreateNumber(val)); [EOL]         val = "1234E5"; [EOL]         assertTrue("isNumber(String) 4 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 4 failed", checkCreateNumber(val)); [EOL]         val = "1234E+5"; [EOL]         assertTrue("isNumber(String) 5 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 5 failed", checkCreateNumber(val)); [EOL]         val = "1234E-5"; [EOL]         assertTrue("isNumber(String) 6 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 6 failed", checkCreateNumber(val)); [EOL]         val = "123.4E5"; [EOL]         assertTrue("isNumber(String) 7 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 7 failed", checkCreateNumber(val)); [EOL]         val = "-1234"; [EOL]         assertTrue("isNumber(String) 8 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 8 failed", checkCreateNumber(val)); [EOL]         val = "-1234.5"; [EOL]         assertTrue("isNumber(String) 9 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 9 failed", checkCreateNumber(val)); [EOL]         val = "-.12345"; [EOL]         assertTrue("isNumber(String) 10 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 10 failed", checkCreateNumber(val)); [EOL]         val = "-1234E5"; [EOL]         assertTrue("isNumber(String) 11 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 11 failed", checkCreateNumber(val)); [EOL]         val = "0"; [EOL]         assertTrue("isNumber(String) 12 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 12 failed", checkCreateNumber(val)); [EOL]         val = "-0"; [EOL]         assertTrue("isNumber(String) 13 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 13 failed", checkCreateNumber(val)); [EOL]         val = "01234"; [EOL]         assertTrue("isNumber(String) 14 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 14 failed", checkCreateNumber(val)); [EOL]         val = "-01234"; [EOL]         assertTrue("isNumber(String) 15 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 15 failed", checkCreateNumber(val)); [EOL]         val = "0xABC123"; [EOL]         assertTrue("isNumber(String) 16 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 16 failed", checkCreateNumber(val)); [EOL]         val = "0x0"; [EOL]         assertTrue("isNumber(String) 17 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 17 failed", checkCreateNumber(val)); [EOL]         val = "123.4E21D"; [EOL]         assertTrue("isNumber(String) 19 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 19 failed", checkCreateNumber(val)); [EOL]         val = "-221.23F"; [EOL]         assertTrue("isNumber(String) 20 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 20 failed", checkCreateNumber(val)); [EOL]         val = "22338L"; [EOL]         assertTrue("isNumber(String) 21 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 21 failed", checkCreateNumber(val)); [EOL]         val = null; [EOL]         assertTrue("isNumber(String) 1 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 1 Neg failed", !checkCreateNumber(val)); [EOL]         val = ""; [EOL]         assertTrue("isNumber(String) 2 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 2 Neg failed", !checkCreateNumber(val)); [EOL]         val = "--2.3"; [EOL]         assertTrue("isNumber(String) 3 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 3 Neg failed", !checkCreateNumber(val)); [EOL]         val = ".12.3"; [EOL]         assertTrue("isNumber(String) 4 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 4 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-123E"; [EOL]         assertTrue("isNumber(String) 5 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 5 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-123E+-212"; [EOL]         assertTrue("isNumber(String) 6 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 6 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-123E2.12"; [EOL]         assertTrue("isNumber(String) 7 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 7 Neg failed", !checkCreateNumber(val)); [EOL]         val = "0xGF"; [EOL]         assertTrue("isNumber(String) 8 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 8 Neg failed", !checkCreateNumber(val)); [EOL]         val = "0xFAE-1"; [EOL]         assertTrue("isNumber(String) 9 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 9 Neg failed", !checkCreateNumber(val)); [EOL]         val = "."; [EOL]         assertTrue("isNumber(String) 10 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 10 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-0ABC123"; [EOL]         assertTrue("isNumber(String) 11 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 11 Neg failed", !checkCreateNumber(val)); [EOL]         val = "123.4E-D"; [EOL]         assertTrue("isNumber(String) 12 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 12 Neg failed", !checkCreateNumber(val)); [EOL]         val = "123.4ED"; [EOL]         assertTrue("isNumber(String) 13 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 13 Neg failed", !checkCreateNumber(val)); [EOL]         val = "1234E5l"; [EOL]         assertTrue("isNumber(String) 14 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 14 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11a"; [EOL]         assertTrue("isNumber(String) 15 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 15 Neg failed", !checkCreateNumber(val)); [EOL]         val = "1a"; [EOL]         assertTrue("isNumber(String) 16 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 16 Neg failed", !checkCreateNumber(val)); [EOL]         val = "a"; [EOL]         assertTrue("isNumber(String) 17 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 17 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11g"; [EOL]         assertTrue("isNumber(String) 18 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 18 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11z"; [EOL]         assertTrue("isNumber(String) 19 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 19 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11def"; [EOL]         assertTrue("isNumber(String) 20 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 20 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11d11"; [EOL]         assertTrue("isNumber(String) 21 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 21 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11 11"; [EOL]         assertTrue("isNumber(String) 22 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 22 Neg failed", !checkCreateNumber(val)); [EOL]         val = " 1111"; [EOL]         assertTrue("isNumber(String) 23 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 23 Neg failed", !checkCreateNumber(val)); [EOL]         val = "1111 "; [EOL]         assertTrue("isNumber(String) 24 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 24 Neg failed", !checkCreateNumber(val)); [EOL]  [EOL]         // LANG-521 [EOL]         val = "2."; [EOL]         assertTrue("isNumber(String) LANG-521 failed", NumberUtils.isNumber(val)); [EOL]  [EOL]         // LANG-664 [EOL]         val = "1.1L"; [EOL]         assertFalse("isNumber(String) LANG-664 failed", NumberUtils.isNumber(val)); [EOL]     } [EOL]  [EOL]     private boolean checkCreateNumber(final String val) { [EOL]         try { [EOL]             final Object obj = NumberUtils.createNumber(val); [EOL]             if (obj == null) { [EOL]                 return false; [EOL]             } [EOL]             return true; [EOL]         } catch (final NumberFormatException e) { [EOL]             return false; [EOL]        } [EOL]     } [EOL]  [EOL]     @SuppressWarnings("cast") // suppress instanceof warning check [EOL]
@Test [EOL]     public void testIsNumber() { [EOL]         String val = "12345"; [EOL]         assertTrue("isNumber(String) 1 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 1 failed", checkCreateNumber(val)); [EOL]         val = "1234.5"; [EOL]         assertTrue("isNumber(String) 2 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 2 failed", checkCreateNumber(val)); [EOL]         val = ".12345"; [EOL]         assertTrue("isNumber(String) 3 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 3 failed", checkCreateNumber(val)); [EOL]         val = "1234E5"; [EOL]         assertTrue("isNumber(String) 4 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 4 failed", checkCreateNumber(val)); [EOL]         val = "1234E+5"; [EOL]         assertTrue("isNumber(String) 5 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 5 failed", checkCreateNumber(val)); [EOL]         val = "1234E-5"; [EOL]         assertTrue("isNumber(String) 6 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 6 failed", checkCreateNumber(val)); [EOL]         val = "123.4E5"; [EOL]         assertTrue("isNumber(String) 7 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 7 failed", checkCreateNumber(val)); [EOL]         val = "-1234"; [EOL]         assertTrue("isNumber(String) 8 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 8 failed", checkCreateNumber(val)); [EOL]         val = "-1234.5"; [EOL]         assertTrue("isNumber(String) 9 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 9 failed", checkCreateNumber(val)); [EOL]         val = "-.12345"; [EOL]         assertTrue("isNumber(String) 10 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 10 failed", checkCreateNumber(val)); [EOL]         val = "-1234E5"; [EOL]         assertTrue("isNumber(String) 11 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 11 failed", checkCreateNumber(val)); [EOL]         val = "0"; [EOL]         assertTrue("isNumber(String) 12 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 12 failed", checkCreateNumber(val)); [EOL]         val = "-0"; [EOL]         assertTrue("isNumber(String) 13 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 13 failed", checkCreateNumber(val)); [EOL]         val = "01234"; [EOL]         assertTrue("isNumber(String) 14 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 14 failed", checkCreateNumber(val)); [EOL]         val = "-01234"; [EOL]         assertTrue("isNumber(String) 15 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 15 failed", checkCreateNumber(val)); [EOL]         val = "0xABC123"; [EOL]         assertTrue("isNumber(String) 16 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 16 failed", checkCreateNumber(val)); [EOL]         val = "0x0"; [EOL]         assertTrue("isNumber(String) 17 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 17 failed", checkCreateNumber(val)); [EOL]         val = "123.4E21D"; [EOL]         assertTrue("isNumber(String) 19 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 19 failed", checkCreateNumber(val)); [EOL]         val = "-221.23F"; [EOL]         assertTrue("isNumber(String) 20 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 20 failed", checkCreateNumber(val)); [EOL]         val = "22338L"; [EOL]         assertTrue("isNumber(String) 21 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 21 failed", checkCreateNumber(val)); [EOL]         val = null; [EOL]         assertTrue("isNumber(String) 1 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 1 Neg failed", !checkCreateNumber(val)); [EOL]         val = ""; [EOL]         assertTrue("isNumber(String) 2 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 2 Neg failed", !checkCreateNumber(val)); [EOL]         val = "--2.3"; [EOL]         assertTrue("isNumber(String) 3 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 3 Neg failed", !checkCreateNumber(val)); [EOL]         val = ".12.3"; [EOL]         assertTrue("isNumber(String) 4 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 4 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-123E"; [EOL]         assertTrue("isNumber(String) 5 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 5 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-123E+-212"; [EOL]         assertTrue("isNumber(String) 6 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 6 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-123E2.12"; [EOL]         assertTrue("isNumber(String) 7 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 7 Neg failed", !checkCreateNumber(val)); [EOL]         val = "0xGF"; [EOL]         assertTrue("isNumber(String) 8 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 8 Neg failed", !checkCreateNumber(val)); [EOL]         val = "0xFAE-1"; [EOL]         assertTrue("isNumber(String) 9 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 9 Neg failed", !checkCreateNumber(val)); [EOL]         val = "."; [EOL]         assertTrue("isNumber(String) 10 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 10 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-0ABC123"; [EOL]         assertTrue("isNumber(String) 11 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 11 Neg failed", !checkCreateNumber(val)); [EOL]         val = "123.4E-D"; [EOL]         assertTrue("isNumber(String) 12 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 12 Neg failed", !checkCreateNumber(val)); [EOL]         val = "123.4ED"; [EOL]         assertTrue("isNumber(String) 13 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 13 Neg failed", !checkCreateNumber(val)); [EOL]         val = "1234E5l"; [EOL]         assertTrue("isNumber(String) 14 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 14 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11a"; [EOL]         assertTrue("isNumber(String) 15 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 15 Neg failed", !checkCreateNumber(val)); [EOL]         val = "1a"; [EOL]         assertTrue("isNumber(String) 16 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 16 Neg failed", !checkCreateNumber(val)); [EOL]         val = "a"; [EOL]         assertTrue("isNumber(String) 17 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 17 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11g"; [EOL]         assertTrue("isNumber(String) 18 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 18 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11z"; [EOL]         assertTrue("isNumber(String) 19 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 19 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11def"; [EOL]         assertTrue("isNumber(String) 20 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 20 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11d11"; [EOL]         assertTrue("isNumber(String) 21 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 21 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11 11"; [EOL]         assertTrue("isNumber(String) 22 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 22 Neg failed", !checkCreateNumber(val)); [EOL]         val = " 1111"; [EOL]         assertTrue("isNumber(String) 23 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 23 Neg failed", !checkCreateNumber(val)); [EOL]         val = "1111 "; [EOL]         assertTrue("isNumber(String) 24 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 24 Neg failed", !checkCreateNumber(val)); [EOL]  [EOL]         // LANG-521 [EOL]         val = "2."; [EOL]         assertTrue("isNumber(String) LANG-521 failed", NumberUtils.isNumber(val)); [EOL]  [EOL]         // LANG-664 [EOL]         val = "1.1L"; [EOL]         assertFalse("isNumber(String) LANG-664 failed", NumberUtils.isNumber(val)); [EOL]     } [EOL]  [EOL]     private boolean checkCreateNumber(final String val) { [EOL]         try { [EOL]             final Object obj = NumberUtils.createNumber(val); [EOL]             if (obj == null) { [EOL]                 return false; [EOL]             } [EOL]             return true; [EOL]         } catch (final NumberFormatException e) { [EOL]             return false; [EOL]        } [EOL]     } [EOL]  [EOL]     @SuppressWarnings("cast") // suppress instanceof warning check [EOL]
@Test [EOL]     public void testIsNumber() { [EOL]         String val = "12345"; [EOL]         assertTrue("isNumber(String) 1 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 1 failed", checkCreateNumber(val)); [EOL]         val = "1234.5"; [EOL]         assertTrue("isNumber(String) 2 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 2 failed", checkCreateNumber(val)); [EOL]         val = ".12345"; [EOL]         assertTrue("isNumber(String) 3 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 3 failed", checkCreateNumber(val)); [EOL]         val = "1234E5"; [EOL]         assertTrue("isNumber(String) 4 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 4 failed", checkCreateNumber(val)); [EOL]         val = "1234E+5"; [EOL]         assertTrue("isNumber(String) 5 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 5 failed", checkCreateNumber(val)); [EOL]         val = "1234E-5"; [EOL]         assertTrue("isNumber(String) 6 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 6 failed", checkCreateNumber(val)); [EOL]         val = "123.4E5"; [EOL]         assertTrue("isNumber(String) 7 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 7 failed", checkCreateNumber(val)); [EOL]         val = "-1234"; [EOL]         assertTrue("isNumber(String) 8 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 8 failed", checkCreateNumber(val)); [EOL]         val = "-1234.5"; [EOL]         assertTrue("isNumber(String) 9 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 9 failed", checkCreateNumber(val)); [EOL]         val = "-.12345"; [EOL]         assertTrue("isNumber(String) 10 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 10 failed", checkCreateNumber(val)); [EOL]         val = "-1234E5"; [EOL]         assertTrue("isNumber(String) 11 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 11 failed", checkCreateNumber(val)); [EOL]         val = "0"; [EOL]         assertTrue("isNumber(String) 12 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 12 failed", checkCreateNumber(val)); [EOL]         val = "-0"; [EOL]         assertTrue("isNumber(String) 13 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 13 failed", checkCreateNumber(val)); [EOL]         val = "01234"; [EOL]         assertTrue("isNumber(String) 14 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 14 failed", checkCreateNumber(val)); [EOL]         val = "-01234"; [EOL]         assertTrue("isNumber(String) 15 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 15 failed", checkCreateNumber(val)); [EOL]         val = "0xABC123"; [EOL]         assertTrue("isNumber(String) 16 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 16 failed", checkCreateNumber(val)); [EOL]         val = "0x0"; [EOL]         assertTrue("isNumber(String) 17 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 17 failed", checkCreateNumber(val)); [EOL]         val = "123.4E21D"; [EOL]         assertTrue("isNumber(String) 19 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 19 failed", checkCreateNumber(val)); [EOL]         val = "-221.23F"; [EOL]         assertTrue("isNumber(String) 20 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 20 failed", checkCreateNumber(val)); [EOL]         val = "22338L"; [EOL]         assertTrue("isNumber(String) 21 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 21 failed", checkCreateNumber(val)); [EOL]         val = null; [EOL]         assertTrue("isNumber(String) 1 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 1 Neg failed", !checkCreateNumber(val)); [EOL]         val = ""; [EOL]         assertTrue("isNumber(String) 2 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 2 Neg failed", !checkCreateNumber(val)); [EOL]         val = "--2.3"; [EOL]         assertTrue("isNumber(String) 3 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 3 Neg failed", !checkCreateNumber(val)); [EOL]         val = ".12.3"; [EOL]         assertTrue("isNumber(String) 4 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 4 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-123E"; [EOL]         assertTrue("isNumber(String) 5 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 5 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-123E+-212"; [EOL]         assertTrue("isNumber(String) 6 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 6 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-123E2.12"; [EOL]         assertTrue("isNumber(String) 7 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 7 Neg failed", !checkCreateNumber(val)); [EOL]         val = "0xGF"; [EOL]         assertTrue("isNumber(String) 8 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 8 Neg failed", !checkCreateNumber(val)); [EOL]         val = "0xFAE-1"; [EOL]         assertTrue("isNumber(String) 9 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 9 Neg failed", !checkCreateNumber(val)); [EOL]         val = "."; [EOL]         assertTrue("isNumber(String) 10 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 10 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-0ABC123"; [EOL]         assertTrue("isNumber(String) 11 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 11 Neg failed", !checkCreateNumber(val)); [EOL]         val = "123.4E-D"; [EOL]         assertTrue("isNumber(String) 12 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 12 Neg failed", !checkCreateNumber(val)); [EOL]         val = "123.4ED"; [EOL]         assertTrue("isNumber(String) 13 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 13 Neg failed", !checkCreateNumber(val)); [EOL]         val = "1234E5l"; [EOL]         assertTrue("isNumber(String) 14 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 14 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11a"; [EOL]         assertTrue("isNumber(String) 15 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 15 Neg failed", !checkCreateNumber(val)); [EOL]         val = "1a"; [EOL]         assertTrue("isNumber(String) 16 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 16 Neg failed", !checkCreateNumber(val)); [EOL]         val = "a"; [EOL]         assertTrue("isNumber(String) 17 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 17 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11g"; [EOL]         assertTrue("isNumber(String) 18 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 18 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11z"; [EOL]         assertTrue("isNumber(String) 19 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 19 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11def"; [EOL]         assertTrue("isNumber(String) 20 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 20 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11d11"; [EOL]         assertTrue("isNumber(String) 21 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 21 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11 11"; [EOL]         assertTrue("isNumber(String) 22 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 22 Neg failed", !checkCreateNumber(val)); [EOL]         val = " 1111"; [EOL]         assertTrue("isNumber(String) 23 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 23 Neg failed", !checkCreateNumber(val)); [EOL]         val = "1111 "; [EOL]         assertTrue("isNumber(String) 24 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 24 Neg failed", !checkCreateNumber(val)); [EOL]  [EOL]         // LANG-521 [EOL]         val = "2."; [EOL]         assertTrue("isNumber(String) LANG-521 failed", NumberUtils.isNumber(val)); [EOL]  [EOL]         // LANG-664 [EOL]         val = "1.1L"; [EOL]         assertFalse("isNumber(String) LANG-664 failed", NumberUtils.isNumber(val)); [EOL]     } [EOL]  [EOL]     private boolean checkCreateNumber(final String val) { [EOL]         try { [EOL]             final Object obj = NumberUtils.createNumber(val); [EOL]             if (obj == null) { [EOL]                 return false; [EOL]             } [EOL]             return true; [EOL]         } catch (final NumberFormatException e) { [EOL]             return false; [EOL]        } [EOL]     } [EOL]  [EOL]     @SuppressWarnings("cast") // suppress instanceof warning check [EOL]
@Test [EOL]     public void testIsNumber() { [EOL]         String val = "12345"; [EOL]         assertTrue("isNumber(String) 1 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 1 failed", checkCreateNumber(val)); [EOL]         val = "1234.5"; [EOL]         assertTrue("isNumber(String) 2 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 2 failed", checkCreateNumber(val)); [EOL]         val = ".12345"; [EOL]         assertTrue("isNumber(String) 3 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 3 failed", checkCreateNumber(val)); [EOL]         val = "1234E5"; [EOL]         assertTrue("isNumber(String) 4 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 4 failed", checkCreateNumber(val)); [EOL]         val = "1234E+5"; [EOL]         assertTrue("isNumber(String) 5 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 5 failed", checkCreateNumber(val)); [EOL]         val = "1234E-5"; [EOL]         assertTrue("isNumber(String) 6 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 6 failed", checkCreateNumber(val)); [EOL]         val = "123.4E5"; [EOL]         assertTrue("isNumber(String) 7 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 7 failed", checkCreateNumber(val)); [EOL]         val = "-1234"; [EOL]         assertTrue("isNumber(String) 8 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 8 failed", checkCreateNumber(val)); [EOL]         val = "-1234.5"; [EOL]         assertTrue("isNumber(String) 9 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 9 failed", checkCreateNumber(val)); [EOL]         val = "-.12345"; [EOL]         assertTrue("isNumber(String) 10 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 10 failed", checkCreateNumber(val)); [EOL]         val = "-1234E5"; [EOL]         assertTrue("isNumber(String) 11 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 11 failed", checkCreateNumber(val)); [EOL]         val = "0"; [EOL]         assertTrue("isNumber(String) 12 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 12 failed", checkCreateNumber(val)); [EOL]         val = "-0"; [EOL]         assertTrue("isNumber(String) 13 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 13 failed", checkCreateNumber(val)); [EOL]         val = "01234"; [EOL]         assertTrue("isNumber(String) 14 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 14 failed", checkCreateNumber(val)); [EOL]         val = "-01234"; [EOL]         assertTrue("isNumber(String) 15 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 15 failed", checkCreateNumber(val)); [EOL]         val = "0xABC123"; [EOL]         assertTrue("isNumber(String) 16 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 16 failed", checkCreateNumber(val)); [EOL]         val = "0x0"; [EOL]         assertTrue("isNumber(String) 17 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 17 failed", checkCreateNumber(val)); [EOL]         val = "123.4E21D"; [EOL]         assertTrue("isNumber(String) 19 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 19 failed", checkCreateNumber(val)); [EOL]         val = "-221.23F"; [EOL]         assertTrue("isNumber(String) 20 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 20 failed", checkCreateNumber(val)); [EOL]         val = "22338L"; [EOL]         assertTrue("isNumber(String) 21 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 21 failed", checkCreateNumber(val)); [EOL]         val = null; [EOL]         assertTrue("isNumber(String) 1 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 1 Neg failed", !checkCreateNumber(val)); [EOL]         val = ""; [EOL]         assertTrue("isNumber(String) 2 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 2 Neg failed", !checkCreateNumber(val)); [EOL]         val = "--2.3"; [EOL]         assertTrue("isNumber(String) 3 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 3 Neg failed", !checkCreateNumber(val)); [EOL]         val = ".12.3"; [EOL]         assertTrue("isNumber(String) 4 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 4 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-123E"; [EOL]         assertTrue("isNumber(String) 5 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 5 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-123E+-212"; [EOL]         assertTrue("isNumber(String) 6 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 6 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-123E2.12"; [EOL]         assertTrue("isNumber(String) 7 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 7 Neg failed", !checkCreateNumber(val)); [EOL]         val = "0xGF"; [EOL]         assertTrue("isNumber(String) 8 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 8 Neg failed", !checkCreateNumber(val)); [EOL]         val = "0xFAE-1"; [EOL]         assertTrue("isNumber(String) 9 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 9 Neg failed", !checkCreateNumber(val)); [EOL]         val = "."; [EOL]         assertTrue("isNumber(String) 10 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 10 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-0ABC123"; [EOL]         assertTrue("isNumber(String) 11 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 11 Neg failed", !checkCreateNumber(val)); [EOL]         val = "123.4E-D"; [EOL]         assertTrue("isNumber(String) 12 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 12 Neg failed", !checkCreateNumber(val)); [EOL]         val = "123.4ED"; [EOL]         assertTrue("isNumber(String) 13 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 13 Neg failed", !checkCreateNumber(val)); [EOL]         val = "1234E5l"; [EOL]         assertTrue("isNumber(String) 14 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 14 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11a"; [EOL]         assertTrue("isNumber(String) 15 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 15 Neg failed", !checkCreateNumber(val)); [EOL]         val = "1a"; [EOL]         assertTrue("isNumber(String) 16 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 16 Neg failed", !checkCreateNumber(val)); [EOL]         val = "a"; [EOL]         assertTrue("isNumber(String) 17 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 17 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11g"; [EOL]         assertTrue("isNumber(String) 18 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 18 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11z"; [EOL]         assertTrue("isNumber(String) 19 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 19 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11def"; [EOL]         assertTrue("isNumber(String) 20 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 20 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11d11"; [EOL]         assertTrue("isNumber(String) 21 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 21 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11 11"; [EOL]         assertTrue("isNumber(String) 22 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 22 Neg failed", !checkCreateNumber(val)); [EOL]         val = " 1111"; [EOL]         assertTrue("isNumber(String) 23 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 23 Neg failed", !checkCreateNumber(val)); [EOL]         val = "1111 "; [EOL]         assertTrue("isNumber(String) 24 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 24 Neg failed", !checkCreateNumber(val)); [EOL]  [EOL]         // LANG-521 [EOL]         val = "2."; [EOL]         assertTrue("isNumber(String) LANG-521 failed", NumberUtils.isNumber(val)); [EOL]  [EOL]         // LANG-664 [EOL]         val = "1.1L"; [EOL]         assertFalse("isNumber(String) LANG-664 failed", NumberUtils.isNumber(val)); [EOL]     } [EOL]  [EOL]     private boolean checkCreateNumber(final String val) { [EOL]         try { [EOL]             final Object obj = NumberUtils.createNumber(val); [EOL]             if (obj == null) { [EOL]                 return false; [EOL]             } [EOL]             return true; [EOL]         } catch (final NumberFormatException e) { [EOL]             return false; [EOL]        } [EOL]     } [EOL]  [EOL]     @SuppressWarnings("cast") // suppress instanceof warning check [EOL]
@Test [EOL]     public void testIsNumber() { [EOL]         String val = "12345"; [EOL]         assertTrue("isNumber(String) 1 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 1 failed", checkCreateNumber(val)); [EOL]         val = "1234.5"; [EOL]         assertTrue("isNumber(String) 2 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 2 failed", checkCreateNumber(val)); [EOL]         val = ".12345"; [EOL]         assertTrue("isNumber(String) 3 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 3 failed", checkCreateNumber(val)); [EOL]         val = "1234E5"; [EOL]         assertTrue("isNumber(String) 4 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 4 failed", checkCreateNumber(val)); [EOL]         val = "1234E+5"; [EOL]         assertTrue("isNumber(String) 5 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 5 failed", checkCreateNumber(val)); [EOL]         val = "1234E-5"; [EOL]         assertTrue("isNumber(String) 6 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 6 failed", checkCreateNumber(val)); [EOL]         val = "123.4E5"; [EOL]         assertTrue("isNumber(String) 7 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 7 failed", checkCreateNumber(val)); [EOL]         val = "-1234"; [EOL]         assertTrue("isNumber(String) 8 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 8 failed", checkCreateNumber(val)); [EOL]         val = "-1234.5"; [EOL]         assertTrue("isNumber(String) 9 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 9 failed", checkCreateNumber(val)); [EOL]         val = "-.12345"; [EOL]         assertTrue("isNumber(String) 10 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 10 failed", checkCreateNumber(val)); [EOL]         val = "-1234E5"; [EOL]         assertTrue("isNumber(String) 11 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 11 failed", checkCreateNumber(val)); [EOL]         val = "0"; [EOL]         assertTrue("isNumber(String) 12 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 12 failed", checkCreateNumber(val)); [EOL]         val = "-0"; [EOL]         assertTrue("isNumber(String) 13 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 13 failed", checkCreateNumber(val)); [EOL]         val = "01234"; [EOL]         assertTrue("isNumber(String) 14 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 14 failed", checkCreateNumber(val)); [EOL]         val = "-01234"; [EOL]         assertTrue("isNumber(String) 15 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 15 failed", checkCreateNumber(val)); [EOL]         val = "0xABC123"; [EOL]         assertTrue("isNumber(String) 16 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 16 failed", checkCreateNumber(val)); [EOL]         val = "0x0"; [EOL]         assertTrue("isNumber(String) 17 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 17 failed", checkCreateNumber(val)); [EOL]         val = "123.4E21D"; [EOL]         assertTrue("isNumber(String) 19 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 19 failed", checkCreateNumber(val)); [EOL]         val = "-221.23F"; [EOL]         assertTrue("isNumber(String) 20 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 20 failed", checkCreateNumber(val)); [EOL]         val = "22338L"; [EOL]         assertTrue("isNumber(String) 21 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 21 failed", checkCreateNumber(val)); [EOL]         val = null; [EOL]         assertTrue("isNumber(String) 1 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 1 Neg failed", !checkCreateNumber(val)); [EOL]         val = ""; [EOL]         assertTrue("isNumber(String) 2 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 2 Neg failed", !checkCreateNumber(val)); [EOL]         val = "--2.3"; [EOL]         assertTrue("isNumber(String) 3 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 3 Neg failed", !checkCreateNumber(val)); [EOL]         val = ".12.3"; [EOL]         assertTrue("isNumber(String) 4 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 4 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-123E"; [EOL]         assertTrue("isNumber(String) 5 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 5 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-123E+-212"; [EOL]         assertTrue("isNumber(String) 6 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 6 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-123E2.12"; [EOL]         assertTrue("isNumber(String) 7 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 7 Neg failed", !checkCreateNumber(val)); [EOL]         val = "0xGF"; [EOL]         assertTrue("isNumber(String) 8 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 8 Neg failed", !checkCreateNumber(val)); [EOL]         val = "0xFAE-1"; [EOL]         assertTrue("isNumber(String) 9 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 9 Neg failed", !checkCreateNumber(val)); [EOL]         val = "."; [EOL]         assertTrue("isNumber(String) 10 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 10 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-0ABC123"; [EOL]         assertTrue("isNumber(String) 11 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 11 Neg failed", !checkCreateNumber(val)); [EOL]         val = "123.4E-D"; [EOL]         assertTrue("isNumber(String) 12 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 12 Neg failed", !checkCreateNumber(val)); [EOL]         val = "123.4ED"; [EOL]         assertTrue("isNumber(String) 13 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 13 Neg failed", !checkCreateNumber(val)); [EOL]         val = "1234E5l"; [EOL]         assertTrue("isNumber(String) 14 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 14 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11a"; [EOL]         assertTrue("isNumber(String) 15 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 15 Neg failed", !checkCreateNumber(val)); [EOL]         val = "1a"; [EOL]         assertTrue("isNumber(String) 16 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 16 Neg failed", !checkCreateNumber(val)); [EOL]         val = "a"; [EOL]         assertTrue("isNumber(String) 17 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 17 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11g"; [EOL]         assertTrue("isNumber(String) 18 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 18 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11z"; [EOL]         assertTrue("isNumber(String) 19 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 19 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11def"; [EOL]         assertTrue("isNumber(String) 20 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 20 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11d11"; [EOL]         assertTrue("isNumber(String) 21 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 21 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11 11"; [EOL]         assertTrue("isNumber(String) 22 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 22 Neg failed", !checkCreateNumber(val)); [EOL]         val = " 1111"; [EOL]         assertTrue("isNumber(String) 23 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 23 Neg failed", !checkCreateNumber(val)); [EOL]         val = "1111 "; [EOL]         assertTrue("isNumber(String) 24 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 24 Neg failed", !checkCreateNumber(val)); [EOL]  [EOL]         // LANG-521 [EOL]         val = "2."; [EOL]         assertTrue("isNumber(String) LANG-521 failed", NumberUtils.isNumber(val)); [EOL]  [EOL]         // LANG-664 [EOL]         val = "1.1L"; [EOL]         assertFalse("isNumber(String) LANG-664 failed", NumberUtils.isNumber(val)); [EOL]     } [EOL]  [EOL]     private boolean checkCreateNumber(final String val) { [EOL]         try { [EOL]             final Object obj = NumberUtils.createNumber(val); [EOL]             if (obj == null) { [EOL]                 return false; [EOL]             } [EOL]             return true; [EOL]         } catch (final NumberFormatException e) { [EOL]             return false; [EOL]        } [EOL]     } [EOL]  [EOL]     @SuppressWarnings("cast") // suppress instanceof warning check [EOL]
@Test [EOL]     public void testIsNumber() { [EOL]         String val = "12345"; [EOL]         assertTrue("isNumber(String) 1 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 1 failed", checkCreateNumber(val)); [EOL]         val = "1234.5"; [EOL]         assertTrue("isNumber(String) 2 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 2 failed", checkCreateNumber(val)); [EOL]         val = ".12345"; [EOL]         assertTrue("isNumber(String) 3 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 3 failed", checkCreateNumber(val)); [EOL]         val = "1234E5"; [EOL]         assertTrue("isNumber(String) 4 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 4 failed", checkCreateNumber(val)); [EOL]         val = "1234E+5"; [EOL]         assertTrue("isNumber(String) 5 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 5 failed", checkCreateNumber(val)); [EOL]         val = "1234E-5"; [EOL]         assertTrue("isNumber(String) 6 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 6 failed", checkCreateNumber(val)); [EOL]         val = "123.4E5"; [EOL]         assertTrue("isNumber(String) 7 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 7 failed", checkCreateNumber(val)); [EOL]         val = "-1234"; [EOL]         assertTrue("isNumber(String) 8 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 8 failed", checkCreateNumber(val)); [EOL]         val = "-1234.5"; [EOL]         assertTrue("isNumber(String) 9 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 9 failed", checkCreateNumber(val)); [EOL]         val = "-.12345"; [EOL]         assertTrue("isNumber(String) 10 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 10 failed", checkCreateNumber(val)); [EOL]         val = "-1234E5"; [EOL]         assertTrue("isNumber(String) 11 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 11 failed", checkCreateNumber(val)); [EOL]         val = "0"; [EOL]         assertTrue("isNumber(String) 12 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 12 failed", checkCreateNumber(val)); [EOL]         val = "-0"; [EOL]         assertTrue("isNumber(String) 13 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 13 failed", checkCreateNumber(val)); [EOL]         val = "01234"; [EOL]         assertTrue("isNumber(String) 14 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 14 failed", checkCreateNumber(val)); [EOL]         val = "-01234"; [EOL]         assertTrue("isNumber(String) 15 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 15 failed", checkCreateNumber(val)); [EOL]         val = "0xABC123"; [EOL]         assertTrue("isNumber(String) 16 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 16 failed", checkCreateNumber(val)); [EOL]         val = "0x0"; [EOL]         assertTrue("isNumber(String) 17 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 17 failed", checkCreateNumber(val)); [EOL]         val = "123.4E21D"; [EOL]         assertTrue("isNumber(String) 19 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 19 failed", checkCreateNumber(val)); [EOL]         val = "-221.23F"; [EOL]         assertTrue("isNumber(String) 20 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 20 failed", checkCreateNumber(val)); [EOL]         val = "22338L"; [EOL]         assertTrue("isNumber(String) 21 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 21 failed", checkCreateNumber(val)); [EOL]         val = null; [EOL]         assertTrue("isNumber(String) 1 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 1 Neg failed", !checkCreateNumber(val)); [EOL]         val = ""; [EOL]         assertTrue("isNumber(String) 2 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 2 Neg failed", !checkCreateNumber(val)); [EOL]         val = "--2.3"; [EOL]         assertTrue("isNumber(String) 3 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 3 Neg failed", !checkCreateNumber(val)); [EOL]         val = ".12.3"; [EOL]         assertTrue("isNumber(String) 4 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 4 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-123E"; [EOL]         assertTrue("isNumber(String) 5 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 5 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-123E+-212"; [EOL]         assertTrue("isNumber(String) 6 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 6 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-123E2.12"; [EOL]         assertTrue("isNumber(String) 7 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 7 Neg failed", !checkCreateNumber(val)); [EOL]         val = "0xGF"; [EOL]         assertTrue("isNumber(String) 8 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 8 Neg failed", !checkCreateNumber(val)); [EOL]         val = "0xFAE-1"; [EOL]         assertTrue("isNumber(String) 9 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 9 Neg failed", !checkCreateNumber(val)); [EOL]         val = "."; [EOL]         assertTrue("isNumber(String) 10 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 10 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-0ABC123"; [EOL]         assertTrue("isNumber(String) 11 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 11 Neg failed", !checkCreateNumber(val)); [EOL]         val = "123.4E-D"; [EOL]         assertTrue("isNumber(String) 12 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 12 Neg failed", !checkCreateNumber(val)); [EOL]         val = "123.4ED"; [EOL]         assertTrue("isNumber(String) 13 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 13 Neg failed", !checkCreateNumber(val)); [EOL]         val = "1234E5l"; [EOL]         assertTrue("isNumber(String) 14 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 14 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11a"; [EOL]         assertTrue("isNumber(String) 15 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 15 Neg failed", !checkCreateNumber(val)); [EOL]         val = "1a"; [EOL]         assertTrue("isNumber(String) 16 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 16 Neg failed", !checkCreateNumber(val)); [EOL]         val = "a"; [EOL]         assertTrue("isNumber(String) 17 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 17 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11g"; [EOL]         assertTrue("isNumber(String) 18 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 18 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11z"; [EOL]         assertTrue("isNumber(String) 19 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 19 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11def"; [EOL]         assertTrue("isNumber(String) 20 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 20 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11d11"; [EOL]         assertTrue("isNumber(String) 21 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 21 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11 11"; [EOL]         assertTrue("isNumber(String) 22 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 22 Neg failed", !checkCreateNumber(val)); [EOL]         val = " 1111"; [EOL]         assertTrue("isNumber(String) 23 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 23 Neg failed", !checkCreateNumber(val)); [EOL]         val = "1111 "; [EOL]         assertTrue("isNumber(String) 24 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 24 Neg failed", !checkCreateNumber(val)); [EOL]  [EOL]         // LANG-521 [EOL]         val = "2."; [EOL]         assertTrue("isNumber(String) LANG-521 failed", NumberUtils.isNumber(val)); [EOL]  [EOL]         // LANG-664 [EOL]         val = "1.1L"; [EOL]         assertFalse("isNumber(String) LANG-664 failed", NumberUtils.isNumber(val)); [EOL]     } [EOL]  [EOL]     private boolean checkCreateNumber(final String val) { [EOL]         try { [EOL]             final Object obj = NumberUtils.createNumber(val); [EOL]             if (obj == null) { [EOL]                 return false; [EOL]             } [EOL]             return true; [EOL]         } catch (final NumberFormatException e) { [EOL]             return false; [EOL]        } [EOL]     } [EOL]  [EOL]     @SuppressWarnings("cast") // suppress instanceof warning check [EOL]
@Test [EOL]     public void testIsNumber() { [EOL]         String val = "12345"; [EOL]         assertTrue("isNumber(String) 1 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 1 failed", checkCreateNumber(val)); [EOL]         val = "1234.5"; [EOL]         assertTrue("isNumber(String) 2 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 2 failed", checkCreateNumber(val)); [EOL]         val = ".12345"; [EOL]         assertTrue("isNumber(String) 3 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 3 failed", checkCreateNumber(val)); [EOL]         val = "1234E5"; [EOL]         assertTrue("isNumber(String) 4 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 4 failed", checkCreateNumber(val)); [EOL]         val = "1234E+5"; [EOL]         assertTrue("isNumber(String) 5 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 5 failed", checkCreateNumber(val)); [EOL]         val = "1234E-5"; [EOL]         assertTrue("isNumber(String) 6 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 6 failed", checkCreateNumber(val)); [EOL]         val = "123.4E5"; [EOL]         assertTrue("isNumber(String) 7 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 7 failed", checkCreateNumber(val)); [EOL]         val = "-1234"; [EOL]         assertTrue("isNumber(String) 8 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 8 failed", checkCreateNumber(val)); [EOL]         val = "-1234.5"; [EOL]         assertTrue("isNumber(String) 9 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 9 failed", checkCreateNumber(val)); [EOL]         val = "-.12345"; [EOL]         assertTrue("isNumber(String) 10 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 10 failed", checkCreateNumber(val)); [EOL]         val = "-1234E5"; [EOL]         assertTrue("isNumber(String) 11 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 11 failed", checkCreateNumber(val)); [EOL]         val = "0"; [EOL]         assertTrue("isNumber(String) 12 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 12 failed", checkCreateNumber(val)); [EOL]         val = "-0"; [EOL]         assertTrue("isNumber(String) 13 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 13 failed", checkCreateNumber(val)); [EOL]         val = "01234"; [EOL]         assertTrue("isNumber(String) 14 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 14 failed", checkCreateNumber(val)); [EOL]         val = "-01234"; [EOL]         assertTrue("isNumber(String) 15 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 15 failed", checkCreateNumber(val)); [EOL]         val = "0xABC123"; [EOL]         assertTrue("isNumber(String) 16 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 16 failed", checkCreateNumber(val)); [EOL]         val = "0x0"; [EOL]         assertTrue("isNumber(String) 17 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 17 failed", checkCreateNumber(val)); [EOL]         val = "123.4E21D"; [EOL]         assertTrue("isNumber(String) 19 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 19 failed", checkCreateNumber(val)); [EOL]         val = "-221.23F"; [EOL]         assertTrue("isNumber(String) 20 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 20 failed", checkCreateNumber(val)); [EOL]         val = "22338L"; [EOL]         assertTrue("isNumber(String) 21 failed", NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 21 failed", checkCreateNumber(val)); [EOL]         val = null; [EOL]         assertTrue("isNumber(String) 1 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 1 Neg failed", !checkCreateNumber(val)); [EOL]         val = ""; [EOL]         assertTrue("isNumber(String) 2 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 2 Neg failed", !checkCreateNumber(val)); [EOL]         val = "--2.3"; [EOL]         assertTrue("isNumber(String) 3 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 3 Neg failed", !checkCreateNumber(val)); [EOL]         val = ".12.3"; [EOL]         assertTrue("isNumber(String) 4 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 4 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-123E"; [EOL]         assertTrue("isNumber(String) 5 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 5 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-123E+-212"; [EOL]         assertTrue("isNumber(String) 6 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 6 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-123E2.12"; [EOL]         assertTrue("isNumber(String) 7 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 7 Neg failed", !checkCreateNumber(val)); [EOL]         val = "0xGF"; [EOL]         assertTrue("isNumber(String) 8 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 8 Neg failed", !checkCreateNumber(val)); [EOL]         val = "0xFAE-1"; [EOL]         assertTrue("isNumber(String) 9 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 9 Neg failed", !checkCreateNumber(val)); [EOL]         val = "."; [EOL]         assertTrue("isNumber(String) 10 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 10 Neg failed", !checkCreateNumber(val)); [EOL]         val = "-0ABC123"; [EOL]         assertTrue("isNumber(String) 11 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 11 Neg failed", !checkCreateNumber(val)); [EOL]         val = "123.4E-D"; [EOL]         assertTrue("isNumber(String) 12 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 12 Neg failed", !checkCreateNumber(val)); [EOL]         val = "123.4ED"; [EOL]         assertTrue("isNumber(String) 13 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 13 Neg failed", !checkCreateNumber(val)); [EOL]         val = "1234E5l"; [EOL]         assertTrue("isNumber(String) 14 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 14 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11a"; [EOL]         assertTrue("isNumber(String) 15 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 15 Neg failed", !checkCreateNumber(val)); [EOL]         val = "1a"; [EOL]         assertTrue("isNumber(String) 16 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 16 Neg failed", !checkCreateNumber(val)); [EOL]         val = "a"; [EOL]         assertTrue("isNumber(String) 17 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 17 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11g"; [EOL]         assertTrue("isNumber(String) 18 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 18 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11z"; [EOL]         assertTrue("isNumber(String) 19 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 19 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11def"; [EOL]         assertTrue("isNumber(String) 20 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 20 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11d11"; [EOL]         assertTrue("isNumber(String) 21 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 21 Neg failed", !checkCreateNumber(val)); [EOL]         val = "11 11"; [EOL]         assertTrue("isNumber(String) 22 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 22 Neg failed", !checkCreateNumber(val)); [EOL]         val = " 1111"; [EOL]         assertTrue("isNumber(String) 23 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 23 Neg failed", !checkCreateNumber(val)); [EOL]         val = "1111 "; [EOL]         assertTrue("isNumber(String) 24 Neg failed", !NumberUtils.isNumber(val)); [EOL]         assertTrue("isNumber(String)/createNumber(String) 24 Neg failed", !checkCreateNumber(val)); [EOL]  [EOL]         // LANG-521 [EOL]         val = "2."; [EOL]         assertTrue("isNumber(String) LANG-521 failed", NumberUtils.isNumber(val)); [EOL]  [EOL]         // LANG-664 [EOL]         val = "1.1L"; [EOL]         assertFalse("isNumber(String) LANG-664 failed", NumberUtils.isNumber(val)); [EOL]     } [EOL]  [EOL]     private boolean checkCreateNumber(final String val) { [EOL]         try { [EOL]             final Object obj = NumberUtils.createNumber(val); [EOL]             if (obj == null) { [EOL]                 return false; [EOL]             } [EOL]             return true; [EOL]         } catch (final NumberFormatException e) { [EOL]             return false; [EOL]        } [EOL]     } [EOL]  [EOL]     @SuppressWarnings("cast") // suppress instanceof warning check [EOL]
@Test [EOL]     public void testStripToNull_String() { [EOL]         assertEquals(null, StringUtils.stripToNull(null)); [EOL]         assertEquals(null, StringUtils.stripToNull("")); [EOL]         assertEquals(null, StringUtils.stripToNull("        ")); [EOL]         assertEquals(null, StringUtils.stripToNull(StringUtilsTest.WHITESPACE)); [EOL]         assertEquals("ab c", StringUtils.stripToNull("  ab c  ")); [EOL]         assertEquals(StringUtilsTest.NON_WHITESPACE,  [EOL]             StringUtils.stripToNull(StringUtilsTest.WHITESPACE + StringUtilsTest.NON_WHITESPACE + StringUtilsTest.WHITESPACE)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testStripAccents() { [EOL]         final String cue = "\u00C7\u00FA\u00EA"; [EOL]         assertEquals( "Failed to strip accents from " + cue, "Cue", StringUtils.stripAccents(cue)); [EOL]  [EOL]         final String lots = "\u00C0\u00C1\u00C2\u00C3\u00C4\u00C5\u00C7\u00C8\u00C9" +  [EOL]                       "\u00CA\u00CB\u00CC\u00CD\u00CE\u00CF\u00D1\u00D2\u00D3" +  [EOL]                       "\u00D4\u00D5\u00D6\u00D9\u00DA\u00DB\u00DC\u00DD"; [EOL]         assertEquals( "Failed to strip accents from " + lots,  [EOL]                       "AAAAAACEEEEIIIINOOOOOUUUUY",  [EOL]                       StringUtils.stripAccents(lots)); [EOL]  [EOL]         assertNull( "Failed null safety", StringUtils.stripAccents(null) ); [EOL]         assertEquals( "Failed empty String", "", StringUtils.stripAccents("") ); [EOL]         assertEquals( "Failed to handle non-accented text", "control", StringUtils.stripAccents("control") ); [EOL]         assertEquals( "Failed to handle easy example", "eclair", StringUtils.stripAccents("\u00E9clair") ); [EOL]     } [EOL] } [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final CharSequence fooCs = FOO, barCs = BAR, foobarCs = FOOBAR; [EOL]         assertTrue(StringUtils.equals(null, null)); [EOL]         assertTrue(StringUtils.equals(fooCs, fooCs)); [EOL]         assertTrue(StringUtils.equals(fooCs, new StringBuilder(FOO))); [EOL]         assertTrue(StringUtils.equals(fooCs, new String(new char[] { 'f', 'o', 'o' }))); [EOL]         assertTrue(StringUtils.equals(fooCs, new CustomCharSequence(FOO))); [EOL]         assertTrue(StringUtils.equals(new CustomCharSequence(FOO), fooCs)); [EOL]         assertFalse(StringUtils.equals(fooCs, new String(new char[] { 'f', 'O', 'O' }))); [EOL]         assertFalse(StringUtils.equals(fooCs, barCs)); [EOL]         assertFalse(StringUtils.equals(fooCs, null)); [EOL]         assertFalse(StringUtils.equals(null, fooCs)); [EOL]         assertFalse(StringUtils.equals(fooCs, foobarCs)); [EOL]         assertFalse(StringUtils.equals(foobarCs, fooCs)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEqualsIgnoreCase() { [EOL]         assertTrue(StringUtils.equalsIgnoreCase(null, null)); [EOL]         assertTrue(StringUtils.equalsIgnoreCase(FOO, FOO)); [EOL]         assertTrue(StringUtils.equalsIgnoreCase(FOO, new String(new char[] { 'f', 'o', 'o' }))); [EOL]         assertTrue(StringUtils.equalsIgnoreCase(FOO, new String(new char[] { 'f', 'O', 'O' }))); [EOL]         assertFalse(StringUtils.equalsIgnoreCase(FOO, BAR)); [EOL]         assertFalse(StringUtils.equalsIgnoreCase(FOO, null)); [EOL]         assertFalse(StringUtils.equalsIgnoreCase(null, FOO)); [EOL]         assertTrue(StringUtils.equalsIgnoreCase("","")); [EOL]         assertFalse(StringUtils.equalsIgnoreCase("abcd","abcd ")); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testIndexOf_String() { [EOL]         assertEquals(-1, StringUtils.indexOf(null, null)); [EOL]         assertEquals(-1, StringUtils.indexOf("", null)); [EOL]         assertEquals(0, StringUtils.indexOf("", "")); [EOL]         assertEquals(0, StringUtils.indexOf("aabaabaa", "a")); [EOL]         assertEquals(2, StringUtils.indexOf("aabaabaa", "b")); [EOL]         assertEquals(1, StringUtils.indexOf("aabaabaa", "ab")); [EOL]         assertEquals(0, StringUtils.indexOf("aabaabaa", "")); [EOL]  [EOL]         assertEquals(2, StringUtils.indexOf(new StringBuilder("aabaabaa"), "b")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testOrdinalIndexOf() { [EOL]         assertEquals(-1, StringUtils.ordinalIndexOf(null, null, Integer.MIN_VALUE)); [EOL]         assertEquals(-1, StringUtils.ordinalIndexOf("", null, Integer.MIN_VALUE)); [EOL]         assertEquals(-1, StringUtils.ordinalIndexOf("", "", Integer.MIN_VALUE)); [EOL]         assertEquals(-1, StringUtils.ordinalIndexOf("aabaabaa", "a", Integer.MIN_VALUE)); [EOL]         assertEquals(-1, StringUtils.ordinalIndexOf("aabaabaa", "b", Integer.MIN_VALUE)); [EOL]         assertEquals(-1, StringUtils.ordinalIndexOf("aabaabaa", "ab", Integer.MIN_VALUE)); [EOL]         assertEquals(-1, StringUtils.ordinalIndexOf("aabaabaa", "", Integer.MIN_VALUE)); [EOL]  [EOL]         assertEquals(-1, StringUtils.ordinalIndexOf(null, null, -1)); [EOL]         assertEquals(-1, StringUtils.ordinalIndexOf("", null, -1)); [EOL]         assertEquals(-1, StringUtils.ordinalIndexOf("", "", -1)); [EOL]         assertEquals(-1, StringUtils.ordinalIndexOf("aabaabaa", "a", -1)); [EOL]         assertEquals(-1, StringUtils.ordinalIndexOf("aabaabaa", "b", -1)); [EOL]         assertEquals(-1, StringUtils.ordinalIndexOf("aabaabaa", "ab", -1)); [EOL]         assertEquals(-1, StringUtils.ordinalIndexOf("aabaabaa", "", -1)); [EOL]  [EOL]         assertEquals(-1, StringUtils.ordinalIndexOf(null, null, 0)); [EOL]         assertEquals(-1, StringUtils.ordinalIndexOf("", null, 0)); [EOL]         assertEquals(-1, StringUtils.ordinalIndexOf("", "", 0)); [EOL]         assertEquals(-1, StringUtils.ordinalIndexOf("aabaabaa", "a", 0)); [EOL]         assertEquals(-1, StringUtils.ordinalIndexOf("aabaabaa", "b", 0)); [EOL]         assertEquals(-1, StringUtils.ordinalIndexOf("aabaabaa", "ab", 0)); [EOL]         assertEquals(-1, StringUtils.ordinalIndexOf("aabaabaa", "", 0)); [EOL]  [EOL]         assertEquals(-1, StringUtils.ordinalIndexOf(null, null, 1)); [EOL]         assertEquals(-1, StringUtils.ordinalIndexOf("", null, 1)); [EOL]         assertEquals(0, StringUtils.ordinalIndexOf("", "", 1)); [EOL]         assertEquals(0, StringUtils.ordinalIndexOf("aabaabaa", "a", 1)); [EOL]         assertEquals(2, StringUtils.ordinalIndexOf("aabaabaa", "b", 1)); [EOL]         assertEquals(1, StringUtils.ordinalIndexOf("aabaabaa", "ab", 1)); [EOL]         assertEquals(0, StringUtils.ordinalIndexOf("aabaabaa", "", 1)); [EOL]  [EOL]         assertEquals(-1, StringUtils.ordinalIndexOf(null, null, 2)); [EOL]         assertEquals(-1, StringUtils.ordinalIndexOf("", null, 2)); [EOL]         assertEquals(0, StringUtils.ordinalIndexOf("", "", 2)); [EOL]         assertEquals(1, StringUtils.ordinalIndexOf("aabaabaa", "a", 2)); [EOL]         assertEquals(5, StringUtils.ordinalIndexOf("aabaabaa", "b", 2)); [EOL]         assertEquals(4, StringUtils.ordinalIndexOf("aabaabaa", "ab", 2)); [EOL]         assertEquals(0, StringUtils.ordinalIndexOf("aabaabaa", "", 2)); [EOL]  [EOL]         assertEquals(-1, StringUtils.ordinalIndexOf(null, null, Integer.MAX_VALUE)); [EOL]         assertEquals(-1, StringUtils.ordinalIndexOf("", null, Integer.MAX_VALUE)); [EOL]         assertEquals(0, StringUtils.ordinalIndexOf("", "", Integer.MAX_VALUE)); [EOL]         assertEquals(-1, StringUtils.ordinalIndexOf("aabaabaa", "a", Integer.MAX_VALUE)); [EOL]         assertEquals(-1, StringUtils.ordinalIndexOf("aabaabaa", "b", Integer.MAX_VALUE)); [EOL]         assertEquals(-1, StringUtils.ordinalIndexOf("aabaabaa", "ab", Integer.MAX_VALUE)); [EOL]         assertEquals(0, StringUtils.ordinalIndexOf("aabaabaa", "", Integer.MAX_VALUE)); [EOL]  [EOL]         assertEquals(-1, StringUtils.ordinalIndexOf("aaaaaaaaa", "a", 0)); [EOL]         assertEquals(0, StringUtils.ordinalIndexOf("aaaaaaaaa", "a", 1)); [EOL]         assertEquals(1, StringUtils.ordinalIndexOf("aaaaaaaaa", "a", 2)); [EOL]         assertEquals(2, StringUtils.ordinalIndexOf("aaaaaaaaa", "a", 3)); [EOL]         assertEquals(3, StringUtils.ordinalIndexOf("aaaaaaaaa", "a", 4)); [EOL]         assertEquals(4, StringUtils.ordinalIndexOf("aaaaaaaaa", "a", 5)); [EOL]         assertEquals(5, StringUtils.ordinalIndexOf("aaaaaaaaa", "a", 6)); [EOL]         assertEquals(6, StringUtils.ordinalIndexOf("aaaaaaaaa", "a", 7)); [EOL]         assertEquals(7, StringUtils.ordinalIndexOf("aaaaaaaaa", "a", 8)); [EOL]         assertEquals(8, StringUtils.ordinalIndexOf("aaaaaaaaa", "a", 9)); [EOL]         assertEquals(-1, StringUtils.ordinalIndexOf("aaaaaaaaa", "a", 10)); [EOL]     } [EOL]  [EOL] } [EOL]
@Test [EOL]     public void testIndexOfIgnoreCase_StringInt() { [EOL]         assertEquals(1, StringUtils.indexOfIgnoreCase("aabaabaa", "AB", -1)); [EOL]         assertEquals(1, StringUtils.indexOfIgnoreCase("aabaabaa", "AB", 0)); [EOL]         assertEquals(1, StringUtils.indexOfIgnoreCase("aabaabaa", "AB", 1)); [EOL]         assertEquals(4, StringUtils.indexOfIgnoreCase("aabaabaa", "AB", 2)); [EOL]         assertEquals(4, StringUtils.indexOfIgnoreCase("aabaabaa", "AB", 3)); [EOL]         assertEquals(4, StringUtils.indexOfIgnoreCase("aabaabaa", "AB", 4)); [EOL]         assertEquals(-1, StringUtils.indexOfIgnoreCase("aabaabaa", "AB", 5)); [EOL]         assertEquals(-1, StringUtils.indexOfIgnoreCase("aabaabaa", "AB", 6)); [EOL]         assertEquals(-1, StringUtils.indexOfIgnoreCase("aabaabaa", "AB", 7)); [EOL]         assertEquals(-1, StringUtils.indexOfIgnoreCase("aabaabaa", "AB", 8)); [EOL]         assertEquals(1, StringUtils.indexOfIgnoreCase("aab", "AB", 1)); [EOL]         assertEquals(5, StringUtils.indexOfIgnoreCase("aabaabaa", "", 5)); [EOL]         assertEquals(-1, StringUtils.indexOfIgnoreCase("ab", "AAB", 0)); [EOL]         assertEquals(-1, StringUtils.indexOfIgnoreCase("aab", "AAB", 1)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLastIndexOf_StringInt() { [EOL]         assertEquals(-1, StringUtils.lastIndexOf(null, null, 0)); [EOL]         assertEquals(-1, StringUtils.lastIndexOf(null, null, -1)); [EOL]         assertEquals(-1, StringUtils.lastIndexOf(null, "", 0)); [EOL]         assertEquals(-1, StringUtils.lastIndexOf(null, "", -1)); [EOL]         assertEquals(-1, StringUtils.lastIndexOf("", null, 0)); [EOL]         assertEquals(-1, StringUtils.lastIndexOf("", null, -1)); [EOL]         assertEquals(0, StringUtils.lastIndexOf("", "", 0)); [EOL]         assertEquals(-1, StringUtils.lastIndexOf("", "", -1)); [EOL]         assertEquals(0, StringUtils.lastIndexOf("", "", 9)); [EOL]         assertEquals(0, StringUtils.lastIndexOf("abc", "", 0)); [EOL]         assertEquals(-1, StringUtils.lastIndexOf("abc", "", -1)); [EOL]         assertEquals(3, StringUtils.lastIndexOf("abc", "", 9)); [EOL]         assertEquals(7, StringUtils.lastIndexOf("aabaabaa", "a", 8)); [EOL]         assertEquals(5, StringUtils.lastIndexOf("aabaabaa", "b", 8)); [EOL]         assertEquals(4, StringUtils.lastIndexOf("aabaabaa", "ab", 8)); [EOL]         assertEquals(2, StringUtils.lastIndexOf("aabaabaa", "b", 3)); [EOL]         assertEquals(5, StringUtils.lastIndexOf("aabaabaa", "b", 9)); [EOL]         assertEquals(-1, StringUtils.lastIndexOf("aabaabaa", "b", -1)); [EOL]         assertEquals(-1, StringUtils.lastIndexOf("aabaabaa", "b", 0)); [EOL]         assertEquals(0, StringUtils.lastIndexOf("aabaabaa", "a", 0)); [EOL]         assertEquals(-1, StringUtils.lastIndexOf("aabaabaa", "a", -1)); [EOL]  [EOL]         // Test that fromIndex works correctly, i.e. cannot match after fromIndex [EOL]         assertEquals(7, StringUtils.lastIndexOf("12345678", "8", 9)); [EOL]         assertEquals(7, StringUtils.lastIndexOf("12345678", "8", 8)); [EOL]         assertEquals(7, StringUtils.lastIndexOf("12345678", "8", 7)); // 7 is last index [EOL]         assertEquals(-1, StringUtils.lastIndexOf("12345678", "8", 6)); [EOL]  [EOL]         assertEquals(-1, StringUtils.lastIndexOf("aabaabaa", "b", 1)); [EOL]         assertEquals(2, StringUtils.lastIndexOf("aabaabaa", "b", 2)); [EOL]         assertEquals(2, StringUtils.lastIndexOf("aabaabaa", "ba", 2)); [EOL]         assertEquals(2, StringUtils.lastIndexOf("aabaabaa", "ba", 3)); [EOL]  [EOL]         assertEquals(2, StringUtils.lastIndexOf(new StringBuilder("aabaabaa"), "b", 3)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLastIndexOfIgnoreCase_StringInt() { [EOL]         assertEquals(-1, StringUtils.lastIndexOfIgnoreCase(null, null, 0)); [EOL]         assertEquals(-1, StringUtils.lastIndexOfIgnoreCase(null, null, -1)); [EOL]         assertEquals(-1, StringUtils.lastIndexOfIgnoreCase(null, "", 0)); [EOL]         assertEquals(-1, StringUtils.lastIndexOfIgnoreCase(null, "", -1)); [EOL]         assertEquals(-1, StringUtils.lastIndexOfIgnoreCase("", null, 0)); [EOL]         assertEquals(-1, StringUtils.lastIndexOfIgnoreCase("", null, -1)); [EOL]         assertEquals(0, StringUtils.lastIndexOfIgnoreCase("", "", 0)); [EOL]         assertEquals(-1, StringUtils.lastIndexOfIgnoreCase("", "", -1)); [EOL]         assertEquals(0, StringUtils.lastIndexOfIgnoreCase("", "", 9)); [EOL]         assertEquals(0, StringUtils.lastIndexOfIgnoreCase("abc", "", 0)); [EOL]         assertEquals(-1, StringUtils.lastIndexOfIgnoreCase("abc", "", -1)); [EOL]         assertEquals(3, StringUtils.lastIndexOfIgnoreCase("abc", "", 9)); [EOL]         assertEquals(7, StringUtils.lastIndexOfIgnoreCase("aabaabaa", "A", 8)); [EOL]         assertEquals(5, StringUtils.lastIndexOfIgnoreCase("aabaabaa", "B", 8)); [EOL]         assertEquals(4, StringUtils.lastIndexOfIgnoreCase("aabaabaa", "AB", 8)); [EOL]         assertEquals(2, StringUtils.lastIndexOfIgnoreCase("aabaabaa", "B", 3)); [EOL]         assertEquals(5, StringUtils.lastIndexOfIgnoreCase("aabaabaa", "B", 9)); [EOL]         assertEquals(-1, StringUtils.lastIndexOfIgnoreCase("aabaabaa", "B", -1)); [EOL]         assertEquals(-1, StringUtils.lastIndexOfIgnoreCase("aabaabaa", "B", 0)); [EOL]         assertEquals(0, StringUtils.lastIndexOfIgnoreCase("aabaabaa", "A", 0)); [EOL]         assertEquals(1, StringUtils.lastIndexOfIgnoreCase("aab", "AB", 1)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIndexOfAny_StringStringWithSupplementaryChars() { [EOL]         assertEquals(0, StringUtils.indexOfAny(CharU20000 + CharU20001, CharU20000)); [EOL]         assertEquals(2, StringUtils.indexOfAny(CharU20000 + CharU20001, CharU20001)); [EOL]         assertEquals(0, StringUtils.indexOfAny(CharU20000, CharU20000)); [EOL]         assertEquals(-1, StringUtils.indexOfAny(CharU20000, CharU20001)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIndexOfAny_StringStringWithSupplementaryChars() { [EOL]         assertEquals(0, StringUtils.indexOfAny(CharU20000 + CharU20001, CharU20000)); [EOL]         assertEquals(2, StringUtils.indexOfAny(CharU20000 + CharU20001, CharU20001)); [EOL]         assertEquals(0, StringUtils.indexOfAny(CharU20000, CharU20000)); [EOL]         assertEquals(-1, StringUtils.indexOfAny(CharU20000, CharU20001)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testContainsAny_StringCharArrayWithSupplementaryChars() { [EOL]         assertTrue(StringUtils.containsAny(CharU20000 + CharU20001, CharU20000.toCharArray())); [EOL]         assertTrue(StringUtils.containsAny("a" + CharU20000 + CharU20001, "a".toCharArray())); [EOL]         assertTrue(StringUtils.containsAny(CharU20000 + "a" + CharU20001, "a".toCharArray())); [EOL]         assertTrue(StringUtils.containsAny(CharU20000 + CharU20001 + "a", "a".toCharArray())); [EOL]         assertTrue(StringUtils.containsAny(CharU20000 + CharU20001, CharU20001.toCharArray())); [EOL]         assertTrue(StringUtils.containsAny(CharU20000, CharU20000.toCharArray())); [EOL]         // Sanity check: [EOL]         assertEquals(-1, CharU20000.indexOf(CharU20001)); [EOL]         assertEquals(0, CharU20000.indexOf(CharU20001.charAt(0))); [EOL]         assertEquals(-1, CharU20000.indexOf(CharU20001.charAt(1))); [EOL]         // Test: [EOL]         assertFalse(StringUtils.containsAny(CharU20000, CharU20001.toCharArray())); [EOL]         assertFalse(StringUtils.containsAny(CharU20001, CharU20000.toCharArray())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testContainsAny_StringCharArrayWithBadSupplementaryChars() { [EOL]         // Test edge case: 1/2 of a (broken) supplementary char [EOL]         assertFalse(StringUtils.containsAny(CharUSuppCharHigh, CharU20001.toCharArray())); [EOL]         assertFalse(StringUtils.containsAny("abc" + CharUSuppCharHigh + "xyz", CharU20001.toCharArray())); [EOL]         assertEquals(-1, CharUSuppCharLow.indexOf(CharU20001)); [EOL]         assertFalse(StringUtils.containsAny(CharUSuppCharLow, CharU20001.toCharArray())); [EOL]         assertFalse(StringUtils.containsAny(CharU20001, CharUSuppCharHigh.toCharArray())); [EOL]         assertEquals(0, CharU20001.indexOf(CharUSuppCharLow)); [EOL]         assertTrue(StringUtils.containsAny(CharU20001, CharUSuppCharLow.toCharArray())); [EOL]     } [EOL]  [EOL]     /** [EOL]      * See http://www.oracle.com/technetwork/articles/javase/supplementary-142654.html [EOL]      */ [EOL]
@Test [EOL]     public void testContainsAny_StringCharArrayWithSupplementaryChars() { [EOL]         assertTrue(StringUtils.containsAny(CharU20000 + CharU20001, CharU20000.toCharArray())); [EOL]         assertTrue(StringUtils.containsAny("a" + CharU20000 + CharU20001, "a".toCharArray())); [EOL]         assertTrue(StringUtils.containsAny(CharU20000 + "a" + CharU20001, "a".toCharArray())); [EOL]         assertTrue(StringUtils.containsAny(CharU20000 + CharU20001 + "a", "a".toCharArray())); [EOL]         assertTrue(StringUtils.containsAny(CharU20000 + CharU20001, CharU20001.toCharArray())); [EOL]         assertTrue(StringUtils.containsAny(CharU20000, CharU20000.toCharArray())); [EOL]         // Sanity check: [EOL]         assertEquals(-1, CharU20000.indexOf(CharU20001)); [EOL]         assertEquals(0, CharU20000.indexOf(CharU20001.charAt(0))); [EOL]         assertEquals(-1, CharU20000.indexOf(CharU20001.charAt(1))); [EOL]         // Test: [EOL]         assertFalse(StringUtils.containsAny(CharU20000, CharU20001.toCharArray())); [EOL]         assertFalse(StringUtils.containsAny(CharU20001, CharU20000.toCharArray())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testContainsAny_StringCharArrayWithSupplementaryChars() { [EOL]         assertTrue(StringUtils.containsAny(CharU20000 + CharU20001, CharU20000.toCharArray())); [EOL]         assertTrue(StringUtils.containsAny("a" + CharU20000 + CharU20001, "a".toCharArray())); [EOL]         assertTrue(StringUtils.containsAny(CharU20000 + "a" + CharU20001, "a".toCharArray())); [EOL]         assertTrue(StringUtils.containsAny(CharU20000 + CharU20001 + "a", "a".toCharArray())); [EOL]         assertTrue(StringUtils.containsAny(CharU20000 + CharU20001, CharU20001.toCharArray())); [EOL]         assertTrue(StringUtils.containsAny(CharU20000, CharU20000.toCharArray())); [EOL]         // Sanity check: [EOL]         assertEquals(-1, CharU20000.indexOf(CharU20001)); [EOL]         assertEquals(0, CharU20000.indexOf(CharU20001.charAt(0))); [EOL]         assertEquals(-1, CharU20000.indexOf(CharU20001.charAt(1))); [EOL]         // Test: [EOL]         assertFalse(StringUtils.containsAny(CharU20000, CharU20001.toCharArray())); [EOL]         assertFalse(StringUtils.containsAny(CharU20001, CharU20000.toCharArray())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testRepeat_StringInt() { [EOL]         assertEquals(null, StringUtils.repeat(null, 2)); [EOL]         assertEquals("", StringUtils.repeat("ab", 0)); [EOL]         assertEquals("", StringUtils.repeat("", 3)); [EOL]         assertEquals("aaa", StringUtils.repeat("a", 3)); [EOL]         assertEquals("ababab", StringUtils.repeat("ab", 3)); [EOL]         assertEquals("abcabcabc", StringUtils.repeat("abc", 3)); [EOL]         final String str = StringUtils.repeat("a", 10000);  // bigger than pad limit [EOL]         assertEquals(10000, str.length()); [EOL]         assertTrue(StringUtils.containsOnly(str, new char[] {'a'})); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIndexOfAnyBut_StringCharArrayWithSupplementaryChars() { [EOL]         assertEquals(2, StringUtils.indexOfAnyBut(CharU20000 + CharU20001, CharU20000.toCharArray())); [EOL]         assertEquals(0, StringUtils.indexOfAnyBut(CharU20000 + CharU20001, CharU20001.toCharArray())); [EOL]         assertEquals(-1, StringUtils.indexOfAnyBut(CharU20000, CharU20000.toCharArray())); [EOL]         assertEquals(0, StringUtils.indexOfAnyBut(CharU20000, CharU20001.toCharArray())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIndexOfAnyBut_StringCharArrayWithSupplementaryChars() { [EOL]         assertEquals(2, StringUtils.indexOfAnyBut(CharU20000 + CharU20001, CharU20000.toCharArray())); [EOL]         assertEquals(0, StringUtils.indexOfAnyBut(CharU20000 + CharU20001, CharU20001.toCharArray())); [EOL]         assertEquals(-1, StringUtils.indexOfAnyBut(CharU20000, CharU20000.toCharArray())); [EOL]         assertEquals(0, StringUtils.indexOfAnyBut(CharU20000, CharU20001.toCharArray())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testRepeat_StringInt() { [EOL]         assertEquals(null, StringUtils.repeat(null, 2)); [EOL]         assertEquals("", StringUtils.repeat("ab", 0)); [EOL]         assertEquals("", StringUtils.repeat("", 3)); [EOL]         assertEquals("aaa", StringUtils.repeat("a", 3)); [EOL]         assertEquals("ababab", StringUtils.repeat("ab", 3)); [EOL]         assertEquals("abcabcabc", StringUtils.repeat("abc", 3)); [EOL]         final String str = StringUtils.repeat("a", 10000);  // bigger than pad limit [EOL]         assertEquals(10000, str.length()); [EOL]         assertTrue(StringUtils.containsOnly(str, new char[] {'a'})); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testRepeat_StringInt() { [EOL]         assertEquals(null, StringUtils.repeat(null, 2)); [EOL]         assertEquals("", StringUtils.repeat("ab", 0)); [EOL]         assertEquals("", StringUtils.repeat("", 3)); [EOL]         assertEquals("aaa", StringUtils.repeat("a", 3)); [EOL]         assertEquals("ababab", StringUtils.repeat("ab", 3)); [EOL]         assertEquals("abcabcabc", StringUtils.repeat("abc", 3)); [EOL]         final String str = StringUtils.repeat("a", 10000);  // bigger than pad limit [EOL]         assertEquals(10000, str.length()); [EOL]         assertTrue(StringUtils.containsOnly(str, new char[] {'a'})); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIndexOfAnyBut_StringStringWithSupplementaryChars() { [EOL]         assertEquals(2, StringUtils.indexOfAnyBut(CharU20000 + CharU20001, CharU20000)); [EOL]         assertEquals(0, StringUtils.indexOfAnyBut(CharU20000 + CharU20001, CharU20001)); [EOL]         assertEquals(-1, StringUtils.indexOfAnyBut(CharU20000, CharU20000)); [EOL]         assertEquals(0, StringUtils.indexOfAnyBut(CharU20000, CharU20001)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIndexOfAnyBut_StringStringWithSupplementaryChars() { [EOL]         assertEquals(2, StringUtils.indexOfAnyBut(CharU20000 + CharU20001, CharU20000)); [EOL]         assertEquals(0, StringUtils.indexOfAnyBut(CharU20000 + CharU20001, CharU20001)); [EOL]         assertEquals(-1, StringUtils.indexOfAnyBut(CharU20000, CharU20000)); [EOL]         assertEquals(0, StringUtils.indexOfAnyBut(CharU20000, CharU20001)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIndexOfAnyBut_StringStringWithSupplementaryChars() { [EOL]         assertEquals(2, StringUtils.indexOfAnyBut(CharU20000 + CharU20001, CharU20000)); [EOL]         assertEquals(0, StringUtils.indexOfAnyBut(CharU20000 + CharU20001, CharU20001)); [EOL]         assertEquals(-1, StringUtils.indexOfAnyBut(CharU20000, CharU20000)); [EOL]         assertEquals(0, StringUtils.indexOfAnyBut(CharU20000, CharU20001)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIndexOfAnyBut_StringString() { [EOL]         assertEquals(-1, StringUtils.indexOfAnyBut(null, (String) null)); [EOL]         assertEquals(-1, StringUtils.indexOfAnyBut(null, "")); [EOL]         assertEquals(-1, StringUtils.indexOfAnyBut(null, "ab")); [EOL]  [EOL]         assertEquals(-1, StringUtils.indexOfAnyBut("", (String) null)); [EOL]         assertEquals(-1, StringUtils.indexOfAnyBut("", "")); [EOL]         assertEquals(-1, StringUtils.indexOfAnyBut("", "ab")); [EOL]  [EOL]         assertEquals(-1, StringUtils.indexOfAnyBut("zzabyycdxx", (String) null)); [EOL]         assertEquals(-1, StringUtils.indexOfAnyBut("zzabyycdxx", "")); [EOL]         assertEquals(3, StringUtils.indexOfAnyBut("zzabyycdxx", "za")); [EOL]         assertEquals(0, StringUtils.indexOfAnyBut("zzabyycdxx", "by")); [EOL]         assertEquals(0, StringUtils.indexOfAnyBut("ab", "z")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testContainsOnly_CharArray() { [EOL]         final String str1 = "a"; [EOL]         final String str2 = "b"; [EOL]         final String str3 = "ab"; [EOL]         final char[] chars1= {'b'}; [EOL]         final char[] chars2= {'a'}; [EOL]         final char[] chars3= {'a', 'b'}; [EOL]         final char[] emptyChars = new char[0]; [EOL]         assertFalse(StringUtils.containsOnly(null, (char[]) null)); [EOL]         assertFalse(StringUtils.containsOnly("", (char[]) null)); [EOL]         assertFalse(StringUtils.containsOnly(null, emptyChars)); [EOL]         assertFalse(StringUtils.containsOnly(str1, emptyChars)); [EOL]         assertTrue(StringUtils.containsOnly("", emptyChars)); [EOL]         assertTrue(StringUtils.containsOnly("", chars1)); [EOL]         assertFalse(StringUtils.containsOnly(str1, chars1)); [EOL]         assertTrue(StringUtils.containsOnly(str1, chars2)); [EOL]         assertTrue(StringUtils.containsOnly(str1, chars3)); [EOL]         assertTrue(StringUtils.containsOnly(str2, chars1)); [EOL]         assertFalse(StringUtils.containsOnly(str2, chars2)); [EOL]         assertTrue(StringUtils.containsOnly(str2, chars3)); [EOL]         assertFalse(StringUtils.containsOnly(str3, chars1)); [EOL]         assertFalse(StringUtils.containsOnly(str3, chars2)); [EOL]         assertTrue(StringUtils.containsOnly(str3, chars3)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testContainsOnly_CharArray() { [EOL]         final String str1 = "a"; [EOL]         final String str2 = "b"; [EOL]         final String str3 = "ab"; [EOL]         final char[] chars1= {'b'}; [EOL]         final char[] chars2= {'a'}; [EOL]         final char[] chars3= {'a', 'b'}; [EOL]         final char[] emptyChars = new char[0]; [EOL]         assertFalse(StringUtils.containsOnly(null, (char[]) null)); [EOL]         assertFalse(StringUtils.containsOnly("", (char[]) null)); [EOL]         assertFalse(StringUtils.containsOnly(null, emptyChars)); [EOL]         assertFalse(StringUtils.containsOnly(str1, emptyChars)); [EOL]         assertTrue(StringUtils.containsOnly("", emptyChars)); [EOL]         assertTrue(StringUtils.containsOnly("", chars1)); [EOL]         assertFalse(StringUtils.containsOnly(str1, chars1)); [EOL]         assertTrue(StringUtils.containsOnly(str1, chars2)); [EOL]         assertTrue(StringUtils.containsOnly(str1, chars3)); [EOL]         assertTrue(StringUtils.containsOnly(str2, chars1)); [EOL]         assertFalse(StringUtils.containsOnly(str2, chars2)); [EOL]         assertTrue(StringUtils.containsOnly(str2, chars3)); [EOL]         assertFalse(StringUtils.containsOnly(str3, chars1)); [EOL]         assertFalse(StringUtils.containsOnly(str3, chars2)); [EOL]         assertTrue(StringUtils.containsOnly(str3, chars3)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testContainsOnly_String() { [EOL]         final String str1 = "a"; [EOL]         final String str2 = "b"; [EOL]         final String str3 = "ab"; [EOL]         final String chars1= "b"; [EOL]         final String chars2= "a"; [EOL]         final String chars3= "ab"; [EOL]         assertFalse(StringUtils.containsOnly(null, (String) null)); [EOL]         assertFalse(StringUtils.containsOnly("", (String) null)); [EOL]         assertFalse(StringUtils.containsOnly(null, "")); [EOL]         assertFalse(StringUtils.containsOnly(str1, "")); [EOL]         assertTrue(StringUtils.containsOnly("", "")); [EOL]         assertTrue(StringUtils.containsOnly("", chars1)); [EOL]         assertFalse(StringUtils.containsOnly(str1, chars1)); [EOL]         assertTrue(StringUtils.containsOnly(str1, chars2)); [EOL]         assertTrue(StringUtils.containsOnly(str1, chars3)); [EOL]         assertTrue(StringUtils.containsOnly(str2, chars1)); [EOL]         assertFalse(StringUtils.containsOnly(str2, chars2)); [EOL]         assertTrue(StringUtils.containsOnly(str2, chars3)); [EOL]         assertFalse(StringUtils.containsOnly(str3, chars1)); [EOL]         assertFalse(StringUtils.containsOnly(str3, chars2)); [EOL]         assertTrue(StringUtils.containsOnly(str3, chars3)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testContainsNone_StringWithSupplementaryChars() { [EOL]         assertFalse(StringUtils.containsNone(CharU20000 + CharU20001, CharU20000)); [EOL]         assertFalse(StringUtils.containsNone(CharU20000 + CharU20001, CharU20001)); [EOL]         assertFalse(StringUtils.containsNone(CharU20000, CharU20000)); [EOL]         // Sanity check: [EOL]         assertEquals(-1, CharU20000.indexOf(CharU20001)); [EOL]         assertEquals(0, CharU20000.indexOf(CharU20001.charAt(0))); [EOL]         assertEquals(-1, CharU20000.indexOf(CharU20001.charAt(1))); [EOL]         // Test: [EOL]         assertTrue(StringUtils.containsNone(CharU20000, CharU20001)); [EOL]         assertTrue(StringUtils.containsNone(CharU20001, CharU20000)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testContainsNone_CharArrayWithBadSupplementaryChars() { [EOL]         // Test edge case: 1/2 of a (broken) supplementary char [EOL]         assertTrue(StringUtils.containsNone(CharUSuppCharHigh, CharU20001.toCharArray())); [EOL]         assertEquals(-1, CharUSuppCharLow.indexOf(CharU20001)); [EOL]         assertTrue(StringUtils.containsNone(CharUSuppCharLow, CharU20001.toCharArray())); [EOL]         assertEquals(-1, CharU20001.indexOf(CharUSuppCharHigh)); [EOL]         assertTrue(StringUtils.containsNone(CharU20001, CharUSuppCharHigh.toCharArray())); [EOL]         assertEquals(0, CharU20001.indexOf(CharUSuppCharLow)); [EOL]         assertFalse(StringUtils.containsNone(CharU20001, CharUSuppCharLow.toCharArray())); [EOL]     } [EOL]  [EOL]     /** [EOL]      * See http://www.oracle.com/technetwork/articles/javase/supplementary-142654.html [EOL]      */ [EOL]
@Test [EOL]     public void testContainsNone_StringWithSupplementaryChars() { [EOL]         assertFalse(StringUtils.containsNone(CharU20000 + CharU20001, CharU20000)); [EOL]         assertFalse(StringUtils.containsNone(CharU20000 + CharU20001, CharU20001)); [EOL]         assertFalse(StringUtils.containsNone(CharU20000, CharU20000)); [EOL]         // Sanity check: [EOL]         assertEquals(-1, CharU20000.indexOf(CharU20001)); [EOL]         assertEquals(0, CharU20000.indexOf(CharU20001.charAt(0))); [EOL]         assertEquals(-1, CharU20000.indexOf(CharU20001.charAt(1))); [EOL]         // Test: [EOL]         assertTrue(StringUtils.containsNone(CharU20000, CharU20001)); [EOL]         assertTrue(StringUtils.containsNone(CharU20001, CharU20000)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testContainsNone_StringWithSupplementaryChars() { [EOL]         assertFalse(StringUtils.containsNone(CharU20000 + CharU20001, CharU20000)); [EOL]         assertFalse(StringUtils.containsNone(CharU20000 + CharU20001, CharU20001)); [EOL]         assertFalse(StringUtils.containsNone(CharU20000, CharU20000)); [EOL]         // Sanity check: [EOL]         assertEquals(-1, CharU20000.indexOf(CharU20001)); [EOL]         assertEquals(0, CharU20000.indexOf(CharU20001.charAt(0))); [EOL]         assertEquals(-1, CharU20000.indexOf(CharU20001.charAt(1))); [EOL]         // Test: [EOL]         assertTrue(StringUtils.containsNone(CharU20000, CharU20001)); [EOL]         assertTrue(StringUtils.containsNone(CharU20001, CharU20000)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMid_String() { [EOL]         assertSame(null, StringUtils.mid(null, -1, 0)); [EOL]         assertSame(null, StringUtils.mid(null, 0, -1)); [EOL]         assertSame(null, StringUtils.mid(null, 3, 0)); [EOL]         assertSame(null, StringUtils.mid(null, 3, 2)); [EOL]          [EOL]         assertEquals("", StringUtils.mid("", 0, -1)); [EOL]         assertEquals("", StringUtils.mid("", 0, 0)); [EOL]         assertEquals("", StringUtils.mid("", 0, 2)); [EOL]          [EOL]         assertEquals("", StringUtils.mid(FOOBAR, 3, -1)); [EOL]         assertEquals("", StringUtils.mid(FOOBAR, 3, 0)); [EOL]         assertEquals("b", StringUtils.mid(FOOBAR, 3, 1)); [EOL]         assertEquals(FOO, StringUtils.mid(FOOBAR, 0, 3)); [EOL]         assertEquals(BAR, StringUtils.mid(FOOBAR, 3, 3)); [EOL]         assertEquals(FOOBAR, StringUtils.mid(FOOBAR, 0, 80)); [EOL]         assertEquals(BAR, StringUtils.mid(FOOBAR, 3, 80)); [EOL]         assertEquals("", StringUtils.mid(FOOBAR, 9, 3)); [EOL]         assertEquals(FOO, StringUtils.mid(FOOBAR, -1, 3)); [EOL]     } [EOL]      [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testMid_String() { [EOL]         assertSame(null, StringUtils.mid(null, -1, 0)); [EOL]         assertSame(null, StringUtils.mid(null, 0, -1)); [EOL]         assertSame(null, StringUtils.mid(null, 3, 0)); [EOL]         assertSame(null, StringUtils.mid(null, 3, 2)); [EOL]          [EOL]         assertEquals("", StringUtils.mid("", 0, -1)); [EOL]         assertEquals("", StringUtils.mid("", 0, 0)); [EOL]         assertEquals("", StringUtils.mid("", 0, 2)); [EOL]          [EOL]         assertEquals("", StringUtils.mid(FOOBAR, 3, -1)); [EOL]         assertEquals("", StringUtils.mid(FOOBAR, 3, 0)); [EOL]         assertEquals("b", StringUtils.mid(FOOBAR, 3, 1)); [EOL]         assertEquals(FOO, StringUtils.mid(FOOBAR, 0, 3)); [EOL]         assertEquals(BAR, StringUtils.mid(FOOBAR, 3, 3)); [EOL]         assertEquals(FOOBAR, StringUtils.mid(FOOBAR, 0, 80)); [EOL]         assertEquals(BAR, StringUtils.mid(FOOBAR, 3, 80)); [EOL]         assertEquals("", StringUtils.mid(FOOBAR, 9, 3)); [EOL]         assertEquals(FOO, StringUtils.mid(FOOBAR, -1, 3)); [EOL]     } [EOL]      [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testMid_String() { [EOL]         assertSame(null, StringUtils.mid(null, -1, 0)); [EOL]         assertSame(null, StringUtils.mid(null, 0, -1)); [EOL]         assertSame(null, StringUtils.mid(null, 3, 0)); [EOL]         assertSame(null, StringUtils.mid(null, 3, 2)); [EOL]          [EOL]         assertEquals("", StringUtils.mid("", 0, -1)); [EOL]         assertEquals("", StringUtils.mid("", 0, 0)); [EOL]         assertEquals("", StringUtils.mid("", 0, 2)); [EOL]          [EOL]         assertEquals("", StringUtils.mid(FOOBAR, 3, -1)); [EOL]         assertEquals("", StringUtils.mid(FOOBAR, 3, 0)); [EOL]         assertEquals("b", StringUtils.mid(FOOBAR, 3, 1)); [EOL]         assertEquals(FOO, StringUtils.mid(FOOBAR, 0, 3)); [EOL]         assertEquals(BAR, StringUtils.mid(FOOBAR, 3, 3)); [EOL]         assertEquals(FOOBAR, StringUtils.mid(FOOBAR, 0, 80)); [EOL]         assertEquals(BAR, StringUtils.mid(FOOBAR, 3, 80)); [EOL]         assertEquals("", StringUtils.mid(FOOBAR, 9, 3)); [EOL]         assertEquals(FOO, StringUtils.mid(FOOBAR, -1, 3)); [EOL]     } [EOL]      [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testSubstringAfter_StringString() { [EOL]         assertEquals("barXXbaz", StringUtils.substringAfter("fooXXbarXXbaz", "XX")); [EOL]          [EOL]         assertEquals(null, StringUtils.substringAfter(null, null)); [EOL]         assertEquals(null, StringUtils.substringAfter(null, "")); [EOL]         assertEquals(null, StringUtils.substringAfter(null, "XX")); [EOL]         assertEquals("", StringUtils.substringAfter("", null)); [EOL]         assertEquals("", StringUtils.substringAfter("", "")); [EOL]         assertEquals("", StringUtils.substringAfter("", "XX")); [EOL]          [EOL]         assertEquals("", StringUtils.substringAfter("foo", null)); [EOL]         assertEquals("ot", StringUtils.substringAfter("foot", "o")); [EOL]         assertEquals("bc", StringUtils.substringAfter("abc", "a")); [EOL]         assertEquals("cba", StringUtils.substringAfter("abcba", "b")); [EOL]         assertEquals("", StringUtils.substringAfter("abc", "c")); [EOL]         assertEquals("abc", StringUtils.substringAfter("abc", "")); [EOL]         assertEquals("", StringUtils.substringAfter("abc", "d")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSubstringAfterLast_StringString() { [EOL]         assertEquals("baz", StringUtils.substringAfterLast("fooXXbarXXbaz", "XX")); [EOL]  [EOL]         assertEquals(null, StringUtils.substringAfterLast(null, null)); [EOL]         assertEquals(null, StringUtils.substringAfterLast(null, "")); [EOL]         assertEquals(null, StringUtils.substringAfterLast(null, "XX")); [EOL]         assertEquals("", StringUtils.substringAfterLast("", null)); [EOL]         assertEquals("", StringUtils.substringAfterLast("", "")); [EOL]         assertEquals("", StringUtils.substringAfterLast("", "a")); [EOL]  [EOL]         assertEquals("", StringUtils.substringAfterLast("foo", null)); [EOL]         assertEquals("", StringUtils.substringAfterLast("foo", "b")); [EOL]         assertEquals("t", StringUtils.substringAfterLast("foot", "o")); [EOL]         assertEquals("bc", StringUtils.substringAfterLast("abc", "a")); [EOL]         assertEquals("a", StringUtils.substringAfterLast("abcba", "b")); [EOL]         assertEquals("", StringUtils.substringAfterLast("abc", "c")); [EOL]         assertEquals("", StringUtils.substringAfterLast("", "d")); [EOL]         assertEquals("", StringUtils.substringAfterLast("abc", "")); [EOL]     }         [EOL]          [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testSubstringAfterLast_StringString() { [EOL]         assertEquals("baz", StringUtils.substringAfterLast("fooXXbarXXbaz", "XX")); [EOL]  [EOL]         assertEquals(null, StringUtils.substringAfterLast(null, null)); [EOL]         assertEquals(null, StringUtils.substringAfterLast(null, "")); [EOL]         assertEquals(null, StringUtils.substringAfterLast(null, "XX")); [EOL]         assertEquals("", StringUtils.substringAfterLast("", null)); [EOL]         assertEquals("", StringUtils.substringAfterLast("", "")); [EOL]         assertEquals("", StringUtils.substringAfterLast("", "a")); [EOL]  [EOL]         assertEquals("", StringUtils.substringAfterLast("foo", null)); [EOL]         assertEquals("", StringUtils.substringAfterLast("foo", "b")); [EOL]         assertEquals("t", StringUtils.substringAfterLast("foot", "o")); [EOL]         assertEquals("bc", StringUtils.substringAfterLast("abc", "a")); [EOL]         assertEquals("a", StringUtils.substringAfterLast("abcba", "b")); [EOL]         assertEquals("", StringUtils.substringAfterLast("abc", "c")); [EOL]         assertEquals("", StringUtils.substringAfterLast("", "d")); [EOL]         assertEquals("", StringUtils.substringAfterLast("abc", "")); [EOL]     }         [EOL]          [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testSubstringsBetween_StringStringString() { [EOL]  [EOL]         String[] results = StringUtils.substringsBetween("[one], [two], [three]", "[", "]"); [EOL]         assertEquals(3, results.length); [EOL]         assertEquals("one", results[0]); [EOL]         assertEquals("two", results[1]); [EOL]         assertEquals("three", results[2]); [EOL]  [EOL]         results = StringUtils.substringsBetween("[one], [two], three", "[", "]"); [EOL]         assertEquals(2, results.length); [EOL]         assertEquals("one", results[0]); [EOL]         assertEquals("two", results[1]); [EOL]  [EOL]         results = StringUtils.substringsBetween("[one], [two], three]", "[", "]"); [EOL]         assertEquals(2, results.length); [EOL]         assertEquals("one", results[0]); [EOL]         assertEquals("two", results[1]); [EOL]  [EOL]         results = StringUtils.substringsBetween("[one], two], three]", "[", "]"); [EOL]         assertEquals(1, results.length); [EOL]         assertEquals("one", results[0]); [EOL]  [EOL]         results = StringUtils.substringsBetween("one], two], [three]", "[", "]"); [EOL]         assertEquals(1, results.length); [EOL]         assertEquals("three", results[0]); [EOL]  [EOL]         // 'ab hello ba' will match, but 'ab non ba' won't [EOL]         // this is because the 'a' is shared between the two and can't be matched twice [EOL]         results = StringUtils.substringsBetween("aabhellobabnonba", "ab", "ba"); [EOL]         assertEquals(1, results.length); [EOL]         assertEquals("hello", results[0]); [EOL]  [EOL]         results = StringUtils.substringsBetween("one, two, three", "[", "]"); [EOL]         assertNull(results); [EOL]  [EOL]         results = StringUtils.substringsBetween("[one, two, three", "[", "]"); [EOL]         assertNull(results); [EOL]  [EOL]         results = StringUtils.substringsBetween("one, two, three]", "[", "]"); [EOL]         assertNull(results); [EOL]  [EOL]         results = StringUtils.substringsBetween("[one], [two], [three]", "[", null); [EOL]         assertNull(results); [EOL]  [EOL]         results = StringUtils.substringsBetween("[one], [two], [three]", null, "]"); [EOL]         assertNull(results); [EOL]  [EOL]         results = StringUtils.substringsBetween("[one], [two], [three]", "", ""); [EOL]         assertNull(results); [EOL]  [EOL]         results = StringUtils.substringsBetween(null, "[", "]"); [EOL]         assertNull(results); [EOL]  [EOL]         results = StringUtils.substringsBetween("", "[", "]"); [EOL]         assertEquals(0, results.length); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testSubstringsBetween_StringStringString() { [EOL]  [EOL]         String[] results = StringUtils.substringsBetween("[one], [two], [three]", "[", "]"); [EOL]         assertEquals(3, results.length); [EOL]         assertEquals("one", results[0]); [EOL]         assertEquals("two", results[1]); [EOL]         assertEquals("three", results[2]); [EOL]  [EOL]         results = StringUtils.substringsBetween("[one], [two], three", "[", "]"); [EOL]         assertEquals(2, results.length); [EOL]         assertEquals("one", results[0]); [EOL]         assertEquals("two", results[1]); [EOL]  [EOL]         results = StringUtils.substringsBetween("[one], [two], three]", "[", "]"); [EOL]         assertEquals(2, results.length); [EOL]         assertEquals("one", results[0]); [EOL]         assertEquals("two", results[1]); [EOL]  [EOL]         results = StringUtils.substringsBetween("[one], two], three]", "[", "]"); [EOL]         assertEquals(1, results.length); [EOL]         assertEquals("one", results[0]); [EOL]  [EOL]         results = StringUtils.substringsBetween("one], two], [three]", "[", "]"); [EOL]         assertEquals(1, results.length); [EOL]         assertEquals("three", results[0]); [EOL]  [EOL]         // 'ab hello ba' will match, but 'ab non ba' won't [EOL]         // this is because the 'a' is shared between the two and can't be matched twice [EOL]         results = StringUtils.substringsBetween("aabhellobabnonba", "ab", "ba"); [EOL]         assertEquals(1, results.length); [EOL]         assertEquals("hello", results[0]); [EOL]  [EOL]         results = StringUtils.substringsBetween("one, two, three", "[", "]"); [EOL]         assertNull(results); [EOL]  [EOL]         results = StringUtils.substringsBetween("[one, two, three", "[", "]"); [EOL]         assertNull(results); [EOL]  [EOL]         results = StringUtils.substringsBetween("one, two, three]", "[", "]"); [EOL]         assertNull(results); [EOL]  [EOL]         results = StringUtils.substringsBetween("[one], [two], [three]", "[", null); [EOL]         assertNull(results); [EOL]  [EOL]         results = StringUtils.substringsBetween("[one], [two], [three]", null, "]"); [EOL]         assertNull(results); [EOL]  [EOL]         results = StringUtils.substringsBetween("[one], [two], [three]", "", ""); [EOL]         assertNull(results); [EOL]  [EOL]         results = StringUtils.substringsBetween(null, "[", "]"); [EOL]         assertNull(results); [EOL]  [EOL]         results = StringUtils.substringsBetween("", "[", "]"); [EOL]         assertEquals(0, results.length); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testSubstringsBetween_StringStringString() { [EOL]  [EOL]         String[] results = StringUtils.substringsBetween("[one], [two], [three]", "[", "]"); [EOL]         assertEquals(3, results.length); [EOL]         assertEquals("one", results[0]); [EOL]         assertEquals("two", results[1]); [EOL]         assertEquals("three", results[2]); [EOL]  [EOL]         results = StringUtils.substringsBetween("[one], [two], three", "[", "]"); [EOL]         assertEquals(2, results.length); [EOL]         assertEquals("one", results[0]); [EOL]         assertEquals("two", results[1]); [EOL]  [EOL]         results = StringUtils.substringsBetween("[one], [two], three]", "[", "]"); [EOL]         assertEquals(2, results.length); [EOL]         assertEquals("one", results[0]); [EOL]         assertEquals("two", results[1]); [EOL]  [EOL]         results = StringUtils.substringsBetween("[one], two], three]", "[", "]"); [EOL]         assertEquals(1, results.length); [EOL]         assertEquals("one", results[0]); [EOL]  [EOL]         results = StringUtils.substringsBetween("one], two], [three]", "[", "]"); [EOL]         assertEquals(1, results.length); [EOL]         assertEquals("three", results[0]); [EOL]  [EOL]         // 'ab hello ba' will match, but 'ab non ba' won't [EOL]         // this is because the 'a' is shared between the two and can't be matched twice [EOL]         results = StringUtils.substringsBetween("aabhellobabnonba", "ab", "ba"); [EOL]         assertEquals(1, results.length); [EOL]         assertEquals("hello", results[0]); [EOL]  [EOL]         results = StringUtils.substringsBetween("one, two, three", "[", "]"); [EOL]         assertNull(results); [EOL]  [EOL]         results = StringUtils.substringsBetween("[one, two, three", "[", "]"); [EOL]         assertNull(results); [EOL]  [EOL]         results = StringUtils.substringsBetween("one, two, three]", "[", "]"); [EOL]         assertNull(results); [EOL]  [EOL]         results = StringUtils.substringsBetween("[one], [two], [three]", "[", null); [EOL]         assertNull(results); [EOL]  [EOL]         results = StringUtils.substringsBetween("[one], [two], [three]", null, "]"); [EOL]         assertNull(results); [EOL]  [EOL]         results = StringUtils.substringsBetween("[one], [two], [three]", "", ""); [EOL]         assertNull(results); [EOL]  [EOL]         results = StringUtils.substringsBetween(null, "[", "]"); [EOL]         assertNull(results); [EOL]  [EOL]         results = StringUtils.substringsBetween("", "[", "]"); [EOL]         assertEquals(0, results.length); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testSubstringsBetween_StringStringString() { [EOL]  [EOL]         String[] results = StringUtils.substringsBetween("[one], [two], [three]", "[", "]"); [EOL]         assertEquals(3, results.length); [EOL]         assertEquals("one", results[0]); [EOL]         assertEquals("two", results[1]); [EOL]         assertEquals("three", results[2]); [EOL]  [EOL]         results = StringUtils.substringsBetween("[one], [two], three", "[", "]"); [EOL]         assertEquals(2, results.length); [EOL]         assertEquals("one", results[0]); [EOL]         assertEquals("two", results[1]); [EOL]  [EOL]         results = StringUtils.substringsBetween("[one], [two], three]", "[", "]"); [EOL]         assertEquals(2, results.length); [EOL]         assertEquals("one", results[0]); [EOL]         assertEquals("two", results[1]); [EOL]  [EOL]         results = StringUtils.substringsBetween("[one], two], three]", "[", "]"); [EOL]         assertEquals(1, results.length); [EOL]         assertEquals("one", results[0]); [EOL]  [EOL]         results = StringUtils.substringsBetween("one], two], [three]", "[", "]"); [EOL]         assertEquals(1, results.length); [EOL]         assertEquals("three", results[0]); [EOL]  [EOL]         // 'ab hello ba' will match, but 'ab non ba' won't [EOL]         // this is because the 'a' is shared between the two and can't be matched twice [EOL]         results = StringUtils.substringsBetween("aabhellobabnonba", "ab", "ba"); [EOL]         assertEquals(1, results.length); [EOL]         assertEquals("hello", results[0]); [EOL]  [EOL]         results = StringUtils.substringsBetween("one, two, three", "[", "]"); [EOL]         assertNull(results); [EOL]  [EOL]         results = StringUtils.substringsBetween("[one, two, three", "[", "]"); [EOL]         assertNull(results); [EOL]  [EOL]         results = StringUtils.substringsBetween("one, two, three]", "[", "]"); [EOL]         assertNull(results); [EOL]  [EOL]         results = StringUtils.substringsBetween("[one], [two], [three]", "[", null); [EOL]         assertNull(results); [EOL]  [EOL]         results = StringUtils.substringsBetween("[one], [two], [three]", null, "]"); [EOL]         assertNull(results); [EOL]  [EOL]         results = StringUtils.substringsBetween("[one], [two], [three]", "", ""); [EOL]         assertNull(results); [EOL]  [EOL]         results = StringUtils.substringsBetween(null, "[", "]"); [EOL]         assertNull(results); [EOL]  [EOL]         results = StringUtils.substringsBetween("", "[", "]"); [EOL]         assertEquals(0, results.length); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testSubstringsBetween_StringStringString() { [EOL]  [EOL]         String[] results = StringUtils.substringsBetween("[one], [two], [three]", "[", "]"); [EOL]         assertEquals(3, results.length); [EOL]         assertEquals("one", results[0]); [EOL]         assertEquals("two", results[1]); [EOL]         assertEquals("three", results[2]); [EOL]  [EOL]         results = StringUtils.substringsBetween("[one], [two], three", "[", "]"); [EOL]         assertEquals(2, results.length); [EOL]         assertEquals("one", results[0]); [EOL]         assertEquals("two", results[1]); [EOL]  [EOL]         results = StringUtils.substringsBetween("[one], [two], three]", "[", "]"); [EOL]         assertEquals(2, results.length); [EOL]         assertEquals("one", results[0]); [EOL]         assertEquals("two", results[1]); [EOL]  [EOL]         results = StringUtils.substringsBetween("[one], two], three]", "[", "]"); [EOL]         assertEquals(1, results.length); [EOL]         assertEquals("one", results[0]); [EOL]  [EOL]         results = StringUtils.substringsBetween("one], two], [three]", "[", "]"); [EOL]         assertEquals(1, results.length); [EOL]         assertEquals("three", results[0]); [EOL]  [EOL]         // 'ab hello ba' will match, but 'ab non ba' won't [EOL]         // this is because the 'a' is shared between the two and can't be matched twice [EOL]         results = StringUtils.substringsBetween("aabhellobabnonba", "ab", "ba"); [EOL]         assertEquals(1, results.length); [EOL]         assertEquals("hello", results[0]); [EOL]  [EOL]         results = StringUtils.substringsBetween("one, two, three", "[", "]"); [EOL]         assertNull(results); [EOL]  [EOL]         results = StringUtils.substringsBetween("[one, two, three", "[", "]"); [EOL]         assertNull(results); [EOL]  [EOL]         results = StringUtils.substringsBetween("one, two, three]", "[", "]"); [EOL]         assertNull(results); [EOL]  [EOL]         results = StringUtils.substringsBetween("[one], [two], [three]", "[", null); [EOL]         assertNull(results); [EOL]  [EOL]         results = StringUtils.substringsBetween("[one], [two], [three]", null, "]"); [EOL]         assertNull(results); [EOL]  [EOL]         results = StringUtils.substringsBetween("[one], [two], [three]", "", ""); [EOL]         assertNull(results); [EOL]  [EOL]         results = StringUtils.substringsBetween(null, "[", "]"); [EOL]         assertNull(results); [EOL]  [EOL]         results = StringUtils.substringsBetween("", "[", "]"); [EOL]         assertEquals(0, results.length); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testSubstringsBetween_StringStringString() { [EOL]  [EOL]         String[] results = StringUtils.substringsBetween("[one], [two], [three]", "[", "]"); [EOL]         assertEquals(3, results.length); [EOL]         assertEquals("one", results[0]); [EOL]         assertEquals("two", results[1]); [EOL]         assertEquals("three", results[2]); [EOL]  [EOL]         results = StringUtils.substringsBetween("[one], [two], three", "[", "]"); [EOL]         assertEquals(2, results.length); [EOL]         assertEquals("one", results[0]); [EOL]         assertEquals("two", results[1]); [EOL]  [EOL]         results = StringUtils.substringsBetween("[one], [two], three]", "[", "]"); [EOL]         assertEquals(2, results.length); [EOL]         assertEquals("one", results[0]); [EOL]         assertEquals("two", results[1]); [EOL]  [EOL]         results = StringUtils.substringsBetween("[one], two], three]", "[", "]"); [EOL]         assertEquals(1, results.length); [EOL]         assertEquals("one", results[0]); [EOL]  [EOL]         results = StringUtils.substringsBetween("one], two], [three]", "[", "]"); [EOL]         assertEquals(1, results.length); [EOL]         assertEquals("three", results[0]); [EOL]  [EOL]         // 'ab hello ba' will match, but 'ab non ba' won't [EOL]         // this is because the 'a' is shared between the two and can't be matched twice [EOL]         results = StringUtils.substringsBetween("aabhellobabnonba", "ab", "ba"); [EOL]         assertEquals(1, results.length); [EOL]         assertEquals("hello", results[0]); [EOL]  [EOL]         results = StringUtils.substringsBetween("one, two, three", "[", "]"); [EOL]         assertNull(results); [EOL]  [EOL]         results = StringUtils.substringsBetween("[one, two, three", "[", "]"); [EOL]         assertNull(results); [EOL]  [EOL]         results = StringUtils.substringsBetween("one, two, three]", "[", "]"); [EOL]         assertNull(results); [EOL]  [EOL]         results = StringUtils.substringsBetween("[one], [two], [three]", "[", null); [EOL]         assertNull(results); [EOL]  [EOL]         results = StringUtils.substringsBetween("[one], [two], [three]", null, "]"); [EOL]         assertNull(results); [EOL]  [EOL]         results = StringUtils.substringsBetween("[one], [two], [three]", "", ""); [EOL]         assertNull(results); [EOL]  [EOL]         results = StringUtils.substringsBetween(null, "[", "]"); [EOL]         assertNull(results); [EOL]  [EOL]         results = StringUtils.substringsBetween("", "[", "]"); [EOL]         assertEquals(0, results.length); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testSubstringsBetween_StringStringString() { [EOL]  [EOL]         String[] results = StringUtils.substringsBetween("[one], [two], [three]", "[", "]"); [EOL]         assertEquals(3, results.length); [EOL]         assertEquals("one", results[0]); [EOL]         assertEquals("two", results[1]); [EOL]         assertEquals("three", results[2]); [EOL]  [EOL]         results = StringUtils.substringsBetween("[one], [two], three", "[", "]"); [EOL]         assertEquals(2, results.length); [EOL]         assertEquals("one", results[0]); [EOL]         assertEquals("two", results[1]); [EOL]  [EOL]         results = StringUtils.substringsBetween("[one], [two], three]", "[", "]"); [EOL]         assertEquals(2, results.length); [EOL]         assertEquals("one", results[0]); [EOL]         assertEquals("two", results[1]); [EOL]  [EOL]         results = StringUtils.substringsBetween("[one], two], three]", "[", "]"); [EOL]         assertEquals(1, results.length); [EOL]         assertEquals("one", results[0]); [EOL]  [EOL]         results = StringUtils.substringsBetween("one], two], [three]", "[", "]"); [EOL]         assertEquals(1, results.length); [EOL]         assertEquals("three", results[0]); [EOL]  [EOL]         // 'ab hello ba' will match, but 'ab non ba' won't [EOL]         // this is because the 'a' is shared between the two and can't be matched twice [EOL]         results = StringUtils.substringsBetween("aabhellobabnonba", "ab", "ba"); [EOL]         assertEquals(1, results.length); [EOL]         assertEquals("hello", results[0]); [EOL]  [EOL]         results = StringUtils.substringsBetween("one, two, three", "[", "]"); [EOL]         assertNull(results); [EOL]  [EOL]         results = StringUtils.substringsBetween("[one, two, three", "[", "]"); [EOL]         assertNull(results); [EOL]  [EOL]         results = StringUtils.substringsBetween("one, two, three]", "[", "]"); [EOL]         assertNull(results); [EOL]  [EOL]         results = StringUtils.substringsBetween("[one], [two], [three]", "[", null); [EOL]         assertNull(results); [EOL]  [EOL]         results = StringUtils.substringsBetween("[one], [two], [three]", null, "]"); [EOL]         assertNull(results); [EOL]  [EOL]         results = StringUtils.substringsBetween("[one], [two], [three]", "", ""); [EOL]         assertNull(results); [EOL]  [EOL]         results = StringUtils.substringsBetween(null, "[", "]"); [EOL]         assertNull(results); [EOL]  [EOL]         results = StringUtils.substringsBetween("", "[", "]"); [EOL]         assertEquals(0, results.length); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testSubstringsBetween_StringStringString() { [EOL]  [EOL]         String[] results = StringUtils.substringsBetween("[one], [two], [three]", "[", "]"); [EOL]         assertEquals(3, results.length); [EOL]         assertEquals("one", results[0]); [EOL]         assertEquals("two", results[1]); [EOL]         assertEquals("three", results[2]); [EOL]  [EOL]         results = StringUtils.substringsBetween("[one], [two], three", "[", "]"); [EOL]         assertEquals(2, results.length); [EOL]         assertEquals("one", results[0]); [EOL]         assertEquals("two", results[1]); [EOL]  [EOL]         results = StringUtils.substringsBetween("[one], [two], three]", "[", "]"); [EOL]         assertEquals(2, results.length); [EOL]         assertEquals("one", results[0]); [EOL]         assertEquals("two", results[1]); [EOL]  [EOL]         results = StringUtils.substringsBetween("[one], two], three]", "[", "]"); [EOL]         assertEquals(1, results.length); [EOL]         assertEquals("one", results[0]); [EOL]  [EOL]         results = StringUtils.substringsBetween("one], two], [three]", "[", "]"); [EOL]         assertEquals(1, results.length); [EOL]         assertEquals("three", results[0]); [EOL]  [EOL]         // 'ab hello ba' will match, but 'ab non ba' won't [EOL]         // this is because the 'a' is shared between the two and can't be matched twice [EOL]         results = StringUtils.substringsBetween("aabhellobabnonba", "ab", "ba"); [EOL]         assertEquals(1, results.length); [EOL]         assertEquals("hello", results[0]); [EOL]  [EOL]         results = StringUtils.substringsBetween("one, two, three", "[", "]"); [EOL]         assertNull(results); [EOL]  [EOL]         results = StringUtils.substringsBetween("[one, two, three", "[", "]"); [EOL]         assertNull(results); [EOL]  [EOL]         results = StringUtils.substringsBetween("one, two, three]", "[", "]"); [EOL]         assertNull(results); [EOL]  [EOL]         results = StringUtils.substringsBetween("[one], [two], [three]", "[", null); [EOL]         assertNull(results); [EOL]  [EOL]         results = StringUtils.substringsBetween("[one], [two], [three]", null, "]"); [EOL]         assertNull(results); [EOL]  [EOL]         results = StringUtils.substringsBetween("[one], [two], [three]", "", ""); [EOL]         assertNull(results); [EOL]  [EOL]         results = StringUtils.substringsBetween(null, "[", "]"); [EOL]         assertNull(results); [EOL]  [EOL]         results = StringUtils.substringsBetween("", "[", "]"); [EOL]         assertEquals(0, results.length); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testSplitByWholeString_StringStringBoolean() { [EOL]         assertArrayEquals( null, StringUtils.splitByWholeSeparator( null, "." ) ) ; [EOL]  [EOL]         assertEquals( 0, StringUtils.splitByWholeSeparator( "", "." ).length ) ; [EOL]  [EOL]         final String stringToSplitOnNulls = "ab   de fg" ; [EOL]         final String[] splitOnNullExpectedResults = { "ab", "de", "fg" } ; [EOL]  [EOL]         final String[] splitOnNullResults = StringUtils.splitByWholeSeparator( stringToSplitOnNulls, null ) ; [EOL]         assertEquals( splitOnNullExpectedResults.length, splitOnNullResults.length ) ; [EOL]         for ( int i = 0 ; i < splitOnNullExpectedResults.length ; i+= 1 ) { [EOL]             assertEquals( splitOnNullExpectedResults[i], splitOnNullResults[i] ) ; [EOL]         } [EOL]  [EOL]         final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiously" ; [EOL]  [EOL]         final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" } ; [EOL]         final String[] splitOnStringResults = StringUtils.splitByWholeSeparator( stringToSplitOnCharactersAndString, "aeiouy" ) ; [EOL]         assertEquals( splitOnStringExpectedResults.length, splitOnStringResults.length ) ; [EOL]         for ( int i = 0 ; i < splitOnStringExpectedResults.length ; i+= 1 ) { [EOL]             assertEquals( splitOnStringExpectedResults[i], splitOnStringResults[i] ) ; [EOL]         } [EOL]  [EOL]         final String[] splitWithMultipleSeparatorExpectedResults = {"ab", "cd", "ef"}; [EOL]         final String[] splitWithMultipleSeparator = StringUtils.splitByWholeSeparator("ab:cd::ef", ":"); [EOL]         assertEquals( splitWithMultipleSeparatorExpectedResults.length, splitWithMultipleSeparator.length ); [EOL]         for( int i = 0; i < splitWithMultipleSeparatorExpectedResults.length ; i++ ) { [EOL]             assertEquals( splitWithMultipleSeparatorExpectedResults[i], splitWithMultipleSeparator[i] ) ; [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSplitByWholeString_StringStringBoolean() { [EOL]         assertArrayEquals( null, StringUtils.splitByWholeSeparator( null, "." ) ) ; [EOL]  [EOL]         assertEquals( 0, StringUtils.splitByWholeSeparator( "", "." ).length ) ; [EOL]  [EOL]         final String stringToSplitOnNulls = "ab   de fg" ; [EOL]         final String[] splitOnNullExpectedResults = { "ab", "de", "fg" } ; [EOL]  [EOL]         final String[] splitOnNullResults = StringUtils.splitByWholeSeparator( stringToSplitOnNulls, null ) ; [EOL]         assertEquals( splitOnNullExpectedResults.length, splitOnNullResults.length ) ; [EOL]         for ( int i = 0 ; i < splitOnNullExpectedResults.length ; i+= 1 ) { [EOL]             assertEquals( splitOnNullExpectedResults[i], splitOnNullResults[i] ) ; [EOL]         } [EOL]  [EOL]         final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiously" ; [EOL]  [EOL]         final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" } ; [EOL]         final String[] splitOnStringResults = StringUtils.splitByWholeSeparator( stringToSplitOnCharactersAndString, "aeiouy" ) ; [EOL]         assertEquals( splitOnStringExpectedResults.length, splitOnStringResults.length ) ; [EOL]         for ( int i = 0 ; i < splitOnStringExpectedResults.length ; i+= 1 ) { [EOL]             assertEquals( splitOnStringExpectedResults[i], splitOnStringResults[i] ) ; [EOL]         } [EOL]  [EOL]         final String[] splitWithMultipleSeparatorExpectedResults = {"ab", "cd", "ef"}; [EOL]         final String[] splitWithMultipleSeparator = StringUtils.splitByWholeSeparator("ab:cd::ef", ":"); [EOL]         assertEquals( splitWithMultipleSeparatorExpectedResults.length, splitWithMultipleSeparator.length ); [EOL]         for( int i = 0; i < splitWithMultipleSeparatorExpectedResults.length ; i++ ) { [EOL]             assertEquals( splitWithMultipleSeparatorExpectedResults[i], splitWithMultipleSeparator[i] ) ; [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSplitByWholeString_StringStringBooleanInt() { [EOL]         assertArrayEquals( null, StringUtils.splitByWholeSeparator( null, ".", 3 ) ) ; [EOL]  [EOL]         assertEquals( 0, StringUtils.splitByWholeSeparator( "", ".", 3 ).length ) ; [EOL]  [EOL]         final String stringToSplitOnNulls = "ab   de fg" ; [EOL]         final String[] splitOnNullExpectedResults = { "ab", "de fg" } ; [EOL]         //String[] splitOnNullExpectedResults = { "ab", "de" } ; [EOL]  [EOL]         final String[] splitOnNullResults = StringUtils.splitByWholeSeparator( stringToSplitOnNulls, null, 2 ) ; [EOL]         assertEquals( splitOnNullExpectedResults.length, splitOnNullResults.length ) ; [EOL]         for ( int i = 0 ; i < splitOnNullExpectedResults.length ; i+= 1 ) { [EOL]             assertEquals( splitOnNullExpectedResults[i], splitOnNullResults[i] ) ; [EOL]         } [EOL]  [EOL]         final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiouslyaeiouyabstemiously" ; [EOL]  [EOL]         final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiouslyaeiouyabstemiously" } ; [EOL]         //String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" } ; [EOL]         final String[] splitOnStringResults = StringUtils.splitByWholeSeparator( stringToSplitOnCharactersAndString, "aeiouy", 2 ) ; [EOL]         assertEquals( splitOnStringExpectedResults.length, splitOnStringResults.length ) ; [EOL]         for ( int i = 0 ; i < splitOnStringExpectedResults.length ; i++ ) { [EOL]             assertEquals( splitOnStringExpectedResults[i], splitOnStringResults[i] ) ; [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSplitByWholeString_StringStringBooleanInt() { [EOL]         assertArrayEquals( null, StringUtils.splitByWholeSeparator( null, ".", 3 ) ) ; [EOL]  [EOL]         assertEquals( 0, StringUtils.splitByWholeSeparator( "", ".", 3 ).length ) ; [EOL]  [EOL]         final String stringToSplitOnNulls = "ab   de fg" ; [EOL]         final String[] splitOnNullExpectedResults = { "ab", "de fg" } ; [EOL]         //String[] splitOnNullExpectedResults = { "ab", "de" } ; [EOL]  [EOL]         final String[] splitOnNullResults = StringUtils.splitByWholeSeparator( stringToSplitOnNulls, null, 2 ) ; [EOL]         assertEquals( splitOnNullExpectedResults.length, splitOnNullResults.length ) ; [EOL]         for ( int i = 0 ; i < splitOnNullExpectedResults.length ; i+= 1 ) { [EOL]             assertEquals( splitOnNullExpectedResults[i], splitOnNullResults[i] ) ; [EOL]         } [EOL]  [EOL]         final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiouslyaeiouyabstemiously" ; [EOL]  [EOL]         final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiouslyaeiouyabstemiously" } ; [EOL]         //String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" } ; [EOL]         final String[] splitOnStringResults = StringUtils.splitByWholeSeparator( stringToSplitOnCharactersAndString, "aeiouy", 2 ) ; [EOL]         assertEquals( splitOnStringExpectedResults.length, splitOnStringResults.length ) ; [EOL]         for ( int i = 0 ; i < splitOnStringExpectedResults.length ; i++ ) { [EOL]             assertEquals( splitOnStringExpectedResults[i], splitOnStringResults[i] ) ; [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSplitByWholeString_StringStringBoolean() { [EOL]         assertArrayEquals( null, StringUtils.splitByWholeSeparator( null, "." ) ) ; [EOL]  [EOL]         assertEquals( 0, StringUtils.splitByWholeSeparator( "", "." ).length ) ; [EOL]  [EOL]         final String stringToSplitOnNulls = "ab   de fg" ; [EOL]         final String[] splitOnNullExpectedResults = { "ab", "de", "fg" } ; [EOL]  [EOL]         final String[] splitOnNullResults = StringUtils.splitByWholeSeparator( stringToSplitOnNulls, null ) ; [EOL]         assertEquals( splitOnNullExpectedResults.length, splitOnNullResults.length ) ; [EOL]         for ( int i = 0 ; i < splitOnNullExpectedResults.length ; i+= 1 ) { [EOL]             assertEquals( splitOnNullExpectedResults[i], splitOnNullResults[i] ) ; [EOL]         } [EOL]  [EOL]         final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiously" ; [EOL]  [EOL]         final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" } ; [EOL]         final String[] splitOnStringResults = StringUtils.splitByWholeSeparator( stringToSplitOnCharactersAndString, "aeiouy" ) ; [EOL]         assertEquals( splitOnStringExpectedResults.length, splitOnStringResults.length ) ; [EOL]         for ( int i = 0 ; i < splitOnStringExpectedResults.length ; i+= 1 ) { [EOL]             assertEquals( splitOnStringExpectedResults[i], splitOnStringResults[i] ) ; [EOL]         } [EOL]  [EOL]         final String[] splitWithMultipleSeparatorExpectedResults = {"ab", "cd", "ef"}; [EOL]         final String[] splitWithMultipleSeparator = StringUtils.splitByWholeSeparator("ab:cd::ef", ":"); [EOL]         assertEquals( splitWithMultipleSeparatorExpectedResults.length, splitWithMultipleSeparator.length ); [EOL]         for( int i = 0; i < splitWithMultipleSeparatorExpectedResults.length ; i++ ) { [EOL]             assertEquals( splitWithMultipleSeparatorExpectedResults[i], splitWithMultipleSeparator[i] ) ; [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSplitByWholeString_StringStringBoolean() { [EOL]         assertArrayEquals( null, StringUtils.splitByWholeSeparator( null, "." ) ) ; [EOL]  [EOL]         assertEquals( 0, StringUtils.splitByWholeSeparator( "", "." ).length ) ; [EOL]  [EOL]         final String stringToSplitOnNulls = "ab   de fg" ; [EOL]         final String[] splitOnNullExpectedResults = { "ab", "de", "fg" } ; [EOL]  [EOL]         final String[] splitOnNullResults = StringUtils.splitByWholeSeparator( stringToSplitOnNulls, null ) ; [EOL]         assertEquals( splitOnNullExpectedResults.length, splitOnNullResults.length ) ; [EOL]         for ( int i = 0 ; i < splitOnNullExpectedResults.length ; i+= 1 ) { [EOL]             assertEquals( splitOnNullExpectedResults[i], splitOnNullResults[i] ) ; [EOL]         } [EOL]  [EOL]         final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiously" ; [EOL]  [EOL]         final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" } ; [EOL]         final String[] splitOnStringResults = StringUtils.splitByWholeSeparator( stringToSplitOnCharactersAndString, "aeiouy" ) ; [EOL]         assertEquals( splitOnStringExpectedResults.length, splitOnStringResults.length ) ; [EOL]         for ( int i = 0 ; i < splitOnStringExpectedResults.length ; i+= 1 ) { [EOL]             assertEquals( splitOnStringExpectedResults[i], splitOnStringResults[i] ) ; [EOL]         } [EOL]  [EOL]         final String[] splitWithMultipleSeparatorExpectedResults = {"ab", "cd", "ef"}; [EOL]         final String[] splitWithMultipleSeparator = StringUtils.splitByWholeSeparator("ab:cd::ef", ":"); [EOL]         assertEquals( splitWithMultipleSeparatorExpectedResults.length, splitWithMultipleSeparator.length ); [EOL]         for( int i = 0; i < splitWithMultipleSeparatorExpectedResults.length ; i++ ) { [EOL]             assertEquals( splitWithMultipleSeparatorExpectedResults[i], splitWithMultipleSeparator[i] ) ; [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSplitByWholeSeparatorPreserveAllTokens_StringStringInt() { [EOL]         assertArrayEquals( null, StringUtils.splitByWholeSeparatorPreserveAllTokens( null, ".", -1 ) ) ; [EOL]  [EOL]         assertEquals( 0, StringUtils.splitByWholeSeparatorPreserveAllTokens( "", ".", -1 ).length ) ; [EOL]  [EOL]         // test whitespace [EOL]         String input = "ab   de fg" ; [EOL]         String[] expected = new String[] { "ab", "", "", "de", "fg" } ; [EOL]  [EOL]         String[] actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, null, -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual.length ; i+= 1 ) { [EOL]             assertEquals( expected[i], actual[i] ); [EOL]         } [EOL]  [EOL]         // test delimiter singlechar [EOL]         input = "1::2:::3::::4"; [EOL]         expected = new String[] { "1", "", "2", "", "", "3", "", "", "", "4" }; [EOL]  [EOL]         actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, ":", -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual.length ; i+= 1 ) { [EOL]             assertEquals( expected[i], actual[i] ); [EOL]         } [EOL]  [EOL]         // test delimiter multichar [EOL]         input = "1::2:::3::::4"; [EOL]         expected = new String[] { "1", "2", ":3", "", "4" }; [EOL]  [EOL]         actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, "::", -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual.length ; i+= 1 ) { [EOL]             assertEquals( expected[i], actual[i] ); [EOL]         } [EOL]  [EOL]         // test delimiter char with max [EOL]         input = "1::2::3:4"; [EOL]         expected = new String[] { "1", "", "2", ":3:4" }; [EOL]  [EOL]         actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, ":", 4 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual.length ; i+= 1 ) { [EOL]             assertEquals( expected[i], actual[i] ); [EOL]         } [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testSplitByWholeSeparatorPreserveAllTokens_StringStringInt() { [EOL]         assertArrayEquals( null, StringUtils.splitByWholeSeparatorPreserveAllTokens( null, ".", -1 ) ) ; [EOL]  [EOL]         assertEquals( 0, StringUtils.splitByWholeSeparatorPreserveAllTokens( "", ".", -1 ).length ) ; [EOL]  [EOL]         // test whitespace [EOL]         String input = "ab   de fg" ; [EOL]         String[] expected = new String[] { "ab", "", "", "de", "fg" } ; [EOL]  [EOL]         String[] actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, null, -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual.length ; i+= 1 ) { [EOL]             assertEquals( expected[i], actual[i] ); [EOL]         } [EOL]  [EOL]         // test delimiter singlechar [EOL]         input = "1::2:::3::::4"; [EOL]         expected = new String[] { "1", "", "2", "", "", "3", "", "", "", "4" }; [EOL]  [EOL]         actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, ":", -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual.length ; i+= 1 ) { [EOL]             assertEquals( expected[i], actual[i] ); [EOL]         } [EOL]  [EOL]         // test delimiter multichar [EOL]         input = "1::2:::3::::4"; [EOL]         expected = new String[] { "1", "2", ":3", "", "4" }; [EOL]  [EOL]         actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, "::", -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual.length ; i+= 1 ) { [EOL]             assertEquals( expected[i], actual[i] ); [EOL]         } [EOL]  [EOL]         // test delimiter char with max [EOL]         input = "1::2::3:4"; [EOL]         expected = new String[] { "1", "", "2", ":3:4" }; [EOL]  [EOL]         actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, ":", 4 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual.length ; i+= 1 ) { [EOL]             assertEquals( expected[i], actual[i] ); [EOL]         } [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testSplitPreserveAllTokens_StringString_StringStringInt() { [EOL]         assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".")); [EOL]         assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".", 3)); [EOL]          [EOL]         assertEquals(0, StringUtils.splitPreserveAllTokens("", ".").length); [EOL]         assertEquals(0, StringUtils.splitPreserveAllTokens("", ".", 3).length); [EOL]          [EOL]         innerTestSplitPreserveAllTokens('.', ".", ' '); [EOL]         innerTestSplitPreserveAllTokens('.', ".", ','); [EOL]         innerTestSplitPreserveAllTokens('.', ".,", 'x'); [EOL]         for (int i = 0; i < WHITESPACE.length(); i++) { [EOL]             for (int j = 0; j < NON_WHITESPACE.length(); j++) { [EOL]                 innerTestSplitPreserveAllTokens(WHITESPACE.charAt(i), null, NON_WHITESPACE.charAt(j)); [EOL]                 innerTestSplitPreserveAllTokens(WHITESPACE.charAt(i), String.valueOf(WHITESPACE.charAt(i)), NON_WHITESPACE.charAt(j)); [EOL]             } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "de fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab de fg", null, 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "  de fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab   de fg", null, 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "::de:fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab:::de:fg", ":", 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "", " de fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab   de fg", null, 3); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "", "", "de fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab   de fg", null, 4); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           final String[] expectedResults = {"ab", "cd:ef"}; [EOL]           String[] results; [EOL]           results = StringUtils.splitPreserveAllTokens("ab:cd:ef",":", 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", ":cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab::cd:ef",":", 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "", ":cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab:::cd:ef",":", 3); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "", "", "cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab:::cd:ef",":", 4); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"", "ab", "", "", "cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens(":ab:::cd:ef",":", 5); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"", "", "ab", "", "", "cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens("::ab:::cd:ef",":", 6); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]     } [EOL]      [EOL]     private void innerTestSplitPreserveAllTokens(final char separator, final String sepStr, final char noMatch) { [EOL]         final String msg = "Failed on separator hex(" + Integer.toHexString(separator) + [EOL]             "), noMatch hex(" + Integer.toHexString(noMatch) + "), sepStr(" + sepStr + ")"; [EOL]          [EOL]         final String str = "a" + separator + "b" + separator + separator + noMatch + "c"; [EOL]         String[] res; [EOL]         // (str, sepStr) [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr); [EOL]         assertEquals(msg, 4, res.length); [EOL]         assertEquals(msg, "a", res[0]); [EOL]         assertEquals(msg, "b", res[1]); [EOL]         assertEquals(msg, "", res[2]); [EOL]         assertEquals(msg, noMatch + "c", res[3]); [EOL]          [EOL]         final String str2 = separator + "a" + separator; [EOL]         res = StringUtils.splitPreserveAllTokens(str2, sepStr); [EOL]         assertEquals(msg, 3, res.length); [EOL]         assertEquals(msg, "", res[0]); [EOL]         assertEquals(msg, "a", res[1]); [EOL]         assertEquals(msg, "", res[2]); [EOL]  [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr, -1); [EOL]         assertEquals(msg, 4, res.length); [EOL]         assertEquals(msg, "a", res[0]); [EOL]         assertEquals(msg, "b", res[1]); [EOL]         assertEquals(msg, "", res[2]); [EOL]         assertEquals(msg, noMatch + "c", res[3]); [EOL]          [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr, 0); [EOL]         assertEquals(msg, 4, res.length); [EOL]         assertEquals(msg, "a", res[0]); [EOL]         assertEquals(msg, "b", res[1]); [EOL]         assertEquals(msg, "", res[2]); [EOL]         assertEquals(msg, noMatch + "c", res[3]); [EOL]          [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr, 1); [EOL]         assertEquals(msg, 1, res.length); [EOL]         assertEquals(msg, str, res[0]); [EOL]          [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr, 2); [EOL]         assertEquals(msg, 2, res.length); [EOL]         assertEquals(msg, "a", res[0]); [EOL]         assertEquals(msg, str.substring(2), res[1]); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSplitPreserveAllTokens_StringString_StringStringInt() { [EOL]         assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".")); [EOL]         assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".", 3)); [EOL]          [EOL]         assertEquals(0, StringUtils.splitPreserveAllTokens("", ".").length); [EOL]         assertEquals(0, StringUtils.splitPreserveAllTokens("", ".", 3).length); [EOL]          [EOL]         innerTestSplitPreserveAllTokens('.', ".", ' '); [EOL]         innerTestSplitPreserveAllTokens('.', ".", ','); [EOL]         innerTestSplitPreserveAllTokens('.', ".,", 'x'); [EOL]         for (int i = 0; i < WHITESPACE.length(); i++) { [EOL]             for (int j = 0; j < NON_WHITESPACE.length(); j++) { [EOL]                 innerTestSplitPreserveAllTokens(WHITESPACE.charAt(i), null, NON_WHITESPACE.charAt(j)); [EOL]                 innerTestSplitPreserveAllTokens(WHITESPACE.charAt(i), String.valueOf(WHITESPACE.charAt(i)), NON_WHITESPACE.charAt(j)); [EOL]             } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "de fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab de fg", null, 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "  de fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab   de fg", null, 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "::de:fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab:::de:fg", ":", 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "", " de fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab   de fg", null, 3); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "", "", "de fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab   de fg", null, 4); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           final String[] expectedResults = {"ab", "cd:ef"}; [EOL]           String[] results; [EOL]           results = StringUtils.splitPreserveAllTokens("ab:cd:ef",":", 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", ":cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab::cd:ef",":", 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "", ":cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab:::cd:ef",":", 3); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "", "", "cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab:::cd:ef",":", 4); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"", "ab", "", "", "cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens(":ab:::cd:ef",":", 5); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"", "", "ab", "", "", "cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens("::ab:::cd:ef",":", 6); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]     } [EOL]      [EOL]     private void innerTestSplitPreserveAllTokens(final char separator, final String sepStr, final char noMatch) { [EOL]         final String msg = "Failed on separator hex(" + Integer.toHexString(separator) + [EOL]             "), noMatch hex(" + Integer.toHexString(noMatch) + "), sepStr(" + sepStr + ")"; [EOL]          [EOL]         final String str = "a" + separator + "b" + separator + separator + noMatch + "c"; [EOL]         String[] res; [EOL]         // (str, sepStr) [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr); [EOL]         assertEquals(msg, 4, res.length); [EOL]         assertEquals(msg, "a", res[0]); [EOL]         assertEquals(msg, "b", res[1]); [EOL]         assertEquals(msg, "", res[2]); [EOL]         assertEquals(msg, noMatch + "c", res[3]); [EOL]          [EOL]         final String str2 = separator + "a" + separator; [EOL]         res = StringUtils.splitPreserveAllTokens(str2, sepStr); [EOL]         assertEquals(msg, 3, res.length); [EOL]         assertEquals(msg, "", res[0]); [EOL]         assertEquals(msg, "a", res[1]); [EOL]         assertEquals(msg, "", res[2]); [EOL]  [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr, -1); [EOL]         assertEquals(msg, 4, res.length); [EOL]         assertEquals(msg, "a", res[0]); [EOL]         assertEquals(msg, "b", res[1]); [EOL]         assertEquals(msg, "", res[2]); [EOL]         assertEquals(msg, noMatch + "c", res[3]); [EOL]          [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr, 0); [EOL]         assertEquals(msg, 4, res.length); [EOL]         assertEquals(msg, "a", res[0]); [EOL]         assertEquals(msg, "b", res[1]); [EOL]         assertEquals(msg, "", res[2]); [EOL]         assertEquals(msg, noMatch + "c", res[3]); [EOL]          [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr, 1); [EOL]         assertEquals(msg, 1, res.length); [EOL]         assertEquals(msg, str, res[0]); [EOL]          [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr, 2); [EOL]         assertEquals(msg, 2, res.length); [EOL]         assertEquals(msg, "a", res[0]); [EOL]         assertEquals(msg, str.substring(2), res[1]); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSplitPreserveAllTokens_StringString_StringStringInt() { [EOL]         assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".")); [EOL]         assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".", 3)); [EOL]          [EOL]         assertEquals(0, StringUtils.splitPreserveAllTokens("", ".").length); [EOL]         assertEquals(0, StringUtils.splitPreserveAllTokens("", ".", 3).length); [EOL]          [EOL]         innerTestSplitPreserveAllTokens('.', ".", ' '); [EOL]         innerTestSplitPreserveAllTokens('.', ".", ','); [EOL]         innerTestSplitPreserveAllTokens('.', ".,", 'x'); [EOL]         for (int i = 0; i < WHITESPACE.length(); i++) { [EOL]             for (int j = 0; j < NON_WHITESPACE.length(); j++) { [EOL]                 innerTestSplitPreserveAllTokens(WHITESPACE.charAt(i), null, NON_WHITESPACE.charAt(j)); [EOL]                 innerTestSplitPreserveAllTokens(WHITESPACE.charAt(i), String.valueOf(WHITESPACE.charAt(i)), NON_WHITESPACE.charAt(j)); [EOL]             } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "de fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab de fg", null, 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "  de fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab   de fg", null, 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "::de:fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab:::de:fg", ":", 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "", " de fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab   de fg", null, 3); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "", "", "de fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab   de fg", null, 4); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           final String[] expectedResults = {"ab", "cd:ef"}; [EOL]           String[] results; [EOL]           results = StringUtils.splitPreserveAllTokens("ab:cd:ef",":", 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", ":cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab::cd:ef",":", 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "", ":cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab:::cd:ef",":", 3); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "", "", "cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab:::cd:ef",":", 4); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"", "ab", "", "", "cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens(":ab:::cd:ef",":", 5); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"", "", "ab", "", "", "cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens("::ab:::cd:ef",":", 6); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]     } [EOL]      [EOL]     private void innerTestSplitPreserveAllTokens(final char separator, final String sepStr, final char noMatch) { [EOL]         final String msg = "Failed on separator hex(" + Integer.toHexString(separator) + [EOL]             "), noMatch hex(" + Integer.toHexString(noMatch) + "), sepStr(" + sepStr + ")"; [EOL]          [EOL]         final String str = "a" + separator + "b" + separator + separator + noMatch + "c"; [EOL]         String[] res; [EOL]         // (str, sepStr) [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr); [EOL]         assertEquals(msg, 4, res.length); [EOL]         assertEquals(msg, "a", res[0]); [EOL]         assertEquals(msg, "b", res[1]); [EOL]         assertEquals(msg, "", res[2]); [EOL]         assertEquals(msg, noMatch + "c", res[3]); [EOL]          [EOL]         final String str2 = separator + "a" + separator; [EOL]         res = StringUtils.splitPreserveAllTokens(str2, sepStr); [EOL]         assertEquals(msg, 3, res.length); [EOL]         assertEquals(msg, "", res[0]); [EOL]         assertEquals(msg, "a", res[1]); [EOL]         assertEquals(msg, "", res[2]); [EOL]  [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr, -1); [EOL]         assertEquals(msg, 4, res.length); [EOL]         assertEquals(msg, "a", res[0]); [EOL]         assertEquals(msg, "b", res[1]); [EOL]         assertEquals(msg, "", res[2]); [EOL]         assertEquals(msg, noMatch + "c", res[3]); [EOL]          [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr, 0); [EOL]         assertEquals(msg, 4, res.length); [EOL]         assertEquals(msg, "a", res[0]); [EOL]         assertEquals(msg, "b", res[1]); [EOL]         assertEquals(msg, "", res[2]); [EOL]         assertEquals(msg, noMatch + "c", res[3]); [EOL]          [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr, 1); [EOL]         assertEquals(msg, 1, res.length); [EOL]         assertEquals(msg, str, res[0]); [EOL]          [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr, 2); [EOL]         assertEquals(msg, 2, res.length); [EOL]         assertEquals(msg, "a", res[0]); [EOL]         assertEquals(msg, str.substring(2), res[1]); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSplitPreserveAllTokens_StringString_StringStringInt() { [EOL]         assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".")); [EOL]         assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".", 3)); [EOL]          [EOL]         assertEquals(0, StringUtils.splitPreserveAllTokens("", ".").length); [EOL]         assertEquals(0, StringUtils.splitPreserveAllTokens("", ".", 3).length); [EOL]          [EOL]         innerTestSplitPreserveAllTokens('.', ".", ' '); [EOL]         innerTestSplitPreserveAllTokens('.', ".", ','); [EOL]         innerTestSplitPreserveAllTokens('.', ".,", 'x'); [EOL]         for (int i = 0; i < WHITESPACE.length(); i++) { [EOL]             for (int j = 0; j < NON_WHITESPACE.length(); j++) { [EOL]                 innerTestSplitPreserveAllTokens(WHITESPACE.charAt(i), null, NON_WHITESPACE.charAt(j)); [EOL]                 innerTestSplitPreserveAllTokens(WHITESPACE.charAt(i), String.valueOf(WHITESPACE.charAt(i)), NON_WHITESPACE.charAt(j)); [EOL]             } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "de fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab de fg", null, 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "  de fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab   de fg", null, 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "::de:fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab:::de:fg", ":", 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "", " de fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab   de fg", null, 3); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "", "", "de fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab   de fg", null, 4); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           final String[] expectedResults = {"ab", "cd:ef"}; [EOL]           String[] results; [EOL]           results = StringUtils.splitPreserveAllTokens("ab:cd:ef",":", 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", ":cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab::cd:ef",":", 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "", ":cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab:::cd:ef",":", 3); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "", "", "cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab:::cd:ef",":", 4); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"", "ab", "", "", "cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens(":ab:::cd:ef",":", 5); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"", "", "ab", "", "", "cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens("::ab:::cd:ef",":", 6); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]     } [EOL]      [EOL]     private void innerTestSplitPreserveAllTokens(final char separator, final String sepStr, final char noMatch) { [EOL]         final String msg = "Failed on separator hex(" + Integer.toHexString(separator) + [EOL]             "), noMatch hex(" + Integer.toHexString(noMatch) + "), sepStr(" + sepStr + ")"; [EOL]          [EOL]         final String str = "a" + separator + "b" + separator + separator + noMatch + "c"; [EOL]         String[] res; [EOL]         // (str, sepStr) [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr); [EOL]         assertEquals(msg, 4, res.length); [EOL]         assertEquals(msg, "a", res[0]); [EOL]         assertEquals(msg, "b", res[1]); [EOL]         assertEquals(msg, "", res[2]); [EOL]         assertEquals(msg, noMatch + "c", res[3]); [EOL]          [EOL]         final String str2 = separator + "a" + separator; [EOL]         res = StringUtils.splitPreserveAllTokens(str2, sepStr); [EOL]         assertEquals(msg, 3, res.length); [EOL]         assertEquals(msg, "", res[0]); [EOL]         assertEquals(msg, "a", res[1]); [EOL]         assertEquals(msg, "", res[2]); [EOL]  [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr, -1); [EOL]         assertEquals(msg, 4, res.length); [EOL]         assertEquals(msg, "a", res[0]); [EOL]         assertEquals(msg, "b", res[1]); [EOL]         assertEquals(msg, "", res[2]); [EOL]         assertEquals(msg, noMatch + "c", res[3]); [EOL]          [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr, 0); [EOL]         assertEquals(msg, 4, res.length); [EOL]         assertEquals(msg, "a", res[0]); [EOL]         assertEquals(msg, "b", res[1]); [EOL]         assertEquals(msg, "", res[2]); [EOL]         assertEquals(msg, noMatch + "c", res[3]); [EOL]          [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr, 1); [EOL]         assertEquals(msg, 1, res.length); [EOL]         assertEquals(msg, str, res[0]); [EOL]          [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr, 2); [EOL]         assertEquals(msg, 2, res.length); [EOL]         assertEquals(msg, "a", res[0]); [EOL]         assertEquals(msg, str.substring(2), res[1]); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSplitPreserveAllTokens_StringString_StringStringInt() { [EOL]         assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".")); [EOL]         assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".", 3)); [EOL]          [EOL]         assertEquals(0, StringUtils.splitPreserveAllTokens("", ".").length); [EOL]         assertEquals(0, StringUtils.splitPreserveAllTokens("", ".", 3).length); [EOL]          [EOL]         innerTestSplitPreserveAllTokens('.', ".", ' '); [EOL]         innerTestSplitPreserveAllTokens('.', ".", ','); [EOL]         innerTestSplitPreserveAllTokens('.', ".,", 'x'); [EOL]         for (int i = 0; i < WHITESPACE.length(); i++) { [EOL]             for (int j = 0; j < NON_WHITESPACE.length(); j++) { [EOL]                 innerTestSplitPreserveAllTokens(WHITESPACE.charAt(i), null, NON_WHITESPACE.charAt(j)); [EOL]                 innerTestSplitPreserveAllTokens(WHITESPACE.charAt(i), String.valueOf(WHITESPACE.charAt(i)), NON_WHITESPACE.charAt(j)); [EOL]             } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "de fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab de fg", null, 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "  de fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab   de fg", null, 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "::de:fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab:::de:fg", ":", 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "", " de fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab   de fg", null, 3); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "", "", "de fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab   de fg", null, 4); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           final String[] expectedResults = {"ab", "cd:ef"}; [EOL]           String[] results; [EOL]           results = StringUtils.splitPreserveAllTokens("ab:cd:ef",":", 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", ":cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab::cd:ef",":", 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "", ":cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab:::cd:ef",":", 3); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "", "", "cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab:::cd:ef",":", 4); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"", "ab", "", "", "cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens(":ab:::cd:ef",":", 5); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"", "", "ab", "", "", "cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens("::ab:::cd:ef",":", 6); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]     } [EOL]      [EOL]     private void innerTestSplitPreserveAllTokens(final char separator, final String sepStr, final char noMatch) { [EOL]         final String msg = "Failed on separator hex(" + Integer.toHexString(separator) + [EOL]             "), noMatch hex(" + Integer.toHexString(noMatch) + "), sepStr(" + sepStr + ")"; [EOL]          [EOL]         final String str = "a" + separator + "b" + separator + separator + noMatch + "c"; [EOL]         String[] res; [EOL]         // (str, sepStr) [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr); [EOL]         assertEquals(msg, 4, res.length); [EOL]         assertEquals(msg, "a", res[0]); [EOL]         assertEquals(msg, "b", res[1]); [EOL]         assertEquals(msg, "", res[2]); [EOL]         assertEquals(msg, noMatch + "c", res[3]); [EOL]          [EOL]         final String str2 = separator + "a" + separator; [EOL]         res = StringUtils.splitPreserveAllTokens(str2, sepStr); [EOL]         assertEquals(msg, 3, res.length); [EOL]         assertEquals(msg, "", res[0]); [EOL]         assertEquals(msg, "a", res[1]); [EOL]         assertEquals(msg, "", res[2]); [EOL]  [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr, -1); [EOL]         assertEquals(msg, 4, res.length); [EOL]         assertEquals(msg, "a", res[0]); [EOL]         assertEquals(msg, "b", res[1]); [EOL]         assertEquals(msg, "", res[2]); [EOL]         assertEquals(msg, noMatch + "c", res[3]); [EOL]          [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr, 0); [EOL]         assertEquals(msg, 4, res.length); [EOL]         assertEquals(msg, "a", res[0]); [EOL]         assertEquals(msg, "b", res[1]); [EOL]         assertEquals(msg, "", res[2]); [EOL]         assertEquals(msg, noMatch + "c", res[3]); [EOL]          [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr, 1); [EOL]         assertEquals(msg, 1, res.length); [EOL]         assertEquals(msg, str, res[0]); [EOL]          [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr, 2); [EOL]         assertEquals(msg, 2, res.length); [EOL]         assertEquals(msg, "a", res[0]); [EOL]         assertEquals(msg, str.substring(2), res[1]); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSplitPreserveAllTokens_StringString_StringStringInt() { [EOL]         assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".")); [EOL]         assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".", 3)); [EOL]          [EOL]         assertEquals(0, StringUtils.splitPreserveAllTokens("", ".").length); [EOL]         assertEquals(0, StringUtils.splitPreserveAllTokens("", ".", 3).length); [EOL]          [EOL]         innerTestSplitPreserveAllTokens('.', ".", ' '); [EOL]         innerTestSplitPreserveAllTokens('.', ".", ','); [EOL]         innerTestSplitPreserveAllTokens('.', ".,", 'x'); [EOL]         for (int i = 0; i < WHITESPACE.length(); i++) { [EOL]             for (int j = 0; j < NON_WHITESPACE.length(); j++) { [EOL]                 innerTestSplitPreserveAllTokens(WHITESPACE.charAt(i), null, NON_WHITESPACE.charAt(j)); [EOL]                 innerTestSplitPreserveAllTokens(WHITESPACE.charAt(i), String.valueOf(WHITESPACE.charAt(i)), NON_WHITESPACE.charAt(j)); [EOL]             } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "de fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab de fg", null, 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "  de fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab   de fg", null, 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "::de:fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab:::de:fg", ":", 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "", " de fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab   de fg", null, 3); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "", "", "de fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab   de fg", null, 4); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           final String[] expectedResults = {"ab", "cd:ef"}; [EOL]           String[] results; [EOL]           results = StringUtils.splitPreserveAllTokens("ab:cd:ef",":", 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", ":cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab::cd:ef",":", 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "", ":cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab:::cd:ef",":", 3); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "", "", "cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab:::cd:ef",":", 4); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"", "ab", "", "", "cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens(":ab:::cd:ef",":", 5); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"", "", "ab", "", "", "cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens("::ab:::cd:ef",":", 6); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]     } [EOL]      [EOL]     private void innerTestSplitPreserveAllTokens(final char separator, final String sepStr, final char noMatch) { [EOL]         final String msg = "Failed on separator hex(" + Integer.toHexString(separator) + [EOL]             "), noMatch hex(" + Integer.toHexString(noMatch) + "), sepStr(" + sepStr + ")"; [EOL]          [EOL]         final String str = "a" + separator + "b" + separator + separator + noMatch + "c"; [EOL]         String[] res; [EOL]         // (str, sepStr) [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr); [EOL]         assertEquals(msg, 4, res.length); [EOL]         assertEquals(msg, "a", res[0]); [EOL]         assertEquals(msg, "b", res[1]); [EOL]         assertEquals(msg, "", res[2]); [EOL]         assertEquals(msg, noMatch + "c", res[3]); [EOL]          [EOL]         final String str2 = separator + "a" + separator; [EOL]         res = StringUtils.splitPreserveAllTokens(str2, sepStr); [EOL]         assertEquals(msg, 3, res.length); [EOL]         assertEquals(msg, "", res[0]); [EOL]         assertEquals(msg, "a", res[1]); [EOL]         assertEquals(msg, "", res[2]); [EOL]  [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr, -1); [EOL]         assertEquals(msg, 4, res.length); [EOL]         assertEquals(msg, "a", res[0]); [EOL]         assertEquals(msg, "b", res[1]); [EOL]         assertEquals(msg, "", res[2]); [EOL]         assertEquals(msg, noMatch + "c", res[3]); [EOL]          [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr, 0); [EOL]         assertEquals(msg, 4, res.length); [EOL]         assertEquals(msg, "a", res[0]); [EOL]         assertEquals(msg, "b", res[1]); [EOL]         assertEquals(msg, "", res[2]); [EOL]         assertEquals(msg, noMatch + "c", res[3]); [EOL]          [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr, 1); [EOL]         assertEquals(msg, 1, res.length); [EOL]         assertEquals(msg, str, res[0]); [EOL]          [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr, 2); [EOL]         assertEquals(msg, 2, res.length); [EOL]         assertEquals(msg, "a", res[0]); [EOL]         assertEquals(msg, str.substring(2), res[1]); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSplitPreserveAllTokens_StringString_StringStringInt() { [EOL]         assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".")); [EOL]         assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".", 3)); [EOL]          [EOL]         assertEquals(0, StringUtils.splitPreserveAllTokens("", ".").length); [EOL]         assertEquals(0, StringUtils.splitPreserveAllTokens("", ".", 3).length); [EOL]          [EOL]         innerTestSplitPreserveAllTokens('.', ".", ' '); [EOL]         innerTestSplitPreserveAllTokens('.', ".", ','); [EOL]         innerTestSplitPreserveAllTokens('.', ".,", 'x'); [EOL]         for (int i = 0; i < WHITESPACE.length(); i++) { [EOL]             for (int j = 0; j < NON_WHITESPACE.length(); j++) { [EOL]                 innerTestSplitPreserveAllTokens(WHITESPACE.charAt(i), null, NON_WHITESPACE.charAt(j)); [EOL]                 innerTestSplitPreserveAllTokens(WHITESPACE.charAt(i), String.valueOf(WHITESPACE.charAt(i)), NON_WHITESPACE.charAt(j)); [EOL]             } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "de fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab de fg", null, 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "  de fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab   de fg", null, 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "::de:fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab:::de:fg", ":", 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "", " de fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab   de fg", null, 3); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "", "", "de fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab   de fg", null, 4); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           final String[] expectedResults = {"ab", "cd:ef"}; [EOL]           String[] results; [EOL]           results = StringUtils.splitPreserveAllTokens("ab:cd:ef",":", 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", ":cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab::cd:ef",":", 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "", ":cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab:::cd:ef",":", 3); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "", "", "cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab:::cd:ef",":", 4); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"", "ab", "", "", "cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens(":ab:::cd:ef",":", 5); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"", "", "ab", "", "", "cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens("::ab:::cd:ef",":", 6); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]     } [EOL]      [EOL]     private void innerTestSplitPreserveAllTokens(final char separator, final String sepStr, final char noMatch) { [EOL]         final String msg = "Failed on separator hex(" + Integer.toHexString(separator) + [EOL]             "), noMatch hex(" + Integer.toHexString(noMatch) + "), sepStr(" + sepStr + ")"; [EOL]          [EOL]         final String str = "a" + separator + "b" + separator + separator + noMatch + "c"; [EOL]         String[] res; [EOL]         // (str, sepStr) [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr); [EOL]         assertEquals(msg, 4, res.length); [EOL]         assertEquals(msg, "a", res[0]); [EOL]         assertEquals(msg, "b", res[1]); [EOL]         assertEquals(msg, "", res[2]); [EOL]         assertEquals(msg, noMatch + "c", res[3]); [EOL]          [EOL]         final String str2 = separator + "a" + separator; [EOL]         res = StringUtils.splitPreserveAllTokens(str2, sepStr); [EOL]         assertEquals(msg, 3, res.length); [EOL]         assertEquals(msg, "", res[0]); [EOL]         assertEquals(msg, "a", res[1]); [EOL]         assertEquals(msg, "", res[2]); [EOL]  [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr, -1); [EOL]         assertEquals(msg, 4, res.length); [EOL]         assertEquals(msg, "a", res[0]); [EOL]         assertEquals(msg, "b", res[1]); [EOL]         assertEquals(msg, "", res[2]); [EOL]         assertEquals(msg, noMatch + "c", res[3]); [EOL]          [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr, 0); [EOL]         assertEquals(msg, 4, res.length); [EOL]         assertEquals(msg, "a", res[0]); [EOL]         assertEquals(msg, "b", res[1]); [EOL]         assertEquals(msg, "", res[2]); [EOL]         assertEquals(msg, noMatch + "c", res[3]); [EOL]          [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr, 1); [EOL]         assertEquals(msg, 1, res.length); [EOL]         assertEquals(msg, str, res[0]); [EOL]          [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr, 2); [EOL]         assertEquals(msg, 2, res.length); [EOL]         assertEquals(msg, "a", res[0]); [EOL]         assertEquals(msg, str.substring(2), res[1]); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSplitPreserveAllTokens_StringString_StringStringInt() { [EOL]         assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".")); [EOL]         assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".", 3)); [EOL]          [EOL]         assertEquals(0, StringUtils.splitPreserveAllTokens("", ".").length); [EOL]         assertEquals(0, StringUtils.splitPreserveAllTokens("", ".", 3).length); [EOL]          [EOL]         innerTestSplitPreserveAllTokens('.', ".", ' '); [EOL]         innerTestSplitPreserveAllTokens('.', ".", ','); [EOL]         innerTestSplitPreserveAllTokens('.', ".,", 'x'); [EOL]         for (int i = 0; i < WHITESPACE.length(); i++) { [EOL]             for (int j = 0; j < NON_WHITESPACE.length(); j++) { [EOL]                 innerTestSplitPreserveAllTokens(WHITESPACE.charAt(i), null, NON_WHITESPACE.charAt(j)); [EOL]                 innerTestSplitPreserveAllTokens(WHITESPACE.charAt(i), String.valueOf(WHITESPACE.charAt(i)), NON_WHITESPACE.charAt(j)); [EOL]             } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "de fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab de fg", null, 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "  de fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab   de fg", null, 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "::de:fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab:::de:fg", ":", 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "", " de fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab   de fg", null, 3); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "", "", "de fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab   de fg", null, 4); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           final String[] expectedResults = {"ab", "cd:ef"}; [EOL]           String[] results; [EOL]           results = StringUtils.splitPreserveAllTokens("ab:cd:ef",":", 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", ":cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab::cd:ef",":", 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "", ":cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab:::cd:ef",":", 3); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "", "", "cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab:::cd:ef",":", 4); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"", "ab", "", "", "cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens(":ab:::cd:ef",":", 5); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"", "", "ab", "", "", "cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens("::ab:::cd:ef",":", 6); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]     } [EOL]      [EOL]     private void innerTestSplitPreserveAllTokens(final char separator, final String sepStr, final char noMatch) { [EOL]         final String msg = "Failed on separator hex(" + Integer.toHexString(separator) + [EOL]             "), noMatch hex(" + Integer.toHexString(noMatch) + "), sepStr(" + sepStr + ")"; [EOL]          [EOL]         final String str = "a" + separator + "b" + separator + separator + noMatch + "c"; [EOL]         String[] res; [EOL]         // (str, sepStr) [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr); [EOL]         assertEquals(msg, 4, res.length); [EOL]         assertEquals(msg, "a", res[0]); [EOL]         assertEquals(msg, "b", res[1]); [EOL]         assertEquals(msg, "", res[2]); [EOL]         assertEquals(msg, noMatch + "c", res[3]); [EOL]          [EOL]         final String str2 = separator + "a" + separator; [EOL]         res = StringUtils.splitPreserveAllTokens(str2, sepStr); [EOL]         assertEquals(msg, 3, res.length); [EOL]         assertEquals(msg, "", res[0]); [EOL]         assertEquals(msg, "a", res[1]); [EOL]         assertEquals(msg, "", res[2]); [EOL]  [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr, -1); [EOL]         assertEquals(msg, 4, res.length); [EOL]         assertEquals(msg, "a", res[0]); [EOL]         assertEquals(msg, "b", res[1]); [EOL]         assertEquals(msg, "", res[2]); [EOL]         assertEquals(msg, noMatch + "c", res[3]); [EOL]          [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr, 0); [EOL]         assertEquals(msg, 4, res.length); [EOL]         assertEquals(msg, "a", res[0]); [EOL]         assertEquals(msg, "b", res[1]); [EOL]         assertEquals(msg, "", res[2]); [EOL]         assertEquals(msg, noMatch + "c", res[3]); [EOL]          [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr, 1); [EOL]         assertEquals(msg, 1, res.length); [EOL]         assertEquals(msg, str, res[0]); [EOL]          [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr, 2); [EOL]         assertEquals(msg, 2, res.length); [EOL]         assertEquals(msg, "a", res[0]); [EOL]         assertEquals(msg, str.substring(2), res[1]); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSplitPreserveAllTokens_StringString_StringStringInt() { [EOL]         assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".")); [EOL]         assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".", 3)); [EOL]          [EOL]         assertEquals(0, StringUtils.splitPreserveAllTokens("", ".").length); [EOL]         assertEquals(0, StringUtils.splitPreserveAllTokens("", ".", 3).length); [EOL]          [EOL]         innerTestSplitPreserveAllTokens('.', ".", ' '); [EOL]         innerTestSplitPreserveAllTokens('.', ".", ','); [EOL]         innerTestSplitPreserveAllTokens('.', ".,", 'x'); [EOL]         for (int i = 0; i < WHITESPACE.length(); i++) { [EOL]             for (int j = 0; j < NON_WHITESPACE.length(); j++) { [EOL]                 innerTestSplitPreserveAllTokens(WHITESPACE.charAt(i), null, NON_WHITESPACE.charAt(j)); [EOL]                 innerTestSplitPreserveAllTokens(WHITESPACE.charAt(i), String.valueOf(WHITESPACE.charAt(i)), NON_WHITESPACE.charAt(j)); [EOL]             } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "de fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab de fg", null, 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "  de fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab   de fg", null, 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "::de:fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab:::de:fg", ":", 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "", " de fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab   de fg", null, 3); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "", "", "de fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab   de fg", null, 4); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           final String[] expectedResults = {"ab", "cd:ef"}; [EOL]           String[] results; [EOL]           results = StringUtils.splitPreserveAllTokens("ab:cd:ef",":", 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", ":cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab::cd:ef",":", 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "", ":cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab:::cd:ef",":", 3); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "", "", "cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab:::cd:ef",":", 4); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"", "ab", "", "", "cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens(":ab:::cd:ef",":", 5); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"", "", "ab", "", "", "cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens("::ab:::cd:ef",":", 6); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]     } [EOL]      [EOL]     private void innerTestSplitPreserveAllTokens(final char separator, final String sepStr, final char noMatch) { [EOL]         final String msg = "Failed on separator hex(" + Integer.toHexString(separator) + [EOL]             "), noMatch hex(" + Integer.toHexString(noMatch) + "), sepStr(" + sepStr + ")"; [EOL]          [EOL]         final String str = "a" + separator + "b" + separator + separator + noMatch + "c"; [EOL]         String[] res; [EOL]         // (str, sepStr) [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr); [EOL]         assertEquals(msg, 4, res.length); [EOL]         assertEquals(msg, "a", res[0]); [EOL]         assertEquals(msg, "b", res[1]); [EOL]         assertEquals(msg, "", res[2]); [EOL]         assertEquals(msg, noMatch + "c", res[3]); [EOL]          [EOL]         final String str2 = separator + "a" + separator; [EOL]         res = StringUtils.splitPreserveAllTokens(str2, sepStr); [EOL]         assertEquals(msg, 3, res.length); [EOL]         assertEquals(msg, "", res[0]); [EOL]         assertEquals(msg, "a", res[1]); [EOL]         assertEquals(msg, "", res[2]); [EOL]  [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr, -1); [EOL]         assertEquals(msg, 4, res.length); [EOL]         assertEquals(msg, "a", res[0]); [EOL]         assertEquals(msg, "b", res[1]); [EOL]         assertEquals(msg, "", res[2]); [EOL]         assertEquals(msg, noMatch + "c", res[3]); [EOL]          [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr, 0); [EOL]         assertEquals(msg, 4, res.length); [EOL]         assertEquals(msg, "a", res[0]); [EOL]         assertEquals(msg, "b", res[1]); [EOL]         assertEquals(msg, "", res[2]); [EOL]         assertEquals(msg, noMatch + "c", res[3]); [EOL]          [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr, 1); [EOL]         assertEquals(msg, 1, res.length); [EOL]         assertEquals(msg, str, res[0]); [EOL]          [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr, 2); [EOL]         assertEquals(msg, 2, res.length); [EOL]         assertEquals(msg, "a", res[0]); [EOL]         assertEquals(msg, str.substring(2), res[1]); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSplitPreserveAllTokens_StringString_StringStringInt() { [EOL]         assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".")); [EOL]         assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".", 3)); [EOL]          [EOL]         assertEquals(0, StringUtils.splitPreserveAllTokens("", ".").length); [EOL]         assertEquals(0, StringUtils.splitPreserveAllTokens("", ".", 3).length); [EOL]          [EOL]         innerTestSplitPreserveAllTokens('.', ".", ' '); [EOL]         innerTestSplitPreserveAllTokens('.', ".", ','); [EOL]         innerTestSplitPreserveAllTokens('.', ".,", 'x'); [EOL]         for (int i = 0; i < WHITESPACE.length(); i++) { [EOL]             for (int j = 0; j < NON_WHITESPACE.length(); j++) { [EOL]                 innerTestSplitPreserveAllTokens(WHITESPACE.charAt(i), null, NON_WHITESPACE.charAt(j)); [EOL]                 innerTestSplitPreserveAllTokens(WHITESPACE.charAt(i), String.valueOf(WHITESPACE.charAt(i)), NON_WHITESPACE.charAt(j)); [EOL]             } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "de fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab de fg", null, 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "  de fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab   de fg", null, 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "::de:fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab:::de:fg", ":", 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "", " de fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab   de fg", null, 3); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "", "", "de fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab   de fg", null, 4); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           final String[] expectedResults = {"ab", "cd:ef"}; [EOL]           String[] results; [EOL]           results = StringUtils.splitPreserveAllTokens("ab:cd:ef",":", 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", ":cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab::cd:ef",":", 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "", ":cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab:::cd:ef",":", 3); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "", "", "cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab:::cd:ef",":", 4); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"", "ab", "", "", "cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens(":ab:::cd:ef",":", 5); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"", "", "ab", "", "", "cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens("::ab:::cd:ef",":", 6); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]     } [EOL]      [EOL]     private void innerTestSplitPreserveAllTokens(final char separator, final String sepStr, final char noMatch) { [EOL]         final String msg = "Failed on separator hex(" + Integer.toHexString(separator) + [EOL]             "), noMatch hex(" + Integer.toHexString(noMatch) + "), sepStr(" + sepStr + ")"; [EOL]          [EOL]         final String str = "a" + separator + "b" + separator + separator + noMatch + "c"; [EOL]         String[] res; [EOL]         // (str, sepStr) [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr); [EOL]         assertEquals(msg, 4, res.length); [EOL]         assertEquals(msg, "a", res[0]); [EOL]         assertEquals(msg, "b", res[1]); [EOL]         assertEquals(msg, "", res[2]); [EOL]         assertEquals(msg, noMatch + "c", res[3]); [EOL]          [EOL]         final String str2 = separator + "a" + separator; [EOL]         res = StringUtils.splitPreserveAllTokens(str2, sepStr); [EOL]         assertEquals(msg, 3, res.length); [EOL]         assertEquals(msg, "", res[0]); [EOL]         assertEquals(msg, "a", res[1]); [EOL]         assertEquals(msg, "", res[2]); [EOL]  [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr, -1); [EOL]         assertEquals(msg, 4, res.length); [EOL]         assertEquals(msg, "a", res[0]); [EOL]         assertEquals(msg, "b", res[1]); [EOL]         assertEquals(msg, "", res[2]); [EOL]         assertEquals(msg, noMatch + "c", res[3]); [EOL]          [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr, 0); [EOL]         assertEquals(msg, 4, res.length); [EOL]         assertEquals(msg, "a", res[0]); [EOL]         assertEquals(msg, "b", res[1]); [EOL]         assertEquals(msg, "", res[2]); [EOL]         assertEquals(msg, noMatch + "c", res[3]); [EOL]          [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr, 1); [EOL]         assertEquals(msg, 1, res.length); [EOL]         assertEquals(msg, str, res[0]); [EOL]          [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr, 2); [EOL]         assertEquals(msg, 2, res.length); [EOL]         assertEquals(msg, "a", res[0]); [EOL]         assertEquals(msg, str.substring(2), res[1]); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSplitPreserveAllTokens_StringString_StringStringInt() { [EOL]         assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".")); [EOL]         assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".", 3)); [EOL]          [EOL]         assertEquals(0, StringUtils.splitPreserveAllTokens("", ".").length); [EOL]         assertEquals(0, StringUtils.splitPreserveAllTokens("", ".", 3).length); [EOL]          [EOL]         innerTestSplitPreserveAllTokens('.', ".", ' '); [EOL]         innerTestSplitPreserveAllTokens('.', ".", ','); [EOL]         innerTestSplitPreserveAllTokens('.', ".,", 'x'); [EOL]         for (int i = 0; i < WHITESPACE.length(); i++) { [EOL]             for (int j = 0; j < NON_WHITESPACE.length(); j++) { [EOL]                 innerTestSplitPreserveAllTokens(WHITESPACE.charAt(i), null, NON_WHITESPACE.charAt(j)); [EOL]                 innerTestSplitPreserveAllTokens(WHITESPACE.charAt(i), String.valueOf(WHITESPACE.charAt(i)), NON_WHITESPACE.charAt(j)); [EOL]             } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "de fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab de fg", null, 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "  de fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab   de fg", null, 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "::de:fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab:::de:fg", ":", 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "", " de fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab   de fg", null, 3); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "", "", "de fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab   de fg", null, 4); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           final String[] expectedResults = {"ab", "cd:ef"}; [EOL]           String[] results; [EOL]           results = StringUtils.splitPreserveAllTokens("ab:cd:ef",":", 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", ":cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab::cd:ef",":", 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "", ":cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab:::cd:ef",":", 3); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "", "", "cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab:::cd:ef",":", 4); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"", "ab", "", "", "cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens(":ab:::cd:ef",":", 5); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"", "", "ab", "", "", "cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens("::ab:::cd:ef",":", 6); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]     } [EOL]      [EOL]     private void innerTestSplitPreserveAllTokens(final char separator, final String sepStr, final char noMatch) { [EOL]         final String msg = "Failed on separator hex(" + Integer.toHexString(separator) + [EOL]             "), noMatch hex(" + Integer.toHexString(noMatch) + "), sepStr(" + sepStr + ")"; [EOL]          [EOL]         final String str = "a" + separator + "b" + separator + separator + noMatch + "c"; [EOL]         String[] res; [EOL]         // (str, sepStr) [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr); [EOL]         assertEquals(msg, 4, res.length); [EOL]         assertEquals(msg, "a", res[0]); [EOL]         assertEquals(msg, "b", res[1]); [EOL]         assertEquals(msg, "", res[2]); [EOL]         assertEquals(msg, noMatch + "c", res[3]); [EOL]          [EOL]         final String str2 = separator + "a" + separator; [EOL]         res = StringUtils.splitPreserveAllTokens(str2, sepStr); [EOL]         assertEquals(msg, 3, res.length); [EOL]         assertEquals(msg, "", res[0]); [EOL]         assertEquals(msg, "a", res[1]); [EOL]         assertEquals(msg, "", res[2]); [EOL]  [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr, -1); [EOL]         assertEquals(msg, 4, res.length); [EOL]         assertEquals(msg, "a", res[0]); [EOL]         assertEquals(msg, "b", res[1]); [EOL]         assertEquals(msg, "", res[2]); [EOL]         assertEquals(msg, noMatch + "c", res[3]); [EOL]          [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr, 0); [EOL]         assertEquals(msg, 4, res.length); [EOL]         assertEquals(msg, "a", res[0]); [EOL]         assertEquals(msg, "b", res[1]); [EOL]         assertEquals(msg, "", res[2]); [EOL]         assertEquals(msg, noMatch + "c", res[3]); [EOL]          [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr, 1); [EOL]         assertEquals(msg, 1, res.length); [EOL]         assertEquals(msg, str, res[0]); [EOL]          [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr, 2); [EOL]         assertEquals(msg, 2, res.length); [EOL]         assertEquals(msg, "a", res[0]); [EOL]         assertEquals(msg, str.substring(2), res[1]); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSplitPreserveAllTokens_StringString_StringStringInt() { [EOL]         assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".")); [EOL]         assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".", 3)); [EOL]          [EOL]         assertEquals(0, StringUtils.splitPreserveAllTokens("", ".").length); [EOL]         assertEquals(0, StringUtils.splitPreserveAllTokens("", ".", 3).length); [EOL]          [EOL]         innerTestSplitPreserveAllTokens('.', ".", ' '); [EOL]         innerTestSplitPreserveAllTokens('.', ".", ','); [EOL]         innerTestSplitPreserveAllTokens('.', ".,", 'x'); [EOL]         for (int i = 0; i < WHITESPACE.length(); i++) { [EOL]             for (int j = 0; j < NON_WHITESPACE.length(); j++) { [EOL]                 innerTestSplitPreserveAllTokens(WHITESPACE.charAt(i), null, NON_WHITESPACE.charAt(j)); [EOL]                 innerTestSplitPreserveAllTokens(WHITESPACE.charAt(i), String.valueOf(WHITESPACE.charAt(i)), NON_WHITESPACE.charAt(j)); [EOL]             } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "de fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab de fg", null, 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "  de fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab   de fg", null, 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "::de:fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab:::de:fg", ":", 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "", " de fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab   de fg", null, 3); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "", "", "de fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab   de fg", null, 4); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           final String[] expectedResults = {"ab", "cd:ef"}; [EOL]           String[] results; [EOL]           results = StringUtils.splitPreserveAllTokens("ab:cd:ef",":", 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", ":cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab::cd:ef",":", 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "", ":cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab:::cd:ef",":", 3); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "", "", "cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab:::cd:ef",":", 4); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"", "ab", "", "", "cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens(":ab:::cd:ef",":", 5); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"", "", "ab", "", "", "cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens("::ab:::cd:ef",":", 6); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]     } [EOL]      [EOL]     private void innerTestSplitPreserveAllTokens(final char separator, final String sepStr, final char noMatch) { [EOL]         final String msg = "Failed on separator hex(" + Integer.toHexString(separator) + [EOL]             "), noMatch hex(" + Integer.toHexString(noMatch) + "), sepStr(" + sepStr + ")"; [EOL]          [EOL]         final String str = "a" + separator + "b" + separator + separator + noMatch + "c"; [EOL]         String[] res; [EOL]         // (str, sepStr) [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr); [EOL]         assertEquals(msg, 4, res.length); [EOL]         assertEquals(msg, "a", res[0]); [EOL]         assertEquals(msg, "b", res[1]); [EOL]         assertEquals(msg, "", res[2]); [EOL]         assertEquals(msg, noMatch + "c", res[3]); [EOL]          [EOL]         final String str2 = separator + "a" + separator; [EOL]         res = StringUtils.splitPreserveAllTokens(str2, sepStr); [EOL]         assertEquals(msg, 3, res.length); [EOL]         assertEquals(msg, "", res[0]); [EOL]         assertEquals(msg, "a", res[1]); [EOL]         assertEquals(msg, "", res[2]); [EOL]  [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr, -1); [EOL]         assertEquals(msg, 4, res.length); [EOL]         assertEquals(msg, "a", res[0]); [EOL]         assertEquals(msg, "b", res[1]); [EOL]         assertEquals(msg, "", res[2]); [EOL]         assertEquals(msg, noMatch + "c", res[3]); [EOL]          [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr, 0); [EOL]         assertEquals(msg, 4, res.length); [EOL]         assertEquals(msg, "a", res[0]); [EOL]         assertEquals(msg, "b", res[1]); [EOL]         assertEquals(msg, "", res[2]); [EOL]         assertEquals(msg, noMatch + "c", res[3]); [EOL]          [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr, 1); [EOL]         assertEquals(msg, 1, res.length); [EOL]         assertEquals(msg, str, res[0]); [EOL]          [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr, 2); [EOL]         assertEquals(msg, 2, res.length); [EOL]         assertEquals(msg, "a", res[0]); [EOL]         assertEquals(msg, str.substring(2), res[1]); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSplitPreserveAllTokens_StringString_StringStringInt() { [EOL]         assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".")); [EOL]         assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".", 3)); [EOL]          [EOL]         assertEquals(0, StringUtils.splitPreserveAllTokens("", ".").length); [EOL]         assertEquals(0, StringUtils.splitPreserveAllTokens("", ".", 3).length); [EOL]          [EOL]         innerTestSplitPreserveAllTokens('.', ".", ' '); [EOL]         innerTestSplitPreserveAllTokens('.', ".", ','); [EOL]         innerTestSplitPreserveAllTokens('.', ".,", 'x'); [EOL]         for (int i = 0; i < WHITESPACE.length(); i++) { [EOL]             for (int j = 0; j < NON_WHITESPACE.length(); j++) { [EOL]                 innerTestSplitPreserveAllTokens(WHITESPACE.charAt(i), null, NON_WHITESPACE.charAt(j)); [EOL]                 innerTestSplitPreserveAllTokens(WHITESPACE.charAt(i), String.valueOf(WHITESPACE.charAt(i)), NON_WHITESPACE.charAt(j)); [EOL]             } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "de fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab de fg", null, 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "  de fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab   de fg", null, 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "::de:fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab:::de:fg", ":", 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "", " de fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab   de fg", null, 3); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "", "", "de fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab   de fg", null, 4); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           final String[] expectedResults = {"ab", "cd:ef"}; [EOL]           String[] results; [EOL]           results = StringUtils.splitPreserveAllTokens("ab:cd:ef",":", 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", ":cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab::cd:ef",":", 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "", ":cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab:::cd:ef",":", 3); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "", "", "cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab:::cd:ef",":", 4); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"", "ab", "", "", "cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens(":ab:::cd:ef",":", 5); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"", "", "ab", "", "", "cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens("::ab:::cd:ef",":", 6); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]     } [EOL]      [EOL]     private void innerTestSplitPreserveAllTokens(final char separator, final String sepStr, final char noMatch) { [EOL]         final String msg = "Failed on separator hex(" + Integer.toHexString(separator) + [EOL]             "), noMatch hex(" + Integer.toHexString(noMatch) + "), sepStr(" + sepStr + ")"; [EOL]          [EOL]         final String str = "a" + separator + "b" + separator + separator + noMatch + "c"; [EOL]         String[] res; [EOL]         // (str, sepStr) [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr); [EOL]         assertEquals(msg, 4, res.length); [EOL]         assertEquals(msg, "a", res[0]); [EOL]         assertEquals(msg, "b", res[1]); [EOL]         assertEquals(msg, "", res[2]); [EOL]         assertEquals(msg, noMatch + "c", res[3]); [EOL]          [EOL]         final String str2 = separator + "a" + separator; [EOL]         res = StringUtils.splitPreserveAllTokens(str2, sepStr); [EOL]         assertEquals(msg, 3, res.length); [EOL]         assertEquals(msg, "", res[0]); [EOL]         assertEquals(msg, "a", res[1]); [EOL]         assertEquals(msg, "", res[2]); [EOL]  [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr, -1); [EOL]         assertEquals(msg, 4, res.length); [EOL]         assertEquals(msg, "a", res[0]); [EOL]         assertEquals(msg, "b", res[1]); [EOL]         assertEquals(msg, "", res[2]); [EOL]         assertEquals(msg, noMatch + "c", res[3]); [EOL]          [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr, 0); [EOL]         assertEquals(msg, 4, res.length); [EOL]         assertEquals(msg, "a", res[0]); [EOL]         assertEquals(msg, "b", res[1]); [EOL]         assertEquals(msg, "", res[2]); [EOL]         assertEquals(msg, noMatch + "c", res[3]); [EOL]          [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr, 1); [EOL]         assertEquals(msg, 1, res.length); [EOL]         assertEquals(msg, str, res[0]); [EOL]          [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr, 2); [EOL]         assertEquals(msg, 2, res.length); [EOL]         assertEquals(msg, "a", res[0]); [EOL]         assertEquals(msg, str.substring(2), res[1]); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSplitPreserveAllTokens_StringString_StringStringInt() { [EOL]         assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".")); [EOL]         assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".", 3)); [EOL]          [EOL]         assertEquals(0, StringUtils.splitPreserveAllTokens("", ".").length); [EOL]         assertEquals(0, StringUtils.splitPreserveAllTokens("", ".", 3).length); [EOL]          [EOL]         innerTestSplitPreserveAllTokens('.', ".", ' '); [EOL]         innerTestSplitPreserveAllTokens('.', ".", ','); [EOL]         innerTestSplitPreserveAllTokens('.', ".,", 'x'); [EOL]         for (int i = 0; i < WHITESPACE.length(); i++) { [EOL]             for (int j = 0; j < NON_WHITESPACE.length(); j++) { [EOL]                 innerTestSplitPreserveAllTokens(WHITESPACE.charAt(i), null, NON_WHITESPACE.charAt(j)); [EOL]                 innerTestSplitPreserveAllTokens(WHITESPACE.charAt(i), String.valueOf(WHITESPACE.charAt(i)), NON_WHITESPACE.charAt(j)); [EOL]             } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "de fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab de fg", null, 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "  de fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab   de fg", null, 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "::de:fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab:::de:fg", ":", 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "", " de fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab   de fg", null, 3); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "", "", "de fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab   de fg", null, 4); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           final String[] expectedResults = {"ab", "cd:ef"}; [EOL]           String[] results; [EOL]           results = StringUtils.splitPreserveAllTokens("ab:cd:ef",":", 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", ":cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab::cd:ef",":", 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "", ":cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab:::cd:ef",":", 3); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "", "", "cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab:::cd:ef",":", 4); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"", "ab", "", "", "cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens(":ab:::cd:ef",":", 5); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"", "", "ab", "", "", "cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens("::ab:::cd:ef",":", 6); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]     } [EOL]      [EOL]     private void innerTestSplitPreserveAllTokens(final char separator, final String sepStr, final char noMatch) { [EOL]         final String msg = "Failed on separator hex(" + Integer.toHexString(separator) + [EOL]             "), noMatch hex(" + Integer.toHexString(noMatch) + "), sepStr(" + sepStr + ")"; [EOL]          [EOL]         final String str = "a" + separator + "b" + separator + separator + noMatch + "c"; [EOL]         String[] res; [EOL]         // (str, sepStr) [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr); [EOL]         assertEquals(msg, 4, res.length); [EOL]         assertEquals(msg, "a", res[0]); [EOL]         assertEquals(msg, "b", res[1]); [EOL]         assertEquals(msg, "", res[2]); [EOL]         assertEquals(msg, noMatch + "c", res[3]); [EOL]          [EOL]         final String str2 = separator + "a" + separator; [EOL]         res = StringUtils.splitPreserveAllTokens(str2, sepStr); [EOL]         assertEquals(msg, 3, res.length); [EOL]         assertEquals(msg, "", res[0]); [EOL]         assertEquals(msg, "a", res[1]); [EOL]         assertEquals(msg, "", res[2]); [EOL]  [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr, -1); [EOL]         assertEquals(msg, 4, res.length); [EOL]         assertEquals(msg, "a", res[0]); [EOL]         assertEquals(msg, "b", res[1]); [EOL]         assertEquals(msg, "", res[2]); [EOL]         assertEquals(msg, noMatch + "c", res[3]); [EOL]          [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr, 0); [EOL]         assertEquals(msg, 4, res.length); [EOL]         assertEquals(msg, "a", res[0]); [EOL]         assertEquals(msg, "b", res[1]); [EOL]         assertEquals(msg, "", res[2]); [EOL]         assertEquals(msg, noMatch + "c", res[3]); [EOL]          [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr, 1); [EOL]         assertEquals(msg, 1, res.length); [EOL]         assertEquals(msg, str, res[0]); [EOL]          [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr, 2); [EOL]         assertEquals(msg, 2, res.length); [EOL]         assertEquals(msg, "a", res[0]); [EOL]         assertEquals(msg, str.substring(2), res[1]); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSplitPreserveAllTokens_StringString_StringStringInt() { [EOL]         assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".")); [EOL]         assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".", 3)); [EOL]          [EOL]         assertEquals(0, StringUtils.splitPreserveAllTokens("", ".").length); [EOL]         assertEquals(0, StringUtils.splitPreserveAllTokens("", ".", 3).length); [EOL]          [EOL]         innerTestSplitPreserveAllTokens('.', ".", ' '); [EOL]         innerTestSplitPreserveAllTokens('.', ".", ','); [EOL]         innerTestSplitPreserveAllTokens('.', ".,", 'x'); [EOL]         for (int i = 0; i < WHITESPACE.length(); i++) { [EOL]             for (int j = 0; j < NON_WHITESPACE.length(); j++) { [EOL]                 innerTestSplitPreserveAllTokens(WHITESPACE.charAt(i), null, NON_WHITESPACE.charAt(j)); [EOL]                 innerTestSplitPreserveAllTokens(WHITESPACE.charAt(i), String.valueOf(WHITESPACE.charAt(i)), NON_WHITESPACE.charAt(j)); [EOL]             } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "de fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab de fg", null, 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "  de fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab   de fg", null, 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "::de:fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab:::de:fg", ":", 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "", " de fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab   de fg", null, 3); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "", "", "de fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab   de fg", null, 4); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           final String[] expectedResults = {"ab", "cd:ef"}; [EOL]           String[] results; [EOL]           results = StringUtils.splitPreserveAllTokens("ab:cd:ef",":", 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", ":cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab::cd:ef",":", 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "", ":cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab:::cd:ef",":", 3); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "", "", "cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab:::cd:ef",":", 4); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"", "ab", "", "", "cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens(":ab:::cd:ef",":", 5); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"", "", "ab", "", "", "cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens("::ab:::cd:ef",":", 6); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]     } [EOL]      [EOL]     private void innerTestSplitPreserveAllTokens(final char separator, final String sepStr, final char noMatch) { [EOL]         final String msg = "Failed on separator hex(" + Integer.toHexString(separator) + [EOL]             "), noMatch hex(" + Integer.toHexString(noMatch) + "), sepStr(" + sepStr + ")"; [EOL]          [EOL]         final String str = "a" + separator + "b" + separator + separator + noMatch + "c"; [EOL]         String[] res; [EOL]         // (str, sepStr) [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr); [EOL]         assertEquals(msg, 4, res.length); [EOL]         assertEquals(msg, "a", res[0]); [EOL]         assertEquals(msg, "b", res[1]); [EOL]         assertEquals(msg, "", res[2]); [EOL]         assertEquals(msg, noMatch + "c", res[3]); [EOL]          [EOL]         final String str2 = separator + "a" + separator; [EOL]         res = StringUtils.splitPreserveAllTokens(str2, sepStr); [EOL]         assertEquals(msg, 3, res.length); [EOL]         assertEquals(msg, "", res[0]); [EOL]         assertEquals(msg, "a", res[1]); [EOL]         assertEquals(msg, "", res[2]); [EOL]  [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr, -1); [EOL]         assertEquals(msg, 4, res.length); [EOL]         assertEquals(msg, "a", res[0]); [EOL]         assertEquals(msg, "b", res[1]); [EOL]         assertEquals(msg, "", res[2]); [EOL]         assertEquals(msg, noMatch + "c", res[3]); [EOL]          [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr, 0); [EOL]         assertEquals(msg, 4, res.length); [EOL]         assertEquals(msg, "a", res[0]); [EOL]         assertEquals(msg, "b", res[1]); [EOL]         assertEquals(msg, "", res[2]); [EOL]         assertEquals(msg, noMatch + "c", res[3]); [EOL]          [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr, 1); [EOL]         assertEquals(msg, 1, res.length); [EOL]         assertEquals(msg, str, res[0]); [EOL]          [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr, 2); [EOL]         assertEquals(msg, 2, res.length); [EOL]         assertEquals(msg, "a", res[0]); [EOL]         assertEquals(msg, str.substring(2), res[1]); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSplitPreserveAllTokens_StringString_StringStringInt() { [EOL]         assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".")); [EOL]         assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".", 3)); [EOL]          [EOL]         assertEquals(0, StringUtils.splitPreserveAllTokens("", ".").length); [EOL]         assertEquals(0, StringUtils.splitPreserveAllTokens("", ".", 3).length); [EOL]          [EOL]         innerTestSplitPreserveAllTokens('.', ".", ' '); [EOL]         innerTestSplitPreserveAllTokens('.', ".", ','); [EOL]         innerTestSplitPreserveAllTokens('.', ".,", 'x'); [EOL]         for (int i = 0; i < WHITESPACE.length(); i++) { [EOL]             for (int j = 0; j < NON_WHITESPACE.length(); j++) { [EOL]                 innerTestSplitPreserveAllTokens(WHITESPACE.charAt(i), null, NON_WHITESPACE.charAt(j)); [EOL]                 innerTestSplitPreserveAllTokens(WHITESPACE.charAt(i), String.valueOf(WHITESPACE.charAt(i)), NON_WHITESPACE.charAt(j)); [EOL]             } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "de fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab de fg", null, 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "  de fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab   de fg", null, 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "::de:fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab:::de:fg", ":", 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "", " de fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab   de fg", null, 3); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "", "", "de fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab   de fg", null, 4); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           final String[] expectedResults = {"ab", "cd:ef"}; [EOL]           String[] results; [EOL]           results = StringUtils.splitPreserveAllTokens("ab:cd:ef",":", 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", ":cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab::cd:ef",":", 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "", ":cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab:::cd:ef",":", 3); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "", "", "cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab:::cd:ef",":", 4); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"", "ab", "", "", "cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens(":ab:::cd:ef",":", 5); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"", "", "ab", "", "", "cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens("::ab:::cd:ef",":", 6); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]     } [EOL]      [EOL]     private void innerTestSplitPreserveAllTokens(final char separator, final String sepStr, final char noMatch) { [EOL]         final String msg = "Failed on separator hex(" + Integer.toHexString(separator) + [EOL]             "), noMatch hex(" + Integer.toHexString(noMatch) + "), sepStr(" + sepStr + ")"; [EOL]          [EOL]         final String str = "a" + separator + "b" + separator + separator + noMatch + "c"; [EOL]         String[] res; [EOL]         // (str, sepStr) [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr); [EOL]         assertEquals(msg, 4, res.length); [EOL]         assertEquals(msg, "a", res[0]); [EOL]         assertEquals(msg, "b", res[1]); [EOL]         assertEquals(msg, "", res[2]); [EOL]         assertEquals(msg, noMatch + "c", res[3]); [EOL]          [EOL]         final String str2 = separator + "a" + separator; [EOL]         res = StringUtils.splitPreserveAllTokens(str2, sepStr); [EOL]         assertEquals(msg, 3, res.length); [EOL]         assertEquals(msg, "", res[0]); [EOL]         assertEquals(msg, "a", res[1]); [EOL]         assertEquals(msg, "", res[2]); [EOL]  [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr, -1); [EOL]         assertEquals(msg, 4, res.length); [EOL]         assertEquals(msg, "a", res[0]); [EOL]         assertEquals(msg, "b", res[1]); [EOL]         assertEquals(msg, "", res[2]); [EOL]         assertEquals(msg, noMatch + "c", res[3]); [EOL]          [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr, 0); [EOL]         assertEquals(msg, 4, res.length); [EOL]         assertEquals(msg, "a", res[0]); [EOL]         assertEquals(msg, "b", res[1]); [EOL]         assertEquals(msg, "", res[2]); [EOL]         assertEquals(msg, noMatch + "c", res[3]); [EOL]          [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr, 1); [EOL]         assertEquals(msg, 1, res.length); [EOL]         assertEquals(msg, str, res[0]); [EOL]          [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr, 2); [EOL]         assertEquals(msg, 2, res.length); [EOL]         assertEquals(msg, "a", res[0]); [EOL]         assertEquals(msg, str.substring(2), res[1]); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSplitPreserveAllTokens_StringString_StringStringInt() { [EOL]         assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".")); [EOL]         assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".", 3)); [EOL]          [EOL]         assertEquals(0, StringUtils.splitPreserveAllTokens("", ".").length); [EOL]         assertEquals(0, StringUtils.splitPreserveAllTokens("", ".", 3).length); [EOL]          [EOL]         innerTestSplitPreserveAllTokens('.', ".", ' '); [EOL]         innerTestSplitPreserveAllTokens('.', ".", ','); [EOL]         innerTestSplitPreserveAllTokens('.', ".,", 'x'); [EOL]         for (int i = 0; i < WHITESPACE.length(); i++) { [EOL]             for (int j = 0; j < NON_WHITESPACE.length(); j++) { [EOL]                 innerTestSplitPreserveAllTokens(WHITESPACE.charAt(i), null, NON_WHITESPACE.charAt(j)); [EOL]                 innerTestSplitPreserveAllTokens(WHITESPACE.charAt(i), String.valueOf(WHITESPACE.charAt(i)), NON_WHITESPACE.charAt(j)); [EOL]             } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "de fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab de fg", null, 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "  de fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab   de fg", null, 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "::de:fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab:::de:fg", ":", 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "", " de fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab   de fg", null, 3); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "", "", "de fg"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab   de fg", null, 4); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           final String[] expectedResults = {"ab", "cd:ef"}; [EOL]           String[] results; [EOL]           results = StringUtils.splitPreserveAllTokens("ab:cd:ef",":", 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", ":cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab::cd:ef",":", 2); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "", ":cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab:::cd:ef",":", 3); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"ab", "", "", "cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens("ab:::cd:ef",":", 4); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]  [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"", "ab", "", "", "cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens(":ab:::cd:ef",":", 5); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]         { [EOL]           String[] results; [EOL]           final String[] expectedResults = {"", "", "ab", "", "", "cd:ef"}; [EOL]           results = StringUtils.splitPreserveAllTokens("::ab:::cd:ef",":", 6); [EOL]           assertEquals(expectedResults.length, results.length); [EOL]           for (int i = 0; i < expectedResults.length; i++) { [EOL]               assertEquals(expectedResults[i], results[i]); [EOL]           } [EOL]         } [EOL]          [EOL]     } [EOL]      [EOL]     private void innerTestSplitPreserveAllTokens(final char separator, final String sepStr, final char noMatch) { [EOL]         final String msg = "Failed on separator hex(" + Integer.toHexString(separator) + [EOL]             "), noMatch hex(" + Integer.toHexString(noMatch) + "), sepStr(" + sepStr + ")"; [EOL]          [EOL]         final String str = "a" + separator + "b" + separator + separator + noMatch + "c"; [EOL]         String[] res; [EOL]         // (str, sepStr) [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr); [EOL]         assertEquals(msg, 4, res.length); [EOL]         assertEquals(msg, "a", res[0]); [EOL]         assertEquals(msg, "b", res[1]); [EOL]         assertEquals(msg, "", res[2]); [EOL]         assertEquals(msg, noMatch + "c", res[3]); [EOL]          [EOL]         final String str2 = separator + "a" + separator; [EOL]         res = StringUtils.splitPreserveAllTokens(str2, sepStr); [EOL]         assertEquals(msg, 3, res.length); [EOL]         assertEquals(msg, "", res[0]); [EOL]         assertEquals(msg, "a", res[1]); [EOL]         assertEquals(msg, "", res[2]); [EOL]  [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr, -1); [EOL]         assertEquals(msg, 4, res.length); [EOL]         assertEquals(msg, "a", res[0]); [EOL]         assertEquals(msg, "b", res[1]); [EOL]         assertEquals(msg, "", res[2]); [EOL]         assertEquals(msg, noMatch + "c", res[3]); [EOL]          [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr, 0); [EOL]         assertEquals(msg, 4, res.length); [EOL]         assertEquals(msg, "a", res[0]); [EOL]         assertEquals(msg, "b", res[1]); [EOL]         assertEquals(msg, "", res[2]); [EOL]         assertEquals(msg, noMatch + "c", res[3]); [EOL]          [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr, 1); [EOL]         assertEquals(msg, 1, res.length); [EOL]         assertEquals(msg, str, res[0]); [EOL]          [EOL]         res = StringUtils.splitPreserveAllTokens(str, sepStr, 2); [EOL]         assertEquals(msg, 2, res.length); [EOL]         assertEquals(msg, "a", res[0]); [EOL]         assertEquals(msg, str.substring(2), res[1]); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testJoin_ArrayOfFloats() { [EOL]         assertEquals(null, StringUtils.join((float[]) null, ',')); [EOL]         assertEquals("1.0;2.0", StringUtils.join(FLOAT_PRIM_LIST, SEPARATOR_CHAR)); [EOL]         assertEquals("2.0", StringUtils.join(FLOAT_PRIM_LIST, SEPARATOR_CHAR, 1, 2)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testJoin_ArrayOfDoubles() { [EOL]         assertEquals(null, StringUtils.join((double[]) null, ',')); [EOL]         assertEquals("1.0;2.0", StringUtils.join(DOUBLE_PRIM_LIST, SEPARATOR_CHAR)); [EOL]         assertEquals("2.0", StringUtils.join(DOUBLE_PRIM_LIST, SEPARATOR_CHAR, 1, 2)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testJoin_IteratorChar() { [EOL]         assertEquals(null, StringUtils.join((Iterator<?>) null, ',')); [EOL]         assertEquals(TEXT_LIST_CHAR, StringUtils.join(Arrays.asList(ARRAY_LIST).iterator(), SEPARATOR_CHAR)); [EOL]         assertEquals("", StringUtils.join(Arrays.asList(NULL_ARRAY_LIST).iterator(), SEPARATOR_CHAR)); [EOL]         assertEquals("", StringUtils.join(Arrays.asList(EMPTY_ARRAY_LIST).iterator(), SEPARATOR_CHAR)); [EOL]         assertEquals("foo", StringUtils.join(Collections.singleton("foo").iterator(), 'x')); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testReplace_StringStringStringInt() { [EOL]         assertEquals(null, StringUtils.replace(null, null, null, 2)); [EOL]         assertEquals(null, StringUtils.replace(null, null, "any", 2)); [EOL]         assertEquals(null, StringUtils.replace(null, "any", null, 2)); [EOL]         assertEquals(null, StringUtils.replace(null, "any", "any", 2)); [EOL]  [EOL]         assertEquals("", StringUtils.replace("", null, null, 2)); [EOL]         assertEquals("", StringUtils.replace("", null, "any", 2)); [EOL]         assertEquals("", StringUtils.replace("", "any", null, 2)); [EOL]         assertEquals("", StringUtils.replace("", "any", "any", 2)); [EOL]          [EOL]         final String str = new String(new char[] {'o', 'o', 'f', 'o', 'o'}); [EOL]         assertSame(str, StringUtils.replace(str, "x", "", -1)); [EOL]          [EOL]         assertEquals("f", StringUtils.replace("oofoo", "o", "", -1)); [EOL]         assertEquals("oofoo", StringUtils.replace("oofoo", "o", "", 0)); [EOL]         assertEquals("ofoo", StringUtils.replace("oofoo", "o", "", 1)); [EOL]         assertEquals("foo", StringUtils.replace("oofoo", "o", "", 2)); [EOL]         assertEquals("fo", StringUtils.replace("oofoo", "o", "", 3)); [EOL]         assertEquals("f", StringUtils.replace("oofoo", "o", "", 4)); [EOL]          [EOL]         assertEquals("f", StringUtils.replace("oofoo", "o", "", -5)); [EOL]         assertEquals("f", StringUtils.replace("oofoo", "o", "", 1000)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testReplace_StringStringArrayStringArrayBoolean() { [EOL]         //JAVADOC TESTS START [EOL]         assertNull(StringUtils.replaceEachRepeatedly(null, new String[]{"a"}, new String[]{"b"})); [EOL]         assertEquals(StringUtils.replaceEachRepeatedly("", new String[]{"a"}, new String[]{"b"}),""); [EOL]         assertEquals(StringUtils.replaceEachRepeatedly("aba", null, null),"aba"); [EOL]         assertEquals(StringUtils.replaceEachRepeatedly("aba", new String[0], null),"aba"); [EOL]         assertEquals(StringUtils.replaceEachRepeatedly("aba", null, new String[0]),"aba"); [EOL]         assertEquals(StringUtils.replaceEachRepeatedly("aba", new String[0], null),"aba"); [EOL]  [EOL]         assertEquals(StringUtils.replaceEachRepeatedly("aba", new String[]{"a"}, new String[]{""}),"b"); [EOL]         assertEquals(StringUtils.replaceEachRepeatedly("aba", new String[]{null}, new String[]{"a"}),"aba"); [EOL]         assertEquals(StringUtils.replaceEachRepeatedly("abcde", new String[]{"ab", "d"}, new String[]{"w", "t"}),"wcte"); [EOL]         assertEquals(StringUtils.replaceEachRepeatedly("abcde", new String[]{"ab", "d"}, new String[]{"d", "t"}),"tcte"); [EOL]  [EOL]         try { [EOL]             StringUtils.replaceEachRepeatedly("abcde", new String[]{"ab", "d"}, new String[]{"d", "ab"}); [EOL]             fail("Should be a circular reference"); [EOL]         } catch (final IllegalStateException e) {} [EOL]  [EOL]         //JAVADOC TESTS END [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testReplace_StringStringArrayStringArray() { [EOL]         //JAVADOC TESTS START [EOL]         assertNull(StringUtils.replaceEach(null, new String[]{"a"}, new String[]{"b"})); [EOL]         assertEquals(StringUtils.replaceEach("", new String[]{"a"}, new String[]{"b"}),""); [EOL]         assertEquals(StringUtils.replaceEach("aba", null, null),"aba"); [EOL]         assertEquals(StringUtils.replaceEach("aba", new String[0], null),"aba"); [EOL]         assertEquals(StringUtils.replaceEach("aba", null, new String[0]),"aba"); [EOL]         assertEquals(StringUtils.replaceEach("aba", new String[]{"a"}, null),"aba"); [EOL]  [EOL]         assertEquals(StringUtils.replaceEach("aba", new String[]{"a"}, new String[]{""}),"b"); [EOL]         assertEquals(StringUtils.replaceEach("aba", new String[]{null}, new String[]{"a"}),"aba"); [EOL]         assertEquals(StringUtils.replaceEach("abcde", new String[]{"ab", "d"}, new String[]{"w", "t"}),"wcte"); [EOL]         assertEquals(StringUtils.replaceEach("abcde", new String[]{"ab", "d"}, new String[]{"d", "t"}),"dcte"); [EOL]         //JAVADOC TESTS END [EOL]  [EOL]         assertEquals("bcc", StringUtils.replaceEach("abc", new String[]{"a", "b"}, new String[]{"b", "c"})); [EOL]         assertEquals("q651.506bera", StringUtils.replaceEach("d216.102oren", [EOL]             new String[]{"a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n",  [EOL]                 "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "A", "B", "C", "D",  [EOL]                 "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T",  [EOL]                 "U", "V", "W", "X", "Y", "Z", "1", "2", "3", "4", "5", "6", "7", "8", "9"}, [EOL]             new String[]{"n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "a",  [EOL]                 "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "N", "O", "P", "Q",  [EOL]                 "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "A", "B", "C", "D", "E", "F", "G",  [EOL]                 "H", "I", "J", "K", "L", "M", "5", "6", "7", "8", "9", "1", "2", "3", "4"})); [EOL]  [EOL]         // Test null safety inside arrays - LANG-552 [EOL]         assertEquals(StringUtils.replaceEach("aba", new String[]{"a"}, new String[]{null}),"aba"); [EOL]         assertEquals(StringUtils.replaceEach("aba", new String[]{"a", "b"}, new String[]{"c", null}),"cbc"); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test method for 'StringUtils.replaceEachRepeatedly(String, String[], String[])' [EOL]      */ [EOL]
@Test [EOL]     public void testReplace_StringStringArrayStringArray() { [EOL]         //JAVADOC TESTS START [EOL]         assertNull(StringUtils.replaceEach(null, new String[]{"a"}, new String[]{"b"})); [EOL]         assertEquals(StringUtils.replaceEach("", new String[]{"a"}, new String[]{"b"}),""); [EOL]         assertEquals(StringUtils.replaceEach("aba", null, null),"aba"); [EOL]         assertEquals(StringUtils.replaceEach("aba", new String[0], null),"aba"); [EOL]         assertEquals(StringUtils.replaceEach("aba", null, new String[0]),"aba"); [EOL]         assertEquals(StringUtils.replaceEach("aba", new String[]{"a"}, null),"aba"); [EOL]  [EOL]         assertEquals(StringUtils.replaceEach("aba", new String[]{"a"}, new String[]{""}),"b"); [EOL]         assertEquals(StringUtils.replaceEach("aba", new String[]{null}, new String[]{"a"}),"aba"); [EOL]         assertEquals(StringUtils.replaceEach("abcde", new String[]{"ab", "d"}, new String[]{"w", "t"}),"wcte"); [EOL]         assertEquals(StringUtils.replaceEach("abcde", new String[]{"ab", "d"}, new String[]{"d", "t"}),"dcte"); [EOL]         //JAVADOC TESTS END [EOL]  [EOL]         assertEquals("bcc", StringUtils.replaceEach("abc", new String[]{"a", "b"}, new String[]{"b", "c"})); [EOL]         assertEquals("q651.506bera", StringUtils.replaceEach("d216.102oren", [EOL]             new String[]{"a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n",  [EOL]                 "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "A", "B", "C", "D",  [EOL]                 "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T",  [EOL]                 "U", "V", "W", "X", "Y", "Z", "1", "2", "3", "4", "5", "6", "7", "8", "9"}, [EOL]             new String[]{"n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "a",  [EOL]                 "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "N", "O", "P", "Q",  [EOL]                 "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "A", "B", "C", "D", "E", "F", "G",  [EOL]                 "H", "I", "J", "K", "L", "M", "5", "6", "7", "8", "9", "1", "2", "3", "4"})); [EOL]  [EOL]         // Test null safety inside arrays - LANG-552 [EOL]         assertEquals(StringUtils.replaceEach("aba", new String[]{"a"}, new String[]{null}),"aba"); [EOL]         assertEquals(StringUtils.replaceEach("aba", new String[]{"a", "b"}, new String[]{"c", null}),"cbc"); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test method for 'StringUtils.replaceEachRepeatedly(String, String[], String[])' [EOL]      */ [EOL]
@Test [EOL]     public void testReplace_StringStringArrayStringArray() { [EOL]         //JAVADOC TESTS START [EOL]         assertNull(StringUtils.replaceEach(null, new String[]{"a"}, new String[]{"b"})); [EOL]         assertEquals(StringUtils.replaceEach("", new String[]{"a"}, new String[]{"b"}),""); [EOL]         assertEquals(StringUtils.replaceEach("aba", null, null),"aba"); [EOL]         assertEquals(StringUtils.replaceEach("aba", new String[0], null),"aba"); [EOL]         assertEquals(StringUtils.replaceEach("aba", null, new String[0]),"aba"); [EOL]         assertEquals(StringUtils.replaceEach("aba", new String[]{"a"}, null),"aba"); [EOL]  [EOL]         assertEquals(StringUtils.replaceEach("aba", new String[]{"a"}, new String[]{""}),"b"); [EOL]         assertEquals(StringUtils.replaceEach("aba", new String[]{null}, new String[]{"a"}),"aba"); [EOL]         assertEquals(StringUtils.replaceEach("abcde", new String[]{"ab", "d"}, new String[]{"w", "t"}),"wcte"); [EOL]         assertEquals(StringUtils.replaceEach("abcde", new String[]{"ab", "d"}, new String[]{"d", "t"}),"dcte"); [EOL]         //JAVADOC TESTS END [EOL]  [EOL]         assertEquals("bcc", StringUtils.replaceEach("abc", new String[]{"a", "b"}, new String[]{"b", "c"})); [EOL]         assertEquals("q651.506bera", StringUtils.replaceEach("d216.102oren", [EOL]             new String[]{"a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n",  [EOL]                 "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "A", "B", "C", "D",  [EOL]                 "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T",  [EOL]                 "U", "V", "W", "X", "Y", "Z", "1", "2", "3", "4", "5", "6", "7", "8", "9"}, [EOL]             new String[]{"n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "a",  [EOL]                 "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "N", "O", "P", "Q",  [EOL]                 "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "A", "B", "C", "D", "E", "F", "G",  [EOL]                 "H", "I", "J", "K", "L", "M", "5", "6", "7", "8", "9", "1", "2", "3", "4"})); [EOL]  [EOL]         // Test null safety inside arrays - LANG-552 [EOL]         assertEquals(StringUtils.replaceEach("aba", new String[]{"a"}, new String[]{null}),"aba"); [EOL]         assertEquals(StringUtils.replaceEach("aba", new String[]{"a", "b"}, new String[]{"c", null}),"cbc"); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test method for 'StringUtils.replaceEachRepeatedly(String, String[], String[])' [EOL]      */ [EOL]
@Test [EOL]     public void testReplace_StringStringArrayStringArray() { [EOL]         //JAVADOC TESTS START [EOL]         assertNull(StringUtils.replaceEach(null, new String[]{"a"}, new String[]{"b"})); [EOL]         assertEquals(StringUtils.replaceEach("", new String[]{"a"}, new String[]{"b"}),""); [EOL]         assertEquals(StringUtils.replaceEach("aba", null, null),"aba"); [EOL]         assertEquals(StringUtils.replaceEach("aba", new String[0], null),"aba"); [EOL]         assertEquals(StringUtils.replaceEach("aba", null, new String[0]),"aba"); [EOL]         assertEquals(StringUtils.replaceEach("aba", new String[]{"a"}, null),"aba"); [EOL]  [EOL]         assertEquals(StringUtils.replaceEach("aba", new String[]{"a"}, new String[]{""}),"b"); [EOL]         assertEquals(StringUtils.replaceEach("aba", new String[]{null}, new String[]{"a"}),"aba"); [EOL]         assertEquals(StringUtils.replaceEach("abcde", new String[]{"ab", "d"}, new String[]{"w", "t"}),"wcte"); [EOL]         assertEquals(StringUtils.replaceEach("abcde", new String[]{"ab", "d"}, new String[]{"d", "t"}),"dcte"); [EOL]         //JAVADOC TESTS END [EOL]  [EOL]         assertEquals("bcc", StringUtils.replaceEach("abc", new String[]{"a", "b"}, new String[]{"b", "c"})); [EOL]         assertEquals("q651.506bera", StringUtils.replaceEach("d216.102oren", [EOL]             new String[]{"a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n",  [EOL]                 "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "A", "B", "C", "D",  [EOL]                 "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T",  [EOL]                 "U", "V", "W", "X", "Y", "Z", "1", "2", "3", "4", "5", "6", "7", "8", "9"}, [EOL]             new String[]{"n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "a",  [EOL]                 "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "N", "O", "P", "Q",  [EOL]                 "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "A", "B", "C", "D", "E", "F", "G",  [EOL]                 "H", "I", "J", "K", "L", "M", "5", "6", "7", "8", "9", "1", "2", "3", "4"})); [EOL]  [EOL]         // Test null safety inside arrays - LANG-552 [EOL]         assertEquals(StringUtils.replaceEach("aba", new String[]{"a"}, new String[]{null}),"aba"); [EOL]         assertEquals(StringUtils.replaceEach("aba", new String[]{"a", "b"}, new String[]{"c", null}),"cbc"); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test method for 'StringUtils.replaceEachRepeatedly(String, String[], String[])' [EOL]      */ [EOL]
@Test [EOL]     public void testReplace_StringStringArrayStringArray() { [EOL]         //JAVADOC TESTS START [EOL]         assertNull(StringUtils.replaceEach(null, new String[]{"a"}, new String[]{"b"})); [EOL]         assertEquals(StringUtils.replaceEach("", new String[]{"a"}, new String[]{"b"}),""); [EOL]         assertEquals(StringUtils.replaceEach("aba", null, null),"aba"); [EOL]         assertEquals(StringUtils.replaceEach("aba", new String[0], null),"aba"); [EOL]         assertEquals(StringUtils.replaceEach("aba", null, new String[0]),"aba"); [EOL]         assertEquals(StringUtils.replaceEach("aba", new String[]{"a"}, null),"aba"); [EOL]  [EOL]         assertEquals(StringUtils.replaceEach("aba", new String[]{"a"}, new String[]{""}),"b"); [EOL]         assertEquals(StringUtils.replaceEach("aba", new String[]{null}, new String[]{"a"}),"aba"); [EOL]         assertEquals(StringUtils.replaceEach("abcde", new String[]{"ab", "d"}, new String[]{"w", "t"}),"wcte"); [EOL]         assertEquals(StringUtils.replaceEach("abcde", new String[]{"ab", "d"}, new String[]{"d", "t"}),"dcte"); [EOL]         //JAVADOC TESTS END [EOL]  [EOL]         assertEquals("bcc", StringUtils.replaceEach("abc", new String[]{"a", "b"}, new String[]{"b", "c"})); [EOL]         assertEquals("q651.506bera", StringUtils.replaceEach("d216.102oren", [EOL]             new String[]{"a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n",  [EOL]                 "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "A", "B", "C", "D",  [EOL]                 "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T",  [EOL]                 "U", "V", "W", "X", "Y", "Z", "1", "2", "3", "4", "5", "6", "7", "8", "9"}, [EOL]             new String[]{"n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "a",  [EOL]                 "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "N", "O", "P", "Q",  [EOL]                 "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "A", "B", "C", "D", "E", "F", "G",  [EOL]                 "H", "I", "J", "K", "L", "M", "5", "6", "7", "8", "9", "1", "2", "3", "4"})); [EOL]  [EOL]         // Test null safety inside arrays - LANG-552 [EOL]         assertEquals(StringUtils.replaceEach("aba", new String[]{"a"}, new String[]{null}),"aba"); [EOL]         assertEquals(StringUtils.replaceEach("aba", new String[]{"a", "b"}, new String[]{"c", null}),"cbc"); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test method for 'StringUtils.replaceEachRepeatedly(String, String[], String[])' [EOL]      */ [EOL]
@Test [EOL]     public void testReplaceChars_StringStringString() { [EOL]         assertEquals(null, StringUtils.replaceChars(null, null, null)); [EOL]         assertEquals(null, StringUtils.replaceChars(null, "", null)); [EOL]         assertEquals(null, StringUtils.replaceChars(null, "a", null)); [EOL]         assertEquals(null, StringUtils.replaceChars(null, null, "")); [EOL]         assertEquals(null, StringUtils.replaceChars(null, null, "x")); [EOL]          [EOL]         assertEquals("", StringUtils.replaceChars("", null, null)); [EOL]         assertEquals("", StringUtils.replaceChars("", "", null)); [EOL]         assertEquals("", StringUtils.replaceChars("", "a", null)); [EOL]         assertEquals("", StringUtils.replaceChars("", null, "")); [EOL]         assertEquals("", StringUtils.replaceChars("", null, "x")); [EOL]  [EOL]         assertEquals("abc", StringUtils.replaceChars("abc", null, null)); [EOL]         assertEquals("abc", StringUtils.replaceChars("abc", null, "")); [EOL]         assertEquals("abc", StringUtils.replaceChars("abc", null, "x")); [EOL]          [EOL]         assertEquals("abc", StringUtils.replaceChars("abc", "", null)); [EOL]         assertEquals("abc", StringUtils.replaceChars("abc", "", "")); [EOL]         assertEquals("abc", StringUtils.replaceChars("abc", "", "x")); [EOL]          [EOL]         assertEquals("ac", StringUtils.replaceChars("abc", "b", null)); [EOL]         assertEquals("ac", StringUtils.replaceChars("abc", "b", "")); [EOL]         assertEquals("axc", StringUtils.replaceChars("abc", "b", "x")); [EOL]          [EOL]         assertEquals("ayzya", StringUtils.replaceChars("abcba", "bc", "yz")); [EOL]         assertEquals("ayya", StringUtils.replaceChars("abcba", "bc", "y")); [EOL]         assertEquals("ayzya", StringUtils.replaceChars("abcba", "bc", "yzx")); [EOL]          [EOL]         assertEquals("abcba", StringUtils.replaceChars("abcba", "z", "w")); [EOL]         assertSame("abcba", StringUtils.replaceChars("abcba", "z", "w")); [EOL]          [EOL]         // Javadoc examples: [EOL]         assertEquals("jelly", StringUtils.replaceChars("hello", "ho", "jy")); [EOL]         assertEquals("ayzya", StringUtils.replaceChars("abcba", "bc", "yz")); [EOL]         assertEquals("ayya", StringUtils.replaceChars("abcba", "bc", "y")); [EOL]         assertEquals("ayzya", StringUtils.replaceChars("abcba", "bc", "yzx")); [EOL]          [EOL]         // From http://issues.apache.org/bugzilla/show_bug.cgi?id=25454 [EOL]         assertEquals("bcc", StringUtils.replaceChars("abc", "ab", "bc")); [EOL]         assertEquals("q651.506bera", StringUtils.replaceChars("d216.102oren", [EOL]             "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ123456789", [EOL]             "nopqrstuvwxyzabcdefghijklmNOPQRSTUVWXYZABCDEFGHIJKLM567891234")); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testReplaceChars_StringStringString() { [EOL]         assertEquals(null, StringUtils.replaceChars(null, null, null)); [EOL]         assertEquals(null, StringUtils.replaceChars(null, "", null)); [EOL]         assertEquals(null, StringUtils.replaceChars(null, "a", null)); [EOL]         assertEquals(null, StringUtils.replaceChars(null, null, "")); [EOL]         assertEquals(null, StringUtils.replaceChars(null, null, "x")); [EOL]          [EOL]         assertEquals("", StringUtils.replaceChars("", null, null)); [EOL]         assertEquals("", StringUtils.replaceChars("", "", null)); [EOL]         assertEquals("", StringUtils.replaceChars("", "a", null)); [EOL]         assertEquals("", StringUtils.replaceChars("", null, "")); [EOL]         assertEquals("", StringUtils.replaceChars("", null, "x")); [EOL]  [EOL]         assertEquals("abc", StringUtils.replaceChars("abc", null, null)); [EOL]         assertEquals("abc", StringUtils.replaceChars("abc", null, "")); [EOL]         assertEquals("abc", StringUtils.replaceChars("abc", null, "x")); [EOL]          [EOL]         assertEquals("abc", StringUtils.replaceChars("abc", "", null)); [EOL]         assertEquals("abc", StringUtils.replaceChars("abc", "", "")); [EOL]         assertEquals("abc", StringUtils.replaceChars("abc", "", "x")); [EOL]          [EOL]         assertEquals("ac", StringUtils.replaceChars("abc", "b", null)); [EOL]         assertEquals("ac", StringUtils.replaceChars("abc", "b", "")); [EOL]         assertEquals("axc", StringUtils.replaceChars("abc", "b", "x")); [EOL]          [EOL]         assertEquals("ayzya", StringUtils.replaceChars("abcba", "bc", "yz")); [EOL]         assertEquals("ayya", StringUtils.replaceChars("abcba", "bc", "y")); [EOL]         assertEquals("ayzya", StringUtils.replaceChars("abcba", "bc", "yzx")); [EOL]          [EOL]         assertEquals("abcba", StringUtils.replaceChars("abcba", "z", "w")); [EOL]         assertSame("abcba", StringUtils.replaceChars("abcba", "z", "w")); [EOL]          [EOL]         // Javadoc examples: [EOL]         assertEquals("jelly", StringUtils.replaceChars("hello", "ho", "jy")); [EOL]         assertEquals("ayzya", StringUtils.replaceChars("abcba", "bc", "yz")); [EOL]         assertEquals("ayya", StringUtils.replaceChars("abcba", "bc", "y")); [EOL]         assertEquals("ayzya", StringUtils.replaceChars("abcba", "bc", "yzx")); [EOL]          [EOL]         // From http://issues.apache.org/bugzilla/show_bug.cgi?id=25454 [EOL]         assertEquals("bcc", StringUtils.replaceChars("abc", "ab", "bc")); [EOL]         assertEquals("q651.506bera", StringUtils.replaceChars("d216.102oren", [EOL]             "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ123456789", [EOL]             "nopqrstuvwxyzabcdefghijklmNOPQRSTUVWXYZABCDEFGHIJKLM567891234")); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testChomp() { [EOL]  [EOL]         final String[][] chompCases = { [EOL]             { FOO_UNCAP + "\r\n", FOO_UNCAP }, [EOL]             { FOO_UNCAP + "\n" , FOO_UNCAP }, [EOL]             { FOO_UNCAP + "\r", FOO_UNCAP }, [EOL]             { FOO_UNCAP + " \r", FOO_UNCAP + " " }, [EOL]             { FOO_UNCAP, FOO_UNCAP }, [EOL]             { FOO_UNCAP + "\n\n", FOO_UNCAP + "\n"}, [EOL]             { FOO_UNCAP + "\r\n\r\n", FOO_UNCAP + "\r\n" }, [EOL]             { "foo\nfoo", "foo\nfoo" }, [EOL]             { "foo\n\rfoo", "foo\n\rfoo" }, [EOL]             { "\n", "" }, [EOL]             { "\r", "" }, [EOL]             { "a", "a" }, [EOL]             { "\r\n", "" }, [EOL]             { "", "" }, [EOL]             { null, null }, [EOL]             { FOO_UNCAP + "\n\r", FOO_UNCAP + "\n"} [EOL]         }; [EOL]         for (final String[] chompCase : chompCases) { [EOL]             final String original = chompCase[0]; [EOL]             final String expectedResult = chompCase[1]; [EOL]             assertEquals("chomp(String) failed", [EOL]                     expectedResult, StringUtils.chomp(original)); [EOL]         } [EOL]  [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 "foo", StringUtils.chomp("foobar", "bar")); [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 "foobar", StringUtils.chomp("foobar", "baz")); [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 "foo", StringUtils.chomp("foo", "foooo")); [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 "foobar", StringUtils.chomp("foobar", "")); [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 "foobar", StringUtils.chomp("foobar", null)); [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 "", StringUtils.chomp("", "foo")); [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 "", StringUtils.chomp("", null)); [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 "", StringUtils.chomp("", "")); [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 null, StringUtils.chomp(null, "foo")); [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 null, StringUtils.chomp(null, null)); [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 null, StringUtils.chomp(null, "")); [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 "", StringUtils.chomp("foo", "foo")); [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 " ", StringUtils.chomp(" foo", "foo")); [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 "foo ", StringUtils.chomp("foo ", "foo")); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testChomp() { [EOL]  [EOL]         final String[][] chompCases = { [EOL]             { FOO_UNCAP + "\r\n", FOO_UNCAP }, [EOL]             { FOO_UNCAP + "\n" , FOO_UNCAP }, [EOL]             { FOO_UNCAP + "\r", FOO_UNCAP }, [EOL]             { FOO_UNCAP + " \r", FOO_UNCAP + " " }, [EOL]             { FOO_UNCAP, FOO_UNCAP }, [EOL]             { FOO_UNCAP + "\n\n", FOO_UNCAP + "\n"}, [EOL]             { FOO_UNCAP + "\r\n\r\n", FOO_UNCAP + "\r\n" }, [EOL]             { "foo\nfoo", "foo\nfoo" }, [EOL]             { "foo\n\rfoo", "foo\n\rfoo" }, [EOL]             { "\n", "" }, [EOL]             { "\r", "" }, [EOL]             { "a", "a" }, [EOL]             { "\r\n", "" }, [EOL]             { "", "" }, [EOL]             { null, null }, [EOL]             { FOO_UNCAP + "\n\r", FOO_UNCAP + "\n"} [EOL]         }; [EOL]         for (final String[] chompCase : chompCases) { [EOL]             final String original = chompCase[0]; [EOL]             final String expectedResult = chompCase[1]; [EOL]             assertEquals("chomp(String) failed", [EOL]                     expectedResult, StringUtils.chomp(original)); [EOL]         } [EOL]  [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 "foo", StringUtils.chomp("foobar", "bar")); [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 "foobar", StringUtils.chomp("foobar", "baz")); [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 "foo", StringUtils.chomp("foo", "foooo")); [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 "foobar", StringUtils.chomp("foobar", "")); [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 "foobar", StringUtils.chomp("foobar", null)); [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 "", StringUtils.chomp("", "foo")); [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 "", StringUtils.chomp("", null)); [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 "", StringUtils.chomp("", "")); [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 null, StringUtils.chomp(null, "foo")); [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 null, StringUtils.chomp(null, null)); [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 null, StringUtils.chomp(null, "")); [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 "", StringUtils.chomp("foo", "foo")); [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 " ", StringUtils.chomp(" foo", "foo")); [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 "foo ", StringUtils.chomp("foo ", "foo")); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testChomp() { [EOL]  [EOL]         final String[][] chompCases = { [EOL]             { FOO_UNCAP + "\r\n", FOO_UNCAP }, [EOL]             { FOO_UNCAP + "\n" , FOO_UNCAP }, [EOL]             { FOO_UNCAP + "\r", FOO_UNCAP }, [EOL]             { FOO_UNCAP + " \r", FOO_UNCAP + " " }, [EOL]             { FOO_UNCAP, FOO_UNCAP }, [EOL]             { FOO_UNCAP + "\n\n", FOO_UNCAP + "\n"}, [EOL]             { FOO_UNCAP + "\r\n\r\n", FOO_UNCAP + "\r\n" }, [EOL]             { "foo\nfoo", "foo\nfoo" }, [EOL]             { "foo\n\rfoo", "foo\n\rfoo" }, [EOL]             { "\n", "" }, [EOL]             { "\r", "" }, [EOL]             { "a", "a" }, [EOL]             { "\r\n", "" }, [EOL]             { "", "" }, [EOL]             { null, null }, [EOL]             { FOO_UNCAP + "\n\r", FOO_UNCAP + "\n"} [EOL]         }; [EOL]         for (final String[] chompCase : chompCases) { [EOL]             final String original = chompCase[0]; [EOL]             final String expectedResult = chompCase[1]; [EOL]             assertEquals("chomp(String) failed", [EOL]                     expectedResult, StringUtils.chomp(original)); [EOL]         } [EOL]  [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 "foo", StringUtils.chomp("foobar", "bar")); [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 "foobar", StringUtils.chomp("foobar", "baz")); [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 "foo", StringUtils.chomp("foo", "foooo")); [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 "foobar", StringUtils.chomp("foobar", "")); [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 "foobar", StringUtils.chomp("foobar", null)); [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 "", StringUtils.chomp("", "foo")); [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 "", StringUtils.chomp("", null)); [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 "", StringUtils.chomp("", "")); [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 null, StringUtils.chomp(null, "foo")); [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 null, StringUtils.chomp(null, null)); [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 null, StringUtils.chomp(null, "")); [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 "", StringUtils.chomp("foo", "foo")); [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 " ", StringUtils.chomp(" foo", "foo")); [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 "foo ", StringUtils.chomp("foo ", "foo")); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testChomp() { [EOL]  [EOL]         final String[][] chompCases = { [EOL]             { FOO_UNCAP + "\r\n", FOO_UNCAP }, [EOL]             { FOO_UNCAP + "\n" , FOO_UNCAP }, [EOL]             { FOO_UNCAP + "\r", FOO_UNCAP }, [EOL]             { FOO_UNCAP + " \r", FOO_UNCAP + " " }, [EOL]             { FOO_UNCAP, FOO_UNCAP }, [EOL]             { FOO_UNCAP + "\n\n", FOO_UNCAP + "\n"}, [EOL]             { FOO_UNCAP + "\r\n\r\n", FOO_UNCAP + "\r\n" }, [EOL]             { "foo\nfoo", "foo\nfoo" }, [EOL]             { "foo\n\rfoo", "foo\n\rfoo" }, [EOL]             { "\n", "" }, [EOL]             { "\r", "" }, [EOL]             { "a", "a" }, [EOL]             { "\r\n", "" }, [EOL]             { "", "" }, [EOL]             { null, null }, [EOL]             { FOO_UNCAP + "\n\r", FOO_UNCAP + "\n"} [EOL]         }; [EOL]         for (final String[] chompCase : chompCases) { [EOL]             final String original = chompCase[0]; [EOL]             final String expectedResult = chompCase[1]; [EOL]             assertEquals("chomp(String) failed", [EOL]                     expectedResult, StringUtils.chomp(original)); [EOL]         } [EOL]  [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 "foo", StringUtils.chomp("foobar", "bar")); [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 "foobar", StringUtils.chomp("foobar", "baz")); [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 "foo", StringUtils.chomp("foo", "foooo")); [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 "foobar", StringUtils.chomp("foobar", "")); [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 "foobar", StringUtils.chomp("foobar", null)); [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 "", StringUtils.chomp("", "foo")); [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 "", StringUtils.chomp("", null)); [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 "", StringUtils.chomp("", "")); [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 null, StringUtils.chomp(null, "foo")); [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 null, StringUtils.chomp(null, null)); [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 null, StringUtils.chomp(null, "")); [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 "", StringUtils.chomp("foo", "foo")); [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 " ", StringUtils.chomp(" foo", "foo")); [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 "foo ", StringUtils.chomp("foo ", "foo")); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testChomp() { [EOL]  [EOL]         final String[][] chompCases = { [EOL]             { FOO_UNCAP + "\r\n", FOO_UNCAP }, [EOL]             { FOO_UNCAP + "\n" , FOO_UNCAP }, [EOL]             { FOO_UNCAP + "\r", FOO_UNCAP }, [EOL]             { FOO_UNCAP + " \r", FOO_UNCAP + " " }, [EOL]             { FOO_UNCAP, FOO_UNCAP }, [EOL]             { FOO_UNCAP + "\n\n", FOO_UNCAP + "\n"}, [EOL]             { FOO_UNCAP + "\r\n\r\n", FOO_UNCAP + "\r\n" }, [EOL]             { "foo\nfoo", "foo\nfoo" }, [EOL]             { "foo\n\rfoo", "foo\n\rfoo" }, [EOL]             { "\n", "" }, [EOL]             { "\r", "" }, [EOL]             { "a", "a" }, [EOL]             { "\r\n", "" }, [EOL]             { "", "" }, [EOL]             { null, null }, [EOL]             { FOO_UNCAP + "\n\r", FOO_UNCAP + "\n"} [EOL]         }; [EOL]         for (final String[] chompCase : chompCases) { [EOL]             final String original = chompCase[0]; [EOL]             final String expectedResult = chompCase[1]; [EOL]             assertEquals("chomp(String) failed", [EOL]                     expectedResult, StringUtils.chomp(original)); [EOL]         } [EOL]  [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 "foo", StringUtils.chomp("foobar", "bar")); [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 "foobar", StringUtils.chomp("foobar", "baz")); [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 "foo", StringUtils.chomp("foo", "foooo")); [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 "foobar", StringUtils.chomp("foobar", "")); [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 "foobar", StringUtils.chomp("foobar", null)); [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 "", StringUtils.chomp("", "foo")); [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 "", StringUtils.chomp("", null)); [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 "", StringUtils.chomp("", "")); [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 null, StringUtils.chomp(null, "foo")); [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 null, StringUtils.chomp(null, null)); [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 null, StringUtils.chomp(null, "")); [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 "", StringUtils.chomp("foo", "foo")); [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 " ", StringUtils.chomp(" foo", "foo")); [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 "foo ", StringUtils.chomp("foo ", "foo")); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testChomp() { [EOL]  [EOL]         final String[][] chompCases = { [EOL]             { FOO_UNCAP + "\r\n", FOO_UNCAP }, [EOL]             { FOO_UNCAP + "\n" , FOO_UNCAP }, [EOL]             { FOO_UNCAP + "\r", FOO_UNCAP }, [EOL]             { FOO_UNCAP + " \r", FOO_UNCAP + " " }, [EOL]             { FOO_UNCAP, FOO_UNCAP }, [EOL]             { FOO_UNCAP + "\n\n", FOO_UNCAP + "\n"}, [EOL]             { FOO_UNCAP + "\r\n\r\n", FOO_UNCAP + "\r\n" }, [EOL]             { "foo\nfoo", "foo\nfoo" }, [EOL]             { "foo\n\rfoo", "foo\n\rfoo" }, [EOL]             { "\n", "" }, [EOL]             { "\r", "" }, [EOL]             { "a", "a" }, [EOL]             { "\r\n", "" }, [EOL]             { "", "" }, [EOL]             { null, null }, [EOL]             { FOO_UNCAP + "\n\r", FOO_UNCAP + "\n"} [EOL]         }; [EOL]         for (final String[] chompCase : chompCases) { [EOL]             final String original = chompCase[0]; [EOL]             final String expectedResult = chompCase[1]; [EOL]             assertEquals("chomp(String) failed", [EOL]                     expectedResult, StringUtils.chomp(original)); [EOL]         } [EOL]  [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 "foo", StringUtils.chomp("foobar", "bar")); [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 "foobar", StringUtils.chomp("foobar", "baz")); [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 "foo", StringUtils.chomp("foo", "foooo")); [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 "foobar", StringUtils.chomp("foobar", "")); [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 "foobar", StringUtils.chomp("foobar", null)); [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 "", StringUtils.chomp("", "foo")); [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 "", StringUtils.chomp("", null)); [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 "", StringUtils.chomp("", "")); [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 null, StringUtils.chomp(null, "foo")); [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 null, StringUtils.chomp(null, null)); [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 null, StringUtils.chomp(null, "")); [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 "", StringUtils.chomp("foo", "foo")); [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 " ", StringUtils.chomp(" foo", "foo")); [EOL]         assertEquals("chomp(String, String) failed", [EOL]                 "foo ", StringUtils.chomp("foo ", "foo")); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testChop() { [EOL]  [EOL]         final String[][] chopCases = { [EOL]             { FOO_UNCAP + "\r\n", FOO_UNCAP } , [EOL]             { FOO_UNCAP + "\n" , FOO_UNCAP } , [EOL]             { FOO_UNCAP + "\r", FOO_UNCAP }, [EOL]             { FOO_UNCAP + " \r", FOO_UNCAP + " " }, [EOL]             { "foo", "fo"}, [EOL]             { "foo\nfoo", "foo\nfo" }, [EOL]             { "\n", "" }, [EOL]             { "\r", "" }, [EOL]             { "\r\n", "" }, [EOL]             { null, null }, [EOL]             { "", "" }, [EOL]             { "a", "" }, [EOL]         }; [EOL]         for (final String[] chopCase : chopCases) { [EOL]             final String original = chopCase[0]; [EOL]             final String expectedResult = chopCase[1]; [EOL]             assertEquals("chop(String) failed", [EOL]                     expectedResult, StringUtils.chop(original)); [EOL]         } [EOL]     } [EOL]  [EOL]     @SuppressWarnings("deprecation") // intentional test of deprecated method [EOL]
@Test [EOL]     public void testRepeat_StringInt() { [EOL]         assertEquals(null, StringUtils.repeat(null, 2)); [EOL]         assertEquals("", StringUtils.repeat("ab", 0)); [EOL]         assertEquals("", StringUtils.repeat("", 3)); [EOL]         assertEquals("aaa", StringUtils.repeat("a", 3)); [EOL]         assertEquals("ababab", StringUtils.repeat("ab", 3)); [EOL]         assertEquals("abcabcabc", StringUtils.repeat("abc", 3)); [EOL]         final String str = StringUtils.repeat("a", 10000);  // bigger than pad limit [EOL]         assertEquals(10000, str.length()); [EOL]         assertTrue(StringUtils.containsOnly(str, new char[] {'a'})); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testRepeat_StringInt() { [EOL]         assertEquals(null, StringUtils.repeat(null, 2)); [EOL]         assertEquals("", StringUtils.repeat("ab", 0)); [EOL]         assertEquals("", StringUtils.repeat("", 3)); [EOL]         assertEquals("aaa", StringUtils.repeat("a", 3)); [EOL]         assertEquals("ababab", StringUtils.repeat("ab", 3)); [EOL]         assertEquals("abcabcabc", StringUtils.repeat("abc", 3)); [EOL]         final String str = StringUtils.repeat("a", 10000);  // bigger than pad limit [EOL]         assertEquals(10000, str.length()); [EOL]         assertTrue(StringUtils.containsOnly(str, new char[] {'a'})); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testRepeat_StringInt() { [EOL]         assertEquals(null, StringUtils.repeat(null, 2)); [EOL]         assertEquals("", StringUtils.repeat("ab", 0)); [EOL]         assertEquals("", StringUtils.repeat("", 3)); [EOL]         assertEquals("aaa", StringUtils.repeat("a", 3)); [EOL]         assertEquals("ababab", StringUtils.repeat("ab", 3)); [EOL]         assertEquals("abcabcabc", StringUtils.repeat("abc", 3)); [EOL]         final String str = StringUtils.repeat("a", 10000);  // bigger than pad limit [EOL]         assertEquals(10000, str.length()); [EOL]         assertTrue(StringUtils.containsOnly(str, new char[] {'a'})); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testRightPad_StringIntChar() { [EOL]         assertEquals(null, StringUtils.rightPad(null, 5, ' ')); [EOL]         assertEquals("     ", StringUtils.rightPad("", 5, ' ')); [EOL]         assertEquals("abc  ", StringUtils.rightPad("abc", 5, ' ')); [EOL]         assertEquals("abc", StringUtils.rightPad("abc", 2, ' ')); [EOL]         assertEquals("abc", StringUtils.rightPad("abc", -1, ' ')); [EOL]         assertEquals("abcxx", StringUtils.rightPad("abc", 5, 'x')); [EOL]         final String str = StringUtils.rightPad("aaa", 10000, 'a');  // bigger than pad length [EOL]         assertEquals(10000, str.length()); [EOL]         assertTrue(StringUtils.containsOnly(str, new char[] {'a'})); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testRightPad_StringIntString() { [EOL]         assertEquals(null, StringUtils.rightPad(null, 5, "-+")); [EOL]         assertEquals("     ", StringUtils.rightPad("", 5, " ")); [EOL]         assertEquals(null, StringUtils.rightPad(null, 8, null)); [EOL]         assertEquals("abc-+-+", StringUtils.rightPad("abc", 7, "-+")); [EOL]         assertEquals("abc-+~", StringUtils.rightPad("abc", 6, "-+~")); [EOL]         assertEquals("abc-+", StringUtils.rightPad("abc", 5, "-+~")); [EOL]         assertEquals("abc", StringUtils.rightPad("abc", 2, " ")); [EOL]         assertEquals("abc", StringUtils.rightPad("abc", -1, " ")); [EOL]         assertEquals("abc  ", StringUtils.rightPad("abc", 5, null)); [EOL]         assertEquals("abc  ", StringUtils.rightPad("abc", 5, "")); [EOL]     } [EOL]          [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testCenter_StringIntString() { [EOL]         assertEquals(null, StringUtils.center(null, 4, null)); [EOL]         assertEquals(null, StringUtils.center(null, -1, " ")); [EOL]         assertEquals(null, StringUtils.center(null, 4, " ")); [EOL]         assertEquals("    ", StringUtils.center("", 4, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 0, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", -1, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 1, " ")); [EOL]         assertEquals("    ", StringUtils.center("", 4, " ")); [EOL]         assertEquals(" ab ", StringUtils.center("ab", 4, " ")); [EOL]         assertEquals("abcd", StringUtils.center("abcd", 2, " ")); [EOL]         assertEquals(" a  ", StringUtils.center("a", 4, " ")); [EOL]         assertEquals("yayz", StringUtils.center("a", 4, "yz")); [EOL]         assertEquals("yzyayzy", StringUtils.center("a", 7, "yz")); [EOL]         assertEquals("  abc  ", StringUtils.center("abc", 7, null)); [EOL]         assertEquals("  abc  ", StringUtils.center("abc", 7, "")); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testLeftPad_StringIntChar() { [EOL]         assertEquals(null, StringUtils.leftPad(null, 5, ' ')); [EOL]         assertEquals("     ", StringUtils.leftPad("", 5, ' ')); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 5, ' ')); [EOL]         assertEquals("xxabc", StringUtils.leftPad("abc", 5, 'x')); [EOL]         assertEquals("\uffff\uffffabc", StringUtils.leftPad("abc", 5, '\uffff')); [EOL]         assertEquals("abc", StringUtils.leftPad("abc", 2, ' ')); [EOL]         final String str = StringUtils.leftPad("aaa", 10000, 'a');  // bigger than pad length [EOL]         assertEquals(10000, str.length()); [EOL]         assertTrue(StringUtils.containsOnly(str, new char[] {'a'})); [EOL]     } [EOL]          [EOL]
@Test [EOL]     public void testLeftPad_StringIntString() { [EOL]         assertEquals(null, StringUtils.leftPad(null, 5, "-+")); [EOL]         assertEquals(null, StringUtils.leftPad(null, 5, null)); [EOL]         assertEquals("     ", StringUtils.leftPad("", 5, " ")); [EOL]         assertEquals("-+-+abc", StringUtils.leftPad("abc", 7, "-+")); [EOL]         assertEquals("-+~abc", StringUtils.leftPad("abc", 6, "-+~")); [EOL]         assertEquals("-+abc", StringUtils.leftPad("abc", 5, "-+~")); [EOL]         assertEquals("abc", StringUtils.leftPad("abc", 2, " ")); [EOL]         assertEquals("abc", StringUtils.leftPad("abc", -1, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 5, null)); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 5, "")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testCenter_StringIntString() { [EOL]         assertEquals(null, StringUtils.center(null, 4, null)); [EOL]         assertEquals(null, StringUtils.center(null, -1, " ")); [EOL]         assertEquals(null, StringUtils.center(null, 4, " ")); [EOL]         assertEquals("    ", StringUtils.center("", 4, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 0, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", -1, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 1, " ")); [EOL]         assertEquals("    ", StringUtils.center("", 4, " ")); [EOL]         assertEquals(" ab ", StringUtils.center("ab", 4, " ")); [EOL]         assertEquals("abcd", StringUtils.center("abcd", 2, " ")); [EOL]         assertEquals(" a  ", StringUtils.center("a", 4, " ")); [EOL]         assertEquals("yayz", StringUtils.center("a", 4, "yz")); [EOL]         assertEquals("yzyayzy", StringUtils.center("a", 7, "yz")); [EOL]         assertEquals("  abc  ", StringUtils.center("abc", 7, null)); [EOL]         assertEquals("  abc  ", StringUtils.center("abc", 7, "")); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testIsAlpha() { [EOL]         assertFalse(StringUtils.isAlpha(null)); [EOL]         assertFalse(StringUtils.isAlpha("")); [EOL]         assertFalse(StringUtils.isAlpha(" ")); [EOL]         assertTrue(StringUtils.isAlpha("a")); [EOL]         assertTrue(StringUtils.isAlpha("A")); [EOL]         assertTrue(StringUtils.isAlpha("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); [EOL]         assertFalse(StringUtils.isAlpha("ham kso")); [EOL]         assertFalse(StringUtils.isAlpha("1")); [EOL]         assertFalse(StringUtils.isAlpha("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); [EOL]         assertFalse(StringUtils.isAlpha("_")); [EOL]         assertFalse(StringUtils.isAlpha("hkHKHik*khbkuh")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsAlphaspace() { [EOL]         assertFalse(StringUtils.isAlphaSpace(null)); [EOL]         assertTrue(StringUtils.isAlphaSpace("")); [EOL]         assertTrue(StringUtils.isAlphaSpace(" ")); [EOL]         assertTrue(StringUtils.isAlphaSpace("a")); [EOL]         assertTrue(StringUtils.isAlphaSpace("A")); [EOL]         assertTrue(StringUtils.isAlphaSpace("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); [EOL]         assertTrue(StringUtils.isAlphaSpace("ham kso")); [EOL]         assertFalse(StringUtils.isAlphaSpace("1")); [EOL]         assertFalse(StringUtils.isAlphaSpace("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); [EOL]         assertFalse(StringUtils.isAlphaSpace("_")); [EOL]         assertFalse(StringUtils.isAlphaSpace("hkHKHik*khbkuh")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsAlphanumeric() { [EOL]         assertFalse(StringUtils.isAlphanumeric(null)); [EOL]         assertFalse(StringUtils.isAlphanumeric("")); [EOL]         assertFalse(StringUtils.isAlphanumeric(" ")); [EOL]         assertTrue(StringUtils.isAlphanumeric("a")); [EOL]         assertTrue(StringUtils.isAlphanumeric("A")); [EOL]         assertTrue(StringUtils.isAlphanumeric("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); [EOL]         assertFalse(StringUtils.isAlphanumeric("ham kso")); [EOL]         assertTrue(StringUtils.isAlphanumeric("1")); [EOL]         assertTrue(StringUtils.isAlphanumeric("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); [EOL]         assertFalse(StringUtils.isAlphanumeric("_")); [EOL]         assertFalse(StringUtils.isAlphanumeric("hkHKHik*khbkuh")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsAsciiPrintable_String() { [EOL]         assertFalse(StringUtils.isAsciiPrintable(null)); [EOL]         assertTrue(StringUtils.isAsciiPrintable("")); [EOL]         assertTrue(StringUtils.isAsciiPrintable(" ")); [EOL]         assertTrue(StringUtils.isAsciiPrintable("a")); [EOL]         assertTrue(StringUtils.isAsciiPrintable("A")); [EOL]         assertTrue(StringUtils.isAsciiPrintable("1")); [EOL]         assertTrue(StringUtils.isAsciiPrintable("Ceki")); [EOL]         assertTrue(StringUtils.isAsciiPrintable("!ab2c~")); [EOL]         assertTrue(StringUtils.isAsciiPrintable("1000")); [EOL]         assertTrue(StringUtils.isAsciiPrintable("10 00")); [EOL]         assertFalse(StringUtils.isAsciiPrintable("10\t00")); [EOL]         assertTrue(StringUtils.isAsciiPrintable("10.00")); [EOL]         assertTrue(StringUtils.isAsciiPrintable("10,00")); [EOL]         assertTrue(StringUtils.isAsciiPrintable("!ab-c~")); [EOL]         assertTrue(StringUtils.isAsciiPrintable("hkHK=Hik6i?UGH_KJgU7.tUJgKJ*GI87GI,kug")); [EOL]         assertTrue(StringUtils.isAsciiPrintable("\u0020")); [EOL]         assertTrue(StringUtils.isAsciiPrintable("\u0021")); [EOL]         assertTrue(StringUtils.isAsciiPrintable("\u007e")); [EOL]         assertFalse(StringUtils.isAsciiPrintable("\u007f")); [EOL]         assertTrue(StringUtils.isAsciiPrintable("G?lc?")); [EOL]         assertTrue(StringUtils.isAsciiPrintable("=?iso-8859-1?Q?G=FClc=FC?=")); [EOL]         assertFalse(StringUtils.isAsciiPrintable("G\u00fclc\u00fc")); [EOL]     } [EOL]    [EOL]
@Test [EOL]     public void testIsNumeric() { [EOL]         assertFalse(StringUtils.isNumeric(null)); [EOL]         assertFalse(StringUtils.isNumeric("")); [EOL]         assertFalse(StringUtils.isNumeric(" ")); [EOL]         assertFalse(StringUtils.isNumeric("a")); [EOL]         assertFalse(StringUtils.isNumeric("A")); [EOL]         assertFalse(StringUtils.isNumeric("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); [EOL]         assertFalse(StringUtils.isNumeric("ham kso")); [EOL]         assertTrue(StringUtils.isNumeric("1")); [EOL]         assertTrue(StringUtils.isNumeric("1000")); [EOL]         assertFalse(StringUtils.isNumeric("2.3")); [EOL]         assertFalse(StringUtils.isNumeric("10 00")); [EOL]         assertFalse(StringUtils.isNumeric("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); [EOL]         assertFalse(StringUtils.isNumeric("_")); [EOL]         assertFalse(StringUtils.isNumeric("hkHKHik*khbkuh")); [EOL]         assertFalse(StringUtils.isNumeric("+123")); [EOL]         assertFalse(StringUtils.isNumeric("-123")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsAllLowerCase() { [EOL]         assertFalse(StringUtils.isAllLowerCase(null)); [EOL]         assertFalse(StringUtils.isAllLowerCase(StringUtils.EMPTY)); [EOL]         assertTrue(StringUtils.isAllLowerCase("abc")); [EOL]         assertFalse(StringUtils.isAllLowerCase("abc ")); [EOL]         assertFalse(StringUtils.isAllLowerCase("abC")); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test for {@link StringUtils#isAllUpperCase(CharSequence)}. [EOL]      */ [EOL]
@Test [EOL]     public void testIsAllUpperCase() { [EOL]         assertFalse(StringUtils.isAllUpperCase(null)); [EOL]         assertFalse(StringUtils.isAllUpperCase(StringUtils.EMPTY)); [EOL]         assertTrue(StringUtils.isAllUpperCase("ABC")); [EOL]         assertFalse(StringUtils.isAllUpperCase("ABC ")); [EOL]         assertFalse(StringUtils.isAllUpperCase("aBC")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testAbbreviate_StringIntInt() { [EOL]         assertEquals(null, StringUtils.abbreviate(null, 10, 12)); [EOL]         assertEquals("", StringUtils.abbreviate("", 0, 10)); [EOL]         assertEquals("", StringUtils.abbreviate("", 2, 10)); [EOL]          [EOL]         try { [EOL]             @SuppressWarnings("unused") [EOL]             final [EOL]             String res = StringUtils.abbreviate("abcdefghij", 0, 3); [EOL]             fail("StringUtils.abbreviate expecting IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException ex) { [EOL]                 // empty [EOL]         }       [EOL]         try { [EOL]             @SuppressWarnings("unused") [EOL]             final [EOL]             String res = StringUtils.abbreviate("abcdefghij", 5, 6); [EOL]             fail("StringUtils.abbreviate expecting IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException ex) { [EOL]                 // empty [EOL]         }       [EOL]          [EOL]  [EOL]         final String raspberry = "raspberry peach"; [EOL]         assertEquals("raspberry peach", StringUtils.abbreviate(raspberry, 11, 15)); [EOL]  [EOL]         assertEquals(null, StringUtils.abbreviate(null, 7, 14)); [EOL]         assertAbbreviateWithOffset("abcdefg...", -1, 10); [EOL]         assertAbbreviateWithOffset("abcdefg...", 0, 10); [EOL]         assertAbbreviateWithOffset("abcdefg...", 1, 10); [EOL]         assertAbbreviateWithOffset("abcdefg...", 2, 10); [EOL]         assertAbbreviateWithOffset("abcdefg...", 3, 10); [EOL]         assertAbbreviateWithOffset("abcdefg...", 4, 10); [EOL]         assertAbbreviateWithOffset("...fghi...", 5, 10); [EOL]         assertAbbreviateWithOffset("...ghij...", 6, 10); [EOL]         assertAbbreviateWithOffset("...hijk...", 7, 10); [EOL]         assertAbbreviateWithOffset("...ijklmno", 8, 10); [EOL]         assertAbbreviateWithOffset("...ijklmno", 9, 10); [EOL]         assertAbbreviateWithOffset("...ijklmno", 10, 10); [EOL]         assertAbbreviateWithOffset("...ijklmno", 10, 10); [EOL]         assertAbbreviateWithOffset("...ijklmno", 11, 10); [EOL]         assertAbbreviateWithOffset("...ijklmno", 12, 10); [EOL]         assertAbbreviateWithOffset("...ijklmno", 13, 10); [EOL]         assertAbbreviateWithOffset("...ijklmno", 14, 10); [EOL]         assertAbbreviateWithOffset("...ijklmno", 15, 10); [EOL]         assertAbbreviateWithOffset("...ijklmno", 16, 10); [EOL]         assertAbbreviateWithOffset("...ijklmno", Integer.MAX_VALUE, 10); [EOL]     } [EOL]  [EOL]     private void assertAbbreviateWithOffset(final String expected, final int offset, final int maxWidth) { [EOL]         final String abcdefghijklmno = "abcdefghijklmno"; [EOL]         final String message = "abbreviate(String,int,int) failed"; [EOL]         final String actual = StringUtils.abbreviate(abcdefghijklmno, offset, maxWidth); [EOL]         if (offset >= 0 && offset < abcdefghijklmno.length()) { [EOL]             assertTrue(message + " -- should contain offset character", [EOL]                     actual.indexOf((char)('a'+offset)) != -1); [EOL]         } [EOL]         assertTrue(message + " -- should not be greater than maxWidth", [EOL]                 actual.length() <= maxWidth); [EOL]         assertEquals(message, expected, actual); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testAbbreviateMiddle() { [EOL]         // javadoc examples [EOL]         assertNull( StringUtils.abbreviateMiddle(null, null, 0) ); [EOL]         assertEquals( "abc", StringUtils.abbreviateMiddle("abc", null, 0) ); [EOL]         assertEquals( "abc", StringUtils.abbreviateMiddle("abc", ".", 0) ); [EOL]         assertEquals( "abc", StringUtils.abbreviateMiddle("abc", ".", 3) ); [EOL]         assertEquals( "ab.f", StringUtils.abbreviateMiddle("abcdef", ".", 4) ); [EOL]  [EOL]         // JIRA issue (LANG-405) example (slightly different than actual expected result) [EOL]         assertEquals(  [EOL]             "A very long text with un...f the text is complete.", [EOL]             StringUtils.abbreviateMiddle( [EOL]                 "A very long text with unimportant stuff in the middle but interesting start and " + [EOL]                 "end to see if the text is complete.", "...", 50) ); [EOL]  [EOL]         // Test a much longer text :) [EOL]         final String longText = "Start text" + StringUtils.repeat("x", 10000) + "Close text"; [EOL]         assertEquals(  [EOL]             "Start text->Close text", [EOL]             StringUtils.abbreviateMiddle( longText, "->", 22 ) ); [EOL]  [EOL]         // Test negative length [EOL]         assertEquals("abc", StringUtils.abbreviateMiddle("abc", ".", -1)); [EOL]  [EOL]         // Test boundaries [EOL]         // Fails to change anything as method ensures first and last char are kept [EOL]         assertEquals("abc", StringUtils.abbreviateMiddle("abc", ".", 1)); [EOL]         assertEquals("abc", StringUtils.abbreviateMiddle("abc", ".", 2)); [EOL]  [EOL]         // Test length of n=1 [EOL]         assertEquals("a", StringUtils.abbreviateMiddle("a", ".", 1)); [EOL]  [EOL]         // Test smallest length that can lead to success [EOL]         assertEquals("a.d", StringUtils.abbreviateMiddle("abcd", ".", 3)); [EOL]  [EOL]         // More from LANG-405 [EOL]         assertEquals("a..f", StringUtils.abbreviateMiddle("abcdef", "..", 4)); [EOL]         assertEquals("ab.ef", StringUtils.abbreviateMiddle("abcdef", ".", 5)); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAbbreviateMiddle() { [EOL]         // javadoc examples [EOL]         assertNull( StringUtils.abbreviateMiddle(null, null, 0) ); [EOL]         assertEquals( "abc", StringUtils.abbreviateMiddle("abc", null, 0) ); [EOL]         assertEquals( "abc", StringUtils.abbreviateMiddle("abc", ".", 0) ); [EOL]         assertEquals( "abc", StringUtils.abbreviateMiddle("abc", ".", 3) ); [EOL]         assertEquals( "ab.f", StringUtils.abbreviateMiddle("abcdef", ".", 4) ); [EOL]  [EOL]         // JIRA issue (LANG-405) example (slightly different than actual expected result) [EOL]         assertEquals(  [EOL]             "A very long text with un...f the text is complete.", [EOL]             StringUtils.abbreviateMiddle( [EOL]                 "A very long text with unimportant stuff in the middle but interesting start and " + [EOL]                 "end to see if the text is complete.", "...", 50) ); [EOL]  [EOL]         // Test a much longer text :) [EOL]         final String longText = "Start text" + StringUtils.repeat("x", 10000) + "Close text"; [EOL]         assertEquals(  [EOL]             "Start text->Close text", [EOL]             StringUtils.abbreviateMiddle( longText, "->", 22 ) ); [EOL]  [EOL]         // Test negative length [EOL]         assertEquals("abc", StringUtils.abbreviateMiddle("abc", ".", -1)); [EOL]  [EOL]         // Test boundaries [EOL]         // Fails to change anything as method ensures first and last char are kept [EOL]         assertEquals("abc", StringUtils.abbreviateMiddle("abc", ".", 1)); [EOL]         assertEquals("abc", StringUtils.abbreviateMiddle("abc", ".", 2)); [EOL]  [EOL]         // Test length of n=1 [EOL]         assertEquals("a", StringUtils.abbreviateMiddle("a", ".", 1)); [EOL]  [EOL]         // Test smallest length that can lead to success [EOL]         assertEquals("a.d", StringUtils.abbreviateMiddle("abcd", ".", 3)); [EOL]  [EOL]         // More from LANG-405 [EOL]         assertEquals("a..f", StringUtils.abbreviateMiddle("abcdef", "..", 4)); [EOL]         assertEquals("ab.ef", StringUtils.abbreviateMiddle("abcdef", ".", 5)); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAbbreviateMiddle() { [EOL]         // javadoc examples [EOL]         assertNull( StringUtils.abbreviateMiddle(null, null, 0) ); [EOL]         assertEquals( "abc", StringUtils.abbreviateMiddle("abc", null, 0) ); [EOL]         assertEquals( "abc", StringUtils.abbreviateMiddle("abc", ".", 0) ); [EOL]         assertEquals( "abc", StringUtils.abbreviateMiddle("abc", ".", 3) ); [EOL]         assertEquals( "ab.f", StringUtils.abbreviateMiddle("abcdef", ".", 4) ); [EOL]  [EOL]         // JIRA issue (LANG-405) example (slightly different than actual expected result) [EOL]         assertEquals(  [EOL]             "A very long text with un...f the text is complete.", [EOL]             StringUtils.abbreviateMiddle( [EOL]                 "A very long text with unimportant stuff in the middle but interesting start and " + [EOL]                 "end to see if the text is complete.", "...", 50) ); [EOL]  [EOL]         // Test a much longer text :) [EOL]         final String longText = "Start text" + StringUtils.repeat("x", 10000) + "Close text"; [EOL]         assertEquals(  [EOL]             "Start text->Close text", [EOL]             StringUtils.abbreviateMiddle( longText, "->", 22 ) ); [EOL]  [EOL]         // Test negative length [EOL]         assertEquals("abc", StringUtils.abbreviateMiddle("abc", ".", -1)); [EOL]  [EOL]         // Test boundaries [EOL]         // Fails to change anything as method ensures first and last char are kept [EOL]         assertEquals("abc", StringUtils.abbreviateMiddle("abc", ".", 1)); [EOL]         assertEquals("abc", StringUtils.abbreviateMiddle("abc", ".", 2)); [EOL]  [EOL]         // Test length of n=1 [EOL]         assertEquals("a", StringUtils.abbreviateMiddle("a", ".", 1)); [EOL]  [EOL]         // Test smallest length that can lead to success [EOL]         assertEquals("a.d", StringUtils.abbreviateMiddle("abcd", ".", 3)); [EOL]  [EOL]         // More from LANG-405 [EOL]         assertEquals("a..f", StringUtils.abbreviateMiddle("abcdef", "..", 4)); [EOL]         assertEquals("ab.ef", StringUtils.abbreviateMiddle("abcdef", ".", 5)); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAbbreviateMiddle() { [EOL]         // javadoc examples [EOL]         assertNull( StringUtils.abbreviateMiddle(null, null, 0) ); [EOL]         assertEquals( "abc", StringUtils.abbreviateMiddle("abc", null, 0) ); [EOL]         assertEquals( "abc", StringUtils.abbreviateMiddle("abc", ".", 0) ); [EOL]         assertEquals( "abc", StringUtils.abbreviateMiddle("abc", ".", 3) ); [EOL]         assertEquals( "ab.f", StringUtils.abbreviateMiddle("abcdef", ".", 4) ); [EOL]  [EOL]         // JIRA issue (LANG-405) example (slightly different than actual expected result) [EOL]         assertEquals(  [EOL]             "A very long text with un...f the text is complete.", [EOL]             StringUtils.abbreviateMiddle( [EOL]                 "A very long text with unimportant stuff in the middle but interesting start and " + [EOL]                 "end to see if the text is complete.", "...", 50) ); [EOL]  [EOL]         // Test a much longer text :) [EOL]         final String longText = "Start text" + StringUtils.repeat("x", 10000) + "Close text"; [EOL]         assertEquals(  [EOL]             "Start text->Close text", [EOL]             StringUtils.abbreviateMiddle( longText, "->", 22 ) ); [EOL]  [EOL]         // Test negative length [EOL]         assertEquals("abc", StringUtils.abbreviateMiddle("abc", ".", -1)); [EOL]  [EOL]         // Test boundaries [EOL]         // Fails to change anything as method ensures first and last char are kept [EOL]         assertEquals("abc", StringUtils.abbreviateMiddle("abc", ".", 1)); [EOL]         assertEquals("abc", StringUtils.abbreviateMiddle("abc", ".", 2)); [EOL]  [EOL]         // Test length of n=1 [EOL]         assertEquals("a", StringUtils.abbreviateMiddle("a", ".", 1)); [EOL]  [EOL]         // Test smallest length that can lead to success [EOL]         assertEquals("a.d", StringUtils.abbreviateMiddle("abcd", ".", 3)); [EOL]  [EOL]         // More from LANG-405 [EOL]         assertEquals("a..f", StringUtils.abbreviateMiddle("abcdef", "..", 4)); [EOL]         assertEquals("ab.ef", StringUtils.abbreviateMiddle("abcdef", ".", 5)); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAbbreviateMiddle() { [EOL]         // javadoc examples [EOL]         assertNull( StringUtils.abbreviateMiddle(null, null, 0) ); [EOL]         assertEquals( "abc", StringUtils.abbreviateMiddle("abc", null, 0) ); [EOL]         assertEquals( "abc", StringUtils.abbreviateMiddle("abc", ".", 0) ); [EOL]         assertEquals( "abc", StringUtils.abbreviateMiddle("abc", ".", 3) ); [EOL]         assertEquals( "ab.f", StringUtils.abbreviateMiddle("abcdef", ".", 4) ); [EOL]  [EOL]         // JIRA issue (LANG-405) example (slightly different than actual expected result) [EOL]         assertEquals(  [EOL]             "A very long text with un...f the text is complete.", [EOL]             StringUtils.abbreviateMiddle( [EOL]                 "A very long text with unimportant stuff in the middle but interesting start and " + [EOL]                 "end to see if the text is complete.", "...", 50) ); [EOL]  [EOL]         // Test a much longer text :) [EOL]         final String longText = "Start text" + StringUtils.repeat("x", 10000) + "Close text"; [EOL]         assertEquals(  [EOL]             "Start text->Close text", [EOL]             StringUtils.abbreviateMiddle( longText, "->", 22 ) ); [EOL]  [EOL]         // Test negative length [EOL]         assertEquals("abc", StringUtils.abbreviateMiddle("abc", ".", -1)); [EOL]  [EOL]         // Test boundaries [EOL]         // Fails to change anything as method ensures first and last char are kept [EOL]         assertEquals("abc", StringUtils.abbreviateMiddle("abc", ".", 1)); [EOL]         assertEquals("abc", StringUtils.abbreviateMiddle("abc", ".", 2)); [EOL]  [EOL]         // Test length of n=1 [EOL]         assertEquals("a", StringUtils.abbreviateMiddle("a", ".", 1)); [EOL]  [EOL]         // Test smallest length that can lead to success [EOL]         assertEquals("a.d", StringUtils.abbreviateMiddle("abcd", ".", 3)); [EOL]  [EOL]         // More from LANG-405 [EOL]         assertEquals("a..f", StringUtils.abbreviateMiddle("abcdef", "..", 4)); [EOL]         assertEquals("ab.ef", StringUtils.abbreviateMiddle("abcdef", ".", 5)); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAbbreviateMiddle() { [EOL]         // javadoc examples [EOL]         assertNull( StringUtils.abbreviateMiddle(null, null, 0) ); [EOL]         assertEquals( "abc", StringUtils.abbreviateMiddle("abc", null, 0) ); [EOL]         assertEquals( "abc", StringUtils.abbreviateMiddle("abc", ".", 0) ); [EOL]         assertEquals( "abc", StringUtils.abbreviateMiddle("abc", ".", 3) ); [EOL]         assertEquals( "ab.f", StringUtils.abbreviateMiddle("abcdef", ".", 4) ); [EOL]  [EOL]         // JIRA issue (LANG-405) example (slightly different than actual expected result) [EOL]         assertEquals(  [EOL]             "A very long text with un...f the text is complete.", [EOL]             StringUtils.abbreviateMiddle( [EOL]                 "A very long text with unimportant stuff in the middle but interesting start and " + [EOL]                 "end to see if the text is complete.", "...", 50) ); [EOL]  [EOL]         // Test a much longer text :) [EOL]         final String longText = "Start text" + StringUtils.repeat("x", 10000) + "Close text"; [EOL]         assertEquals(  [EOL]             "Start text->Close text", [EOL]             StringUtils.abbreviateMiddle( longText, "->", 22 ) ); [EOL]  [EOL]         // Test negative length [EOL]         assertEquals("abc", StringUtils.abbreviateMiddle("abc", ".", -1)); [EOL]  [EOL]         // Test boundaries [EOL]         // Fails to change anything as method ensures first and last char are kept [EOL]         assertEquals("abc", StringUtils.abbreviateMiddle("abc", ".", 1)); [EOL]         assertEquals("abc", StringUtils.abbreviateMiddle("abc", ".", 2)); [EOL]  [EOL]         // Test length of n=1 [EOL]         assertEquals("a", StringUtils.abbreviateMiddle("a", ".", 1)); [EOL]  [EOL]         // Test smallest length that can lead to success [EOL]         assertEquals("a.d", StringUtils.abbreviateMiddle("abcd", ".", 3)); [EOL]  [EOL]         // More from LANG-405 [EOL]         assertEquals("a..f", StringUtils.abbreviateMiddle("abcdef", "..", 4)); [EOL]         assertEquals("ab.ef", StringUtils.abbreviateMiddle("abcdef", ".", 5)); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAbbreviateMiddle() { [EOL]         // javadoc examples [EOL]         assertNull( StringUtils.abbreviateMiddle(null, null, 0) ); [EOL]         assertEquals( "abc", StringUtils.abbreviateMiddle("abc", null, 0) ); [EOL]         assertEquals( "abc", StringUtils.abbreviateMiddle("abc", ".", 0) ); [EOL]         assertEquals( "abc", StringUtils.abbreviateMiddle("abc", ".", 3) ); [EOL]         assertEquals( "ab.f", StringUtils.abbreviateMiddle("abcdef", ".", 4) ); [EOL]  [EOL]         // JIRA issue (LANG-405) example (slightly different than actual expected result) [EOL]         assertEquals(  [EOL]             "A very long text with un...f the text is complete.", [EOL]             StringUtils.abbreviateMiddle( [EOL]                 "A very long text with unimportant stuff in the middle but interesting start and " + [EOL]                 "end to see if the text is complete.", "...", 50) ); [EOL]  [EOL]         // Test a much longer text :) [EOL]         final String longText = "Start text" + StringUtils.repeat("x", 10000) + "Close text"; [EOL]         assertEquals(  [EOL]             "Start text->Close text", [EOL]             StringUtils.abbreviateMiddle( longText, "->", 22 ) ); [EOL]  [EOL]         // Test negative length [EOL]         assertEquals("abc", StringUtils.abbreviateMiddle("abc", ".", -1)); [EOL]  [EOL]         // Test boundaries [EOL]         // Fails to change anything as method ensures first and last char are kept [EOL]         assertEquals("abc", StringUtils.abbreviateMiddle("abc", ".", 1)); [EOL]         assertEquals("abc", StringUtils.abbreviateMiddle("abc", ".", 2)); [EOL]  [EOL]         // Test length of n=1 [EOL]         assertEquals("a", StringUtils.abbreviateMiddle("a", ".", 1)); [EOL]  [EOL]         // Test smallest length that can lead to success [EOL]         assertEquals("a.d", StringUtils.abbreviateMiddle("abcd", ".", 3)); [EOL]  [EOL]         // More from LANG-405 [EOL]         assertEquals("a..f", StringUtils.abbreviateMiddle("abcdef", "..", 4)); [EOL]         assertEquals("ab.ef", StringUtils.abbreviateMiddle("abcdef", ".", 5)); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAbbreviateMiddle() { [EOL]         // javadoc examples [EOL]         assertNull( StringUtils.abbreviateMiddle(null, null, 0) ); [EOL]         assertEquals( "abc", StringUtils.abbreviateMiddle("abc", null, 0) ); [EOL]         assertEquals( "abc", StringUtils.abbreviateMiddle("abc", ".", 0) ); [EOL]         assertEquals( "abc", StringUtils.abbreviateMiddle("abc", ".", 3) ); [EOL]         assertEquals( "ab.f", StringUtils.abbreviateMiddle("abcdef", ".", 4) ); [EOL]  [EOL]         // JIRA issue (LANG-405) example (slightly different than actual expected result) [EOL]         assertEquals(  [EOL]             "A very long text with un...f the text is complete.", [EOL]             StringUtils.abbreviateMiddle( [EOL]                 "A very long text with unimportant stuff in the middle but interesting start and " + [EOL]                 "end to see if the text is complete.", "...", 50) ); [EOL]  [EOL]         // Test a much longer text :) [EOL]         final String longText = "Start text" + StringUtils.repeat("x", 10000) + "Close text"; [EOL]         assertEquals(  [EOL]             "Start text->Close text", [EOL]             StringUtils.abbreviateMiddle( longText, "->", 22 ) ); [EOL]  [EOL]         // Test negative length [EOL]         assertEquals("abc", StringUtils.abbreviateMiddle("abc", ".", -1)); [EOL]  [EOL]         // Test boundaries [EOL]         // Fails to change anything as method ensures first and last char are kept [EOL]         assertEquals("abc", StringUtils.abbreviateMiddle("abc", ".", 1)); [EOL]         assertEquals("abc", StringUtils.abbreviateMiddle("abc", ".", 2)); [EOL]  [EOL]         // Test length of n=1 [EOL]         assertEquals("a", StringUtils.abbreviateMiddle("a", ".", 1)); [EOL]  [EOL]         // Test smallest length that can lead to success [EOL]         assertEquals("a.d", StringUtils.abbreviateMiddle("abcd", ".", 3)); [EOL]  [EOL]         // More from LANG-405 [EOL]         assertEquals("a..f", StringUtils.abbreviateMiddle("abcdef", "..", 4)); [EOL]         assertEquals("ab.ef", StringUtils.abbreviateMiddle("abcdef", ".", 5)); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testDifference_StringString() { [EOL]         assertEquals(null, StringUtils.difference(null, null)); [EOL]         assertEquals("", StringUtils.difference("", "")); [EOL]         assertEquals("abc", StringUtils.difference("", "abc")); [EOL]         assertEquals("", StringUtils.difference("abc", "")); [EOL]         assertEquals("i am a robot", StringUtils.difference(null, "i am a robot")); [EOL]         assertEquals("i am a machine", StringUtils.difference("i am a machine", null)); [EOL]         assertEquals("robot", StringUtils.difference("i am a machine", "i am a robot")); [EOL]         assertEquals("", StringUtils.difference("abc", "abc")); [EOL]         assertEquals("you are a robot", StringUtils.difference("i am a robot", "you are a robot")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetCommonPrefix_StringArray() { [EOL]         assertEquals("", StringUtils.getCommonPrefix((String[])null)); [EOL]         assertEquals("", StringUtils.getCommonPrefix()); [EOL]         assertEquals("abc", StringUtils.getCommonPrefix("abc")); [EOL]         assertEquals("", StringUtils.getCommonPrefix(null, null)); [EOL]         assertEquals("", StringUtils.getCommonPrefix("", "")); [EOL]         assertEquals("", StringUtils.getCommonPrefix("", null)); [EOL]         assertEquals("", StringUtils.getCommonPrefix("abc", null, null)); [EOL]         assertEquals("", StringUtils.getCommonPrefix(null, null, "abc")); [EOL]         assertEquals("", StringUtils.getCommonPrefix("", "abc")); [EOL]         assertEquals("", StringUtils.getCommonPrefix("abc", "")); [EOL]         assertEquals("abc", StringUtils.getCommonPrefix("abc", "abc")); [EOL]         assertEquals("a", StringUtils.getCommonPrefix("abc", "a")); [EOL]         assertEquals("ab", StringUtils.getCommonPrefix("ab", "abxyz")); [EOL]         assertEquals("ab", StringUtils.getCommonPrefix("abcde", "abxyz")); [EOL]         assertEquals("", StringUtils.getCommonPrefix("abcde", "xyz")); [EOL]         assertEquals("", StringUtils.getCommonPrefix("xyz", "abcde")); [EOL]         assertEquals("i am a ", StringUtils.getCommonPrefix("i am a machine", "i am a robot")); [EOL]     } [EOL]          [EOL]
@Test [EOL]     public void testGetCommonPrefix_StringArray() { [EOL]         assertEquals("", StringUtils.getCommonPrefix((String[])null)); [EOL]         assertEquals("", StringUtils.getCommonPrefix()); [EOL]         assertEquals("abc", StringUtils.getCommonPrefix("abc")); [EOL]         assertEquals("", StringUtils.getCommonPrefix(null, null)); [EOL]         assertEquals("", StringUtils.getCommonPrefix("", "")); [EOL]         assertEquals("", StringUtils.getCommonPrefix("", null)); [EOL]         assertEquals("", StringUtils.getCommonPrefix("abc", null, null)); [EOL]         assertEquals("", StringUtils.getCommonPrefix(null, null, "abc")); [EOL]         assertEquals("", StringUtils.getCommonPrefix("", "abc")); [EOL]         assertEquals("", StringUtils.getCommonPrefix("abc", "")); [EOL]         assertEquals("abc", StringUtils.getCommonPrefix("abc", "abc")); [EOL]         assertEquals("a", StringUtils.getCommonPrefix("abc", "a")); [EOL]         assertEquals("ab", StringUtils.getCommonPrefix("ab", "abxyz")); [EOL]         assertEquals("ab", StringUtils.getCommonPrefix("abcde", "abxyz")); [EOL]         assertEquals("", StringUtils.getCommonPrefix("abcde", "xyz")); [EOL]         assertEquals("", StringUtils.getCommonPrefix("xyz", "abcde")); [EOL]         assertEquals("i am a ", StringUtils.getCommonPrefix("i am a machine", "i am a robot")); [EOL]     } [EOL]          [EOL]
@Test [EOL]     public void testGetCommonPrefix_StringArray() { [EOL]         assertEquals("", StringUtils.getCommonPrefix((String[])null)); [EOL]         assertEquals("", StringUtils.getCommonPrefix()); [EOL]         assertEquals("abc", StringUtils.getCommonPrefix("abc")); [EOL]         assertEquals("", StringUtils.getCommonPrefix(null, null)); [EOL]         assertEquals("", StringUtils.getCommonPrefix("", "")); [EOL]         assertEquals("", StringUtils.getCommonPrefix("", null)); [EOL]         assertEquals("", StringUtils.getCommonPrefix("abc", null, null)); [EOL]         assertEquals("", StringUtils.getCommonPrefix(null, null, "abc")); [EOL]         assertEquals("", StringUtils.getCommonPrefix("", "abc")); [EOL]         assertEquals("", StringUtils.getCommonPrefix("abc", "")); [EOL]         assertEquals("abc", StringUtils.getCommonPrefix("abc", "abc")); [EOL]         assertEquals("a", StringUtils.getCommonPrefix("abc", "a")); [EOL]         assertEquals("ab", StringUtils.getCommonPrefix("ab", "abxyz")); [EOL]         assertEquals("ab", StringUtils.getCommonPrefix("abcde", "abxyz")); [EOL]         assertEquals("", StringUtils.getCommonPrefix("abcde", "xyz")); [EOL]         assertEquals("", StringUtils.getCommonPrefix("xyz", "abcde")); [EOL]         assertEquals("i am a ", StringUtils.getCommonPrefix("i am a machine", "i am a robot")); [EOL]     } [EOL]          [EOL]
@Test [EOL]     public void testGetLevenshteinDistance_StringString() { [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("", "") ); [EOL]         assertEquals(1, StringUtils.getLevenshteinDistance("", "a") ); [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "") ); [EOL]         assertEquals(1, StringUtils.getLevenshteinDistance("frog", "fog") ); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("fly", "ant") ); [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("elephant", "hippo") ); [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("hippo", "elephant") ); [EOL]         assertEquals(8, StringUtils.getLevenshteinDistance("hippo", "zzzzzzzz") ); [EOL]         assertEquals(8, StringUtils.getLevenshteinDistance("zzzzzzzz", "hippo") ); [EOL]         assertEquals(1, StringUtils.getLevenshteinDistance("hello", "hallo") ); [EOL]         try { [EOL]             @SuppressWarnings("unused") [EOL]             final [EOL]             int d = StringUtils.getLevenshteinDistance("a", null); [EOL]             fail("expecting IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException ex) { [EOL]             // empty [EOL]         } [EOL]         try { [EOL]             @SuppressWarnings("unused") [EOL]             final [EOL]             int d = StringUtils.getLevenshteinDistance(null, "a"); [EOL]             fail("expecting IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException ex) { [EOL]             // empty [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetLevenshteinDistance_StringStringInt() { [EOL]         // empty strings [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("", "", 0)); [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "", 8)); [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "", 7)); [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("aaapppp", "", 6)); [EOL]  [EOL]         // unequal strings, zero threshold [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("b", "a", 0)); [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("a", "b", 0)); [EOL]      [EOL]         // equal strings [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("aa", "aa", 0)); [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("aa", "aa", 2)); [EOL]  [EOL]         // same length [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("aaa", "bbb", 2)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("aaa", "bbb", 3)); [EOL]      [EOL]         // big stripe [EOL]         assertEquals(6, StringUtils.getLevenshteinDistance("aaaaaa", "b", 10)); [EOL]  [EOL]         // distance less than threshold [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "b", 8)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("a", "bbb", 4)); [EOL]      [EOL]         // distance equal to threshold [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "b", 7)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("a", "bbb", 3)); [EOL]  [EOL]         // distance greater than threshold [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("a", "bbb", 2)); [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("bbb", "a", 2)); [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("aaapppp", "b", 6)); [EOL]  [EOL]         // stripe runs off array, strings not similar [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("a", "bbb", 1)); [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("bbb", "a", 1)); [EOL]  [EOL]         // stripe runs off array, strings are similar [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("12345", "1234567", 1)); [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("1234567", "12345", 1)); [EOL]  [EOL]         // old getLevenshteinDistance test cases [EOL]         assertEquals(1, StringUtils.getLevenshteinDistance("frog", "fog",1) ); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("fly", "ant",3) ); [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("elephant", "hippo",7) ); [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("elephant", "hippo",6) ); [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("hippo", "elephant",7) ); [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("hippo", "elephant",6) ); [EOL]         assertEquals(8, StringUtils.getLevenshteinDistance("hippo", "zzzzzzzz",8) ); [EOL]         assertEquals(8, StringUtils.getLevenshteinDistance("zzzzzzzz", "hippo",8) ); [EOL]         assertEquals(1, StringUtils.getLevenshteinDistance("hello", "hallo",1) ); [EOL]  [EOL]         // exceptions [EOL]         try { [EOL]             @SuppressWarnings("unused") [EOL]             final [EOL]             int d = StringUtils.getLevenshteinDistance("a", null, 0); [EOL]             fail("expecting IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException ex) { [EOL]             // empty [EOL]         } [EOL]         try { [EOL]             @SuppressWarnings("unused") [EOL]             final [EOL]             int d = StringUtils.getLevenshteinDistance(null, "a", 0); [EOL]             fail("expecting IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException ex) { [EOL]             // empty [EOL]         } [EOL]  [EOL]         try { [EOL]             @SuppressWarnings("unused") [EOL]             final [EOL]             int d = StringUtils.getLevenshteinDistance("a", "a", -1); [EOL]             fail("expecting IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException ex) { [EOL]             // empty [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * A sanity check for {@link StringUtils#EMPTY}. [EOL]      */ [EOL]
@Test [EOL]     public void testStartsWithAny() { [EOL]         assertFalse(StringUtils.startsWithAny(null, (String[])null)); [EOL]         assertFalse(StringUtils.startsWithAny(null, "abc")); [EOL]         assertFalse(StringUtils.startsWithAny("abcxyz", (String[])null)); [EOL]         assertFalse(StringUtils.startsWithAny("abcxyz")); [EOL]         assertTrue(StringUtils.startsWithAny("abcxyz", "abc")); [EOL]         assertTrue(StringUtils.startsWithAny("abcxyz", null, "xyz", "abc")); [EOL]         assertFalse(StringUtils.startsWithAny("abcxyz", null, "xyz", "abcd")); [EOL]  [EOL]         assertTrue("StringUtils.startsWithAny(abcxyz, StringBuilder(xyz), StringBuffer(abc))", StringUtils.startsWithAny("abcxyz", new StringBuilder("xyz"), new StringBuffer("abc"))); [EOL]         assertTrue("StringUtils.startsWithAny( StrBuilder(abcxyz), StringBuilder(xyz), StringBuffer(abc))", StringUtils.startsWithAny( new StrBuilder("abcxyz"), new StringBuilder("xyz"), new StringBuffer("abc"))); [EOL]     } [EOL]   [EOL]  [EOL]     /** [EOL]      * Test StringUtils.endsWith() [EOL]      */ [EOL]
@Test [EOL]     public void testNormalizeSpace() { [EOL]         assertEquals(null, StringUtils.normalizeSpace(null)); [EOL]         assertEquals("", StringUtils.normalizeSpace("")); [EOL]         assertEquals("", StringUtils.normalizeSpace(" ")); [EOL]         assertEquals("", StringUtils.normalizeSpace("\t")); [EOL]         assertEquals("", StringUtils.normalizeSpace("\n"));         [EOL]         assertEquals("", StringUtils.normalizeSpace("\u0009")); [EOL]         assertEquals("", StringUtils.normalizeSpace("\u000B")); [EOL]         assertEquals("", StringUtils.normalizeSpace("\u000C")); [EOL]         assertEquals("", StringUtils.normalizeSpace("\u001C")); [EOL]         assertEquals("", StringUtils.normalizeSpace("\u001D")); [EOL]         assertEquals("", StringUtils.normalizeSpace("\u001E")); [EOL]         assertEquals("", StringUtils.normalizeSpace("\u001F")); [EOL]         assertEquals("", StringUtils.normalizeSpace("\f")); [EOL]         assertEquals("", StringUtils.normalizeSpace("\r")); [EOL]         assertEquals("a", StringUtils.normalizeSpace("  a  ")); [EOL]         assertEquals("a b c", StringUtils.normalizeSpace("  a  b   c  ")); [EOL]         assertEquals("a b c", StringUtils.normalizeSpace("a\t\f\r  b\u000B   c\n")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-0500", fdf.format(millis1)); [EOL]  [EOL]             assertEquals("-0400", fdf.format(date2)); [EOL]             assertEquals("-0400", fdf.format(cal2)); [EOL]             assertEquals("-0400", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("ZZ"); [EOL]             assertEquals("-05:00", fdf.format(date1)); [EOL]             assertEquals("-05:00", fdf.format(cal1)); [EOL]             assertEquals("-05:00", fdf.format(millis1)); [EOL]  [EOL]             assertEquals("-04:00", fdf.format(date2)); [EOL]             assertEquals("-04:00", fdf.format(cal2)); [EOL]             assertEquals("-04:00", fdf.format(millis2)); [EOL]  [EOL]             final String pattern = "GGGG GGG GG G yyyy yyy yy y MMMM MMM MM M" + [EOL]                 " dddd ddd dd d DDDD DDD DD D EEEE EEE EE E aaaa aaa aa a zzzz zzz zz z"; [EOL]             fdf = getInstance(pattern); [EOL]             sdf = new SimpleDateFormat(pattern); [EOL]             // SDF bug fix starting with Java 7 [EOL]             assertEquals(sdf.format(date1).replaceAll("2003 03 03 03", "2003 2003 03 2003"), fdf.format(date1)); [EOL]             assertEquals(sdf.format(date2).replaceAll("2003 03 03 03", "2003 2003 03 2003"), fdf.format(date2)); [EOL]         } finally { [EOL]             Locale.setDefault(realDefaultLocale); [EOL]             TimeZone.setDefault(realDefaultZone); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test case for {@link FastDateParser#FastDateParser(String, TimeZone, Locale)}. [EOL]      */ [EOL]
@Test [EOL]     public void testParseSync() throws InterruptedException { [EOL]         final String pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS Z"; [EOL]         final FastDateFormat formatter= FastDateFormat.getInstance(pattern); [EOL]          [EOL]         final long sdfTime= measureTime(formatter, new SimpleDateFormat(pattern) { [EOL]                         private static final long serialVersionUID = 1L;  // because SimpleDateFormat is serializable [EOL]  [EOL]                         @Override [EOL]                         public Object parseObject(final String formattedDate) throws ParseException { [EOL]                             synchronized(this) { [EOL]                                 return super.parse(formattedDate); [EOL]                             } [EOL]                         } [EOL]         }); [EOL]          [EOL]         final long fdfTime= measureTime(formatter, FastDateFormat.getInstance(pattern)); [EOL]          [EOL]         final String times= ">>FastDateFormatTest: FastDateParser:"+fdfTime+"  SimpleDateFormat:"+sdfTime; [EOL]         System.out.println(times); [EOL]     } [EOL]  [EOL]     final static private int NTHREADS= 10; [EOL]     final static private int NROUNDS= 10000; [EOL]      [EOL]     private long measureTime(final Format formatter, final Format parser) throws InterruptedException { [EOL]         final ExecutorService pool = Executors.newFixedThreadPool(NTHREADS); [EOL]         final AtomicInteger failures= new AtomicInteger(0); [EOL]         final AtomicLong totalElapsed= new AtomicLong(0); [EOL]          [EOL]         for(int i= 0; i<NTHREADS; ++i) { [EOL]             pool.submit(new Runnable() { [EOL]                 @Override [EOL]                 public void run() { [EOL]                     for(int i= 0; i<NROUNDS; ++i) { [EOL]                         try { [EOL]                             final Date date= new Date(); [EOL]                             final String formattedDate= formatter.format(date); [EOL]                             final long start= System.currentTimeMillis();         [EOL]                             final Object pd= parser.parseObject(formattedDate); [EOL]                             totalElapsed.addAndGet(System.currentTimeMillis()-start); [EOL]                             if(!date.equals(pd)) { [EOL]                                 failures.incrementAndGet(); [EOL]                             } [EOL]                         } catch (final Exception e) { [EOL]                             failures.incrementAndGet(); [EOL]                             e.printStackTrace(); [EOL]                         } [EOL]                     } [EOL]                 }                 [EOL]             }); [EOL]         } [EOL]         pool.shutdown();                         [EOL]         if(!pool.awaitTermination(20, TimeUnit.SECONDS)) { [EOL]             pool.shutdownNow(); [EOL]             fail("did not complete tasks"); [EOL]         } [EOL]         assertEquals(0, failures.get()); [EOL]         return totalElapsed.get(); [EOL]     } [EOL] } [EOL]
@Test [EOL]     public void testLang303() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2004, 11, 31); [EOL]  [EOL]         DatePrinter format = getInstance(YYYY_MM_DD); [EOL]         final String output = format.format(cal); [EOL]  [EOL]         format = SerializationUtils.deserialize(SerializationUtils.serialize((Serializable) format)); [EOL]         assertEquals(output, format.format(cal)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLang303() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2004, 11, 31); [EOL]  [EOL]         DatePrinter format = getInstance(YYYY_MM_DD); [EOL]         final String output = format.format(cal); [EOL]  [EOL]         format = SerializationUtils.deserialize(SerializationUtils.serialize((Serializable) format)); [EOL]         assertEquals(output, format.format(cal)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLang303() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2004, 11, 31); [EOL]  [EOL]         DatePrinter format = getInstance(YYYY_MM_DD); [EOL]         final String output = format.format(cal); [EOL]  [EOL]         format = SerializationUtils.deserialize(SerializationUtils.serialize((Serializable) format)); [EOL]         assertEquals(output, format.format(cal)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-0500", fdf.format(millis1)); [EOL]  [EOL]             assertEquals("-0400", fdf.format(date2)); [EOL]             assertEquals("-0400", fdf.format(cal2)); [EOL]             assertEquals("-0400", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("ZZ"); [EOL]             assertEquals("-05:00", fdf.format(date1)); [EOL]             assertEquals("-05:00", fdf.format(cal1)); [EOL]             assertEquals("-05:00", fdf.format(millis1)); [EOL]  [EOL]             assertEquals("-04:00", fdf.format(date2)); [EOL]             assertEquals("-04:00", fdf.format(cal2)); [EOL]             assertEquals("-04:00", fdf.format(millis2)); [EOL]  [EOL]             final String pattern = "GGGG GGG GG G yyyy yyy yy y MMMM MMM MM M" + [EOL]                 " dddd ddd dd d DDDD DDD DD D EEEE EEE EE E aaaa aaa aa a zzzz zzz zz z"; [EOL]             fdf = getInstance(pattern); [EOL]             sdf = new SimpleDateFormat(pattern); [EOL]             // SDF bug fix starting with Java 7 [EOL]             assertEquals(sdf.format(date1).replaceAll("2003 03 03 03", "2003 2003 03 2003"), fdf.format(date1)); [EOL]             assertEquals(sdf.format(date2).replaceAll("2003 03 03 03", "2003 2003 03 2003"), fdf.format(date2)); [EOL]         } finally { [EOL]             Locale.setDefault(realDefaultLocale); [EOL]             TimeZone.setDefault(realDefaultZone); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test case for {@link FastDateParser#FastDateParser(String, TimeZone, Locale)}. [EOL]      */ [EOL]
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-0500", fdf.format(millis1)); [EOL]  [EOL]             assertEquals("-0400", fdf.format(date2)); [EOL]             assertEquals("-0400", fdf.format(cal2)); [EOL]             assertEquals("-0400", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("ZZ"); [EOL]             assertEquals("-05:00", fdf.format(date1)); [EOL]             assertEquals("-05:00", fdf.format(cal1)); [EOL]             assertEquals("-05:00", fdf.format(millis1)); [EOL]  [EOL]             assertEquals("-04:00", fdf.format(date2)); [EOL]             assertEquals("-04:00", fdf.format(cal2)); [EOL]             assertEquals("-04:00", fdf.format(millis2)); [EOL]  [EOL]             final String pattern = "GGGG GGG GG G yyyy yyy yy y MMMM MMM MM M" + [EOL]                 " dddd ddd dd d DDDD DDD DD D EEEE EEE EE E aaaa aaa aa a zzzz zzz zz z"; [EOL]             fdf = getInstance(pattern); [EOL]             sdf = new SimpleDateFormat(pattern); [EOL]             // SDF bug fix starting with Java 7 [EOL]             assertEquals(sdf.format(date1).replaceAll("2003 03 03 03", "2003 2003 03 2003"), fdf.format(date1)); [EOL]             assertEquals(sdf.format(date2).replaceAll("2003 03 03 03", "2003 2003 03 2003"), fdf.format(date2)); [EOL]         } finally { [EOL]             Locale.setDefault(realDefaultLocale); [EOL]             TimeZone.setDefault(realDefaultZone); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test case for {@link FastDateParser#FastDateParser(String, TimeZone, Locale)}. [EOL]      */ [EOL]
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-0500", fdf.format(millis1)); [EOL]  [EOL]             assertEquals("-0400", fdf.format(date2)); [EOL]             assertEquals("-0400", fdf.format(cal2)); [EOL]             assertEquals("-0400", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("ZZ"); [EOL]             assertEquals("-05:00", fdf.format(date1)); [EOL]             assertEquals("-05:00", fdf.format(cal1)); [EOL]             assertEquals("-05:00", fdf.format(millis1)); [EOL]  [EOL]             assertEquals("-04:00", fdf.format(date2)); [EOL]             assertEquals("-04:00", fdf.format(cal2)); [EOL]             assertEquals("-04:00", fdf.format(millis2)); [EOL]  [EOL]             final String pattern = "GGGG GGG GG G yyyy yyy yy y MMMM MMM MM M" + [EOL]                 " dddd ddd dd d DDDD DDD DD D EEEE EEE EE E aaaa aaa aa a zzzz zzz zz z"; [EOL]             fdf = getInstance(pattern); [EOL]             sdf = new SimpleDateFormat(pattern); [EOL]             // SDF bug fix starting with Java 7 [EOL]             assertEquals(sdf.format(date1).replaceAll("2003 03 03 03", "2003 2003 03 2003"), fdf.format(date1)); [EOL]             assertEquals(sdf.format(date2).replaceAll("2003 03 03 03", "2003 2003 03 2003"), fdf.format(date2)); [EOL]         } finally { [EOL]             Locale.setDefault(realDefaultLocale); [EOL]             TimeZone.setDefault(realDefaultZone); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test case for {@link FastDateParser#FastDateParser(String, TimeZone, Locale)}. [EOL]      */ [EOL]
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-0500", fdf.format(millis1)); [EOL]  [EOL]             assertEquals("-0400", fdf.format(date2)); [EOL]             assertEquals("-0400", fdf.format(cal2)); [EOL]             assertEquals("-0400", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("ZZ"); [EOL]             assertEquals("-05:00", fdf.format(date1)); [EOL]             assertEquals("-05:00", fdf.format(cal1)); [EOL]             assertEquals("-05:00", fdf.format(millis1)); [EOL]  [EOL]             assertEquals("-04:00", fdf.format(date2)); [EOL]             assertEquals("-04:00", fdf.format(cal2)); [EOL]             assertEquals("-04:00", fdf.format(millis2)); [EOL]  [EOL]             final String pattern = "GGGG GGG GG G yyyy yyy yy y MMMM MMM MM M" + [EOL]                 " dddd ddd dd d DDDD DDD DD D EEEE EEE EE E aaaa aaa aa a zzzz zzz zz z"; [EOL]             fdf = getInstance(pattern); [EOL]             sdf = new SimpleDateFormat(pattern); [EOL]             // SDF bug fix starting with Java 7 [EOL]             assertEquals(sdf.format(date1).replaceAll("2003 03 03 03", "2003 2003 03 2003"), fdf.format(date1)); [EOL]             assertEquals(sdf.format(date2).replaceAll("2003 03 03 03", "2003 2003 03 2003"), fdf.format(date2)); [EOL]         } finally { [EOL]             Locale.setDefault(realDefaultLocale); [EOL]             TimeZone.setDefault(realDefaultZone); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test case for {@link FastDateParser#FastDateParser(String, TimeZone, Locale)}. [EOL]      */ [EOL]
@Test [EOL]     public void testShortDateStyleWithLocales() { [EOL]         final Locale usLocale = Locale.US; [EOL]         final Locale swedishLocale = new Locale("sv", "SE"); [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2004, 1, 3); [EOL]         DatePrinter fdf = getDateInstance(FastDateFormat.SHORT, usLocale); [EOL]         assertEquals("2/3/04", fdf.format(cal)); [EOL]  [EOL]         fdf = getDateInstance(FastDateFormat.SHORT, swedishLocale); [EOL]         assertEquals("2004-02-03", fdf.format(cal)); [EOL]  [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests that pre-1000AD years get padded with yyyy [EOL]      */ [EOL]
@Test [EOL]     public void testShortDateStyleWithLocales() { [EOL]         final Locale usLocale = Locale.US; [EOL]         final Locale swedishLocale = new Locale("sv", "SE"); [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2004, 1, 3); [EOL]         DatePrinter fdf = getDateInstance(FastDateFormat.SHORT, usLocale); [EOL]         assertEquals("2/3/04", fdf.format(cal)); [EOL]  [EOL]         fdf = getDateInstance(FastDateFormat.SHORT, swedishLocale); [EOL]         assertEquals("2004-02-03", fdf.format(cal)); [EOL]  [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests that pre-1000AD years get padded with yyyy [EOL]      */ [EOL]
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-0500", fdf.format(millis1)); [EOL]  [EOL]             assertEquals("-0400", fdf.format(date2)); [EOL]             assertEquals("-0400", fdf.format(cal2)); [EOL]             assertEquals("-0400", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("ZZ"); [EOL]             assertEquals("-05:00", fdf.format(date1)); [EOL]             assertEquals("-05:00", fdf.format(cal1)); [EOL]             assertEquals("-05:00", fdf.format(millis1)); [EOL]  [EOL]             assertEquals("-04:00", fdf.format(date2)); [EOL]             assertEquals("-04:00", fdf.format(cal2)); [EOL]             assertEquals("-04:00", fdf.format(millis2)); [EOL]  [EOL]             final String pattern = "GGGG GGG GG G yyyy yyy yy y MMMM MMM MM M" + [EOL]                 " dddd ddd dd d DDDD DDD DD D EEEE EEE EE E aaaa aaa aa a zzzz zzz zz z"; [EOL]             fdf = getInstance(pattern); [EOL]             sdf = new SimpleDateFormat(pattern); [EOL]             // SDF bug fix starting with Java 7 [EOL]             assertEquals(sdf.format(date1).replaceAll("2003 03 03 03", "2003 2003 03 2003"), fdf.format(date1)); [EOL]             assertEquals(sdf.format(date2).replaceAll("2003 03 03 03", "2003 2003 03 2003"), fdf.format(date2)); [EOL]         } finally { [EOL]             Locale.setDefault(realDefaultLocale); [EOL]             TimeZone.setDefault(realDefaultZone); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test case for {@link FastDateParser#FastDateParser(String, TimeZone, Locale)}. [EOL]      */ [EOL]
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-0500", fdf.format(millis1)); [EOL]  [EOL]             assertEquals("-0400", fdf.format(date2)); [EOL]             assertEquals("-0400", fdf.format(cal2)); [EOL]             assertEquals("-0400", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("ZZ"); [EOL]             assertEquals("-05:00", fdf.format(date1)); [EOL]             assertEquals("-05:00", fdf.format(cal1)); [EOL]             assertEquals("-05:00", fdf.format(millis1)); [EOL]  [EOL]             assertEquals("-04:00", fdf.format(date2)); [EOL]             assertEquals("-04:00", fdf.format(cal2)); [EOL]             assertEquals("-04:00", fdf.format(millis2)); [EOL]  [EOL]             final String pattern = "GGGG GGG GG G yyyy yyy yy y MMMM MMM MM M" + [EOL]                 " dddd ddd dd d DDDD DDD DD D EEEE EEE EE E aaaa aaa aa a zzzz zzz zz z"; [EOL]             fdf = getInstance(pattern); [EOL]             sdf = new SimpleDateFormat(pattern); [EOL]             // SDF bug fix starting with Java 7 [EOL]             assertEquals(sdf.format(date1).replaceAll("2003 03 03 03", "2003 2003 03 2003"), fdf.format(date1)); [EOL]             assertEquals(sdf.format(date2).replaceAll("2003 03 03 03", "2003 2003 03 2003"), fdf.format(date2)); [EOL]         } finally { [EOL]             Locale.setDefault(realDefaultLocale); [EOL]             TimeZone.setDefault(realDefaultZone); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test case for {@link FastDateParser#FastDateParser(String, TimeZone, Locale)}. [EOL]      */ [EOL]
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-0500", fdf.format(millis1)); [EOL]  [EOL]             assertEquals("-0400", fdf.format(date2)); [EOL]             assertEquals("-0400", fdf.format(cal2)); [EOL]             assertEquals("-0400", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("ZZ"); [EOL]             assertEquals("-05:00", fdf.format(date1)); [EOL]             assertEquals("-05:00", fdf.format(cal1)); [EOL]             assertEquals("-05:00", fdf.format(millis1)); [EOL]  [EOL]             assertEquals("-04:00", fdf.format(date2)); [EOL]             assertEquals("-04:00", fdf.format(cal2)); [EOL]             assertEquals("-04:00", fdf.format(millis2)); [EOL]  [EOL]             final String pattern = "GGGG GGG GG G yyyy yyy yy y MMMM MMM MM M" + [EOL]                 " dddd ddd dd d DDDD DDD DD D EEEE EEE EE E aaaa aaa aa a zzzz zzz zz z"; [EOL]             fdf = getInstance(pattern); [EOL]             sdf = new SimpleDateFormat(pattern); [EOL]             // SDF bug fix starting with Java 7 [EOL]             assertEquals(sdf.format(date1).replaceAll("2003 03 03 03", "2003 2003 03 2003"), fdf.format(date1)); [EOL]             assertEquals(sdf.format(date2).replaceAll("2003 03 03 03", "2003 2003 03 2003"), fdf.format(date2)); [EOL]         } finally { [EOL]             Locale.setDefault(realDefaultLocale); [EOL]             TimeZone.setDefault(realDefaultZone); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test case for {@link FastDateParser#FastDateParser(String, TimeZone, Locale)}. [EOL]      */ [EOL]
@Test [EOL]     public void testFactory_int_int_int() { [EOL]         Fraction f = null; [EOL]          [EOL]         // zero [EOL]         f = Fraction.getFraction(0, 0, 2); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(2, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(2, 0, 2); [EOL]         assertEquals(4, f.getNumerator()); [EOL]         assertEquals(2, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(0, 1, 2); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(2, f.getDenominator()); [EOL]          [EOL]         // normal [EOL]         f = Fraction.getFraction(1, 1, 2); [EOL]         assertEquals(3, f.getNumerator()); [EOL]         assertEquals(2, f.getDenominator()); [EOL]          [EOL]         // negatives [EOL]         try { [EOL]             f = Fraction.getFraction(1, -6, -10); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(1, -6, -10); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(1, -6, -10); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]          [EOL]         // negative whole [EOL]         f = Fraction.getFraction(-1, 6, 10); [EOL]         assertEquals(-16, f.getNumerator()); [EOL]         assertEquals(10, f.getDenominator()); [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction(-1, -6, 10); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(-1, 6, -10); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction(-1, -6, -10); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]          [EOL]         // zero denominator [EOL]         try { [EOL]             f = Fraction.getFraction(0, 1, 0); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction(1, 2, 0); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction(-1, -3, 0); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction(Integer.MAX_VALUE, 1, 2);  [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction(-Integer.MAX_VALUE, 1, 2); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         // very large [EOL]         f = Fraction.getFraction(-1, 0, Integer.MAX_VALUE); [EOL]         assertEquals(-Integer.MAX_VALUE, f.getNumerator()); [EOL]         assertEquals(Integer.MAX_VALUE, f.getDenominator()); [EOL]  [EOL]         try { [EOL]             // negative denominators not allowed in this constructor. [EOL]             f = Fraction.getFraction(0, 4, Integer.MIN_VALUE); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]         try { [EOL]             f = Fraction.getFraction(1, 1, Integer.MAX_VALUE); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]         try { [EOL]             f = Fraction.getFraction(-1, 2, Integer.MAX_VALUE); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]     } [EOL]
@Test [EOL]     public void testFactory_String_proper() { [EOL]         Fraction f = null; [EOL]          [EOL]         f = Fraction.getFraction("0 0/1"); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction("1 1/5"); [EOL]         assertEquals(6, f.getNumerator()); [EOL]         assertEquals(5, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction("7 1/2"); [EOL]         assertEquals(15, f.getNumerator()); [EOL]         assertEquals(2, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction("1 2/4"); [EOL]         assertEquals(6, f.getNumerator()); [EOL]         assertEquals(4, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction("-7 1/2"); [EOL]         assertEquals(-15, f.getNumerator()); [EOL]         assertEquals(2, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction("-1 2/4"); [EOL]         assertEquals(-6, f.getNumerator()); [EOL]         assertEquals(4, f.getDenominator()); [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction("2 3"); [EOL]             fail("expecting NumberFormatException"); [EOL]         } catch (final NumberFormatException ex) {} [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction("a 3"); [EOL]             fail("expecting NumberFormatException"); [EOL]         } catch (final NumberFormatException ex) {} [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction("2 b/4"); [EOL]             fail("expecting NumberFormatException"); [EOL]         } catch (final NumberFormatException ex) {} [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction("2 "); [EOL]             fail("expecting NumberFormatException"); [EOL]         } catch (final NumberFormatException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(" 3"); [EOL]             fail("expecting NumberFormatException"); [EOL]         } catch (final NumberFormatException ex) {} [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction(" "); [EOL]             fail("expecting NumberFormatException"); [EOL]         } catch (final NumberFormatException ex) {} [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testInvert() { [EOL]         Fraction f = null; [EOL]          [EOL]         f = Fraction.getFraction(50, 75); [EOL]         f = f.invert(); [EOL]         assertEquals(75, f.getNumerator()); [EOL]         assertEquals(50, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(4, 3); [EOL]         f = f.invert(); [EOL]         assertEquals(3, f.getNumerator()); [EOL]         assertEquals(4, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(-15, 47); [EOL]         f = f.invert(); [EOL]         assertEquals(-47, f.getNumerator()); [EOL]         assertEquals(15, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(0, 3); [EOL]         try { [EOL]             f = f.invert(); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         // large values [EOL]         f = Fraction.getFraction(Integer.MIN_VALUE, 1); [EOL]         try { [EOL]             f = f.invert(); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         f = Fraction.getFraction(Integer.MAX_VALUE, 1); [EOL]         f = f.invert(); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(Integer.MAX_VALUE, f.getDenominator()); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testAbs() { [EOL]         Fraction f = null; [EOL]          [EOL]         f = Fraction.getFraction(50, 75); [EOL]         f = f.abs(); [EOL]         assertEquals(50, f.getNumerator()); [EOL]         assertEquals(75, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(-50, 75); [EOL]         f = f.abs(); [EOL]         assertEquals(50, f.getNumerator()); [EOL]         assertEquals(75, f.getDenominator()); [EOL]  [EOL]         f = Fraction.getFraction(Integer.MAX_VALUE, 1); [EOL]         f = f.abs(); [EOL]         assertEquals(Integer.MAX_VALUE, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]  [EOL]         f = Fraction.getFraction(Integer.MAX_VALUE, -1); [EOL]         f = f.abs(); [EOL]         assertEquals(Integer.MAX_VALUE, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]  [EOL]         f = Fraction.getFraction(Integer.MIN_VALUE, 1); [EOL]         try { [EOL]             f = f.abs(); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testAdd() { [EOL]         Fraction f = null; [EOL]         Fraction f1 = null; [EOL]         Fraction f2 = null; [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(1, 5); [EOL]         f = f1.add(f2); [EOL]         assertEquals(4, f.getNumerator()); [EOL]         assertEquals(5, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(2, 5); [EOL]         f = f1.add(f2); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(3, 5); [EOL]         f = f1.add(f2); [EOL]         assertEquals(6, f.getNumerator()); [EOL]         assertEquals(5, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(-4, 5); [EOL]         f = f1.add(f2); [EOL]         assertEquals(-1, f.getNumerator()); [EOL]         assertEquals(5, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(Integer.MAX_VALUE - 1, 1); [EOL]         f2 = Fraction.ONE; [EOL]         f = f1.add(f2); [EOL]         assertEquals(Integer.MAX_VALUE, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(1, 2); [EOL]         f = f1.add(f2); [EOL]         assertEquals(11, f.getNumerator()); [EOL]         assertEquals(10, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 8); [EOL]         f2 = Fraction.getFraction(1, 6); [EOL]         f = f1.add(f2); [EOL]         assertEquals(13, f.getNumerator()); [EOL]         assertEquals(24, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(0, 5); [EOL]         f2 = Fraction.getFraction(1, 5); [EOL]         f = f1.add(f2); [EOL]         assertSame(f2, f); [EOL]         f = f2.add(f1); [EOL]         assertSame(f2, f); [EOL]          [EOL]         f1 = Fraction.getFraction(-1, 13*13*2*2); [EOL]         f2 = Fraction.getFraction(-2, 13*17*2); [EOL]         f = f1.add(f2); [EOL]         assertEquals(13*13*17*2*2, f.getDenominator()); [EOL]         assertEquals(-17 - 2*13*2, f.getNumerator()); [EOL]          [EOL]         try { [EOL]             f.add(null); [EOL]             fail("expecting IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]          [EOL]         // if this fraction is added naively, it will overflow. [EOL]         // check that it doesn't. [EOL]         f1 = Fraction.getFraction(1,32768*3); [EOL]         f2 = Fraction.getFraction(1,59049); [EOL]         f = f1.add(f2); [EOL]         assertEquals(52451, f.getNumerator()); [EOL]         assertEquals(1934917632, f.getDenominator()); [EOL]  [EOL]         f1 = Fraction.getFraction(Integer.MIN_VALUE, 3); [EOL]         f2 = Fraction.ONE_THIRD; [EOL]         f = f1.add(f2); [EOL]         assertEquals(Integer.MIN_VALUE+1, f.getNumerator()); [EOL]         assertEquals(3, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(Integer.MAX_VALUE - 1, 1); [EOL]         f2 = Fraction.ONE; [EOL]         f = f1.add(f2); [EOL]         assertEquals(Integer.MAX_VALUE, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         try { [EOL]             f = f.add(Fraction.ONE); // should overflow [EOL]             fail("expecting ArithmeticException but got: " + f.toString()); [EOL]         } catch (final ArithmeticException ex) {} [EOL]          [EOL]         // denominator should not be a multiple of 2 or 3 to trigger overflow [EOL]         f1 = Fraction.getFraction(Integer.MIN_VALUE, 5); [EOL]         f2 = Fraction.getFraction(-1,5); [EOL]         try { [EOL]             f = f1.add(f2); // should overflow [EOL]             fail("expecting ArithmeticException but got: " + f.toString()); [EOL]         } catch (final ArithmeticException ex) {} [EOL]          [EOL]         try { [EOL]             f= Fraction.getFraction(-Integer.MAX_VALUE, 1); [EOL]             f = f.add(f); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]              [EOL]         try { [EOL]             f= Fraction.getFraction(-Integer.MAX_VALUE, 1); [EOL]             f = f.add(f); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]              [EOL]         f1 = Fraction.getFraction(3,327680); [EOL]         f2 = Fraction.getFraction(2,59049); [EOL]         try { [EOL]             f = f1.add(f2); // should overflow [EOL]             fail("expecting ArithmeticException but got: " + f.toString()); [EOL]         } catch (final ArithmeticException ex) {} [EOL]     } [EOL]              [EOL]
@Test [EOL]     public void testSubtract() { [EOL]         Fraction f = null; [EOL]         Fraction f1 = null; [EOL]         Fraction f2 = null; [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(1, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(2, f.getNumerator()); [EOL]         assertEquals(5, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(7, 5); [EOL]         f2 = Fraction.getFraction(2, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(3, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(-4, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(7, f.getNumerator()); [EOL]         assertEquals(5, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(0, 5); [EOL]         f2 = Fraction.getFraction(4, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(-4, f.getNumerator()); [EOL]         assertEquals(5, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(0, 5); [EOL]         f2 = Fraction.getFraction(-4, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(4, f.getNumerator()); [EOL]         assertEquals(5, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(1, 2); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(10, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(0, 5); [EOL]         f2 = Fraction.getFraction(1, 5); [EOL]         f = f2.subtract(f1); [EOL]         assertSame(f2, f); [EOL]          [EOL]         try { [EOL]             f.subtract(null); [EOL]             fail("expecting IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]          [EOL]         // if this fraction is subtracted naively, it will overflow. [EOL]         // check that it doesn't. [EOL]         f1 = Fraction.getFraction(1,32768*3); [EOL]         f2 = Fraction.getFraction(1,59049); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(-13085, f.getNumerator()); [EOL]         assertEquals(1934917632, f.getDenominator()); [EOL]  [EOL]         f1 = Fraction.getFraction(Integer.MIN_VALUE, 3); [EOL]         f2 = Fraction.ONE_THIRD.negate(); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(Integer.MIN_VALUE+1, f.getNumerator()); [EOL]         assertEquals(3, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(Integer.MAX_VALUE, 1); [EOL]         f2 = Fraction.ONE; [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(Integer.MAX_VALUE-1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]  [EOL]         try { [EOL]             f1 = Fraction.getFraction(1, Integer.MAX_VALUE); [EOL]             f2 = Fraction.getFraction(1, Integer.MAX_VALUE - 1); [EOL]             f = f1.subtract(f2); [EOL]             fail("expecting ArithmeticException");  //should overflow [EOL]         } catch (final ArithmeticException ex) {} [EOL]              [EOL]         // denominator should not be a multiple of 2 or 3 to trigger overflow [EOL]         f1 = Fraction.getFraction(Integer.MIN_VALUE, 5); [EOL]         f2 = Fraction.getFraction(1,5); [EOL]         try { [EOL]             f = f1.subtract(f2); // should overflow [EOL]             fail("expecting ArithmeticException but got: " + f.toString()); [EOL]         } catch (final ArithmeticException ex) {} [EOL]          [EOL]         try { [EOL]             f= Fraction.getFraction(Integer.MIN_VALUE, 1); [EOL]             f = f.subtract(Fraction.ONE); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]              [EOL]         try { [EOL]             f= Fraction.getFraction(Integer.MAX_VALUE, 1); [EOL]             f = f.subtract(Fraction.ONE.negate()); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]              [EOL]         f1 = Fraction.getFraction(3,327680); [EOL]         f2 = Fraction.getFraction(2,59049); [EOL]         try { [EOL]             f = f1.subtract(f2); // should overflow [EOL]             fail("expecting ArithmeticException but got: " + f.toString()); [EOL]         } catch (final ArithmeticException ex) {} [EOL]     } [EOL]              [EOL]
@Test [EOL]     public void testSubtract() { [EOL]         Fraction f = null; [EOL]         Fraction f1 = null; [EOL]         Fraction f2 = null; [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(1, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(2, f.getNumerator()); [EOL]         assertEquals(5, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(7, 5); [EOL]         f2 = Fraction.getFraction(2, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(3, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(-4, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(7, f.getNumerator()); [EOL]         assertEquals(5, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(0, 5); [EOL]         f2 = Fraction.getFraction(4, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(-4, f.getNumerator()); [EOL]         assertEquals(5, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(0, 5); [EOL]         f2 = Fraction.getFraction(-4, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(4, f.getNumerator()); [EOL]         assertEquals(5, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(1, 2); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(10, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(0, 5); [EOL]         f2 = Fraction.getFraction(1, 5); [EOL]         f = f2.subtract(f1); [EOL]         assertSame(f2, f); [EOL]          [EOL]         try { [EOL]             f.subtract(null); [EOL]             fail("expecting IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]          [EOL]         // if this fraction is subtracted naively, it will overflow. [EOL]         // check that it doesn't. [EOL]         f1 = Fraction.getFraction(1,32768*3); [EOL]         f2 = Fraction.getFraction(1,59049); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(-13085, f.getNumerator()); [EOL]         assertEquals(1934917632, f.getDenominator()); [EOL]  [EOL]         f1 = Fraction.getFraction(Integer.MIN_VALUE, 3); [EOL]         f2 = Fraction.ONE_THIRD.negate(); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(Integer.MIN_VALUE+1, f.getNumerator()); [EOL]         assertEquals(3, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(Integer.MAX_VALUE, 1); [EOL]         f2 = Fraction.ONE; [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(Integer.MAX_VALUE-1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]  [EOL]         try { [EOL]             f1 = Fraction.getFraction(1, Integer.MAX_VALUE); [EOL]             f2 = Fraction.getFraction(1, Integer.MAX_VALUE - 1); [EOL]             f = f1.subtract(f2); [EOL]             fail("expecting ArithmeticException");  //should overflow [EOL]         } catch (final ArithmeticException ex) {} [EOL]              [EOL]         // denominator should not be a multiple of 2 or 3 to trigger overflow [EOL]         f1 = Fraction.getFraction(Integer.MIN_VALUE, 5); [EOL]         f2 = Fraction.getFraction(1,5); [EOL]         try { [EOL]             f = f1.subtract(f2); // should overflow [EOL]             fail("expecting ArithmeticException but got: " + f.toString()); [EOL]         } catch (final ArithmeticException ex) {} [EOL]          [EOL]         try { [EOL]             f= Fraction.getFraction(Integer.MIN_VALUE, 1); [EOL]             f = f.subtract(Fraction.ONE); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]              [EOL]         try { [EOL]             f= Fraction.getFraction(Integer.MAX_VALUE, 1); [EOL]             f = f.subtract(Fraction.ONE.negate()); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]              [EOL]         f1 = Fraction.getFraction(3,327680); [EOL]         f2 = Fraction.getFraction(2,59049); [EOL]         try { [EOL]             f = f1.subtract(f2); // should overflow [EOL]             fail("expecting ArithmeticException but got: " + f.toString()); [EOL]         } catch (final ArithmeticException ex) {} [EOL]     } [EOL]              [EOL]
@Test [EOL]     public void testToProperString() { [EOL]         Fraction f = null; [EOL]  [EOL]         f = Fraction.getFraction(3, 5); [EOL]         final String str = f.toProperString(); [EOL]         assertEquals("3/5", str); [EOL]         assertSame(str, f.toProperString()); [EOL]          [EOL]         f = Fraction.getFraction(7, 5); [EOL]         assertEquals("1 2/5", f.toProperString());         [EOL]          [EOL]         f = Fraction.getFraction(14, 10); [EOL]         assertEquals("1 4/10", f.toProperString());         [EOL]          [EOL]         f = Fraction.getFraction(4, 2); [EOL]         assertEquals("2", f.toProperString());         [EOL]          [EOL]         f = Fraction.getFraction(0, 2); [EOL]         assertEquals("0", f.toProperString());         [EOL]          [EOL]         f = Fraction.getFraction(2, 2); [EOL]         assertEquals("1", f.toProperString());         [EOL]          [EOL]         f = Fraction.getFraction(-7, 5); [EOL]         assertEquals("-1 2/5", f.toProperString());         [EOL]  [EOL]         f = Fraction.getFraction(Integer.MIN_VALUE, 0, 1); [EOL]         assertEquals("-2147483648", f.toProperString());         [EOL]  [EOL]         f = Fraction.getFraction(-1, 1, Integer.MAX_VALUE); [EOL]         assertEquals("-1 1/2147483647", f.toProperString()); [EOL]  [EOL]         assertEquals("-1", Fraction.getFraction(-1).toProperString()); [EOL]     } [EOL] } [EOL]
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals(0x0, Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals(0x8, Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals(0x4, Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals(0xC, Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals(0x2, Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals(0xA, Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals(0x6, Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals(0xE, Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals(0x1, Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals(0x9, Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('a')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('b')); [EOL]         assertEquals(0x3, Conversion.hexDigitMsb0ToInt('C')); [EOL]         assertEquals(0x3, Conversion.hexDigitMsb0ToInt('c')); [EOL]         assertEquals(0xB, Conversion.hexDigitMsb0ToInt('D')); [EOL]         assertEquals(0xB, Conversion.hexDigitMsb0ToInt('d')); [EOL]         assertEquals(0x7, Conversion.hexDigitMsb0ToInt('E')); [EOL]         assertEquals(0x7, Conversion.hexDigitMsb0ToInt('e')); [EOL]         assertEquals(0xF, Conversion.hexDigitMsb0ToInt('F')); [EOL]         assertEquals(0xF, Conversion.hexDigitMsb0ToInt('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToInt('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#hexDigitToBinary(char)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals(0x0, Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals(0x8, Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals(0x4, Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals(0xC, Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals(0x2, Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals(0xA, Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals(0x6, Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals(0xE, Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals(0x1, Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals(0x9, Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('a')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('b')); [EOL]         assertEquals(0x3, Conversion.hexDigitMsb0ToInt('C')); [EOL]         assertEquals(0x3, Conversion.hexDigitMsb0ToInt('c')); [EOL]         assertEquals(0xB, Conversion.hexDigitMsb0ToInt('D')); [EOL]         assertEquals(0xB, Conversion.hexDigitMsb0ToInt('d')); [EOL]         assertEquals(0x7, Conversion.hexDigitMsb0ToInt('E')); [EOL]         assertEquals(0x7, Conversion.hexDigitMsb0ToInt('e')); [EOL]         assertEquals(0xF, Conversion.hexDigitMsb0ToInt('F')); [EOL]         assertEquals(0xF, Conversion.hexDigitMsb0ToInt('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToInt('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#hexDigitToBinary(char)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals(0x0, Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals(0x8, Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals(0x4, Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals(0xC, Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals(0x2, Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals(0xA, Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals(0x6, Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals(0xE, Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals(0x1, Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals(0x9, Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('a')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('b')); [EOL]         assertEquals(0x3, Conversion.hexDigitMsb0ToInt('C')); [EOL]         assertEquals(0x3, Conversion.hexDigitMsb0ToInt('c')); [EOL]         assertEquals(0xB, Conversion.hexDigitMsb0ToInt('D')); [EOL]         assertEquals(0xB, Conversion.hexDigitMsb0ToInt('d')); [EOL]         assertEquals(0x7, Conversion.hexDigitMsb0ToInt('E')); [EOL]         assertEquals(0x7, Conversion.hexDigitMsb0ToInt('e')); [EOL]         assertEquals(0xF, Conversion.hexDigitMsb0ToInt('F')); [EOL]         assertEquals(0xF, Conversion.hexDigitMsb0ToInt('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToInt('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#hexDigitToBinary(char)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals(0x0, Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals(0x8, Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals(0x4, Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals(0xC, Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals(0x2, Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals(0xA, Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals(0x6, Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals(0xE, Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals(0x1, Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals(0x9, Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('a')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('b')); [EOL]         assertEquals(0x3, Conversion.hexDigitMsb0ToInt('C')); [EOL]         assertEquals(0x3, Conversion.hexDigitMsb0ToInt('c')); [EOL]         assertEquals(0xB, Conversion.hexDigitMsb0ToInt('D')); [EOL]         assertEquals(0xB, Conversion.hexDigitMsb0ToInt('d')); [EOL]         assertEquals(0x7, Conversion.hexDigitMsb0ToInt('E')); [EOL]         assertEquals(0x7, Conversion.hexDigitMsb0ToInt('e')); [EOL]         assertEquals(0xF, Conversion.hexDigitMsb0ToInt('F')); [EOL]         assertEquals(0xF, Conversion.hexDigitMsb0ToInt('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToInt('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#hexDigitToBinary(char)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals(0x0, Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals(0x8, Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals(0x4, Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals(0xC, Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals(0x2, Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals(0xA, Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals(0x6, Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals(0xE, Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals(0x1, Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals(0x9, Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('a')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('b')); [EOL]         assertEquals(0x3, Conversion.hexDigitMsb0ToInt('C')); [EOL]         assertEquals(0x3, Conversion.hexDigitMsb0ToInt('c')); [EOL]         assertEquals(0xB, Conversion.hexDigitMsb0ToInt('D')); [EOL]         assertEquals(0xB, Conversion.hexDigitMsb0ToInt('d')); [EOL]         assertEquals(0x7, Conversion.hexDigitMsb0ToInt('E')); [EOL]         assertEquals(0x7, Conversion.hexDigitMsb0ToInt('e')); [EOL]         assertEquals(0xF, Conversion.hexDigitMsb0ToInt('F')); [EOL]         assertEquals(0xF, Conversion.hexDigitMsb0ToInt('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToInt('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#hexDigitToBinary(char)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals(0x0, Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals(0x8, Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals(0x4, Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals(0xC, Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals(0x2, Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals(0xA, Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals(0x6, Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals(0xE, Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals(0x1, Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals(0x9, Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('a')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('b')); [EOL]         assertEquals(0x3, Conversion.hexDigitMsb0ToInt('C')); [EOL]         assertEquals(0x3, Conversion.hexDigitMsb0ToInt('c')); [EOL]         assertEquals(0xB, Conversion.hexDigitMsb0ToInt('D')); [EOL]         assertEquals(0xB, Conversion.hexDigitMsb0ToInt('d')); [EOL]         assertEquals(0x7, Conversion.hexDigitMsb0ToInt('E')); [EOL]         assertEquals(0x7, Conversion.hexDigitMsb0ToInt('e')); [EOL]         assertEquals(0xF, Conversion.hexDigitMsb0ToInt('F')); [EOL]         assertEquals(0xF, Conversion.hexDigitMsb0ToInt('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToInt('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#hexDigitToBinary(char)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals(0x0, Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals(0x8, Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals(0x4, Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals(0xC, Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals(0x2, Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals(0xA, Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals(0x6, Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals(0xE, Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals(0x1, Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals(0x9, Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('a')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('b')); [EOL]         assertEquals(0x3, Conversion.hexDigitMsb0ToInt('C')); [EOL]         assertEquals(0x3, Conversion.hexDigitMsb0ToInt('c')); [EOL]         assertEquals(0xB, Conversion.hexDigitMsb0ToInt('D')); [EOL]         assertEquals(0xB, Conversion.hexDigitMsb0ToInt('d')); [EOL]         assertEquals(0x7, Conversion.hexDigitMsb0ToInt('E')); [EOL]         assertEquals(0x7, Conversion.hexDigitMsb0ToInt('e')); [EOL]         assertEquals(0xF, Conversion.hexDigitMsb0ToInt('F')); [EOL]         assertEquals(0xF, Conversion.hexDigitMsb0ToInt('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToInt('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#hexDigitToBinary(char)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals(0x0, Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals(0x8, Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals(0x4, Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals(0xC, Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals(0x2, Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals(0xA, Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals(0x6, Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals(0xE, Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals(0x1, Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals(0x9, Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('a')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('b')); [EOL]         assertEquals(0x3, Conversion.hexDigitMsb0ToInt('C')); [EOL]         assertEquals(0x3, Conversion.hexDigitMsb0ToInt('c')); [EOL]         assertEquals(0xB, Conversion.hexDigitMsb0ToInt('D')); [EOL]         assertEquals(0xB, Conversion.hexDigitMsb0ToInt('d')); [EOL]         assertEquals(0x7, Conversion.hexDigitMsb0ToInt('E')); [EOL]         assertEquals(0x7, Conversion.hexDigitMsb0ToInt('e')); [EOL]         assertEquals(0xF, Conversion.hexDigitMsb0ToInt('F')); [EOL]         assertEquals(0xF, Conversion.hexDigitMsb0ToInt('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToInt('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#hexDigitToBinary(char)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals(0x0, Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals(0x8, Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals(0x4, Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals(0xC, Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals(0x2, Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals(0xA, Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals(0x6, Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals(0xE, Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals(0x1, Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals(0x9, Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('a')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('b')); [EOL]         assertEquals(0x3, Conversion.hexDigitMsb0ToInt('C')); [EOL]         assertEquals(0x3, Conversion.hexDigitMsb0ToInt('c')); [EOL]         assertEquals(0xB, Conversion.hexDigitMsb0ToInt('D')); [EOL]         assertEquals(0xB, Conversion.hexDigitMsb0ToInt('d')); [EOL]         assertEquals(0x7, Conversion.hexDigitMsb0ToInt('E')); [EOL]         assertEquals(0x7, Conversion.hexDigitMsb0ToInt('e')); [EOL]         assertEquals(0xF, Conversion.hexDigitMsb0ToInt('F')); [EOL]         assertEquals(0xF, Conversion.hexDigitMsb0ToInt('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToInt('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#hexDigitToBinary(char)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals(0x0, Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals(0x8, Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals(0x4, Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals(0xC, Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals(0x2, Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals(0xA, Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals(0x6, Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals(0xE, Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals(0x1, Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals(0x9, Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('a')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('b')); [EOL]         assertEquals(0x3, Conversion.hexDigitMsb0ToInt('C')); [EOL]         assertEquals(0x3, Conversion.hexDigitMsb0ToInt('c')); [EOL]         assertEquals(0xB, Conversion.hexDigitMsb0ToInt('D')); [EOL]         assertEquals(0xB, Conversion.hexDigitMsb0ToInt('d')); [EOL]         assertEquals(0x7, Conversion.hexDigitMsb0ToInt('E')); [EOL]         assertEquals(0x7, Conversion.hexDigitMsb0ToInt('e')); [EOL]         assertEquals(0xF, Conversion.hexDigitMsb0ToInt('F')); [EOL]         assertEquals(0xF, Conversion.hexDigitMsb0ToInt('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToInt('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#hexDigitToBinary(char)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals(0x0, Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals(0x8, Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals(0x4, Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals(0xC, Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals(0x2, Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals(0xA, Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals(0x6, Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals(0xE, Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals(0x1, Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals(0x9, Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('a')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('b')); [EOL]         assertEquals(0x3, Conversion.hexDigitMsb0ToInt('C')); [EOL]         assertEquals(0x3, Conversion.hexDigitMsb0ToInt('c')); [EOL]         assertEquals(0xB, Conversion.hexDigitMsb0ToInt('D')); [EOL]         assertEquals(0xB, Conversion.hexDigitMsb0ToInt('d')); [EOL]         assertEquals(0x7, Conversion.hexDigitMsb0ToInt('E')); [EOL]         assertEquals(0x7, Conversion.hexDigitMsb0ToInt('e')); [EOL]         assertEquals(0xF, Conversion.hexDigitMsb0ToInt('F')); [EOL]         assertEquals(0xF, Conversion.hexDigitMsb0ToInt('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToInt('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#hexDigitToBinary(char)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals(0x0, Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals(0x8, Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals(0x4, Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals(0xC, Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals(0x2, Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals(0xA, Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals(0x6, Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals(0xE, Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals(0x1, Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals(0x9, Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('a')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('b')); [EOL]         assertEquals(0x3, Conversion.hexDigitMsb0ToInt('C')); [EOL]         assertEquals(0x3, Conversion.hexDigitMsb0ToInt('c')); [EOL]         assertEquals(0xB, Conversion.hexDigitMsb0ToInt('D')); [EOL]         assertEquals(0xB, Conversion.hexDigitMsb0ToInt('d')); [EOL]         assertEquals(0x7, Conversion.hexDigitMsb0ToInt('E')); [EOL]         assertEquals(0x7, Conversion.hexDigitMsb0ToInt('e')); [EOL]         assertEquals(0xF, Conversion.hexDigitMsb0ToInt('F')); [EOL]         assertEquals(0xF, Conversion.hexDigitMsb0ToInt('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToInt('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#hexDigitToBinary(char)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals(0x0, Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals(0x8, Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals(0x4, Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals(0xC, Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals(0x2, Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals(0xA, Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals(0x6, Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals(0xE, Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals(0x1, Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals(0x9, Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('a')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('b')); [EOL]         assertEquals(0x3, Conversion.hexDigitMsb0ToInt('C')); [EOL]         assertEquals(0x3, Conversion.hexDigitMsb0ToInt('c')); [EOL]         assertEquals(0xB, Conversion.hexDigitMsb0ToInt('D')); [EOL]         assertEquals(0xB, Conversion.hexDigitMsb0ToInt('d')); [EOL]         assertEquals(0x7, Conversion.hexDigitMsb0ToInt('E')); [EOL]         assertEquals(0x7, Conversion.hexDigitMsb0ToInt('e')); [EOL]         assertEquals(0xF, Conversion.hexDigitMsb0ToInt('F')); [EOL]         assertEquals(0xF, Conversion.hexDigitMsb0ToInt('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToInt('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#hexDigitToBinary(char)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals(0x0, Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals(0x8, Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals(0x4, Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals(0xC, Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals(0x2, Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals(0xA, Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals(0x6, Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals(0xE, Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals(0x1, Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals(0x9, Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('a')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('b')); [EOL]         assertEquals(0x3, Conversion.hexDigitMsb0ToInt('C')); [EOL]         assertEquals(0x3, Conversion.hexDigitMsb0ToInt('c')); [EOL]         assertEquals(0xB, Conversion.hexDigitMsb0ToInt('D')); [EOL]         assertEquals(0xB, Conversion.hexDigitMsb0ToInt('d')); [EOL]         assertEquals(0x7, Conversion.hexDigitMsb0ToInt('E')); [EOL]         assertEquals(0x7, Conversion.hexDigitMsb0ToInt('e')); [EOL]         assertEquals(0xF, Conversion.hexDigitMsb0ToInt('F')); [EOL]         assertEquals(0xF, Conversion.hexDigitMsb0ToInt('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToInt('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#hexDigitToBinary(char)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals(0x0, Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals(0x8, Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals(0x4, Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals(0xC, Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals(0x2, Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals(0xA, Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals(0x6, Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals(0xE, Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals(0x1, Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals(0x9, Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('a')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('b')); [EOL]         assertEquals(0x3, Conversion.hexDigitMsb0ToInt('C')); [EOL]         assertEquals(0x3, Conversion.hexDigitMsb0ToInt('c')); [EOL]         assertEquals(0xB, Conversion.hexDigitMsb0ToInt('D')); [EOL]         assertEquals(0xB, Conversion.hexDigitMsb0ToInt('d')); [EOL]         assertEquals(0x7, Conversion.hexDigitMsb0ToInt('E')); [EOL]         assertEquals(0x7, Conversion.hexDigitMsb0ToInt('e')); [EOL]         assertEquals(0xF, Conversion.hexDigitMsb0ToInt('F')); [EOL]         assertEquals(0xF, Conversion.hexDigitMsb0ToInt('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToInt('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#hexDigitToBinary(char)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals(0x0, Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals(0x8, Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals(0x4, Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals(0xC, Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals(0x2, Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals(0xA, Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals(0x6, Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals(0xE, Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals(0x1, Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals(0x9, Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('a')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('b')); [EOL]         assertEquals(0x3, Conversion.hexDigitMsb0ToInt('C')); [EOL]         assertEquals(0x3, Conversion.hexDigitMsb0ToInt('c')); [EOL]         assertEquals(0xB, Conversion.hexDigitMsb0ToInt('D')); [EOL]         assertEquals(0xB, Conversion.hexDigitMsb0ToInt('d')); [EOL]         assertEquals(0x7, Conversion.hexDigitMsb0ToInt('E')); [EOL]         assertEquals(0x7, Conversion.hexDigitMsb0ToInt('e')); [EOL]         assertEquals(0xF, Conversion.hexDigitMsb0ToInt('F')); [EOL]         assertEquals(0xF, Conversion.hexDigitMsb0ToInt('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToInt('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#hexDigitToBinary(char)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals(0x0, Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals(0x8, Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals(0x4, Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals(0xC, Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals(0x2, Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals(0xA, Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals(0x6, Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals(0xE, Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals(0x1, Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals(0x9, Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('a')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('b')); [EOL]         assertEquals(0x3, Conversion.hexDigitMsb0ToInt('C')); [EOL]         assertEquals(0x3, Conversion.hexDigitMsb0ToInt('c')); [EOL]         assertEquals(0xB, Conversion.hexDigitMsb0ToInt('D')); [EOL]         assertEquals(0xB, Conversion.hexDigitMsb0ToInt('d')); [EOL]         assertEquals(0x7, Conversion.hexDigitMsb0ToInt('E')); [EOL]         assertEquals(0x7, Conversion.hexDigitMsb0ToInt('e')); [EOL]         assertEquals(0xF, Conversion.hexDigitMsb0ToInt('F')); [EOL]         assertEquals(0xF, Conversion.hexDigitMsb0ToInt('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToInt('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#hexDigitToBinary(char)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals(0x0, Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals(0x8, Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals(0x4, Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals(0xC, Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals(0x2, Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals(0xA, Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals(0x6, Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals(0xE, Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals(0x1, Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals(0x9, Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('a')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('b')); [EOL]         assertEquals(0x3, Conversion.hexDigitMsb0ToInt('C')); [EOL]         assertEquals(0x3, Conversion.hexDigitMsb0ToInt('c')); [EOL]         assertEquals(0xB, Conversion.hexDigitMsb0ToInt('D')); [EOL]         assertEquals(0xB, Conversion.hexDigitMsb0ToInt('d')); [EOL]         assertEquals(0x7, Conversion.hexDigitMsb0ToInt('E')); [EOL]         assertEquals(0x7, Conversion.hexDigitMsb0ToInt('e')); [EOL]         assertEquals(0xF, Conversion.hexDigitMsb0ToInt('F')); [EOL]         assertEquals(0xF, Conversion.hexDigitMsb0ToInt('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToInt('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#hexDigitToBinary(char)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals(0x0, Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals(0x8, Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals(0x4, Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals(0xC, Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals(0x2, Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals(0xA, Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals(0x6, Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals(0xE, Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals(0x1, Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals(0x9, Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('a')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('b')); [EOL]         assertEquals(0x3, Conversion.hexDigitMsb0ToInt('C')); [EOL]         assertEquals(0x3, Conversion.hexDigitMsb0ToInt('c')); [EOL]         assertEquals(0xB, Conversion.hexDigitMsb0ToInt('D')); [EOL]         assertEquals(0xB, Conversion.hexDigitMsb0ToInt('d')); [EOL]         assertEquals(0x7, Conversion.hexDigitMsb0ToInt('E')); [EOL]         assertEquals(0x7, Conversion.hexDigitMsb0ToInt('e')); [EOL]         assertEquals(0xF, Conversion.hexDigitMsb0ToInt('F')); [EOL]         assertEquals(0xF, Conversion.hexDigitMsb0ToInt('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToInt('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#hexDigitToBinary(char)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals(0x0, Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals(0x8, Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals(0x4, Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals(0xC, Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals(0x2, Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals(0xA, Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals(0x6, Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals(0xE, Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals(0x1, Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals(0x9, Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('a')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('b')); [EOL]         assertEquals(0x3, Conversion.hexDigitMsb0ToInt('C')); [EOL]         assertEquals(0x3, Conversion.hexDigitMsb0ToInt('c')); [EOL]         assertEquals(0xB, Conversion.hexDigitMsb0ToInt('D')); [EOL]         assertEquals(0xB, Conversion.hexDigitMsb0ToInt('d')); [EOL]         assertEquals(0x7, Conversion.hexDigitMsb0ToInt('E')); [EOL]         assertEquals(0x7, Conversion.hexDigitMsb0ToInt('e')); [EOL]         assertEquals(0xF, Conversion.hexDigitMsb0ToInt('F')); [EOL]         assertEquals(0xF, Conversion.hexDigitMsb0ToInt('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToInt('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#hexDigitToBinary(char)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals(0x0, Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals(0x8, Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals(0x4, Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals(0xC, Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals(0x2, Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals(0xA, Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals(0x6, Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals(0xE, Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals(0x1, Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals(0x9, Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('a')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('b')); [EOL]         assertEquals(0x3, Conversion.hexDigitMsb0ToInt('C')); [EOL]         assertEquals(0x3, Conversion.hexDigitMsb0ToInt('c')); [EOL]         assertEquals(0xB, Conversion.hexDigitMsb0ToInt('D')); [EOL]         assertEquals(0xB, Conversion.hexDigitMsb0ToInt('d')); [EOL]         assertEquals(0x7, Conversion.hexDigitMsb0ToInt('E')); [EOL]         assertEquals(0x7, Conversion.hexDigitMsb0ToInt('e')); [EOL]         assertEquals(0xF, Conversion.hexDigitMsb0ToInt('F')); [EOL]         assertEquals(0xF, Conversion.hexDigitMsb0ToInt('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToInt('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#hexDigitToBinary(char)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals(0x0, Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals(0x8, Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals(0x4, Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals(0xC, Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals(0x2, Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals(0xA, Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals(0x6, Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals(0xE, Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals(0x1, Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals(0x9, Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('a')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('b')); [EOL]         assertEquals(0x3, Conversion.hexDigitMsb0ToInt('C')); [EOL]         assertEquals(0x3, Conversion.hexDigitMsb0ToInt('c')); [EOL]         assertEquals(0xB, Conversion.hexDigitMsb0ToInt('D')); [EOL]         assertEquals(0xB, Conversion.hexDigitMsb0ToInt('d')); [EOL]         assertEquals(0x7, Conversion.hexDigitMsb0ToInt('E')); [EOL]         assertEquals(0x7, Conversion.hexDigitMsb0ToInt('e')); [EOL]         assertEquals(0xF, Conversion.hexDigitMsb0ToInt('F')); [EOL]         assertEquals(0xF, Conversion.hexDigitMsb0ToInt('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToInt('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#hexDigitToBinary(char)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals(0x0, Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals(0x8, Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals(0x4, Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals(0xC, Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals(0x2, Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals(0xA, Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals(0x6, Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals(0xE, Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals(0x1, Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals(0x9, Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('a')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('b')); [EOL]         assertEquals(0x3, Conversion.hexDigitMsb0ToInt('C')); [EOL]         assertEquals(0x3, Conversion.hexDigitMsb0ToInt('c')); [EOL]         assertEquals(0xB, Conversion.hexDigitMsb0ToInt('D')); [EOL]         assertEquals(0xB, Conversion.hexDigitMsb0ToInt('d')); [EOL]         assertEquals(0x7, Conversion.hexDigitMsb0ToInt('E')); [EOL]         assertEquals(0x7, Conversion.hexDigitMsb0ToInt('e')); [EOL]         assertEquals(0xF, Conversion.hexDigitMsb0ToInt('F')); [EOL]         assertEquals(0xF, Conversion.hexDigitMsb0ToInt('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToInt('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#hexDigitToBinary(char)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals(0x0, Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals(0x8, Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals(0x4, Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals(0xC, Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals(0x2, Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals(0xA, Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals(0x6, Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals(0xE, Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals(0x1, Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals(0x9, Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('a')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('b')); [EOL]         assertEquals(0x3, Conversion.hexDigitMsb0ToInt('C')); [EOL]         assertEquals(0x3, Conversion.hexDigitMsb0ToInt('c')); [EOL]         assertEquals(0xB, Conversion.hexDigitMsb0ToInt('D')); [EOL]         assertEquals(0xB, Conversion.hexDigitMsb0ToInt('d')); [EOL]         assertEquals(0x7, Conversion.hexDigitMsb0ToInt('E')); [EOL]         assertEquals(0x7, Conversion.hexDigitMsb0ToInt('e')); [EOL]         assertEquals(0xF, Conversion.hexDigitMsb0ToInt('F')); [EOL]         assertEquals(0xF, Conversion.hexDigitMsb0ToInt('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToInt('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#hexDigitToBinary(char)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitToBinary('B')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitToBinary('b')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitToBinary('C')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitToBinary('c')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitToBinary('D')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitToBinary('d')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitToBinary('E')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitToBinary('e')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitToBinary('F')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitToBinary('f')); [EOL]         try { [EOL]             Conversion.hexDigitToBinary('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#hexDigitMsb0ToBinary(char)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitToBinary('B')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitToBinary('b')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitToBinary('C')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitToBinary('c')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitToBinary('D')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitToBinary('d')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitToBinary('E')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitToBinary('e')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitToBinary('F')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitToBinary('f')); [EOL]         try { [EOL]             Conversion.hexDigitToBinary('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#hexDigitMsb0ToBinary(char)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitToBinary('B')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitToBinary('b')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitToBinary('C')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitToBinary('c')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitToBinary('D')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitToBinary('d')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitToBinary('E')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitToBinary('e')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitToBinary('F')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitToBinary('f')); [EOL]         try { [EOL]             Conversion.hexDigitToBinary('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#hexDigitMsb0ToBinary(char)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitToBinary('B')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitToBinary('b')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitToBinary('C')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitToBinary('c')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitToBinary('D')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitToBinary('d')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitToBinary('E')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitToBinary('e')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitToBinary('F')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitToBinary('f')); [EOL]         try { [EOL]             Conversion.hexDigitToBinary('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#hexDigitMsb0ToBinary(char)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitToBinary('B')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitToBinary('b')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitToBinary('C')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitToBinary('c')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitToBinary('D')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitToBinary('d')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitToBinary('E')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitToBinary('e')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitToBinary('F')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitToBinary('f')); [EOL]         try { [EOL]             Conversion.hexDigitToBinary('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#hexDigitMsb0ToBinary(char)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitToBinary('B')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitToBinary('b')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitToBinary('C')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitToBinary('c')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitToBinary('D')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitToBinary('d')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitToBinary('E')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitToBinary('e')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitToBinary('F')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitToBinary('f')); [EOL]         try { [EOL]             Conversion.hexDigitToBinary('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#hexDigitMsb0ToBinary(char)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitToBinary('B')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitToBinary('b')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitToBinary('C')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitToBinary('c')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitToBinary('D')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitToBinary('d')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitToBinary('E')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitToBinary('e')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitToBinary('F')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitToBinary('f')); [EOL]         try { [EOL]             Conversion.hexDigitToBinary('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#hexDigitMsb0ToBinary(char)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitToBinary('B')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitToBinary('b')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitToBinary('C')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitToBinary('c')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitToBinary('D')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitToBinary('d')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitToBinary('E')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitToBinary('e')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitToBinary('F')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitToBinary('f')); [EOL]         try { [EOL]             Conversion.hexDigitToBinary('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#hexDigitMsb0ToBinary(char)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitToBinary('B')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitToBinary('b')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitToBinary('C')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitToBinary('c')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitToBinary('D')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitToBinary('d')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitToBinary('E')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitToBinary('e')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitToBinary('F')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitToBinary('f')); [EOL]         try { [EOL]             Conversion.hexDigitToBinary('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#hexDigitMsb0ToBinary(char)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitToBinary('B')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitToBinary('b')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitToBinary('C')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitToBinary('c')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitToBinary('D')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitToBinary('d')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitToBinary('E')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitToBinary('e')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitToBinary('F')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitToBinary('f')); [EOL]         try { [EOL]             Conversion.hexDigitToBinary('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#hexDigitMsb0ToBinary(char)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitToBinary('B')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitToBinary('b')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitToBinary('C')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitToBinary('c')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitToBinary('D')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitToBinary('d')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitToBinary('E')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitToBinary('e')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitToBinary('F')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitToBinary('f')); [EOL]         try { [EOL]             Conversion.hexDigitToBinary('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#hexDigitMsb0ToBinary(char)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitToBinary('B')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitToBinary('b')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitToBinary('C')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitToBinary('c')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitToBinary('D')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitToBinary('d')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitToBinary('E')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitToBinary('e')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitToBinary('F')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitToBinary('f')); [EOL]         try { [EOL]             Conversion.hexDigitToBinary('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#hexDigitMsb0ToBinary(char)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitToBinary('B')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitToBinary('b')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitToBinary('C')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitToBinary('c')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitToBinary('D')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitToBinary('d')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitToBinary('E')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitToBinary('e')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitToBinary('F')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitToBinary('f')); [EOL]         try { [EOL]             Conversion.hexDigitToBinary('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#hexDigitMsb0ToBinary(char)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitToBinary('B')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitToBinary('b')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitToBinary('C')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitToBinary('c')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitToBinary('D')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitToBinary('d')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitToBinary('E')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitToBinary('e')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitToBinary('F')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitToBinary('f')); [EOL]         try { [EOL]             Conversion.hexDigitToBinary('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#hexDigitMsb0ToBinary(char)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitToBinary('B')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitToBinary('b')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitToBinary('C')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitToBinary('c')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitToBinary('D')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitToBinary('d')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitToBinary('E')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitToBinary('e')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitToBinary('F')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitToBinary('f')); [EOL]         try { [EOL]             Conversion.hexDigitToBinary('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#hexDigitMsb0ToBinary(char)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitToBinary('B')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitToBinary('b')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitToBinary('C')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitToBinary('c')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitToBinary('D')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitToBinary('d')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitToBinary('E')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitToBinary('e')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitToBinary('F')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitToBinary('f')); [EOL]         try { [EOL]             Conversion.hexDigitToBinary('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#hexDigitMsb0ToBinary(char)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitToBinary('B')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitToBinary('b')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitToBinary('C')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitToBinary('c')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitToBinary('D')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitToBinary('d')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitToBinary('E')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitToBinary('e')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitToBinary('F')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitToBinary('f')); [EOL]         try { [EOL]             Conversion.hexDigitToBinary('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#hexDigitMsb0ToBinary(char)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitToBinary('B')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitToBinary('b')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitToBinary('C')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitToBinary('c')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitToBinary('D')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitToBinary('d')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitToBinary('E')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitToBinary('e')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitToBinary('F')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitToBinary('f')); [EOL]         try { [EOL]             Conversion.hexDigitToBinary('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#hexDigitMsb0ToBinary(char)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitToBinary('B')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitToBinary('b')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitToBinary('C')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitToBinary('c')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitToBinary('D')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitToBinary('d')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitToBinary('E')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitToBinary('e')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitToBinary('F')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitToBinary('f')); [EOL]         try { [EOL]             Conversion.hexDigitToBinary('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#hexDigitMsb0ToBinary(char)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitToBinary('B')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitToBinary('b')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitToBinary('C')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitToBinary('c')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitToBinary('D')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitToBinary('d')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitToBinary('E')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitToBinary('e')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitToBinary('F')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitToBinary('f')); [EOL]         try { [EOL]             Conversion.hexDigitToBinary('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#hexDigitMsb0ToBinary(char)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitToBinary('B')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitToBinary('b')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitToBinary('C')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitToBinary('c')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitToBinary('D')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitToBinary('d')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitToBinary('E')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitToBinary('e')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitToBinary('F')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitToBinary('f')); [EOL]         try { [EOL]             Conversion.hexDigitToBinary('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#hexDigitMsb0ToBinary(char)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitToBinary('B')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitToBinary('b')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitToBinary('C')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitToBinary('c')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitToBinary('D')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitToBinary('d')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitToBinary('E')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitToBinary('e')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitToBinary('F')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitToBinary('f')); [EOL]         try { [EOL]             Conversion.hexDigitToBinary('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#hexDigitMsb0ToBinary(char)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitToBinary('B')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitToBinary('b')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitToBinary('C')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitToBinary('c')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitToBinary('D')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitToBinary('d')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitToBinary('E')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitToBinary('e')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitToBinary('F')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitToBinary('f')); [EOL]         try { [EOL]             Conversion.hexDigitToBinary('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#hexDigitMsb0ToBinary(char)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitToBinary('B')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitToBinary('b')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitToBinary('C')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitToBinary('c')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitToBinary('D')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitToBinary('d')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitToBinary('E')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitToBinary('e')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitToBinary('F')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitToBinary('f')); [EOL]         try { [EOL]             Conversion.hexDigitToBinary('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#hexDigitMsb0ToBinary(char)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitToBinary('B')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitToBinary('b')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitToBinary('C')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitToBinary('c')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitToBinary('D')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitToBinary('d')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitToBinary('E')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitToBinary('e')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitToBinary('F')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitToBinary('f')); [EOL]         try { [EOL]             Conversion.hexDigitToBinary('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#hexDigitMsb0ToBinary(char)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitToBinary('B')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitToBinary('b')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitToBinary('C')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitToBinary('c')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitToBinary('D')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitToBinary('d')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitToBinary('E')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitToBinary('e')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitToBinary('F')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitToBinary('f')); [EOL]         try { [EOL]             Conversion.hexDigitToBinary('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#hexDigitMsb0ToBinary(char)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitToBinary('B')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitToBinary('b')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitToBinary('C')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitToBinary('c')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitToBinary('D')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitToBinary('d')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitToBinary('E')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitToBinary('e')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitToBinary('F')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitToBinary('f')); [EOL]         try { [EOL]             Conversion.hexDigitToBinary('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#hexDigitMsb0ToBinary(char)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitToBinary('B')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitToBinary('b')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitToBinary('C')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitToBinary('c')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitToBinary('D')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitToBinary('d')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitToBinary('E')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitToBinary('e')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitToBinary('F')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitToBinary('f')); [EOL]         try { [EOL]             Conversion.hexDigitToBinary('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#hexDigitMsb0ToBinary(char)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitMsb0ToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitMsb0ToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitMsb0ToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitMsb0ToBinary('B')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitMsb0ToBinary('b')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('C')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('c')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('D')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('d')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('E')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('e')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitMsb0ToBinary('F')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitMsb0ToBinary('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToBinary('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#binaryToHexDigit(boolean[])}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitMsb0ToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitMsb0ToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitMsb0ToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitMsb0ToBinary('B')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitMsb0ToBinary('b')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('C')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('c')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('D')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('d')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('E')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('e')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitMsb0ToBinary('F')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitMsb0ToBinary('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToBinary('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#binaryToHexDigit(boolean[])}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitMsb0ToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitMsb0ToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitMsb0ToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitMsb0ToBinary('B')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitMsb0ToBinary('b')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('C')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('c')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('D')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('d')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('E')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('e')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitMsb0ToBinary('F')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitMsb0ToBinary('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToBinary('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#binaryToHexDigit(boolean[])}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitMsb0ToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitMsb0ToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitMsb0ToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitMsb0ToBinary('B')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitMsb0ToBinary('b')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('C')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('c')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('D')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('d')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('E')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('e')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitMsb0ToBinary('F')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitMsb0ToBinary('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToBinary('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#binaryToHexDigit(boolean[])}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitMsb0ToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitMsb0ToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitMsb0ToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitMsb0ToBinary('B')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitMsb0ToBinary('b')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('C')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('c')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('D')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('d')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('E')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('e')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitMsb0ToBinary('F')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitMsb0ToBinary('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToBinary('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#binaryToHexDigit(boolean[])}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitMsb0ToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitMsb0ToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitMsb0ToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitMsb0ToBinary('B')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitMsb0ToBinary('b')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('C')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('c')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('D')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('d')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('E')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('e')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitMsb0ToBinary('F')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitMsb0ToBinary('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToBinary('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#binaryToHexDigit(boolean[])}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitMsb0ToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitMsb0ToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitMsb0ToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitMsb0ToBinary('B')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitMsb0ToBinary('b')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('C')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('c')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('D')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('d')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('E')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('e')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitMsb0ToBinary('F')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitMsb0ToBinary('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToBinary('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#binaryToHexDigit(boolean[])}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitMsb0ToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitMsb0ToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitMsb0ToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitMsb0ToBinary('B')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitMsb0ToBinary('b')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('C')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('c')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('D')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('d')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('E')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('e')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitMsb0ToBinary('F')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitMsb0ToBinary('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToBinary('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#binaryToHexDigit(boolean[])}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitMsb0ToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitMsb0ToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitMsb0ToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitMsb0ToBinary('B')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitMsb0ToBinary('b')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('C')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('c')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('D')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('d')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('E')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('e')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitMsb0ToBinary('F')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitMsb0ToBinary('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToBinary('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#binaryToHexDigit(boolean[])}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitMsb0ToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitMsb0ToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitMsb0ToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitMsb0ToBinary('B')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitMsb0ToBinary('b')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('C')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('c')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('D')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('d')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('E')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('e')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitMsb0ToBinary('F')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitMsb0ToBinary('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToBinary('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#binaryToHexDigit(boolean[])}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitMsb0ToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitMsb0ToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitMsb0ToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitMsb0ToBinary('B')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitMsb0ToBinary('b')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('C')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('c')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('D')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('d')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('E')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('e')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitMsb0ToBinary('F')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitMsb0ToBinary('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToBinary('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#binaryToHexDigit(boolean[])}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitMsb0ToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitMsb0ToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitMsb0ToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitMsb0ToBinary('B')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitMsb0ToBinary('b')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('C')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('c')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('D')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('d')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('E')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('e')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitMsb0ToBinary('F')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitMsb0ToBinary('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToBinary('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#binaryToHexDigit(boolean[])}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitMsb0ToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitMsb0ToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitMsb0ToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitMsb0ToBinary('B')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitMsb0ToBinary('b')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('C')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('c')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('D')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('d')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('E')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('e')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitMsb0ToBinary('F')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitMsb0ToBinary('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToBinary('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#binaryToHexDigit(boolean[])}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitMsb0ToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitMsb0ToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitMsb0ToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitMsb0ToBinary('B')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitMsb0ToBinary('b')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('C')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('c')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('D')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('d')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('E')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('e')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitMsb0ToBinary('F')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitMsb0ToBinary('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToBinary('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#binaryToHexDigit(boolean[])}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitMsb0ToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitMsb0ToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitMsb0ToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitMsb0ToBinary('B')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitMsb0ToBinary('b')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('C')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('c')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('D')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('d')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('E')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('e')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitMsb0ToBinary('F')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitMsb0ToBinary('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToBinary('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#binaryToHexDigit(boolean[])}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitMsb0ToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitMsb0ToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitMsb0ToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitMsb0ToBinary('B')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitMsb0ToBinary('b')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('C')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('c')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('D')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('d')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('E')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('e')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitMsb0ToBinary('F')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitMsb0ToBinary('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToBinary('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#binaryToHexDigit(boolean[])}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitMsb0ToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitMsb0ToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitMsb0ToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitMsb0ToBinary('B')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitMsb0ToBinary('b')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('C')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('c')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('D')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('d')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('E')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('e')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitMsb0ToBinary('F')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitMsb0ToBinary('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToBinary('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#binaryToHexDigit(boolean[])}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitMsb0ToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitMsb0ToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitMsb0ToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitMsb0ToBinary('B')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitMsb0ToBinary('b')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('C')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('c')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('D')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('d')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('E')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('e')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitMsb0ToBinary('F')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitMsb0ToBinary('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToBinary('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#binaryToHexDigit(boolean[])}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitMsb0ToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitMsb0ToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitMsb0ToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitMsb0ToBinary('B')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitMsb0ToBinary('b')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('C')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('c')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('D')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('d')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('E')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('e')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitMsb0ToBinary('F')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitMsb0ToBinary('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToBinary('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#binaryToHexDigit(boolean[])}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitMsb0ToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitMsb0ToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitMsb0ToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitMsb0ToBinary('B')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitMsb0ToBinary('b')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('C')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('c')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('D')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('d')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('E')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('e')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitMsb0ToBinary('F')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitMsb0ToBinary('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToBinary('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#binaryToHexDigit(boolean[])}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitMsb0ToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitMsb0ToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitMsb0ToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitMsb0ToBinary('B')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitMsb0ToBinary('b')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('C')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('c')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('D')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('d')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('E')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('e')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitMsb0ToBinary('F')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitMsb0ToBinary('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToBinary('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#binaryToHexDigit(boolean[])}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitMsb0ToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitMsb0ToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitMsb0ToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitMsb0ToBinary('B')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitMsb0ToBinary('b')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('C')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('c')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('D')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('d')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('E')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('e')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitMsb0ToBinary('F')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitMsb0ToBinary('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToBinary('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#binaryToHexDigit(boolean[])}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitMsb0ToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitMsb0ToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitMsb0ToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitMsb0ToBinary('B')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitMsb0ToBinary('b')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('C')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('c')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('D')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('d')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('E')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('e')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitMsb0ToBinary('F')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitMsb0ToBinary('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToBinary('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#binaryToHexDigit(boolean[])}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitMsb0ToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitMsb0ToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitMsb0ToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitMsb0ToBinary('B')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitMsb0ToBinary('b')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('C')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('c')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('D')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('d')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('E')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('e')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitMsb0ToBinary('F')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitMsb0ToBinary('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToBinary('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#binaryToHexDigit(boolean[])}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitMsb0ToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitMsb0ToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitMsb0ToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitMsb0ToBinary('B')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitMsb0ToBinary('b')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('C')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('c')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('D')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('d')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('E')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('e')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitMsb0ToBinary('F')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitMsb0ToBinary('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToBinary('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#binaryToHexDigit(boolean[])}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitMsb0ToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitMsb0ToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitMsb0ToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitMsb0ToBinary('B')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitMsb0ToBinary('b')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('C')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('c')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('D')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('d')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('E')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('e')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitMsb0ToBinary('F')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitMsb0ToBinary('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToBinary('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#binaryToHexDigit(boolean[])}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitMsb0ToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitMsb0ToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitMsb0ToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitMsb0ToBinary('B')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitMsb0ToBinary('b')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('C')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('c')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('D')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('d')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('E')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('e')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitMsb0ToBinary('F')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitMsb0ToBinary('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToBinary('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#binaryToHexDigit(boolean[])}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitMsb0ToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitMsb0ToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitMsb0ToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitMsb0ToBinary('B')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitMsb0ToBinary('b')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('C')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('c')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('D')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('d')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('E')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('e')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitMsb0ToBinary('F')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitMsb0ToBinary('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToBinary('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#binaryToHexDigit(boolean[])}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitMsb0ToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitMsb0ToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitMsb0ToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitMsb0ToBinary('B')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitMsb0ToBinary('b')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('C')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('c')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('D')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('d')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('E')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('e')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitMsb0ToBinary('F')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitMsb0ToBinary('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToBinary('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#binaryToHexDigit(boolean[])}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitMsb0ToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitMsb0ToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitMsb0ToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitMsb0ToBinary('B')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitMsb0ToBinary('b')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('C')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('c')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('D')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('d')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('E')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('e')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitMsb0ToBinary('F')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitMsb0ToBinary('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToBinary('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#binaryToHexDigit(boolean[])}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitMsb0ToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitMsb0ToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitMsb0ToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitMsb0ToBinary('B')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitMsb0ToBinary('b')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('C')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('c')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('D')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('d')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('E')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('e')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitMsb0ToBinary('F')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitMsb0ToBinary('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToBinary('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#binaryToHexDigit(boolean[])}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, true}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, true}, Conversion.hexDigitMsb0ToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitMsb0ToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitMsb0ToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitMsb0ToBinary('B')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, true}, Conversion.hexDigitMsb0ToBinary('b')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('C')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('c')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('D')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('d')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('E')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('e')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitMsb0ToBinary('F')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, true}, Conversion.hexDigitMsb0ToBinary('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToBinary('G'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#binaryToHexDigit(boolean[])}. [EOL]      */ [EOL]
@Test [EOL]     public void testBinaryToHexDigitMsb0_bits() { [EOL]         assertEquals( [EOL]             '0', [EOL]             Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', [EOL]             Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', [EOL]             Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', [EOL]             Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, false, true})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, true, true})); [EOL]         assertEquals( [EOL]             '8', [EOL]             Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             '9', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, false, true})); [EOL]         assertEquals( [EOL]             'a', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, true, false})); [EOL]         assertEquals( [EOL]             'b', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, true, true})); [EOL]         assertEquals( [EOL]             'c', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, true, false, false})); [EOL]         assertEquals( [EOL]             'd', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, true, false, true})); [EOL]         assertEquals( [EOL]             'e', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, true, true, false})); [EOL]         assertEquals( [EOL]             'f', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, true, true, true})); [EOL]         try { [EOL]             Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{}); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#binaryToHexDigitMsb0_4bits(boolean[], int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testBinaryBeMsb0ToHexDigit() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, true, false, true})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, true, true, true})); [EOL]         assertEquals( [EOL]             '8', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             '9', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{true, false, false, true})); [EOL]         assertEquals( [EOL]             'a', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{true, false, true, false})); [EOL]         assertEquals( [EOL]             'b', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{true, false, true, true})); [EOL]         assertEquals( [EOL]             'c', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{true, true, false, false})); [EOL]         assertEquals( [EOL]             'd', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{true, true, false, true})); [EOL]         assertEquals( [EOL]             'e', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{true, true, true, false})); [EOL]         assertEquals( [EOL]             'f', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{true, true, true, true})); [EOL]         assertEquals( [EOL]             '4', [EOL]             Conversion.binaryBeMsb0ToHexDigit(new boolean[]{ [EOL]                 true, false, false, false, false, false, false, false, false, false, false, [EOL]                 false, false, true, false, false})); [EOL]         try { [EOL]             Conversion.binaryBeMsb0ToHexDigit(new boolean[]{}); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#binaryToHexDigit(boolean[], int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testBinaryBeMsb0ToHexDigit() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, true, false, true})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, true, true, true})); [EOL]         assertEquals( [EOL]             '8', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             '9', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{true, false, false, true})); [EOL]         assertEquals( [EOL]             'a', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{true, false, true, false})); [EOL]         assertEquals( [EOL]             'b', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{true, false, true, true})); [EOL]         assertEquals( [EOL]             'c', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{true, true, false, false})); [EOL]         assertEquals( [EOL]             'd', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{true, true, false, true})); [EOL]         assertEquals( [EOL]             'e', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{true, true, true, false})); [EOL]         assertEquals( [EOL]             'f', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{true, true, true, true})); [EOL]         assertEquals( [EOL]             '4', [EOL]             Conversion.binaryBeMsb0ToHexDigit(new boolean[]{ [EOL]                 true, false, false, false, false, false, false, false, false, false, false, [EOL]                 false, false, true, false, false})); [EOL]         try { [EOL]             Conversion.binaryBeMsb0ToHexDigit(new boolean[]{}); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#binaryToHexDigit(boolean[], int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testBinaryBeMsb0ToHexDigit() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, true, false, true})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, true, true, true})); [EOL]         assertEquals( [EOL]             '8', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             '9', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{true, false, false, true})); [EOL]         assertEquals( [EOL]             'a', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{true, false, true, false})); [EOL]         assertEquals( [EOL]             'b', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{true, false, true, true})); [EOL]         assertEquals( [EOL]             'c', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{true, true, false, false})); [EOL]         assertEquals( [EOL]             'd', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{true, true, false, true})); [EOL]         assertEquals( [EOL]             'e', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{true, true, true, false})); [EOL]         assertEquals( [EOL]             'f', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{true, true, true, true})); [EOL]         assertEquals( [EOL]             '4', [EOL]             Conversion.binaryBeMsb0ToHexDigit(new boolean[]{ [EOL]                 true, false, false, false, false, false, false, false, false, false, false, [EOL]                 false, false, true, false, false})); [EOL]         try { [EOL]             Conversion.binaryBeMsb0ToHexDigit(new boolean[]{}); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#binaryToHexDigit(boolean[], int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testBinaryBeMsb0ToHexDigit() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, true, false, true})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, true, true, true})); [EOL]         assertEquals( [EOL]             '8', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             '9', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{true, false, false, true})); [EOL]         assertEquals( [EOL]             'a', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{true, false, true, false})); [EOL]         assertEquals( [EOL]             'b', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{true, false, true, true})); [EOL]         assertEquals( [EOL]             'c', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{true, true, false, false})); [EOL]         assertEquals( [EOL]             'd', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{true, true, false, true})); [EOL]         assertEquals( [EOL]             'e', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{true, true, true, false})); [EOL]         assertEquals( [EOL]             'f', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{true, true, true, true})); [EOL]         assertEquals( [EOL]             '4', [EOL]             Conversion.binaryBeMsb0ToHexDigit(new boolean[]{ [EOL]                 true, false, false, false, false, false, false, false, false, false, false, [EOL]                 false, false, true, false, false})); [EOL]         try { [EOL]             Conversion.binaryBeMsb0ToHexDigit(new boolean[]{}); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#binaryToHexDigit(boolean[], int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testBinaryBeMsb0ToHexDigit() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, true, false, true})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, true, true, true})); [EOL]         assertEquals( [EOL]             '8', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             '9', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{true, false, false, true})); [EOL]         assertEquals( [EOL]             'a', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{true, false, true, false})); [EOL]         assertEquals( [EOL]             'b', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{true, false, true, true})); [EOL]         assertEquals( [EOL]             'c', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{true, true, false, false})); [EOL]         assertEquals( [EOL]             'd', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{true, true, false, true})); [EOL]         assertEquals( [EOL]             'e', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{true, true, true, false})); [EOL]         assertEquals( [EOL]             'f', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{true, true, true, true})); [EOL]         assertEquals( [EOL]             '4', [EOL]             Conversion.binaryBeMsb0ToHexDigit(new boolean[]{ [EOL]                 true, false, false, false, false, false, false, false, false, false, false, [EOL]                 false, false, true, false, false})); [EOL]         try { [EOL]             Conversion.binaryBeMsb0ToHexDigit(new boolean[]{}); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#binaryToHexDigit(boolean[], int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testIntToHexDigitMsb0() { [EOL]         assertEquals('0', Conversion.intToHexDigitMsb0(0)); [EOL]         assertEquals('8', Conversion.intToHexDigitMsb0(1)); [EOL]         assertEquals('4', Conversion.intToHexDigitMsb0(2)); [EOL]         assertEquals('c', Conversion.intToHexDigitMsb0(3)); [EOL]         assertEquals('2', Conversion.intToHexDigitMsb0(4)); [EOL]         assertEquals('a', Conversion.intToHexDigitMsb0(5)); [EOL]         assertEquals('6', Conversion.intToHexDigitMsb0(6)); [EOL]         assertEquals('e', Conversion.intToHexDigitMsb0(7)); [EOL]         assertEquals('1', Conversion.intToHexDigitMsb0(8)); [EOL]         assertEquals('9', Conversion.intToHexDigitMsb0(9)); [EOL]         assertEquals('5', Conversion.intToHexDigitMsb0(10)); [EOL]         assertEquals('d', Conversion.intToHexDigitMsb0(11)); [EOL]         assertEquals('3', Conversion.intToHexDigitMsb0(12)); [EOL]         assertEquals('b', Conversion.intToHexDigitMsb0(13)); [EOL]         assertEquals('7', Conversion.intToHexDigitMsb0(14)); [EOL]         assertEquals('f', Conversion.intToHexDigitMsb0(15)); [EOL]         try { [EOL]             Conversion.intToHexDigitMsb0(16); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     static String dbgPrint(final boolean[] src) { [EOL]         final StringBuilder sb = new StringBuilder(); [EOL]         for (final boolean e : src) { [EOL]             if (e) { [EOL]                 sb.append("1,"); [EOL]             } else { [EOL]                 sb.append("0,"); [EOL]             } [EOL]         } [EOL]         final String out = sb.toString(); [EOL]         return out.substring(0, out.length() - 1); [EOL]     } [EOL]  [EOL]     // org.junit.Assert(boolean[], boolean[]) does not exist in JUnit 4.2 [EOL]     static void assertBinaryEquals(final boolean[] expected, final boolean[] actual) { [EOL]         assertEquals(expected.length, actual.length); [EOL]         for (int i = 0; i < expected.length; i++ ) { [EOL]             try { [EOL]                 assertEquals(expected[i], actual[i]); [EOL]             } catch (final Throwable e) { [EOL]                 final String msg = "Mismatch at index " [EOL]                     + i [EOL]                     + " between:\n" [EOL]                     + dbgPrint(expected) [EOL]                     + " and\n" [EOL]                     + dbgPrint(actual); [EOL]                 fail(msg + "\n" + e.getMessage()); [EOL]             } [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#intArrayToLong(int[], int, long, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testIntToHexDigitMsb0() { [EOL]         assertEquals('0', Conversion.intToHexDigitMsb0(0)); [EOL]         assertEquals('8', Conversion.intToHexDigitMsb0(1)); [EOL]         assertEquals('4', Conversion.intToHexDigitMsb0(2)); [EOL]         assertEquals('c', Conversion.intToHexDigitMsb0(3)); [EOL]         assertEquals('2', Conversion.intToHexDigitMsb0(4)); [EOL]         assertEquals('a', Conversion.intToHexDigitMsb0(5)); [EOL]         assertEquals('6', Conversion.intToHexDigitMsb0(6)); [EOL]         assertEquals('e', Conversion.intToHexDigitMsb0(7)); [EOL]         assertEquals('1', Conversion.intToHexDigitMsb0(8)); [EOL]         assertEquals('9', Conversion.intToHexDigitMsb0(9)); [EOL]         assertEquals('5', Conversion.intToHexDigitMsb0(10)); [EOL]         assertEquals('d', Conversion.intToHexDigitMsb0(11)); [EOL]         assertEquals('3', Conversion.intToHexDigitMsb0(12)); [EOL]         assertEquals('b', Conversion.intToHexDigitMsb0(13)); [EOL]         assertEquals('7', Conversion.intToHexDigitMsb0(14)); [EOL]         assertEquals('f', Conversion.intToHexDigitMsb0(15)); [EOL]         try { [EOL]             Conversion.intToHexDigitMsb0(16); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     static String dbgPrint(final boolean[] src) { [EOL]         final StringBuilder sb = new StringBuilder(); [EOL]         for (final boolean e : src) { [EOL]             if (e) { [EOL]                 sb.append("1,"); [EOL]             } else { [EOL]                 sb.append("0,"); [EOL]             } [EOL]         } [EOL]         final String out = sb.toString(); [EOL]         return out.substring(0, out.length() - 1); [EOL]     } [EOL]  [EOL]     // org.junit.Assert(boolean[], boolean[]) does not exist in JUnit 4.2 [EOL]     static void assertBinaryEquals(final boolean[] expected, final boolean[] actual) { [EOL]         assertEquals(expected.length, actual.length); [EOL]         for (int i = 0; i < expected.length; i++ ) { [EOL]             try { [EOL]                 assertEquals(expected[i], actual[i]); [EOL]             } catch (final Throwable e) { [EOL]                 final String msg = "Mismatch at index " [EOL]                     + i [EOL]                     + " between:\n" [EOL]                     + dbgPrint(expected) [EOL]                     + " and\n" [EOL]                     + dbgPrint(actual); [EOL]                 fail(msg + "\n" + e.getMessage()); [EOL]             } [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#intArrayToLong(int[], int, long, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testIntToHexDigitMsb0() { [EOL]         assertEquals('0', Conversion.intToHexDigitMsb0(0)); [EOL]         assertEquals('8', Conversion.intToHexDigitMsb0(1)); [EOL]         assertEquals('4', Conversion.intToHexDigitMsb0(2)); [EOL]         assertEquals('c', Conversion.intToHexDigitMsb0(3)); [EOL]         assertEquals('2', Conversion.intToHexDigitMsb0(4)); [EOL]         assertEquals('a', Conversion.intToHexDigitMsb0(5)); [EOL]         assertEquals('6', Conversion.intToHexDigitMsb0(6)); [EOL]         assertEquals('e', Conversion.intToHexDigitMsb0(7)); [EOL]         assertEquals('1', Conversion.intToHexDigitMsb0(8)); [EOL]         assertEquals('9', Conversion.intToHexDigitMsb0(9)); [EOL]         assertEquals('5', Conversion.intToHexDigitMsb0(10)); [EOL]         assertEquals('d', Conversion.intToHexDigitMsb0(11)); [EOL]         assertEquals('3', Conversion.intToHexDigitMsb0(12)); [EOL]         assertEquals('b', Conversion.intToHexDigitMsb0(13)); [EOL]         assertEquals('7', Conversion.intToHexDigitMsb0(14)); [EOL]         assertEquals('f', Conversion.intToHexDigitMsb0(15)); [EOL]         try { [EOL]             Conversion.intToHexDigitMsb0(16); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     static String dbgPrint(final boolean[] src) { [EOL]         final StringBuilder sb = new StringBuilder(); [EOL]         for (final boolean e : src) { [EOL]             if (e) { [EOL]                 sb.append("1,"); [EOL]             } else { [EOL]                 sb.append("0,"); [EOL]             } [EOL]         } [EOL]         final String out = sb.toString(); [EOL]         return out.substring(0, out.length() - 1); [EOL]     } [EOL]  [EOL]     // org.junit.Assert(boolean[], boolean[]) does not exist in JUnit 4.2 [EOL]     static void assertBinaryEquals(final boolean[] expected, final boolean[] actual) { [EOL]         assertEquals(expected.length, actual.length); [EOL]         for (int i = 0; i < expected.length; i++ ) { [EOL]             try { [EOL]                 assertEquals(expected[i], actual[i]); [EOL]             } catch (final Throwable e) { [EOL]                 final String msg = "Mismatch at index " [EOL]                     + i [EOL]                     + " between:\n" [EOL]                     + dbgPrint(expected) [EOL]                     + " and\n" [EOL]                     + dbgPrint(actual); [EOL]                 fail(msg + "\n" + e.getMessage()); [EOL]             } [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#intArrayToLong(int[], int, long, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testIntToHexDigitMsb0() { [EOL]         assertEquals('0', Conversion.intToHexDigitMsb0(0)); [EOL]         assertEquals('8', Conversion.intToHexDigitMsb0(1)); [EOL]         assertEquals('4', Conversion.intToHexDigitMsb0(2)); [EOL]         assertEquals('c', Conversion.intToHexDigitMsb0(3)); [EOL]         assertEquals('2', Conversion.intToHexDigitMsb0(4)); [EOL]         assertEquals('a', Conversion.intToHexDigitMsb0(5)); [EOL]         assertEquals('6', Conversion.intToHexDigitMsb0(6)); [EOL]         assertEquals('e', Conversion.intToHexDigitMsb0(7)); [EOL]         assertEquals('1', Conversion.intToHexDigitMsb0(8)); [EOL]         assertEquals('9', Conversion.intToHexDigitMsb0(9)); [EOL]         assertEquals('5', Conversion.intToHexDigitMsb0(10)); [EOL]         assertEquals('d', Conversion.intToHexDigitMsb0(11)); [EOL]         assertEquals('3', Conversion.intToHexDigitMsb0(12)); [EOL]         assertEquals('b', Conversion.intToHexDigitMsb0(13)); [EOL]         assertEquals('7', Conversion.intToHexDigitMsb0(14)); [EOL]         assertEquals('f', Conversion.intToHexDigitMsb0(15)); [EOL]         try { [EOL]             Conversion.intToHexDigitMsb0(16); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     static String dbgPrint(final boolean[] src) { [EOL]         final StringBuilder sb = new StringBuilder(); [EOL]         for (final boolean e : src) { [EOL]             if (e) { [EOL]                 sb.append("1,"); [EOL]             } else { [EOL]                 sb.append("0,"); [EOL]             } [EOL]         } [EOL]         final String out = sb.toString(); [EOL]         return out.substring(0, out.length() - 1); [EOL]     } [EOL]  [EOL]     // org.junit.Assert(boolean[], boolean[]) does not exist in JUnit 4.2 [EOL]     static void assertBinaryEquals(final boolean[] expected, final boolean[] actual) { [EOL]         assertEquals(expected.length, actual.length); [EOL]         for (int i = 0; i < expected.length; i++ ) { [EOL]             try { [EOL]                 assertEquals(expected[i], actual[i]); [EOL]             } catch (final Throwable e) { [EOL]                 final String msg = "Mismatch at index " [EOL]                     + i [EOL]                     + " between:\n" [EOL]                     + dbgPrint(expected) [EOL]                     + " and\n" [EOL]                     + dbgPrint(actual); [EOL]                 fail(msg + "\n" + e.getMessage()); [EOL]             } [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#intArrayToLong(int[], int, long, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testIntToHexDigitMsb0() { [EOL]         assertEquals('0', Conversion.intToHexDigitMsb0(0)); [EOL]         assertEquals('8', Conversion.intToHexDigitMsb0(1)); [EOL]         assertEquals('4', Conversion.intToHexDigitMsb0(2)); [EOL]         assertEquals('c', Conversion.intToHexDigitMsb0(3)); [EOL]         assertEquals('2', Conversion.intToHexDigitMsb0(4)); [EOL]         assertEquals('a', Conversion.intToHexDigitMsb0(5)); [EOL]         assertEquals('6', Conversion.intToHexDigitMsb0(6)); [EOL]         assertEquals('e', Conversion.intToHexDigitMsb0(7)); [EOL]         assertEquals('1', Conversion.intToHexDigitMsb0(8)); [EOL]         assertEquals('9', Conversion.intToHexDigitMsb0(9)); [EOL]         assertEquals('5', Conversion.intToHexDigitMsb0(10)); [EOL]         assertEquals('d', Conversion.intToHexDigitMsb0(11)); [EOL]         assertEquals('3', Conversion.intToHexDigitMsb0(12)); [EOL]         assertEquals('b', Conversion.intToHexDigitMsb0(13)); [EOL]         assertEquals('7', Conversion.intToHexDigitMsb0(14)); [EOL]         assertEquals('f', Conversion.intToHexDigitMsb0(15)); [EOL]         try { [EOL]             Conversion.intToHexDigitMsb0(16); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     static String dbgPrint(final boolean[] src) { [EOL]         final StringBuilder sb = new StringBuilder(); [EOL]         for (final boolean e : src) { [EOL]             if (e) { [EOL]                 sb.append("1,"); [EOL]             } else { [EOL]                 sb.append("0,"); [EOL]             } [EOL]         } [EOL]         final String out = sb.toString(); [EOL]         return out.substring(0, out.length() - 1); [EOL]     } [EOL]  [EOL]     // org.junit.Assert(boolean[], boolean[]) does not exist in JUnit 4.2 [EOL]     static void assertBinaryEquals(final boolean[] expected, final boolean[] actual) { [EOL]         assertEquals(expected.length, actual.length); [EOL]         for (int i = 0; i < expected.length; i++ ) { [EOL]             try { [EOL]                 assertEquals(expected[i], actual[i]); [EOL]             } catch (final Throwable e) { [EOL]                 final String msg = "Mismatch at index " [EOL]                     + i [EOL]                     + " between:\n" [EOL]                     + dbgPrint(expected) [EOL]                     + " and\n" [EOL]                     + dbgPrint(actual); [EOL]                 fail(msg + "\n" + e.getMessage()); [EOL]             } [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#intArrayToLong(int[], int, long, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testIntToHexDigitMsb0() { [EOL]         assertEquals('0', Conversion.intToHexDigitMsb0(0)); [EOL]         assertEquals('8', Conversion.intToHexDigitMsb0(1)); [EOL]         assertEquals('4', Conversion.intToHexDigitMsb0(2)); [EOL]         assertEquals('c', Conversion.intToHexDigitMsb0(3)); [EOL]         assertEquals('2', Conversion.intToHexDigitMsb0(4)); [EOL]         assertEquals('a', Conversion.intToHexDigitMsb0(5)); [EOL]         assertEquals('6', Conversion.intToHexDigitMsb0(6)); [EOL]         assertEquals('e', Conversion.intToHexDigitMsb0(7)); [EOL]         assertEquals('1', Conversion.intToHexDigitMsb0(8)); [EOL]         assertEquals('9', Conversion.intToHexDigitMsb0(9)); [EOL]         assertEquals('5', Conversion.intToHexDigitMsb0(10)); [EOL]         assertEquals('d', Conversion.intToHexDigitMsb0(11)); [EOL]         assertEquals('3', Conversion.intToHexDigitMsb0(12)); [EOL]         assertEquals('b', Conversion.intToHexDigitMsb0(13)); [EOL]         assertEquals('7', Conversion.intToHexDigitMsb0(14)); [EOL]         assertEquals('f', Conversion.intToHexDigitMsb0(15)); [EOL]         try { [EOL]             Conversion.intToHexDigitMsb0(16); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     static String dbgPrint(final boolean[] src) { [EOL]         final StringBuilder sb = new StringBuilder(); [EOL]         for (final boolean e : src) { [EOL]             if (e) { [EOL]                 sb.append("1,"); [EOL]             } else { [EOL]                 sb.append("0,"); [EOL]             } [EOL]         } [EOL]         final String out = sb.toString(); [EOL]         return out.substring(0, out.length() - 1); [EOL]     } [EOL]  [EOL]     // org.junit.Assert(boolean[], boolean[]) does not exist in JUnit 4.2 [EOL]     static void assertBinaryEquals(final boolean[] expected, final boolean[] actual) { [EOL]         assertEquals(expected.length, actual.length); [EOL]         for (int i = 0; i < expected.length; i++ ) { [EOL]             try { [EOL]                 assertEquals(expected[i], actual[i]); [EOL]             } catch (final Throwable e) { [EOL]                 final String msg = "Mismatch at index " [EOL]                     + i [EOL]                     + " between:\n" [EOL]                     + dbgPrint(expected) [EOL]                     + " and\n" [EOL]                     + dbgPrint(actual); [EOL]                 fail(msg + "\n" + e.getMessage()); [EOL]             } [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#intArrayToLong(int[], int, long, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testIntToHexDigitMsb0() { [EOL]         assertEquals('0', Conversion.intToHexDigitMsb0(0)); [EOL]         assertEquals('8', Conversion.intToHexDigitMsb0(1)); [EOL]         assertEquals('4', Conversion.intToHexDigitMsb0(2)); [EOL]         assertEquals('c', Conversion.intToHexDigitMsb0(3)); [EOL]         assertEquals('2', Conversion.intToHexDigitMsb0(4)); [EOL]         assertEquals('a', Conversion.intToHexDigitMsb0(5)); [EOL]         assertEquals('6', Conversion.intToHexDigitMsb0(6)); [EOL]         assertEquals('e', Conversion.intToHexDigitMsb0(7)); [EOL]         assertEquals('1', Conversion.intToHexDigitMsb0(8)); [EOL]         assertEquals('9', Conversion.intToHexDigitMsb0(9)); [EOL]         assertEquals('5', Conversion.intToHexDigitMsb0(10)); [EOL]         assertEquals('d', Conversion.intToHexDigitMsb0(11)); [EOL]         assertEquals('3', Conversion.intToHexDigitMsb0(12)); [EOL]         assertEquals('b', Conversion.intToHexDigitMsb0(13)); [EOL]         assertEquals('7', Conversion.intToHexDigitMsb0(14)); [EOL]         assertEquals('f', Conversion.intToHexDigitMsb0(15)); [EOL]         try { [EOL]             Conversion.intToHexDigitMsb0(16); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     static String dbgPrint(final boolean[] src) { [EOL]         final StringBuilder sb = new StringBuilder(); [EOL]         for (final boolean e : src) { [EOL]             if (e) { [EOL]                 sb.append("1,"); [EOL]             } else { [EOL]                 sb.append("0,"); [EOL]             } [EOL]         } [EOL]         final String out = sb.toString(); [EOL]         return out.substring(0, out.length() - 1); [EOL]     } [EOL]  [EOL]     // org.junit.Assert(boolean[], boolean[]) does not exist in JUnit 4.2 [EOL]     static void assertBinaryEquals(final boolean[] expected, final boolean[] actual) { [EOL]         assertEquals(expected.length, actual.length); [EOL]         for (int i = 0; i < expected.length; i++ ) { [EOL]             try { [EOL]                 assertEquals(expected[i], actual[i]); [EOL]             } catch (final Throwable e) { [EOL]                 final String msg = "Mismatch at index " [EOL]                     + i [EOL]                     + " between:\n" [EOL]                     + dbgPrint(expected) [EOL]                     + " and\n" [EOL]                     + dbgPrint(actual); [EOL]                 fail(msg + "\n" + e.getMessage()); [EOL]             } [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#intArrayToLong(int[], int, long, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testIntToHexDigitMsb0() { [EOL]         assertEquals('0', Conversion.intToHexDigitMsb0(0)); [EOL]         assertEquals('8', Conversion.intToHexDigitMsb0(1)); [EOL]         assertEquals('4', Conversion.intToHexDigitMsb0(2)); [EOL]         assertEquals('c', Conversion.intToHexDigitMsb0(3)); [EOL]         assertEquals('2', Conversion.intToHexDigitMsb0(4)); [EOL]         assertEquals('a', Conversion.intToHexDigitMsb0(5)); [EOL]         assertEquals('6', Conversion.intToHexDigitMsb0(6)); [EOL]         assertEquals('e', Conversion.intToHexDigitMsb0(7)); [EOL]         assertEquals('1', Conversion.intToHexDigitMsb0(8)); [EOL]         assertEquals('9', Conversion.intToHexDigitMsb0(9)); [EOL]         assertEquals('5', Conversion.intToHexDigitMsb0(10)); [EOL]         assertEquals('d', Conversion.intToHexDigitMsb0(11)); [EOL]         assertEquals('3', Conversion.intToHexDigitMsb0(12)); [EOL]         assertEquals('b', Conversion.intToHexDigitMsb0(13)); [EOL]         assertEquals('7', Conversion.intToHexDigitMsb0(14)); [EOL]         assertEquals('f', Conversion.intToHexDigitMsb0(15)); [EOL]         try { [EOL]             Conversion.intToHexDigitMsb0(16); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     static String dbgPrint(final boolean[] src) { [EOL]         final StringBuilder sb = new StringBuilder(); [EOL]         for (final boolean e : src) { [EOL]             if (e) { [EOL]                 sb.append("1,"); [EOL]             } else { [EOL]                 sb.append("0,"); [EOL]             } [EOL]         } [EOL]         final String out = sb.toString(); [EOL]         return out.substring(0, out.length() - 1); [EOL]     } [EOL]  [EOL]     // org.junit.Assert(boolean[], boolean[]) does not exist in JUnit 4.2 [EOL]     static void assertBinaryEquals(final boolean[] expected, final boolean[] actual) { [EOL]         assertEquals(expected.length, actual.length); [EOL]         for (int i = 0; i < expected.length; i++ ) { [EOL]             try { [EOL]                 assertEquals(expected[i], actual[i]); [EOL]             } catch (final Throwable e) { [EOL]                 final String msg = "Mismatch at index " [EOL]                     + i [EOL]                     + " between:\n" [EOL]                     + dbgPrint(expected) [EOL]                     + " and\n" [EOL]                     + dbgPrint(actual); [EOL]                 fail(msg + "\n" + e.getMessage()); [EOL]             } [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#intArrayToLong(int[], int, long, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testIntToHexDigitMsb0() { [EOL]         assertEquals('0', Conversion.intToHexDigitMsb0(0)); [EOL]         assertEquals('8', Conversion.intToHexDigitMsb0(1)); [EOL]         assertEquals('4', Conversion.intToHexDigitMsb0(2)); [EOL]         assertEquals('c', Conversion.intToHexDigitMsb0(3)); [EOL]         assertEquals('2', Conversion.intToHexDigitMsb0(4)); [EOL]         assertEquals('a', Conversion.intToHexDigitMsb0(5)); [EOL]         assertEquals('6', Conversion.intToHexDigitMsb0(6)); [EOL]         assertEquals('e', Conversion.intToHexDigitMsb0(7)); [EOL]         assertEquals('1', Conversion.intToHexDigitMsb0(8)); [EOL]         assertEquals('9', Conversion.intToHexDigitMsb0(9)); [EOL]         assertEquals('5', Conversion.intToHexDigitMsb0(10)); [EOL]         assertEquals('d', Conversion.intToHexDigitMsb0(11)); [EOL]         assertEquals('3', Conversion.intToHexDigitMsb0(12)); [EOL]         assertEquals('b', Conversion.intToHexDigitMsb0(13)); [EOL]         assertEquals('7', Conversion.intToHexDigitMsb0(14)); [EOL]         assertEquals('f', Conversion.intToHexDigitMsb0(15)); [EOL]         try { [EOL]             Conversion.intToHexDigitMsb0(16); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     static String dbgPrint(final boolean[] src) { [EOL]         final StringBuilder sb = new StringBuilder(); [EOL]         for (final boolean e : src) { [EOL]             if (e) { [EOL]                 sb.append("1,"); [EOL]             } else { [EOL]                 sb.append("0,"); [EOL]             } [EOL]         } [EOL]         final String out = sb.toString(); [EOL]         return out.substring(0, out.length() - 1); [EOL]     } [EOL]  [EOL]     // org.junit.Assert(boolean[], boolean[]) does not exist in JUnit 4.2 [EOL]     static void assertBinaryEquals(final boolean[] expected, final boolean[] actual) { [EOL]         assertEquals(expected.length, actual.length); [EOL]         for (int i = 0; i < expected.length; i++ ) { [EOL]             try { [EOL]                 assertEquals(expected[i], actual[i]); [EOL]             } catch (final Throwable e) { [EOL]                 final String msg = "Mismatch at index " [EOL]                     + i [EOL]                     + " between:\n" [EOL]                     + dbgPrint(expected) [EOL]                     + " and\n" [EOL]                     + dbgPrint(actual); [EOL]                 fail(msg + "\n" + e.getMessage()); [EOL]             } [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#intArrayToLong(int[], int, long, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testIntToHexDigitMsb0() { [EOL]         assertEquals('0', Conversion.intToHexDigitMsb0(0)); [EOL]         assertEquals('8', Conversion.intToHexDigitMsb0(1)); [EOL]         assertEquals('4', Conversion.intToHexDigitMsb0(2)); [EOL]         assertEquals('c', Conversion.intToHexDigitMsb0(3)); [EOL]         assertEquals('2', Conversion.intToHexDigitMsb0(4)); [EOL]         assertEquals('a', Conversion.intToHexDigitMsb0(5)); [EOL]         assertEquals('6', Conversion.intToHexDigitMsb0(6)); [EOL]         assertEquals('e', Conversion.intToHexDigitMsb0(7)); [EOL]         assertEquals('1', Conversion.intToHexDigitMsb0(8)); [EOL]         assertEquals('9', Conversion.intToHexDigitMsb0(9)); [EOL]         assertEquals('5', Conversion.intToHexDigitMsb0(10)); [EOL]         assertEquals('d', Conversion.intToHexDigitMsb0(11)); [EOL]         assertEquals('3', Conversion.intToHexDigitMsb0(12)); [EOL]         assertEquals('b', Conversion.intToHexDigitMsb0(13)); [EOL]         assertEquals('7', Conversion.intToHexDigitMsb0(14)); [EOL]         assertEquals('f', Conversion.intToHexDigitMsb0(15)); [EOL]         try { [EOL]             Conversion.intToHexDigitMsb0(16); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     static String dbgPrint(final boolean[] src) { [EOL]         final StringBuilder sb = new StringBuilder(); [EOL]         for (final boolean e : src) { [EOL]             if (e) { [EOL]                 sb.append("1,"); [EOL]             } else { [EOL]                 sb.append("0,"); [EOL]             } [EOL]         } [EOL]         final String out = sb.toString(); [EOL]         return out.substring(0, out.length() - 1); [EOL]     } [EOL]  [EOL]     // org.junit.Assert(boolean[], boolean[]) does not exist in JUnit 4.2 [EOL]     static void assertBinaryEquals(final boolean[] expected, final boolean[] actual) { [EOL]         assertEquals(expected.length, actual.length); [EOL]         for (int i = 0; i < expected.length; i++ ) { [EOL]             try { [EOL]                 assertEquals(expected[i], actual[i]); [EOL]             } catch (final Throwable e) { [EOL]                 final String msg = "Mismatch at index " [EOL]                     + i [EOL]                     + " between:\n" [EOL]                     + dbgPrint(expected) [EOL]                     + " and\n" [EOL]                     + dbgPrint(actual); [EOL]                 fail(msg + "\n" + e.getMessage()); [EOL]             } [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#intArrayToLong(int[], int, long, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testIntToHexDigitMsb0() { [EOL]         assertEquals('0', Conversion.intToHexDigitMsb0(0)); [EOL]         assertEquals('8', Conversion.intToHexDigitMsb0(1)); [EOL]         assertEquals('4', Conversion.intToHexDigitMsb0(2)); [EOL]         assertEquals('c', Conversion.intToHexDigitMsb0(3)); [EOL]         assertEquals('2', Conversion.intToHexDigitMsb0(4)); [EOL]         assertEquals('a', Conversion.intToHexDigitMsb0(5)); [EOL]         assertEquals('6', Conversion.intToHexDigitMsb0(6)); [EOL]         assertEquals('e', Conversion.intToHexDigitMsb0(7)); [EOL]         assertEquals('1', Conversion.intToHexDigitMsb0(8)); [EOL]         assertEquals('9', Conversion.intToHexDigitMsb0(9)); [EOL]         assertEquals('5', Conversion.intToHexDigitMsb0(10)); [EOL]         assertEquals('d', Conversion.intToHexDigitMsb0(11)); [EOL]         assertEquals('3', Conversion.intToHexDigitMsb0(12)); [EOL]         assertEquals('b', Conversion.intToHexDigitMsb0(13)); [EOL]         assertEquals('7', Conversion.intToHexDigitMsb0(14)); [EOL]         assertEquals('f', Conversion.intToHexDigitMsb0(15)); [EOL]         try { [EOL]             Conversion.intToHexDigitMsb0(16); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     static String dbgPrint(final boolean[] src) { [EOL]         final StringBuilder sb = new StringBuilder(); [EOL]         for (final boolean e : src) { [EOL]             if (e) { [EOL]                 sb.append("1,"); [EOL]             } else { [EOL]                 sb.append("0,"); [EOL]             } [EOL]         } [EOL]         final String out = sb.toString(); [EOL]         return out.substring(0, out.length() - 1); [EOL]     } [EOL]  [EOL]     // org.junit.Assert(boolean[], boolean[]) does not exist in JUnit 4.2 [EOL]     static void assertBinaryEquals(final boolean[] expected, final boolean[] actual) { [EOL]         assertEquals(expected.length, actual.length); [EOL]         for (int i = 0; i < expected.length; i++ ) { [EOL]             try { [EOL]                 assertEquals(expected[i], actual[i]); [EOL]             } catch (final Throwable e) { [EOL]                 final String msg = "Mismatch at index " [EOL]                     + i [EOL]                     + " between:\n" [EOL]                     + dbgPrint(expected) [EOL]                     + " and\n" [EOL]                     + dbgPrint(actual); [EOL]                 fail(msg + "\n" + e.getMessage()); [EOL]             } [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#intArrayToLong(int[], int, long, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testIntToHexDigitMsb0() { [EOL]         assertEquals('0', Conversion.intToHexDigitMsb0(0)); [EOL]         assertEquals('8', Conversion.intToHexDigitMsb0(1)); [EOL]         assertEquals('4', Conversion.intToHexDigitMsb0(2)); [EOL]         assertEquals('c', Conversion.intToHexDigitMsb0(3)); [EOL]         assertEquals('2', Conversion.intToHexDigitMsb0(4)); [EOL]         assertEquals('a', Conversion.intToHexDigitMsb0(5)); [EOL]         assertEquals('6', Conversion.intToHexDigitMsb0(6)); [EOL]         assertEquals('e', Conversion.intToHexDigitMsb0(7)); [EOL]         assertEquals('1', Conversion.intToHexDigitMsb0(8)); [EOL]         assertEquals('9', Conversion.intToHexDigitMsb0(9)); [EOL]         assertEquals('5', Conversion.intToHexDigitMsb0(10)); [EOL]         assertEquals('d', Conversion.intToHexDigitMsb0(11)); [EOL]         assertEquals('3', Conversion.intToHexDigitMsb0(12)); [EOL]         assertEquals('b', Conversion.intToHexDigitMsb0(13)); [EOL]         assertEquals('7', Conversion.intToHexDigitMsb0(14)); [EOL]         assertEquals('f', Conversion.intToHexDigitMsb0(15)); [EOL]         try { [EOL]             Conversion.intToHexDigitMsb0(16); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     static String dbgPrint(final boolean[] src) { [EOL]         final StringBuilder sb = new StringBuilder(); [EOL]         for (final boolean e : src) { [EOL]             if (e) { [EOL]                 sb.append("1,"); [EOL]             } else { [EOL]                 sb.append("0,"); [EOL]             } [EOL]         } [EOL]         final String out = sb.toString(); [EOL]         return out.substring(0, out.length() - 1); [EOL]     } [EOL]  [EOL]     // org.junit.Assert(boolean[], boolean[]) does not exist in JUnit 4.2 [EOL]     static void assertBinaryEquals(final boolean[] expected, final boolean[] actual) { [EOL]         assertEquals(expected.length, actual.length); [EOL]         for (int i = 0; i < expected.length; i++ ) { [EOL]             try { [EOL]                 assertEquals(expected[i], actual[i]); [EOL]             } catch (final Throwable e) { [EOL]                 final String msg = "Mismatch at index " [EOL]                     + i [EOL]                     + " between:\n" [EOL]                     + dbgPrint(expected) [EOL]                     + " and\n" [EOL]                     + dbgPrint(actual); [EOL]                 fail(msg + "\n" + e.getMessage()); [EOL]             } [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#intArrayToLong(int[], int, long, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testIntToHexDigitMsb0() { [EOL]         assertEquals('0', Conversion.intToHexDigitMsb0(0)); [EOL]         assertEquals('8', Conversion.intToHexDigitMsb0(1)); [EOL]         assertEquals('4', Conversion.intToHexDigitMsb0(2)); [EOL]         assertEquals('c', Conversion.intToHexDigitMsb0(3)); [EOL]         assertEquals('2', Conversion.intToHexDigitMsb0(4)); [EOL]         assertEquals('a', Conversion.intToHexDigitMsb0(5)); [EOL]         assertEquals('6', Conversion.intToHexDigitMsb0(6)); [EOL]         assertEquals('e', Conversion.intToHexDigitMsb0(7)); [EOL]         assertEquals('1', Conversion.intToHexDigitMsb0(8)); [EOL]         assertEquals('9', Conversion.intToHexDigitMsb0(9)); [EOL]         assertEquals('5', Conversion.intToHexDigitMsb0(10)); [EOL]         assertEquals('d', Conversion.intToHexDigitMsb0(11)); [EOL]         assertEquals('3', Conversion.intToHexDigitMsb0(12)); [EOL]         assertEquals('b', Conversion.intToHexDigitMsb0(13)); [EOL]         assertEquals('7', Conversion.intToHexDigitMsb0(14)); [EOL]         assertEquals('f', Conversion.intToHexDigitMsb0(15)); [EOL]         try { [EOL]             Conversion.intToHexDigitMsb0(16); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     static String dbgPrint(final boolean[] src) { [EOL]         final StringBuilder sb = new StringBuilder(); [EOL]         for (final boolean e : src) { [EOL]             if (e) { [EOL]                 sb.append("1,"); [EOL]             } else { [EOL]                 sb.append("0,"); [EOL]             } [EOL]         } [EOL]         final String out = sb.toString(); [EOL]         return out.substring(0, out.length() - 1); [EOL]     } [EOL]  [EOL]     // org.junit.Assert(boolean[], boolean[]) does not exist in JUnit 4.2 [EOL]     static void assertBinaryEquals(final boolean[] expected, final boolean[] actual) { [EOL]         assertEquals(expected.length, actual.length); [EOL]         for (int i = 0; i < expected.length; i++ ) { [EOL]             try { [EOL]                 assertEquals(expected[i], actual[i]); [EOL]             } catch (final Throwable e) { [EOL]                 final String msg = "Mismatch at index " [EOL]                     + i [EOL]                     + " between:\n" [EOL]                     + dbgPrint(expected) [EOL]                     + " and\n" [EOL]                     + dbgPrint(actual); [EOL]                 fail(msg + "\n" + e.getMessage()); [EOL]             } [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#intArrayToLong(int[], int, long, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testIntToHexDigitMsb0() { [EOL]         assertEquals('0', Conversion.intToHexDigitMsb0(0)); [EOL]         assertEquals('8', Conversion.intToHexDigitMsb0(1)); [EOL]         assertEquals('4', Conversion.intToHexDigitMsb0(2)); [EOL]         assertEquals('c', Conversion.intToHexDigitMsb0(3)); [EOL]         assertEquals('2', Conversion.intToHexDigitMsb0(4)); [EOL]         assertEquals('a', Conversion.intToHexDigitMsb0(5)); [EOL]         assertEquals('6', Conversion.intToHexDigitMsb0(6)); [EOL]         assertEquals('e', Conversion.intToHexDigitMsb0(7)); [EOL]         assertEquals('1', Conversion.intToHexDigitMsb0(8)); [EOL]         assertEquals('9', Conversion.intToHexDigitMsb0(9)); [EOL]         assertEquals('5', Conversion.intToHexDigitMsb0(10)); [EOL]         assertEquals('d', Conversion.intToHexDigitMsb0(11)); [EOL]         assertEquals('3', Conversion.intToHexDigitMsb0(12)); [EOL]         assertEquals('b', Conversion.intToHexDigitMsb0(13)); [EOL]         assertEquals('7', Conversion.intToHexDigitMsb0(14)); [EOL]         assertEquals('f', Conversion.intToHexDigitMsb0(15)); [EOL]         try { [EOL]             Conversion.intToHexDigitMsb0(16); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     static String dbgPrint(final boolean[] src) { [EOL]         final StringBuilder sb = new StringBuilder(); [EOL]         for (final boolean e : src) { [EOL]             if (e) { [EOL]                 sb.append("1,"); [EOL]             } else { [EOL]                 sb.append("0,"); [EOL]             } [EOL]         } [EOL]         final String out = sb.toString(); [EOL]         return out.substring(0, out.length() - 1); [EOL]     } [EOL]  [EOL]     // org.junit.Assert(boolean[], boolean[]) does not exist in JUnit 4.2 [EOL]     static void assertBinaryEquals(final boolean[] expected, final boolean[] actual) { [EOL]         assertEquals(expected.length, actual.length); [EOL]         for (int i = 0; i < expected.length; i++ ) { [EOL]             try { [EOL]                 assertEquals(expected[i], actual[i]); [EOL]             } catch (final Throwable e) { [EOL]                 final String msg = "Mismatch at index " [EOL]                     + i [EOL]                     + " between:\n" [EOL]                     + dbgPrint(expected) [EOL]                     + " and\n" [EOL]                     + dbgPrint(actual); [EOL]                 fail(msg + "\n" + e.getMessage()); [EOL]             } [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#intArrayToLong(int[], int, long, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testIntToHexDigitMsb0() { [EOL]         assertEquals('0', Conversion.intToHexDigitMsb0(0)); [EOL]         assertEquals('8', Conversion.intToHexDigitMsb0(1)); [EOL]         assertEquals('4', Conversion.intToHexDigitMsb0(2)); [EOL]         assertEquals('c', Conversion.intToHexDigitMsb0(3)); [EOL]         assertEquals('2', Conversion.intToHexDigitMsb0(4)); [EOL]         assertEquals('a', Conversion.intToHexDigitMsb0(5)); [EOL]         assertEquals('6', Conversion.intToHexDigitMsb0(6)); [EOL]         assertEquals('e', Conversion.intToHexDigitMsb0(7)); [EOL]         assertEquals('1', Conversion.intToHexDigitMsb0(8)); [EOL]         assertEquals('9', Conversion.intToHexDigitMsb0(9)); [EOL]         assertEquals('5', Conversion.intToHexDigitMsb0(10)); [EOL]         assertEquals('d', Conversion.intToHexDigitMsb0(11)); [EOL]         assertEquals('3', Conversion.intToHexDigitMsb0(12)); [EOL]         assertEquals('b', Conversion.intToHexDigitMsb0(13)); [EOL]         assertEquals('7', Conversion.intToHexDigitMsb0(14)); [EOL]         assertEquals('f', Conversion.intToHexDigitMsb0(15)); [EOL]         try { [EOL]             Conversion.intToHexDigitMsb0(16); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     static String dbgPrint(final boolean[] src) { [EOL]         final StringBuilder sb = new StringBuilder(); [EOL]         for (final boolean e : src) { [EOL]             if (e) { [EOL]                 sb.append("1,"); [EOL]             } else { [EOL]                 sb.append("0,"); [EOL]             } [EOL]         } [EOL]         final String out = sb.toString(); [EOL]         return out.substring(0, out.length() - 1); [EOL]     } [EOL]  [EOL]     // org.junit.Assert(boolean[], boolean[]) does not exist in JUnit 4.2 [EOL]     static void assertBinaryEquals(final boolean[] expected, final boolean[] actual) { [EOL]         assertEquals(expected.length, actual.length); [EOL]         for (int i = 0; i < expected.length; i++ ) { [EOL]             try { [EOL]                 assertEquals(expected[i], actual[i]); [EOL]             } catch (final Throwable e) { [EOL]                 final String msg = "Mismatch at index " [EOL]                     + i [EOL]                     + " between:\n" [EOL]                     + dbgPrint(expected) [EOL]                     + " and\n" [EOL]                     + dbgPrint(actual); [EOL]                 fail(msg + "\n" + e.getMessage()); [EOL]             } [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#intArrayToLong(int[], int, long, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testIntToHexDigitMsb0() { [EOL]         assertEquals('0', Conversion.intToHexDigitMsb0(0)); [EOL]         assertEquals('8', Conversion.intToHexDigitMsb0(1)); [EOL]         assertEquals('4', Conversion.intToHexDigitMsb0(2)); [EOL]         assertEquals('c', Conversion.intToHexDigitMsb0(3)); [EOL]         assertEquals('2', Conversion.intToHexDigitMsb0(4)); [EOL]         assertEquals('a', Conversion.intToHexDigitMsb0(5)); [EOL]         assertEquals('6', Conversion.intToHexDigitMsb0(6)); [EOL]         assertEquals('e', Conversion.intToHexDigitMsb0(7)); [EOL]         assertEquals('1', Conversion.intToHexDigitMsb0(8)); [EOL]         assertEquals('9', Conversion.intToHexDigitMsb0(9)); [EOL]         assertEquals('5', Conversion.intToHexDigitMsb0(10)); [EOL]         assertEquals('d', Conversion.intToHexDigitMsb0(11)); [EOL]         assertEquals('3', Conversion.intToHexDigitMsb0(12)); [EOL]         assertEquals('b', Conversion.intToHexDigitMsb0(13)); [EOL]         assertEquals('7', Conversion.intToHexDigitMsb0(14)); [EOL]         assertEquals('f', Conversion.intToHexDigitMsb0(15)); [EOL]         try { [EOL]             Conversion.intToHexDigitMsb0(16); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     static String dbgPrint(final boolean[] src) { [EOL]         final StringBuilder sb = new StringBuilder(); [EOL]         for (final boolean e : src) { [EOL]             if (e) { [EOL]                 sb.append("1,"); [EOL]             } else { [EOL]                 sb.append("0,"); [EOL]             } [EOL]         } [EOL]         final String out = sb.toString(); [EOL]         return out.substring(0, out.length() - 1); [EOL]     } [EOL]  [EOL]     // org.junit.Assert(boolean[], boolean[]) does not exist in JUnit 4.2 [EOL]     static void assertBinaryEquals(final boolean[] expected, final boolean[] actual) { [EOL]         assertEquals(expected.length, actual.length); [EOL]         for (int i = 0; i < expected.length; i++ ) { [EOL]             try { [EOL]                 assertEquals(expected[i], actual[i]); [EOL]             } catch (final Throwable e) { [EOL]                 final String msg = "Mismatch at index " [EOL]                     + i [EOL]                     + " between:\n" [EOL]                     + dbgPrint(expected) [EOL]                     + " and\n" [EOL]                     + dbgPrint(actual); [EOL]                 fail(msg + "\n" + e.getMessage()); [EOL]             } [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#intArrayToLong(int[], int, long, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testIntToHexDigitMsb0() { [EOL]         assertEquals('0', Conversion.intToHexDigitMsb0(0)); [EOL]         assertEquals('8', Conversion.intToHexDigitMsb0(1)); [EOL]         assertEquals('4', Conversion.intToHexDigitMsb0(2)); [EOL]         assertEquals('c', Conversion.intToHexDigitMsb0(3)); [EOL]         assertEquals('2', Conversion.intToHexDigitMsb0(4)); [EOL]         assertEquals('a', Conversion.intToHexDigitMsb0(5)); [EOL]         assertEquals('6', Conversion.intToHexDigitMsb0(6)); [EOL]         assertEquals('e', Conversion.intToHexDigitMsb0(7)); [EOL]         assertEquals('1', Conversion.intToHexDigitMsb0(8)); [EOL]         assertEquals('9', Conversion.intToHexDigitMsb0(9)); [EOL]         assertEquals('5', Conversion.intToHexDigitMsb0(10)); [EOL]         assertEquals('d', Conversion.intToHexDigitMsb0(11)); [EOL]         assertEquals('3', Conversion.intToHexDigitMsb0(12)); [EOL]         assertEquals('b', Conversion.intToHexDigitMsb0(13)); [EOL]         assertEquals('7', Conversion.intToHexDigitMsb0(14)); [EOL]         assertEquals('f', Conversion.intToHexDigitMsb0(15)); [EOL]         try { [EOL]             Conversion.intToHexDigitMsb0(16); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     static String dbgPrint(final boolean[] src) { [EOL]         final StringBuilder sb = new StringBuilder(); [EOL]         for (final boolean e : src) { [EOL]             if (e) { [EOL]                 sb.append("1,"); [EOL]             } else { [EOL]                 sb.append("0,"); [EOL]             } [EOL]         } [EOL]         final String out = sb.toString(); [EOL]         return out.substring(0, out.length() - 1); [EOL]     } [EOL]  [EOL]     // org.junit.Assert(boolean[], boolean[]) does not exist in JUnit 4.2 [EOL]     static void assertBinaryEquals(final boolean[] expected, final boolean[] actual) { [EOL]         assertEquals(expected.length, actual.length); [EOL]         for (int i = 0; i < expected.length; i++ ) { [EOL]             try { [EOL]                 assertEquals(expected[i], actual[i]); [EOL]             } catch (final Throwable e) { [EOL]                 final String msg = "Mismatch at index " [EOL]                     + i [EOL]                     + " between:\n" [EOL]                     + dbgPrint(expected) [EOL]                     + " and\n" [EOL]                     + dbgPrint(actual); [EOL]                 fail(msg + "\n" + e.getMessage()); [EOL]             } [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#intArrayToLong(int[], int, long, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testIntToHexDigitMsb0() { [EOL]         assertEquals('0', Conversion.intToHexDigitMsb0(0)); [EOL]         assertEquals('8', Conversion.intToHexDigitMsb0(1)); [EOL]         assertEquals('4', Conversion.intToHexDigitMsb0(2)); [EOL]         assertEquals('c', Conversion.intToHexDigitMsb0(3)); [EOL]         assertEquals('2', Conversion.intToHexDigitMsb0(4)); [EOL]         assertEquals('a', Conversion.intToHexDigitMsb0(5)); [EOL]         assertEquals('6', Conversion.intToHexDigitMsb0(6)); [EOL]         assertEquals('e', Conversion.intToHexDigitMsb0(7)); [EOL]         assertEquals('1', Conversion.intToHexDigitMsb0(8)); [EOL]         assertEquals('9', Conversion.intToHexDigitMsb0(9)); [EOL]         assertEquals('5', Conversion.intToHexDigitMsb0(10)); [EOL]         assertEquals('d', Conversion.intToHexDigitMsb0(11)); [EOL]         assertEquals('3', Conversion.intToHexDigitMsb0(12)); [EOL]         assertEquals('b', Conversion.intToHexDigitMsb0(13)); [EOL]         assertEquals('7', Conversion.intToHexDigitMsb0(14)); [EOL]         assertEquals('f', Conversion.intToHexDigitMsb0(15)); [EOL]         try { [EOL]             Conversion.intToHexDigitMsb0(16); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     static String dbgPrint(final boolean[] src) { [EOL]         final StringBuilder sb = new StringBuilder(); [EOL]         for (final boolean e : src) { [EOL]             if (e) { [EOL]                 sb.append("1,"); [EOL]             } else { [EOL]                 sb.append("0,"); [EOL]             } [EOL]         } [EOL]         final String out = sb.toString(); [EOL]         return out.substring(0, out.length() - 1); [EOL]     } [EOL]  [EOL]     // org.junit.Assert(boolean[], boolean[]) does not exist in JUnit 4.2 [EOL]     static void assertBinaryEquals(final boolean[] expected, final boolean[] actual) { [EOL]         assertEquals(expected.length, actual.length); [EOL]         for (int i = 0; i < expected.length; i++ ) { [EOL]             try { [EOL]                 assertEquals(expected[i], actual[i]); [EOL]             } catch (final Throwable e) { [EOL]                 final String msg = "Mismatch at index " [EOL]                     + i [EOL]                     + " between:\n" [EOL]                     + dbgPrint(expected) [EOL]                     + " and\n" [EOL]                     + dbgPrint(actual); [EOL]                 fail(msg + "\n" + e.getMessage()); [EOL]             } [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#intArrayToLong(int[], int, long, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testIntToHexDigitMsb0() { [EOL]         assertEquals('0', Conversion.intToHexDigitMsb0(0)); [EOL]         assertEquals('8', Conversion.intToHexDigitMsb0(1)); [EOL]         assertEquals('4', Conversion.intToHexDigitMsb0(2)); [EOL]         assertEquals('c', Conversion.intToHexDigitMsb0(3)); [EOL]         assertEquals('2', Conversion.intToHexDigitMsb0(4)); [EOL]         assertEquals('a', Conversion.intToHexDigitMsb0(5)); [EOL]         assertEquals('6', Conversion.intToHexDigitMsb0(6)); [EOL]         assertEquals('e', Conversion.intToHexDigitMsb0(7)); [EOL]         assertEquals('1', Conversion.intToHexDigitMsb0(8)); [EOL]         assertEquals('9', Conversion.intToHexDigitMsb0(9)); [EOL]         assertEquals('5', Conversion.intToHexDigitMsb0(10)); [EOL]         assertEquals('d', Conversion.intToHexDigitMsb0(11)); [EOL]         assertEquals('3', Conversion.intToHexDigitMsb0(12)); [EOL]         assertEquals('b', Conversion.intToHexDigitMsb0(13)); [EOL]         assertEquals('7', Conversion.intToHexDigitMsb0(14)); [EOL]         assertEquals('f', Conversion.intToHexDigitMsb0(15)); [EOL]         try { [EOL]             Conversion.intToHexDigitMsb0(16); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     static String dbgPrint(final boolean[] src) { [EOL]         final StringBuilder sb = new StringBuilder(); [EOL]         for (final boolean e : src) { [EOL]             if (e) { [EOL]                 sb.append("1,"); [EOL]             } else { [EOL]                 sb.append("0,"); [EOL]             } [EOL]         } [EOL]         final String out = sb.toString(); [EOL]         return out.substring(0, out.length() - 1); [EOL]     } [EOL]  [EOL]     // org.junit.Assert(boolean[], boolean[]) does not exist in JUnit 4.2 [EOL]     static void assertBinaryEquals(final boolean[] expected, final boolean[] actual) { [EOL]         assertEquals(expected.length, actual.length); [EOL]         for (int i = 0; i < expected.length; i++ ) { [EOL]             try { [EOL]                 assertEquals(expected[i], actual[i]); [EOL]             } catch (final Throwable e) { [EOL]                 final String msg = "Mismatch at index " [EOL]                     + i [EOL]                     + " between:\n" [EOL]                     + dbgPrint(expected) [EOL]                     + " and\n" [EOL]                     + dbgPrint(actual); [EOL]                 fail(msg + "\n" + e.getMessage()); [EOL]             } [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#intArrayToLong(int[], int, long, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testIntToHexDigitMsb0() { [EOL]         assertEquals('0', Conversion.intToHexDigitMsb0(0)); [EOL]         assertEquals('8', Conversion.intToHexDigitMsb0(1)); [EOL]         assertEquals('4', Conversion.intToHexDigitMsb0(2)); [EOL]         assertEquals('c', Conversion.intToHexDigitMsb0(3)); [EOL]         assertEquals('2', Conversion.intToHexDigitMsb0(4)); [EOL]         assertEquals('a', Conversion.intToHexDigitMsb0(5)); [EOL]         assertEquals('6', Conversion.intToHexDigitMsb0(6)); [EOL]         assertEquals('e', Conversion.intToHexDigitMsb0(7)); [EOL]         assertEquals('1', Conversion.intToHexDigitMsb0(8)); [EOL]         assertEquals('9', Conversion.intToHexDigitMsb0(9)); [EOL]         assertEquals('5', Conversion.intToHexDigitMsb0(10)); [EOL]         assertEquals('d', Conversion.intToHexDigitMsb0(11)); [EOL]         assertEquals('3', Conversion.intToHexDigitMsb0(12)); [EOL]         assertEquals('b', Conversion.intToHexDigitMsb0(13)); [EOL]         assertEquals('7', Conversion.intToHexDigitMsb0(14)); [EOL]         assertEquals('f', Conversion.intToHexDigitMsb0(15)); [EOL]         try { [EOL]             Conversion.intToHexDigitMsb0(16); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     static String dbgPrint(final boolean[] src) { [EOL]         final StringBuilder sb = new StringBuilder(); [EOL]         for (final boolean e : src) { [EOL]             if (e) { [EOL]                 sb.append("1,"); [EOL]             } else { [EOL]                 sb.append("0,"); [EOL]             } [EOL]         } [EOL]         final String out = sb.toString(); [EOL]         return out.substring(0, out.length() - 1); [EOL]     } [EOL]  [EOL]     // org.junit.Assert(boolean[], boolean[]) does not exist in JUnit 4.2 [EOL]     static void assertBinaryEquals(final boolean[] expected, final boolean[] actual) { [EOL]         assertEquals(expected.length, actual.length); [EOL]         for (int i = 0; i < expected.length; i++ ) { [EOL]             try { [EOL]                 assertEquals(expected[i], actual[i]); [EOL]             } catch (final Throwable e) { [EOL]                 final String msg = "Mismatch at index " [EOL]                     + i [EOL]                     + " between:\n" [EOL]                     + dbgPrint(expected) [EOL]                     + " and\n" [EOL]                     + dbgPrint(actual); [EOL]                 fail(msg + "\n" + e.getMessage()); [EOL]             } [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#intArrayToLong(int[], int, long, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testIntArrayToLong() { [EOL]         final int[] src = new int[]{0xCDF1F0C1, 0x0F123456, 0x78000000}; [EOL]         assertEquals(0x0000000000000000L, Conversion.intArrayToLong(src, 0, 0L, 0, 0)); [EOL]         assertEquals(0x0000000000000000L, Conversion.intArrayToLong(src, 1, 0L, 0, 0)); [EOL]         assertEquals(0x00000000CDF1F0C1L, Conversion.intArrayToLong(src, 0, 0L, 0, 1)); [EOL]         assertEquals(0x0F123456CDF1F0C1L, Conversion.intArrayToLong(src, 0, 0L, 0, 2)); [EOL]         assertEquals(0x000000000F123456L, Conversion.intArrayToLong(src, 1, 0L, 0, 1)); [EOL]         assertEquals( [EOL]             0x123456789ABCDEF0L, Conversion.intArrayToLong(src, 0, 0x123456789ABCDEF0L, 0, 0)); [EOL]         assertEquals( [EOL]             0x1234567878000000L, Conversion.intArrayToLong(src, 2, 0x123456789ABCDEF0L, 0, 1)); [EOL]         // assertEquals(0x0F12345678000000L,Conversion.intsToLong(src,1,0x123456789ABCDEF0L,32,2)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#shortArrayToLong(short[], int, long, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testIntArrayToLong() { [EOL]         final int[] src = new int[]{0xCDF1F0C1, 0x0F123456, 0x78000000}; [EOL]         assertEquals(0x0000000000000000L, Conversion.intArrayToLong(src, 0, 0L, 0, 0)); [EOL]         assertEquals(0x0000000000000000L, Conversion.intArrayToLong(src, 1, 0L, 0, 0)); [EOL]         assertEquals(0x00000000CDF1F0C1L, Conversion.intArrayToLong(src, 0, 0L, 0, 1)); [EOL]         assertEquals(0x0F123456CDF1F0C1L, Conversion.intArrayToLong(src, 0, 0L, 0, 2)); [EOL]         assertEquals(0x000000000F123456L, Conversion.intArrayToLong(src, 1, 0L, 0, 1)); [EOL]         assertEquals( [EOL]             0x123456789ABCDEF0L, Conversion.intArrayToLong(src, 0, 0x123456789ABCDEF0L, 0, 0)); [EOL]         assertEquals( [EOL]             0x1234567878000000L, Conversion.intArrayToLong(src, 2, 0x123456789ABCDEF0L, 0, 1)); [EOL]         // assertEquals(0x0F12345678000000L,Conversion.intsToLong(src,1,0x123456789ABCDEF0L,32,2)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#shortArrayToLong(short[], int, long, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testShortArrayToLong() { [EOL]         final short[] src = new short[]{ [EOL]             (short)0xCDF1, (short)0xF0C1, (short)0x0F12, (short)0x3456, (short)0x7800}; [EOL]         assertEquals(0x0000000000000000L, Conversion.shortArrayToLong(src, 0, 0L, 0, 0)); [EOL]         assertEquals(0x000000000000CDF1L, Conversion.shortArrayToLong(src, 0, 0L, 0, 1)); [EOL]         assertEquals(0x00000000F0C1CDF1L, Conversion.shortArrayToLong(src, 0, 0L, 0, 2)); [EOL]         assertEquals(0x780034560F12F0C1L, Conversion.shortArrayToLong(src, 1, 0L, 0, 4)); [EOL]         assertEquals( [EOL]             0x123456789ABCDEF0L, Conversion.shortArrayToLong(src, 0, 0x123456789ABCDEF0L, 0, 0)); [EOL]         assertEquals( [EOL]             0x123456CDF1BCDEF0L, [EOL]             Conversion.shortArrayToLong(src, 0, 0x123456789ABCDEF0L, 24, 1)); [EOL]         assertEquals( [EOL]             0x123478003456DEF0L, [EOL]             Conversion.shortArrayToLong(src, 3, 0x123456789ABCDEF0L, 16, 2)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#byteArrayToLong(byte[], int, long, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testShortArrayToLong() { [EOL]         final short[] src = new short[]{ [EOL]             (short)0xCDF1, (short)0xF0C1, (short)0x0F12, (short)0x3456, (short)0x7800}; [EOL]         assertEquals(0x0000000000000000L, Conversion.shortArrayToLong(src, 0, 0L, 0, 0)); [EOL]         assertEquals(0x000000000000CDF1L, Conversion.shortArrayToLong(src, 0, 0L, 0, 1)); [EOL]         assertEquals(0x00000000F0C1CDF1L, Conversion.shortArrayToLong(src, 0, 0L, 0, 2)); [EOL]         assertEquals(0x780034560F12F0C1L, Conversion.shortArrayToLong(src, 1, 0L, 0, 4)); [EOL]         assertEquals( [EOL]             0x123456789ABCDEF0L, Conversion.shortArrayToLong(src, 0, 0x123456789ABCDEF0L, 0, 0)); [EOL]         assertEquals( [EOL]             0x123456CDF1BCDEF0L, [EOL]             Conversion.shortArrayToLong(src, 0, 0x123456789ABCDEF0L, 24, 1)); [EOL]         assertEquals( [EOL]             0x123478003456DEF0L, [EOL]             Conversion.shortArrayToLong(src, 3, 0x123456789ABCDEF0L, 16, 2)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#byteArrayToLong(byte[], int, long, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testShortArrayToInt() { [EOL]         final short[] src = new short[]{ [EOL]             (short)0xCDF1, (short)0xF0C1, (short)0x0F12, (short)0x3456, (short)0x7800}; [EOL]         assertEquals(0x00000000, Conversion.shortArrayToInt(src, 0, 0, 0, 0)); [EOL]         assertEquals(0x0000CDF1, Conversion.shortArrayToInt(src, 0, 0, 0, 1)); [EOL]         assertEquals(0xF0C1CDF1, Conversion.shortArrayToInt(src, 0, 0, 0, 2)); [EOL]         assertEquals(0x0F12F0C1, Conversion.shortArrayToInt(src, 1, 0, 0, 2)); [EOL]         assertEquals(0x12345678, Conversion.shortArrayToInt(src, 0, 0x12345678, 0, 0)); [EOL]         assertEquals(0xCDF15678, Conversion.shortArrayToInt(src, 0, 0x12345678, 16, 1)); [EOL]         // assertEquals(0x34567800,Conversion.ShortArrayToInt(src, 3, 0x12345678, 16, 2)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#byteArrayToInt(byte[], int, int, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testShortArrayToInt() { [EOL]         final short[] src = new short[]{ [EOL]             (short)0xCDF1, (short)0xF0C1, (short)0x0F12, (short)0x3456, (short)0x7800}; [EOL]         assertEquals(0x00000000, Conversion.shortArrayToInt(src, 0, 0, 0, 0)); [EOL]         assertEquals(0x0000CDF1, Conversion.shortArrayToInt(src, 0, 0, 0, 1)); [EOL]         assertEquals(0xF0C1CDF1, Conversion.shortArrayToInt(src, 0, 0, 0, 2)); [EOL]         assertEquals(0x0F12F0C1, Conversion.shortArrayToInt(src, 1, 0, 0, 2)); [EOL]         assertEquals(0x12345678, Conversion.shortArrayToInt(src, 0, 0x12345678, 0, 0)); [EOL]         assertEquals(0xCDF15678, Conversion.shortArrayToInt(src, 0, 0x12345678, 16, 1)); [EOL]         // assertEquals(0x34567800,Conversion.ShortArrayToInt(src, 3, 0x12345678, 16, 2)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#byteArrayToInt(byte[], int, int, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testShortArrayToInt() { [EOL]         final short[] src = new short[]{ [EOL]             (short)0xCDF1, (short)0xF0C1, (short)0x0F12, (short)0x3456, (short)0x7800}; [EOL]         assertEquals(0x00000000, Conversion.shortArrayToInt(src, 0, 0, 0, 0)); [EOL]         assertEquals(0x0000CDF1, Conversion.shortArrayToInt(src, 0, 0, 0, 1)); [EOL]         assertEquals(0xF0C1CDF1, Conversion.shortArrayToInt(src, 0, 0, 0, 2)); [EOL]         assertEquals(0x0F12F0C1, Conversion.shortArrayToInt(src, 1, 0, 0, 2)); [EOL]         assertEquals(0x12345678, Conversion.shortArrayToInt(src, 0, 0x12345678, 0, 0)); [EOL]         assertEquals(0xCDF15678, Conversion.shortArrayToInt(src, 0, 0x12345678, 16, 1)); [EOL]         // assertEquals(0x34567800,Conversion.ShortArrayToInt(src, 3, 0x12345678, 16, 2)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#byteArrayToInt(byte[], int, int, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testShortArrayToInt() { [EOL]         final short[] src = new short[]{ [EOL]             (short)0xCDF1, (short)0xF0C1, (short)0x0F12, (short)0x3456, (short)0x7800}; [EOL]         assertEquals(0x00000000, Conversion.shortArrayToInt(src, 0, 0, 0, 0)); [EOL]         assertEquals(0x0000CDF1, Conversion.shortArrayToInt(src, 0, 0, 0, 1)); [EOL]         assertEquals(0xF0C1CDF1, Conversion.shortArrayToInt(src, 0, 0, 0, 2)); [EOL]         assertEquals(0x0F12F0C1, Conversion.shortArrayToInt(src, 1, 0, 0, 2)); [EOL]         assertEquals(0x12345678, Conversion.shortArrayToInt(src, 0, 0x12345678, 0, 0)); [EOL]         assertEquals(0xCDF15678, Conversion.shortArrayToInt(src, 0, 0x12345678, 16, 1)); [EOL]         // assertEquals(0x34567800,Conversion.ShortArrayToInt(src, 3, 0x12345678, 16, 2)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#byteArrayToInt(byte[], int, int, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testByteArrayToLong() { [EOL]         final byte[] src = new byte[]{ [EOL]             (byte)0xCD, (byte)0xF1, (byte)0xF0, (byte)0xC1, (byte)0x0F, (byte)0x12, (byte)0x34, [EOL]             (byte)0x56, (byte)0x78}; [EOL]         assertEquals(0x0000000000000000L, Conversion.byteArrayToLong(src, 0, 0L, 0, 0)); [EOL]         assertEquals(0x00000000000000CDL, Conversion.byteArrayToLong(src, 0, 0L, 0, 1)); [EOL]         assertEquals(0x00000000C1F0F1CDL, Conversion.byteArrayToLong(src, 0, 0L, 0, 4)); [EOL]         assertEquals(0x000000000FC1F0F1L, Conversion.byteArrayToLong(src, 1, 0L, 0, 4)); [EOL]         assertEquals( [EOL]             0x123456789ABCDEF0L, Conversion.byteArrayToLong(src, 0, 0x123456789ABCDEF0L, 0, 0)); [EOL]         assertEquals( [EOL]             0x12345678CDBCDEF0L, Conversion.byteArrayToLong(src, 0, 0x123456789ABCDEF0L, 24, 1)); [EOL]         assertEquals( [EOL]             0x123456789A7856F0L, Conversion.byteArrayToLong(src, 7, 0x123456789ABCDEF0L, 8, 2)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#shortArrayToInt(short[], int, int, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testByteArrayToLong() { [EOL]         final byte[] src = new byte[]{ [EOL]             (byte)0xCD, (byte)0xF1, (byte)0xF0, (byte)0xC1, (byte)0x0F, (byte)0x12, (byte)0x34, [EOL]             (byte)0x56, (byte)0x78}; [EOL]         assertEquals(0x0000000000000000L, Conversion.byteArrayToLong(src, 0, 0L, 0, 0)); [EOL]         assertEquals(0x00000000000000CDL, Conversion.byteArrayToLong(src, 0, 0L, 0, 1)); [EOL]         assertEquals(0x00000000C1F0F1CDL, Conversion.byteArrayToLong(src, 0, 0L, 0, 4)); [EOL]         assertEquals(0x000000000FC1F0F1L, Conversion.byteArrayToLong(src, 1, 0L, 0, 4)); [EOL]         assertEquals( [EOL]             0x123456789ABCDEF0L, Conversion.byteArrayToLong(src, 0, 0x123456789ABCDEF0L, 0, 0)); [EOL]         assertEquals( [EOL]             0x12345678CDBCDEF0L, Conversion.byteArrayToLong(src, 0, 0x123456789ABCDEF0L, 24, 1)); [EOL]         assertEquals( [EOL]             0x123456789A7856F0L, Conversion.byteArrayToLong(src, 7, 0x123456789ABCDEF0L, 8, 2)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#shortArrayToInt(short[], int, int, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testByteArrayToInt() { [EOL]         final byte[] src = new byte[]{ [EOL]             (byte)0xCD, (byte)0xF1, (byte)0xF0, (byte)0xC1, (byte)0x0F, (byte)0x12, (byte)0x34, [EOL]             (byte)0x56, (byte)0x78}; [EOL]         assertEquals(0x00000000, Conversion.byteArrayToInt(src, 0, 0, 0, 0)); [EOL]         assertEquals(0x000000CD, Conversion.byteArrayToInt(src, 0, 0, 0, 1)); [EOL]         assertEquals(0xC1F0F1CD, Conversion.byteArrayToInt(src, 0, 0, 0, 4)); [EOL]         assertEquals(0x0FC1F0F1, Conversion.byteArrayToInt(src, 1, 0, 0, 4)); [EOL]         assertEquals(0x12345678, Conversion.byteArrayToInt(src, 0, 0x12345678, 0, 0)); [EOL]         assertEquals(0xCD345678, Conversion.byteArrayToInt(src, 0, 0x12345678, 24, 1)); [EOL]         // assertEquals(0x56341278,Conversion.ByteArrayToInt(src, 5, 0x01234567, 8, 4)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#byteArrayToShort(byte[], int, short, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testByteArrayToInt() { [EOL]         final byte[] src = new byte[]{ [EOL]             (byte)0xCD, (byte)0xF1, (byte)0xF0, (byte)0xC1, (byte)0x0F, (byte)0x12, (byte)0x34, [EOL]             (byte)0x56, (byte)0x78}; [EOL]         assertEquals(0x00000000, Conversion.byteArrayToInt(src, 0, 0, 0, 0)); [EOL]         assertEquals(0x000000CD, Conversion.byteArrayToInt(src, 0, 0, 0, 1)); [EOL]         assertEquals(0xC1F0F1CD, Conversion.byteArrayToInt(src, 0, 0, 0, 4)); [EOL]         assertEquals(0x0FC1F0F1, Conversion.byteArrayToInt(src, 1, 0, 0, 4)); [EOL]         assertEquals(0x12345678, Conversion.byteArrayToInt(src, 0, 0x12345678, 0, 0)); [EOL]         assertEquals(0xCD345678, Conversion.byteArrayToInt(src, 0, 0x12345678, 24, 1)); [EOL]         // assertEquals(0x56341278,Conversion.ByteArrayToInt(src, 5, 0x01234567, 8, 4)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#byteArrayToShort(byte[], int, short, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testByteArrayToShort() { [EOL]         final byte[] src = new byte[]{ [EOL]             (byte)0xCD, (byte)0xF1, (byte)0xF0, (byte)0xC1, (byte)0x0F, (byte)0x12, (byte)0x34, [EOL]             (byte)0x56, (byte)0x78}; [EOL]         assertEquals((short)0x0000, Conversion.byteArrayToShort(src, 0, (short)0, 0, 0)); [EOL]         assertEquals((short)0x00CD, Conversion.byteArrayToShort(src, 0, (short)0, 0, 1)); [EOL]         assertEquals((short)0xF1CD, Conversion.byteArrayToShort(src, 0, (short)0, 0, 2)); [EOL]         assertEquals((short)0xF0F1, Conversion.byteArrayToShort(src, 1, (short)0, 0, 2)); [EOL]         assertEquals((short)0x1234, Conversion.byteArrayToShort(src, 0, (short)0x1234, 0, 0)); [EOL]         assertEquals((short)0xCD34, Conversion.byteArrayToShort(src, 0, (short)0x1234, 8, 1)); [EOL]         // assertEquals((short)0x5678,Conversion.ByteArrayToShort(src, 7, (short) 0x0123, 8, [EOL]         // 2)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#hexToLong(String, int, long, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testByteArrayToShort() { [EOL]         final byte[] src = new byte[]{ [EOL]             (byte)0xCD, (byte)0xF1, (byte)0xF0, (byte)0xC1, (byte)0x0F, (byte)0x12, (byte)0x34, [EOL]             (byte)0x56, (byte)0x78}; [EOL]         assertEquals((short)0x0000, Conversion.byteArrayToShort(src, 0, (short)0, 0, 0)); [EOL]         assertEquals((short)0x00CD, Conversion.byteArrayToShort(src, 0, (short)0, 0, 1)); [EOL]         assertEquals((short)0xF1CD, Conversion.byteArrayToShort(src, 0, (short)0, 0, 2)); [EOL]         assertEquals((short)0xF0F1, Conversion.byteArrayToShort(src, 1, (short)0, 0, 2)); [EOL]         assertEquals((short)0x1234, Conversion.byteArrayToShort(src, 0, (short)0x1234, 0, 0)); [EOL]         assertEquals((short)0xCD34, Conversion.byteArrayToShort(src, 0, (short)0x1234, 8, 1)); [EOL]         // assertEquals((short)0x5678,Conversion.ByteArrayToShort(src, 7, (short) 0x0123, 8, [EOL]         // 2)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#hexToLong(String, int, long, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexToLong() { [EOL]         final String src = "CDF1F0C10F12345678"; [EOL]         assertEquals(0x0000000000000000L, Conversion.hexToLong(src, 0, 0L, 0, 0)); [EOL]         assertEquals(0x000000000000000CL, Conversion.hexToLong(src, 0, 0L, 0, 1)); [EOL]         assertEquals(0x000000001C0F1FDCL, Conversion.hexToLong(src, 0, 0L, 0, 8)); [EOL]         assertEquals(0x0000000001C0F1FDL, Conversion.hexToLong(src, 1, 0L, 0, 8)); [EOL]         assertEquals( [EOL]             0x123456798ABCDEF0L, Conversion.hexToLong(src, 0, 0x123456798ABCDEF0L, 0, 0)); [EOL]         assertEquals( [EOL]             0x1234567876BCDEF0L, Conversion.hexToLong(src, 15, 0x123456798ABCDEF0L, 24, 3)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#hexToInt(String, int, int, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexToLong() { [EOL]         final String src = "CDF1F0C10F12345678"; [EOL]         assertEquals(0x0000000000000000L, Conversion.hexToLong(src, 0, 0L, 0, 0)); [EOL]         assertEquals(0x000000000000000CL, Conversion.hexToLong(src, 0, 0L, 0, 1)); [EOL]         assertEquals(0x000000001C0F1FDCL, Conversion.hexToLong(src, 0, 0L, 0, 8)); [EOL]         assertEquals(0x0000000001C0F1FDL, Conversion.hexToLong(src, 1, 0L, 0, 8)); [EOL]         assertEquals( [EOL]             0x123456798ABCDEF0L, Conversion.hexToLong(src, 0, 0x123456798ABCDEF0L, 0, 0)); [EOL]         assertEquals( [EOL]             0x1234567876BCDEF0L, Conversion.hexToLong(src, 15, 0x123456798ABCDEF0L, 24, 3)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#hexToInt(String, int, int, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexToInt() { [EOL]         final String src = "CDF1F0C10F12345678"; [EOL]         assertEquals(0x00000000, Conversion.hexToInt(src, 0, 0, 0, 0)); [EOL]         assertEquals(0x0000000C, Conversion.hexToInt(src, 0, 0, 0, 1)); [EOL]         assertEquals(0x1C0F1FDC, Conversion.hexToInt(src, 0, 0, 0, 8)); [EOL]         assertEquals(0x01C0F1FD, Conversion.hexToInt(src, 1, 0, 0, 8)); [EOL]         assertEquals(0x12345679, Conversion.hexToInt(src, 0, 0x12345679, 0, 0)); [EOL]         assertEquals(0x87645679, Conversion.hexToInt(src, 15, 0x12345679, 20, 3)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#hexToShort(String, int, short, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexToInt() { [EOL]         final String src = "CDF1F0C10F12345678"; [EOL]         assertEquals(0x00000000, Conversion.hexToInt(src, 0, 0, 0, 0)); [EOL]         assertEquals(0x0000000C, Conversion.hexToInt(src, 0, 0, 0, 1)); [EOL]         assertEquals(0x1C0F1FDC, Conversion.hexToInt(src, 0, 0, 0, 8)); [EOL]         assertEquals(0x01C0F1FD, Conversion.hexToInt(src, 1, 0, 0, 8)); [EOL]         assertEquals(0x12345679, Conversion.hexToInt(src, 0, 0x12345679, 0, 0)); [EOL]         assertEquals(0x87645679, Conversion.hexToInt(src, 15, 0x12345679, 20, 3)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#hexToShort(String, int, short, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexToShort() { [EOL]         final String src = "CDF1F0C10F12345678"; [EOL]         assertEquals((short)0x0000, Conversion.hexToShort(src, 0, (short)0, 0, 0)); [EOL]         assertEquals((short)0x000C, Conversion.hexToShort(src, 0, (short)0, 0, 1)); [EOL]         assertEquals((short)0x1FDC, Conversion.hexToShort(src, 0, (short)0, 0, 4)); [EOL]         assertEquals((short)0xF1FD, Conversion.hexToShort(src, 1, (short)0, 0, 4)); [EOL]         assertEquals((short)0x1234, Conversion.hexToShort(src, 0, (short)0x1234, 0, 0)); [EOL]         assertEquals((short)0x8764, Conversion.hexToShort(src, 15, (short)0x1234, 4, 3)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#hexToByte(String, int, byte, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexToShort() { [EOL]         final String src = "CDF1F0C10F12345678"; [EOL]         assertEquals((short)0x0000, Conversion.hexToShort(src, 0, (short)0, 0, 0)); [EOL]         assertEquals((short)0x000C, Conversion.hexToShort(src, 0, (short)0, 0, 1)); [EOL]         assertEquals((short)0x1FDC, Conversion.hexToShort(src, 0, (short)0, 0, 4)); [EOL]         assertEquals((short)0xF1FD, Conversion.hexToShort(src, 1, (short)0, 0, 4)); [EOL]         assertEquals((short)0x1234, Conversion.hexToShort(src, 0, (short)0x1234, 0, 0)); [EOL]         assertEquals((short)0x8764, Conversion.hexToShort(src, 15, (short)0x1234, 4, 3)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#hexToByte(String, int, byte, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexToByte() { [EOL]         final String src = "CDF1F0C10F12345678"; [EOL]         assertEquals((byte)0x00, Conversion.hexToByte(src, 0, (byte)0, 0, 0)); [EOL]         assertEquals((byte)0x0C, Conversion.hexToByte(src, 0, (byte)0, 0, 1)); [EOL]         assertEquals((byte)0xDC, Conversion.hexToByte(src, 0, (byte)0, 0, 2)); [EOL]         assertEquals((byte)0xFD, Conversion.hexToByte(src, 1, (byte)0, 0, 2)); [EOL]         assertEquals((byte)0x34, Conversion.hexToByte(src, 0, (byte)0x34, 0, 0)); [EOL]         assertEquals((byte)0x84, Conversion.hexToByte(src, 17, (byte)0x34, 4, 1)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#binaryToLong(boolean[], int, long, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexToByte() { [EOL]         final String src = "CDF1F0C10F12345678"; [EOL]         assertEquals((byte)0x00, Conversion.hexToByte(src, 0, (byte)0, 0, 0)); [EOL]         assertEquals((byte)0x0C, Conversion.hexToByte(src, 0, (byte)0, 0, 1)); [EOL]         assertEquals((byte)0xDC, Conversion.hexToByte(src, 0, (byte)0, 0, 2)); [EOL]         assertEquals((byte)0xFD, Conversion.hexToByte(src, 1, (byte)0, 0, 2)); [EOL]         assertEquals((byte)0x34, Conversion.hexToByte(src, 0, (byte)0x34, 0, 0)); [EOL]         assertEquals((byte)0x84, Conversion.hexToByte(src, 17, (byte)0x34, 4, 1)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#binaryToLong(boolean[], int, long, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testBinaryToLong() { [EOL]         final boolean[] src = new boolean[]{ [EOL]             false, false, true, true, true, false, true, true, true, true, true, true, true, [EOL]             false, false, false, true, true, true, true, false, false, false, false, false, [EOL]             false, true, true, true, false, false, false, false, false, false, false, true, [EOL]             true, true, true, true, false, false, false, false, true, false, false, true, true, [EOL]             false, false, false, false, true, false, true, false, true, false, false, true, [EOL]             true, false, true, true, true, false, false, false, false, true}; [EOL]         // conversion of "CDF1F0C10F12345678" by HexToBinary [EOL]         assertEquals(0x0000000000000000L, Conversion.binaryToLong(src, 0, 0L, 0, 0)); [EOL]         assertEquals(0x000000000000000CL, Conversion.binaryToLong(src, 0, 0L, 0, 1 * 4)); [EOL]         assertEquals(0x000000001C0F1FDCL, Conversion.binaryToLong(src, 0, 0L, 0, 8 * 4)); [EOL]         assertEquals(0x0000000001C0F1FDL, Conversion.binaryToLong(src, 1 * 4, 0L, 0, 8 * 4)); [EOL]         assertEquals( [EOL]             0x123456798ABCDEF0L, Conversion.binaryToLong(src, 0, 0x123456798ABCDEF0L, 0, 0)); [EOL]         assertEquals( [EOL]             0x1234567876BCDEF0L, [EOL]             Conversion.binaryToLong(src, 15 * 4, 0x123456798ABCDEF0L, 24, 3 * 4)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#binaryToInt(boolean[], int, int, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testBinaryToLong() { [EOL]         final boolean[] src = new boolean[]{ [EOL]             false, false, true, true, true, false, true, true, true, true, true, true, true, [EOL]             false, false, false, true, true, true, true, false, false, false, false, false, [EOL]             false, true, true, true, false, false, false, false, false, false, false, true, [EOL]             true, true, true, true, false, false, false, false, true, false, false, true, true, [EOL]             false, false, false, false, true, false, true, false, true, false, false, true, [EOL]             true, false, true, true, true, false, false, false, false, true}; [EOL]         // conversion of "CDF1F0C10F12345678" by HexToBinary [EOL]         assertEquals(0x0000000000000000L, Conversion.binaryToLong(src, 0, 0L, 0, 0)); [EOL]         assertEquals(0x000000000000000CL, Conversion.binaryToLong(src, 0, 0L, 0, 1 * 4)); [EOL]         assertEquals(0x000000001C0F1FDCL, Conversion.binaryToLong(src, 0, 0L, 0, 8 * 4)); [EOL]         assertEquals(0x0000000001C0F1FDL, Conversion.binaryToLong(src, 1 * 4, 0L, 0, 8 * 4)); [EOL]         assertEquals( [EOL]             0x123456798ABCDEF0L, Conversion.binaryToLong(src, 0, 0x123456798ABCDEF0L, 0, 0)); [EOL]         assertEquals( [EOL]             0x1234567876BCDEF0L, [EOL]             Conversion.binaryToLong(src, 15 * 4, 0x123456798ABCDEF0L, 24, 3 * 4)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#binaryToInt(boolean[], int, int, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testLongToIntArray() { [EOL]         assertArrayEquals( [EOL]             new int[]{}, Conversion.longToIntArray(0x0000000000000000L, 0, new int[]{}, 0, 0)); [EOL]         assertArrayEquals( [EOL]             new int[]{}, Conversion.longToIntArray(0x0000000000000000L, 100, new int[]{}, 0, 0)); [EOL]         assertArrayEquals( [EOL]             new int[]{}, Conversion.longToIntArray(0x0000000000000000L, 0, new int[]{}, 100, 0)); [EOL]         assertArrayEquals( [EOL]             new int[]{0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF}, [EOL]             Conversion.longToIntArray(0x1234567890ABCDEFL, 0, new int[]{-1, -1, -1, -1}, 0, 0)); [EOL]         assertArrayEquals( [EOL]             new int[]{0x90ABCDEF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF}, [EOL]             Conversion.longToIntArray(0x1234567890ABCDEFL, 0, new int[]{-1, -1, -1, -1}, 0, 1)); [EOL]         assertArrayEquals( [EOL]             new int[]{0x90ABCDEF, 0x12345678, 0xFFFFFFFF, 0xFFFFFFFF}, [EOL]             Conversion.longToIntArray(0x1234567890ABCDEFL, 0, new int[]{-1, -1, -1, -1}, 0, 2)); [EOL]         // assertArrayEquals(new [EOL]         // int[]{0x90ABCDEF,0x12345678,0x90ABCDEF,0x12345678},Conversion.longToIntArray(0x1234567890ABCDEFL, [EOL]         // 0,new int[]{-1,-1,-1,-1},0,4));//rejected by assertion [EOL]         // assertArrayEquals(new [EOL]         // int[]{0xFFFFFFFF,0x90ABCDEF,0x12345678,0x90ABCDEF},Conversion.longToIntArray(0x1234567890ABCDEFL, [EOL]         // 0,new int[]{-1,-1,-1,-1},1,3)); [EOL]         assertArrayEquals( [EOL]             new int[]{0xFFFFFFFF, 0xFFFFFFFF, 0x90ABCDEF, 0x12345678}, [EOL]             Conversion.longToIntArray(0x1234567890ABCDEFL, 0, new int[]{-1, -1, -1, -1}, 2, 2)); [EOL]         assertArrayEquals( [EOL]             new int[]{0xFFFFFFFF, 0xFFFFFFFF, 0x90ABCDEF, 0xFFFFFFFF}, [EOL]             Conversion.longToIntArray(0x1234567890ABCDEFL, 0, new int[]{-1, -1, -1, -1}, 2, 1)); [EOL]         assertArrayEquals( [EOL]             new int[]{0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x90ABCDEF}, [EOL]             Conversion.longToIntArray(0x1234567890ABCDEFL, 0, new int[]{-1, -1, -1, -1}, 3, 1)); [EOL]         assertArrayEquals( [EOL]             new int[]{0xFFFFFFFF, 0xFFFFFFFF, 0x4855E6F7, 0xFFFFFFFF}, [EOL]             Conversion.longToIntArray(0x1234567890ABCDEFL, 1, new int[]{-1, -1, -1, -1}, 2, 1)); [EOL]         assertArrayEquals( [EOL]             new int[]{0xFFFFFFFF, 0xFFFFFFFF, 0x242AF37B, 0xFFFFFFFF}, [EOL]             Conversion.longToIntArray(0x1234567890ABCDEFL, 2, new int[]{-1, -1, -1, -1}, 2, 1)); [EOL]         assertArrayEquals( [EOL]             new int[]{0xFFFFFFFF, 0xFFFFFFFF, 0x121579BD, 0xFFFFFFFF}, [EOL]             Conversion.longToIntArray(0x1234567890ABCDEFL, 3, new int[]{-1, -1, -1, -1}, 2, 1)); [EOL]         assertArrayEquals( [EOL]             new int[]{0xFFFFFFFF, 0xFFFFFFFF, 0x890ABCDE, 0xFFFFFFFF}, [EOL]             Conversion.longToIntArray(0x1234567890ABCDEFL, 4, new int[]{-1, -1, -1, -1}, 2, 1)); [EOL]         // assertArrayEquals(new [EOL]         // int[]{0x4855E6F7,0x091A2B3C,0x4855E6F7,0x091A2B3C},Conversion.longToIntArray(0x1234567890ABCDEFL, [EOL]         // 1,new int[]{-1,-1,-1,-1},0,4));//rejected by assertion [EOL]         assertArrayEquals( [EOL]             new int[]{0x091A2B3C}, [EOL]             Conversion.longToIntArray(0x1234567890ABCDEFL, 33, new int[]{0}, 0, 1)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#longToShortArray(long, int, short[], int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testLongToIntArray() { [EOL]         assertArrayEquals( [EOL]             new int[]{}, Conversion.longToIntArray(0x0000000000000000L, 0, new int[]{}, 0, 0)); [EOL]         assertArrayEquals( [EOL]             new int[]{}, Conversion.longToIntArray(0x0000000000000000L, 100, new int[]{}, 0, 0)); [EOL]         assertArrayEquals( [EOL]             new int[]{}, Conversion.longToIntArray(0x0000000000000000L, 0, new int[]{}, 100, 0)); [EOL]         assertArrayEquals( [EOL]             new int[]{0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF}, [EOL]             Conversion.longToIntArray(0x1234567890ABCDEFL, 0, new int[]{-1, -1, -1, -1}, 0, 0)); [EOL]         assertArrayEquals( [EOL]             new int[]{0x90ABCDEF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF}, [EOL]             Conversion.longToIntArray(0x1234567890ABCDEFL, 0, new int[]{-1, -1, -1, -1}, 0, 1)); [EOL]         assertArrayEquals( [EOL]             new int[]{0x90ABCDEF, 0x12345678, 0xFFFFFFFF, 0xFFFFFFFF}, [EOL]             Conversion.longToIntArray(0x1234567890ABCDEFL, 0, new int[]{-1, -1, -1, -1}, 0, 2)); [EOL]         // assertArrayEquals(new [EOL]         // int[]{0x90ABCDEF,0x12345678,0x90ABCDEF,0x12345678},Conversion.longToIntArray(0x1234567890ABCDEFL, [EOL]         // 0,new int[]{-1,-1,-1,-1},0,4));//rejected by assertion [EOL]         // assertArrayEquals(new [EOL]         // int[]{0xFFFFFFFF,0x90ABCDEF,0x12345678,0x90ABCDEF},Conversion.longToIntArray(0x1234567890ABCDEFL, [EOL]         // 0,new int[]{-1,-1,-1,-1},1,3)); [EOL]         assertArrayEquals( [EOL]             new int[]{0xFFFFFFFF, 0xFFFFFFFF, 0x90ABCDEF, 0x12345678}, [EOL]             Conversion.longToIntArray(0x1234567890ABCDEFL, 0, new int[]{-1, -1, -1, -1}, 2, 2)); [EOL]         assertArrayEquals( [EOL]             new int[]{0xFFFFFFFF, 0xFFFFFFFF, 0x90ABCDEF, 0xFFFFFFFF}, [EOL]             Conversion.longToIntArray(0x1234567890ABCDEFL, 0, new int[]{-1, -1, -1, -1}, 2, 1)); [EOL]         assertArrayEquals( [EOL]             new int[]{0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x90ABCDEF}, [EOL]             Conversion.longToIntArray(0x1234567890ABCDEFL, 0, new int[]{-1, -1, -1, -1}, 3, 1)); [EOL]         assertArrayEquals( [EOL]             new int[]{0xFFFFFFFF, 0xFFFFFFFF, 0x4855E6F7, 0xFFFFFFFF}, [EOL]             Conversion.longToIntArray(0x1234567890ABCDEFL, 1, new int[]{-1, -1, -1, -1}, 2, 1)); [EOL]         assertArrayEquals( [EOL]             new int[]{0xFFFFFFFF, 0xFFFFFFFF, 0x242AF37B, 0xFFFFFFFF}, [EOL]             Conversion.longToIntArray(0x1234567890ABCDEFL, 2, new int[]{-1, -1, -1, -1}, 2, 1)); [EOL]         assertArrayEquals( [EOL]             new int[]{0xFFFFFFFF, 0xFFFFFFFF, 0x121579BD, 0xFFFFFFFF}, [EOL]             Conversion.longToIntArray(0x1234567890ABCDEFL, 3, new int[]{-1, -1, -1, -1}, 2, 1)); [EOL]         assertArrayEquals( [EOL]             new int[]{0xFFFFFFFF, 0xFFFFFFFF, 0x890ABCDE, 0xFFFFFFFF}, [EOL]             Conversion.longToIntArray(0x1234567890ABCDEFL, 4, new int[]{-1, -1, -1, -1}, 2, 1)); [EOL]         // assertArrayEquals(new [EOL]         // int[]{0x4855E6F7,0x091A2B3C,0x4855E6F7,0x091A2B3C},Conversion.longToIntArray(0x1234567890ABCDEFL, [EOL]         // 1,new int[]{-1,-1,-1,-1},0,4));//rejected by assertion [EOL]         assertArrayEquals( [EOL]             new int[]{0x091A2B3C}, [EOL]             Conversion.longToIntArray(0x1234567890ABCDEFL, 33, new int[]{0}, 0, 1)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#longToShortArray(long, int, short[], int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testLongToHex() { [EOL]         assertEquals("", Conversion.longToHex(0x0000000000000000L, 0, "", 0, 0)); [EOL]         assertEquals("", Conversion.longToHex(0x0000000000000000L, 100, "", 0, 0)); [EOL]         assertEquals("", Conversion.longToHex(0x0000000000000000L, 0, "", 100, 0)); [EOL]         assertEquals( [EOL]             "ffffffffffffffffffffffff", [EOL]             Conversion.longToHex(0x1234567890ABCDEFL, 0, "ffffffffffffffffffffffff", 0, 0)); [EOL]         assertEquals( [EOL]             "3fffffffffffffffffffffff", [EOL]             Conversion.longToHex(0x1234567890ABCDE3L, 0, "ffffffffffffffffffffffff", 0, 1)); [EOL]         assertEquals( [EOL]             "feffffffffffffffffffffff", [EOL]             Conversion.longToHex(0x1234567890ABCDEFL, 0, "ffffffffffffffffffffffff", 0, 2)); [EOL]         assertEquals( [EOL]             "fedcffffffffffffffffffff", [EOL]             Conversion.longToHex(0x1234567890ABCDEFL, 0, "ffffffffffffffffffffffff", 0, 4)); [EOL]         assertEquals( [EOL]             "fedcba098765432fffffffff", [EOL]             Conversion.longToHex(0x1234567890ABCDEFL, 0, "ffffffffffffffffffffffff", 0, 15)); [EOL]         assertEquals( [EOL]             "fedcba0987654321ffffffff", [EOL]             Conversion.longToHex(0x1234567890ABCDEFL, 0, "ffffffffffffffffffffffff", 0, 16)); [EOL]         assertEquals( [EOL]             "fff3ffffffffffffffffffff", [EOL]             Conversion.longToHex(0x1234567890ABCDE3L, 0, "ffffffffffffffffffffffff", 3, 1)); [EOL]         assertEquals( [EOL]             "ffffefffffffffffffffffff", [EOL]             Conversion.longToHex(0x1234567890ABCDEFL, 0, "ffffffffffffffffffffffff", 3, 2)); [EOL]         assertEquals( [EOL]             "ffffedcfffffffffffffffff", [EOL]             Conversion.longToHex(0x1234567890ABCDEFL, 0, "ffffffffffffffffffffffff", 3, 4)); [EOL]         assertEquals( [EOL]             "ffffedcba098765432ffffff", [EOL]             Conversion.longToHex(0x1234567890ABCDEFL, 0, "ffffffffffffffffffffffff", 3, 15)); [EOL]         assertEquals( [EOL]             "ffffedcba0987654321fffff", [EOL]             Conversion.longToHex(0x1234567890ABCDEFL, 0, "ffffffffffffffffffffffff", 3, 16)); [EOL]         assertEquals( [EOL]             "7fffffffffffffffffffffff", [EOL]             Conversion.longToHex(0x1234567890ABCDEFL, 1, "ffffffffffffffffffffffff", 0, 1)); [EOL]         assertEquals( [EOL]             "bfffffffffffffffffffffff", [EOL]             Conversion.longToHex(0x1234567890ABCDEFL, 2, "ffffffffffffffffffffffff", 0, 1)); [EOL]         assertEquals( [EOL]             "fffdb975121fca86420fffff", [EOL]             Conversion.longToHex(0x1234567890ABCDEFL, 3, "ffffffffffffffffffffffff", 3, 16)); [EOL]         // assertEquals("ffffffffffffffffffffffff",Conversion.longToHex(0x1234567890ABCDEFL,4,"ffffffffffffffffffffffff",3,16));//rejected [EOL]         // by assertion [EOL]         assertEquals( [EOL]             "fffedcba0987654321ffffff", [EOL]             Conversion.longToHex(0x1234567890ABCDEFL, 4, "ffffffffffffffffffffffff", 3, 15)); [EOL]         assertEquals( [EOL]             "fedcba0987654321", Conversion.longToHex(0x1234567890ABCDEFL, 0, "", 0, 16)); [EOL]         try { [EOL]             Conversion.longToHex(0x1234567890ABCDEFL, 0, "", 1, 8); [EOL]             fail("Thrown " + StringIndexOutOfBoundsException.class.getName() + " expected"); [EOL]         } catch (final StringIndexOutOfBoundsException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#intToHex(int, int, String, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testLongToHex() { [EOL]         assertEquals("", Conversion.longToHex(0x0000000000000000L, 0, "", 0, 0)); [EOL]         assertEquals("", Conversion.longToHex(0x0000000000000000L, 100, "", 0, 0)); [EOL]         assertEquals("", Conversion.longToHex(0x0000000000000000L, 0, "", 100, 0)); [EOL]         assertEquals( [EOL]             "ffffffffffffffffffffffff", [EOL]             Conversion.longToHex(0x1234567890ABCDEFL, 0, "ffffffffffffffffffffffff", 0, 0)); [EOL]         assertEquals( [EOL]             "3fffffffffffffffffffffff", [EOL]             Conversion.longToHex(0x1234567890ABCDE3L, 0, "ffffffffffffffffffffffff", 0, 1)); [EOL]         assertEquals( [EOL]             "feffffffffffffffffffffff", [EOL]             Conversion.longToHex(0x1234567890ABCDEFL, 0, "ffffffffffffffffffffffff", 0, 2)); [EOL]         assertEquals( [EOL]             "fedcffffffffffffffffffff", [EOL]             Conversion.longToHex(0x1234567890ABCDEFL, 0, "ffffffffffffffffffffffff", 0, 4)); [EOL]         assertEquals( [EOL]             "fedcba098765432fffffffff", [EOL]             Conversion.longToHex(0x1234567890ABCDEFL, 0, "ffffffffffffffffffffffff", 0, 15)); [EOL]         assertEquals( [EOL]             "fedcba0987654321ffffffff", [EOL]             Conversion.longToHex(0x1234567890ABCDEFL, 0, "ffffffffffffffffffffffff", 0, 16)); [EOL]         assertEquals( [EOL]             "fff3ffffffffffffffffffff", [EOL]             Conversion.longToHex(0x1234567890ABCDE3L, 0, "ffffffffffffffffffffffff", 3, 1)); [EOL]         assertEquals( [EOL]             "ffffefffffffffffffffffff", [EOL]             Conversion.longToHex(0x1234567890ABCDEFL, 0, "ffffffffffffffffffffffff", 3, 2)); [EOL]         assertEquals( [EOL]             "ffffedcfffffffffffffffff", [EOL]             Conversion.longToHex(0x1234567890ABCDEFL, 0, "ffffffffffffffffffffffff", 3, 4)); [EOL]         assertEquals( [EOL]             "ffffedcba098765432ffffff", [EOL]             Conversion.longToHex(0x1234567890ABCDEFL, 0, "ffffffffffffffffffffffff", 3, 15)); [EOL]         assertEquals( [EOL]             "ffffedcba0987654321fffff", [EOL]             Conversion.longToHex(0x1234567890ABCDEFL, 0, "ffffffffffffffffffffffff", 3, 16)); [EOL]         assertEquals( [EOL]             "7fffffffffffffffffffffff", [EOL]             Conversion.longToHex(0x1234567890ABCDEFL, 1, "ffffffffffffffffffffffff", 0, 1)); [EOL]         assertEquals( [EOL]             "bfffffffffffffffffffffff", [EOL]             Conversion.longToHex(0x1234567890ABCDEFL, 2, "ffffffffffffffffffffffff", 0, 1)); [EOL]         assertEquals( [EOL]             "fffdb975121fca86420fffff", [EOL]             Conversion.longToHex(0x1234567890ABCDEFL, 3, "ffffffffffffffffffffffff", 3, 16)); [EOL]         // assertEquals("ffffffffffffffffffffffff",Conversion.longToHex(0x1234567890ABCDEFL,4,"ffffffffffffffffffffffff",3,16));//rejected [EOL]         // by assertion [EOL]         assertEquals( [EOL]             "fffedcba0987654321ffffff", [EOL]             Conversion.longToHex(0x1234567890ABCDEFL, 4, "ffffffffffffffffffffffff", 3, 15)); [EOL]         assertEquals( [EOL]             "fedcba0987654321", Conversion.longToHex(0x1234567890ABCDEFL, 0, "", 0, 16)); [EOL]         try { [EOL]             Conversion.longToHex(0x1234567890ABCDEFL, 0, "", 1, 8); [EOL]             fail("Thrown " + StringIndexOutOfBoundsException.class.getName() + " expected"); [EOL]         } catch (final StringIndexOutOfBoundsException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#intToHex(int, int, String, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testIntToHex() { [EOL]         assertEquals("", Conversion.intToHex(0x00000000, 0, "", 0, 0)); [EOL]         assertEquals("", Conversion.intToHex(0x00000000, 100, "", 0, 0)); [EOL]         assertEquals("", Conversion.intToHex(0x00000000, 0, "", 100, 0)); [EOL]         assertEquals( [EOL]             "ffffffffffffffffffffffff", [EOL]             Conversion.intToHex(0x90ABCDEF, 0, "ffffffffffffffffffffffff", 0, 0)); [EOL]         assertEquals( [EOL]             "3fffffffffffffffffffffff", [EOL]             Conversion.intToHex(0x90ABCDE3, 0, "ffffffffffffffffffffffff", 0, 1)); [EOL]         assertEquals( [EOL]             "feffffffffffffffffffffff", [EOL]             Conversion.intToHex(0x90ABCDEF, 0, "ffffffffffffffffffffffff", 0, 2)); [EOL]         assertEquals( [EOL]             "fedcffffffffffffffffffff", [EOL]             Conversion.intToHex(0x90ABCDEF, 0, "ffffffffffffffffffffffff", 0, 4)); [EOL]         assertEquals( [EOL]             "fedcba0fffffffffffffffff", [EOL]             Conversion.intToHex(0x90ABCDEF, 0, "ffffffffffffffffffffffff", 0, 7)); [EOL]         assertEquals( [EOL]             "fedcba09ffffffffffffffff", [EOL]             Conversion.intToHex(0x90ABCDEF, 0, "ffffffffffffffffffffffff", 0, 8)); [EOL]         assertEquals( [EOL]             "fff3ffffffffffffffffffff", [EOL]             Conversion.intToHex(0x90ABCDE3, 0, "ffffffffffffffffffffffff", 3, 1)); [EOL]         assertEquals( [EOL]             "ffffefffffffffffffffffff", [EOL]             Conversion.intToHex(0x90ABCDEF, 0, "ffffffffffffffffffffffff", 3, 2)); [EOL]         assertEquals( [EOL]             "ffffedcfffffffffffffffff", [EOL]             Conversion.intToHex(0x90ABCDEF, 0, "ffffffffffffffffffffffff", 3, 4)); [EOL]         assertEquals( [EOL]             "ffffedcba0ffffffffffffff", [EOL]             Conversion.intToHex(0x90ABCDEF, 0, "ffffffffffffffffffffffff", 3, 7)); [EOL]         assertEquals( [EOL]             "ffffedcba09fffffffffffff", [EOL]             Conversion.intToHex(0x90ABCDEF, 0, "ffffffffffffffffffffffff", 3, 8)); [EOL]         assertEquals( [EOL]             "7fffffffffffffffffffffff", [EOL]             Conversion.intToHex(0x90ABCDEF, 1, "ffffffffffffffffffffffff", 0, 1)); [EOL]         assertEquals( [EOL]             "bfffffffffffffffffffffff", [EOL]             Conversion.intToHex(0x90ABCDEF, 2, "ffffffffffffffffffffffff", 0, 1)); [EOL]         assertEquals( [EOL]             "fffdb97512ffffffffffffff", [EOL]             Conversion.intToHex(0x90ABCDEF, 3, "ffffffffffffffffffffffff", 3, 8)); [EOL]         // assertEquals("ffffffffffffffffffffffff",Conversion.intToHex(0x90ABCDEF, [EOL]         // 4,"ffffffffffffffffffffffff",3,8));//rejected by assertion [EOL]         assertEquals( [EOL]             "fffedcba09ffffffffffffff", [EOL]             Conversion.intToHex(0x90ABCDEF, 4, "ffffffffffffffffffffffff", 3, 7)); [EOL]         assertEquals("fedcba09", Conversion.intToHex(0x90ABCDEF, 0, "", 0, 8)); [EOL]         try { [EOL]             Conversion.intToHex(0x90ABCDEF, 0, "", 1, 8); [EOL]             fail("Thrown " + StringIndexOutOfBoundsException.class.getName() + " expected"); [EOL]         } catch (final StringIndexOutOfBoundsException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#shortToHex(short, int, String, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testIntToHex() { [EOL]         assertEquals("", Conversion.intToHex(0x00000000, 0, "", 0, 0)); [EOL]         assertEquals("", Conversion.intToHex(0x00000000, 100, "", 0, 0)); [EOL]         assertEquals("", Conversion.intToHex(0x00000000, 0, "", 100, 0)); [EOL]         assertEquals( [EOL]             "ffffffffffffffffffffffff", [EOL]             Conversion.intToHex(0x90ABCDEF, 0, "ffffffffffffffffffffffff", 0, 0)); [EOL]         assertEquals( [EOL]             "3fffffffffffffffffffffff", [EOL]             Conversion.intToHex(0x90ABCDE3, 0, "ffffffffffffffffffffffff", 0, 1)); [EOL]         assertEquals( [EOL]             "feffffffffffffffffffffff", [EOL]             Conversion.intToHex(0x90ABCDEF, 0, "ffffffffffffffffffffffff", 0, 2)); [EOL]         assertEquals( [EOL]             "fedcffffffffffffffffffff", [EOL]             Conversion.intToHex(0x90ABCDEF, 0, "ffffffffffffffffffffffff", 0, 4)); [EOL]         assertEquals( [EOL]             "fedcba0fffffffffffffffff", [EOL]             Conversion.intToHex(0x90ABCDEF, 0, "ffffffffffffffffffffffff", 0, 7)); [EOL]         assertEquals( [EOL]             "fedcba09ffffffffffffffff", [EOL]             Conversion.intToHex(0x90ABCDEF, 0, "ffffffffffffffffffffffff", 0, 8)); [EOL]         assertEquals( [EOL]             "fff3ffffffffffffffffffff", [EOL]             Conversion.intToHex(0x90ABCDE3, 0, "ffffffffffffffffffffffff", 3, 1)); [EOL]         assertEquals( [EOL]             "ffffefffffffffffffffffff", [EOL]             Conversion.intToHex(0x90ABCDEF, 0, "ffffffffffffffffffffffff", 3, 2)); [EOL]         assertEquals( [EOL]             "ffffedcfffffffffffffffff", [EOL]             Conversion.intToHex(0x90ABCDEF, 0, "ffffffffffffffffffffffff", 3, 4)); [EOL]         assertEquals( [EOL]             "ffffedcba0ffffffffffffff", [EOL]             Conversion.intToHex(0x90ABCDEF, 0, "ffffffffffffffffffffffff", 3, 7)); [EOL]         assertEquals( [EOL]             "ffffedcba09fffffffffffff", [EOL]             Conversion.intToHex(0x90ABCDEF, 0, "ffffffffffffffffffffffff", 3, 8)); [EOL]         assertEquals( [EOL]             "7fffffffffffffffffffffff", [EOL]             Conversion.intToHex(0x90ABCDEF, 1, "ffffffffffffffffffffffff", 0, 1)); [EOL]         assertEquals( [EOL]             "bfffffffffffffffffffffff", [EOL]             Conversion.intToHex(0x90ABCDEF, 2, "ffffffffffffffffffffffff", 0, 1)); [EOL]         assertEquals( [EOL]             "fffdb97512ffffffffffffff", [EOL]             Conversion.intToHex(0x90ABCDEF, 3, "ffffffffffffffffffffffff", 3, 8)); [EOL]         // assertEquals("ffffffffffffffffffffffff",Conversion.intToHex(0x90ABCDEF, [EOL]         // 4,"ffffffffffffffffffffffff",3,8));//rejected by assertion [EOL]         assertEquals( [EOL]             "fffedcba09ffffffffffffff", [EOL]             Conversion.intToHex(0x90ABCDEF, 4, "ffffffffffffffffffffffff", 3, 7)); [EOL]         assertEquals("fedcba09", Conversion.intToHex(0x90ABCDEF, 0, "", 0, 8)); [EOL]         try { [EOL]             Conversion.intToHex(0x90ABCDEF, 0, "", 1, 8); [EOL]             fail("Thrown " + StringIndexOutOfBoundsException.class.getName() + " expected"); [EOL]         } catch (final StringIndexOutOfBoundsException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#shortToHex(short, int, String, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testShortToHex() { [EOL]         assertEquals("", Conversion.shortToHex((short)0x0000, 0, "", 0, 0)); [EOL]         assertEquals("", Conversion.shortToHex((short)0x0000, 100, "", 0, 0)); [EOL]         assertEquals("", Conversion.shortToHex((short)0x0000, 0, "", 100, 0)); [EOL]         assertEquals( [EOL]             "ffffffffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDEF, 0, "ffffffffffffffffffffffff", 0, 0)); [EOL]         assertEquals( [EOL]             "3fffffffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDE3, 0, "ffffffffffffffffffffffff", 0, 1)); [EOL]         assertEquals( [EOL]             "feffffffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDEF, 0, "ffffffffffffffffffffffff", 0, 2)); [EOL]         assertEquals( [EOL]             "fedfffffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDEF, 0, "ffffffffffffffffffffffff", 0, 3)); [EOL]         assertEquals( [EOL]             "fedcffffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDEF, 0, "ffffffffffffffffffffffff", 0, 4)); [EOL]         assertEquals( [EOL]             "fff3ffffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDE3, 0, "ffffffffffffffffffffffff", 3, 1)); [EOL]         assertEquals( [EOL]             "ffffefffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDEF, 0, "ffffffffffffffffffffffff", 3, 2)); [EOL]         assertEquals( [EOL]             "7fffffffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDEF, 1, "ffffffffffffffffffffffff", 0, 1)); [EOL]         assertEquals( [EOL]             "bfffffffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDEF, 2, "ffffffffffffffffffffffff", 0, 1)); [EOL]         assertEquals( [EOL]             "fffdb9ffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDEF, 3, "ffffffffffffffffffffffff", 3, 4)); [EOL]         // assertEquals("ffffffffffffffffffffffff",Conversion.shortToHex((short)0xCDEF, [EOL]         // 4,"ffffffffffffffffffffffff",3,4));//rejected by assertion [EOL]         assertEquals( [EOL]             "fffedcffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDEF, 4, "ffffffffffffffffffffffff", 3, 3)); [EOL]         assertEquals("fedc", Conversion.shortToHex((short)0xCDEF, 0, "", 0, 4)); [EOL]         try { [EOL]             Conversion.shortToHex((short)0xCDEF, 0, "", 1, 4); [EOL]             fail("Thrown " + StringIndexOutOfBoundsException.class.getName() + " expected"); [EOL]         } catch (final StringIndexOutOfBoundsException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#byteToHex(byte, int, String, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testShortToHex() { [EOL]         assertEquals("", Conversion.shortToHex((short)0x0000, 0, "", 0, 0)); [EOL]         assertEquals("", Conversion.shortToHex((short)0x0000, 100, "", 0, 0)); [EOL]         assertEquals("", Conversion.shortToHex((short)0x0000, 0, "", 100, 0)); [EOL]         assertEquals( [EOL]             "ffffffffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDEF, 0, "ffffffffffffffffffffffff", 0, 0)); [EOL]         assertEquals( [EOL]             "3fffffffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDE3, 0, "ffffffffffffffffffffffff", 0, 1)); [EOL]         assertEquals( [EOL]             "feffffffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDEF, 0, "ffffffffffffffffffffffff", 0, 2)); [EOL]         assertEquals( [EOL]             "fedfffffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDEF, 0, "ffffffffffffffffffffffff", 0, 3)); [EOL]         assertEquals( [EOL]             "fedcffffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDEF, 0, "ffffffffffffffffffffffff", 0, 4)); [EOL]         assertEquals( [EOL]             "fff3ffffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDE3, 0, "ffffffffffffffffffffffff", 3, 1)); [EOL]         assertEquals( [EOL]             "ffffefffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDEF, 0, "ffffffffffffffffffffffff", 3, 2)); [EOL]         assertEquals( [EOL]             "7fffffffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDEF, 1, "ffffffffffffffffffffffff", 0, 1)); [EOL]         assertEquals( [EOL]             "bfffffffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDEF, 2, "ffffffffffffffffffffffff", 0, 1)); [EOL]         assertEquals( [EOL]             "fffdb9ffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDEF, 3, "ffffffffffffffffffffffff", 3, 4)); [EOL]         // assertEquals("ffffffffffffffffffffffff",Conversion.shortToHex((short)0xCDEF, [EOL]         // 4,"ffffffffffffffffffffffff",3,4));//rejected by assertion [EOL]         assertEquals( [EOL]             "fffedcffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDEF, 4, "ffffffffffffffffffffffff", 3, 3)); [EOL]         assertEquals("fedc", Conversion.shortToHex((short)0xCDEF, 0, "", 0, 4)); [EOL]         try { [EOL]             Conversion.shortToHex((short)0xCDEF, 0, "", 1, 4); [EOL]             fail("Thrown " + StringIndexOutOfBoundsException.class.getName() + " expected"); [EOL]         } catch (final StringIndexOutOfBoundsException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#byteToHex(byte, int, String, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testShortToHex() { [EOL]         assertEquals("", Conversion.shortToHex((short)0x0000, 0, "", 0, 0)); [EOL]         assertEquals("", Conversion.shortToHex((short)0x0000, 100, "", 0, 0)); [EOL]         assertEquals("", Conversion.shortToHex((short)0x0000, 0, "", 100, 0)); [EOL]         assertEquals( [EOL]             "ffffffffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDEF, 0, "ffffffffffffffffffffffff", 0, 0)); [EOL]         assertEquals( [EOL]             "3fffffffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDE3, 0, "ffffffffffffffffffffffff", 0, 1)); [EOL]         assertEquals( [EOL]             "feffffffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDEF, 0, "ffffffffffffffffffffffff", 0, 2)); [EOL]         assertEquals( [EOL]             "fedfffffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDEF, 0, "ffffffffffffffffffffffff", 0, 3)); [EOL]         assertEquals( [EOL]             "fedcffffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDEF, 0, "ffffffffffffffffffffffff", 0, 4)); [EOL]         assertEquals( [EOL]             "fff3ffffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDE3, 0, "ffffffffffffffffffffffff", 3, 1)); [EOL]         assertEquals( [EOL]             "ffffefffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDEF, 0, "ffffffffffffffffffffffff", 3, 2)); [EOL]         assertEquals( [EOL]             "7fffffffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDEF, 1, "ffffffffffffffffffffffff", 0, 1)); [EOL]         assertEquals( [EOL]             "bfffffffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDEF, 2, "ffffffffffffffffffffffff", 0, 1)); [EOL]         assertEquals( [EOL]             "fffdb9ffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDEF, 3, "ffffffffffffffffffffffff", 3, 4)); [EOL]         // assertEquals("ffffffffffffffffffffffff",Conversion.shortToHex((short)0xCDEF, [EOL]         // 4,"ffffffffffffffffffffffff",3,4));//rejected by assertion [EOL]         assertEquals( [EOL]             "fffedcffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDEF, 4, "ffffffffffffffffffffffff", 3, 3)); [EOL]         assertEquals("fedc", Conversion.shortToHex((short)0xCDEF, 0, "", 0, 4)); [EOL]         try { [EOL]             Conversion.shortToHex((short)0xCDEF, 0, "", 1, 4); [EOL]             fail("Thrown " + StringIndexOutOfBoundsException.class.getName() + " expected"); [EOL]         } catch (final StringIndexOutOfBoundsException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#byteToHex(byte, int, String, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testShortToHex() { [EOL]         assertEquals("", Conversion.shortToHex((short)0x0000, 0, "", 0, 0)); [EOL]         assertEquals("", Conversion.shortToHex((short)0x0000, 100, "", 0, 0)); [EOL]         assertEquals("", Conversion.shortToHex((short)0x0000, 0, "", 100, 0)); [EOL]         assertEquals( [EOL]             "ffffffffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDEF, 0, "ffffffffffffffffffffffff", 0, 0)); [EOL]         assertEquals( [EOL]             "3fffffffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDE3, 0, "ffffffffffffffffffffffff", 0, 1)); [EOL]         assertEquals( [EOL]             "feffffffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDEF, 0, "ffffffffffffffffffffffff", 0, 2)); [EOL]         assertEquals( [EOL]             "fedfffffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDEF, 0, "ffffffffffffffffffffffff", 0, 3)); [EOL]         assertEquals( [EOL]             "fedcffffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDEF, 0, "ffffffffffffffffffffffff", 0, 4)); [EOL]         assertEquals( [EOL]             "fff3ffffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDE3, 0, "ffffffffffffffffffffffff", 3, 1)); [EOL]         assertEquals( [EOL]             "ffffefffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDEF, 0, "ffffffffffffffffffffffff", 3, 2)); [EOL]         assertEquals( [EOL]             "7fffffffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDEF, 1, "ffffffffffffffffffffffff", 0, 1)); [EOL]         assertEquals( [EOL]             "bfffffffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDEF, 2, "ffffffffffffffffffffffff", 0, 1)); [EOL]         assertEquals( [EOL]             "fffdb9ffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDEF, 3, "ffffffffffffffffffffffff", 3, 4)); [EOL]         // assertEquals("ffffffffffffffffffffffff",Conversion.shortToHex((short)0xCDEF, [EOL]         // 4,"ffffffffffffffffffffffff",3,4));//rejected by assertion [EOL]         assertEquals( [EOL]             "fffedcffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDEF, 4, "ffffffffffffffffffffffff", 3, 3)); [EOL]         assertEquals("fedc", Conversion.shortToHex((short)0xCDEF, 0, "", 0, 4)); [EOL]         try { [EOL]             Conversion.shortToHex((short)0xCDEF, 0, "", 1, 4); [EOL]             fail("Thrown " + StringIndexOutOfBoundsException.class.getName() + " expected"); [EOL]         } catch (final StringIndexOutOfBoundsException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#byteToHex(byte, int, String, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testShortToHex() { [EOL]         assertEquals("", Conversion.shortToHex((short)0x0000, 0, "", 0, 0)); [EOL]         assertEquals("", Conversion.shortToHex((short)0x0000, 100, "", 0, 0)); [EOL]         assertEquals("", Conversion.shortToHex((short)0x0000, 0, "", 100, 0)); [EOL]         assertEquals( [EOL]             "ffffffffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDEF, 0, "ffffffffffffffffffffffff", 0, 0)); [EOL]         assertEquals( [EOL]             "3fffffffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDE3, 0, "ffffffffffffffffffffffff", 0, 1)); [EOL]         assertEquals( [EOL]             "feffffffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDEF, 0, "ffffffffffffffffffffffff", 0, 2)); [EOL]         assertEquals( [EOL]             "fedfffffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDEF, 0, "ffffffffffffffffffffffff", 0, 3)); [EOL]         assertEquals( [EOL]             "fedcffffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDEF, 0, "ffffffffffffffffffffffff", 0, 4)); [EOL]         assertEquals( [EOL]             "fff3ffffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDE3, 0, "ffffffffffffffffffffffff", 3, 1)); [EOL]         assertEquals( [EOL]             "ffffefffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDEF, 0, "ffffffffffffffffffffffff", 3, 2)); [EOL]         assertEquals( [EOL]             "7fffffffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDEF, 1, "ffffffffffffffffffffffff", 0, 1)); [EOL]         assertEquals( [EOL]             "bfffffffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDEF, 2, "ffffffffffffffffffffffff", 0, 1)); [EOL]         assertEquals( [EOL]             "fffdb9ffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDEF, 3, "ffffffffffffffffffffffff", 3, 4)); [EOL]         // assertEquals("ffffffffffffffffffffffff",Conversion.shortToHex((short)0xCDEF, [EOL]         // 4,"ffffffffffffffffffffffff",3,4));//rejected by assertion [EOL]         assertEquals( [EOL]             "fffedcffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDEF, 4, "ffffffffffffffffffffffff", 3, 3)); [EOL]         assertEquals("fedc", Conversion.shortToHex((short)0xCDEF, 0, "", 0, 4)); [EOL]         try { [EOL]             Conversion.shortToHex((short)0xCDEF, 0, "", 1, 4); [EOL]             fail("Thrown " + StringIndexOutOfBoundsException.class.getName() + " expected"); [EOL]         } catch (final StringIndexOutOfBoundsException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#byteToHex(byte, int, String, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testShortToHex() { [EOL]         assertEquals("", Conversion.shortToHex((short)0x0000, 0, "", 0, 0)); [EOL]         assertEquals("", Conversion.shortToHex((short)0x0000, 100, "", 0, 0)); [EOL]         assertEquals("", Conversion.shortToHex((short)0x0000, 0, "", 100, 0)); [EOL]         assertEquals( [EOL]             "ffffffffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDEF, 0, "ffffffffffffffffffffffff", 0, 0)); [EOL]         assertEquals( [EOL]             "3fffffffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDE3, 0, "ffffffffffffffffffffffff", 0, 1)); [EOL]         assertEquals( [EOL]             "feffffffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDEF, 0, "ffffffffffffffffffffffff", 0, 2)); [EOL]         assertEquals( [EOL]             "fedfffffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDEF, 0, "ffffffffffffffffffffffff", 0, 3)); [EOL]         assertEquals( [EOL]             "fedcffffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDEF, 0, "ffffffffffffffffffffffff", 0, 4)); [EOL]         assertEquals( [EOL]             "fff3ffffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDE3, 0, "ffffffffffffffffffffffff", 3, 1)); [EOL]         assertEquals( [EOL]             "ffffefffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDEF, 0, "ffffffffffffffffffffffff", 3, 2)); [EOL]         assertEquals( [EOL]             "7fffffffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDEF, 1, "ffffffffffffffffffffffff", 0, 1)); [EOL]         assertEquals( [EOL]             "bfffffffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDEF, 2, "ffffffffffffffffffffffff", 0, 1)); [EOL]         assertEquals( [EOL]             "fffdb9ffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDEF, 3, "ffffffffffffffffffffffff", 3, 4)); [EOL]         // assertEquals("ffffffffffffffffffffffff",Conversion.shortToHex((short)0xCDEF, [EOL]         // 4,"ffffffffffffffffffffffff",3,4));//rejected by assertion [EOL]         assertEquals( [EOL]             "fffedcffffffffffffffffff", [EOL]             Conversion.shortToHex((short)0xCDEF, 4, "ffffffffffffffffffffffff", 3, 3)); [EOL]         assertEquals("fedc", Conversion.shortToHex((short)0xCDEF, 0, "", 0, 4)); [EOL]         try { [EOL]             Conversion.shortToHex((short)0xCDEF, 0, "", 1, 4); [EOL]             fail("Thrown " + StringIndexOutOfBoundsException.class.getName() + " expected"); [EOL]         } catch (final StringIndexOutOfBoundsException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#byteToHex(byte, int, String, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testByteToHex() { [EOL]         assertEquals("", Conversion.byteToHex((byte)0x00, 0, "", 0, 0)); [EOL]         assertEquals("", Conversion.byteToHex((byte)0x00, 100, "", 0, 0)); [EOL]         assertEquals("", Conversion.byteToHex((byte)0x00, 0, "", 100, 0)); [EOL]         assertEquals("00000", Conversion.byteToHex((byte)0xEF, 0, "00000", 0, 0)); [EOL]         assertEquals("f0000", Conversion.byteToHex((byte)0xEF, 0, "00000", 0, 1)); [EOL]         assertEquals("fe000", Conversion.byteToHex((byte)0xEF, 0, "00000", 0, 2)); [EOL]         assertEquals("000f0", Conversion.byteToHex((byte)0xEF, 0, "00000", 3, 1)); [EOL]         assertEquals("000fe", Conversion.byteToHex((byte)0xEF, 0, "00000", 3, 2)); [EOL]         assertEquals("70000", Conversion.byteToHex((byte)0xEF, 1, "00000", 0, 1)); [EOL]         assertEquals("b0000", Conversion.byteToHex((byte)0xEF, 2, "00000", 0, 1)); [EOL]         assertEquals("000df", Conversion.byteToHex((byte)0xEF, 3, "00000", 3, 2)); [EOL]         // assertEquals("00000",Conversion.byteToHex((byte)0xEF, 4,"00000",3,2));//rejected by [EOL]         // assertion [EOL]         assertEquals("000e0", Conversion.byteToHex((byte)0xEF, 4, "00000", 3, 1)); [EOL]         assertEquals("fe", Conversion.byteToHex((byte)0xEF, 0, "", 0, 2)); [EOL]         try { [EOL]             Conversion.byteToHex((byte)0xEF, 0, "", 1, 2); [EOL]             fail("Thrown " + StringIndexOutOfBoundsException.class.getName() + " expected"); [EOL]         } catch (final StringIndexOutOfBoundsException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#longToBinary(long, int, boolean[], int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testByteToHex() { [EOL]         assertEquals("", Conversion.byteToHex((byte)0x00, 0, "", 0, 0)); [EOL]         assertEquals("", Conversion.byteToHex((byte)0x00, 100, "", 0, 0)); [EOL]         assertEquals("", Conversion.byteToHex((byte)0x00, 0, "", 100, 0)); [EOL]         assertEquals("00000", Conversion.byteToHex((byte)0xEF, 0, "00000", 0, 0)); [EOL]         assertEquals("f0000", Conversion.byteToHex((byte)0xEF, 0, "00000", 0, 1)); [EOL]         assertEquals("fe000", Conversion.byteToHex((byte)0xEF, 0, "00000", 0, 2)); [EOL]         assertEquals("000f0", Conversion.byteToHex((byte)0xEF, 0, "00000", 3, 1)); [EOL]         assertEquals("000fe", Conversion.byteToHex((byte)0xEF, 0, "00000", 3, 2)); [EOL]         assertEquals("70000", Conversion.byteToHex((byte)0xEF, 1, "00000", 0, 1)); [EOL]         assertEquals("b0000", Conversion.byteToHex((byte)0xEF, 2, "00000", 0, 1)); [EOL]         assertEquals("000df", Conversion.byteToHex((byte)0xEF, 3, "00000", 3, 2)); [EOL]         // assertEquals("00000",Conversion.byteToHex((byte)0xEF, 4,"00000",3,2));//rejected by [EOL]         // assertion [EOL]         assertEquals("000e0", Conversion.byteToHex((byte)0xEF, 4, "00000", 3, 1)); [EOL]         assertEquals("fe", Conversion.byteToHex((byte)0xEF, 0, "", 0, 2)); [EOL]         try { [EOL]             Conversion.byteToHex((byte)0xEF, 0, "", 1, 2); [EOL]             fail("Thrown " + StringIndexOutOfBoundsException.class.getName() + " expected"); [EOL]         } catch (final StringIndexOutOfBoundsException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#longToBinary(long, int, boolean[], int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testShortToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{}, Conversion.shortToBinary((short)0x0000, 0, new boolean[]{}, 0, 0)); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{}, [EOL]             Conversion.shortToBinary((short)0x0000, 100, new boolean[]{}, 0, 0)); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{}, [EOL]             Conversion.shortToBinary((short)0x0000, 0, new boolean[]{}, 100, 0)); [EOL]         assertBinaryEquals( [EOL]             new boolean[69], Conversion.shortToBinary((short)0xCDEF, 0, new boolean[69], 0, 0)); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{ [EOL]                 true, false, false, false, false, false, false, false, false, false, false, [EOL]                 false, false, false, false, false, false, false, false, false, false}, [EOL]             Conversion.shortToBinary((short)0xCDEF, 0, new boolean[21], 0, 1)); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{ [EOL]                 true, true, false, false, false, false, false, false, false, false, false, [EOL]                 false, false, false, false, false, false, false, false, false, false}, [EOL]             Conversion.shortToBinary((short)0xCDEF, 0, new boolean[21], 0, 2)); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{ [EOL]                 true, true, true, false, false, false, false, false, false, false, false, [EOL]                 false, false, false, false, false, false, false, false, false, false}, [EOL]             Conversion.shortToBinary((short)0xCDEF, 0, new boolean[21], 0, 3)); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{ [EOL]                 true, true, true, true, false, true, true, true, true, false, true, true, [EOL]                 false, false, true, false, false, false, false, false, false}, [EOL]             Conversion.shortToBinary((short)0xCDEF, 0, new boolean[21], 0, 15)); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{ [EOL]                 true, true, true, true, false, true, true, true, true, false, true, true, [EOL]                 false, false, true, true, false, false, false, false, false}, [EOL]             Conversion.shortToBinary((short)0xCDEF, 0, new boolean[21], 0, 16)); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{ [EOL]                 false, false, true, false, false, false, false, false, false, false, false, [EOL]                 false, false, false, false, false, false, false, false, false, false}, [EOL]             Conversion.shortToBinary((short)0xCDEF, 0, new boolean[21], 2, 1)); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{ [EOL]                 false, false, true, true, true, true, false, true, true, true, true, false, [EOL]                 true, true, false, false, true, true, false, false, false}, [EOL]             Conversion.shortToBinary((short)0xCDEF, 0, new boolean[21], 2, 16)); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{ [EOL]                 true, true, true, false, true, true, true, true, false, true, true, false, [EOL]                 false, true, true, false, false, false, false, false, false}, [EOL]             Conversion.shortToBinary((short)0xCDEF, 1, new boolean[21], 0, 15)); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{ [EOL]                 true, true, false, true, true, true, true, false, true, true, false, false, [EOL]                 true, true, false, false, false, false, false, false, false}, [EOL]             Conversion.shortToBinary((short)0xCDEF, 2, new boolean[21], 0, 14)); [EOL]         // assertArrayEquals(new boolean[]{false, false, false, true, true, false, true, true, [EOL]         // true, true, false, true, true, false, false, true, false, false, false, false, [EOL]         // false},Conversion.shortToBinary((short)0xCDEF, 2,new boolean[21], [EOL]         // 3,15));//rejected by [EOL]         // assertion [EOL]         assertBinaryEquals( [EOL]             new boolean[]{ [EOL]                 false, false, false, true, true, false, true, true, true, true, false, true, [EOL]                 true, false, false, true, true, false, false, false, false}, [EOL]             Conversion.shortToBinary((short)0xCDEF, 2, new boolean[21], 3, 14)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#byteToBinary(byte, int, boolean[], int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testByteToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{}, Conversion.byteToBinary((byte)0x00, 0, new boolean[]{}, 0, 0)); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{}, Conversion.byteToBinary((byte)0x00, 100, new boolean[]{}, 0, 0)); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{}, Conversion.byteToBinary((byte)0x00, 0, new boolean[]{}, 100, 0)); [EOL]         assertBinaryEquals( [EOL]             new boolean[69], Conversion.byteToBinary((byte)0xEF, 0, new boolean[69], 0, 0)); [EOL]         assertBinaryEquals(new boolean[]{ [EOL]             true, false, false, false, false, false, false, false, false, false, false, false, [EOL]             false}, Conversion.byteToBinary((byte)0x95, 0, new boolean[13], 0, 1)); [EOL]         assertBinaryEquals(new boolean[]{ [EOL]             true, false, false, false, false, false, false, false, false, false, false, false, [EOL]             false}, Conversion.byteToBinary((byte)0x95, 0, new boolean[13], 0, 2)); [EOL]         assertBinaryEquals(new boolean[]{ [EOL]             true, false, true, false, false, false, false, false, false, false, false, false, [EOL]             false}, Conversion.byteToBinary((byte)0x95, 0, new boolean[13], 0, 3)); [EOL]         assertBinaryEquals(new boolean[]{ [EOL]             true, false, true, false, true, false, false, false, false, false, false, false, [EOL]             false}, Conversion.byteToBinary((byte)0x95, 0, new boolean[13], 0, 7)); [EOL]         assertBinaryEquals(new boolean[]{ [EOL]             true, false, true, false, true, false, false, true, false, false, false, false, [EOL]             false}, Conversion.byteToBinary((byte)0x95, 0, new boolean[13], 0, 8)); [EOL]         assertBinaryEquals(new boolean[]{ [EOL]             false, false, true, false, false, false, false, false, false, false, false, false, [EOL]             false}, Conversion.byteToBinary((byte)0x95, 0, new boolean[13], 2, 1)); [EOL]         assertBinaryEquals(new boolean[]{ [EOL]             false, false, true, false, true, false, true, false, false, true, false, false, [EOL]             false}, Conversion.byteToBinary((byte)0x95, 0, new boolean[13], 2, 8)); [EOL]         assertBinaryEquals(new boolean[]{ [EOL]             false, true, false, true, false, false, true, false, false, false, false, false, [EOL]             false}, Conversion.byteToBinary((byte)0x95, 1, new boolean[13], 0, 7)); [EOL]         assertBinaryEquals(new boolean[]{ [EOL]             true, false, true, false, false, true, false, false, false, false, false, false, [EOL]             false}, Conversion.byteToBinary((byte)0x95, 2, new boolean[13], 0, 6)); [EOL]         // assertArrayEquals(new boolean[]{false, false, false, true, true, false, true, true, [EOL]         // false, false, false, false, false},Conversion.byteToBinary((byte)0x95, 2,new [EOL]         // boolean[13], 3, 7));//rejected by assertion [EOL]         assertBinaryEquals(new boolean[]{ [EOL]             false, false, false, true, false, true, false, false, true, false, false, false, [EOL]             false}, Conversion.byteToBinary((byte)0x95, 2, new boolean[13], 3, 6)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#uuidToByteArray(UUID, byte[], int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testByteToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{}, Conversion.byteToBinary((byte)0x00, 0, new boolean[]{}, 0, 0)); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{}, Conversion.byteToBinary((byte)0x00, 100, new boolean[]{}, 0, 0)); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{}, Conversion.byteToBinary((byte)0x00, 0, new boolean[]{}, 100, 0)); [EOL]         assertBinaryEquals( [EOL]             new boolean[69], Conversion.byteToBinary((byte)0xEF, 0, new boolean[69], 0, 0)); [EOL]         assertBinaryEquals(new boolean[]{ [EOL]             true, false, false, false, false, false, false, false, false, false, false, false, [EOL]             false}, Conversion.byteToBinary((byte)0x95, 0, new boolean[13], 0, 1)); [EOL]         assertBinaryEquals(new boolean[]{ [EOL]             true, false, false, false, false, false, false, false, false, false, false, false, [EOL]             false}, Conversion.byteToBinary((byte)0x95, 0, new boolean[13], 0, 2)); [EOL]         assertBinaryEquals(new boolean[]{ [EOL]             true, false, true, false, false, false, false, false, false, false, false, false, [EOL]             false}, Conversion.byteToBinary((byte)0x95, 0, new boolean[13], 0, 3)); [EOL]         assertBinaryEquals(new boolean[]{ [EOL]             true, false, true, false, true, false, false, false, false, false, false, false, [EOL]             false}, Conversion.byteToBinary((byte)0x95, 0, new boolean[13], 0, 7)); [EOL]         assertBinaryEquals(new boolean[]{ [EOL]             true, false, true, false, true, false, false, true, false, false, false, false, [EOL]             false}, Conversion.byteToBinary((byte)0x95, 0, new boolean[13], 0, 8)); [EOL]         assertBinaryEquals(new boolean[]{ [EOL]             false, false, true, false, false, false, false, false, false, false, false, false, [EOL]             false}, Conversion.byteToBinary((byte)0x95, 0, new boolean[13], 2, 1)); [EOL]         assertBinaryEquals(new boolean[]{ [EOL]             false, false, true, false, true, false, true, false, false, true, false, false, [EOL]             false}, Conversion.byteToBinary((byte)0x95, 0, new boolean[13], 2, 8)); [EOL]         assertBinaryEquals(new boolean[]{ [EOL]             false, true, false, true, false, false, true, false, false, false, false, false, [EOL]             false}, Conversion.byteToBinary((byte)0x95, 1, new boolean[13], 0, 7)); [EOL]         assertBinaryEquals(new boolean[]{ [EOL]             true, false, true, false, false, true, false, false, false, false, false, false, [EOL]             false}, Conversion.byteToBinary((byte)0x95, 2, new boolean[13], 0, 6)); [EOL]         // assertArrayEquals(new boolean[]{false, false, false, true, true, false, true, true, [EOL]         // false, false, false, false, false},Conversion.byteToBinary((byte)0x95, 2,new [EOL]         // boolean[13], 3, 7));//rejected by assertion [EOL]         assertBinaryEquals(new boolean[]{ [EOL]             false, false, false, true, false, true, false, false, true, false, false, false, [EOL]             false}, Conversion.byteToBinary((byte)0x95, 2, new boolean[13], 3, 6)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#uuidToByteArray(UUID, byte[], int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testUuidToByteArray() { [EOL]         assertArrayEquals(new byte[]{ [EOL]             (byte)0xff, (byte)0xff, (byte)0xff, (byte)0xff, (byte)0xff, (byte)0xff, (byte)0xff, [EOL]             (byte)0xff, (byte)0xff, (byte)0xff, (byte)0xff, (byte)0xff, (byte)0xff, (byte)0xff, [EOL]             (byte)0xff, (byte)0xff}, Conversion.uuidToByteArray(new UUID( [EOL]             0xFFFFFFFFFFFFFFFFL, 0xFFFFFFFFFFFFFFFFL), new byte[16], 0, 16)); [EOL]         assertArrayEquals(new byte[]{ [EOL]             (byte)0x88, (byte)0x99, (byte)0xaa, (byte)0xbb, (byte)0xcc, (byte)0xdd, (byte)0xee, [EOL]             (byte)0xff, (byte)0x00, (byte)0x11, (byte)0x22, (byte)0x33, (byte)0x44, (byte)0x55, [EOL]             (byte)0x66, (byte)0x77}, Conversion.uuidToByteArray(new UUID( [EOL]             0xFFEEDDCCBBAA9988L, 0x7766554433221100L), new byte[16], 0, 16)); [EOL]         assertArrayEquals(new byte[]{ [EOL]             (byte)0x00, (byte)0x00, (byte)0x00, (byte)0x00, (byte)0x88, (byte)0x99, (byte)0xaa, [EOL]             (byte)0xbb, (byte)0xcc, (byte)0xdd, (byte)0xee, (byte)0xff, (byte)0x00, (byte)0x00, [EOL]             (byte)0x00, (byte)0x00}, Conversion.uuidToByteArray(new UUID( [EOL]             0xFFEEDDCCBBAA9988L, 0x7766554433221100L), new byte[16], 4, 8)); [EOL]         assertArrayEquals(new byte[]{ [EOL]             (byte)0x00, (byte)0x00, (byte)0x88, (byte)0x99, (byte)0xaa, (byte)0xbb, (byte)0xcc, [EOL]             (byte)0xdd, (byte)0xee, (byte)0xff, (byte)0x00, (byte)0x11, (byte)0x22, (byte)0x33, [EOL]             (byte)0x00, (byte)0x00}, Conversion.uuidToByteArray(new UUID( [EOL]             0xFFEEDDCCBBAA9988L, 0x7766554433221100L), new byte[16], 2, 12)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#byteArrayToUuid(byte[], int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testSupplementary() { [EOL]         final NumericEntityEscaper nee = new NumericEntityEscaper(); [EOL]         final String input = "\uD803\uDC22"; [EOL]         final String expected = "&#68642;"; [EOL]  [EOL]         final String result = nee.translate(input); [EOL]         assertEquals("Failed to escape numeric entities supplementary characters", expected, result); [EOL]  [EOL]     } [EOL]  [EOL] } [EOL]
@Test [EOL]     public void testSupplementary() { [EOL]         final NumericEntityEscaper nee = new NumericEntityEscaper(); [EOL]         final String input = "\uD803\uDC22"; [EOL]         final String expected = "&#68642;"; [EOL]  [EOL]         final String result = nee.translate(input); [EOL]         assertEquals("Failed to escape numeric entities supplementary characters", expected, result); [EOL]  [EOL]     } [EOL]  [EOL] } [EOL]
@Test [EOL]     public void testSupplementary() { [EOL]         final NumericEntityEscaper nee = new NumericEntityEscaper(); [EOL]         final String input = "\uD803\uDC22"; [EOL]         final String expected = "&#68642;"; [EOL]  [EOL]         final String result = nee.translate(input); [EOL]         assertEquals("Failed to escape numeric entities supplementary characters", expected, result); [EOL]  [EOL]     } [EOL]  [EOL] } [EOL]
@Test [EOL]     public void testSupplementary() { [EOL]         final NumericEntityEscaper nee = new NumericEntityEscaper(); [EOL]         final String input = "\uD803\uDC22"; [EOL]         final String expected = "&#68642;"; [EOL]  [EOL]         final String result = nee.translate(input); [EOL]         assertEquals("Failed to escape numeric entities supplementary characters", expected, result); [EOL]  [EOL]     } [EOL]  [EOL] } [EOL]
@Test [EOL]     public void testSupplementary() { [EOL]         final NumericEntityEscaper nee = new NumericEntityEscaper(); [EOL]         final String input = "\uD803\uDC22"; [EOL]         final String expected = "&#68642;"; [EOL]  [EOL]         final String result = nee.translate(input); [EOL]         assertEquals("Failed to escape numeric entities supplementary characters", expected, result); [EOL]  [EOL]     } [EOL]  [EOL] } [EOL]
@Test [EOL]     public void testSupplementary() { [EOL]         final NumericEntityEscaper nee = new NumericEntityEscaper(); [EOL]         final String input = "\uD803\uDC22"; [EOL]         final String expected = "&#68642;"; [EOL]  [EOL]         final String result = nee.translate(input); [EOL]         assertEquals("Failed to escape numeric entities supplementary characters", expected, result); [EOL]  [EOL]     } [EOL]  [EOL] } [EOL]
@Test [EOL]     public void testBelow() { [EOL]         final NumericEntityEscaper nee = NumericEntityEscaper.below('F'); [EOL]  [EOL]         final String input = "ADFGZ"; [EOL]         final String result = nee.translate(input); [EOL]         assertEquals("Failed to escape numeric entities via the below method", "&#65;&#68;FGZ", result); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testBelow() { [EOL]         final NumericEntityEscaper nee = NumericEntityEscaper.below('F'); [EOL]  [EOL]         final String input = "ADFGZ"; [EOL]         final String result = nee.translate(input); [EOL]         assertEquals("Failed to escape numeric entities via the below method", "&#65;&#68;FGZ", result); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testAbove() { [EOL]         final NumericEntityEscaper nee = NumericEntityEscaper.above('F'); [EOL]  [EOL]         final String input = "ADFGZ"; [EOL]         final String result = nee.translate(input); [EOL]         assertEquals("Failed to escape numeric entities via the above method", "ADF&#71;&#90;", result); [EOL]     } [EOL]  [EOL]     // See LANG-617 [EOL]
@Test [EOL]     public void testAbove() { [EOL]         final NumericEntityEscaper nee = NumericEntityEscaper.above('F'); [EOL]  [EOL]         final String input = "ADFGZ"; [EOL]         final String result = nee.translate(input); [EOL]         assertEquals("Failed to escape numeric entities via the above method", "ADF&#71;&#90;", result); [EOL]     } [EOL]  [EOL]     // See LANG-617 [EOL]
@Test [EOL]     public void testBetween() { [EOL]         final NumericEntityEscaper nee = NumericEntityEscaper.between('F', 'L'); [EOL]  [EOL]         final String input = "ADFGZ"; [EOL]         final String result = nee.translate(input); [EOL]         assertEquals("Failed to escape numeric entities via the between method", "AD&#70;&#71;Z", result); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testBetween() { [EOL]         final NumericEntityEscaper nee = NumericEntityEscaper.between('F', 'L'); [EOL]  [EOL]         final String input = "ADFGZ"; [EOL]         final String result = nee.translate(input); [EOL]         assertEquals("Failed to escape numeric entities via the between method", "AD&#70;&#71;Z", result); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testBelow() { [EOL]         final NumericEntityEscaper nee = NumericEntityEscaper.below('F'); [EOL]  [EOL]         final String input = "ADFGZ"; [EOL]         final String result = nee.translate(input); [EOL]         assertEquals("Failed to escape numeric entities via the below method", "&#65;&#68;FGZ", result); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testBelow() { [EOL]         final NumericEntityEscaper nee = NumericEntityEscaper.below('F'); [EOL]  [EOL]         final String input = "ADFGZ"; [EOL]         final String result = nee.translate(input); [EOL]         assertEquals("Failed to escape numeric entities via the below method", "&#65;&#68;FGZ", result); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSupplementary() { [EOL]         final NumericEntityEscaper nee = new NumericEntityEscaper(); [EOL]         final String input = "\uD803\uDC22"; [EOL]         final String expected = "&#68642;"; [EOL]  [EOL]         final String result = nee.translate(input); [EOL]         assertEquals("Failed to escape numeric entities supplementary characters", expected, result); [EOL]  [EOL]     } [EOL]  [EOL] } [EOL]
@Test [EOL]     public void testSupplementary() { [EOL]         final NumericEntityEscaper nee = new NumericEntityEscaper(); [EOL]         final String input = "\uD803\uDC22"; [EOL]         final String expected = "&#68642;"; [EOL]  [EOL]         final String result = nee.translate(input); [EOL]         assertEquals("Failed to escape numeric entities supplementary characters", expected, result); [EOL]  [EOL]     } [EOL]  [EOL] } [EOL]
@Test [EOL]     public void testSupplementary() { [EOL]         final NumericEntityEscaper nee = new NumericEntityEscaper(); [EOL]         final String input = "\uD803\uDC22"; [EOL]         final String expected = "&#68642;"; [EOL]  [EOL]         final String result = nee.translate(input); [EOL]         assertEquals("Failed to escape numeric entities supplementary characters", expected, result); [EOL]  [EOL]     } [EOL]  [EOL] } [EOL]
@Test [EOL]     public void testBetween() { [EOL]         final NumericEntityEscaper nee = NumericEntityEscaper.between('F', 'L'); [EOL]  [EOL]         final String input = "ADFGZ"; [EOL]         final String result = nee.translate(input); [EOL]         assertEquals("Failed to escape numeric entities via the between method", "AD&#70;&#71;Z", result); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testBelow() { [EOL]         final NumericEntityEscaper nee = NumericEntityEscaper.below('F'); [EOL]  [EOL]         final String input = "ADFGZ"; [EOL]         final String result = nee.translate(input); [EOL]         assertEquals("Failed to escape numeric entities via the below method", "&#65;&#68;FGZ", result); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testBelow() { [EOL]         final NumericEntityEscaper nee = NumericEntityEscaper.below('F'); [EOL]  [EOL]         final String input = "ADFGZ"; [EOL]         final String result = nee.translate(input); [EOL]         assertEquals("Failed to escape numeric entities via the below method", "&#65;&#68;FGZ", result); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSupplementary() { [EOL]         final NumericEntityEscaper nee = new NumericEntityEscaper(); [EOL]         final String input = "\uD803\uDC22"; [EOL]         final String expected = "&#68642;"; [EOL]  [EOL]         final String result = nee.translate(input); [EOL]         assertEquals("Failed to escape numeric entities supplementary characters", expected, result); [EOL]  [EOL]     } [EOL]  [EOL] } [EOL]
@Test [EOL]     public void testSupplementary() { [EOL]         final NumericEntityEscaper nee = new NumericEntityEscaper(); [EOL]         final String input = "\uD803\uDC22"; [EOL]         final String expected = "&#68642;"; [EOL]  [EOL]         final String result = nee.translate(input); [EOL]         assertEquals("Failed to escape numeric entities supplementary characters", expected, result); [EOL]  [EOL]     } [EOL]  [EOL] } [EOL]
@Test [EOL]     public void testSupplementary() { [EOL]         final NumericEntityEscaper nee = new NumericEntityEscaper(); [EOL]         final String input = "\uD803\uDC22"; [EOL]         final String expected = "&#68642;"; [EOL]  [EOL]         final String result = nee.translate(input); [EOL]         assertEquals("Failed to escape numeric entities supplementary characters", expected, result); [EOL]  [EOL]     } [EOL]  [EOL] } [EOL]
@Test [EOL]     public void testSupplementary() { [EOL]         final NumericEntityEscaper nee = new NumericEntityEscaper(); [EOL]         final String input = "\uD803\uDC22"; [EOL]         final String expected = "&#68642;"; [EOL]  [EOL]         final String result = nee.translate(input); [EOL]         assertEquals("Failed to escape numeric entities supplementary characters", expected, result); [EOL]  [EOL]     } [EOL]  [EOL] } [EOL]
@Test [EOL]     public void testIdentityToStringAppendable() { [EOL]         final Integer i = Integer.valueOf(121); [EOL]         final String expected = "java.lang.Integer@" + Integer.toHexString(System.identityHashCode(i)); [EOL]  [EOL]         try { [EOL]             final Appendable appendable = new StringBuilder(); [EOL]             ObjectUtils.identityToString(appendable, i); [EOL]             assertEquals(expected, appendable.toString()); [EOL]         } catch(IOException ex) { [EOL]             fail("IOException unexpected"); [EOL]         } [EOL]          [EOL]         try { [EOL]             ObjectUtils.identityToString((Appendable)null, "tmp"); [EOL]             fail("NullPointerException expected"); [EOL]         } catch(final NullPointerException npe) { [EOL]         } catch (IOException ex) { [EOL]         } [EOL]          [EOL]         try { [EOL]             ObjectUtils.identityToString((Appendable)(new StringBuilder()), null); [EOL]             fail("NullPointerException expected"); [EOL]         } catch(final NullPointerException npe) { [EOL]         } catch (IOException ex) { [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIdentityToStringStringBuilder() { [EOL]         assertEquals(null, ObjectUtils.identityToString(null)); [EOL]         assertEquals( [EOL]             "java.lang.String@" + Integer.toHexString(System.identityHashCode(FOO)), [EOL]             ObjectUtils.identityToString(FOO)); [EOL]         final Integer i = Integer.valueOf(90); [EOL]         final String expected = "java.lang.Integer@" + Integer.toHexString(System.identityHashCode(i)); [EOL]          [EOL]         assertEquals(expected, ObjectUtils.identityToString(i)); [EOL]          [EOL]         final StringBuilder builder = new StringBuilder(); [EOL]         ObjectUtils.identityToString(builder, i); [EOL]         assertEquals(expected, builder.toString()); [EOL]  [EOL]         try { [EOL]             ObjectUtils.identityToString((StringBuilder)null, "tmp"); [EOL]             fail("NullPointerException expected"); [EOL]         } catch(final NullPointerException npe) { [EOL]         } [EOL]          [EOL]         try { [EOL]             ObjectUtils.identityToString(new StringBuilder(), null); [EOL]             fail("NullPointerException expected"); [EOL]         } catch(final NullPointerException npe) { [EOL]         } [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testMin() { [EOL]         final Calendar calendar = Calendar.getInstance(); [EOL]         final Date nonNullComparable1 = calendar.getTime(); [EOL]         final Date nonNullComparable2 = calendar.getTime(); [EOL]         final String[] nullAray = null; [EOL]          [EOL]         calendar.set( Calendar.YEAR, calendar.get( Calendar.YEAR ) -1 ); [EOL]         final Date minComparable = calendar.getTime(); [EOL]          [EOL]         assertNotSame( nonNullComparable1, nonNullComparable2 ); [EOL]          [EOL]         assertNull(ObjectUtils.min( (String) null ) ); [EOL]         assertNull(ObjectUtils.min( nullAray ) ); [EOL]         assertSame( nonNullComparable1, ObjectUtils.min( null, nonNullComparable1 ) ); [EOL]         assertSame( nonNullComparable1, ObjectUtils.min( nonNullComparable1, null ) ); [EOL]         assertSame( nonNullComparable1, ObjectUtils.min( null, nonNullComparable1, null ) ); [EOL]         assertSame( nonNullComparable1, ObjectUtils.min( nonNullComparable1, nonNullComparable2 ) ); [EOL]         assertSame( nonNullComparable2, ObjectUtils.min( nonNullComparable2, nonNullComparable1 ) ); [EOL]         assertSame( minComparable, ObjectUtils.min( nonNullComparable1, minComparable ) ); [EOL]         assertSame( minComparable, ObjectUtils.min( minComparable, nonNullComparable1 ) ); [EOL]         assertSame( minComparable, ObjectUtils.min( null, nonNullComparable1, null, minComparable ) ); [EOL]  [EOL]         assertNull( ObjectUtils.min((String)null, (String)null) ); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link ObjectUtils#compare(Comparable, Comparable, boolean)}. [EOL]      */ [EOL]
@Test [EOL]     public void testMax() { [EOL]         final Calendar calendar = Calendar.getInstance(); [EOL]         final Date nonNullComparable1 = calendar.getTime(); [EOL]         final Date nonNullComparable2 = calendar.getTime(); [EOL]         final String[] nullAray = null; [EOL]          [EOL]         calendar.set( Calendar.YEAR, calendar.get( Calendar.YEAR ) -1 ); [EOL]         final Date minComparable = calendar.getTime(); [EOL]          [EOL]         assertNotSame( nonNullComparable1, nonNullComparable2 ); [EOL]          [EOL]         assertNull(ObjectUtils.max( (String) null ) ); [EOL]         assertNull(ObjectUtils.max( nullAray ) ); [EOL]         assertSame( nonNullComparable1, ObjectUtils.max( null, nonNullComparable1 ) ); [EOL]         assertSame( nonNullComparable1, ObjectUtils.max( nonNullComparable1, null ) ); [EOL]         assertSame( nonNullComparable1, ObjectUtils.max( null, nonNullComparable1, null ) ); [EOL]         assertSame( nonNullComparable1, ObjectUtils.max( nonNullComparable1, nonNullComparable2 ) ); [EOL]         assertSame( nonNullComparable2, ObjectUtils.max( nonNullComparable2, nonNullComparable1 ) ); [EOL]         assertSame( nonNullComparable1, ObjectUtils.max( nonNullComparable1, minComparable ) ); [EOL]         assertSame( nonNullComparable1, ObjectUtils.max( minComparable, nonNullComparable1 ) ); [EOL]         assertSame( nonNullComparable1, ObjectUtils.max( null, minComparable, null, nonNullComparable1 ) ); [EOL]  [EOL]         assertNull( ObjectUtils.max((String)null, (String)null) ); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testCloneOfStringArray() { [EOL]         assertTrue(Arrays.deepEquals( [EOL]             new String[]{"string"}, ObjectUtils.clone(new String[]{"string"}))); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link ObjectUtils#clone(Object)} with an array of primitives. [EOL]      */ [EOL]
@Test [EOL]     public void testCloneOfStringArray() { [EOL]         assertTrue(Arrays.deepEquals( [EOL]             new String[]{"string"}, ObjectUtils.clone(new String[]{"string"}))); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link ObjectUtils#clone(Object)} with an array of primitives. [EOL]      */ [EOL]
@Test [EOL]     public void testCloneOfStringArray() { [EOL]         assertTrue(Arrays.deepEquals( [EOL]             new String[]{"string"}, ObjectUtils.clone(new String[]{"string"}))); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link ObjectUtils#clone(Object)} with an array of primitives. [EOL]      */ [EOL]
@Test [EOL]     public void testCloneOfPrimitiveArray() { [EOL]         assertTrue(Arrays.equals(new int[]{1}, ObjectUtils.clone(new int[]{1}))); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link ObjectUtils#cloneIfPossible(Object)} with a cloneable object. [EOL]      */ [EOL]
@Test [EOL]     public void testCloneOfPrimitiveArray() { [EOL]         assertTrue(Arrays.equals(new int[]{1}, ObjectUtils.clone(new int[]{1}))); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link ObjectUtils#cloneIfPossible(Object)} with a cloneable object. [EOL]      */ [EOL]
@Test [EOL]     public void testCloneOfPrimitiveArray() { [EOL]         assertTrue(Arrays.equals(new int[]{1}, ObjectUtils.clone(new int[]{1}))); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link ObjectUtils#cloneIfPossible(Object)} with a cloneable object. [EOL]      */ [EOL]
@Test [EOL]     public void testCloneOfPrimitiveArray() { [EOL]         assertTrue(Arrays.equals(new int[]{1}, ObjectUtils.clone(new int[]{1}))); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link ObjectUtils#cloneIfPossible(Object)} with a cloneable object. [EOL]      */ [EOL]
@Test(expected = NoSuchMethodException.class) [EOL]     public void testPossibleCloneOfUncloneable() throws Throwable { [EOL]         final UncloneableString string = new UncloneableString("apache"); [EOL]         try { [EOL]             ObjectUtils.cloneIfPossible(string); [EOL]             fail("Thrown " + CloneFailedException.class.getName() + " expected"); [EOL]         } catch (final CloneFailedException e) { [EOL]             throw e.getCause(); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNull() { [EOL]         assertNotNull(ObjectUtils.NULL); [EOL]         // 1 Check that NULL really is a Null i.e. the definition has not been changed [EOL]         assertTrue(ObjectUtils.NULL instanceof ObjectUtils.Null); [EOL]         assertSame(ObjectUtils.NULL, SerializationUtils.clone(ObjectUtils.NULL)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNull() { [EOL]         assertNotNull(ObjectUtils.NULL); [EOL]         // 1 Check that NULL really is a Null i.e. the definition has not been changed [EOL]         assertTrue(ObjectUtils.NULL instanceof ObjectUtils.Null); [EOL]         assertSame(ObjectUtils.NULL, SerializationUtils.clone(ObjectUtils.NULL)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testPrintRootCauseStackTrace_ThrowableWriter() throws Exception { [EOL]         StringWriter writer = new StringWriter(1024); [EOL]         ExceptionUtils.printRootCauseStackTrace(null, (PrintWriter) null); [EOL]         ExceptionUtils.printRootCauseStackTrace(null, new PrintWriter(writer)); [EOL]         assertEquals(0, writer.getBuffer().length()); [EOL]          [EOL]         writer = new StringWriter(1024); [EOL]         try { [EOL]             ExceptionUtils.printRootCauseStackTrace(withCause, (PrintWriter) null); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) { [EOL]         } [EOL]          [EOL]         writer = new StringWriter(1024); [EOL]         final Throwable withCause = createExceptionWithCause(); [EOL]         ExceptionUtils.printRootCauseStackTrace(withCause, new PrintWriter(writer)); [EOL]         String stackTrace = writer.toString(); [EOL]         assertTrue(stackTrace.indexOf(ExceptionUtils.WRAPPED_MARKER) != -1); [EOL]          [EOL]         writer = new StringWriter(1024); [EOL]         ExceptionUtils.printRootCauseStackTrace(withoutCause, new PrintWriter(writer)); [EOL]         stackTrace = writer.toString(); [EOL]         assertTrue(stackTrace.indexOf(ExceptionUtils.WRAPPED_MARKER) == -1); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testPrintRootCauseStackTrace_ThrowableWriter() throws Exception { [EOL]         StringWriter writer = new StringWriter(1024); [EOL]         ExceptionUtils.printRootCauseStackTrace(null, (PrintWriter) null); [EOL]         ExceptionUtils.printRootCauseStackTrace(null, new PrintWriter(writer)); [EOL]         assertEquals(0, writer.getBuffer().length()); [EOL]          [EOL]         writer = new StringWriter(1024); [EOL]         try { [EOL]             ExceptionUtils.printRootCauseStackTrace(withCause, (PrintWriter) null); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) { [EOL]         } [EOL]          [EOL]         writer = new StringWriter(1024); [EOL]         final Throwable withCause = createExceptionWithCause(); [EOL]         ExceptionUtils.printRootCauseStackTrace(withCause, new PrintWriter(writer)); [EOL]         String stackTrace = writer.toString(); [EOL]         assertTrue(stackTrace.indexOf(ExceptionUtils.WRAPPED_MARKER) != -1); [EOL]          [EOL]         writer = new StringWriter(1024); [EOL]         ExceptionUtils.printRootCauseStackTrace(withoutCause, new PrintWriter(writer)); [EOL]         stackTrace = writer.toString(); [EOL]         assertTrue(stackTrace.indexOf(ExceptionUtils.WRAPPED_MARKER) == -1); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testPrintRootCauseStackTrace_ThrowableWriter() throws Exception { [EOL]         StringWriter writer = new StringWriter(1024); [EOL]         ExceptionUtils.printRootCauseStackTrace(null, (PrintWriter) null); [EOL]         ExceptionUtils.printRootCauseStackTrace(null, new PrintWriter(writer)); [EOL]         assertEquals(0, writer.getBuffer().length()); [EOL]          [EOL]         writer = new StringWriter(1024); [EOL]         try { [EOL]             ExceptionUtils.printRootCauseStackTrace(withCause, (PrintWriter) null); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) { [EOL]         } [EOL]          [EOL]         writer = new StringWriter(1024); [EOL]         final Throwable withCause = createExceptionWithCause(); [EOL]         ExceptionUtils.printRootCauseStackTrace(withCause, new PrintWriter(writer)); [EOL]         String stackTrace = writer.toString(); [EOL]         assertTrue(stackTrace.indexOf(ExceptionUtils.WRAPPED_MARKER) != -1); [EOL]          [EOL]         writer = new StringWriter(1024); [EOL]         ExceptionUtils.printRootCauseStackTrace(withoutCause, new PrintWriter(writer)); [EOL]         stackTrace = writer.toString(); [EOL]         assertTrue(stackTrace.indexOf(ExceptionUtils.WRAPPED_MARKER) == -1); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testPrintRootCauseStackTrace_ThrowableWriter() throws Exception { [EOL]         StringWriter writer = new StringWriter(1024); [EOL]         ExceptionUtils.printRootCauseStackTrace(null, (PrintWriter) null); [EOL]         ExceptionUtils.printRootCauseStackTrace(null, new PrintWriter(writer)); [EOL]         assertEquals(0, writer.getBuffer().length()); [EOL]          [EOL]         writer = new StringWriter(1024); [EOL]         try { [EOL]             ExceptionUtils.printRootCauseStackTrace(withCause, (PrintWriter) null); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) { [EOL]         } [EOL]          [EOL]         writer = new StringWriter(1024); [EOL]         final Throwable withCause = createExceptionWithCause(); [EOL]         ExceptionUtils.printRootCauseStackTrace(withCause, new PrintWriter(writer)); [EOL]         String stackTrace = writer.toString(); [EOL]         assertTrue(stackTrace.indexOf(ExceptionUtils.WRAPPED_MARKER) != -1); [EOL]          [EOL]         writer = new StringWriter(1024); [EOL]         ExceptionUtils.printRootCauseStackTrace(withoutCause, new PrintWriter(writer)); [EOL]         stackTrace = writer.toString(); [EOL]         assertTrue(stackTrace.indexOf(ExceptionUtils.WRAPPED_MARKER) == -1); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testEscapeSurrogatePairsLang858() throws Exception { [EOL]         assertEquals("\\uDBFF\\uDFFD", StringEscapeUtils.escapeJava("\uDBFF\uDFFD"));       //fail LANG-858 [EOL]         assertEquals("\\uDBFF\\uDFFD", StringEscapeUtils.escapeEcmaScript("\uDBFF\uDFFD")); //fail LANG-858 [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testEscapeSurrogatePairsLang858() throws Exception { [EOL]         assertEquals("\\uDBFF\\uDFFD", StringEscapeUtils.escapeJava("\uDBFF\uDFFD"));       //fail LANG-858 [EOL]         assertEquals("\\uDBFF\\uDFFD", StringEscapeUtils.escapeEcmaScript("\uDBFF\uDFFD")); //fail LANG-858 [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testEscapeSurrogatePairsLang858() throws Exception { [EOL]         assertEquals("\\uDBFF\\uDFFD", StringEscapeUtils.escapeJava("\uDBFF\uDFFD"));       //fail LANG-858 [EOL]         assertEquals("\\uDBFF\\uDFFD", StringEscapeUtils.escapeEcmaScript("\uDBFF\uDFFD")); //fail LANG-858 [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testTimeZoneMatches() { [EOL]         final DateParser parser= getInstance(yMdHmsSZ, REYKJAVIK); [EOL]         assertEquals(REYKJAVIK, parser.getTimeZone()); [EOL]     } [EOL] } [EOL]
@Test [EOL]     public void testTimeZoneMatches() { [EOL]         final DateParser parser= getInstance(yMdHmsSZ, REYKJAVIK); [EOL]         assertEquals(REYKJAVIK, parser.getTimeZone()); [EOL]     } [EOL] } [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLang303() throws ParseException { [EOL]         DateParser parser = getInstance(YMD_SLASH); [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2004, 11, 31); [EOL]  [EOL]         final Date date = parser.parse("2004/11/31"); [EOL]  [EOL]         parser = SerializationUtils.deserialize(SerializationUtils.serialize((Serializable) parser)); [EOL]         assertEquals(date, parser.parse("2004/11/31")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLang303() throws ParseException { [EOL]         DateParser parser = getInstance(YMD_SLASH); [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2004, 11, 31); [EOL]  [EOL]         final Date date = parser.parse("2004/11/31"); [EOL]  [EOL]         parser = SerializationUtils.deserialize(SerializationUtils.serialize((Serializable) parser)); [EOL]         assertEquals(date, parser.parse("2004/11/31")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLang303() throws ParseException { [EOL]         DateParser parser = getInstance(YMD_SLASH); [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2004, 11, 31); [EOL]  [EOL]         final Date date = parser.parse("2004/11/31"); [EOL]  [EOL]         parser = SerializationUtils.deserialize(SerializationUtils.serialize((Serializable) parser)); [EOL]         assertEquals(date, parser.parse("2004/11/31")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSpecialCharacters() throws Exception { [EOL]         testSdfAndFdp("q" ,"", true); // bad pattern character (at present) [EOL]         testSdfAndFdp("Q" ,"", true); // bad pattern character [EOL]         testSdfAndFdp("$" ,"$", false); // OK [EOL]         testSdfAndFdp("?.d" ,"?.12", false); // OK [EOL]         testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); // OK [EOL]         testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); // OK [EOL]         testSdfAndFdp("'$\\Ed'" ,"$\\Ed", false); // OK [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSpecialCharacters() throws Exception { [EOL]         testSdfAndFdp("q" ,"", true); // bad pattern character (at present) [EOL]         testSdfAndFdp("Q" ,"", true); // bad pattern character [EOL]         testSdfAndFdp("$" ,"$", false); // OK [EOL]         testSdfAndFdp("?.d" ,"?.12", false); // OK [EOL]         testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); // OK [EOL]         testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); // OK [EOL]         testSdfAndFdp("'$\\Ed'" ,"$\\Ed", false); // OK [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSpecialCharacters() throws Exception { [EOL]         testSdfAndFdp("q" ,"", true); // bad pattern character (at present) [EOL]         testSdfAndFdp("Q" ,"", true); // bad pattern character [EOL]         testSdfAndFdp("$" ,"$", false); // OK [EOL]         testSdfAndFdp("?.d" ,"?.12", false); // OK [EOL]         testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); // OK [EOL]         testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); // OK [EOL]         testSdfAndFdp("'$\\Ed'" ,"$\\Ed", false); // OK [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSpecialCharacters() throws Exception { [EOL]         testSdfAndFdp("q" ,"", true); // bad pattern character (at present) [EOL]         testSdfAndFdp("Q" ,"", true); // bad pattern character [EOL]         testSdfAndFdp("$" ,"$", false); // OK [EOL]         testSdfAndFdp("?.d" ,"?.12", false); // OK [EOL]         testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); // OK [EOL]         testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); // OK [EOL]         testSdfAndFdp("'$\\Ed'" ,"$\\Ed", false); // OK [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSpecialCharacters() throws Exception { [EOL]         testSdfAndFdp("q" ,"", true); // bad pattern character (at present) [EOL]         testSdfAndFdp("Q" ,"", true); // bad pattern character [EOL]         testSdfAndFdp("$" ,"$", false); // OK [EOL]         testSdfAndFdp("?.d" ,"?.12", false); // OK [EOL]         testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); // OK [EOL]         testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); // OK [EOL]         testSdfAndFdp("'$\\Ed'" ,"$\\Ed", false); // OK [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSpecialCharacters() throws Exception { [EOL]         testSdfAndFdp("q" ,"", true); // bad pattern character (at present) [EOL]         testSdfAndFdp("Q" ,"", true); // bad pattern character [EOL]         testSdfAndFdp("$" ,"$", false); // OK [EOL]         testSdfAndFdp("?.d" ,"?.12", false); // OK [EOL]         testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); // OK [EOL]         testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); // OK [EOL]         testSdfAndFdp("'$\\Ed'" ,"$\\Ed", false); // OK [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSpecialCharacters() throws Exception { [EOL]         testSdfAndFdp("q" ,"", true); // bad pattern character (at present) [EOL]         testSdfAndFdp("Q" ,"", true); // bad pattern character [EOL]         testSdfAndFdp("$" ,"$", false); // OK [EOL]         testSdfAndFdp("?.d" ,"?.12", false); // OK [EOL]         testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); // OK [EOL]         testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); // OK [EOL]         testSdfAndFdp("'$\\Ed'" ,"$\\Ed", false); // OK [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSpecialCharacters() throws Exception { [EOL]         testSdfAndFdp("q" ,"", true); // bad pattern character (at present) [EOL]         testSdfAndFdp("Q" ,"", true); // bad pattern character [EOL]         testSdfAndFdp("$" ,"$", false); // OK [EOL]         testSdfAndFdp("?.d" ,"?.12", false); // OK [EOL]         testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); // OK [EOL]         testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); // OK [EOL]         testSdfAndFdp("'$\\Ed'" ,"$\\Ed", false); // OK [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSpecialCharacters() throws Exception { [EOL]         testSdfAndFdp("q" ,"", true); // bad pattern character (at present) [EOL]         testSdfAndFdp("Q" ,"", true); // bad pattern character [EOL]         testSdfAndFdp("$" ,"$", false); // OK [EOL]         testSdfAndFdp("?.d" ,"?.12", false); // OK [EOL]         testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); // OK [EOL]         testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); // OK [EOL]         testSdfAndFdp("'$\\Ed'" ,"$\\Ed", false); // OK [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLocales_ShortNoEra_AD() throws Exception { [EOL]         testLocales(SHORT_FORMAT_NOERA, false); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLocales_ShortNoEra_AD() throws Exception { [EOL]         testLocales(SHORT_FORMAT_NOERA, false); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLocales_ShortNoEra_AD() throws Exception { [EOL]         testLocales(SHORT_FORMAT_NOERA, false); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLocales_ShortNoEra_AD() throws Exception { [EOL]         testLocales(SHORT_FORMAT_NOERA, false); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLocales_ShortNoEra_AD() throws Exception { [EOL]         testLocales(SHORT_FORMAT_NOERA, false); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLocales_ShortNoEra_AD() throws Exception { [EOL]         testLocales(SHORT_FORMAT_NOERA, false); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLocales_ShortNoEra_AD() throws Exception { [EOL]         testLocales(SHORT_FORMAT_NOERA, false); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLocales_ShortNoEra_AD() throws Exception { [EOL]         testLocales(SHORT_FORMAT_NOERA, false); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLocales_ShortNoEra_AD() throws Exception { [EOL]         testLocales(SHORT_FORMAT_NOERA, false); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testParseLongShort() throws ParseException { [EOL]         final Calendar cal= Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal.clear(); [EOL]         cal.set(2003, 1, 10, 15, 33, 20); [EOL]         cal.set(Calendar.MILLISECOND, 989); [EOL]         cal.setTimeZone(NEW_YORK); [EOL]  [EOL]         DateParser fdf = getInstance("yyyy GGGG MMMM dddd aaaa EEEE HHHH mmmm ssss SSSS ZZZZ", NEW_YORK, Locale.US); [EOL]  [EOL]         assertEquals(cal.getTime(), fdf.parse("2003 AD February 0010 PM Monday 0015 0033 0020 0989 GMT-05:00")); [EOL]         cal.set(Calendar.ERA, GregorianCalendar.BC); [EOL]  [EOL]         final Date parse = fdf.parse("2003 BC February 0010 PM Saturday 0015 0033 0020 0989 GMT-05:00"); [EOL]                 assertEquals(cal.getTime(), parse); [EOL]  [EOL]         fdf = getInstance("y G M d a E H m s S Z", NEW_YORK, Locale.US); [EOL]         assertEquals(cal.getTime(), fdf.parse("03 BC 2 10 PM Sat 15 33 20 989 -0500")); [EOL]  [EOL]         cal.set(Calendar.ERA, GregorianCalendar.AD); [EOL]         assertEquals(cal.getTime(), fdf.parse("03 AD 2 10 PM Saturday 15 33 20 989 -0500")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testParseLongShort() throws ParseException { [EOL]         final Calendar cal= Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal.clear(); [EOL]         cal.set(2003, 1, 10, 15, 33, 20); [EOL]         cal.set(Calendar.MILLISECOND, 989); [EOL]         cal.setTimeZone(NEW_YORK); [EOL]  [EOL]         DateParser fdf = getInstance("yyyy GGGG MMMM dddd aaaa EEEE HHHH mmmm ssss SSSS ZZZZ", NEW_YORK, Locale.US); [EOL]  [EOL]         assertEquals(cal.getTime(), fdf.parse("2003 AD February 0010 PM Monday 0015 0033 0020 0989 GMT-05:00")); [EOL]         cal.set(Calendar.ERA, GregorianCalendar.BC); [EOL]  [EOL]         final Date parse = fdf.parse("2003 BC February 0010 PM Saturday 0015 0033 0020 0989 GMT-05:00"); [EOL]                 assertEquals(cal.getTime(), parse); [EOL]  [EOL]         fdf = getInstance("y G M d a E H m s S Z", NEW_YORK, Locale.US); [EOL]         assertEquals(cal.getTime(), fdf.parse("03 BC 2 10 PM Sat 15 33 20 989 -0500")); [EOL]  [EOL]         cal.set(Calendar.ERA, GregorianCalendar.AD); [EOL]         assertEquals(cal.getTime(), fdf.parse("03 AD 2 10 PM Saturday 15 33 20 989 -0500")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLocales_ShortNoEra_AD() throws Exception { [EOL]         testLocales(SHORT_FORMAT_NOERA, false); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLang538() throws ParseException { [EOL]         final DateParser parser = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", GMT); [EOL]  [EOL]         final Calendar cal = Calendar.getInstance(TimeZone.getTimeZone("GMT-8")); [EOL]         cal.clear(); [EOL]         cal.set(2009, 9, 16, 8, 42, 16); [EOL]  [EOL]         assertEquals(cal.getTime(), parser.parse("2009-10-16T16:42:16.000Z")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLang538() throws ParseException { [EOL]         final DateParser parser = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", GMT); [EOL]  [EOL]         final Calendar cal = Calendar.getInstance(TimeZone.getTimeZone("GMT-8")); [EOL]         cal.clear(); [EOL]         cal.set(2009, 9, 16, 8, 42, 16); [EOL]  [EOL]         assertEquals(cal.getTime(), parser.parse("2009-10-16T16:42:16.000Z")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLocales_ShortNoEra_AD() throws Exception { [EOL]         testLocales(SHORT_FORMAT_NOERA, false); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLocales_ShortNoEra_AD() throws Exception { [EOL]         testLocales(SHORT_FORMAT_NOERA, false); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNullExceptionPassing() { [EOL]         exceptionContext = new ContextedRuntimeException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE), null) [EOL]         .addContextValue("test1", null) [EOL]         .addContextValue("test2", "some value") [EOL]         .addContextValue("test Date", new Date()) [EOL]         .addContextValue("test Nbr", Integer.valueOf(5)) [EOL]         .addContextValue("test Poorly written obj", new ObjectWithFaultyToString()); [EOL]          [EOL]         final String message = exceptionContext.getMessage(); [EOL]         assertTrue(message != null); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testUuuuu() { [EOL]         final UnicodeUnescaper uu = new UnicodeUnescaper(); [EOL]  [EOL]         final String input = "\\uuuuuuuu0047"; [EOL]         final String result = uu.translate(input); [EOL]         assertEquals("Failed to unescape Unicode characters with many 'u' characters", "G", result); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testUPlus() { [EOL]         final UnicodeUnescaper uu = new UnicodeUnescaper(); [EOL]  [EOL]         final String input = "\\u+0047"; [EOL]         assertEquals("Failed to unescape Unicode characters with 'u+' notation", "G", uu.translate(input)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testUPlus() { [EOL]         final UnicodeUnescaper uu = new UnicodeUnescaper(); [EOL]  [EOL]         final String input = "\\u+0047"; [EOL]         assertEquals("Failed to unescape Unicode characters with 'u+' notation", "G", uu.translate(input)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testUPlus() { [EOL]         final UnicodeUnescaper uu = new UnicodeUnescaper(); [EOL]  [EOL]         final String input = "\\u+0047"; [EOL]         assertEquals("Failed to unescape Unicode characters with 'u+' notation", "G", uu.translate(input)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testUPlus() { [EOL]         final UnicodeUnescaper uu = new UnicodeUnescaper(); [EOL]  [EOL]         final String input = "\\u+0047"; [EOL]         assertEquals("Failed to unescape Unicode characters with 'u+' notation", "G", uu.translate(input)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testUPlus() { [EOL]         final UnicodeUnescaper uu = new UnicodeUnescaper(); [EOL]  [EOL]         final String input = "\\u+0047"; [EOL]         assertEquals("Failed to unescape Unicode characters with 'u+' notation", "G", uu.translate(input)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testUnescapeJava() throws IOException { [EOL]         assertEquals(null, StringEscapeUtils.unescapeJava(null)); [EOL]         try { [EOL]             StringEscapeUtils.UNESCAPE_JAVA.translate(null, null); [EOL]             fail(); [EOL]         } catch (final IOException ex) { [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) { [EOL]         } [EOL]         try { [EOL]             StringEscapeUtils.UNESCAPE_JAVA.translate("", null); [EOL]             fail(); [EOL]         } catch (final IOException ex) { [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) { [EOL]         } [EOL]         try { [EOL]             StringEscapeUtils.unescapeJava("\\u02-3"); [EOL]             fail(); [EOL]         } catch (final RuntimeException ex) { [EOL]         } [EOL]          [EOL]         assertUnescapeJava("", ""); [EOL]         assertUnescapeJava("test", "test"); [EOL]         assertUnescapeJava("\ntest\b", "\\ntest\\b"); [EOL]         assertUnescapeJava("\u123425foo\ntest\b", "\\u123425foo\\ntest\\b"); [EOL]         assertUnescapeJava("'\foo\teste\r", "\\'\\foo\\teste\\r"); [EOL]         assertUnescapeJava("", "\\"); [EOL]         //foo [EOL]         assertUnescapeJava("lowercase Unicode", "\uABCDx", "\\uabcdx"); [EOL]         assertUnescapeJava("uppercase Unicode", "\uABCDx", "\\uABCDx"); [EOL]         assertUnescapeJava("Unicode as final character", "\uABCD", "\\uabcd"); [EOL]     } [EOL]  [EOL]     private void assertUnescapeJava(final String unescaped, final String original) throws IOException { [EOL]         assertUnescapeJava(null, unescaped, original); [EOL]     } [EOL]  [EOL]     private void assertUnescapeJava(final String message, final String unescaped, final String original) throws IOException { [EOL]         final String expected = unescaped; [EOL]         final String actual = StringEscapeUtils.unescapeJava(original); [EOL]  [EOL]         assertEquals("unescape(String) failed" + [EOL]                 (message == null ? "" : (": " + message)) + [EOL]                 ": expected '" + StringEscapeUtils.escapeJava(expected) + [EOL]                 // we escape this so we can see it in the error message [EOL]                 "' actual '" + StringEscapeUtils.escapeJava(actual) + "'", [EOL]                 expected, actual); [EOL]  [EOL]         final StringWriter writer = new StringWriter(); [EOL]         StringEscapeUtils.UNESCAPE_JAVA.translate(original, writer); [EOL]         assertEquals(unescaped, writer.toString()); [EOL]  [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testUPlus() { [EOL]         final UnicodeUnescaper uu = new UnicodeUnescaper(); [EOL]  [EOL]         final String input = "\\u+0047"; [EOL]         assertEquals("Failed to unescape Unicode characters with 'u+' notation", "G", uu.translate(input)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLongArrayAsObject() { [EOL]         final long[] obj = new long[2]; [EOL]         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]         obj[0] = 5L; [EOL]         final int h1 = (int) (5L ^ 5L >> 32); [EOL]         assertEquals((17 * 37 + h1) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]         obj[1] = 6L; [EOL]         final int h2 = (int) (6L ^ 6L >> 32); [EOL]         assertEquals((17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIntArrayAsObject() { [EOL]         final int[] obj = new int[2]; [EOL]         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]         obj[0] = 5; [EOL]         assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]         obj[1] = 6; [EOL]         assertEquals((17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testShortArrayAsObject() { [EOL]         final short[] obj = new short[2]; [EOL]         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]         obj[0] = (short) 5; [EOL]         assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]         obj[1] = (short) 6; [EOL]         assertEquals((17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testBooleanMultiArray() { [EOL]         final boolean[][] obj = new boolean[2][]; [EOL]         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]         obj[0] = new boolean[0]; [EOL]         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]         obj[0] = new boolean[1]; [EOL]         assertEquals((17 * 37 + 1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]         obj[0] = new boolean[2]; [EOL]         assertEquals(((17 * 37 + 1) * 37 + 1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]         obj[0][0] = true; [EOL]         assertEquals(((17 * 37 + 0) * 37 + 1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]         obj[1] = new boolean[1]; [EOL]         assertEquals(((17 * 37 + 0) * 37 + 1) * 37 + 1, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testByteArrayAsObject() { [EOL]         final byte[] obj = new byte[2]; [EOL]         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]         obj[0] = (byte) 5; [EOL]         assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]         obj[1] = (byte) 6; [EOL]         assertEquals((17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testBooleanMultiArray() { [EOL]         final boolean[][] obj = new boolean[2][]; [EOL]         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]         obj[0] = new boolean[0]; [EOL]         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]         obj[0] = new boolean[1]; [EOL]         assertEquals((17 * 37 + 1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]         obj[0] = new boolean[2]; [EOL]         assertEquals(((17 * 37 + 1) * 37 + 1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]         obj[0][0] = true; [EOL]         assertEquals(((17 * 37 + 0) * 37 + 1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]         obj[1] = new boolean[1]; [EOL]         assertEquals(((17 * 37 + 0) * 37 + 1) * 37 + 1, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testDoubleArrayAsObject() { [EOL]         final double[] obj = new double[2]; [EOL]         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]         obj[0] = 5.4d; [EOL]         final long l1 = Double.doubleToLongBits(5.4d); [EOL]         final int h1 = (int) (l1 ^ l1 >> 32); [EOL]         assertEquals((17 * 37 + h1) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]         obj[1] = 6.3d; [EOL]         final long l2 = Double.doubleToLongBits(6.3d); [EOL]         final int h2 = (int) (l2 ^ l2 >> 32); [EOL]         assertEquals((17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testBooleanMultiArray() { [EOL]         final boolean[][] obj = new boolean[2][]; [EOL]         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]         obj[0] = new boolean[0]; [EOL]         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]         obj[0] = new boolean[1]; [EOL]         assertEquals((17 * 37 + 1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]         obj[0] = new boolean[2]; [EOL]         assertEquals(((17 * 37 + 1) * 37 + 1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]         obj[0][0] = true; [EOL]         assertEquals(((17 * 37 + 0) * 37 + 1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]         obj[1] = new boolean[1]; [EOL]         assertEquals(((17 * 37 + 0) * 37 + 1) * 37 + 1, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testFloatArrayAsObject() { [EOL]         final float[] obj = new float[2]; [EOL]         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]         obj[0] = 5.4f; [EOL]         final int h1 = Float.floatToIntBits(5.4f); [EOL]         assertEquals((17 * 37 + h1) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]         obj[1] = 6.3f; [EOL]         final int h2 = Float.floatToIntBits(6.3f); [EOL]         assertEquals((17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testBooleanMultiArray() { [EOL]         final boolean[][] obj = new boolean[2][]; [EOL]         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]         obj[0] = new boolean[0]; [EOL]         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]         obj[0] = new boolean[1]; [EOL]         assertEquals((17 * 37 + 1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]         obj[0] = new boolean[2]; [EOL]         assertEquals(((17 * 37 + 1) * 37 + 1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]         obj[0][0] = true; [EOL]         assertEquals(((17 * 37 + 0) * 37 + 1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]         obj[1] = new boolean[1]; [EOL]         assertEquals(((17 * 37 + 0) * 37 + 1) * 37 + 1, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testBooleanMultiArray() { [EOL]         final boolean[][] obj = new boolean[2][]; [EOL]         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]         obj[0] = new boolean[0]; [EOL]         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]         obj[0] = new boolean[1]; [EOL]         assertEquals((17 * 37 + 1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]         obj[0] = new boolean[2]; [EOL]         assertEquals(((17 * 37 + 1) * 37 + 1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]         obj[0][0] = true; [EOL]         assertEquals(((17 * 37 + 0) * 37 + 1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]         obj[1] = new boolean[1]; [EOL]         assertEquals(((17 * 37 + 0) * 37 + 1) * 37 + 1, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testObjectArrayAsObject() { [EOL]         final Object[] obj = new Object[2]; [EOL]         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]         obj[0] = new Object(); [EOL]         assertEquals((17 * 37 + obj[0].hashCode()) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]         obj[1] = new Object(); [EOL]         assertEquals((17 * 37 + obj[0].hashCode()) * 37 + obj[1].hashCode(), new HashCodeBuilder(17, 37).append( [EOL]                 (Object) obj).toHashCode()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testBetween() { [EOL]         final OctalUnescaper oue = new OctalUnescaper();   //.between("1", "377"); [EOL]  [EOL]         String input = "\\45"; [EOL]         String result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\45", result); [EOL]  [EOL]         input = "\\377"; [EOL]         result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\377", result); [EOL]  [EOL]         input = "\\377 and"; [EOL]         result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\377 and", result); [EOL]  [EOL]         input = "\\378 and"; [EOL]         result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\378 and", result); [EOL]  [EOL]         input = "\\378"; [EOL]         result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\378", result); [EOL]  [EOL]         input = "\\1"; [EOL]         result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\1", result); [EOL]     } [EOL]  [EOL] } [EOL]
@Test [EOL]     public void testBetween() { [EOL]         final OctalUnescaper oue = new OctalUnescaper();   //.between("1", "377"); [EOL]  [EOL]         String input = "\\45"; [EOL]         String result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\45", result); [EOL]  [EOL]         input = "\\377"; [EOL]         result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\377", result); [EOL]  [EOL]         input = "\\377 and"; [EOL]         result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\377 and", result); [EOL]  [EOL]         input = "\\378 and"; [EOL]         result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\378 and", result); [EOL]  [EOL]         input = "\\378"; [EOL]         result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\378", result); [EOL]  [EOL]         input = "\\1"; [EOL]         result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\1", result); [EOL]     } [EOL]  [EOL] } [EOL]
@Test [EOL]     public void testBetween() { [EOL]         final OctalUnescaper oue = new OctalUnescaper();   //.between("1", "377"); [EOL]  [EOL]         String input = "\\45"; [EOL]         String result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\45", result); [EOL]  [EOL]         input = "\\377"; [EOL]         result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\377", result); [EOL]  [EOL]         input = "\\377 and"; [EOL]         result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\377 and", result); [EOL]  [EOL]         input = "\\378 and"; [EOL]         result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\378 and", result); [EOL]  [EOL]         input = "\\378"; [EOL]         result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\378", result); [EOL]  [EOL]         input = "\\1"; [EOL]         result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\1", result); [EOL]     } [EOL]  [EOL] } [EOL]
@Test [EOL]     public void testBetween() { [EOL]         final OctalUnescaper oue = new OctalUnescaper();   //.between("1", "377"); [EOL]  [EOL]         String input = "\\45"; [EOL]         String result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\45", result); [EOL]  [EOL]         input = "\\377"; [EOL]         result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\377", result); [EOL]  [EOL]         input = "\\377 and"; [EOL]         result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\377 and", result); [EOL]  [EOL]         input = "\\378 and"; [EOL]         result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\378 and", result); [EOL]  [EOL]         input = "\\378"; [EOL]         result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\378", result); [EOL]  [EOL]         input = "\\1"; [EOL]         result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\1", result); [EOL]     } [EOL]  [EOL] } [EOL]
@Test [EOL]     public void testBetween() { [EOL]         final OctalUnescaper oue = new OctalUnescaper();   //.between("1", "377"); [EOL]  [EOL]         String input = "\\45"; [EOL]         String result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\45", result); [EOL]  [EOL]         input = "\\377"; [EOL]         result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\377", result); [EOL]  [EOL]         input = "\\377 and"; [EOL]         result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\377 and", result); [EOL]  [EOL]         input = "\\378 and"; [EOL]         result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\378 and", result); [EOL]  [EOL]         input = "\\378"; [EOL]         result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\378", result); [EOL]  [EOL]         input = "\\1"; [EOL]         result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\1", result); [EOL]     } [EOL]  [EOL] } [EOL]
@Test [EOL]     public void testBetween() { [EOL]         final OctalUnescaper oue = new OctalUnescaper();   //.between("1", "377"); [EOL]  [EOL]         String input = "\\45"; [EOL]         String result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\45", result); [EOL]  [EOL]         input = "\\377"; [EOL]         result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\377", result); [EOL]  [EOL]         input = "\\377 and"; [EOL]         result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\377 and", result); [EOL]  [EOL]         input = "\\378 and"; [EOL]         result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\378 and", result); [EOL]  [EOL]         input = "\\378"; [EOL]         result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\378", result); [EOL]  [EOL]         input = "\\1"; [EOL]         result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\1", result); [EOL]     } [EOL]  [EOL] } [EOL]
@Test [EOL]     public void testBetween() { [EOL]         final OctalUnescaper oue = new OctalUnescaper();   //.between("1", "377"); [EOL]  [EOL]         String input = "\\45"; [EOL]         String result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\45", result); [EOL]  [EOL]         input = "\\377"; [EOL]         result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\377", result); [EOL]  [EOL]         input = "\\377 and"; [EOL]         result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\377 and", result); [EOL]  [EOL]         input = "\\378 and"; [EOL]         result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\378 and", result); [EOL]  [EOL]         input = "\\378"; [EOL]         result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\378", result); [EOL]  [EOL]         input = "\\1"; [EOL]         result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\1", result); [EOL]     } [EOL]  [EOL] } [EOL]
@Test [EOL]     public void testBetween() { [EOL]         final OctalUnescaper oue = new OctalUnescaper();   //.between("1", "377"); [EOL]  [EOL]         String input = "\\45"; [EOL]         String result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\45", result); [EOL]  [EOL]         input = "\\377"; [EOL]         result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\377", result); [EOL]  [EOL]         input = "\\377 and"; [EOL]         result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\377 and", result); [EOL]  [EOL]         input = "\\378 and"; [EOL]         result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\378 and", result); [EOL]  [EOL]         input = "\\378"; [EOL]         result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\378", result); [EOL]  [EOL]         input = "\\1"; [EOL]         result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\1", result); [EOL]     } [EOL]  [EOL] } [EOL]
@Test [EOL]     public void testBetween() { [EOL]         final OctalUnescaper oue = new OctalUnescaper();   //.between("1", "377"); [EOL]  [EOL]         String input = "\\45"; [EOL]         String result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\45", result); [EOL]  [EOL]         input = "\\377"; [EOL]         result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\377", result); [EOL]  [EOL]         input = "\\377 and"; [EOL]         result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\377 and", result); [EOL]  [EOL]         input = "\\378 and"; [EOL]         result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\378 and", result); [EOL]  [EOL]         input = "\\378"; [EOL]         result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\378", result); [EOL]  [EOL]         input = "\\1"; [EOL]         result = oue.translate(input); [EOL]         assertEquals("Failed to unescape octal characters via the between method", "\1", result); [EOL]     } [EOL]  [EOL] } [EOL]
@Test [EOL]     public void testEscapeJson() { [EOL]         assertEquals(null, StringEscapeUtils.escapeJson(null)); [EOL]         try { [EOL]             StringEscapeUtils.ESCAPE_JSON.translate(null, null); [EOL]             fail(); [EOL]         } catch (final IOException ex) { [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) { [EOL]         } [EOL]         try { [EOL]             StringEscapeUtils.ESCAPE_JSON.translate("", null); [EOL]             fail(); [EOL]         } catch (final IOException ex) { [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) { [EOL]         } [EOL]  [EOL]         assertEquals("He didn't say, \\\"stop!\\\"", StringEscapeUtils.escapeJson("He didn't say, \"stop!\"")); [EOL]  [EOL]         String expected = "\\\"foo\\\" isn't \\\"bar\\\". specials: \\b\\r\\n\\f\\t\\\\\\/"; [EOL]         String input ="\"foo\" isn't \"bar\". specials: \b\r\n\f\t\\/"; [EOL]  [EOL]         assertEquals(expected, StringEscapeUtils.escapeJson(input)); [EOL]     } [EOL]  [EOL] } [EOL]
@Test [EOL]     public void testEscapeHtml() { [EOL]         for (int i = 0; i < HTML_ESCAPES.length; ++i) { [EOL]             final String message = HTML_ESCAPES[i][0]; [EOL]             final String expected = HTML_ESCAPES[i][1]; [EOL]             final String original = HTML_ESCAPES[i][2]; [EOL]             assertEquals(message, expected, StringEscapeUtils.escapeHtml4(original)); [EOL]             final StringWriter sw = new StringWriter(); [EOL]             try { [EOL]                 StringEscapeUtils.ESCAPE_HTML4.translate(original, sw); [EOL]             } catch (final IOException e) { [EOL]             } [EOL]             final String actual = original == null ? null : sw.toString(); [EOL]             assertEquals(message, expected, actual); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEscapeSurrogatePairsLang858() throws Exception { [EOL]         assertEquals("\\uDBFF\\uDFFD", StringEscapeUtils.escapeJava("\uDBFF\uDFFD"));       //fail LANG-858 [EOL]         assertEquals("\\uDBFF\\uDFFD", StringEscapeUtils.escapeEcmaScript("\uDBFF\uDFFD")); //fail LANG-858 [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testEscapeSurrogatePairsLang858() throws Exception { [EOL]         assertEquals("\\uDBFF\\uDFFD", StringEscapeUtils.escapeJava("\uDBFF\uDFFD"));       //fail LANG-858 [EOL]         assertEquals("\\uDBFF\\uDFFD", StringEscapeUtils.escapeEcmaScript("\uDBFF\uDFFD")); //fail LANG-858 [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testFormatDurationWords() { [EOL]         String text = null; [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, true, false); [EOL]         assertEquals("50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, true, false); [EOL]         assertEquals("1 minute 5 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(120 * 1000, true, false); [EOL]         assertEquals("2 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(121 * 1000, true, false); [EOL]         assertEquals("2 minutes 1 second", text); [EOL]         text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false); [EOL]         assertEquals("1 hour 12 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false); [EOL]         assertEquals("1 day 0 hours 0 minutes 0 seconds", text); [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, true, true); [EOL]         assertEquals("50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, true, true); [EOL]         assertEquals("1 minute 5 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(120 * 1000, true, true); [EOL]         assertEquals("2 minutes", text); [EOL]         text = DurationFormatUtils.formatDurationWords(121 * 1000, true, true); [EOL]         assertEquals("2 minutes 1 second", text); [EOL]         text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, true); [EOL]         assertEquals("1 hour 12 minutes", text); [EOL]         text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, true); [EOL]         assertEquals("1 day", text); [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, false, true); [EOL]         assertEquals("0 days 0 hours 0 minutes 50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, false, true); [EOL]         assertEquals("0 days 0 hours 1 minute 5 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(120 * 1000, false, true); [EOL]         assertEquals("0 days 0 hours 2 minutes", text); [EOL]         text = DurationFormatUtils.formatDurationWords(121 * 1000, false, true); [EOL]         assertEquals("0 days 0 hours 2 minutes 1 second", text); [EOL]         text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, false, true); [EOL]         assertEquals("0 days 1 hour 12 minutes", text); [EOL]         text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, false, true); [EOL]         assertEquals("1 day", text); [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, false, false); [EOL]         assertEquals("0 days 0 hours 0 minutes 50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, false, false); [EOL]         assertEquals("0 days 0 hours 1 minute 5 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(120 * 1000, false, false); [EOL]         assertEquals("0 days 0 hours 2 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(121 * 1000, false, false); [EOL]         assertEquals("0 days 0 hours 2 minutes 1 second", text); [EOL]         text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, false, false); [EOL]         assertEquals("0 days 1 hour 12 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000 + 72 * 60 * 1000, false, false); [EOL]         assertEquals("1 day 1 hour 12 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(2 * 24 * 60 * 60 * 1000 + 72 * 60 * 1000, false, false); [EOL]         assertEquals("2 days 1 hour 12 minutes 0 seconds", text); [EOL]         for (int i = 2; i < 31; i++) { [EOL]             text = DurationFormatUtils.formatDurationWords(i * 24 * 60 * 60 * 1000L, false, false); [EOL]             // assertEquals(i + " days 0 hours 0 minutes 0 seconds", text); [EOL]             //             [EOL]             // junit.framework.ComparisonFailure: expected:<25 days 0 hours 0 minutes 0...> but was:<-24 days -17 hours [EOL]             // -2 minutes -47...> [EOL]             // at junit.framework.Assert.assertEquals(Assert.java:81) [EOL]             // at junit.framework.Assert.assertEquals(Assert.java:87) [EOL]             // at [EOL]             // org.apache.commons.lang.time.DurationFormatUtilsTest.testFormatDurationWords(DurationFormatUtilsTest.java:124) [EOL]             // at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) [EOL]             // at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) [EOL]             // at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) [EOL]             // at java.lang.reflect.Method.invoke(Method.java:324) [EOL]             // at junit.framework.TestCase.runTest(TestCase.java:154) [EOL]             // at junit.framework.TestCase.runBare(TestCase.java:127) [EOL]             // at junit.framework.TestResult$1.protect(TestResult.java:106) [EOL]             // at junit.framework.TestResult.runProtected(TestResult.java:124) [EOL]             // at junit.framework.TestResult.run(TestResult.java:109) [EOL]             // at junit.framework.TestCase.run(TestCase.java:118) [EOL]             // at junit.framework.TestSuite.runTest(TestSuite.java:208) [EOL]             // at junit.framework.TestSuite.run(TestSuite.java:203) [EOL]             // at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:478) [EOL]             // at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:344) [EOL]             // at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests that "1 <unit>s" gets converted to "1 <unit>" but that "11 <unit>s" is left alone. [EOL]      */ [EOL]
@Test [EOL]     public void testFormatDurationWords() { [EOL]         String text = null; [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, true, false); [EOL]         assertEquals("50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, true, false); [EOL]         assertEquals("1 minute 5 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(120 * 1000, true, false); [EOL]         assertEquals("2 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(121 * 1000, true, false); [EOL]         assertEquals("2 minutes 1 second", text); [EOL]         text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false); [EOL]         assertEquals("1 hour 12 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false); [EOL]         assertEquals("1 day 0 hours 0 minutes 0 seconds", text); [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, true, true); [EOL]         assertEquals("50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, true, true); [EOL]         assertEquals("1 minute 5 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(120 * 1000, true, true); [EOL]         assertEquals("2 minutes", text); [EOL]         text = DurationFormatUtils.formatDurationWords(121 * 1000, true, true); [EOL]         assertEquals("2 minutes 1 second", text); [EOL]         text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, true); [EOL]         assertEquals("1 hour 12 minutes", text); [EOL]         text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, true); [EOL]         assertEquals("1 day", text); [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, false, true); [EOL]         assertEquals("0 days 0 hours 0 minutes 50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, false, true); [EOL]         assertEquals("0 days 0 hours 1 minute 5 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(120 * 1000, false, true); [EOL]         assertEquals("0 days 0 hours 2 minutes", text); [EOL]         text = DurationFormatUtils.formatDurationWords(121 * 1000, false, true); [EOL]         assertEquals("0 days 0 hours 2 minutes 1 second", text); [EOL]         text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, false, true); [EOL]         assertEquals("0 days 1 hour 12 minutes", text); [EOL]         text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, false, true); [EOL]         assertEquals("1 day", text); [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, false, false); [EOL]         assertEquals("0 days 0 hours 0 minutes 50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, false, false); [EOL]         assertEquals("0 days 0 hours 1 minute 5 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(120 * 1000, false, false); [EOL]         assertEquals("0 days 0 hours 2 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(121 * 1000, false, false); [EOL]         assertEquals("0 days 0 hours 2 minutes 1 second", text); [EOL]         text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, false, false); [EOL]         assertEquals("0 days 1 hour 12 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000 + 72 * 60 * 1000, false, false); [EOL]         assertEquals("1 day 1 hour 12 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(2 * 24 * 60 * 60 * 1000 + 72 * 60 * 1000, false, false); [EOL]         assertEquals("2 days 1 hour 12 minutes 0 seconds", text); [EOL]         for (int i = 2; i < 31; i++) { [EOL]             text = DurationFormatUtils.formatDurationWords(i * 24 * 60 * 60 * 1000L, false, false); [EOL]             // assertEquals(i + " days 0 hours 0 minutes 0 seconds", text); [EOL]             //             [EOL]             // junit.framework.ComparisonFailure: expected:<25 days 0 hours 0 minutes 0...> but was:<-24 days -17 hours [EOL]             // -2 minutes -47...> [EOL]             // at junit.framework.Assert.assertEquals(Assert.java:81) [EOL]             // at junit.framework.Assert.assertEquals(Assert.java:87) [EOL]             // at [EOL]             // org.apache.commons.lang.time.DurationFormatUtilsTest.testFormatDurationWords(DurationFormatUtilsTest.java:124) [EOL]             // at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) [EOL]             // at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) [EOL]             // at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) [EOL]             // at java.lang.reflect.Method.invoke(Method.java:324) [EOL]             // at junit.framework.TestCase.runTest(TestCase.java:154) [EOL]             // at junit.framework.TestCase.runBare(TestCase.java:127) [EOL]             // at junit.framework.TestResult$1.protect(TestResult.java:106) [EOL]             // at junit.framework.TestResult.runProtected(TestResult.java:124) [EOL]             // at junit.framework.TestResult.run(TestResult.java:109) [EOL]             // at junit.framework.TestCase.run(TestCase.java:118) [EOL]             // at junit.framework.TestSuite.runTest(TestSuite.java:208) [EOL]             // at junit.framework.TestSuite.run(TestSuite.java:203) [EOL]             // at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:478) [EOL]             // at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:344) [EOL]             // at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests that "1 <unit>s" gets converted to "1 <unit>" but that "11 <unit>s" is left alone. [EOL]      */ [EOL]
@Test [EOL]     public void testFormatDurationWords() { [EOL]         String text = null; [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, true, false); [EOL]         assertEquals("50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, true, false); [EOL]         assertEquals("1 minute 5 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(120 * 1000, true, false); [EOL]         assertEquals("2 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(121 * 1000, true, false); [EOL]         assertEquals("2 minutes 1 second", text); [EOL]         text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false); [EOL]         assertEquals("1 hour 12 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false); [EOL]         assertEquals("1 day 0 hours 0 minutes 0 seconds", text); [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, true, true); [EOL]         assertEquals("50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, true, true); [EOL]         assertEquals("1 minute 5 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(120 * 1000, true, true); [EOL]         assertEquals("2 minutes", text); [EOL]         text = DurationFormatUtils.formatDurationWords(121 * 1000, true, true); [EOL]         assertEquals("2 minutes 1 second", text); [EOL]         text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, true); [EOL]         assertEquals("1 hour 12 minutes", text); [EOL]         text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, true); [EOL]         assertEquals("1 day", text); [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, false, true); [EOL]         assertEquals("0 days 0 hours 0 minutes 50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, false, true); [EOL]         assertEquals("0 days 0 hours 1 minute 5 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(120 * 1000, false, true); [EOL]         assertEquals("0 days 0 hours 2 minutes", text); [EOL]         text = DurationFormatUtils.formatDurationWords(121 * 1000, false, true); [EOL]         assertEquals("0 days 0 hours 2 minutes 1 second", text); [EOL]         text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, false, true); [EOL]         assertEquals("0 days 1 hour 12 minutes", text); [EOL]         text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, false, true); [EOL]         assertEquals("1 day", text); [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, false, false); [EOL]         assertEquals("0 days 0 hours 0 minutes 50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, false, false); [EOL]         assertEquals("0 days 0 hours 1 minute 5 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(120 * 1000, false, false); [EOL]         assertEquals("0 days 0 hours 2 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(121 * 1000, false, false); [EOL]         assertEquals("0 days 0 hours 2 minutes 1 second", text); [EOL]         text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, false, false); [EOL]         assertEquals("0 days 1 hour 12 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000 + 72 * 60 * 1000, false, false); [EOL]         assertEquals("1 day 1 hour 12 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(2 * 24 * 60 * 60 * 1000 + 72 * 60 * 1000, false, false); [EOL]         assertEquals("2 days 1 hour 12 minutes 0 seconds", text); [EOL]         for (int i = 2; i < 31; i++) { [EOL]             text = DurationFormatUtils.formatDurationWords(i * 24 * 60 * 60 * 1000L, false, false); [EOL]             // assertEquals(i + " days 0 hours 0 minutes 0 seconds", text); [EOL]             //             [EOL]             // junit.framework.ComparisonFailure: expected:<25 days 0 hours 0 minutes 0...> but was:<-24 days -17 hours [EOL]             // -2 minutes -47...> [EOL]             // at junit.framework.Assert.assertEquals(Assert.java:81) [EOL]             // at junit.framework.Assert.assertEquals(Assert.java:87) [EOL]             // at [EOL]             // org.apache.commons.lang.time.DurationFormatUtilsTest.testFormatDurationWords(DurationFormatUtilsTest.java:124) [EOL]             // at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) [EOL]             // at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) [EOL]             // at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) [EOL]             // at java.lang.reflect.Method.invoke(Method.java:324) [EOL]             // at junit.framework.TestCase.runTest(TestCase.java:154) [EOL]             // at junit.framework.TestCase.runBare(TestCase.java:127) [EOL]             // at junit.framework.TestResult$1.protect(TestResult.java:106) [EOL]             // at junit.framework.TestResult.runProtected(TestResult.java:124) [EOL]             // at junit.framework.TestResult.run(TestResult.java:109) [EOL]             // at junit.framework.TestCase.run(TestCase.java:118) [EOL]             // at junit.framework.TestSuite.runTest(TestSuite.java:208) [EOL]             // at junit.framework.TestSuite.run(TestSuite.java:203) [EOL]             // at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:478) [EOL]             // at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:344) [EOL]             // at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests that "1 <unit>s" gets converted to "1 <unit>" but that "11 <unit>s" is left alone. [EOL]      */ [EOL]
@Test [EOL]     public void testFormatDurationWords() { [EOL]         String text = null; [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, true, false); [EOL]         assertEquals("50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, true, false); [EOL]         assertEquals("1 minute 5 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(120 * 1000, true, false); [EOL]         assertEquals("2 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(121 * 1000, true, false); [EOL]         assertEquals("2 minutes 1 second", text); [EOL]         text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false); [EOL]         assertEquals("1 hour 12 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false); [EOL]         assertEquals("1 day 0 hours 0 minutes 0 seconds", text); [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, true, true); [EOL]         assertEquals("50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, true, true); [EOL]         assertEquals("1 minute 5 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(120 * 1000, true, true); [EOL]         assertEquals("2 minutes", text); [EOL]         text = DurationFormatUtils.formatDurationWords(121 * 1000, true, true); [EOL]         assertEquals("2 minutes 1 second", text); [EOL]         text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, true); [EOL]         assertEquals("1 hour 12 minutes", text); [EOL]         text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, true); [EOL]         assertEquals("1 day", text); [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, false, true); [EOL]         assertEquals("0 days 0 hours 0 minutes 50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, false, true); [EOL]         assertEquals("0 days 0 hours 1 minute 5 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(120 * 1000, false, true); [EOL]         assertEquals("0 days 0 hours 2 minutes", text); [EOL]         text = DurationFormatUtils.formatDurationWords(121 * 1000, false, true); [EOL]         assertEquals("0 days 0 hours 2 minutes 1 second", text); [EOL]         text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, false, true); [EOL]         assertEquals("0 days 1 hour 12 minutes", text); [EOL]         text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, false, true); [EOL]         assertEquals("1 day", text); [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, false, false); [EOL]         assertEquals("0 days 0 hours 0 minutes 50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, false, false); [EOL]         assertEquals("0 days 0 hours 1 minute 5 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(120 * 1000, false, false); [EOL]         assertEquals("0 days 0 hours 2 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(121 * 1000, false, false); [EOL]         assertEquals("0 days 0 hours 2 minutes 1 second", text); [EOL]         text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, false, false); [EOL]         assertEquals("0 days 1 hour 12 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000 + 72 * 60 * 1000, false, false); [EOL]         assertEquals("1 day 1 hour 12 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(2 * 24 * 60 * 60 * 1000 + 72 * 60 * 1000, false, false); [EOL]         assertEquals("2 days 1 hour 12 minutes 0 seconds", text); [EOL]         for (int i = 2; i < 31; i++) { [EOL]             text = DurationFormatUtils.formatDurationWords(i * 24 * 60 * 60 * 1000L, false, false); [EOL]             // assertEquals(i + " days 0 hours 0 minutes 0 seconds", text); [EOL]             //             [EOL]             // junit.framework.ComparisonFailure: expected:<25 days 0 hours 0 minutes 0...> but was:<-24 days -17 hours [EOL]             // -2 minutes -47...> [EOL]             // at junit.framework.Assert.assertEquals(Assert.java:81) [EOL]             // at junit.framework.Assert.assertEquals(Assert.java:87) [EOL]             // at [EOL]             // org.apache.commons.lang.time.DurationFormatUtilsTest.testFormatDurationWords(DurationFormatUtilsTest.java:124) [EOL]             // at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) [EOL]             // at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) [EOL]             // at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) [EOL]             // at java.lang.reflect.Method.invoke(Method.java:324) [EOL]             // at junit.framework.TestCase.runTest(TestCase.java:154) [EOL]             // at junit.framework.TestCase.runBare(TestCase.java:127) [EOL]             // at junit.framework.TestResult$1.protect(TestResult.java:106) [EOL]             // at junit.framework.TestResult.runProtected(TestResult.java:124) [EOL]             // at junit.framework.TestResult.run(TestResult.java:109) [EOL]             // at junit.framework.TestCase.run(TestCase.java:118) [EOL]             // at junit.framework.TestSuite.runTest(TestSuite.java:208) [EOL]             // at junit.framework.TestSuite.run(TestSuite.java:203) [EOL]             // at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:478) [EOL]             // at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:344) [EOL]             // at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests that "1 <unit>s" gets converted to "1 <unit>" but that "11 <unit>s" is left alone. [EOL]      */ [EOL]
@Test [EOL]     public void testFormatDurationWords() { [EOL]         String text = null; [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, true, false); [EOL]         assertEquals("50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, true, false); [EOL]         assertEquals("1 minute 5 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(120 * 1000, true, false); [EOL]         assertEquals("2 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(121 * 1000, true, false); [EOL]         assertEquals("2 minutes 1 second", text); [EOL]         text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false); [EOL]         assertEquals("1 hour 12 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false); [EOL]         assertEquals("1 day 0 hours 0 minutes 0 seconds", text); [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, true, true); [EOL]         assertEquals("50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, true, true); [EOL]         assertEquals("1 minute 5 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(120 * 1000, true, true); [EOL]         assertEquals("2 minutes", text); [EOL]         text = DurationFormatUtils.formatDurationWords(121 * 1000, true, true); [EOL]         assertEquals("2 minutes 1 second", text); [EOL]         text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, true); [EOL]         assertEquals("1 hour 12 minutes", text); [EOL]         text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, true); [EOL]         assertEquals("1 day", text); [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, false, true); [EOL]         assertEquals("0 days 0 hours 0 minutes 50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, false, true); [EOL]         assertEquals("0 days 0 hours 1 minute 5 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(120 * 1000, false, true); [EOL]         assertEquals("0 days 0 hours 2 minutes", text); [EOL]         text = DurationFormatUtils.formatDurationWords(121 * 1000, false, true); [EOL]         assertEquals("0 days 0 hours 2 minutes 1 second", text); [EOL]         text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, false, true); [EOL]         assertEquals("0 days 1 hour 12 minutes", text); [EOL]         text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, false, true); [EOL]         assertEquals("1 day", text); [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, false, false); [EOL]         assertEquals("0 days 0 hours 0 minutes 50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, false, false); [EOL]         assertEquals("0 days 0 hours 1 minute 5 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(120 * 1000, false, false); [EOL]         assertEquals("0 days 0 hours 2 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(121 * 1000, false, false); [EOL]         assertEquals("0 days 0 hours 2 minutes 1 second", text); [EOL]         text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, false, false); [EOL]         assertEquals("0 days 1 hour 12 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000 + 72 * 60 * 1000, false, false); [EOL]         assertEquals("1 day 1 hour 12 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(2 * 24 * 60 * 60 * 1000 + 72 * 60 * 1000, false, false); [EOL]         assertEquals("2 days 1 hour 12 minutes 0 seconds", text); [EOL]         for (int i = 2; i < 31; i++) { [EOL]             text = DurationFormatUtils.formatDurationWords(i * 24 * 60 * 60 * 1000L, false, false); [EOL]             // assertEquals(i + " days 0 hours 0 minutes 0 seconds", text); [EOL]             //             [EOL]             // junit.framework.ComparisonFailure: expected:<25 days 0 hours 0 minutes 0...> but was:<-24 days -17 hours [EOL]             // -2 minutes -47...> [EOL]             // at junit.framework.Assert.assertEquals(Assert.java:81) [EOL]             // at junit.framework.Assert.assertEquals(Assert.java:87) [EOL]             // at [EOL]             // org.apache.commons.lang.time.DurationFormatUtilsTest.testFormatDurationWords(DurationFormatUtilsTest.java:124) [EOL]             // at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) [EOL]             // at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) [EOL]             // at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) [EOL]             // at java.lang.reflect.Method.invoke(Method.java:324) [EOL]             // at junit.framework.TestCase.runTest(TestCase.java:154) [EOL]             // at junit.framework.TestCase.runBare(TestCase.java:127) [EOL]             // at junit.framework.TestResult$1.protect(TestResult.java:106) [EOL]             // at junit.framework.TestResult.runProtected(TestResult.java:124) [EOL]             // at junit.framework.TestResult.run(TestResult.java:109) [EOL]             // at junit.framework.TestCase.run(TestCase.java:118) [EOL]             // at junit.framework.TestSuite.runTest(TestSuite.java:208) [EOL]             // at junit.framework.TestSuite.run(TestSuite.java:203) [EOL]             // at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:478) [EOL]             // at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:344) [EOL]             // at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests that "1 <unit>s" gets converted to "1 <unit>" but that "11 <unit>s" is left alone. [EOL]      */ [EOL]
@Test [EOL]     public void testFormatDurationWords() { [EOL]         String text = null; [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, true, false); [EOL]         assertEquals("50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, true, false); [EOL]         assertEquals("1 minute 5 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(120 * 1000, true, false); [EOL]         assertEquals("2 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(121 * 1000, true, false); [EOL]         assertEquals("2 minutes 1 second", text); [EOL]         text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false); [EOL]         assertEquals("1 hour 12 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false); [EOL]         assertEquals("1 day 0 hours 0 minutes 0 seconds", text); [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, true, true); [EOL]         assertEquals("50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, true, true); [EOL]         assertEquals("1 minute 5 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(120 * 1000, true, true); [EOL]         assertEquals("2 minutes", text); [EOL]         text = DurationFormatUtils.formatDurationWords(121 * 1000, true, true); [EOL]         assertEquals("2 minutes 1 second", text); [EOL]         text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, true); [EOL]         assertEquals("1 hour 12 minutes", text); [EOL]         text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, true); [EOL]         assertEquals("1 day", text); [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, false, true); [EOL]         assertEquals("0 days 0 hours 0 minutes 50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, false, true); [EOL]         assertEquals("0 days 0 hours 1 minute 5 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(120 * 1000, false, true); [EOL]         assertEquals("0 days 0 hours 2 minutes", text); [EOL]         text = DurationFormatUtils.formatDurationWords(121 * 1000, false, true); [EOL]         assertEquals("0 days 0 hours 2 minutes 1 second", text); [EOL]         text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, false, true); [EOL]         assertEquals("0 days 1 hour 12 minutes", text); [EOL]         text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, false, true); [EOL]         assertEquals("1 day", text); [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, false, false); [EOL]         assertEquals("0 days 0 hours 0 minutes 50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, false, false); [EOL]         assertEquals("0 days 0 hours 1 minute 5 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(120 * 1000, false, false); [EOL]         assertEquals("0 days 0 hours 2 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(121 * 1000, false, false); [EOL]         assertEquals("0 days 0 hours 2 minutes 1 second", text); [EOL]         text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, false, false); [EOL]         assertEquals("0 days 1 hour 12 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000 + 72 * 60 * 1000, false, false); [EOL]         assertEquals("1 day 1 hour 12 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(2 * 24 * 60 * 60 * 1000 + 72 * 60 * 1000, false, false); [EOL]         assertEquals("2 days 1 hour 12 minutes 0 seconds", text); [EOL]         for (int i = 2; i < 31; i++) { [EOL]             text = DurationFormatUtils.formatDurationWords(i * 24 * 60 * 60 * 1000L, false, false); [EOL]             // assertEquals(i + " days 0 hours 0 minutes 0 seconds", text); [EOL]             //             [EOL]             // junit.framework.ComparisonFailure: expected:<25 days 0 hours 0 minutes 0...> but was:<-24 days -17 hours [EOL]             // -2 minutes -47...> [EOL]             // at junit.framework.Assert.assertEquals(Assert.java:81) [EOL]             // at junit.framework.Assert.assertEquals(Assert.java:87) [EOL]             // at [EOL]             // org.apache.commons.lang.time.DurationFormatUtilsTest.testFormatDurationWords(DurationFormatUtilsTest.java:124) [EOL]             // at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) [EOL]             // at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) [EOL]             // at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) [EOL]             // at java.lang.reflect.Method.invoke(Method.java:324) [EOL]             // at junit.framework.TestCase.runTest(TestCase.java:154) [EOL]             // at junit.framework.TestCase.runBare(TestCase.java:127) [EOL]             // at junit.framework.TestResult$1.protect(TestResult.java:106) [EOL]             // at junit.framework.TestResult.runProtected(TestResult.java:124) [EOL]             // at junit.framework.TestResult.run(TestResult.java:109) [EOL]             // at junit.framework.TestCase.run(TestCase.java:118) [EOL]             // at junit.framework.TestSuite.runTest(TestSuite.java:208) [EOL]             // at junit.framework.TestSuite.run(TestSuite.java:203) [EOL]             // at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:478) [EOL]             // at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:344) [EOL]             // at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests that "1 <unit>s" gets converted to "1 <unit>" but that "11 <unit>s" is left alone. [EOL]      */ [EOL]
@Test [EOL]     public void testFormatDurationWords() { [EOL]         String text = null; [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, true, false); [EOL]         assertEquals("50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, true, false); [EOL]         assertEquals("1 minute 5 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(120 * 1000, true, false); [EOL]         assertEquals("2 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(121 * 1000, true, false); [EOL]         assertEquals("2 minutes 1 second", text); [EOL]         text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false); [EOL]         assertEquals("1 hour 12 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false); [EOL]         assertEquals("1 day 0 hours 0 minutes 0 seconds", text); [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, true, true); [EOL]         assertEquals("50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, true, true); [EOL]         assertEquals("1 minute 5 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(120 * 1000, true, true); [EOL]         assertEquals("2 minutes", text); [EOL]         text = DurationFormatUtils.formatDurationWords(121 * 1000, true, true); [EOL]         assertEquals("2 minutes 1 second", text); [EOL]         text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, true); [EOL]         assertEquals("1 hour 12 minutes", text); [EOL]         text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, true); [EOL]         assertEquals("1 day", text); [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, false, true); [EOL]         assertEquals("0 days 0 hours 0 minutes 50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, false, true); [EOL]         assertEquals("0 days 0 hours 1 minute 5 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(120 * 1000, false, true); [EOL]         assertEquals("0 days 0 hours 2 minutes", text); [EOL]         text = DurationFormatUtils.formatDurationWords(121 * 1000, false, true); [EOL]         assertEquals("0 days 0 hours 2 minutes 1 second", text); [EOL]         text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, false, true); [EOL]         assertEquals("0 days 1 hour 12 minutes", text); [EOL]         text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, false, true); [EOL]         assertEquals("1 day", text); [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, false, false); [EOL]         assertEquals("0 days 0 hours 0 minutes 50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, false, false); [EOL]         assertEquals("0 days 0 hours 1 minute 5 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(120 * 1000, false, false); [EOL]         assertEquals("0 days 0 hours 2 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(121 * 1000, false, false); [EOL]         assertEquals("0 days 0 hours 2 minutes 1 second", text); [EOL]         text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, false, false); [EOL]         assertEquals("0 days 1 hour 12 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000 + 72 * 60 * 1000, false, false); [EOL]         assertEquals("1 day 1 hour 12 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(2 * 24 * 60 * 60 * 1000 + 72 * 60 * 1000, false, false); [EOL]         assertEquals("2 days 1 hour 12 minutes 0 seconds", text); [EOL]         for (int i = 2; i < 31; i++) { [EOL]             text = DurationFormatUtils.formatDurationWords(i * 24 * 60 * 60 * 1000L, false, false); [EOL]             // assertEquals(i + " days 0 hours 0 minutes 0 seconds", text); [EOL]             //             [EOL]             // junit.framework.ComparisonFailure: expected:<25 days 0 hours 0 minutes 0...> but was:<-24 days -17 hours [EOL]             // -2 minutes -47...> [EOL]             // at junit.framework.Assert.assertEquals(Assert.java:81) [EOL]             // at junit.framework.Assert.assertEquals(Assert.java:87) [EOL]             // at [EOL]             // org.apache.commons.lang.time.DurationFormatUtilsTest.testFormatDurationWords(DurationFormatUtilsTest.java:124) [EOL]             // at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) [EOL]             // at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) [EOL]             // at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) [EOL]             // at java.lang.reflect.Method.invoke(Method.java:324) [EOL]             // at junit.framework.TestCase.runTest(TestCase.java:154) [EOL]             // at junit.framework.TestCase.runBare(TestCase.java:127) [EOL]             // at junit.framework.TestResult$1.protect(TestResult.java:106) [EOL]             // at junit.framework.TestResult.runProtected(TestResult.java:124) [EOL]             // at junit.framework.TestResult.run(TestResult.java:109) [EOL]             // at junit.framework.TestCase.run(TestCase.java:118) [EOL]             // at junit.framework.TestSuite.runTest(TestSuite.java:208) [EOL]             // at junit.framework.TestSuite.run(TestSuite.java:203) [EOL]             // at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:478) [EOL]             // at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:344) [EOL]             // at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests that "1 <unit>s" gets converted to "1 <unit>" but that "11 <unit>s" is left alone. [EOL]      */ [EOL]
@Test [EOL]     public void testFormatDurationWords() { [EOL]         String text = null; [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, true, false); [EOL]         assertEquals("50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, true, false); [EOL]         assertEquals("1 minute 5 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(120 * 1000, true, false); [EOL]         assertEquals("2 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(121 * 1000, true, false); [EOL]         assertEquals("2 minutes 1 second", text); [EOL]         text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false); [EOL]         assertEquals("1 hour 12 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false); [EOL]         assertEquals("1 day 0 hours 0 minutes 0 seconds", text); [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, true, true); [EOL]         assertEquals("50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, true, true); [EOL]         assertEquals("1 minute 5 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(120 * 1000, true, true); [EOL]         assertEquals("2 minutes", text); [EOL]         text = DurationFormatUtils.formatDurationWords(121 * 1000, true, true); [EOL]         assertEquals("2 minutes 1 second", text); [EOL]         text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, true); [EOL]         assertEquals("1 hour 12 minutes", text); [EOL]         text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, true); [EOL]         assertEquals("1 day", text); [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, false, true); [EOL]         assertEquals("0 days 0 hours 0 minutes 50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, false, true); [EOL]         assertEquals("0 days 0 hours 1 minute 5 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(120 * 1000, false, true); [EOL]         assertEquals("0 days 0 hours 2 minutes", text); [EOL]         text = DurationFormatUtils.formatDurationWords(121 * 1000, false, true); [EOL]         assertEquals("0 days 0 hours 2 minutes 1 second", text); [EOL]         text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, false, true); [EOL]         assertEquals("0 days 1 hour 12 minutes", text); [EOL]         text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, false, true); [EOL]         assertEquals("1 day", text); [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, false, false); [EOL]         assertEquals("0 days 0 hours 0 minutes 50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, false, false); [EOL]         assertEquals("0 days 0 hours 1 minute 5 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(120 * 1000, false, false); [EOL]         assertEquals("0 days 0 hours 2 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(121 * 1000, false, false); [EOL]         assertEquals("0 days 0 hours 2 minutes 1 second", text); [EOL]         text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, false, false); [EOL]         assertEquals("0 days 1 hour 12 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000 + 72 * 60 * 1000, false, false); [EOL]         assertEquals("1 day 1 hour 12 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(2 * 24 * 60 * 60 * 1000 + 72 * 60 * 1000, false, false); [EOL]         assertEquals("2 days 1 hour 12 minutes 0 seconds", text); [EOL]         for (int i = 2; i < 31; i++) { [EOL]             text = DurationFormatUtils.formatDurationWords(i * 24 * 60 * 60 * 1000L, false, false); [EOL]             // assertEquals(i + " days 0 hours 0 minutes 0 seconds", text); [EOL]             //             [EOL]             // junit.framework.ComparisonFailure: expected:<25 days 0 hours 0 minutes 0...> but was:<-24 days -17 hours [EOL]             // -2 minutes -47...> [EOL]             // at junit.framework.Assert.assertEquals(Assert.java:81) [EOL]             // at junit.framework.Assert.assertEquals(Assert.java:87) [EOL]             // at [EOL]             // org.apache.commons.lang.time.DurationFormatUtilsTest.testFormatDurationWords(DurationFormatUtilsTest.java:124) [EOL]             // at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) [EOL]             // at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) [EOL]             // at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) [EOL]             // at java.lang.reflect.Method.invoke(Method.java:324) [EOL]             // at junit.framework.TestCase.runTest(TestCase.java:154) [EOL]             // at junit.framework.TestCase.runBare(TestCase.java:127) [EOL]             // at junit.framework.TestResult$1.protect(TestResult.java:106) [EOL]             // at junit.framework.TestResult.runProtected(TestResult.java:124) [EOL]             // at junit.framework.TestResult.run(TestResult.java:109) [EOL]             // at junit.framework.TestCase.run(TestCase.java:118) [EOL]             // at junit.framework.TestSuite.runTest(TestSuite.java:208) [EOL]             // at junit.framework.TestSuite.run(TestSuite.java:203) [EOL]             // at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:478) [EOL]             // at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:344) [EOL]             // at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests that "1 <unit>s" gets converted to "1 <unit>" but that "11 <unit>s" is left alone. [EOL]      */ [EOL]
@Test [EOL]     public void testFormatDurationWords() { [EOL]         String text = null; [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, true, false); [EOL]         assertEquals("50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, true, false); [EOL]         assertEquals("1 minute 5 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(120 * 1000, true, false); [EOL]         assertEquals("2 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(121 * 1000, true, false); [EOL]         assertEquals("2 minutes 1 second", text); [EOL]         text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false); [EOL]         assertEquals("1 hour 12 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false); [EOL]         assertEquals("1 day 0 hours 0 minutes 0 seconds", text); [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, true, true); [EOL]         assertEquals("50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, true, true); [EOL]         assertEquals("1 minute 5 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(120 * 1000, true, true); [EOL]         assertEquals("2 minutes", text); [EOL]         text = DurationFormatUtils.formatDurationWords(121 * 1000, true, true); [EOL]         assertEquals("2 minutes 1 second", text); [EOL]         text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, true); [EOL]         assertEquals("1 hour 12 minutes", text); [EOL]         text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, true); [EOL]         assertEquals("1 day", text); [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, false, true); [EOL]         assertEquals("0 days 0 hours 0 minutes 50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, false, true); [EOL]         assertEquals("0 days 0 hours 1 minute 5 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(120 * 1000, false, true); [EOL]         assertEquals("0 days 0 hours 2 minutes", text); [EOL]         text = DurationFormatUtils.formatDurationWords(121 * 1000, false, true); [EOL]         assertEquals("0 days 0 hours 2 minutes 1 second", text); [EOL]         text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, false, true); [EOL]         assertEquals("0 days 1 hour 12 minutes", text); [EOL]         text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, false, true); [EOL]         assertEquals("1 day", text); [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, false, false); [EOL]         assertEquals("0 days 0 hours 0 minutes 50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, false, false); [EOL]         assertEquals("0 days 0 hours 1 minute 5 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(120 * 1000, false, false); [EOL]         assertEquals("0 days 0 hours 2 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(121 * 1000, false, false); [EOL]         assertEquals("0 days 0 hours 2 minutes 1 second", text); [EOL]         text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, false, false); [EOL]         assertEquals("0 days 1 hour 12 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000 + 72 * 60 * 1000, false, false); [EOL]         assertEquals("1 day 1 hour 12 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(2 * 24 * 60 * 60 * 1000 + 72 * 60 * 1000, false, false); [EOL]         assertEquals("2 days 1 hour 12 minutes 0 seconds", text); [EOL]         for (int i = 2; i < 31; i++) { [EOL]             text = DurationFormatUtils.formatDurationWords(i * 24 * 60 * 60 * 1000L, false, false); [EOL]             // assertEquals(i + " days 0 hours 0 minutes 0 seconds", text); [EOL]             //             [EOL]             // junit.framework.ComparisonFailure: expected:<25 days 0 hours 0 minutes 0...> but was:<-24 days -17 hours [EOL]             // -2 minutes -47...> [EOL]             // at junit.framework.Assert.assertEquals(Assert.java:81) [EOL]             // at junit.framework.Assert.assertEquals(Assert.java:87) [EOL]             // at [EOL]             // org.apache.commons.lang.time.DurationFormatUtilsTest.testFormatDurationWords(DurationFormatUtilsTest.java:124) [EOL]             // at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) [EOL]             // at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) [EOL]             // at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) [EOL]             // at java.lang.reflect.Method.invoke(Method.java:324) [EOL]             // at junit.framework.TestCase.runTest(TestCase.java:154) [EOL]             // at junit.framework.TestCase.runBare(TestCase.java:127) [EOL]             // at junit.framework.TestResult$1.protect(TestResult.java:106) [EOL]             // at junit.framework.TestResult.runProtected(TestResult.java:124) [EOL]             // at junit.framework.TestResult.run(TestResult.java:109) [EOL]             // at junit.framework.TestCase.run(TestCase.java:118) [EOL]             // at junit.framework.TestSuite.runTest(TestSuite.java:208) [EOL]             // at junit.framework.TestSuite.run(TestSuite.java:203) [EOL]             // at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:478) [EOL]             // at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:344) [EOL]             // at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests that "1 <unit>s" gets converted to "1 <unit>" but that "11 <unit>s" is left alone. [EOL]      */ [EOL]
@Test [EOL]     public void testFormatDurationWords() { [EOL]         String text = null; [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, true, false); [EOL]         assertEquals("50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, true, false); [EOL]         assertEquals("1 minute 5 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(120 * 1000, true, false); [EOL]         assertEquals("2 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(121 * 1000, true, false); [EOL]         assertEquals("2 minutes 1 second", text); [EOL]         text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false); [EOL]         assertEquals("1 hour 12 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false); [EOL]         assertEquals("1 day 0 hours 0 minutes 0 seconds", text); [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, true, true); [EOL]         assertEquals("50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, true, true); [EOL]         assertEquals("1 minute 5 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(120 * 1000, true, true); [EOL]         assertEquals("2 minutes", text); [EOL]         text = DurationFormatUtils.formatDurationWords(121 * 1000, true, true); [EOL]         assertEquals("2 minutes 1 second", text); [EOL]         text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, true); [EOL]         assertEquals("1 hour 12 minutes", text); [EOL]         text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, true); [EOL]         assertEquals("1 day", text); [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, false, true); [EOL]         assertEquals("0 days 0 hours 0 minutes 50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, false, true); [EOL]         assertEquals("0 days 0 hours 1 minute 5 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(120 * 1000, false, true); [EOL]         assertEquals("0 days 0 hours 2 minutes", text); [EOL]         text = DurationFormatUtils.formatDurationWords(121 * 1000, false, true); [EOL]         assertEquals("0 days 0 hours 2 minutes 1 second", text); [EOL]         text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, false, true); [EOL]         assertEquals("0 days 1 hour 12 minutes", text); [EOL]         text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, false, true); [EOL]         assertEquals("1 day", text); [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, false, false); [EOL]         assertEquals("0 days 0 hours 0 minutes 50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, false, false); [EOL]         assertEquals("0 days 0 hours 1 minute 5 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(120 * 1000, false, false); [EOL]         assertEquals("0 days 0 hours 2 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(121 * 1000, false, false); [EOL]         assertEquals("0 days 0 hours 2 minutes 1 second", text); [EOL]         text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, false, false); [EOL]         assertEquals("0 days 1 hour 12 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000 + 72 * 60 * 1000, false, false); [EOL]         assertEquals("1 day 1 hour 12 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(2 * 24 * 60 * 60 * 1000 + 72 * 60 * 1000, false, false); [EOL]         assertEquals("2 days 1 hour 12 minutes 0 seconds", text); [EOL]         for (int i = 2; i < 31; i++) { [EOL]             text = DurationFormatUtils.formatDurationWords(i * 24 * 60 * 60 * 1000L, false, false); [EOL]             // assertEquals(i + " days 0 hours 0 minutes 0 seconds", text); [EOL]             //             [EOL]             // junit.framework.ComparisonFailure: expected:<25 days 0 hours 0 minutes 0...> but was:<-24 days -17 hours [EOL]             // -2 minutes -47...> [EOL]             // at junit.framework.Assert.assertEquals(Assert.java:81) [EOL]             // at junit.framework.Assert.assertEquals(Assert.java:87) [EOL]             // at [EOL]             // org.apache.commons.lang.time.DurationFormatUtilsTest.testFormatDurationWords(DurationFormatUtilsTest.java:124) [EOL]             // at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) [EOL]             // at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) [EOL]             // at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) [EOL]             // at java.lang.reflect.Method.invoke(Method.java:324) [EOL]             // at junit.framework.TestCase.runTest(TestCase.java:154) [EOL]             // at junit.framework.TestCase.runBare(TestCase.java:127) [EOL]             // at junit.framework.TestResult$1.protect(TestResult.java:106) [EOL]             // at junit.framework.TestResult.runProtected(TestResult.java:124) [EOL]             // at junit.framework.TestResult.run(TestResult.java:109) [EOL]             // at junit.framework.TestCase.run(TestCase.java:118) [EOL]             // at junit.framework.TestSuite.runTest(TestSuite.java:208) [EOL]             // at junit.framework.TestSuite.run(TestSuite.java:203) [EOL]             // at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:478) [EOL]             // at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:344) [EOL]             // at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests that "1 <unit>s" gets converted to "1 <unit>" but that "11 <unit>s" is left alone. [EOL]      */ [EOL]
@Test [EOL]     public void testFormatDurationWords() { [EOL]         String text = null; [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, true, false); [EOL]         assertEquals("50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, true, false); [EOL]         assertEquals("1 minute 5 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(120 * 1000, true, false); [EOL]         assertEquals("2 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(121 * 1000, true, false); [EOL]         assertEquals("2 minutes 1 second", text); [EOL]         text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false); [EOL]         assertEquals("1 hour 12 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false); [EOL]         assertEquals("1 day 0 hours 0 minutes 0 seconds", text); [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, true, true); [EOL]         assertEquals("50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, true, true); [EOL]         assertEquals("1 minute 5 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(120 * 1000, true, true); [EOL]         assertEquals("2 minutes", text); [EOL]         text = DurationFormatUtils.formatDurationWords(121 * 1000, true, true); [EOL]         assertEquals("2 minutes 1 second", text); [EOL]         text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, true); [EOL]         assertEquals("1 hour 12 minutes", text); [EOL]         text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, true); [EOL]         assertEquals("1 day", text); [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, false, true); [EOL]         assertEquals("0 days 0 hours 0 minutes 50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, false, true); [EOL]         assertEquals("0 days 0 hours 1 minute 5 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(120 * 1000, false, true); [EOL]         assertEquals("0 days 0 hours 2 minutes", text); [EOL]         text = DurationFormatUtils.formatDurationWords(121 * 1000, false, true); [EOL]         assertEquals("0 days 0 hours 2 minutes 1 second", text); [EOL]         text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, false, true); [EOL]         assertEquals("0 days 1 hour 12 minutes", text); [EOL]         text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, false, true); [EOL]         assertEquals("1 day", text); [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, false, false); [EOL]         assertEquals("0 days 0 hours 0 minutes 50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, false, false); [EOL]         assertEquals("0 days 0 hours 1 minute 5 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(120 * 1000, false, false); [EOL]         assertEquals("0 days 0 hours 2 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(121 * 1000, false, false); [EOL]         assertEquals("0 days 0 hours 2 minutes 1 second", text); [EOL]         text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, false, false); [EOL]         assertEquals("0 days 1 hour 12 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000 + 72 * 60 * 1000, false, false); [EOL]         assertEquals("1 day 1 hour 12 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(2 * 24 * 60 * 60 * 1000 + 72 * 60 * 1000, false, false); [EOL]         assertEquals("2 days 1 hour 12 minutes 0 seconds", text); [EOL]         for (int i = 2; i < 31; i++) { [EOL]             text = DurationFormatUtils.formatDurationWords(i * 24 * 60 * 60 * 1000L, false, false); [EOL]             // assertEquals(i + " days 0 hours 0 minutes 0 seconds", text); [EOL]             //             [EOL]             // junit.framework.ComparisonFailure: expected:<25 days 0 hours 0 minutes 0...> but was:<-24 days -17 hours [EOL]             // -2 minutes -47...> [EOL]             // at junit.framework.Assert.assertEquals(Assert.java:81) [EOL]             // at junit.framework.Assert.assertEquals(Assert.java:87) [EOL]             // at [EOL]             // org.apache.commons.lang.time.DurationFormatUtilsTest.testFormatDurationWords(DurationFormatUtilsTest.java:124) [EOL]             // at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) [EOL]             // at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) [EOL]             // at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) [EOL]             // at java.lang.reflect.Method.invoke(Method.java:324) [EOL]             // at junit.framework.TestCase.runTest(TestCase.java:154) [EOL]             // at junit.framework.TestCase.runBare(TestCase.java:127) [EOL]             // at junit.framework.TestResult$1.protect(TestResult.java:106) [EOL]             // at junit.framework.TestResult.runProtected(TestResult.java:124) [EOL]             // at junit.framework.TestResult.run(TestResult.java:109) [EOL]             // at junit.framework.TestCase.run(TestCase.java:118) [EOL]             // at junit.framework.TestSuite.runTest(TestSuite.java:208) [EOL]             // at junit.framework.TestSuite.run(TestSuite.java:203) [EOL]             // at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:478) [EOL]             // at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:344) [EOL]             // at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests that "1 <unit>s" gets converted to "1 <unit>" but that "11 <unit>s" is left alone. [EOL]      */ [EOL]
@Test [EOL]     public void testFormatDurationWords() { [EOL]         String text = null; [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, true, false); [EOL]         assertEquals("50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, true, false); [EOL]         assertEquals("1 minute 5 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(120 * 1000, true, false); [EOL]         assertEquals("2 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(121 * 1000, true, false); [EOL]         assertEquals("2 minutes 1 second", text); [EOL]         text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false); [EOL]         assertEquals("1 hour 12 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false); [EOL]         assertEquals("1 day 0 hours 0 minutes 0 seconds", text); [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, true, true); [EOL]         assertEquals("50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, true, true); [EOL]         assertEquals("1 minute 5 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(120 * 1000, true, true); [EOL]         assertEquals("2 minutes", text); [EOL]         text = DurationFormatUtils.formatDurationWords(121 * 1000, true, true); [EOL]         assertEquals("2 minutes 1 second", text); [EOL]         text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, true); [EOL]         assertEquals("1 hour 12 minutes", text); [EOL]         text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, true); [EOL]         assertEquals("1 day", text); [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, false, true); [EOL]         assertEquals("0 days 0 hours 0 minutes 50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, false, true); [EOL]         assertEquals("0 days 0 hours 1 minute 5 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(120 * 1000, false, true); [EOL]         assertEquals("0 days 0 hours 2 minutes", text); [EOL]         text = DurationFormatUtils.formatDurationWords(121 * 1000, false, true); [EOL]         assertEquals("0 days 0 hours 2 minutes 1 second", text); [EOL]         text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, false, true); [EOL]         assertEquals("0 days 1 hour 12 minutes", text); [EOL]         text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, false, true); [EOL]         assertEquals("1 day", text); [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, false, false); [EOL]         assertEquals("0 days 0 hours 0 minutes 50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, false, false); [EOL]         assertEquals("0 days 0 hours 1 minute 5 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(120 * 1000, false, false); [EOL]         assertEquals("0 days 0 hours 2 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(121 * 1000, false, false); [EOL]         assertEquals("0 days 0 hours 2 minutes 1 second", text); [EOL]         text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, false, false); [EOL]         assertEquals("0 days 1 hour 12 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000 + 72 * 60 * 1000, false, false); [EOL]         assertEquals("1 day 1 hour 12 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(2 * 24 * 60 * 60 * 1000 + 72 * 60 * 1000, false, false); [EOL]         assertEquals("2 days 1 hour 12 minutes 0 seconds", text); [EOL]         for (int i = 2; i < 31; i++) { [EOL]             text = DurationFormatUtils.formatDurationWords(i * 24 * 60 * 60 * 1000L, false, false); [EOL]             // assertEquals(i + " days 0 hours 0 minutes 0 seconds", text); [EOL]             //             [EOL]             // junit.framework.ComparisonFailure: expected:<25 days 0 hours 0 minutes 0...> but was:<-24 days -17 hours [EOL]             // -2 minutes -47...> [EOL]             // at junit.framework.Assert.assertEquals(Assert.java:81) [EOL]             // at junit.framework.Assert.assertEquals(Assert.java:87) [EOL]             // at [EOL]             // org.apache.commons.lang.time.DurationFormatUtilsTest.testFormatDurationWords(DurationFormatUtilsTest.java:124) [EOL]             // at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) [EOL]             // at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) [EOL]             // at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) [EOL]             // at java.lang.reflect.Method.invoke(Method.java:324) [EOL]             // at junit.framework.TestCase.runTest(TestCase.java:154) [EOL]             // at junit.framework.TestCase.runBare(TestCase.java:127) [EOL]             // at junit.framework.TestResult$1.protect(TestResult.java:106) [EOL]             // at junit.framework.TestResult.runProtected(TestResult.java:124) [EOL]             // at junit.framework.TestResult.run(TestResult.java:109) [EOL]             // at junit.framework.TestCase.run(TestCase.java:118) [EOL]             // at junit.framework.TestSuite.runTest(TestSuite.java:208) [EOL]             // at junit.framework.TestSuite.run(TestSuite.java:203) [EOL]             // at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:478) [EOL]             // at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:344) [EOL]             // at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests that "1 <unit>s" gets converted to "1 <unit>" but that "11 <unit>s" is left alone. [EOL]      */ [EOL]
@Test [EOL]     public void testFormatDurationWords() { [EOL]         String text = null; [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, true, false); [EOL]         assertEquals("50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, true, false); [EOL]         assertEquals("1 minute 5 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(120 * 1000, true, false); [EOL]         assertEquals("2 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(121 * 1000, true, false); [EOL]         assertEquals("2 minutes 1 second", text); [EOL]         text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false); [EOL]         assertEquals("1 hour 12 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false); [EOL]         assertEquals("1 day 0 hours 0 minutes 0 seconds", text); [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, true, true); [EOL]         assertEquals("50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, true, true); [EOL]         assertEquals("1 minute 5 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(120 * 1000, true, true); [EOL]         assertEquals("2 minutes", text); [EOL]         text = DurationFormatUtils.formatDurationWords(121 * 1000, true, true); [EOL]         assertEquals("2 minutes 1 second", text); [EOL]         text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, true); [EOL]         assertEquals("1 hour 12 minutes", text); [EOL]         text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, true); [EOL]         assertEquals("1 day", text); [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, false, true); [EOL]         assertEquals("0 days 0 hours 0 minutes 50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, false, true); [EOL]         assertEquals("0 days 0 hours 1 minute 5 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(120 * 1000, false, true); [EOL]         assertEquals("0 days 0 hours 2 minutes", text); [EOL]         text = DurationFormatUtils.formatDurationWords(121 * 1000, false, true); [EOL]         assertEquals("0 days 0 hours 2 minutes 1 second", text); [EOL]         text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, false, true); [EOL]         assertEquals("0 days 1 hour 12 minutes", text); [EOL]         text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, false, true); [EOL]         assertEquals("1 day", text); [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, false, false); [EOL]         assertEquals("0 days 0 hours 0 minutes 50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, false, false); [EOL]         assertEquals("0 days 0 hours 1 minute 5 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(120 * 1000, false, false); [EOL]         assertEquals("0 days 0 hours 2 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(121 * 1000, false, false); [EOL]         assertEquals("0 days 0 hours 2 minutes 1 second", text); [EOL]         text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, false, false); [EOL]         assertEquals("0 days 1 hour 12 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000 + 72 * 60 * 1000, false, false); [EOL]         assertEquals("1 day 1 hour 12 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(2 * 24 * 60 * 60 * 1000 + 72 * 60 * 1000, false, false); [EOL]         assertEquals("2 days 1 hour 12 minutes 0 seconds", text); [EOL]         for (int i = 2; i < 31; i++) { [EOL]             text = DurationFormatUtils.formatDurationWords(i * 24 * 60 * 60 * 1000L, false, false); [EOL]             // assertEquals(i + " days 0 hours 0 minutes 0 seconds", text); [EOL]             //             [EOL]             // junit.framework.ComparisonFailure: expected:<25 days 0 hours 0 minutes 0...> but was:<-24 days -17 hours [EOL]             // -2 minutes -47...> [EOL]             // at junit.framework.Assert.assertEquals(Assert.java:81) [EOL]             // at junit.framework.Assert.assertEquals(Assert.java:87) [EOL]             // at [EOL]             // org.apache.commons.lang.time.DurationFormatUtilsTest.testFormatDurationWords(DurationFormatUtilsTest.java:124) [EOL]             // at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) [EOL]             // at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) [EOL]             // at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) [EOL]             // at java.lang.reflect.Method.invoke(Method.java:324) [EOL]             // at junit.framework.TestCase.runTest(TestCase.java:154) [EOL]             // at junit.framework.TestCase.runBare(TestCase.java:127) [EOL]             // at junit.framework.TestResult$1.protect(TestResult.java:106) [EOL]             // at junit.framework.TestResult.runProtected(TestResult.java:124) [EOL]             // at junit.framework.TestResult.run(TestResult.java:109) [EOL]             // at junit.framework.TestCase.run(TestCase.java:118) [EOL]             // at junit.framework.TestSuite.runTest(TestSuite.java:208) [EOL]             // at junit.framework.TestSuite.run(TestSuite.java:203) [EOL]             // at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:478) [EOL]             // at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:344) [EOL]             // at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests that "1 <unit>s" gets converted to "1 <unit>" but that "11 <unit>s" is left alone. [EOL]      */ [EOL]
@Test [EOL]     public void testFormatDurationWords() { [EOL]         String text = null; [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, true, false); [EOL]         assertEquals("50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, true, false); [EOL]         assertEquals("1 minute 5 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(120 * 1000, true, false); [EOL]         assertEquals("2 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(121 * 1000, true, false); [EOL]         assertEquals("2 minutes 1 second", text); [EOL]         text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false); [EOL]         assertEquals("1 hour 12 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false); [EOL]         assertEquals("1 day 0 hours 0 minutes 0 seconds", text); [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, true, true); [EOL]         assertEquals("50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, true, true); [EOL]         assertEquals("1 minute 5 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(120 * 1000, true, true); [EOL]         assertEquals("2 minutes", text); [EOL]         text = DurationFormatUtils.formatDurationWords(121 * 1000, true, true); [EOL]         assertEquals("2 minutes 1 second", text); [EOL]         text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, true); [EOL]         assertEquals("1 hour 12 minutes", text); [EOL]         text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, true); [EOL]         assertEquals("1 day", text); [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, false, true); [EOL]         assertEquals("0 days 0 hours 0 minutes 50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, false, true); [EOL]         assertEquals("0 days 0 hours 1 minute 5 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(120 * 1000, false, true); [EOL]         assertEquals("0 days 0 hours 2 minutes", text); [EOL]         text = DurationFormatUtils.formatDurationWords(121 * 1000, false, true); [EOL]         assertEquals("0 days 0 hours 2 minutes 1 second", text); [EOL]         text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, false, true); [EOL]         assertEquals("0 days 1 hour 12 minutes", text); [EOL]         text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, false, true); [EOL]         assertEquals("1 day", text); [EOL]  [EOL]         text = DurationFormatUtils.formatDurationWords(50 * 1000, false, false); [EOL]         assertEquals("0 days 0 hours 0 minutes 50 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(65 * 1000, false, false); [EOL]         assertEquals("0 days 0 hours 1 minute 5 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(120 * 1000, false, false); [EOL]         assertEquals("0 days 0 hours 2 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(121 * 1000, false, false); [EOL]         assertEquals("0 days 0 hours 2 minutes 1 second", text); [EOL]         text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, false, false); [EOL]         assertEquals("0 days 1 hour 12 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000 + 72 * 60 * 1000, false, false); [EOL]         assertEquals("1 day 1 hour 12 minutes 0 seconds", text); [EOL]         text = DurationFormatUtils.formatDurationWords(2 * 24 * 60 * 60 * 1000 + 72 * 60 * 1000, false, false); [EOL]         assertEquals("2 days 1 hour 12 minutes 0 seconds", text); [EOL]         for (int i = 2; i < 31; i++) { [EOL]             text = DurationFormatUtils.formatDurationWords(i * 24 * 60 * 60 * 1000L, false, false); [EOL]             // assertEquals(i + " days 0 hours 0 minutes 0 seconds", text); [EOL]             //             [EOL]             // junit.framework.ComparisonFailure: expected:<25 days 0 hours 0 minutes 0...> but was:<-24 days -17 hours [EOL]             // -2 minutes -47...> [EOL]             // at junit.framework.Assert.assertEquals(Assert.java:81) [EOL]             // at junit.framework.Assert.assertEquals(Assert.java:87) [EOL]             // at [EOL]             // org.apache.commons.lang.time.DurationFormatUtilsTest.testFormatDurationWords(DurationFormatUtilsTest.java:124) [EOL]             // at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) [EOL]             // at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) [EOL]             // at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) [EOL]             // at java.lang.reflect.Method.invoke(Method.java:324) [EOL]             // at junit.framework.TestCase.runTest(TestCase.java:154) [EOL]             // at junit.framework.TestCase.runBare(TestCase.java:127) [EOL]             // at junit.framework.TestResult$1.protect(TestResult.java:106) [EOL]             // at junit.framework.TestResult.runProtected(TestResult.java:124) [EOL]             // at junit.framework.TestResult.run(TestResult.java:109) [EOL]             // at junit.framework.TestCase.run(TestCase.java:118) [EOL]             // at junit.framework.TestSuite.runTest(TestSuite.java:208) [EOL]             // at junit.framework.TestSuite.run(TestSuite.java:203) [EOL]             // at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:478) [EOL]             // at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:344) [EOL]             // at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests that "1 <unit>s" gets converted to "1 <unit>" but that "11 <unit>s" is left alone. [EOL]      */ [EOL]
@Test [EOL]     public void testDurationsByBruteForce() { [EOL]         bruteForce(2006, 0, 1, "d", Calendar.DAY_OF_MONTH); [EOL]         bruteForce(2006, 0, 2, "d", Calendar.DAY_OF_MONTH); [EOL]         bruteForce(2007, 1, 2, "d", Calendar.DAY_OF_MONTH); [EOL]         bruteForce(2004, 1, 29, "d", Calendar.DAY_OF_MONTH); [EOL]         bruteForce(1996, 1, 29, "d", Calendar.DAY_OF_MONTH); [EOL]  [EOL]         bruteForce(1969, 1, 28, "M", Calendar.MONTH);  // tests for 48 years [EOL]         //bruteForce(1996, 1, 29, "M", Calendar.MONTH);  // this will fail [EOL]     } [EOL]      [EOL]     private static final int FOUR_YEARS = 365 * 3 + 366; [EOL]      [EOL]     // Takes a minute to run, so generally turned off [EOL] //    public void testBrutally() { [EOL] //        Calendar c = Calendar.getInstance(); [EOL] //        c.set(2004, 0, 1, 0, 0, 0); [EOL] //        for (int i=0; i < FOUR_YEARS; i++) { [EOL] //            bruteForce(c.get(Calendar.YEAR), c.get(Calendar.MONTH), c.get(Calendar.DAY_OF_MONTH), "d", Calendar.DAY_OF_MONTH ); [EOL] //            c.add(Calendar.DAY_OF_MONTH, 1); [EOL] //        } [EOL] //    }         [EOL]      [EOL]     private void bruteForce(final int year, final int month, final int day, final String format, final int calendarType) { [EOL]         final String msg = year + "-" + month + "-" + day + " to "; [EOL]         final Calendar c = Calendar.getInstance(); [EOL]         c.set(year, month, day, 0, 0, 0); [EOL]         final int[] array1 = new int[] { year, month, day, 0, 0, 0 }; [EOL]         final int[] array2 = new int[] { year, month, day, 0, 0, 0 }; [EOL]         for (int i=0; i < FOUR_YEARS; i++) { [EOL]             array2[0] = c.get(Calendar.YEAR); [EOL]             array2[1] = c.get(Calendar.MONTH); [EOL]             array2[2] = c.get(Calendar.DAY_OF_MONTH); [EOL]             final String tmpMsg = msg + array2[0] + "-" + array2[1] + "-" + array2[2] + " at "; [EOL]             assertEqualDuration( tmpMsg + i, Integer.toString(i), array1, array2, format ); [EOL]             c.add(calendarType, 1); [EOL]         } [EOL]     } [EOL]  [EOL]     private void assertEqualDuration(final String expected, final int[] start, final int[] end, final String format) { [EOL]         assertEqualDuration(null, expected, start, end, format); [EOL]     } [EOL]     private void assertEqualDuration(final String message, final String expected, final int[] start, final int[] end, final String format) { [EOL]         final Calendar cal1 = Calendar.getInstance(); [EOL]         cal1.set(start[0], start[1], start[2], start[3], start[4], start[5]); [EOL]         cal1.set(Calendar.MILLISECOND, 0); [EOL]         final Calendar cal2 = Calendar.getInstance(); [EOL]         cal2.set(end[0], end[1], end[2], end[3], end[4], end[5]); [EOL]         cal2.set(Calendar.MILLISECOND, 0); [EOL]         final long milli1 = cal1.getTime().getTime(); [EOL]         final long milli2 = cal2.getTime().getTime(); [EOL]         final String result = DurationFormatUtils.formatPeriod(milli1, milli2, format); [EOL]         if (message == null) { [EOL]             assertEquals(expected, result); [EOL]         } else { [EOL]             assertEquals(message, expected, result); [EOL]         } [EOL]     } [EOL]  [EOL]     private void assertArrayEquals(final DurationFormatUtils.Token[] obj1, final DurationFormatUtils.Token[] obj2) { [EOL]         assertEquals("Arrays are unequal length. ", obj1.length, obj2.length); [EOL]         for (int i = 0; i < obj1.length; i++) { [EOL]             assertTrue("Index " + i + " not equal, " + obj1[i] + " vs " + obj2[i], obj1[i].equals(obj2[i])); [EOL]         } [EOL]     } [EOL]  [EOL] } [EOL]
@Test [EOL]     public void testDurationsByBruteForce() { [EOL]         bruteForce(2006, 0, 1, "d", Calendar.DAY_OF_MONTH); [EOL]         bruteForce(2006, 0, 2, "d", Calendar.DAY_OF_MONTH); [EOL]         bruteForce(2007, 1, 2, "d", Calendar.DAY_OF_MONTH); [EOL]         bruteForce(2004, 1, 29, "d", Calendar.DAY_OF_MONTH); [EOL]         bruteForce(1996, 1, 29, "d", Calendar.DAY_OF_MONTH); [EOL]  [EOL]         bruteForce(1969, 1, 28, "M", Calendar.MONTH);  // tests for 48 years [EOL]         //bruteForce(1996, 1, 29, "M", Calendar.MONTH);  // this will fail [EOL]     } [EOL]      [EOL]     private static final int FOUR_YEARS = 365 * 3 + 366; [EOL]      [EOL]     // Takes a minute to run, so generally turned off [EOL] //    public void testBrutally() { [EOL] //        Calendar c = Calendar.getInstance(); [EOL] //        c.set(2004, 0, 1, 0, 0, 0); [EOL] //        for (int i=0; i < FOUR_YEARS; i++) { [EOL] //            bruteForce(c.get(Calendar.YEAR), c.get(Calendar.MONTH), c.get(Calendar.DAY_OF_MONTH), "d", Calendar.DAY_OF_MONTH ); [EOL] //            c.add(Calendar.DAY_OF_MONTH, 1); [EOL] //        } [EOL] //    }         [EOL]      [EOL]     private void bruteForce(final int year, final int month, final int day, final String format, final int calendarType) { [EOL]         final String msg = year + "-" + month + "-" + day + " to "; [EOL]         final Calendar c = Calendar.getInstance(); [EOL]         c.set(year, month, day, 0, 0, 0); [EOL]         final int[] array1 = new int[] { year, month, day, 0, 0, 0 }; [EOL]         final int[] array2 = new int[] { year, month, day, 0, 0, 0 }; [EOL]         for (int i=0; i < FOUR_YEARS; i++) { [EOL]             array2[0] = c.get(Calendar.YEAR); [EOL]             array2[1] = c.get(Calendar.MONTH); [EOL]             array2[2] = c.get(Calendar.DAY_OF_MONTH); [EOL]             final String tmpMsg = msg + array2[0] + "-" + array2[1] + "-" + array2[2] + " at "; [EOL]             assertEqualDuration( tmpMsg + i, Integer.toString(i), array1, array2, format ); [EOL]             c.add(calendarType, 1); [EOL]         } [EOL]     } [EOL]  [EOL]     private void assertEqualDuration(final String expected, final int[] start, final int[] end, final String format) { [EOL]         assertEqualDuration(null, expected, start, end, format); [EOL]     } [EOL]     private void assertEqualDuration(final String message, final String expected, final int[] start, final int[] end, final String format) { [EOL]         final Calendar cal1 = Calendar.getInstance(); [EOL]         cal1.set(start[0], start[1], start[2], start[3], start[4], start[5]); [EOL]         cal1.set(Calendar.MILLISECOND, 0); [EOL]         final Calendar cal2 = Calendar.getInstance(); [EOL]         cal2.set(end[0], end[1], end[2], end[3], end[4], end[5]); [EOL]         cal2.set(Calendar.MILLISECOND, 0); [EOL]         final long milli1 = cal1.getTime().getTime(); [EOL]         final long milli2 = cal2.getTime().getTime(); [EOL]         final String result = DurationFormatUtils.formatPeriod(milli1, milli2, format); [EOL]         if (message == null) { [EOL]             assertEquals(expected, result); [EOL]         } else { [EOL]             assertEquals(message, expected, result); [EOL]         } [EOL]     } [EOL]  [EOL]     private void assertArrayEquals(final DurationFormatUtils.Token[] obj1, final DurationFormatUtils.Token[] obj2) { [EOL]         assertEquals("Arrays are unequal length. ", obj1.length, obj2.length); [EOL]         for (int i = 0; i < obj1.length; i++) { [EOL]             assertTrue("Index " + i + " not equal, " + obj1[i] + " vs " + obj2[i], obj1[i].equals(obj2[i])); [EOL]         } [EOL]     } [EOL]  [EOL] } [EOL]
@Test [EOL]     public void testDurationsByBruteForce() { [EOL]         bruteForce(2006, 0, 1, "d", Calendar.DAY_OF_MONTH); [EOL]         bruteForce(2006, 0, 2, "d", Calendar.DAY_OF_MONTH); [EOL]         bruteForce(2007, 1, 2, "d", Calendar.DAY_OF_MONTH); [EOL]         bruteForce(2004, 1, 29, "d", Calendar.DAY_OF_MONTH); [EOL]         bruteForce(1996, 1, 29, "d", Calendar.DAY_OF_MONTH); [EOL]  [EOL]         bruteForce(1969, 1, 28, "M", Calendar.MONTH);  // tests for 48 years [EOL]         //bruteForce(1996, 1, 29, "M", Calendar.MONTH);  // this will fail [EOL]     } [EOL]      [EOL]     private static final int FOUR_YEARS = 365 * 3 + 366; [EOL]      [EOL]     // Takes a minute to run, so generally turned off [EOL] //    public void testBrutally() { [EOL] //        Calendar c = Calendar.getInstance(); [EOL] //        c.set(2004, 0, 1, 0, 0, 0); [EOL] //        for (int i=0; i < FOUR_YEARS; i++) { [EOL] //            bruteForce(c.get(Calendar.YEAR), c.get(Calendar.MONTH), c.get(Calendar.DAY_OF_MONTH), "d", Calendar.DAY_OF_MONTH ); [EOL] //            c.add(Calendar.DAY_OF_MONTH, 1); [EOL] //        } [EOL] //    }         [EOL]      [EOL]     private void bruteForce(final int year, final int month, final int day, final String format, final int calendarType) { [EOL]         final String msg = year + "-" + month + "-" + day + " to "; [EOL]         final Calendar c = Calendar.getInstance(); [EOL]         c.set(year, month, day, 0, 0, 0); [EOL]         final int[] array1 = new int[] { year, month, day, 0, 0, 0 }; [EOL]         final int[] array2 = new int[] { year, month, day, 0, 0, 0 }; [EOL]         for (int i=0; i < FOUR_YEARS; i++) { [EOL]             array2[0] = c.get(Calendar.YEAR); [EOL]             array2[1] = c.get(Calendar.MONTH); [EOL]             array2[2] = c.get(Calendar.DAY_OF_MONTH); [EOL]             final String tmpMsg = msg + array2[0] + "-" + array2[1] + "-" + array2[2] + " at "; [EOL]             assertEqualDuration( tmpMsg + i, Integer.toString(i), array1, array2, format ); [EOL]             c.add(calendarType, 1); [EOL]         } [EOL]     } [EOL]  [EOL]     private void assertEqualDuration(final String expected, final int[] start, final int[] end, final String format) { [EOL]         assertEqualDuration(null, expected, start, end, format); [EOL]     } [EOL]     private void assertEqualDuration(final String message, final String expected, final int[] start, final int[] end, final String format) { [EOL]         final Calendar cal1 = Calendar.getInstance(); [EOL]         cal1.set(start[0], start[1], start[2], start[3], start[4], start[5]); [EOL]         cal1.set(Calendar.MILLISECOND, 0); [EOL]         final Calendar cal2 = Calendar.getInstance(); [EOL]         cal2.set(end[0], end[1], end[2], end[3], end[4], end[5]); [EOL]         cal2.set(Calendar.MILLISECOND, 0); [EOL]         final long milli1 = cal1.getTime().getTime(); [EOL]         final long milli2 = cal2.getTime().getTime(); [EOL]         final String result = DurationFormatUtils.formatPeriod(milli1, milli2, format); [EOL]         if (message == null) { [EOL]             assertEquals(expected, result); [EOL]         } else { [EOL]             assertEquals(message, expected, result); [EOL]         } [EOL]     } [EOL]  [EOL]     private void assertArrayEquals(final DurationFormatUtils.Token[] obj1, final DurationFormatUtils.Token[] obj2) { [EOL]         assertEquals("Arrays are unequal length. ", obj1.length, obj2.length); [EOL]         for (int i = 0; i < obj1.length; i++) { [EOL]             assertTrue("Index " + i + " not equal, " + obj1[i] + " vs " + obj2[i], obj1[i].equals(obj2[i])); [EOL]         } [EOL]     } [EOL]  [EOL] } [EOL]
@Test [EOL]     public void testDurationsByBruteForce() { [EOL]         bruteForce(2006, 0, 1, "d", Calendar.DAY_OF_MONTH); [EOL]         bruteForce(2006, 0, 2, "d", Calendar.DAY_OF_MONTH); [EOL]         bruteForce(2007, 1, 2, "d", Calendar.DAY_OF_MONTH); [EOL]         bruteForce(2004, 1, 29, "d", Calendar.DAY_OF_MONTH); [EOL]         bruteForce(1996, 1, 29, "d", Calendar.DAY_OF_MONTH); [EOL]  [EOL]         bruteForce(1969, 1, 28, "M", Calendar.MONTH);  // tests for 48 years [EOL]         //bruteForce(1996, 1, 29, "M", Calendar.MONTH);  // this will fail [EOL]     } [EOL]      [EOL]     private static final int FOUR_YEARS = 365 * 3 + 366; [EOL]      [EOL]     // Takes a minute to run, so generally turned off [EOL] //    public void testBrutally() { [EOL] //        Calendar c = Calendar.getInstance(); [EOL] //        c.set(2004, 0, 1, 0, 0, 0); [EOL] //        for (int i=0; i < FOUR_YEARS; i++) { [EOL] //            bruteForce(c.get(Calendar.YEAR), c.get(Calendar.MONTH), c.get(Calendar.DAY_OF_MONTH), "d", Calendar.DAY_OF_MONTH ); [EOL] //            c.add(Calendar.DAY_OF_MONTH, 1); [EOL] //        } [EOL] //    }         [EOL]      [EOL]     private void bruteForce(final int year, final int month, final int day, final String format, final int calendarType) { [EOL]         final String msg = year + "-" + month + "-" + day + " to "; [EOL]         final Calendar c = Calendar.getInstance(); [EOL]         c.set(year, month, day, 0, 0, 0); [EOL]         final int[] array1 = new int[] { year, month, day, 0, 0, 0 }; [EOL]         final int[] array2 = new int[] { year, month, day, 0, 0, 0 }; [EOL]         for (int i=0; i < FOUR_YEARS; i++) { [EOL]             array2[0] = c.get(Calendar.YEAR); [EOL]             array2[1] = c.get(Calendar.MONTH); [EOL]             array2[2] = c.get(Calendar.DAY_OF_MONTH); [EOL]             final String tmpMsg = msg + array2[0] + "-" + array2[1] + "-" + array2[2] + " at "; [EOL]             assertEqualDuration( tmpMsg + i, Integer.toString(i), array1, array2, format ); [EOL]             c.add(calendarType, 1); [EOL]         } [EOL]     } [EOL]  [EOL]     private void assertEqualDuration(final String expected, final int[] start, final int[] end, final String format) { [EOL]         assertEqualDuration(null, expected, start, end, format); [EOL]     } [EOL]     private void assertEqualDuration(final String message, final String expected, final int[] start, final int[] end, final String format) { [EOL]         final Calendar cal1 = Calendar.getInstance(); [EOL]         cal1.set(start[0], start[1], start[2], start[3], start[4], start[5]); [EOL]         cal1.set(Calendar.MILLISECOND, 0); [EOL]         final Calendar cal2 = Calendar.getInstance(); [EOL]         cal2.set(end[0], end[1], end[2], end[3], end[4], end[5]); [EOL]         cal2.set(Calendar.MILLISECOND, 0); [EOL]         final long milli1 = cal1.getTime().getTime(); [EOL]         final long milli2 = cal2.getTime().getTime(); [EOL]         final String result = DurationFormatUtils.formatPeriod(milli1, milli2, format); [EOL]         if (message == null) { [EOL]             assertEquals(expected, result); [EOL]         } else { [EOL]             assertEquals(message, expected, result); [EOL]         } [EOL]     } [EOL]  [EOL]     private void assertArrayEquals(final DurationFormatUtils.Token[] obj1, final DurationFormatUtils.Token[] obj2) { [EOL]         assertEquals("Arrays are unequal length. ", obj1.length, obj2.length); [EOL]         for (int i = 0; i < obj1.length; i++) { [EOL]             assertTrue("Index " + i + " not equal, " + obj1[i] + " vs " + obj2[i], obj1[i].equals(obj2[i])); [EOL]         } [EOL]     } [EOL]  [EOL] } [EOL]
@Test [EOL]     public void testLexx() { [EOL]         // tests each constant [EOL]         assertArrayEquals(new DurationFormatUtils.Token[]{ [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.y, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.M, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.d, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.H, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.m, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.s, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.S, 1)}, DurationFormatUtils.lexx("yMdHmsS")); [EOL]  [EOL]         // tests the ISO8601-like [EOL]         assertArrayEquals(new DurationFormatUtils.Token[]{ [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.H, 1), [EOL]             new DurationFormatUtils.Token(new StringBuilder(":"), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.m, 2), [EOL]             new DurationFormatUtils.Token(new StringBuilder(":"), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.s, 2), [EOL]             new DurationFormatUtils.Token(new StringBuilder("."), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.S, 3)}, DurationFormatUtils.lexx("H:mm:ss.SSS")); [EOL]  [EOL]         // test the iso extended format [EOL]         assertArrayEquals(new DurationFormatUtils.Token[]{ [EOL]             new DurationFormatUtils.Token(new StringBuilder("P"), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.y, 4), [EOL]             new DurationFormatUtils.Token(new StringBuilder("Y"), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.M, 1), [EOL]             new DurationFormatUtils.Token(new StringBuilder("M"), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.d, 1), [EOL]             new DurationFormatUtils.Token(new StringBuilder("DT"), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.H, 1), [EOL]             new DurationFormatUtils.Token(new StringBuilder("H"), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.m, 1), [EOL]             new DurationFormatUtils.Token(new StringBuilder("M"), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.s, 1), [EOL]             new DurationFormatUtils.Token(new StringBuilder("."), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.S, 1), [EOL]             new DurationFormatUtils.Token(new StringBuilder("S"), 1)}, DurationFormatUtils [EOL]                 .lexx(DurationFormatUtils.ISO_EXTENDED_FORMAT_PATTERN)); [EOL]  [EOL]         // test failures in equals [EOL]         final DurationFormatUtils.Token token = new DurationFormatUtils.Token(DurationFormatUtils.y, 4); [EOL]         assertFalse("Token equal to non-Token class. ", token.equals(new Object())); [EOL]         assertFalse("Token equal to Token with wrong value class. ", token.equals(new DurationFormatUtils.Token( [EOL]                 new Object()))); [EOL]         assertFalse("Token equal to Token with different count. ", token.equals(new DurationFormatUtils.Token( [EOL]                 DurationFormatUtils.y, 1))); [EOL]         final DurationFormatUtils.Token numToken = new DurationFormatUtils.Token(Integer.valueOf(1), 4); [EOL]         assertTrue("Token with Number value not equal to itself. ", numToken.equals(numToken)); [EOL]     } [EOL]  [EOL]  [EOL]     // http://issues.apache.org/bugzilla/show_bug.cgi?id=38401 [EOL]
@Test [EOL]     public void testLexx() { [EOL]         // tests each constant [EOL]         assertArrayEquals(new DurationFormatUtils.Token[]{ [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.y, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.M, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.d, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.H, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.m, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.s, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.S, 1)}, DurationFormatUtils.lexx("yMdHmsS")); [EOL]  [EOL]         // tests the ISO8601-like [EOL]         assertArrayEquals(new DurationFormatUtils.Token[]{ [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.H, 1), [EOL]             new DurationFormatUtils.Token(new StringBuilder(":"), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.m, 2), [EOL]             new DurationFormatUtils.Token(new StringBuilder(":"), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.s, 2), [EOL]             new DurationFormatUtils.Token(new StringBuilder("."), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.S, 3)}, DurationFormatUtils.lexx("H:mm:ss.SSS")); [EOL]  [EOL]         // test the iso extended format [EOL]         assertArrayEquals(new DurationFormatUtils.Token[]{ [EOL]             new DurationFormatUtils.Token(new StringBuilder("P"), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.y, 4), [EOL]             new DurationFormatUtils.Token(new StringBuilder("Y"), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.M, 1), [EOL]             new DurationFormatUtils.Token(new StringBuilder("M"), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.d, 1), [EOL]             new DurationFormatUtils.Token(new StringBuilder("DT"), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.H, 1), [EOL]             new DurationFormatUtils.Token(new StringBuilder("H"), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.m, 1), [EOL]             new DurationFormatUtils.Token(new StringBuilder("M"), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.s, 1), [EOL]             new DurationFormatUtils.Token(new StringBuilder("."), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.S, 1), [EOL]             new DurationFormatUtils.Token(new StringBuilder("S"), 1)}, DurationFormatUtils [EOL]                 .lexx(DurationFormatUtils.ISO_EXTENDED_FORMAT_PATTERN)); [EOL]  [EOL]         // test failures in equals [EOL]         final DurationFormatUtils.Token token = new DurationFormatUtils.Token(DurationFormatUtils.y, 4); [EOL]         assertFalse("Token equal to non-Token class. ", token.equals(new Object())); [EOL]         assertFalse("Token equal to Token with wrong value class. ", token.equals(new DurationFormatUtils.Token( [EOL]                 new Object()))); [EOL]         assertFalse("Token equal to Token with different count. ", token.equals(new DurationFormatUtils.Token( [EOL]                 DurationFormatUtils.y, 1))); [EOL]         final DurationFormatUtils.Token numToken = new DurationFormatUtils.Token(Integer.valueOf(1), 4); [EOL]         assertTrue("Token with Number value not equal to itself. ", numToken.equals(numToken)); [EOL]     } [EOL]  [EOL]  [EOL]     // http://issues.apache.org/bugzilla/show_bug.cgi?id=38401 [EOL]
@Test [EOL]     public void testGetCheckedException() throws Exception { [EOL]         final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(); [EOL]         final Exception ex = new Exception(); [EOL]         init.ex = ex; [EOL]         init.start(); [EOL]         try { [EOL]             init.get(); [EOL]             fail("Exception not thrown!"); [EOL]         } catch (final ConcurrentException cex) { [EOL]             assertEquals("Exception not thrown", ex, cex.getCause()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the get() method if waiting for the initialization is interrupted. [EOL]      */ [EOL]
@Test [EOL]     public void testGetInterruptedException() throws Exception { [EOL]         final ExecutorService exec = Executors.newSingleThreadExecutor(); [EOL]         final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl( [EOL]                 exec); [EOL]         final CountDownLatch latch1 = new CountDownLatch(1); [EOL]         init.shouldSleep = true; [EOL]         init.start(); [EOL]         final AtomicReference<InterruptedException> iex = new AtomicReference<InterruptedException>(); [EOL]         final Thread getThread = new Thread() { [EOL]             @Override [EOL]             public void run() { [EOL]                 try { [EOL]                     init.get(); [EOL]                 } catch (final ConcurrentException cex) { [EOL]                     if (cex.getCause() instanceof InterruptedException) { [EOL]                         iex.set((InterruptedException) cex.getCause()); [EOL]                     } [EOL]                 } finally { [EOL]                     assertTrue("Thread not interrupted", isInterrupted()); [EOL]                     latch1.countDown(); [EOL]                 } [EOL]             } [EOL]         }; [EOL]         getThread.start(); [EOL]         getThread.interrupt(); [EOL]         latch1.await(); [EOL]         exec.shutdownNow(); [EOL]         exec.awaitTermination(Long.MAX_VALUE, TimeUnit.MILLISECONDS); [EOL]         assertNotNull("No interrupted exception", iex.get()); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests isStarted() before start() was called. [EOL]      */ [EOL]
@Test [EOL]     public void testGetInterruptedException() throws Exception { [EOL]         final ExecutorService exec = Executors.newSingleThreadExecutor(); [EOL]         final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl( [EOL]                 exec); [EOL]         final CountDownLatch latch1 = new CountDownLatch(1); [EOL]         init.shouldSleep = true; [EOL]         init.start(); [EOL]         final AtomicReference<InterruptedException> iex = new AtomicReference<InterruptedException>(); [EOL]         final Thread getThread = new Thread() { [EOL]             @Override [EOL]             public void run() { [EOL]                 try { [EOL]                     init.get(); [EOL]                 } catch (final ConcurrentException cex) { [EOL]                     if (cex.getCause() instanceof InterruptedException) { [EOL]                         iex.set((InterruptedException) cex.getCause()); [EOL]                     } [EOL]                 } finally { [EOL]                     assertTrue("Thread not interrupted", isInterrupted()); [EOL]                     latch1.countDown(); [EOL]                 } [EOL]             } [EOL]         }; [EOL]         getThread.start(); [EOL]         getThread.interrupt(); [EOL]         latch1.await(); [EOL]         exec.shutdownNow(); [EOL]         exec.awaitTermination(Long.MAX_VALUE, TimeUnit.MILLISECONDS); [EOL]         assertNotNull("No interrupted exception", iex.get()); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests isStarted() before start() was called. [EOL]      */ [EOL]
@Test [EOL]     public void testConstructor() { [EOL]         assertNotNull(new FieldUtils()); [EOL]         final Constructor<?>[] cons = FieldUtils.class.getDeclaredConstructors(); [EOL]         assertEquals(1, cons.length); [EOL]         assertTrue(Modifier.isPublic(cons[0].getModifiers())); [EOL]         assertTrue(Modifier.isPublic(FieldUtils.class.getModifiers())); [EOL]         assertFalse(Modifier.isFinal(FieldUtils.class.getModifiers())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testConstructor() { [EOL]         assertNotNull(new FieldUtils()); [EOL]         final Constructor<?>[] cons = FieldUtils.class.getDeclaredConstructors(); [EOL]         assertEquals(1, cons.length); [EOL]         assertTrue(Modifier.isPublic(cons[0].getModifiers())); [EOL]         assertTrue(Modifier.isPublic(FieldUtils.class.getModifiers())); [EOL]         assertFalse(Modifier.isFinal(FieldUtils.class.getModifiers())); [EOL]     } [EOL]  [EOL]
@Test(expected = IllegalArgumentException.class) [EOL]     public void testGetFieldIllegalArgumentException1() { [EOL]         FieldUtils.getField(null, "none"); [EOL]     } [EOL]  [EOL]
@Test(expected = IllegalArgumentException.class) [EOL]     public void testGetFieldIllegalArgumentException1() { [EOL]         FieldUtils.getField(null, "none"); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReadStaticField() throws Exception { [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(FieldUtils.getField(Foo.class, "VALUE"))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReadStaticField() throws Exception { [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(FieldUtils.getField(Foo.class, "VALUE"))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReadNamedStaticField() throws Exception { [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(Foo.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PubliclyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PrivatelyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PublicChild.class, "VALUE")); [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(null, "none"); [EOL]             fail("null class should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(Foo.class, null); [EOL]             fail("null field name should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(Foo.class, "does_not_exist"); [EOL]             fail("a field that doesn't exist should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(PublicChild.class, "s"); [EOL]             fail("non-static field should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReadNamedStaticField() throws Exception { [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(Foo.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PubliclyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PrivatelyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PublicChild.class, "VALUE")); [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(null, "none"); [EOL]             fail("null class should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(Foo.class, null); [EOL]             fail("null field name should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(Foo.class, "does_not_exist"); [EOL]             fail("a field that doesn't exist should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(PublicChild.class, "s"); [EOL]             fail("non-static field should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetFieldForceAccess() { [EOL]         assertEquals(PublicChild.class, FieldUtils.getField(PublicChild.class, "VALUE", true).getDeclaringClass()); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "s", true).getDeclaringClass()); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "b", true).getDeclaringClass()); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "i", true).getDeclaringClass()); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "d", true).getDeclaringClass()); [EOL]         assertEquals(Foo.class, FieldUtils.getField(PubliclyShadowedChild.class, "VALUE", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "s", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "b", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "i", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "d", true).getDeclaringClass()); [EOL]         assertEquals(Foo.class, FieldUtils.getField(PrivatelyShadowedChild.class, "VALUE", true).getDeclaringClass()); [EOL]         assertEquals(PrivatelyShadowedChild.class, FieldUtils.getField(PrivatelyShadowedChild.class, "s", true).getDeclaringClass()); [EOL]         assertEquals(PrivatelyShadowedChild.class, FieldUtils.getField(PrivatelyShadowedChild.class, "b", true).getDeclaringClass()); [EOL]         assertEquals(PrivatelyShadowedChild.class, FieldUtils.getField(PrivatelyShadowedChild.class, "i", true).getDeclaringClass()); [EOL]         assertEquals(PrivatelyShadowedChild.class, FieldUtils.getField(PrivatelyShadowedChild.class, "d", true).getDeclaringClass()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetFieldForceAccess() { [EOL]         assertEquals(PublicChild.class, FieldUtils.getField(PublicChild.class, "VALUE", true).getDeclaringClass()); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "s", true).getDeclaringClass()); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "b", true).getDeclaringClass()); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "i", true).getDeclaringClass()); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "d", true).getDeclaringClass()); [EOL]         assertEquals(Foo.class, FieldUtils.getField(PubliclyShadowedChild.class, "VALUE", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "s", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "b", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "i", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "d", true).getDeclaringClass()); [EOL]         assertEquals(Foo.class, FieldUtils.getField(PrivatelyShadowedChild.class, "VALUE", true).getDeclaringClass()); [EOL]         assertEquals(PrivatelyShadowedChild.class, FieldUtils.getField(PrivatelyShadowedChild.class, "s", true).getDeclaringClass()); [EOL]         assertEquals(PrivatelyShadowedChild.class, FieldUtils.getField(PrivatelyShadowedChild.class, "b", true).getDeclaringClass()); [EOL]         assertEquals(PrivatelyShadowedChild.class, FieldUtils.getField(PrivatelyShadowedChild.class, "i", true).getDeclaringClass()); [EOL]         assertEquals(PrivatelyShadowedChild.class, FieldUtils.getField(PrivatelyShadowedChild.class, "d", true).getDeclaringClass()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetFieldForceAccess() { [EOL]         assertEquals(PublicChild.class, FieldUtils.getField(PublicChild.class, "VALUE", true).getDeclaringClass()); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "s", true).getDeclaringClass()); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "b", true).getDeclaringClass()); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "i", true).getDeclaringClass()); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "d", true).getDeclaringClass()); [EOL]         assertEquals(Foo.class, FieldUtils.getField(PubliclyShadowedChild.class, "VALUE", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "s", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "b", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "i", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "d", true).getDeclaringClass()); [EOL]         assertEquals(Foo.class, FieldUtils.getField(PrivatelyShadowedChild.class, "VALUE", true).getDeclaringClass()); [EOL]         assertEquals(PrivatelyShadowedChild.class, FieldUtils.getField(PrivatelyShadowedChild.class, "s", true).getDeclaringClass()); [EOL]         assertEquals(PrivatelyShadowedChild.class, FieldUtils.getField(PrivatelyShadowedChild.class, "b", true).getDeclaringClass()); [EOL]         assertEquals(PrivatelyShadowedChild.class, FieldUtils.getField(PrivatelyShadowedChild.class, "i", true).getDeclaringClass()); [EOL]         assertEquals(PrivatelyShadowedChild.class, FieldUtils.getField(PrivatelyShadowedChild.class, "d", true).getDeclaringClass()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReadNamedStaticField() throws Exception { [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(Foo.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PubliclyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PrivatelyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PublicChild.class, "VALUE")); [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(null, "none"); [EOL]             fail("null class should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(Foo.class, null); [EOL]             fail("null field name should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(Foo.class, "does_not_exist"); [EOL]             fail("a field that doesn't exist should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(PublicChild.class, "s"); [EOL]             fail("non-static field should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetFieldForceAccess() { [EOL]         assertEquals(PublicChild.class, FieldUtils.getField(PublicChild.class, "VALUE", true).getDeclaringClass()); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "s", true).getDeclaringClass()); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "b", true).getDeclaringClass()); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "i", true).getDeclaringClass()); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "d", true).getDeclaringClass()); [EOL]         assertEquals(Foo.class, FieldUtils.getField(PubliclyShadowedChild.class, "VALUE", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "s", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "b", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "i", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "d", true).getDeclaringClass()); [EOL]         assertEquals(Foo.class, FieldUtils.getField(PrivatelyShadowedChild.class, "VALUE", true).getDeclaringClass()); [EOL]         assertEquals(PrivatelyShadowedChild.class, FieldUtils.getField(PrivatelyShadowedChild.class, "s", true).getDeclaringClass()); [EOL]         assertEquals(PrivatelyShadowedChild.class, FieldUtils.getField(PrivatelyShadowedChild.class, "b", true).getDeclaringClass()); [EOL]         assertEquals(PrivatelyShadowedChild.class, FieldUtils.getField(PrivatelyShadowedChild.class, "i", true).getDeclaringClass()); [EOL]         assertEquals(PrivatelyShadowedChild.class, FieldUtils.getField(PrivatelyShadowedChild.class, "d", true).getDeclaringClass()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetFieldForceAccess() { [EOL]         assertEquals(PublicChild.class, FieldUtils.getField(PublicChild.class, "VALUE", true).getDeclaringClass()); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "s", true).getDeclaringClass()); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "b", true).getDeclaringClass()); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "i", true).getDeclaringClass()); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "d", true).getDeclaringClass()); [EOL]         assertEquals(Foo.class, FieldUtils.getField(PubliclyShadowedChild.class, "VALUE", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "s", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "b", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "i", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "d", true).getDeclaringClass()); [EOL]         assertEquals(Foo.class, FieldUtils.getField(PrivatelyShadowedChild.class, "VALUE", true).getDeclaringClass()); [EOL]         assertEquals(PrivatelyShadowedChild.class, FieldUtils.getField(PrivatelyShadowedChild.class, "s", true).getDeclaringClass()); [EOL]         assertEquals(PrivatelyShadowedChild.class, FieldUtils.getField(PrivatelyShadowedChild.class, "b", true).getDeclaringClass()); [EOL]         assertEquals(PrivatelyShadowedChild.class, FieldUtils.getField(PrivatelyShadowedChild.class, "i", true).getDeclaringClass()); [EOL]         assertEquals(PrivatelyShadowedChild.class, FieldUtils.getField(PrivatelyShadowedChild.class, "d", true).getDeclaringClass()); [EOL]     } [EOL]  [EOL]
@Test(expected = IllegalArgumentException.class) [EOL]     public void testAmbig() { [EOL]         FieldUtils.getField(Ambig.class, "VALUE"); [EOL]     } [EOL]  [EOL] } [EOL]
@Test [EOL]     public void testGetFieldForceAccess() { [EOL]         assertEquals(PublicChild.class, FieldUtils.getField(PublicChild.class, "VALUE", true).getDeclaringClass()); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "s", true).getDeclaringClass()); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "b", true).getDeclaringClass()); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "i", true).getDeclaringClass()); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "d", true).getDeclaringClass()); [EOL]         assertEquals(Foo.class, FieldUtils.getField(PubliclyShadowedChild.class, "VALUE", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "s", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "b", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "i", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "d", true).getDeclaringClass()); [EOL]         assertEquals(Foo.class, FieldUtils.getField(PrivatelyShadowedChild.class, "VALUE", true).getDeclaringClass()); [EOL]         assertEquals(PrivatelyShadowedChild.class, FieldUtils.getField(PrivatelyShadowedChild.class, "s", true).getDeclaringClass()); [EOL]         assertEquals(PrivatelyShadowedChild.class, FieldUtils.getField(PrivatelyShadowedChild.class, "b", true).getDeclaringClass()); [EOL]         assertEquals(PrivatelyShadowedChild.class, FieldUtils.getField(PrivatelyShadowedChild.class, "i", true).getDeclaringClass()); [EOL]         assertEquals(PrivatelyShadowedChild.class, FieldUtils.getField(PrivatelyShadowedChild.class, "d", true).getDeclaringClass()); [EOL]     } [EOL]  [EOL]
@Test(expected = IllegalArgumentException.class) [EOL]     public void testGetDeclaredFieldAccessIllegalArgumentException1() { [EOL]         FieldUtils.getDeclaredField(null, "none"); [EOL]     } [EOL]  [EOL]
@Test(expected = IllegalArgumentException.class) [EOL]     public void testGetDeclaredFieldAccessIllegalArgumentException1() { [EOL]         FieldUtils.getDeclaredField(null, "none"); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetDeclaredFieldForceAccess() { [EOL]         assertEquals(PublicChild.class, FieldUtils.getDeclaredField(PublicChild.class, "VALUE", true).getDeclaringClass()); [EOL]         assertNull(FieldUtils.getDeclaredField(PublicChild.class, "s", true)); [EOL]         assertNull(FieldUtils.getDeclaredField(PublicChild.class, "b", true)); [EOL]         assertNull(FieldUtils.getDeclaredField(PublicChild.class, "i", true)); [EOL]         assertNull(FieldUtils.getDeclaredField(PublicChild.class, "d", true)); [EOL]         assertNull(FieldUtils.getDeclaredField(PubliclyShadowedChild.class, "VALUE", true)); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getDeclaredField(PubliclyShadowedChild.class, "s", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getDeclaredField(PubliclyShadowedChild.class, "b", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getDeclaredField(PubliclyShadowedChild.class, "i", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getDeclaredField(PubliclyShadowedChild.class, "d", true).getDeclaringClass()); [EOL]         assertNull(FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, "VALUE", true)); [EOL]         assertEquals(PrivatelyShadowedChild.class, FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, "s", true).getDeclaringClass()); [EOL]         assertEquals(PrivatelyShadowedChild.class, FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, "b", true).getDeclaringClass()); [EOL]         assertEquals(PrivatelyShadowedChild.class, FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, "i", true).getDeclaringClass()); [EOL]         assertEquals(PrivatelyShadowedChild.class, FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, "d", true).getDeclaringClass()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetDeclaredFieldForceAccess() { [EOL]         assertEquals(PublicChild.class, FieldUtils.getDeclaredField(PublicChild.class, "VALUE", true).getDeclaringClass()); [EOL]         assertNull(FieldUtils.getDeclaredField(PublicChild.class, "s", true)); [EOL]         assertNull(FieldUtils.getDeclaredField(PublicChild.class, "b", true)); [EOL]         assertNull(FieldUtils.getDeclaredField(PublicChild.class, "i", true)); [EOL]         assertNull(FieldUtils.getDeclaredField(PublicChild.class, "d", true)); [EOL]         assertNull(FieldUtils.getDeclaredField(PubliclyShadowedChild.class, "VALUE", true)); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getDeclaredField(PubliclyShadowedChild.class, "s", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getDeclaredField(PubliclyShadowedChild.class, "b", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getDeclaredField(PubliclyShadowedChild.class, "i", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getDeclaredField(PubliclyShadowedChild.class, "d", true).getDeclaringClass()); [EOL]         assertNull(FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, "VALUE", true)); [EOL]         assertEquals(PrivatelyShadowedChild.class, FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, "s", true).getDeclaringClass()); [EOL]         assertEquals(PrivatelyShadowedChild.class, FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, "b", true).getDeclaringClass()); [EOL]         assertEquals(PrivatelyShadowedChild.class, FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, "i", true).getDeclaringClass()); [EOL]         assertEquals(PrivatelyShadowedChild.class, FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, "d", true).getDeclaringClass()); [EOL]     } [EOL]  [EOL]
@Test(expected = IllegalArgumentException.class) [EOL]     public void testGetDeclaredFieldAccessIllegalArgumentException1() { [EOL]         FieldUtils.getDeclaredField(null, "none"); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetDeclaredFieldForceAccess() { [EOL]         assertEquals(PublicChild.class, FieldUtils.getDeclaredField(PublicChild.class, "VALUE", true).getDeclaringClass()); [EOL]         assertNull(FieldUtils.getDeclaredField(PublicChild.class, "s", true)); [EOL]         assertNull(FieldUtils.getDeclaredField(PublicChild.class, "b", true)); [EOL]         assertNull(FieldUtils.getDeclaredField(PublicChild.class, "i", true)); [EOL]         assertNull(FieldUtils.getDeclaredField(PublicChild.class, "d", true)); [EOL]         assertNull(FieldUtils.getDeclaredField(PubliclyShadowedChild.class, "VALUE", true)); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getDeclaredField(PubliclyShadowedChild.class, "s", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getDeclaredField(PubliclyShadowedChild.class, "b", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getDeclaredField(PubliclyShadowedChild.class, "i", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getDeclaredField(PubliclyShadowedChild.class, "d", true).getDeclaringClass()); [EOL]         assertNull(FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, "VALUE", true)); [EOL]         assertEquals(PrivatelyShadowedChild.class, FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, "s", true).getDeclaringClass()); [EOL]         assertEquals(PrivatelyShadowedChild.class, FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, "b", true).getDeclaringClass()); [EOL]         assertEquals(PrivatelyShadowedChild.class, FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, "i", true).getDeclaringClass()); [EOL]         assertEquals(PrivatelyShadowedChild.class, FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, "d", true).getDeclaringClass()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReadDeclaredNamedFieldForceAccess() throws Exception { [EOL]         try { [EOL]             FieldUtils.readDeclaredField(publicChild, null, true); [EOL]             fail("a null field name should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readDeclaredField((Object) null, "none", true); [EOL]             fail("a null target should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             assertEquals("s", FieldUtils.readDeclaredField(publicChild, "s", true)); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals("ss", FieldUtils.readDeclaredField(publiclyShadowedChild, "s", true)); [EOL]         assertEquals("ss", FieldUtils.readDeclaredField(privatelyShadowedChild, "s", true)); [EOL]         try { [EOL]             assertEquals(Boolean.FALSE, FieldUtils.readDeclaredField(publicChild, "b", true)); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(Boolean.TRUE, FieldUtils.readDeclaredField(publiclyShadowedChild, "b", true)); [EOL]         assertEquals(Boolean.TRUE, FieldUtils.readDeclaredField(privatelyShadowedChild, "b", true)); [EOL]         try { [EOL]             assertEquals(I0, FieldUtils.readDeclaredField(publicChild, "i", true)); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(I1, FieldUtils.readDeclaredField(publiclyShadowedChild, "i", true)); [EOL]         assertEquals(I1, FieldUtils.readDeclaredField(privatelyShadowedChild, "i", true)); [EOL]         try { [EOL]             assertEquals(D0, FieldUtils.readDeclaredField(publicChild, "d", true)); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(D1, FieldUtils.readDeclaredField(publiclyShadowedChild, "d", true)); [EOL]         assertEquals(D1, FieldUtils.readDeclaredField(privatelyShadowedChild, "d", true)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetDeclaredFieldForceAccess() { [EOL]         assertEquals(PublicChild.class, FieldUtils.getDeclaredField(PublicChild.class, "VALUE", true).getDeclaringClass()); [EOL]         assertNull(FieldUtils.getDeclaredField(PublicChild.class, "s", true)); [EOL]         assertNull(FieldUtils.getDeclaredField(PublicChild.class, "b", true)); [EOL]         assertNull(FieldUtils.getDeclaredField(PublicChild.class, "i", true)); [EOL]         assertNull(FieldUtils.getDeclaredField(PublicChild.class, "d", true)); [EOL]         assertNull(FieldUtils.getDeclaredField(PubliclyShadowedChild.class, "VALUE", true)); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getDeclaredField(PubliclyShadowedChild.class, "s", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getDeclaredField(PubliclyShadowedChild.class, "b", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getDeclaredField(PubliclyShadowedChild.class, "i", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getDeclaredField(PubliclyShadowedChild.class, "d", true).getDeclaringClass()); [EOL]         assertNull(FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, "VALUE", true)); [EOL]         assertEquals(PrivatelyShadowedChild.class, FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, "s", true).getDeclaringClass()); [EOL]         assertEquals(PrivatelyShadowedChild.class, FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, "b", true).getDeclaringClass()); [EOL]         assertEquals(PrivatelyShadowedChild.class, FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, "i", true).getDeclaringClass()); [EOL]         assertEquals(PrivatelyShadowedChild.class, FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, "d", true).getDeclaringClass()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetDeclaredFieldForceAccess() { [EOL]         assertEquals(PublicChild.class, FieldUtils.getDeclaredField(PublicChild.class, "VALUE", true).getDeclaringClass()); [EOL]         assertNull(FieldUtils.getDeclaredField(PublicChild.class, "s", true)); [EOL]         assertNull(FieldUtils.getDeclaredField(PublicChild.class, "b", true)); [EOL]         assertNull(FieldUtils.getDeclaredField(PublicChild.class, "i", true)); [EOL]         assertNull(FieldUtils.getDeclaredField(PublicChild.class, "d", true)); [EOL]         assertNull(FieldUtils.getDeclaredField(PubliclyShadowedChild.class, "VALUE", true)); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getDeclaredField(PubliclyShadowedChild.class, "s", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getDeclaredField(PubliclyShadowedChild.class, "b", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getDeclaredField(PubliclyShadowedChild.class, "i", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getDeclaredField(PubliclyShadowedChild.class, "d", true).getDeclaringClass()); [EOL]         assertNull(FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, "VALUE", true)); [EOL]         assertEquals(PrivatelyShadowedChild.class, FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, "s", true).getDeclaringClass()); [EOL]         assertEquals(PrivatelyShadowedChild.class, FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, "b", true).getDeclaringClass()); [EOL]         assertEquals(PrivatelyShadowedChild.class, FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, "i", true).getDeclaringClass()); [EOL]         assertEquals(PrivatelyShadowedChild.class, FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, "d", true).getDeclaringClass()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetDeclaredFieldForceAccess() { [EOL]         assertEquals(PublicChild.class, FieldUtils.getDeclaredField(PublicChild.class, "VALUE", true).getDeclaringClass()); [EOL]         assertNull(FieldUtils.getDeclaredField(PublicChild.class, "s", true)); [EOL]         assertNull(FieldUtils.getDeclaredField(PublicChild.class, "b", true)); [EOL]         assertNull(FieldUtils.getDeclaredField(PublicChild.class, "i", true)); [EOL]         assertNull(FieldUtils.getDeclaredField(PublicChild.class, "d", true)); [EOL]         assertNull(FieldUtils.getDeclaredField(PubliclyShadowedChild.class, "VALUE", true)); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getDeclaredField(PubliclyShadowedChild.class, "s", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getDeclaredField(PubliclyShadowedChild.class, "b", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getDeclaredField(PubliclyShadowedChild.class, "i", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getDeclaredField(PubliclyShadowedChild.class, "d", true).getDeclaringClass()); [EOL]         assertNull(FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, "VALUE", true)); [EOL]         assertEquals(PrivatelyShadowedChild.class, FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, "s", true).getDeclaringClass()); [EOL]         assertEquals(PrivatelyShadowedChild.class, FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, "b", true).getDeclaringClass()); [EOL]         assertEquals(PrivatelyShadowedChild.class, FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, "i", true).getDeclaringClass()); [EOL]         assertEquals(PrivatelyShadowedChild.class, FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, "d", true).getDeclaringClass()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetDeclaredFieldForceAccess() { [EOL]         assertEquals(PublicChild.class, FieldUtils.getDeclaredField(PublicChild.class, "VALUE", true).getDeclaringClass()); [EOL]         assertNull(FieldUtils.getDeclaredField(PublicChild.class, "s", true)); [EOL]         assertNull(FieldUtils.getDeclaredField(PublicChild.class, "b", true)); [EOL]         assertNull(FieldUtils.getDeclaredField(PublicChild.class, "i", true)); [EOL]         assertNull(FieldUtils.getDeclaredField(PublicChild.class, "d", true)); [EOL]         assertNull(FieldUtils.getDeclaredField(PubliclyShadowedChild.class, "VALUE", true)); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getDeclaredField(PubliclyShadowedChild.class, "s", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getDeclaredField(PubliclyShadowedChild.class, "b", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getDeclaredField(PubliclyShadowedChild.class, "i", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getDeclaredField(PubliclyShadowedChild.class, "d", true).getDeclaringClass()); [EOL]         assertNull(FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, "VALUE", true)); [EOL]         assertEquals(PrivatelyShadowedChild.class, FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, "s", true).getDeclaringClass()); [EOL]         assertEquals(PrivatelyShadowedChild.class, FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, "b", true).getDeclaringClass()); [EOL]         assertEquals(PrivatelyShadowedChild.class, FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, "i", true).getDeclaringClass()); [EOL]         assertEquals(PrivatelyShadowedChild.class, FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, "d", true).getDeclaringClass()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetDeclaredFieldForceAccess() { [EOL]         assertEquals(PublicChild.class, FieldUtils.getDeclaredField(PublicChild.class, "VALUE", true).getDeclaringClass()); [EOL]         assertNull(FieldUtils.getDeclaredField(PublicChild.class, "s", true)); [EOL]         assertNull(FieldUtils.getDeclaredField(PublicChild.class, "b", true)); [EOL]         assertNull(FieldUtils.getDeclaredField(PublicChild.class, "i", true)); [EOL]         assertNull(FieldUtils.getDeclaredField(PublicChild.class, "d", true)); [EOL]         assertNull(FieldUtils.getDeclaredField(PubliclyShadowedChild.class, "VALUE", true)); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getDeclaredField(PubliclyShadowedChild.class, "s", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getDeclaredField(PubliclyShadowedChild.class, "b", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getDeclaredField(PubliclyShadowedChild.class, "i", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getDeclaredField(PubliclyShadowedChild.class, "d", true).getDeclaringClass()); [EOL]         assertNull(FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, "VALUE", true)); [EOL]         assertEquals(PrivatelyShadowedChild.class, FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, "s", true).getDeclaringClass()); [EOL]         assertEquals(PrivatelyShadowedChild.class, FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, "b", true).getDeclaringClass()); [EOL]         assertEquals(PrivatelyShadowedChild.class, FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, "i", true).getDeclaringClass()); [EOL]         assertEquals(PrivatelyShadowedChild.class, FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, "d", true).getDeclaringClass()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReadDeclaredNamedField() throws Exception { [EOL]         try { [EOL]             FieldUtils.readDeclaredField(publicChild, null); [EOL]             fail("a null field name should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readDeclaredField((Object) null, "none"); [EOL]             fail("a null target should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             assertEquals("s", FieldUtils.readDeclaredField(publicChild, "s")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals("ss", FieldUtils.readDeclaredField(publiclyShadowedChild, "s")); [EOL]         try { [EOL]             assertEquals("s", FieldUtils.readDeclaredField(privatelyShadowedChild, "s")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             assertEquals(Boolean.FALSE, FieldUtils.readDeclaredField(publicChild, "b")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(Boolean.TRUE, FieldUtils.readDeclaredField(publiclyShadowedChild, "b")); [EOL]         try { [EOL]             assertEquals(Boolean.FALSE, FieldUtils.readDeclaredField(privatelyShadowedChild, "b")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             assertEquals(I0, FieldUtils.readDeclaredField(publicChild, "i")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(I1, FieldUtils.readDeclaredField(publiclyShadowedChild, "i")); [EOL]         try { [EOL]             assertEquals(I0, FieldUtils.readDeclaredField(privatelyShadowedChild, "i")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             assertEquals(D0, FieldUtils.readDeclaredField(publicChild, "d")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(D1, FieldUtils.readDeclaredField(publiclyShadowedChild, "d")); [EOL]         try { [EOL]             assertEquals(D0, FieldUtils.readDeclaredField(privatelyShadowedChild, "d")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetDeclaredFieldForceAccess() { [EOL]         assertEquals(PublicChild.class, FieldUtils.getDeclaredField(PublicChild.class, "VALUE", true).getDeclaringClass()); [EOL]         assertNull(FieldUtils.getDeclaredField(PublicChild.class, "s", true)); [EOL]         assertNull(FieldUtils.getDeclaredField(PublicChild.class, "b", true)); [EOL]         assertNull(FieldUtils.getDeclaredField(PublicChild.class, "i", true)); [EOL]         assertNull(FieldUtils.getDeclaredField(PublicChild.class, "d", true)); [EOL]         assertNull(FieldUtils.getDeclaredField(PubliclyShadowedChild.class, "VALUE", true)); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getDeclaredField(PubliclyShadowedChild.class, "s", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getDeclaredField(PubliclyShadowedChild.class, "b", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getDeclaredField(PubliclyShadowedChild.class, "i", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getDeclaredField(PubliclyShadowedChild.class, "d", true).getDeclaringClass()); [EOL]         assertNull(FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, "VALUE", true)); [EOL]         assertEquals(PrivatelyShadowedChild.class, FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, "s", true).getDeclaringClass()); [EOL]         assertEquals(PrivatelyShadowedChild.class, FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, "b", true).getDeclaringClass()); [EOL]         assertEquals(PrivatelyShadowedChild.class, FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, "i", true).getDeclaringClass()); [EOL]         assertEquals(PrivatelyShadowedChild.class, FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, "d", true).getDeclaringClass()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetDeclaredFieldForceAccess() { [EOL]         assertEquals(PublicChild.class, FieldUtils.getDeclaredField(PublicChild.class, "VALUE", true).getDeclaringClass()); [EOL]         assertNull(FieldUtils.getDeclaredField(PublicChild.class, "s", true)); [EOL]         assertNull(FieldUtils.getDeclaredField(PublicChild.class, "b", true)); [EOL]         assertNull(FieldUtils.getDeclaredField(PublicChild.class, "i", true)); [EOL]         assertNull(FieldUtils.getDeclaredField(PublicChild.class, "d", true)); [EOL]         assertNull(FieldUtils.getDeclaredField(PubliclyShadowedChild.class, "VALUE", true)); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getDeclaredField(PubliclyShadowedChild.class, "s", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getDeclaredField(PubliclyShadowedChild.class, "b", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getDeclaredField(PubliclyShadowedChild.class, "i", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getDeclaredField(PubliclyShadowedChild.class, "d", true).getDeclaringClass()); [EOL]         assertNull(FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, "VALUE", true)); [EOL]         assertEquals(PrivatelyShadowedChild.class, FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, "s", true).getDeclaringClass()); [EOL]         assertEquals(PrivatelyShadowedChild.class, FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, "b", true).getDeclaringClass()); [EOL]         assertEquals(PrivatelyShadowedChild.class, FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, "i", true).getDeclaringClass()); [EOL]         assertEquals(PrivatelyShadowedChild.class, FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, "d", true).getDeclaringClass()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAllFields() { [EOL]         assertArrayEquals(new Field[0], FieldUtils.getAllFields(Object.class)); [EOL]         final Field[] fieldsNumber = Number.class.getDeclaredFields(); [EOL]         assertArrayEquals(fieldsNumber, FieldUtils.getAllFields(Number.class)); [EOL]         final Field[] fieldsInteger = Integer.class.getDeclaredFields(); [EOL]         assertArrayEquals(ArrayUtils.addAll(fieldsInteger, fieldsNumber), FieldUtils.getAllFields(Integer.class)); [EOL]         assertEquals(5, FieldUtils.getAllFields(PublicChild.class).length); [EOL]     } [EOL]  [EOL]     private <T> List<T> asArrayList(T... values) { [EOL]         final ArrayList<T> arrayList = new ArrayList<T>(); [EOL]         for (T t : values) { [EOL]             arrayList.add(t); [EOL]         } [EOL]         return arrayList; [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAllFields() { [EOL]         assertArrayEquals(new Field[0], FieldUtils.getAllFields(Object.class)); [EOL]         final Field[] fieldsNumber = Number.class.getDeclaredFields(); [EOL]         assertArrayEquals(fieldsNumber, FieldUtils.getAllFields(Number.class)); [EOL]         final Field[] fieldsInteger = Integer.class.getDeclaredFields(); [EOL]         assertArrayEquals(ArrayUtils.addAll(fieldsInteger, fieldsNumber), FieldUtils.getAllFields(Integer.class)); [EOL]         assertEquals(5, FieldUtils.getAllFields(PublicChild.class).length); [EOL]     } [EOL]  [EOL]     private <T> List<T> asArrayList(T... values) { [EOL]         final ArrayList<T> arrayList = new ArrayList<T>(); [EOL]         for (T t : values) { [EOL]             arrayList.add(t); [EOL]         } [EOL]         return arrayList; [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAllFields() { [EOL]         assertArrayEquals(new Field[0], FieldUtils.getAllFields(Object.class)); [EOL]         final Field[] fieldsNumber = Number.class.getDeclaredFields(); [EOL]         assertArrayEquals(fieldsNumber, FieldUtils.getAllFields(Number.class)); [EOL]         final Field[] fieldsInteger = Integer.class.getDeclaredFields(); [EOL]         assertArrayEquals(ArrayUtils.addAll(fieldsInteger, fieldsNumber), FieldUtils.getAllFields(Integer.class)); [EOL]         assertEquals(5, FieldUtils.getAllFields(PublicChild.class).length); [EOL]     } [EOL]  [EOL]     private <T> List<T> asArrayList(T... values) { [EOL]         final ArrayList<T> arrayList = new ArrayList<T>(); [EOL]         for (T t : values) { [EOL]             arrayList.add(t); [EOL]         } [EOL]         return arrayList; [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAllFieldsList() { [EOL]         assertEquals(0, FieldUtils.getAllFieldsList(Object.class).size()); [EOL]         final List<Field> fieldsNumber = asArrayList(Number.class.getDeclaredFields()); [EOL]         assertEquals(fieldsNumber, FieldUtils.getAllFieldsList(Number.class)); [EOL]         final List<Field> fieldsInteger = asArrayList(Integer.class.getDeclaredFields()); [EOL]         final List<Field> allFieldsInteger = new ArrayList<Field>(fieldsInteger); [EOL]         allFieldsInteger.addAll(fieldsNumber); [EOL]         assertEquals(allFieldsInteger, FieldUtils.getAllFieldsList(Integer.class)); [EOL]         assertEquals(5, FieldUtils.getAllFieldsList(PublicChild.class).size()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAllFieldsList() { [EOL]         assertEquals(0, FieldUtils.getAllFieldsList(Object.class).size()); [EOL]         final List<Field> fieldsNumber = asArrayList(Number.class.getDeclaredFields()); [EOL]         assertEquals(fieldsNumber, FieldUtils.getAllFieldsList(Number.class)); [EOL]         final List<Field> fieldsInteger = asArrayList(Integer.class.getDeclaredFields()); [EOL]         final List<Field> allFieldsInteger = new ArrayList<Field>(fieldsInteger); [EOL]         allFieldsInteger.addAll(fieldsNumber); [EOL]         assertEquals(allFieldsInteger, FieldUtils.getAllFieldsList(Integer.class)); [EOL]         assertEquals(5, FieldUtils.getAllFieldsList(PublicChild.class).size()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAllFieldsList() { [EOL]         assertEquals(0, FieldUtils.getAllFieldsList(Object.class).size()); [EOL]         final List<Field> fieldsNumber = asArrayList(Number.class.getDeclaredFields()); [EOL]         assertEquals(fieldsNumber, FieldUtils.getAllFieldsList(Number.class)); [EOL]         final List<Field> fieldsInteger = asArrayList(Integer.class.getDeclaredFields()); [EOL]         final List<Field> allFieldsInteger = new ArrayList<Field>(fieldsInteger); [EOL]         allFieldsInteger.addAll(fieldsNumber); [EOL]         assertEquals(allFieldsInteger, FieldUtils.getAllFieldsList(Integer.class)); [EOL]         assertEquals(5, FieldUtils.getAllFieldsList(PublicChild.class).size()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAllFieldsList() { [EOL]         assertEquals(0, FieldUtils.getAllFieldsList(Object.class).size()); [EOL]         final List<Field> fieldsNumber = asArrayList(Number.class.getDeclaredFields()); [EOL]         assertEquals(fieldsNumber, FieldUtils.getAllFieldsList(Number.class)); [EOL]         final List<Field> fieldsInteger = asArrayList(Integer.class.getDeclaredFields()); [EOL]         final List<Field> allFieldsInteger = new ArrayList<Field>(fieldsInteger); [EOL]         allFieldsInteger.addAll(fieldsNumber); [EOL]         assertEquals(allFieldsInteger, FieldUtils.getAllFieldsList(Integer.class)); [EOL]         assertEquals(5, FieldUtils.getAllFieldsList(PublicChild.class).size()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAllFieldsList() { [EOL]         assertEquals(0, FieldUtils.getAllFieldsList(Object.class).size()); [EOL]         final List<Field> fieldsNumber = asArrayList(Number.class.getDeclaredFields()); [EOL]         assertEquals(fieldsNumber, FieldUtils.getAllFieldsList(Number.class)); [EOL]         final List<Field> fieldsInteger = asArrayList(Integer.class.getDeclaredFields()); [EOL]         final List<Field> allFieldsInteger = new ArrayList<Field>(fieldsInteger); [EOL]         allFieldsInteger.addAll(fieldsNumber); [EOL]         assertEquals(allFieldsInteger, FieldUtils.getAllFieldsList(Integer.class)); [EOL]         assertEquals(5, FieldUtils.getAllFieldsList(PublicChild.class).size()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAllFieldsList() { [EOL]         assertEquals(0, FieldUtils.getAllFieldsList(Object.class).size()); [EOL]         final List<Field> fieldsNumber = asArrayList(Number.class.getDeclaredFields()); [EOL]         assertEquals(fieldsNumber, FieldUtils.getAllFieldsList(Number.class)); [EOL]         final List<Field> fieldsInteger = asArrayList(Integer.class.getDeclaredFields()); [EOL]         final List<Field> allFieldsInteger = new ArrayList<Field>(fieldsInteger); [EOL]         allFieldsInteger.addAll(fieldsNumber); [EOL]         assertEquals(allFieldsInteger, FieldUtils.getAllFieldsList(Integer.class)); [EOL]         assertEquals(5, FieldUtils.getAllFieldsList(PublicChild.class).size()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAllFieldsList() { [EOL]         assertEquals(0, FieldUtils.getAllFieldsList(Object.class).size()); [EOL]         final List<Field> fieldsNumber = asArrayList(Number.class.getDeclaredFields()); [EOL]         assertEquals(fieldsNumber, FieldUtils.getAllFieldsList(Number.class)); [EOL]         final List<Field> fieldsInteger = asArrayList(Integer.class.getDeclaredFields()); [EOL]         final List<Field> allFieldsInteger = new ArrayList<Field>(fieldsInteger); [EOL]         allFieldsInteger.addAll(fieldsNumber); [EOL]         assertEquals(allFieldsInteger, FieldUtils.getAllFieldsList(Integer.class)); [EOL]         assertEquals(5, FieldUtils.getAllFieldsList(PublicChild.class).size()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAllFieldsList() { [EOL]         assertEquals(0, FieldUtils.getAllFieldsList(Object.class).size()); [EOL]         final List<Field> fieldsNumber = asArrayList(Number.class.getDeclaredFields()); [EOL]         assertEquals(fieldsNumber, FieldUtils.getAllFieldsList(Number.class)); [EOL]         final List<Field> fieldsInteger = asArrayList(Integer.class.getDeclaredFields()); [EOL]         final List<Field> allFieldsInteger = new ArrayList<Field>(fieldsInteger); [EOL]         allFieldsInteger.addAll(fieldsNumber); [EOL]         assertEquals(allFieldsInteger, FieldUtils.getAllFieldsList(Integer.class)); [EOL]         assertEquals(5, FieldUtils.getAllFieldsList(PublicChild.class).size()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAllFieldsList() { [EOL]         assertEquals(0, FieldUtils.getAllFieldsList(Object.class).size()); [EOL]         final List<Field> fieldsNumber = asArrayList(Number.class.getDeclaredFields()); [EOL]         assertEquals(fieldsNumber, FieldUtils.getAllFieldsList(Number.class)); [EOL]         final List<Field> fieldsInteger = asArrayList(Integer.class.getDeclaredFields()); [EOL]         final List<Field> allFieldsInteger = new ArrayList<Field>(fieldsInteger); [EOL]         allFieldsInteger.addAll(fieldsNumber); [EOL]         assertEquals(allFieldsInteger, FieldUtils.getAllFieldsList(Integer.class)); [EOL]         assertEquals(5, FieldUtils.getAllFieldsList(PublicChild.class).size()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAllFieldsList() { [EOL]         assertEquals(0, FieldUtils.getAllFieldsList(Object.class).size()); [EOL]         final List<Field> fieldsNumber = asArrayList(Number.class.getDeclaredFields()); [EOL]         assertEquals(fieldsNumber, FieldUtils.getAllFieldsList(Number.class)); [EOL]         final List<Field> fieldsInteger = asArrayList(Integer.class.getDeclaredFields()); [EOL]         final List<Field> allFieldsInteger = new ArrayList<Field>(fieldsInteger); [EOL]         allFieldsInteger.addAll(fieldsNumber); [EOL]         assertEquals(allFieldsInteger, FieldUtils.getAllFieldsList(Integer.class)); [EOL]         assertEquals(5, FieldUtils.getAllFieldsList(PublicChild.class).size()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReadStaticField() throws Exception { [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(FieldUtils.getField(Foo.class, "VALUE"))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReadStaticField() throws Exception { [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(FieldUtils.getField(Foo.class, "VALUE"))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReadNamedStaticField() throws Exception { [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(Foo.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PubliclyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PrivatelyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PublicChild.class, "VALUE")); [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(null, "none"); [EOL]             fail("null class should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(Foo.class, null); [EOL]             fail("null field name should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(Foo.class, "does_not_exist"); [EOL]             fail("a field that doesn't exist should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(PublicChild.class, "s"); [EOL]             fail("non-static field should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReadNamedStaticField() throws Exception { [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(Foo.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PubliclyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PrivatelyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PublicChild.class, "VALUE")); [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(null, "none"); [EOL]             fail("null class should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(Foo.class, null); [EOL]             fail("null field name should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(Foo.class, "does_not_exist"); [EOL]             fail("a field that doesn't exist should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(PublicChild.class, "s"); [EOL]             fail("non-static field should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]     } [EOL]  [EOL]
@Test(expected = IllegalArgumentException.class) [EOL]     public void testReadStaticFieldForceAccessIllegalArgumentException1() throws Exception { [EOL]         FieldUtils.readStaticField(null, true); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReadNamedStaticField() throws Exception { [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(Foo.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PubliclyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PrivatelyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PublicChild.class, "VALUE")); [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(null, "none"); [EOL]             fail("null class should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(Foo.class, null); [EOL]             fail("null field name should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(Foo.class, "does_not_exist"); [EOL]             fail("a field that doesn't exist should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(PublicChild.class, "s"); [EOL]             fail("non-static field should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReadNamedStaticField() throws Exception { [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(Foo.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PubliclyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PrivatelyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PublicChild.class, "VALUE")); [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(null, "none"); [EOL]             fail("null class should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(Foo.class, null); [EOL]             fail("null field name should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(Foo.class, "does_not_exist"); [EOL]             fail("a field that doesn't exist should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(PublicChild.class, "s"); [EOL]             fail("non-static field should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReadNamedStaticField() throws Exception { [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(Foo.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PubliclyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PrivatelyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PublicChild.class, "VALUE")); [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(null, "none"); [EOL]             fail("null class should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(Foo.class, null); [EOL]             fail("null field name should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(Foo.class, "does_not_exist"); [EOL]             fail("a field that doesn't exist should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(PublicChild.class, "s"); [EOL]             fail("non-static field should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReadNamedStaticField() throws Exception { [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(Foo.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PubliclyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PrivatelyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PublicChild.class, "VALUE")); [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(null, "none"); [EOL]             fail("null class should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(Foo.class, null); [EOL]             fail("null field name should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(Foo.class, "does_not_exist"); [EOL]             fail("a field that doesn't exist should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(PublicChild.class, "s"); [EOL]             fail("non-static field should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReadNamedStaticField() throws Exception { [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(Foo.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PubliclyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PrivatelyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PublicChild.class, "VALUE")); [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(null, "none"); [EOL]             fail("null class should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(Foo.class, null); [EOL]             fail("null field name should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(Foo.class, "does_not_exist"); [EOL]             fail("a field that doesn't exist should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(PublicChild.class, "s"); [EOL]             fail("non-static field should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReadNamedStaticField() throws Exception { [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(Foo.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PubliclyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PrivatelyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PublicChild.class, "VALUE")); [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(null, "none"); [EOL]             fail("null class should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(Foo.class, null); [EOL]             fail("null field name should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(Foo.class, "does_not_exist"); [EOL]             fail("a field that doesn't exist should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(PublicChild.class, "s"); [EOL]             fail("non-static field should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReadNamedStaticField() throws Exception { [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(Foo.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PubliclyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PrivatelyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PublicChild.class, "VALUE")); [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(null, "none"); [EOL]             fail("null class should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(Foo.class, null); [EOL]             fail("null field name should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(Foo.class, "does_not_exist"); [EOL]             fail("a field that doesn't exist should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(PublicChild.class, "s"); [EOL]             fail("non-static field should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReadNamedStaticField() throws Exception { [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(Foo.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PubliclyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PrivatelyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PublicChild.class, "VALUE")); [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(null, "none"); [EOL]             fail("null class should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(Foo.class, null); [EOL]             fail("null field name should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(Foo.class, "does_not_exist"); [EOL]             fail("a field that doesn't exist should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(PublicChild.class, "s"); [EOL]             fail("non-static field should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReadNamedStaticField() throws Exception { [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(Foo.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PubliclyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PrivatelyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PublicChild.class, "VALUE")); [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(null, "none"); [EOL]             fail("null class should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(Foo.class, null); [EOL]             fail("null field name should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(Foo.class, "does_not_exist"); [EOL]             fail("a field that doesn't exist should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(PublicChild.class, "s"); [EOL]             fail("non-static field should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReadNamedStaticField() throws Exception { [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(Foo.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PubliclyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PrivatelyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PublicChild.class, "VALUE")); [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(null, "none"); [EOL]             fail("null class should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(Foo.class, null); [EOL]             fail("null field name should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(Foo.class, "does_not_exist"); [EOL]             fail("a field that doesn't exist should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(PublicChild.class, "s"); [EOL]             fail("non-static field should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReadDeclaredNamedStaticField() throws Exception { [EOL]         assertEquals(Foo.VALUE, FieldUtils.readDeclaredStaticField(Foo.class, "VALUE")); [EOL]         try { [EOL]             assertEquals("child", FieldUtils.readDeclaredStaticField(PublicChild.class, "VALUE")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             assertEquals(Foo.VALUE, FieldUtils.readDeclaredStaticField(PubliclyShadowedChild.class, "VALUE")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             assertEquals(Foo.VALUE, FieldUtils.readDeclaredStaticField(PrivatelyShadowedChild.class, "VALUE")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReadDeclaredNamedStaticField() throws Exception { [EOL]         assertEquals(Foo.VALUE, FieldUtils.readDeclaredStaticField(Foo.class, "VALUE")); [EOL]         try { [EOL]             assertEquals("child", FieldUtils.readDeclaredStaticField(PublicChild.class, "VALUE")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             assertEquals(Foo.VALUE, FieldUtils.readDeclaredStaticField(PubliclyShadowedChild.class, "VALUE")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             assertEquals(Foo.VALUE, FieldUtils.readDeclaredStaticField(PrivatelyShadowedChild.class, "VALUE")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReadDeclaredNamedStaticFieldForceAccess() throws Exception { [EOL]         assertEquals(Foo.VALUE, FieldUtils.readDeclaredStaticField(Foo.class, "VALUE", true)); [EOL]         assertEquals("child", FieldUtils.readDeclaredStaticField(PublicChild.class, "VALUE", true)); [EOL]         try { [EOL]             assertEquals(Foo.VALUE, FieldUtils.readDeclaredStaticField(PubliclyShadowedChild.class, "VALUE", true)); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             assertEquals(Foo.VALUE, FieldUtils.readDeclaredStaticField(PrivatelyShadowedChild.class, "VALUE", true)); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReadDeclaredNamedStaticFieldForceAccess() throws Exception { [EOL]         assertEquals(Foo.VALUE, FieldUtils.readDeclaredStaticField(Foo.class, "VALUE", true)); [EOL]         assertEquals("child", FieldUtils.readDeclaredStaticField(PublicChild.class, "VALUE", true)); [EOL]         try { [EOL]             assertEquals(Foo.VALUE, FieldUtils.readDeclaredStaticField(PubliclyShadowedChild.class, "VALUE", true)); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             assertEquals(Foo.VALUE, FieldUtils.readDeclaredStaticField(PrivatelyShadowedChild.class, "VALUE", true)); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReadDeclaredNamedStaticFieldForceAccess() throws Exception { [EOL]         assertEquals(Foo.VALUE, FieldUtils.readDeclaredStaticField(Foo.class, "VALUE", true)); [EOL]         assertEquals("child", FieldUtils.readDeclaredStaticField(PublicChild.class, "VALUE", true)); [EOL]         try { [EOL]             assertEquals(Foo.VALUE, FieldUtils.readDeclaredStaticField(PubliclyShadowedChild.class, "VALUE", true)); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             assertEquals(Foo.VALUE, FieldUtils.readDeclaredStaticField(PrivatelyShadowedChild.class, "VALUE", true)); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReadDeclaredNamedStaticFieldForceAccess() throws Exception { [EOL]         assertEquals(Foo.VALUE, FieldUtils.readDeclaredStaticField(Foo.class, "VALUE", true)); [EOL]         assertEquals("child", FieldUtils.readDeclaredStaticField(PublicChild.class, "VALUE", true)); [EOL]         try { [EOL]             assertEquals(Foo.VALUE, FieldUtils.readDeclaredStaticField(PubliclyShadowedChild.class, "VALUE", true)); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             assertEquals(Foo.VALUE, FieldUtils.readDeclaredStaticField(PrivatelyShadowedChild.class, "VALUE", true)); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReadDeclaredNamedStaticFieldForceAccess() throws Exception { [EOL]         assertEquals(Foo.VALUE, FieldUtils.readDeclaredStaticField(Foo.class, "VALUE", true)); [EOL]         assertEquals("child", FieldUtils.readDeclaredStaticField(PublicChild.class, "VALUE", true)); [EOL]         try { [EOL]             assertEquals(Foo.VALUE, FieldUtils.readDeclaredStaticField(PubliclyShadowedChild.class, "VALUE", true)); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             assertEquals(Foo.VALUE, FieldUtils.readDeclaredStaticField(PrivatelyShadowedChild.class, "VALUE", true)); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReadNamedField() throws Exception { [EOL]         assertEquals("s", FieldUtils.readField(publicChild, "s")); [EOL]         assertEquals("ss", FieldUtils.readField(publiclyShadowedChild, "s")); [EOL]         assertEquals("s", FieldUtils.readField(privatelyShadowedChild, "s")); [EOL]  [EOL]         try { [EOL]             FieldUtils.readField(publicChild, null); [EOL]             fail("a null field name should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readField((Object) null, "none"); [EOL]             fail("a null target should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             assertEquals(Boolean.FALSE, FieldUtils.readField(publicChild, "b")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(Boolean.TRUE, FieldUtils.readField(publiclyShadowedChild, "b")); [EOL]         try { [EOL]             assertEquals(Boolean.FALSE, FieldUtils.readField(privatelyShadowedChild, "b")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             assertEquals(I0, FieldUtils.readField(publicChild, "i")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(I1, FieldUtils.readField(publiclyShadowedChild, "i")); [EOL]         try { [EOL]             assertEquals(I0, FieldUtils.readField(privatelyShadowedChild, "i")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             assertEquals(D0, FieldUtils.readField(publicChild, "d")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(D1, FieldUtils.readField(publiclyShadowedChild, "d")); [EOL]         try { [EOL]             assertEquals(D0, FieldUtils.readField(privatelyShadowedChild, "d")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReadNamedField() throws Exception { [EOL]         assertEquals("s", FieldUtils.readField(publicChild, "s")); [EOL]         assertEquals("ss", FieldUtils.readField(publiclyShadowedChild, "s")); [EOL]         assertEquals("s", FieldUtils.readField(privatelyShadowedChild, "s")); [EOL]  [EOL]         try { [EOL]             FieldUtils.readField(publicChild, null); [EOL]             fail("a null field name should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readField((Object) null, "none"); [EOL]             fail("a null target should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             assertEquals(Boolean.FALSE, FieldUtils.readField(publicChild, "b")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(Boolean.TRUE, FieldUtils.readField(publiclyShadowedChild, "b")); [EOL]         try { [EOL]             assertEquals(Boolean.FALSE, FieldUtils.readField(privatelyShadowedChild, "b")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             assertEquals(I0, FieldUtils.readField(publicChild, "i")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(I1, FieldUtils.readField(publiclyShadowedChild, "i")); [EOL]         try { [EOL]             assertEquals(I0, FieldUtils.readField(privatelyShadowedChild, "i")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             assertEquals(D0, FieldUtils.readField(publicChild, "d")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(D1, FieldUtils.readField(publiclyShadowedChild, "d")); [EOL]         try { [EOL]             assertEquals(D0, FieldUtils.readField(privatelyShadowedChild, "d")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReadNamedStaticField() throws Exception { [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(Foo.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PubliclyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PrivatelyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PublicChild.class, "VALUE")); [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(null, "none"); [EOL]             fail("null class should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(Foo.class, null); [EOL]             fail("null field name should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(Foo.class, "does_not_exist"); [EOL]             fail("a field that doesn't exist should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(PublicChild.class, "s"); [EOL]             fail("non-static field should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReadNamedStaticField() throws Exception { [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(Foo.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PubliclyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PrivatelyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PublicChild.class, "VALUE")); [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(null, "none"); [EOL]             fail("null class should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(Foo.class, null); [EOL]             fail("null field name should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(Foo.class, "does_not_exist"); [EOL]             fail("a field that doesn't exist should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(PublicChild.class, "s"); [EOL]             fail("non-static field should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReadField() throws Exception { [EOL]         final Field parentS = FieldUtils.getDeclaredField(parentClass, "s"); [EOL]         assertEquals("s", FieldUtils.readField(parentS, publicChild)); [EOL]         assertEquals("s", FieldUtils.readField(parentS, publiclyShadowedChild)); [EOL]         assertEquals("s", FieldUtils.readField(parentS, privatelyShadowedChild)); [EOL]         final Field parentB = FieldUtils.getDeclaredField(parentClass, "b", true); [EOL]         assertEquals(Boolean.FALSE, FieldUtils.readField(parentB, publicChild)); [EOL]         assertEquals(Boolean.FALSE, FieldUtils.readField(parentB, publiclyShadowedChild)); [EOL]         assertEquals(Boolean.FALSE, FieldUtils.readField(parentB, privatelyShadowedChild)); [EOL]         final Field parentI = FieldUtils.getDeclaredField(parentClass, "i", true); [EOL]         assertEquals(I0, FieldUtils.readField(parentI, publicChild)); [EOL]         assertEquals(I0, FieldUtils.readField(parentI, publiclyShadowedChild)); [EOL]         assertEquals(I0, FieldUtils.readField(parentI, privatelyShadowedChild)); [EOL]         final Field parentD = FieldUtils.getDeclaredField(parentClass, "d", true); [EOL]         assertEquals(D0, FieldUtils.readField(parentD, publicChild)); [EOL]         assertEquals(D0, FieldUtils.readField(parentD, publiclyShadowedChild)); [EOL]         assertEquals(D0, FieldUtils.readField(parentD, privatelyShadowedChild)); [EOL]  [EOL]         try { [EOL]             FieldUtils.readField((Field) null, publicChild); [EOL]             fail("a null field should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReadNamedStaticField() throws Exception { [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(Foo.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PubliclyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PrivatelyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PublicChild.class, "VALUE")); [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(null, "none"); [EOL]             fail("null class should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(Foo.class, null); [EOL]             fail("null field name should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(Foo.class, "does_not_exist"); [EOL]             fail("a field that doesn't exist should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(PublicChild.class, "s"); [EOL]             fail("non-static field should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReadFieldForceAccess() throws Exception { [EOL]         final Field parentS = FieldUtils.getDeclaredField(parentClass, "s"); [EOL]         parentS.setAccessible(false); [EOL]         assertEquals("s", FieldUtils.readField(parentS, publicChild, true)); [EOL]         assertEquals("s", FieldUtils.readField(parentS, publiclyShadowedChild, true)); [EOL]         assertEquals("s", FieldUtils.readField(parentS, privatelyShadowedChild, true)); [EOL]         final Field parentB = FieldUtils.getDeclaredField(parentClass, "b", true); [EOL]         parentB.setAccessible(false); [EOL]         assertEquals(Boolean.FALSE, FieldUtils.readField(parentB, publicChild, true)); [EOL]         assertEquals(Boolean.FALSE, FieldUtils.readField(parentB, publiclyShadowedChild, true)); [EOL]         assertEquals(Boolean.FALSE, FieldUtils.readField(parentB, privatelyShadowedChild, true)); [EOL]         final Field parentI = FieldUtils.getDeclaredField(parentClass, "i", true); [EOL]         parentI.setAccessible(false); [EOL]         assertEquals(I0, FieldUtils.readField(parentI, publicChild, true)); [EOL]         assertEquals(I0, FieldUtils.readField(parentI, publiclyShadowedChild, true)); [EOL]         assertEquals(I0, FieldUtils.readField(parentI, privatelyShadowedChild, true)); [EOL]         final Field parentD = FieldUtils.getDeclaredField(parentClass, "d", true); [EOL]         parentD.setAccessible(false); [EOL]         assertEquals(D0, FieldUtils.readField(parentD, publicChild, true)); [EOL]         assertEquals(D0, FieldUtils.readField(parentD, publiclyShadowedChild, true)); [EOL]         assertEquals(D0, FieldUtils.readField(parentD, privatelyShadowedChild, true)); [EOL]  [EOL]         try { [EOL]             FieldUtils.readField((Field) null, publicChild, true); [EOL]             fail("a null field should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReadNamedStaticField() throws Exception { [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(Foo.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PubliclyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PrivatelyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PublicChild.class, "VALUE")); [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(null, "none"); [EOL]             fail("null class should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(Foo.class, null); [EOL]             fail("null field name should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(Foo.class, "does_not_exist"); [EOL]             fail("a field that doesn't exist should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(PublicChild.class, "s"); [EOL]             fail("non-static field should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReadNamedStaticField() throws Exception { [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(Foo.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PubliclyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PrivatelyShadowedChild.class, "VALUE")); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PublicChild.class, "VALUE")); [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(null, "none"); [EOL]             fail("null class should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(Foo.class, null); [EOL]             fail("null field name should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(Foo.class, "does_not_exist"); [EOL]             fail("a field that doesn't exist should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(PublicChild.class, "s"); [EOL]             fail("non-static field should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReadNamedField() throws Exception { [EOL]         assertEquals("s", FieldUtils.readField(publicChild, "s")); [EOL]         assertEquals("ss", FieldUtils.readField(publiclyShadowedChild, "s")); [EOL]         assertEquals("s", FieldUtils.readField(privatelyShadowedChild, "s")); [EOL]  [EOL]         try { [EOL]             FieldUtils.readField(publicChild, null); [EOL]             fail("a null field name should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readField((Object) null, "none"); [EOL]             fail("a null target should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             assertEquals(Boolean.FALSE, FieldUtils.readField(publicChild, "b")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(Boolean.TRUE, FieldUtils.readField(publiclyShadowedChild, "b")); [EOL]         try { [EOL]             assertEquals(Boolean.FALSE, FieldUtils.readField(privatelyShadowedChild, "b")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             assertEquals(I0, FieldUtils.readField(publicChild, "i")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(I1, FieldUtils.readField(publiclyShadowedChild, "i")); [EOL]         try { [EOL]             assertEquals(I0, FieldUtils.readField(privatelyShadowedChild, "i")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             assertEquals(D0, FieldUtils.readField(publicChild, "d")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(D1, FieldUtils.readField(publiclyShadowedChild, "d")); [EOL]         try { [EOL]             assertEquals(D0, FieldUtils.readField(privatelyShadowedChild, "d")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReadNamedField() throws Exception { [EOL]         assertEquals("s", FieldUtils.readField(publicChild, "s")); [EOL]         assertEquals("ss", FieldUtils.readField(publiclyShadowedChild, "s")); [EOL]         assertEquals("s", FieldUtils.readField(privatelyShadowedChild, "s")); [EOL]  [EOL]         try { [EOL]             FieldUtils.readField(publicChild, null); [EOL]             fail("a null field name should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readField((Object) null, "none"); [EOL]             fail("a null target should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             assertEquals(Boolean.FALSE, FieldUtils.readField(publicChild, "b")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(Boolean.TRUE, FieldUtils.readField(publiclyShadowedChild, "b")); [EOL]         try { [EOL]             assertEquals(Boolean.FALSE, FieldUtils.readField(privatelyShadowedChild, "b")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             assertEquals(I0, FieldUtils.readField(publicChild, "i")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(I1, FieldUtils.readField(publiclyShadowedChild, "i")); [EOL]         try { [EOL]             assertEquals(I0, FieldUtils.readField(privatelyShadowedChild, "i")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             assertEquals(D0, FieldUtils.readField(publicChild, "d")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(D1, FieldUtils.readField(publiclyShadowedChild, "d")); [EOL]         try { [EOL]             assertEquals(D0, FieldUtils.readField(privatelyShadowedChild, "d")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReadNamedField() throws Exception { [EOL]         assertEquals("s", FieldUtils.readField(publicChild, "s")); [EOL]         assertEquals("ss", FieldUtils.readField(publiclyShadowedChild, "s")); [EOL]         assertEquals("s", FieldUtils.readField(privatelyShadowedChild, "s")); [EOL]  [EOL]         try { [EOL]             FieldUtils.readField(publicChild, null); [EOL]             fail("a null field name should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readField((Object) null, "none"); [EOL]             fail("a null target should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             assertEquals(Boolean.FALSE, FieldUtils.readField(publicChild, "b")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(Boolean.TRUE, FieldUtils.readField(publiclyShadowedChild, "b")); [EOL]         try { [EOL]             assertEquals(Boolean.FALSE, FieldUtils.readField(privatelyShadowedChild, "b")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             assertEquals(I0, FieldUtils.readField(publicChild, "i")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(I1, FieldUtils.readField(publiclyShadowedChild, "i")); [EOL]         try { [EOL]             assertEquals(I0, FieldUtils.readField(privatelyShadowedChild, "i")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             assertEquals(D0, FieldUtils.readField(publicChild, "d")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(D1, FieldUtils.readField(publiclyShadowedChild, "d")); [EOL]         try { [EOL]             assertEquals(D0, FieldUtils.readField(privatelyShadowedChild, "d")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReadNamedField() throws Exception { [EOL]         assertEquals("s", FieldUtils.readField(publicChild, "s")); [EOL]         assertEquals("ss", FieldUtils.readField(publiclyShadowedChild, "s")); [EOL]         assertEquals("s", FieldUtils.readField(privatelyShadowedChild, "s")); [EOL]  [EOL]         try { [EOL]             FieldUtils.readField(publicChild, null); [EOL]             fail("a null field name should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readField((Object) null, "none"); [EOL]             fail("a null target should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             assertEquals(Boolean.FALSE, FieldUtils.readField(publicChild, "b")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(Boolean.TRUE, FieldUtils.readField(publiclyShadowedChild, "b")); [EOL]         try { [EOL]             assertEquals(Boolean.FALSE, FieldUtils.readField(privatelyShadowedChild, "b")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             assertEquals(I0, FieldUtils.readField(publicChild, "i")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(I1, FieldUtils.readField(publiclyShadowedChild, "i")); [EOL]         try { [EOL]             assertEquals(I0, FieldUtils.readField(privatelyShadowedChild, "i")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             assertEquals(D0, FieldUtils.readField(publicChild, "d")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(D1, FieldUtils.readField(publiclyShadowedChild, "d")); [EOL]         try { [EOL]             assertEquals(D0, FieldUtils.readField(privatelyShadowedChild, "d")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReadNamedField() throws Exception { [EOL]         assertEquals("s", FieldUtils.readField(publicChild, "s")); [EOL]         assertEquals("ss", FieldUtils.readField(publiclyShadowedChild, "s")); [EOL]         assertEquals("s", FieldUtils.readField(privatelyShadowedChild, "s")); [EOL]  [EOL]         try { [EOL]             FieldUtils.readField(publicChild, null); [EOL]             fail("a null field name should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readField((Object) null, "none"); [EOL]             fail("a null target should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             assertEquals(Boolean.FALSE, FieldUtils.readField(publicChild, "b")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(Boolean.TRUE, FieldUtils.readField(publiclyShadowedChild, "b")); [EOL]         try { [EOL]             assertEquals(Boolean.FALSE, FieldUtils.readField(privatelyShadowedChild, "b")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             assertEquals(I0, FieldUtils.readField(publicChild, "i")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(I1, FieldUtils.readField(publiclyShadowedChild, "i")); [EOL]         try { [EOL]             assertEquals(I0, FieldUtils.readField(privatelyShadowedChild, "i")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             assertEquals(D0, FieldUtils.readField(publicChild, "d")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(D1, FieldUtils.readField(publiclyShadowedChild, "d")); [EOL]         try { [EOL]             assertEquals(D0, FieldUtils.readField(privatelyShadowedChild, "d")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReadNamedField() throws Exception { [EOL]         assertEquals("s", FieldUtils.readField(publicChild, "s")); [EOL]         assertEquals("ss", FieldUtils.readField(publiclyShadowedChild, "s")); [EOL]         assertEquals("s", FieldUtils.readField(privatelyShadowedChild, "s")); [EOL]  [EOL]         try { [EOL]             FieldUtils.readField(publicChild, null); [EOL]             fail("a null field name should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readField((Object) null, "none"); [EOL]             fail("a null target should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             assertEquals(Boolean.FALSE, FieldUtils.readField(publicChild, "b")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(Boolean.TRUE, FieldUtils.readField(publiclyShadowedChild, "b")); [EOL]         try { [EOL]             assertEquals(Boolean.FALSE, FieldUtils.readField(privatelyShadowedChild, "b")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             assertEquals(I0, FieldUtils.readField(publicChild, "i")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(I1, FieldUtils.readField(publiclyShadowedChild, "i")); [EOL]         try { [EOL]             assertEquals(I0, FieldUtils.readField(privatelyShadowedChild, "i")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             assertEquals(D0, FieldUtils.readField(publicChild, "d")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(D1, FieldUtils.readField(publiclyShadowedChild, "d")); [EOL]         try { [EOL]             assertEquals(D0, FieldUtils.readField(privatelyShadowedChild, "d")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReadNamedField() throws Exception { [EOL]         assertEquals("s", FieldUtils.readField(publicChild, "s")); [EOL]         assertEquals("ss", FieldUtils.readField(publiclyShadowedChild, "s")); [EOL]         assertEquals("s", FieldUtils.readField(privatelyShadowedChild, "s")); [EOL]  [EOL]         try { [EOL]             FieldUtils.readField(publicChild, null); [EOL]             fail("a null field name should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readField((Object) null, "none"); [EOL]             fail("a null target should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             assertEquals(Boolean.FALSE, FieldUtils.readField(publicChild, "b")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(Boolean.TRUE, FieldUtils.readField(publiclyShadowedChild, "b")); [EOL]         try { [EOL]             assertEquals(Boolean.FALSE, FieldUtils.readField(privatelyShadowedChild, "b")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             assertEquals(I0, FieldUtils.readField(publicChild, "i")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(I1, FieldUtils.readField(publiclyShadowedChild, "i")); [EOL]         try { [EOL]             assertEquals(I0, FieldUtils.readField(privatelyShadowedChild, "i")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             assertEquals(D0, FieldUtils.readField(publicChild, "d")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(D1, FieldUtils.readField(publiclyShadowedChild, "d")); [EOL]         try { [EOL]             assertEquals(D0, FieldUtils.readField(privatelyShadowedChild, "d")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReadNamedField() throws Exception { [EOL]         assertEquals("s", FieldUtils.readField(publicChild, "s")); [EOL]         assertEquals("ss", FieldUtils.readField(publiclyShadowedChild, "s")); [EOL]         assertEquals("s", FieldUtils.readField(privatelyShadowedChild, "s")); [EOL]  [EOL]         try { [EOL]             FieldUtils.readField(publicChild, null); [EOL]             fail("a null field name should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readField((Object) null, "none"); [EOL]             fail("a null target should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             assertEquals(Boolean.FALSE, FieldUtils.readField(publicChild, "b")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(Boolean.TRUE, FieldUtils.readField(publiclyShadowedChild, "b")); [EOL]         try { [EOL]             assertEquals(Boolean.FALSE, FieldUtils.readField(privatelyShadowedChild, "b")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             assertEquals(I0, FieldUtils.readField(publicChild, "i")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(I1, FieldUtils.readField(publiclyShadowedChild, "i")); [EOL]         try { [EOL]             assertEquals(I0, FieldUtils.readField(privatelyShadowedChild, "i")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             assertEquals(D0, FieldUtils.readField(publicChild, "d")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(D1, FieldUtils.readField(publiclyShadowedChild, "d")); [EOL]         try { [EOL]             assertEquals(D0, FieldUtils.readField(privatelyShadowedChild, "d")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReadNamedField() throws Exception { [EOL]         assertEquals("s", FieldUtils.readField(publicChild, "s")); [EOL]         assertEquals("ss", FieldUtils.readField(publiclyShadowedChild, "s")); [EOL]         assertEquals("s", FieldUtils.readField(privatelyShadowedChild, "s")); [EOL]  [EOL]         try { [EOL]             FieldUtils.readField(publicChild, null); [EOL]             fail("a null field name should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readField((Object) null, "none"); [EOL]             fail("a null target should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             assertEquals(Boolean.FALSE, FieldUtils.readField(publicChild, "b")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(Boolean.TRUE, FieldUtils.readField(publiclyShadowedChild, "b")); [EOL]         try { [EOL]             assertEquals(Boolean.FALSE, FieldUtils.readField(privatelyShadowedChild, "b")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             assertEquals(I0, FieldUtils.readField(publicChild, "i")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(I1, FieldUtils.readField(publiclyShadowedChild, "i")); [EOL]         try { [EOL]             assertEquals(I0, FieldUtils.readField(privatelyShadowedChild, "i")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             assertEquals(D0, FieldUtils.readField(publicChild, "d")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(D1, FieldUtils.readField(publiclyShadowedChild, "d")); [EOL]         try { [EOL]             assertEquals(D0, FieldUtils.readField(privatelyShadowedChild, "d")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReadNamedField() throws Exception { [EOL]         assertEquals("s", FieldUtils.readField(publicChild, "s")); [EOL]         assertEquals("ss", FieldUtils.readField(publiclyShadowedChild, "s")); [EOL]         assertEquals("s", FieldUtils.readField(privatelyShadowedChild, "s")); [EOL]  [EOL]         try { [EOL]             FieldUtils.readField(publicChild, null); [EOL]             fail("a null field name should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readField((Object) null, "none"); [EOL]             fail("a null target should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             assertEquals(Boolean.FALSE, FieldUtils.readField(publicChild, "b")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(Boolean.TRUE, FieldUtils.readField(publiclyShadowedChild, "b")); [EOL]         try { [EOL]             assertEquals(Boolean.FALSE, FieldUtils.readField(privatelyShadowedChild, "b")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             assertEquals(I0, FieldUtils.readField(publicChild, "i")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(I1, FieldUtils.readField(publiclyShadowedChild, "i")); [EOL]         try { [EOL]             assertEquals(I0, FieldUtils.readField(privatelyShadowedChild, "i")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             assertEquals(D0, FieldUtils.readField(publicChild, "d")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(D1, FieldUtils.readField(publiclyShadowedChild, "d")); [EOL]         try { [EOL]             assertEquals(D0, FieldUtils.readField(privatelyShadowedChild, "d")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReadDeclaredNamedField() throws Exception { [EOL]         try { [EOL]             FieldUtils.readDeclaredField(publicChild, null); [EOL]             fail("a null field name should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readDeclaredField((Object) null, "none"); [EOL]             fail("a null target should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             assertEquals("s", FieldUtils.readDeclaredField(publicChild, "s")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals("ss", FieldUtils.readDeclaredField(publiclyShadowedChild, "s")); [EOL]         try { [EOL]             assertEquals("s", FieldUtils.readDeclaredField(privatelyShadowedChild, "s")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             assertEquals(Boolean.FALSE, FieldUtils.readDeclaredField(publicChild, "b")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(Boolean.TRUE, FieldUtils.readDeclaredField(publiclyShadowedChild, "b")); [EOL]         try { [EOL]             assertEquals(Boolean.FALSE, FieldUtils.readDeclaredField(privatelyShadowedChild, "b")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             assertEquals(I0, FieldUtils.readDeclaredField(publicChild, "i")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(I1, FieldUtils.readDeclaredField(publiclyShadowedChild, "i")); [EOL]         try { [EOL]             assertEquals(I0, FieldUtils.readDeclaredField(privatelyShadowedChild, "i")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             assertEquals(D0, FieldUtils.readDeclaredField(publicChild, "d")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(D1, FieldUtils.readDeclaredField(publiclyShadowedChild, "d")); [EOL]         try { [EOL]             assertEquals(D0, FieldUtils.readDeclaredField(privatelyShadowedChild, "d")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReadDeclaredNamedField() throws Exception { [EOL]         try { [EOL]             FieldUtils.readDeclaredField(publicChild, null); [EOL]             fail("a null field name should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readDeclaredField((Object) null, "none"); [EOL]             fail("a null target should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             assertEquals("s", FieldUtils.readDeclaredField(publicChild, "s")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals("ss", FieldUtils.readDeclaredField(publiclyShadowedChild, "s")); [EOL]         try { [EOL]             assertEquals("s", FieldUtils.readDeclaredField(privatelyShadowedChild, "s")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             assertEquals(Boolean.FALSE, FieldUtils.readDeclaredField(publicChild, "b")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(Boolean.TRUE, FieldUtils.readDeclaredField(publiclyShadowedChild, "b")); [EOL]         try { [EOL]             assertEquals(Boolean.FALSE, FieldUtils.readDeclaredField(privatelyShadowedChild, "b")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             assertEquals(I0, FieldUtils.readDeclaredField(publicChild, "i")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(I1, FieldUtils.readDeclaredField(publiclyShadowedChild, "i")); [EOL]         try { [EOL]             assertEquals(I0, FieldUtils.readDeclaredField(privatelyShadowedChild, "i")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             assertEquals(D0, FieldUtils.readDeclaredField(publicChild, "d")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(D1, FieldUtils.readDeclaredField(publiclyShadowedChild, "d")); [EOL]         try { [EOL]             assertEquals(D0, FieldUtils.readDeclaredField(privatelyShadowedChild, "d")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReadDeclaredNamedFieldForceAccess() throws Exception { [EOL]         try { [EOL]             FieldUtils.readDeclaredField(publicChild, null, true); [EOL]             fail("a null field name should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readDeclaredField((Object) null, "none", true); [EOL]             fail("a null target should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             assertEquals("s", FieldUtils.readDeclaredField(publicChild, "s", true)); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals("ss", FieldUtils.readDeclaredField(publiclyShadowedChild, "s", true)); [EOL]         assertEquals("ss", FieldUtils.readDeclaredField(privatelyShadowedChild, "s", true)); [EOL]         try { [EOL]             assertEquals(Boolean.FALSE, FieldUtils.readDeclaredField(publicChild, "b", true)); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(Boolean.TRUE, FieldUtils.readDeclaredField(publiclyShadowedChild, "b", true)); [EOL]         assertEquals(Boolean.TRUE, FieldUtils.readDeclaredField(privatelyShadowedChild, "b", true)); [EOL]         try { [EOL]             assertEquals(I0, FieldUtils.readDeclaredField(publicChild, "i", true)); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(I1, FieldUtils.readDeclaredField(publiclyShadowedChild, "i", true)); [EOL]         assertEquals(I1, FieldUtils.readDeclaredField(privatelyShadowedChild, "i", true)); [EOL]         try { [EOL]             assertEquals(D0, FieldUtils.readDeclaredField(publicChild, "d", true)); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(D1, FieldUtils.readDeclaredField(publiclyShadowedChild, "d", true)); [EOL]         assertEquals(D1, FieldUtils.readDeclaredField(privatelyShadowedChild, "d", true)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReadDeclaredNamedFieldForceAccess() throws Exception { [EOL]         try { [EOL]             FieldUtils.readDeclaredField(publicChild, null, true); [EOL]             fail("a null field name should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readDeclaredField((Object) null, "none", true); [EOL]             fail("a null target should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             assertEquals("s", FieldUtils.readDeclaredField(publicChild, "s", true)); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals("ss", FieldUtils.readDeclaredField(publiclyShadowedChild, "s", true)); [EOL]         assertEquals("ss", FieldUtils.readDeclaredField(privatelyShadowedChild, "s", true)); [EOL]         try { [EOL]             assertEquals(Boolean.FALSE, FieldUtils.readDeclaredField(publicChild, "b", true)); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(Boolean.TRUE, FieldUtils.readDeclaredField(publiclyShadowedChild, "b", true)); [EOL]         assertEquals(Boolean.TRUE, FieldUtils.readDeclaredField(privatelyShadowedChild, "b", true)); [EOL]         try { [EOL]             assertEquals(I0, FieldUtils.readDeclaredField(publicChild, "i", true)); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(I1, FieldUtils.readDeclaredField(publiclyShadowedChild, "i", true)); [EOL]         assertEquals(I1, FieldUtils.readDeclaredField(privatelyShadowedChild, "i", true)); [EOL]         try { [EOL]             assertEquals(D0, FieldUtils.readDeclaredField(publicChild, "d", true)); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(D1, FieldUtils.readDeclaredField(publiclyShadowedChild, "d", true)); [EOL]         assertEquals(D1, FieldUtils.readDeclaredField(privatelyShadowedChild, "d", true)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReadDeclaredNamedFieldForceAccess() throws Exception { [EOL]         try { [EOL]             FieldUtils.readDeclaredField(publicChild, null, true); [EOL]             fail("a null field name should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readDeclaredField((Object) null, "none", true); [EOL]             fail("a null target should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             assertEquals("s", FieldUtils.readDeclaredField(publicChild, "s", true)); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals("ss", FieldUtils.readDeclaredField(publiclyShadowedChild, "s", true)); [EOL]         assertEquals("ss", FieldUtils.readDeclaredField(privatelyShadowedChild, "s", true)); [EOL]         try { [EOL]             assertEquals(Boolean.FALSE, FieldUtils.readDeclaredField(publicChild, "b", true)); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(Boolean.TRUE, FieldUtils.readDeclaredField(publiclyShadowedChild, "b", true)); [EOL]         assertEquals(Boolean.TRUE, FieldUtils.readDeclaredField(privatelyShadowedChild, "b", true)); [EOL]         try { [EOL]             assertEquals(I0, FieldUtils.readDeclaredField(publicChild, "i", true)); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(I1, FieldUtils.readDeclaredField(publiclyShadowedChild, "i", true)); [EOL]         assertEquals(I1, FieldUtils.readDeclaredField(privatelyShadowedChild, "i", true)); [EOL]         try { [EOL]             assertEquals(D0, FieldUtils.readDeclaredField(publicChild, "d", true)); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(D1, FieldUtils.readDeclaredField(publiclyShadowedChild, "d", true)); [EOL]         assertEquals(D1, FieldUtils.readDeclaredField(privatelyShadowedChild, "d", true)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReadDeclaredNamedFieldForceAccess() throws Exception { [EOL]         try { [EOL]             FieldUtils.readDeclaredField(publicChild, null, true); [EOL]             fail("a null field name should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readDeclaredField((Object) null, "none", true); [EOL]             fail("a null target should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             assertEquals("s", FieldUtils.readDeclaredField(publicChild, "s", true)); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals("ss", FieldUtils.readDeclaredField(publiclyShadowedChild, "s", true)); [EOL]         assertEquals("ss", FieldUtils.readDeclaredField(privatelyShadowedChild, "s", true)); [EOL]         try { [EOL]             assertEquals(Boolean.FALSE, FieldUtils.readDeclaredField(publicChild, "b", true)); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(Boolean.TRUE, FieldUtils.readDeclaredField(publiclyShadowedChild, "b", true)); [EOL]         assertEquals(Boolean.TRUE, FieldUtils.readDeclaredField(privatelyShadowedChild, "b", true)); [EOL]         try { [EOL]             assertEquals(I0, FieldUtils.readDeclaredField(publicChild, "i", true)); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(I1, FieldUtils.readDeclaredField(publiclyShadowedChild, "i", true)); [EOL]         assertEquals(I1, FieldUtils.readDeclaredField(privatelyShadowedChild, "i", true)); [EOL]         try { [EOL]             assertEquals(D0, FieldUtils.readDeclaredField(publicChild, "d", true)); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(D1, FieldUtils.readDeclaredField(publiclyShadowedChild, "d", true)); [EOL]         assertEquals(D1, FieldUtils.readDeclaredField(privatelyShadowedChild, "d", true)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReadDeclaredNamedFieldForceAccess() throws Exception { [EOL]         try { [EOL]             FieldUtils.readDeclaredField(publicChild, null, true); [EOL]             fail("a null field name should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readDeclaredField((Object) null, "none", true); [EOL]             fail("a null target should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             assertEquals("s", FieldUtils.readDeclaredField(publicChild, "s", true)); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals("ss", FieldUtils.readDeclaredField(publiclyShadowedChild, "s", true)); [EOL]         assertEquals("ss", FieldUtils.readDeclaredField(privatelyShadowedChild, "s", true)); [EOL]         try { [EOL]             assertEquals(Boolean.FALSE, FieldUtils.readDeclaredField(publicChild, "b", true)); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(Boolean.TRUE, FieldUtils.readDeclaredField(publiclyShadowedChild, "b", true)); [EOL]         assertEquals(Boolean.TRUE, FieldUtils.readDeclaredField(privatelyShadowedChild, "b", true)); [EOL]         try { [EOL]             assertEquals(I0, FieldUtils.readDeclaredField(publicChild, "i", true)); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(I1, FieldUtils.readDeclaredField(publiclyShadowedChild, "i", true)); [EOL]         assertEquals(I1, FieldUtils.readDeclaredField(privatelyShadowedChild, "i", true)); [EOL]         try { [EOL]             assertEquals(D0, FieldUtils.readDeclaredField(publicChild, "d", true)); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(D1, FieldUtils.readDeclaredField(publiclyShadowedChild, "d", true)); [EOL]         assertEquals(D1, FieldUtils.readDeclaredField(privatelyShadowedChild, "d", true)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReadDeclaredNamedFieldForceAccess() throws Exception { [EOL]         try { [EOL]             FieldUtils.readDeclaredField(publicChild, null, true); [EOL]             fail("a null field name should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readDeclaredField((Object) null, "none", true); [EOL]             fail("a null target should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             assertEquals("s", FieldUtils.readDeclaredField(publicChild, "s", true)); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals("ss", FieldUtils.readDeclaredField(publiclyShadowedChild, "s", true)); [EOL]         assertEquals("ss", FieldUtils.readDeclaredField(privatelyShadowedChild, "s", true)); [EOL]         try { [EOL]             assertEquals(Boolean.FALSE, FieldUtils.readDeclaredField(publicChild, "b", true)); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(Boolean.TRUE, FieldUtils.readDeclaredField(publiclyShadowedChild, "b", true)); [EOL]         assertEquals(Boolean.TRUE, FieldUtils.readDeclaredField(privatelyShadowedChild, "b", true)); [EOL]         try { [EOL]             assertEquals(I0, FieldUtils.readDeclaredField(publicChild, "i", true)); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(I1, FieldUtils.readDeclaredField(publiclyShadowedChild, "i", true)); [EOL]         assertEquals(I1, FieldUtils.readDeclaredField(privatelyShadowedChild, "i", true)); [EOL]         try { [EOL]             assertEquals(D0, FieldUtils.readDeclaredField(publicChild, "d", true)); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(D1, FieldUtils.readDeclaredField(publiclyShadowedChild, "d", true)); [EOL]         assertEquals(D1, FieldUtils.readDeclaredField(privatelyShadowedChild, "d", true)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReadDeclaredNamedFieldForceAccess() throws Exception { [EOL]         try { [EOL]             FieldUtils.readDeclaredField(publicChild, null, true); [EOL]             fail("a null field name should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readDeclaredField((Object) null, "none", true); [EOL]             fail("a null target should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             assertEquals("s", FieldUtils.readDeclaredField(publicChild, "s", true)); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals("ss", FieldUtils.readDeclaredField(publiclyShadowedChild, "s", true)); [EOL]         assertEquals("ss", FieldUtils.readDeclaredField(privatelyShadowedChild, "s", true)); [EOL]         try { [EOL]             assertEquals(Boolean.FALSE, FieldUtils.readDeclaredField(publicChild, "b", true)); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(Boolean.TRUE, FieldUtils.readDeclaredField(publiclyShadowedChild, "b", true)); [EOL]         assertEquals(Boolean.TRUE, FieldUtils.readDeclaredField(privatelyShadowedChild, "b", true)); [EOL]         try { [EOL]             assertEquals(I0, FieldUtils.readDeclaredField(publicChild, "i", true)); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(I1, FieldUtils.readDeclaredField(publiclyShadowedChild, "i", true)); [EOL]         assertEquals(I1, FieldUtils.readDeclaredField(privatelyShadowedChild, "i", true)); [EOL]         try { [EOL]             assertEquals(D0, FieldUtils.readDeclaredField(publicChild, "d", true)); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(D1, FieldUtils.readDeclaredField(publiclyShadowedChild, "d", true)); [EOL]         assertEquals(D1, FieldUtils.readDeclaredField(privatelyShadowedChild, "d", true)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReadDeclaredNamedFieldForceAccess() throws Exception { [EOL]         try { [EOL]             FieldUtils.readDeclaredField(publicChild, null, true); [EOL]             fail("a null field name should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readDeclaredField((Object) null, "none", true); [EOL]             fail("a null target should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             assertEquals("s", FieldUtils.readDeclaredField(publicChild, "s", true)); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals("ss", FieldUtils.readDeclaredField(publiclyShadowedChild, "s", true)); [EOL]         assertEquals("ss", FieldUtils.readDeclaredField(privatelyShadowedChild, "s", true)); [EOL]         try { [EOL]             assertEquals(Boolean.FALSE, FieldUtils.readDeclaredField(publicChild, "b", true)); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(Boolean.TRUE, FieldUtils.readDeclaredField(publiclyShadowedChild, "b", true)); [EOL]         assertEquals(Boolean.TRUE, FieldUtils.readDeclaredField(privatelyShadowedChild, "b", true)); [EOL]         try { [EOL]             assertEquals(I0, FieldUtils.readDeclaredField(publicChild, "i", true)); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(I1, FieldUtils.readDeclaredField(publiclyShadowedChild, "i", true)); [EOL]         assertEquals(I1, FieldUtils.readDeclaredField(privatelyShadowedChild, "i", true)); [EOL]         try { [EOL]             assertEquals(D0, FieldUtils.readDeclaredField(publicChild, "d", true)); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(D1, FieldUtils.readDeclaredField(publiclyShadowedChild, "d", true)); [EOL]         assertEquals(D1, FieldUtils.readDeclaredField(privatelyShadowedChild, "d", true)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testWriteNamedStaticField() throws Exception { [EOL]         FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePublic", "new"); [EOL]         assertEquals("new", StaticContainer.mutablePublic); [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutableProtected", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePackage", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePrivate", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "IMMUTABLE_PUBLIC", "new"); [EOL]             fail("Expected IllegalAccessException"); [EOL]         } catch (final IllegalAccessException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "IMMUTABLE_PROTECTED", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "IMMUTABLE_PACKAGE", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "IMMUTABLE_PRIVATE", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testWriteNamedStaticField() throws Exception { [EOL]         FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePublic", "new"); [EOL]         assertEquals("new", StaticContainer.mutablePublic); [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutableProtected", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePackage", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePrivate", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "IMMUTABLE_PUBLIC", "new"); [EOL]             fail("Expected IllegalAccessException"); [EOL]         } catch (final IllegalAccessException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "IMMUTABLE_PROTECTED", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "IMMUTABLE_PACKAGE", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "IMMUTABLE_PRIVATE", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testWriteNamedStaticField() throws Exception { [EOL]         FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePublic", "new"); [EOL]         assertEquals("new", StaticContainer.mutablePublic); [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutableProtected", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePackage", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePrivate", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "IMMUTABLE_PUBLIC", "new"); [EOL]             fail("Expected IllegalAccessException"); [EOL]         } catch (final IllegalAccessException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "IMMUTABLE_PROTECTED", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "IMMUTABLE_PACKAGE", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "IMMUTABLE_PRIVATE", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testWriteNamedStaticField() throws Exception { [EOL]         FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePublic", "new"); [EOL]         assertEquals("new", StaticContainer.mutablePublic); [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutableProtected", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePackage", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePrivate", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "IMMUTABLE_PUBLIC", "new"); [EOL]             fail("Expected IllegalAccessException"); [EOL]         } catch (final IllegalAccessException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "IMMUTABLE_PROTECTED", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "IMMUTABLE_PACKAGE", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "IMMUTABLE_PRIVATE", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testWriteNamedStaticField() throws Exception { [EOL]         FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePublic", "new"); [EOL]         assertEquals("new", StaticContainer.mutablePublic); [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutableProtected", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePackage", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePrivate", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "IMMUTABLE_PUBLIC", "new"); [EOL]             fail("Expected IllegalAccessException"); [EOL]         } catch (final IllegalAccessException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "IMMUTABLE_PROTECTED", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "IMMUTABLE_PACKAGE", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "IMMUTABLE_PRIVATE", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testWriteNamedStaticField() throws Exception { [EOL]         FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePublic", "new"); [EOL]         assertEquals("new", StaticContainer.mutablePublic); [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutableProtected", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePackage", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePrivate", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "IMMUTABLE_PUBLIC", "new"); [EOL]             fail("Expected IllegalAccessException"); [EOL]         } catch (final IllegalAccessException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "IMMUTABLE_PROTECTED", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "IMMUTABLE_PACKAGE", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "IMMUTABLE_PRIVATE", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testWriteNamedStaticField() throws Exception { [EOL]         FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePublic", "new"); [EOL]         assertEquals("new", StaticContainer.mutablePublic); [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutableProtected", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePackage", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePrivate", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "IMMUTABLE_PUBLIC", "new"); [EOL]             fail("Expected IllegalAccessException"); [EOL]         } catch (final IllegalAccessException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "IMMUTABLE_PROTECTED", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "IMMUTABLE_PACKAGE", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "IMMUTABLE_PRIVATE", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testWriteDeclaredNamedStaticField() throws Exception { [EOL]         FieldUtils.writeStaticField(StaticContainer.class, "mutablePublic", "new"); [EOL]         assertEquals("new", StaticContainer.mutablePublic); [EOL]         try { [EOL]             FieldUtils.writeDeclaredStaticField(StaticContainer.class, "mutableProtected", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeDeclaredStaticField(StaticContainer.class, "mutablePackage", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeDeclaredStaticField(StaticContainer.class, "mutablePrivate", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeDeclaredStaticField(StaticContainer.class, "IMMUTABLE_PUBLIC", "new"); [EOL]             fail("Expected IllegalAccessException"); [EOL]         } catch (final IllegalAccessException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeDeclaredStaticField(StaticContainer.class, "IMMUTABLE_PROTECTED", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeDeclaredStaticField(StaticContainer.class, "IMMUTABLE_PACKAGE", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeDeclaredStaticField(StaticContainer.class, "IMMUTABLE_PRIVATE", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testWriteDeclaredNamedStaticField() throws Exception { [EOL]         FieldUtils.writeStaticField(StaticContainer.class, "mutablePublic", "new"); [EOL]         assertEquals("new", StaticContainer.mutablePublic); [EOL]         try { [EOL]             FieldUtils.writeDeclaredStaticField(StaticContainer.class, "mutableProtected", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeDeclaredStaticField(StaticContainer.class, "mutablePackage", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeDeclaredStaticField(StaticContainer.class, "mutablePrivate", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeDeclaredStaticField(StaticContainer.class, "IMMUTABLE_PUBLIC", "new"); [EOL]             fail("Expected IllegalAccessException"); [EOL]         } catch (final IllegalAccessException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeDeclaredStaticField(StaticContainer.class, "IMMUTABLE_PROTECTED", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeDeclaredStaticField(StaticContainer.class, "IMMUTABLE_PACKAGE", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeDeclaredStaticField(StaticContainer.class, "IMMUTABLE_PRIVATE", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testWriteDeclaredNamedStaticField() throws Exception { [EOL]         FieldUtils.writeStaticField(StaticContainer.class, "mutablePublic", "new"); [EOL]         assertEquals("new", StaticContainer.mutablePublic); [EOL]         try { [EOL]             FieldUtils.writeDeclaredStaticField(StaticContainer.class, "mutableProtected", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeDeclaredStaticField(StaticContainer.class, "mutablePackage", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeDeclaredStaticField(StaticContainer.class, "mutablePrivate", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeDeclaredStaticField(StaticContainer.class, "IMMUTABLE_PUBLIC", "new"); [EOL]             fail("Expected IllegalAccessException"); [EOL]         } catch (final IllegalAccessException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeDeclaredStaticField(StaticContainer.class, "IMMUTABLE_PROTECTED", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeDeclaredStaticField(StaticContainer.class, "IMMUTABLE_PACKAGE", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeDeclaredStaticField(StaticContainer.class, "IMMUTABLE_PRIVATE", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testWriteDeclaredNamedStaticField() throws Exception { [EOL]         FieldUtils.writeStaticField(StaticContainer.class, "mutablePublic", "new"); [EOL]         assertEquals("new", StaticContainer.mutablePublic); [EOL]         try { [EOL]             FieldUtils.writeDeclaredStaticField(StaticContainer.class, "mutableProtected", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeDeclaredStaticField(StaticContainer.class, "mutablePackage", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeDeclaredStaticField(StaticContainer.class, "mutablePrivate", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeDeclaredStaticField(StaticContainer.class, "IMMUTABLE_PUBLIC", "new"); [EOL]             fail("Expected IllegalAccessException"); [EOL]         } catch (final IllegalAccessException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeDeclaredStaticField(StaticContainer.class, "IMMUTABLE_PROTECTED", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeDeclaredStaticField(StaticContainer.class, "IMMUTABLE_PACKAGE", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeDeclaredStaticField(StaticContainer.class, "IMMUTABLE_PRIVATE", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testWriteDeclaredNamedStaticField() throws Exception { [EOL]         FieldUtils.writeStaticField(StaticContainer.class, "mutablePublic", "new"); [EOL]         assertEquals("new", StaticContainer.mutablePublic); [EOL]         try { [EOL]             FieldUtils.writeDeclaredStaticField(StaticContainer.class, "mutableProtected", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeDeclaredStaticField(StaticContainer.class, "mutablePackage", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeDeclaredStaticField(StaticContainer.class, "mutablePrivate", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeDeclaredStaticField(StaticContainer.class, "IMMUTABLE_PUBLIC", "new"); [EOL]             fail("Expected IllegalAccessException"); [EOL]         } catch (final IllegalAccessException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeDeclaredStaticField(StaticContainer.class, "IMMUTABLE_PROTECTED", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeDeclaredStaticField(StaticContainer.class, "IMMUTABLE_PACKAGE", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeDeclaredStaticField(StaticContainer.class, "IMMUTABLE_PRIVATE", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testWriteDeclaredNamedStaticField() throws Exception { [EOL]         FieldUtils.writeStaticField(StaticContainer.class, "mutablePublic", "new"); [EOL]         assertEquals("new", StaticContainer.mutablePublic); [EOL]         try { [EOL]             FieldUtils.writeDeclaredStaticField(StaticContainer.class, "mutableProtected", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeDeclaredStaticField(StaticContainer.class, "mutablePackage", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeDeclaredStaticField(StaticContainer.class, "mutablePrivate", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeDeclaredStaticField(StaticContainer.class, "IMMUTABLE_PUBLIC", "new"); [EOL]             fail("Expected IllegalAccessException"); [EOL]         } catch (final IllegalAccessException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeDeclaredStaticField(StaticContainer.class, "IMMUTABLE_PROTECTED", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeDeclaredStaticField(StaticContainer.class, "IMMUTABLE_PACKAGE", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeDeclaredStaticField(StaticContainer.class, "IMMUTABLE_PRIVATE", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testWriteDeclaredNamedStaticField() throws Exception { [EOL]         FieldUtils.writeStaticField(StaticContainer.class, "mutablePublic", "new"); [EOL]         assertEquals("new", StaticContainer.mutablePublic); [EOL]         try { [EOL]             FieldUtils.writeDeclaredStaticField(StaticContainer.class, "mutableProtected", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeDeclaredStaticField(StaticContainer.class, "mutablePackage", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeDeclaredStaticField(StaticContainer.class, "mutablePrivate", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeDeclaredStaticField(StaticContainer.class, "IMMUTABLE_PUBLIC", "new"); [EOL]             fail("Expected IllegalAccessException"); [EOL]         } catch (final IllegalAccessException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeDeclaredStaticField(StaticContainer.class, "IMMUTABLE_PROTECTED", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeDeclaredStaticField(StaticContainer.class, "IMMUTABLE_PACKAGE", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeDeclaredStaticField(StaticContainer.class, "IMMUTABLE_PRIVATE", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testWriteNamedField() throws Exception { [EOL]         FieldUtils.writeField(publicChild, "s", "S"); [EOL]         assertEquals("S", FieldUtils.readField(publicChild, "s")); [EOL]         try { [EOL]             FieldUtils.writeField(publicChild, "b", Boolean.TRUE); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeField(publicChild, "i", Integer.valueOf(1)); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeField(publicChild, "d", Double.valueOf(1.0)); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]  [EOL]         FieldUtils.writeField(publiclyShadowedChild, "s", "S"); [EOL]         assertEquals("S", FieldUtils.readField(publiclyShadowedChild, "s")); [EOL]         FieldUtils.writeField(publiclyShadowedChild, "b", Boolean.FALSE); [EOL]         assertEquals(Boolean.FALSE, FieldUtils.readField(publiclyShadowedChild, "b")); [EOL]         FieldUtils.writeField(publiclyShadowedChild, "i", Integer.valueOf(0)); [EOL]         assertEquals(Integer.valueOf(0), FieldUtils.readField(publiclyShadowedChild, "i")); [EOL]         FieldUtils.writeField(publiclyShadowedChild, "d", Double.valueOf(0.0)); [EOL]         assertEquals(Double.valueOf(0.0), FieldUtils.readField(publiclyShadowedChild, "d")); [EOL]  [EOL]         FieldUtils.writeField(privatelyShadowedChild, "s", "S"); [EOL]         assertEquals("S", FieldUtils.readField(privatelyShadowedChild, "s")); [EOL]         try { [EOL]             FieldUtils.writeField(privatelyShadowedChild, "b", Boolean.TRUE); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeField(privatelyShadowedChild, "i", Integer.valueOf(1)); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeField(privatelyShadowedChild, "d", Double.valueOf(1.0)); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testWriteNamedField() throws Exception { [EOL]         FieldUtils.writeField(publicChild, "s", "S"); [EOL]         assertEquals("S", FieldUtils.readField(publicChild, "s")); [EOL]         try { [EOL]             FieldUtils.writeField(publicChild, "b", Boolean.TRUE); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeField(publicChild, "i", Integer.valueOf(1)); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeField(publicChild, "d", Double.valueOf(1.0)); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]  [EOL]         FieldUtils.writeField(publiclyShadowedChild, "s", "S"); [EOL]         assertEquals("S", FieldUtils.readField(publiclyShadowedChild, "s")); [EOL]         FieldUtils.writeField(publiclyShadowedChild, "b", Boolean.FALSE); [EOL]         assertEquals(Boolean.FALSE, FieldUtils.readField(publiclyShadowedChild, "b")); [EOL]         FieldUtils.writeField(publiclyShadowedChild, "i", Integer.valueOf(0)); [EOL]         assertEquals(Integer.valueOf(0), FieldUtils.readField(publiclyShadowedChild, "i")); [EOL]         FieldUtils.writeField(publiclyShadowedChild, "d", Double.valueOf(0.0)); [EOL]         assertEquals(Double.valueOf(0.0), FieldUtils.readField(publiclyShadowedChild, "d")); [EOL]  [EOL]         FieldUtils.writeField(privatelyShadowedChild, "s", "S"); [EOL]         assertEquals("S", FieldUtils.readField(privatelyShadowedChild, "s")); [EOL]         try { [EOL]             FieldUtils.writeField(privatelyShadowedChild, "b", Boolean.TRUE); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeField(privatelyShadowedChild, "i", Integer.valueOf(1)); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeField(privatelyShadowedChild, "d", Double.valueOf(1.0)); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testWriteNamedStaticField() throws Exception { [EOL]         FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePublic", "new"); [EOL]         assertEquals("new", StaticContainer.mutablePublic); [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutableProtected", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePackage", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePrivate", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "IMMUTABLE_PUBLIC", "new"); [EOL]             fail("Expected IllegalAccessException"); [EOL]         } catch (final IllegalAccessException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "IMMUTABLE_PROTECTED", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "IMMUTABLE_PACKAGE", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "IMMUTABLE_PRIVATE", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testWriteNamedStaticField() throws Exception { [EOL]         FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePublic", "new"); [EOL]         assertEquals("new", StaticContainer.mutablePublic); [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutableProtected", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePackage", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePrivate", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "IMMUTABLE_PUBLIC", "new"); [EOL]             fail("Expected IllegalAccessException"); [EOL]         } catch (final IllegalAccessException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "IMMUTABLE_PROTECTED", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "IMMUTABLE_PACKAGE", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "IMMUTABLE_PRIVATE", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testWriteNamedStaticField() throws Exception { [EOL]         FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePublic", "new"); [EOL]         assertEquals("new", StaticContainer.mutablePublic); [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutableProtected", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePackage", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePrivate", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "IMMUTABLE_PUBLIC", "new"); [EOL]             fail("Expected IllegalAccessException"); [EOL]         } catch (final IllegalAccessException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "IMMUTABLE_PROTECTED", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "IMMUTABLE_PACKAGE", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "IMMUTABLE_PRIVATE", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testWriteFieldForceAccess() throws Exception { [EOL]         Field field = parentClass.getDeclaredField("s"); [EOL]         FieldUtils.writeField(field, publicChild, "S", true); [EOL]         assertEquals("S", field.get(publicChild)); [EOL]         field = parentClass.getDeclaredField("b"); [EOL]         FieldUtils.writeField(field, publicChild, Boolean.TRUE, true); [EOL]         assertEquals(Boolean.TRUE, field.get(publicChild)); [EOL]         field = parentClass.getDeclaredField("i"); [EOL]         FieldUtils.writeField(field, publicChild, Integer.valueOf(Integer.MAX_VALUE), true); [EOL]         assertEquals(Integer.valueOf(Integer.MAX_VALUE), field.get(publicChild)); [EOL]         field = parentClass.getDeclaredField("d"); [EOL]         FieldUtils.writeField(field, publicChild, Double.valueOf(Double.MAX_VALUE), true); [EOL]         assertEquals(Double.valueOf(Double.MAX_VALUE), field.get(publicChild)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testWriteNamedStaticField() throws Exception { [EOL]         FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePublic", "new"); [EOL]         assertEquals("new", StaticContainer.mutablePublic); [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutableProtected", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePackage", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePrivate", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "IMMUTABLE_PUBLIC", "new"); [EOL]             fail("Expected IllegalAccessException"); [EOL]         } catch (final IllegalAccessException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "IMMUTABLE_PROTECTED", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "IMMUTABLE_PACKAGE", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "IMMUTABLE_PRIVATE", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testWriteNamedStaticField() throws Exception { [EOL]         FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePublic", "new"); [EOL]         assertEquals("new", StaticContainer.mutablePublic); [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutableProtected", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePackage", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePrivate", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "IMMUTABLE_PUBLIC", "new"); [EOL]             fail("Expected IllegalAccessException"); [EOL]         } catch (final IllegalAccessException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "IMMUTABLE_PROTECTED", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "IMMUTABLE_PACKAGE", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeStaticField(StaticContainerChild.class, "IMMUTABLE_PRIVATE", "new"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testWriteNamedField() throws Exception { [EOL]         FieldUtils.writeField(publicChild, "s", "S"); [EOL]         assertEquals("S", FieldUtils.readField(publicChild, "s")); [EOL]         try { [EOL]             FieldUtils.writeField(publicChild, "b", Boolean.TRUE); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeField(publicChild, "i", Integer.valueOf(1)); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeField(publicChild, "d", Double.valueOf(1.0)); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]  [EOL]         FieldUtils.writeField(publiclyShadowedChild, "s", "S"); [EOL]         assertEquals("S", FieldUtils.readField(publiclyShadowedChild, "s")); [EOL]         FieldUtils.writeField(publiclyShadowedChild, "b", Boolean.FALSE); [EOL]         assertEquals(Boolean.FALSE, FieldUtils.readField(publiclyShadowedChild, "b")); [EOL]         FieldUtils.writeField(publiclyShadowedChild, "i", Integer.valueOf(0)); [EOL]         assertEquals(Integer.valueOf(0), FieldUtils.readField(publiclyShadowedChild, "i")); [EOL]         FieldUtils.writeField(publiclyShadowedChild, "d", Double.valueOf(0.0)); [EOL]         assertEquals(Double.valueOf(0.0), FieldUtils.readField(publiclyShadowedChild, "d")); [EOL]  [EOL]         FieldUtils.writeField(privatelyShadowedChild, "s", "S"); [EOL]         assertEquals("S", FieldUtils.readField(privatelyShadowedChild, "s")); [EOL]         try { [EOL]             FieldUtils.writeField(privatelyShadowedChild, "b", Boolean.TRUE); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeField(privatelyShadowedChild, "i", Integer.valueOf(1)); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeField(privatelyShadowedChild, "d", Double.valueOf(1.0)); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testWriteNamedField() throws Exception { [EOL]         FieldUtils.writeField(publicChild, "s", "S"); [EOL]         assertEquals("S", FieldUtils.readField(publicChild, "s")); [EOL]         try { [EOL]             FieldUtils.writeField(publicChild, "b", Boolean.TRUE); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeField(publicChild, "i", Integer.valueOf(1)); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeField(publicChild, "d", Double.valueOf(1.0)); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]  [EOL]         FieldUtils.writeField(publiclyShadowedChild, "s", "S"); [EOL]         assertEquals("S", FieldUtils.readField(publiclyShadowedChild, "s")); [EOL]         FieldUtils.writeField(publiclyShadowedChild, "b", Boolean.FALSE); [EOL]         assertEquals(Boolean.FALSE, FieldUtils.readField(publiclyShadowedChild, "b")); [EOL]         FieldUtils.writeField(publiclyShadowedChild, "i", Integer.valueOf(0)); [EOL]         assertEquals(Integer.valueOf(0), FieldUtils.readField(publiclyShadowedChild, "i")); [EOL]         FieldUtils.writeField(publiclyShadowedChild, "d", Double.valueOf(0.0)); [EOL]         assertEquals(Double.valueOf(0.0), FieldUtils.readField(publiclyShadowedChild, "d")); [EOL]  [EOL]         FieldUtils.writeField(privatelyShadowedChild, "s", "S"); [EOL]         assertEquals("S", FieldUtils.readField(privatelyShadowedChild, "s")); [EOL]         try { [EOL]             FieldUtils.writeField(privatelyShadowedChild, "b", Boolean.TRUE); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeField(privatelyShadowedChild, "i", Integer.valueOf(1)); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeField(privatelyShadowedChild, "d", Double.valueOf(1.0)); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testWriteNamedField() throws Exception { [EOL]         FieldUtils.writeField(publicChild, "s", "S"); [EOL]         assertEquals("S", FieldUtils.readField(publicChild, "s")); [EOL]         try { [EOL]             FieldUtils.writeField(publicChild, "b", Boolean.TRUE); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeField(publicChild, "i", Integer.valueOf(1)); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeField(publicChild, "d", Double.valueOf(1.0)); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]  [EOL]         FieldUtils.writeField(publiclyShadowedChild, "s", "S"); [EOL]         assertEquals("S", FieldUtils.readField(publiclyShadowedChild, "s")); [EOL]         FieldUtils.writeField(publiclyShadowedChild, "b", Boolean.FALSE); [EOL]         assertEquals(Boolean.FALSE, FieldUtils.readField(publiclyShadowedChild, "b")); [EOL]         FieldUtils.writeField(publiclyShadowedChild, "i", Integer.valueOf(0)); [EOL]         assertEquals(Integer.valueOf(0), FieldUtils.readField(publiclyShadowedChild, "i")); [EOL]         FieldUtils.writeField(publiclyShadowedChild, "d", Double.valueOf(0.0)); [EOL]         assertEquals(Double.valueOf(0.0), FieldUtils.readField(publiclyShadowedChild, "d")); [EOL]  [EOL]         FieldUtils.writeField(privatelyShadowedChild, "s", "S"); [EOL]         assertEquals("S", FieldUtils.readField(privatelyShadowedChild, "s")); [EOL]         try { [EOL]             FieldUtils.writeField(privatelyShadowedChild, "b", Boolean.TRUE); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeField(privatelyShadowedChild, "i", Integer.valueOf(1)); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeField(privatelyShadowedChild, "d", Double.valueOf(1.0)); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testWriteNamedField() throws Exception { [EOL]         FieldUtils.writeField(publicChild, "s", "S"); [EOL]         assertEquals("S", FieldUtils.readField(publicChild, "s")); [EOL]         try { [EOL]             FieldUtils.writeField(publicChild, "b", Boolean.TRUE); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeField(publicChild, "i", Integer.valueOf(1)); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeField(publicChild, "d", Double.valueOf(1.0)); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]  [EOL]         FieldUtils.writeField(publiclyShadowedChild, "s", "S"); [EOL]         assertEquals("S", FieldUtils.readField(publiclyShadowedChild, "s")); [EOL]         FieldUtils.writeField(publiclyShadowedChild, "b", Boolean.FALSE); [EOL]         assertEquals(Boolean.FALSE, FieldUtils.readField(publiclyShadowedChild, "b")); [EOL]         FieldUtils.writeField(publiclyShadowedChild, "i", Integer.valueOf(0)); [EOL]         assertEquals(Integer.valueOf(0), FieldUtils.readField(publiclyShadowedChild, "i")); [EOL]         FieldUtils.writeField(publiclyShadowedChild, "d", Double.valueOf(0.0)); [EOL]         assertEquals(Double.valueOf(0.0), FieldUtils.readField(publiclyShadowedChild, "d")); [EOL]  [EOL]         FieldUtils.writeField(privatelyShadowedChild, "s", "S"); [EOL]         assertEquals("S", FieldUtils.readField(privatelyShadowedChild, "s")); [EOL]         try { [EOL]             FieldUtils.writeField(privatelyShadowedChild, "b", Boolean.TRUE); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeField(privatelyShadowedChild, "i", Integer.valueOf(1)); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeField(privatelyShadowedChild, "d", Double.valueOf(1.0)); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testWriteNamedField() throws Exception { [EOL]         FieldUtils.writeField(publicChild, "s", "S"); [EOL]         assertEquals("S", FieldUtils.readField(publicChild, "s")); [EOL]         try { [EOL]             FieldUtils.writeField(publicChild, "b", Boolean.TRUE); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeField(publicChild, "i", Integer.valueOf(1)); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeField(publicChild, "d", Double.valueOf(1.0)); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]  [EOL]         FieldUtils.writeField(publiclyShadowedChild, "s", "S"); [EOL]         assertEquals("S", FieldUtils.readField(publiclyShadowedChild, "s")); [EOL]         FieldUtils.writeField(publiclyShadowedChild, "b", Boolean.FALSE); [EOL]         assertEquals(Boolean.FALSE, FieldUtils.readField(publiclyShadowedChild, "b")); [EOL]         FieldUtils.writeField(publiclyShadowedChild, "i", Integer.valueOf(0)); [EOL]         assertEquals(Integer.valueOf(0), FieldUtils.readField(publiclyShadowedChild, "i")); [EOL]         FieldUtils.writeField(publiclyShadowedChild, "d", Double.valueOf(0.0)); [EOL]         assertEquals(Double.valueOf(0.0), FieldUtils.readField(publiclyShadowedChild, "d")); [EOL]  [EOL]         FieldUtils.writeField(privatelyShadowedChild, "s", "S"); [EOL]         assertEquals("S", FieldUtils.readField(privatelyShadowedChild, "s")); [EOL]         try { [EOL]             FieldUtils.writeField(privatelyShadowedChild, "b", Boolean.TRUE); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeField(privatelyShadowedChild, "i", Integer.valueOf(1)); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeField(privatelyShadowedChild, "d", Double.valueOf(1.0)); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testWriteNamedField() throws Exception { [EOL]         FieldUtils.writeField(publicChild, "s", "S"); [EOL]         assertEquals("S", FieldUtils.readField(publicChild, "s")); [EOL]         try { [EOL]             FieldUtils.writeField(publicChild, "b", Boolean.TRUE); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeField(publicChild, "i", Integer.valueOf(1)); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeField(publicChild, "d", Double.valueOf(1.0)); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]  [EOL]         FieldUtils.writeField(publiclyShadowedChild, "s", "S"); [EOL]         assertEquals("S", FieldUtils.readField(publiclyShadowedChild, "s")); [EOL]         FieldUtils.writeField(publiclyShadowedChild, "b", Boolean.FALSE); [EOL]         assertEquals(Boolean.FALSE, FieldUtils.readField(publiclyShadowedChild, "b")); [EOL]         FieldUtils.writeField(publiclyShadowedChild, "i", Integer.valueOf(0)); [EOL]         assertEquals(Integer.valueOf(0), FieldUtils.readField(publiclyShadowedChild, "i")); [EOL]         FieldUtils.writeField(publiclyShadowedChild, "d", Double.valueOf(0.0)); [EOL]         assertEquals(Double.valueOf(0.0), FieldUtils.readField(publiclyShadowedChild, "d")); [EOL]  [EOL]         FieldUtils.writeField(privatelyShadowedChild, "s", "S"); [EOL]         assertEquals("S", FieldUtils.readField(privatelyShadowedChild, "s")); [EOL]         try { [EOL]             FieldUtils.writeField(privatelyShadowedChild, "b", Boolean.TRUE); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeField(privatelyShadowedChild, "i", Integer.valueOf(1)); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeField(privatelyShadowedChild, "d", Double.valueOf(1.0)); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testWriteNamedField() throws Exception { [EOL]         FieldUtils.writeField(publicChild, "s", "S"); [EOL]         assertEquals("S", FieldUtils.readField(publicChild, "s")); [EOL]         try { [EOL]             FieldUtils.writeField(publicChild, "b", Boolean.TRUE); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeField(publicChild, "i", Integer.valueOf(1)); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeField(publicChild, "d", Double.valueOf(1.0)); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]  [EOL]         FieldUtils.writeField(publiclyShadowedChild, "s", "S"); [EOL]         assertEquals("S", FieldUtils.readField(publiclyShadowedChild, "s")); [EOL]         FieldUtils.writeField(publiclyShadowedChild, "b", Boolean.FALSE); [EOL]         assertEquals(Boolean.FALSE, FieldUtils.readField(publiclyShadowedChild, "b")); [EOL]         FieldUtils.writeField(publiclyShadowedChild, "i", Integer.valueOf(0)); [EOL]         assertEquals(Integer.valueOf(0), FieldUtils.readField(publiclyShadowedChild, "i")); [EOL]         FieldUtils.writeField(publiclyShadowedChild, "d", Double.valueOf(0.0)); [EOL]         assertEquals(Double.valueOf(0.0), FieldUtils.readField(publiclyShadowedChild, "d")); [EOL]  [EOL]         FieldUtils.writeField(privatelyShadowedChild, "s", "S"); [EOL]         assertEquals("S", FieldUtils.readField(privatelyShadowedChild, "s")); [EOL]         try { [EOL]             FieldUtils.writeField(privatelyShadowedChild, "b", Boolean.TRUE); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeField(privatelyShadowedChild, "i", Integer.valueOf(1)); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeField(privatelyShadowedChild, "d", Double.valueOf(1.0)); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testWriteNamedField() throws Exception { [EOL]         FieldUtils.writeField(publicChild, "s", "S"); [EOL]         assertEquals("S", FieldUtils.readField(publicChild, "s")); [EOL]         try { [EOL]             FieldUtils.writeField(publicChild, "b", Boolean.TRUE); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeField(publicChild, "i", Integer.valueOf(1)); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeField(publicChild, "d", Double.valueOf(1.0)); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]  [EOL]         FieldUtils.writeField(publiclyShadowedChild, "s", "S"); [EOL]         assertEquals("S", FieldUtils.readField(publiclyShadowedChild, "s")); [EOL]         FieldUtils.writeField(publiclyShadowedChild, "b", Boolean.FALSE); [EOL]         assertEquals(Boolean.FALSE, FieldUtils.readField(publiclyShadowedChild, "b")); [EOL]         FieldUtils.writeField(publiclyShadowedChild, "i", Integer.valueOf(0)); [EOL]         assertEquals(Integer.valueOf(0), FieldUtils.readField(publiclyShadowedChild, "i")); [EOL]         FieldUtils.writeField(publiclyShadowedChild, "d", Double.valueOf(0.0)); [EOL]         assertEquals(Double.valueOf(0.0), FieldUtils.readField(publiclyShadowedChild, "d")); [EOL]  [EOL]         FieldUtils.writeField(privatelyShadowedChild, "s", "S"); [EOL]         assertEquals("S", FieldUtils.readField(privatelyShadowedChild, "s")); [EOL]         try { [EOL]             FieldUtils.writeField(privatelyShadowedChild, "b", Boolean.TRUE); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeField(privatelyShadowedChild, "i", Integer.valueOf(1)); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeField(privatelyShadowedChild, "d", Double.valueOf(1.0)); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testWriteNamedField() throws Exception { [EOL]         FieldUtils.writeField(publicChild, "s", "S"); [EOL]         assertEquals("S", FieldUtils.readField(publicChild, "s")); [EOL]         try { [EOL]             FieldUtils.writeField(publicChild, "b", Boolean.TRUE); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeField(publicChild, "i", Integer.valueOf(1)); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeField(publicChild, "d", Double.valueOf(1.0)); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]  [EOL]         FieldUtils.writeField(publiclyShadowedChild, "s", "S"); [EOL]         assertEquals("S", FieldUtils.readField(publiclyShadowedChild, "s")); [EOL]         FieldUtils.writeField(publiclyShadowedChild, "b", Boolean.FALSE); [EOL]         assertEquals(Boolean.FALSE, FieldUtils.readField(publiclyShadowedChild, "b")); [EOL]         FieldUtils.writeField(publiclyShadowedChild, "i", Integer.valueOf(0)); [EOL]         assertEquals(Integer.valueOf(0), FieldUtils.readField(publiclyShadowedChild, "i")); [EOL]         FieldUtils.writeField(publiclyShadowedChild, "d", Double.valueOf(0.0)); [EOL]         assertEquals(Double.valueOf(0.0), FieldUtils.readField(publiclyShadowedChild, "d")); [EOL]  [EOL]         FieldUtils.writeField(privatelyShadowedChild, "s", "S"); [EOL]         assertEquals("S", FieldUtils.readField(privatelyShadowedChild, "s")); [EOL]         try { [EOL]             FieldUtils.writeField(privatelyShadowedChild, "b", Boolean.TRUE); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeField(privatelyShadowedChild, "i", Integer.valueOf(1)); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeField(privatelyShadowedChild, "d", Double.valueOf(1.0)); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testWriteDeclaredNamedField() throws Exception { [EOL]         try { [EOL]             FieldUtils.writeDeclaredField(publicChild, "s", "S"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeDeclaredField(publicChild, "b", Boolean.TRUE); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeDeclaredField(publicChild, "i", Integer.valueOf(1)); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeDeclaredField(publicChild, "d", Double.valueOf(1.0)); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]  [EOL]         FieldUtils.writeDeclaredField(publiclyShadowedChild, "s", "S"); [EOL]         assertEquals("S", FieldUtils.readDeclaredField(publiclyShadowedChild, "s")); [EOL]         FieldUtils.writeDeclaredField(publiclyShadowedChild, "b", Boolean.FALSE); [EOL]         assertEquals(Boolean.FALSE, FieldUtils.readDeclaredField(publiclyShadowedChild, "b")); [EOL]         FieldUtils.writeDeclaredField(publiclyShadowedChild, "i", Integer.valueOf(0)); [EOL]         assertEquals(Integer.valueOf(0), FieldUtils.readDeclaredField(publiclyShadowedChild, "i")); [EOL]         FieldUtils.writeDeclaredField(publiclyShadowedChild, "d", Double.valueOf(0.0)); [EOL]         assertEquals(Double.valueOf(0.0), FieldUtils.readDeclaredField(publiclyShadowedChild, "d")); [EOL]  [EOL]         try { [EOL]             FieldUtils.writeDeclaredField(privatelyShadowedChild, "s", "S"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeDeclaredField(privatelyShadowedChild, "b", Boolean.TRUE); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeDeclaredField(privatelyShadowedChild, "i", Integer.valueOf(1)); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeDeclaredField(privatelyShadowedChild, "d", Double.valueOf(1.0)); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testWriteDeclaredNamedField() throws Exception { [EOL]         try { [EOL]             FieldUtils.writeDeclaredField(publicChild, "s", "S"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeDeclaredField(publicChild, "b", Boolean.TRUE); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeDeclaredField(publicChild, "i", Integer.valueOf(1)); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeDeclaredField(publicChild, "d", Double.valueOf(1.0)); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]  [EOL]         FieldUtils.writeDeclaredField(publiclyShadowedChild, "s", "S"); [EOL]         assertEquals("S", FieldUtils.readDeclaredField(publiclyShadowedChild, "s")); [EOL]         FieldUtils.writeDeclaredField(publiclyShadowedChild, "b", Boolean.FALSE); [EOL]         assertEquals(Boolean.FALSE, FieldUtils.readDeclaredField(publiclyShadowedChild, "b")); [EOL]         FieldUtils.writeDeclaredField(publiclyShadowedChild, "i", Integer.valueOf(0)); [EOL]         assertEquals(Integer.valueOf(0), FieldUtils.readDeclaredField(publiclyShadowedChild, "i")); [EOL]         FieldUtils.writeDeclaredField(publiclyShadowedChild, "d", Double.valueOf(0.0)); [EOL]         assertEquals(Double.valueOf(0.0), FieldUtils.readDeclaredField(publiclyShadowedChild, "d")); [EOL]  [EOL]         try { [EOL]             FieldUtils.writeDeclaredField(privatelyShadowedChild, "s", "S"); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeDeclaredField(privatelyShadowedChild, "b", Boolean.TRUE); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeDeclaredField(privatelyShadowedChild, "i", Integer.valueOf(1)); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeDeclaredField(privatelyShadowedChild, "d", Double.valueOf(1.0)); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testWriteDeclaredNamedFieldForceAccess() throws Exception { [EOL]         try { [EOL]             FieldUtils.writeDeclaredField(publicChild, "s", "S", true); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeDeclaredField(publicChild, "b", Boolean.TRUE, true); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeDeclaredField(publicChild, "i", Integer.valueOf(1), true); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeDeclaredField(publicChild, "d", Double.valueOf(1.0), true); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]  [EOL]         FieldUtils.writeDeclaredField(publiclyShadowedChild, "s", "S", true); [EOL]         assertEquals("S", FieldUtils.readDeclaredField(publiclyShadowedChild, "s", true)); [EOL]         FieldUtils.writeDeclaredField(publiclyShadowedChild, "b", Boolean.FALSE, true); [EOL]         assertEquals(Boolean.FALSE, FieldUtils.readDeclaredField(publiclyShadowedChild, "b", true)); [EOL]         FieldUtils.writeDeclaredField(publiclyShadowedChild, "i", Integer.valueOf(0), true); [EOL]         assertEquals(Integer.valueOf(0), FieldUtils.readDeclaredField(publiclyShadowedChild, "i", true)); [EOL]         FieldUtils.writeDeclaredField(publiclyShadowedChild, "d", Double.valueOf(0.0), true); [EOL]         assertEquals(Double.valueOf(0.0), FieldUtils.readDeclaredField(publiclyShadowedChild, "d", true)); [EOL]  [EOL]         FieldUtils.writeDeclaredField(privatelyShadowedChild, "s", "S", true); [EOL]         assertEquals("S", FieldUtils.readDeclaredField(privatelyShadowedChild, "s", true)); [EOL]         FieldUtils.writeDeclaredField(privatelyShadowedChild, "b", Boolean.FALSE, true); [EOL]         assertEquals(Boolean.FALSE, FieldUtils.readDeclaredField(privatelyShadowedChild, "b", true)); [EOL]         FieldUtils.writeDeclaredField(privatelyShadowedChild, "i", Integer.valueOf(0), true); [EOL]         assertEquals(Integer.valueOf(0), FieldUtils.readDeclaredField(privatelyShadowedChild, "i", true)); [EOL]         FieldUtils.writeDeclaredField(privatelyShadowedChild, "d", Double.valueOf(0.0), true); [EOL]         assertEquals(Double.valueOf(0.0), FieldUtils.readDeclaredField(privatelyShadowedChild, "d", true)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testWriteDeclaredNamedFieldForceAccess() throws Exception { [EOL]         try { [EOL]             FieldUtils.writeDeclaredField(publicChild, "s", "S", true); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeDeclaredField(publicChild, "b", Boolean.TRUE, true); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeDeclaredField(publicChild, "i", Integer.valueOf(1), true); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeDeclaredField(publicChild, "d", Double.valueOf(1.0), true); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]  [EOL]         FieldUtils.writeDeclaredField(publiclyShadowedChild, "s", "S", true); [EOL]         assertEquals("S", FieldUtils.readDeclaredField(publiclyShadowedChild, "s", true)); [EOL]         FieldUtils.writeDeclaredField(publiclyShadowedChild, "b", Boolean.FALSE, true); [EOL]         assertEquals(Boolean.FALSE, FieldUtils.readDeclaredField(publiclyShadowedChild, "b", true)); [EOL]         FieldUtils.writeDeclaredField(publiclyShadowedChild, "i", Integer.valueOf(0), true); [EOL]         assertEquals(Integer.valueOf(0), FieldUtils.readDeclaredField(publiclyShadowedChild, "i", true)); [EOL]         FieldUtils.writeDeclaredField(publiclyShadowedChild, "d", Double.valueOf(0.0), true); [EOL]         assertEquals(Double.valueOf(0.0), FieldUtils.readDeclaredField(publiclyShadowedChild, "d", true)); [EOL]  [EOL]         FieldUtils.writeDeclaredField(privatelyShadowedChild, "s", "S", true); [EOL]         assertEquals("S", FieldUtils.readDeclaredField(privatelyShadowedChild, "s", true)); [EOL]         FieldUtils.writeDeclaredField(privatelyShadowedChild, "b", Boolean.FALSE, true); [EOL]         assertEquals(Boolean.FALSE, FieldUtils.readDeclaredField(privatelyShadowedChild, "b", true)); [EOL]         FieldUtils.writeDeclaredField(privatelyShadowedChild, "i", Integer.valueOf(0), true); [EOL]         assertEquals(Integer.valueOf(0), FieldUtils.readDeclaredField(privatelyShadowedChild, "i", true)); [EOL]         FieldUtils.writeDeclaredField(privatelyShadowedChild, "d", Double.valueOf(0.0), true); [EOL]         assertEquals(Double.valueOf(0.0), FieldUtils.readDeclaredField(privatelyShadowedChild, "d", true)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testWriteDeclaredNamedFieldForceAccess() throws Exception { [EOL]         try { [EOL]             FieldUtils.writeDeclaredField(publicChild, "s", "S", true); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeDeclaredField(publicChild, "b", Boolean.TRUE, true); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeDeclaredField(publicChild, "i", Integer.valueOf(1), true); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeDeclaredField(publicChild, "d", Double.valueOf(1.0), true); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]  [EOL]         FieldUtils.writeDeclaredField(publiclyShadowedChild, "s", "S", true); [EOL]         assertEquals("S", FieldUtils.readDeclaredField(publiclyShadowedChild, "s", true)); [EOL]         FieldUtils.writeDeclaredField(publiclyShadowedChild, "b", Boolean.FALSE, true); [EOL]         assertEquals(Boolean.FALSE, FieldUtils.readDeclaredField(publiclyShadowedChild, "b", true)); [EOL]         FieldUtils.writeDeclaredField(publiclyShadowedChild, "i", Integer.valueOf(0), true); [EOL]         assertEquals(Integer.valueOf(0), FieldUtils.readDeclaredField(publiclyShadowedChild, "i", true)); [EOL]         FieldUtils.writeDeclaredField(publiclyShadowedChild, "d", Double.valueOf(0.0), true); [EOL]         assertEquals(Double.valueOf(0.0), FieldUtils.readDeclaredField(publiclyShadowedChild, "d", true)); [EOL]  [EOL]         FieldUtils.writeDeclaredField(privatelyShadowedChild, "s", "S", true); [EOL]         assertEquals("S", FieldUtils.readDeclaredField(privatelyShadowedChild, "s", true)); [EOL]         FieldUtils.writeDeclaredField(privatelyShadowedChild, "b", Boolean.FALSE, true); [EOL]         assertEquals(Boolean.FALSE, FieldUtils.readDeclaredField(privatelyShadowedChild, "b", true)); [EOL]         FieldUtils.writeDeclaredField(privatelyShadowedChild, "i", Integer.valueOf(0), true); [EOL]         assertEquals(Integer.valueOf(0), FieldUtils.readDeclaredField(privatelyShadowedChild, "i", true)); [EOL]         FieldUtils.writeDeclaredField(privatelyShadowedChild, "d", Double.valueOf(0.0), true); [EOL]         assertEquals(Double.valueOf(0.0), FieldUtils.readDeclaredField(privatelyShadowedChild, "d", true)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testWriteDeclaredNamedFieldForceAccess() throws Exception { [EOL]         try { [EOL]             FieldUtils.writeDeclaredField(publicChild, "s", "S", true); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeDeclaredField(publicChild, "b", Boolean.TRUE, true); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeDeclaredField(publicChild, "i", Integer.valueOf(1), true); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeDeclaredField(publicChild, "d", Double.valueOf(1.0), true); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]  [EOL]         FieldUtils.writeDeclaredField(publiclyShadowedChild, "s", "S", true); [EOL]         assertEquals("S", FieldUtils.readDeclaredField(publiclyShadowedChild, "s", true)); [EOL]         FieldUtils.writeDeclaredField(publiclyShadowedChild, "b", Boolean.FALSE, true); [EOL]         assertEquals(Boolean.FALSE, FieldUtils.readDeclaredField(publiclyShadowedChild, "b", true)); [EOL]         FieldUtils.writeDeclaredField(publiclyShadowedChild, "i", Integer.valueOf(0), true); [EOL]         assertEquals(Integer.valueOf(0), FieldUtils.readDeclaredField(publiclyShadowedChild, "i", true)); [EOL]         FieldUtils.writeDeclaredField(publiclyShadowedChild, "d", Double.valueOf(0.0), true); [EOL]         assertEquals(Double.valueOf(0.0), FieldUtils.readDeclaredField(publiclyShadowedChild, "d", true)); [EOL]  [EOL]         FieldUtils.writeDeclaredField(privatelyShadowedChild, "s", "S", true); [EOL]         assertEquals("S", FieldUtils.readDeclaredField(privatelyShadowedChild, "s", true)); [EOL]         FieldUtils.writeDeclaredField(privatelyShadowedChild, "b", Boolean.FALSE, true); [EOL]         assertEquals(Boolean.FALSE, FieldUtils.readDeclaredField(privatelyShadowedChild, "b", true)); [EOL]         FieldUtils.writeDeclaredField(privatelyShadowedChild, "i", Integer.valueOf(0), true); [EOL]         assertEquals(Integer.valueOf(0), FieldUtils.readDeclaredField(privatelyShadowedChild, "i", true)); [EOL]         FieldUtils.writeDeclaredField(privatelyShadowedChild, "d", Double.valueOf(0.0), true); [EOL]         assertEquals(Double.valueOf(0.0), FieldUtils.readDeclaredField(privatelyShadowedChild, "d", true)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testWriteDeclaredNamedFieldForceAccess() throws Exception { [EOL]         try { [EOL]             FieldUtils.writeDeclaredField(publicChild, "s", "S", true); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeDeclaredField(publicChild, "b", Boolean.TRUE, true); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeDeclaredField(publicChild, "i", Integer.valueOf(1), true); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeDeclaredField(publicChild, "d", Double.valueOf(1.0), true); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]  [EOL]         FieldUtils.writeDeclaredField(publiclyShadowedChild, "s", "S", true); [EOL]         assertEquals("S", FieldUtils.readDeclaredField(publiclyShadowedChild, "s", true)); [EOL]         FieldUtils.writeDeclaredField(publiclyShadowedChild, "b", Boolean.FALSE, true); [EOL]         assertEquals(Boolean.FALSE, FieldUtils.readDeclaredField(publiclyShadowedChild, "b", true)); [EOL]         FieldUtils.writeDeclaredField(publiclyShadowedChild, "i", Integer.valueOf(0), true); [EOL]         assertEquals(Integer.valueOf(0), FieldUtils.readDeclaredField(publiclyShadowedChild, "i", true)); [EOL]         FieldUtils.writeDeclaredField(publiclyShadowedChild, "d", Double.valueOf(0.0), true); [EOL]         assertEquals(Double.valueOf(0.0), FieldUtils.readDeclaredField(publiclyShadowedChild, "d", true)); [EOL]  [EOL]         FieldUtils.writeDeclaredField(privatelyShadowedChild, "s", "S", true); [EOL]         assertEquals("S", FieldUtils.readDeclaredField(privatelyShadowedChild, "s", true)); [EOL]         FieldUtils.writeDeclaredField(privatelyShadowedChild, "b", Boolean.FALSE, true); [EOL]         assertEquals(Boolean.FALSE, FieldUtils.readDeclaredField(privatelyShadowedChild, "b", true)); [EOL]         FieldUtils.writeDeclaredField(privatelyShadowedChild, "i", Integer.valueOf(0), true); [EOL]         assertEquals(Integer.valueOf(0), FieldUtils.readDeclaredField(privatelyShadowedChild, "i", true)); [EOL]         FieldUtils.writeDeclaredField(privatelyShadowedChild, "d", Double.valueOf(0.0), true); [EOL]         assertEquals(Double.valueOf(0.0), FieldUtils.readDeclaredField(privatelyShadowedChild, "d", true)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testWriteDeclaredNamedFieldForceAccess() throws Exception { [EOL]         try { [EOL]             FieldUtils.writeDeclaredField(publicChild, "s", "S", true); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeDeclaredField(publicChild, "b", Boolean.TRUE, true); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeDeclaredField(publicChild, "i", Integer.valueOf(1), true); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeDeclaredField(publicChild, "d", Double.valueOf(1.0), true); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]  [EOL]         FieldUtils.writeDeclaredField(publiclyShadowedChild, "s", "S", true); [EOL]         assertEquals("S", FieldUtils.readDeclaredField(publiclyShadowedChild, "s", true)); [EOL]         FieldUtils.writeDeclaredField(publiclyShadowedChild, "b", Boolean.FALSE, true); [EOL]         assertEquals(Boolean.FALSE, FieldUtils.readDeclaredField(publiclyShadowedChild, "b", true)); [EOL]         FieldUtils.writeDeclaredField(publiclyShadowedChild, "i", Integer.valueOf(0), true); [EOL]         assertEquals(Integer.valueOf(0), FieldUtils.readDeclaredField(publiclyShadowedChild, "i", true)); [EOL]         FieldUtils.writeDeclaredField(publiclyShadowedChild, "d", Double.valueOf(0.0), true); [EOL]         assertEquals(Double.valueOf(0.0), FieldUtils.readDeclaredField(publiclyShadowedChild, "d", true)); [EOL]  [EOL]         FieldUtils.writeDeclaredField(privatelyShadowedChild, "s", "S", true); [EOL]         assertEquals("S", FieldUtils.readDeclaredField(privatelyShadowedChild, "s", true)); [EOL]         FieldUtils.writeDeclaredField(privatelyShadowedChild, "b", Boolean.FALSE, true); [EOL]         assertEquals(Boolean.FALSE, FieldUtils.readDeclaredField(privatelyShadowedChild, "b", true)); [EOL]         FieldUtils.writeDeclaredField(privatelyShadowedChild, "i", Integer.valueOf(0), true); [EOL]         assertEquals(Integer.valueOf(0), FieldUtils.readDeclaredField(privatelyShadowedChild, "i", true)); [EOL]         FieldUtils.writeDeclaredField(privatelyShadowedChild, "d", Double.valueOf(0.0), true); [EOL]         assertEquals(Double.valueOf(0.0), FieldUtils.readDeclaredField(privatelyShadowedChild, "d", true)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testWriteDeclaredNamedFieldForceAccess() throws Exception { [EOL]         try { [EOL]             FieldUtils.writeDeclaredField(publicChild, "s", "S", true); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeDeclaredField(publicChild, "b", Boolean.TRUE, true); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeDeclaredField(publicChild, "i", Integer.valueOf(1), true); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.writeDeclaredField(publicChild, "d", Double.valueOf(1.0), true); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]  [EOL]         FieldUtils.writeDeclaredField(publiclyShadowedChild, "s", "S", true); [EOL]         assertEquals("S", FieldUtils.readDeclaredField(publiclyShadowedChild, "s", true)); [EOL]         FieldUtils.writeDeclaredField(publiclyShadowedChild, "b", Boolean.FALSE, true); [EOL]         assertEquals(Boolean.FALSE, FieldUtils.readDeclaredField(publiclyShadowedChild, "b", true)); [EOL]         FieldUtils.writeDeclaredField(publiclyShadowedChild, "i", Integer.valueOf(0), true); [EOL]         assertEquals(Integer.valueOf(0), FieldUtils.readDeclaredField(publiclyShadowedChild, "i", true)); [EOL]         FieldUtils.writeDeclaredField(publiclyShadowedChild, "d", Double.valueOf(0.0), true); [EOL]         assertEquals(Double.valueOf(0.0), FieldUtils.readDeclaredField(publiclyShadowedChild, "d", true)); [EOL]  [EOL]         FieldUtils.writeDeclaredField(privatelyShadowedChild, "s", "S", true); [EOL]         assertEquals("S", FieldUtils.readDeclaredField(privatelyShadowedChild, "s", true)); [EOL]         FieldUtils.writeDeclaredField(privatelyShadowedChild, "b", Boolean.FALSE, true); [EOL]         assertEquals(Boolean.FALSE, FieldUtils.readDeclaredField(privatelyShadowedChild, "b", true)); [EOL]         FieldUtils.writeDeclaredField(privatelyShadowedChild, "i", Integer.valueOf(0), true); [EOL]         assertEquals(Integer.valueOf(0), FieldUtils.readDeclaredField(privatelyShadowedChild, "i", true)); [EOL]         FieldUtils.writeDeclaredField(privatelyShadowedChild, "d", Double.valueOf(0.0), true); [EOL]         assertEquals(Double.valueOf(0.0), FieldUtils.readDeclaredField(privatelyShadowedChild, "d", true)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSwapCase_String() { [EOL]         assertEquals(null, WordUtils.swapCase(null)); [EOL]         assertEquals("", WordUtils.swapCase("")); [EOL]         assertEquals("  ", WordUtils.swapCase("  ")); [EOL]          [EOL]         assertEquals("i", WordUtils.swapCase("I") ); [EOL]         assertEquals("I", WordUtils.swapCase("i") ); [EOL]         assertEquals("I AM HERE 123", WordUtils.swapCase("i am here 123") ); [EOL]         assertEquals("i aM hERE 123", WordUtils.swapCase("I Am Here 123") ); [EOL]         assertEquals("I AM here 123", WordUtils.swapCase("i am HERE 123") ); [EOL]         assertEquals("i am here 123", WordUtils.swapCase("I AM HERE 123") ); [EOL]  [EOL]         final String test = "This String contains a TitleCase character: \u01C8"; [EOL]         final String expect = "tHIS sTRING CONTAINS A tITLEcASE CHARACTER: \u01C9"; [EOL]         assertEquals(expect, WordUtils.swapCase(test)); [EOL]     } [EOL]  [EOL] } [EOL]
@Test [EOL]     public void testSwapCase_String() { [EOL]         assertEquals(null, WordUtils.swapCase(null)); [EOL]         assertEquals("", WordUtils.swapCase("")); [EOL]         assertEquals("  ", WordUtils.swapCase("  ")); [EOL]          [EOL]         assertEquals("i", WordUtils.swapCase("I") ); [EOL]         assertEquals("I", WordUtils.swapCase("i") ); [EOL]         assertEquals("I AM HERE 123", WordUtils.swapCase("i am here 123") ); [EOL]         assertEquals("i aM hERE 123", WordUtils.swapCase("I Am Here 123") ); [EOL]         assertEquals("I AM here 123", WordUtils.swapCase("i am HERE 123") ); [EOL]         assertEquals("i am here 123", WordUtils.swapCase("I AM HERE 123") ); [EOL]  [EOL]         final String test = "This String contains a TitleCase character: \u01C8"; [EOL]         final String expect = "tHIS sTRING CONTAINS A tITLEcASE CHARACTER: \u01C9"; [EOL]         assertEquals(expect, WordUtils.swapCase(test)); [EOL]     } [EOL]  [EOL] } [EOL]
@Test [EOL]     public void testIsSameInstant_Cal() { [EOL]         final GregorianCalendar cal1 = new GregorianCalendar(TimeZone.getTimeZone("GMT+1")); [EOL]         final GregorianCalendar cal2 = new GregorianCalendar(TimeZone.getTimeZone("GMT-1")); [EOL]         cal1.set(2004, 6, 9, 13, 45, 0); [EOL]         cal1.set(Calendar.MILLISECOND, 0); [EOL]         cal2.set(2004, 6, 9, 13, 45, 0); [EOL]         cal2.set(Calendar.MILLISECOND, 0); [EOL]         assertFalse(DateUtils.isSameInstant(cal1, cal2)); [EOL]          [EOL]         cal2.set(2004, 6, 9, 11, 45, 0); [EOL]         assertTrue(DateUtils.isSameInstant(cal1, cal2)); [EOL]         try { [EOL]             DateUtils.isSameInstant((Calendar) null, (Calendar) null); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]     } [EOL]      [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testRoundMonth() throws Exception { [EOL]         final int calendarField = Calendar.MONTH; [EOL]         Date roundedUpDate, roundedDownDate, lastRoundedDownDate; [EOL]         Date minDate, maxDate; [EOL]          [EOL]         //month with 28 days [EOL]         roundedUpDate = dateTimeParser.parse("March 1, 2007 0:00:00.000"); [EOL]         roundedDownDate = dateTimeParser.parse("February 1, 2007 0:00:00.000"); [EOL]         lastRoundedDownDate = dateTimeParser.parse("February 14, 2007 23:59:59.999"); [EOL]         baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate,  calendarField); [EOL]  [EOL]         //month with 29 days [EOL]         roundedUpDate = dateTimeParser.parse("March 1, 2008 0:00:00.000"); [EOL]         roundedDownDate = dateTimeParser.parse("February 1, 2008 0:00:00.000"); [EOL]         lastRoundedDownDate = dateTimeParser.parse("February 15, 2008 23:59:59.999"); [EOL]         baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate,  calendarField); [EOL]          [EOL]         //month with 30 days [EOL]         roundedUpDate = dateTimeParser.parse("May 1, 2008 0:00:00.000"); [EOL]         roundedDownDate = dateTimeParser.parse("April 1, 2008 0:00:00.000"); [EOL]         lastRoundedDownDate = dateTimeParser.parse("April 15, 2008 23:59:59.999"); [EOL]         baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate,  calendarField); [EOL]          [EOL]         //month with 31 days [EOL]         roundedUpDate = dateTimeParser.parse("June 1, 2008 0:00:00.000"); [EOL]         roundedDownDate = dateTimeParser.parse("May 1, 2008 0:00:00.000"); [EOL]         lastRoundedDownDate = dateTimeParser.parse("May 16, 2008 23:59:59.999"); [EOL]         baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate,  calendarField); [EOL]          [EOL]         //round to January 1 [EOL]         minDate = dateTimeParser.parse("December 17, 2007 00:00:00.000"); [EOL]         maxDate = dateTimeParser.parse("January 16, 2008 23:59:59.999"); [EOL]         roundToJanuaryFirst(minDate, maxDate, calendarField); [EOL]     } [EOL]      [EOL]     /** [EOL]      * Tests DateUtils.round()-method with DateUtils.SEMI_MONTH [EOL]      * Includes rounding months with 28, 29, 30 and 31 days, each with first and second half  [EOL]      * Includes rounding to January 1 [EOL]      *       [EOL]      * @throws Exception [EOL]      * @since 3.0 [EOL]      */ [EOL]
@Test [EOL]     public void testCeil() throws Exception { [EOL]         // test javadoc [EOL]         assertEquals("ceiling javadoc-1 failed", [EOL]                 dateTimeParser.parse("March 28, 2002 14:00:00.000"), [EOL]                 DateUtils.ceiling( [EOL]                     dateTimeParser.parse("March 28, 2002 13:45:01.231"), [EOL]                 Calendar.HOUR)); [EOL]         assertEquals("ceiling javadoc-2 failed", [EOL]                 dateTimeParser.parse("April 1, 2002 00:00:00.000"), [EOL]                 DateUtils.ceiling( [EOL]                     dateTimeParser.parse("March 28, 2002 13:45:01.231"), [EOL]                 Calendar.MONTH)); [EOL]  [EOL]         // tests public static Date ceiling(Date date, int field) [EOL]         assertEquals("ceiling year-1 failed", [EOL]                 dateParser.parse("January 1, 2003"), [EOL]                 DateUtils.ceiling(date1, Calendar.YEAR)); [EOL]         assertEquals("ceiling year-2 failed", [EOL]                 dateParser.parse("January 1, 2002"), [EOL]                 DateUtils.ceiling(date2, Calendar.YEAR)); [EOL]         assertEquals("ceiling month-1 failed", [EOL]                 dateParser.parse("March 1, 2002"), [EOL]                 DateUtils.ceiling(date1, Calendar.MONTH)); [EOL]         assertEquals("ceiling month-2 failed", [EOL]                 dateParser.parse("December 1, 2001"), [EOL]                 DateUtils.ceiling(date2, Calendar.MONTH)); [EOL]         assertEquals("ceiling semimonth-1 failed", [EOL]                 dateParser.parse("February 16, 2002"), [EOL]                 DateUtils.ceiling(date1, DateUtils.SEMI_MONTH)); [EOL]         assertEquals("ceiling semimonth-2 failed", [EOL]                 dateParser.parse("December 1, 2001"), [EOL]                 DateUtils.ceiling(date2, DateUtils.SEMI_MONTH)); [EOL]         assertEquals("ceiling date-1 failed", [EOL]                 dateParser.parse("February 13, 2002"), [EOL]                 DateUtils.ceiling(date1, Calendar.DATE)); [EOL]         assertEquals("ceiling date-2 failed", [EOL]                 dateParser.parse("November 19, 2001"), [EOL]                 DateUtils.ceiling(date2, Calendar.DATE)); [EOL]         assertEquals("ceiling hour-1 failed", [EOL]                 dateTimeParser.parse("February 12, 2002 13:00:00.000"), [EOL]                 DateUtils.ceiling(date1, Calendar.HOUR)); [EOL]         assertEquals("ceiling hour-2 failed", [EOL]                 dateTimeParser.parse("November 18, 2001 2:00:00.000"), [EOL]                 DateUtils.ceiling(date2, Calendar.HOUR)); [EOL]         assertEquals("ceiling minute-1 failed", [EOL]                 dateTimeParser.parse("February 12, 2002 12:35:00.000"), [EOL]                 DateUtils.ceiling(date1, Calendar.MINUTE)); [EOL]         assertEquals("ceiling minute-2 failed", [EOL]                 dateTimeParser.parse("November 18, 2001 1:24:00.000"), [EOL]                 DateUtils.ceiling(date2, Calendar.MINUTE)); [EOL]         assertEquals("ceiling second-1 failed", [EOL]                 dateTimeParser.parse("February 12, 2002 12:34:57.000"), [EOL]                 DateUtils.ceiling(date1, Calendar.SECOND)); [EOL]         assertEquals("ceiling second-2 failed", [EOL]                 dateTimeParser.parse("November 18, 2001 1:23:12.000"), [EOL]                 DateUtils.ceiling(date2, Calendar.SECOND)); [EOL]         assertEquals("ceiling ampm-1 failed", [EOL]                 dateTimeParser.parse("February 3, 2002 12:00:00.000"), [EOL]                 DateUtils.ceiling(dateAmPm1, Calendar.AM_PM)); [EOL]         assertEquals("ceiling ampm-2 failed", [EOL]                 dateTimeParser.parse("February 3, 2002 12:00:00.000"), [EOL]                 DateUtils.ceiling(dateAmPm2, Calendar.AM_PM)); [EOL]         assertEquals("ceiling ampm-3 failed", [EOL]                 dateTimeParser.parse("February 4, 2002 00:00:00.000"), [EOL]                 DateUtils.ceiling(dateAmPm3, Calendar.AM_PM)); [EOL]         assertEquals("ceiling ampm-4 failed", [EOL]                 dateTimeParser.parse("February 4, 2002 00:00:00.000"), [EOL]                 DateUtils.ceiling(dateAmPm4, Calendar.AM_PM)); [EOL]          [EOL]      // tests public static Date ceiling(Object date, int field) [EOL]         assertEquals("ceiling year-1 failed", [EOL]                 dateParser.parse("January 1, 2003"), [EOL]                 DateUtils.ceiling((Object) date1, Calendar.YEAR)); [EOL]         assertEquals("ceiling year-2 failed", [EOL]                 dateParser.parse("January 1, 2002"), [EOL]                 DateUtils.ceiling((Object) date2, Calendar.YEAR)); [EOL]         assertEquals("ceiling month-1 failed", [EOL]                 dateParser.parse("March 1, 2002"), [EOL]                 DateUtils.ceiling((Object) date1, Calendar.MONTH)); [EOL]         assertEquals("ceiling month-2 failed", [EOL]                 dateParser.parse("December 1, 2001"), [EOL]                 DateUtils.ceiling((Object) date2, Calendar.MONTH)); [EOL]         assertEquals("ceiling semimonth-1 failed", [EOL]                 dateParser.parse("February 16, 2002"), [EOL]                 DateUtils.ceiling((Object) date1, DateUtils.SEMI_MONTH)); [EOL]         assertEquals("ceiling semimonth-2 failed", [EOL]                 dateParser.parse("December 1, 2001"), [EOL]                 DateUtils.ceiling((Object) date2, DateUtils.SEMI_MONTH)); [EOL]         assertEquals("ceiling date-1 failed", [EOL]                 dateParser.parse("February 13, 2002"), [EOL]                 DateUtils.ceiling((Object) date1, Calendar.DATE)); [EOL]         assertEquals("ceiling date-2 failed", [EOL]                 dateParser.parse("November 19, 2001"), [EOL]                 DateUtils.ceiling((Object) date2, Calendar.DATE)); [EOL]         assertEquals("ceiling hour-1 failed", [EOL]                 dateTimeParser.parse("February 12, 2002 13:00:00.000"), [EOL]                 DateUtils.ceiling((Object) date1, Calendar.HOUR)); [EOL]         assertEquals("ceiling hour-2 failed", [EOL]                 dateTimeParser.parse("November 18, 2001 2:00:00.000"), [EOL]                 DateUtils.ceiling((Object) date2, Calendar.HOUR)); [EOL]         assertEquals("ceiling minute-1 failed", [EOL]                 dateTimeParser.parse("February 12, 2002 12:35:00.000"), [EOL]                 DateUtils.ceiling((Object) date1, Calendar.MINUTE)); [EOL]         assertEquals("ceiling minute-2 failed", [EOL]                 dateTimeParser.parse("November 18, 2001 1:24:00.000"), [EOL]                 DateUtils.ceiling((Object) date2, Calendar.MINUTE)); [EOL]         assertEquals("ceiling second-1 failed", [EOL]                 dateTimeParser.parse("February 12, 2002 12:34:57.000"), [EOL]                 DateUtils.ceiling((Object) date1, Calendar.SECOND)); [EOL]         assertEquals("ceiling second-2 failed", [EOL]                 dateTimeParser.parse("November 18, 2001 1:23:12.000"), [EOL]                 DateUtils.ceiling((Object) date2, Calendar.SECOND)); [EOL]         assertEquals("ceiling ampm-1 failed", [EOL]                 dateTimeParser.parse("February 3, 2002 12:00:00.000"), [EOL]                 DateUtils.ceiling((Object) dateAmPm1, Calendar.AM_PM)); [EOL]         assertEquals("ceiling ampm-2 failed", [EOL]                 dateTimeParser.parse("February 3, 2002 12:00:00.000"), [EOL]                 DateUtils.ceiling((Object) dateAmPm2, Calendar.AM_PM)); [EOL]         assertEquals("ceiling ampm-3 failed", [EOL]                 dateTimeParser.parse("February 4, 2002 00:00:00.000"), [EOL]                 DateUtils.ceiling((Object) dateAmPm3, Calendar.AM_PM)); [EOL]         assertEquals("ceiling ampm-4 failed", [EOL]                 dateTimeParser.parse("February 4, 2002 00:00:00.000"), [EOL]                 DateUtils.ceiling((Object) dateAmPm4, Calendar.AM_PM)); [EOL]          [EOL]         assertEquals("ceiling calendar second-1 failed", [EOL]                 dateTimeParser.parse("February 12, 2002 12:34:57.000"), [EOL]                 DateUtils.ceiling((Object) cal1, Calendar.SECOND)); [EOL]         assertEquals("ceiling calendar second-2 failed", [EOL]                 dateTimeParser.parse("November 18, 2001 1:23:12.000"), [EOL]                 DateUtils.ceiling((Object) cal2, Calendar.SECOND)); [EOL]          [EOL]         assertEquals("ceiling ampm-1 failed", [EOL]                 dateTimeParser.parse("February 3, 2002 12:00:00.000"), [EOL]                 DateUtils.ceiling((Object) calAmPm1, Calendar.AM_PM)); [EOL]         assertEquals("ceiling ampm-2 failed", [EOL]                 dateTimeParser.parse("February 3, 2002 12:00:00.000"), [EOL]                 DateUtils.ceiling((Object) calAmPm2, Calendar.AM_PM)); [EOL]         assertEquals("ceiling ampm-3 failed", [EOL]                 dateTimeParser.parse("February 4, 2002 00:00:00.000"), [EOL]                 DateUtils.ceiling((Object) calAmPm3, Calendar.AM_PM)); [EOL]         assertEquals("ceiling ampm-4 failed", [EOL]                 dateTimeParser.parse("February 4, 2002 00:00:00.000"), [EOL]                 DateUtils.ceiling((Object) calAmPm4, Calendar.AM_PM)); [EOL]  [EOL]         try { [EOL]             DateUtils.ceiling((Date) null, Calendar.SECOND); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             DateUtils.ceiling((Calendar) null, Calendar.SECOND); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             DateUtils.ceiling((Object) null, Calendar.SECOND); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             DateUtils.ceiling("", Calendar.SECOND); [EOL]             fail(); [EOL]         } catch (final ClassCastException ex) {} [EOL]         try { [EOL]             DateUtils.ceiling(date1, -9999); [EOL]             fail(); [EOL]         } catch(final IllegalArgumentException ex) {} [EOL]  [EOL]          [EOL]         // Fix for http://issues.apache.org/bugzilla/show_bug.cgi?id=25560 [EOL]         // Test ceiling across the beginning of daylight saving time [EOL]         TimeZone.setDefault(zone); [EOL]         dateTimeParser.setTimeZone(zone); [EOL]  [EOL]         assertEquals("ceiling MET date across DST change-over", [EOL]                 dateTimeParser.parse("March 31, 2003 00:00:00.000"), [EOL]                 DateUtils.ceiling(date4, Calendar.DATE)); [EOL]         assertEquals("ceiling MET date across DST change-over", [EOL]                 dateTimeParser.parse("March 31, 2003 00:00:00.000"), [EOL]                 DateUtils.ceiling((Object) cal4, Calendar.DATE)); [EOL]         assertEquals("ceiling MET date across DST change-over", [EOL]                 dateTimeParser.parse("March 31, 2003 00:00:00.000"), [EOL]                 DateUtils.ceiling(date5, Calendar.DATE)); [EOL]         assertEquals("ceiling MET date across DST change-over", [EOL]                 dateTimeParser.parse("March 31, 2003 00:00:00.000"), [EOL]                 DateUtils.ceiling((Object) cal5, Calendar.DATE)); [EOL]         assertEquals("ceiling MET date across DST change-over", [EOL]                 dateTimeParser.parse("March 31, 2003 00:00:00.000"), [EOL]                 DateUtils.ceiling(date6, Calendar.DATE)); [EOL]         assertEquals("ceiling MET date across DST change-over", [EOL]                 dateTimeParser.parse("March 31, 2003 00:00:00.000"), [EOL]                 DateUtils.ceiling((Object) cal6, Calendar.DATE)); [EOL]         assertEquals("ceiling MET date across DST change-over", [EOL]                 dateTimeParser.parse("March 31, 2003 00:00:00.000"), [EOL]                 DateUtils.ceiling(date7, Calendar.DATE)); [EOL]         assertEquals("ceiling MET date across DST change-over", [EOL]                 dateTimeParser.parse("March 31, 2003 00:00:00.000"), [EOL]                 DateUtils.ceiling((Object) cal7, Calendar.DATE)); [EOL]          [EOL]         assertEquals("ceiling MET date across DST change-over", [EOL]                 dateTimeParser.parse("March 30, 2003 03:00:00.000"), [EOL]                 DateUtils.ceiling(date4, Calendar.HOUR_OF_DAY)); [EOL]         assertEquals("ceiling MET date across DST change-over", [EOL]                 dateTimeParser.parse("March 30, 2003 03:00:00.000"), [EOL]                 DateUtils.ceiling((Object) cal4, Calendar.HOUR_OF_DAY)); [EOL]         if (SystemUtils.isJavaVersionAtLeast(JAVA_1_4)) { [EOL]             assertEquals("ceiling MET date across DST change-over", [EOL]                     dateTimeParser.parse("March 30, 2003 03:00:00.000"), [EOL]                     DateUtils.ceiling(date5, Calendar.HOUR_OF_DAY)); [EOL]             assertEquals("ceiling MET date across DST change-over", [EOL]                     dateTimeParser.parse("March 30, 2003 03:00:00.000"), [EOL]                     DateUtils.ceiling((Object) cal5, Calendar.HOUR_OF_DAY)); [EOL]             assertEquals("ceiling MET date across DST change-over", [EOL]                     dateTimeParser.parse("March 30, 2003 04:00:00.000"), [EOL]                     DateUtils.ceiling(date6, Calendar.HOUR_OF_DAY)); [EOL]             assertEquals("ceiling MET date across DST change-over", [EOL]                     dateTimeParser.parse("March 30, 2003 04:00:00.000"), [EOL]                     DateUtils.ceiling((Object) cal6, Calendar.HOUR_OF_DAY)); [EOL]             assertEquals("ceiling MET date across DST change-over", [EOL]                     dateTimeParser.parse("March 30, 2003 04:00:00.000"), [EOL]                     DateUtils.ceiling(date7, Calendar.HOUR_OF_DAY)); [EOL]             assertEquals("ceiling MET date across DST change-over", [EOL]                     dateTimeParser.parse("March 30, 2003 04:00:00.000"), [EOL]                     DateUtils.ceiling((Object) cal7, Calendar.HOUR_OF_DAY)); [EOL]         } else { [EOL]             this.warn("WARNING: Some date ceiling tests not run since the current version is " + SystemUtils.JAVA_SPECIFICATION_VERSION); [EOL]         } [EOL]         TimeZone.setDefault(defaultZone); [EOL]         dateTimeParser.setTimeZone(defaultZone); [EOL]          [EOL]      // Bug 31395, large dates [EOL]         final Date endOfTime = new Date(Long.MAX_VALUE); // fyi: Sun Aug 17 07:12:55 CET 292278994 -- 807 millis [EOL]         final GregorianCalendar endCal = new GregorianCalendar(); [EOL]         endCal.setTime(endOfTime); [EOL]         try { [EOL]             DateUtils.ceiling(endCal, Calendar.DATE); [EOL]             fail(); [EOL]         } catch (final ArithmeticException ex) {} [EOL]         endCal.set(Calendar.YEAR, 280000001); [EOL]         try { [EOL]             DateUtils.ceiling(endCal, Calendar.DATE); [EOL]             fail(); [EOL]         } catch (final ArithmeticException ex) {} [EOL]         endCal.set(Calendar.YEAR, 280000000); [EOL]         final Calendar cal = DateUtils.ceiling(endCal, Calendar.DATE); [EOL]         assertEquals(0, cal.get(Calendar.HOUR)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the iterator exceptions [EOL]      */ [EOL]
@Test [EOL]     public void testRoundMinute() throws Exception { [EOL]         final int calendarField = Calendar.MINUTE; [EOL]         Date roundedUpDate, roundedDownDate, lastRoundedDownDate; [EOL]         Date minDate, maxDate; [EOL]  [EOL]         roundedUpDate = dateTimeParser.parse("June 1, 2008 8:16:00.000"); [EOL]         roundedDownDate = targetMinuteDate; [EOL]         lastRoundedDownDate = dateTimeParser.parse("June 1, 2008 8:15:29.999"); [EOL]         baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate,  calendarField); [EOL]          [EOL]         //round to January 1 [EOL]         minDate = dateTimeParser.parse("December 31, 2007 23:59:30.000"); [EOL]         maxDate = dateTimeParser.parse("January 1, 2008 0:00:29.999"); [EOL]         roundToJanuaryFirst(minDate, maxDate, calendarField); [EOL]     } [EOL]      [EOL]     /** [EOL]      * Tests DateUtils.round()-method with Calendar.SECOND [EOL]      * Includes rounding the extremes of one second  [EOL]      * Includes rounding to January 1 [EOL]      *  [EOL]      * @throws Exception [EOL]      * @since 3.0 [EOL]      */ [EOL]
@Test [EOL]     public void testRoundSemiMonth() throws Exception { [EOL]         final int calendarField = DateUtils.SEMI_MONTH; [EOL]         Date roundedUpDate, roundedDownDate, lastRoundedDownDate; [EOL]         Date minDate, maxDate; [EOL]          [EOL]         //month with 28 days (1) [EOL]         roundedUpDate = dateTimeParser.parse("February 16, 2007 0:00:00.000"); [EOL]         roundedDownDate = dateTimeParser.parse("February 1, 2007 0:00:00.000"); [EOL]         lastRoundedDownDate = dateTimeParser.parse("February 8, 2007 23:59:59.999"); [EOL]         baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate,  calendarField); [EOL]  [EOL]         //month with 28 days (2) [EOL]         roundedUpDate = dateTimeParser.parse("March 1, 2007 0:00:00.000"); [EOL]         roundedDownDate = dateTimeParser.parse("February 16, 2007 0:00:00.000"); [EOL]         lastRoundedDownDate = dateTimeParser.parse("February 23, 2007 23:59:59.999"); [EOL]         baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate,  calendarField); [EOL]  [EOL]         //month with 29 days (1) [EOL]         roundedUpDate = dateTimeParser.parse("February 16, 2008 0:00:00.000"); [EOL]         roundedDownDate = dateTimeParser.parse("February 1, 2008 0:00:00.000"); [EOL]         lastRoundedDownDate = dateTimeParser.parse("February 8, 2008 23:59:59.999"); [EOL]         baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate,  calendarField); [EOL]          [EOL]         //month with 29 days (2) [EOL]         roundedUpDate = dateTimeParser.parse("March 1, 2008 0:00:00.000"); [EOL]         roundedDownDate = dateTimeParser.parse("February 16, 2008 0:00:00.000"); [EOL]         lastRoundedDownDate = dateTimeParser.parse("February 23, 2008 23:59:59.999"); [EOL]         baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate,  calendarField); [EOL]  [EOL]         //month with 30 days (1) [EOL]         roundedUpDate = dateTimeParser.parse("April 16, 2008 0:00:00.000"); [EOL]         roundedDownDate = dateTimeParser.parse("April 1, 2008 0:00:00.000"); [EOL]         lastRoundedDownDate = dateTimeParser.parse("April 8, 2008 23:59:59.999"); [EOL]         baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate,  calendarField); [EOL]  [EOL]         //month with 30 days (2) [EOL]         roundedUpDate = dateTimeParser.parse("May 1, 2008 0:00:00.000"); [EOL]         roundedDownDate = dateTimeParser.parse("April 16, 2008 0:00:00.000"); [EOL]         lastRoundedDownDate = dateTimeParser.parse("April 23, 2008 23:59:59.999"); [EOL]         baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate,  calendarField); [EOL]          [EOL]         //month with 31 days (1) [EOL]         roundedUpDate = dateTimeParser.parse("May 16, 2008 0:00:00.000"); [EOL]         roundedDownDate = dateTimeParser.parse("May 1, 2008 0:00:00.000"); [EOL]         lastRoundedDownDate = dateTimeParser.parse("May 8, 2008 23:59:59.999"); [EOL]         baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate,  calendarField); [EOL]  [EOL]         //month with 31 days (2) [EOL]         roundedUpDate = dateTimeParser.parse("June 1, 2008 0:00:00.000"); [EOL]         roundedDownDate = dateTimeParser.parse("May 16, 2008 0:00:00.000"); [EOL]         lastRoundedDownDate = dateTimeParser.parse("May 23, 2008 23:59:59.999"); [EOL]         baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate,  calendarField); [EOL]          [EOL]         //round to January 1 [EOL]         minDate = dateTimeParser.parse("December 24, 2007 00:00:00.000"); [EOL]         maxDate = dateTimeParser.parse("January 8, 2008 23:59:59.999"); [EOL]         roundToJanuaryFirst(minDate, maxDate, calendarField); [EOL]     } [EOL]      [EOL]     /** [EOL]      * Tests DateUtils.round()-method with Calendar.DATE [EOL]      * Includes rounding the extremes of one day  [EOL]      * Includes rounding to January 1 [EOL]      *  [EOL]      * @throws Exception [EOL]      * @since 3.0 [EOL]      */ [EOL]
@Test [EOL]     public void testRoundAmPm() throws Exception { [EOL]         final int calendarField = Calendar.AM_PM; [EOL]         Date roundedUpDate, roundedDownDate, lastRoundedDownDate; [EOL]         Date minDate, maxDate; [EOL]  [EOL]         //AM [EOL]         roundedUpDate = dateTimeParser.parse("June 1, 2008 12:00:00.000"); [EOL]         roundedDownDate = targetAmDate; [EOL]         lastRoundedDownDate = dateTimeParser.parse("June 1, 2008 5:59:59.999"); [EOL]         baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate,  calendarField); [EOL]  [EOL]         //PM [EOL]         roundedUpDate = dateTimeParser.parse("June 2, 2008 0:00:00.000"); [EOL]         roundedDownDate = targetPmDate; [EOL]         lastRoundedDownDate = dateTimeParser.parse("June 1, 2008 17:59:59.999"); [EOL]         baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate,  calendarField); [EOL]  [EOL]         //round to January 1 [EOL]         minDate = dateTimeParser.parse("December 31, 2007 18:00:00.000"); [EOL]         maxDate = dateTimeParser.parse("January 1, 2008 5:59:59.999"); [EOL]         roundToJanuaryFirst(minDate, maxDate, calendarField); [EOL]     } [EOL]      [EOL]     /** [EOL]      * Tests DateUtils.round()-method with Calendar.HOUR_OF_DAY [EOL]      * Includes rounding the extremes of one hour  [EOL]      * Includes rounding to January 1 [EOL]      *  [EOL]      * @throws Exception [EOL]      * @since 3.0 [EOL]      */ [EOL]
@Test [EOL]     public void testRoundAmPm() throws Exception { [EOL]         final int calendarField = Calendar.AM_PM; [EOL]         Date roundedUpDate, roundedDownDate, lastRoundedDownDate; [EOL]         Date minDate, maxDate; [EOL]  [EOL]         //AM [EOL]         roundedUpDate = dateTimeParser.parse("June 1, 2008 12:00:00.000"); [EOL]         roundedDownDate = targetAmDate; [EOL]         lastRoundedDownDate = dateTimeParser.parse("June 1, 2008 5:59:59.999"); [EOL]         baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate,  calendarField); [EOL]  [EOL]         //PM [EOL]         roundedUpDate = dateTimeParser.parse("June 2, 2008 0:00:00.000"); [EOL]         roundedDownDate = targetPmDate; [EOL]         lastRoundedDownDate = dateTimeParser.parse("June 1, 2008 17:59:59.999"); [EOL]         baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate,  calendarField); [EOL]  [EOL]         //round to January 1 [EOL]         minDate = dateTimeParser.parse("December 31, 2007 18:00:00.000"); [EOL]         maxDate = dateTimeParser.parse("January 1, 2008 5:59:59.999"); [EOL]         roundToJanuaryFirst(minDate, maxDate, calendarField); [EOL]     } [EOL]      [EOL]     /** [EOL]      * Tests DateUtils.round()-method with Calendar.HOUR_OF_DAY [EOL]      * Includes rounding the extremes of one hour  [EOL]      * Includes rounding to January 1 [EOL]      *  [EOL]      * @throws Exception [EOL]      * @since 3.0 [EOL]      */ [EOL]
@Test [EOL]     public void testRoundAmPm() throws Exception { [EOL]         final int calendarField = Calendar.AM_PM; [EOL]         Date roundedUpDate, roundedDownDate, lastRoundedDownDate; [EOL]         Date minDate, maxDate; [EOL]  [EOL]         //AM [EOL]         roundedUpDate = dateTimeParser.parse("June 1, 2008 12:00:00.000"); [EOL]         roundedDownDate = targetAmDate; [EOL]         lastRoundedDownDate = dateTimeParser.parse("June 1, 2008 5:59:59.999"); [EOL]         baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate,  calendarField); [EOL]  [EOL]         //PM [EOL]         roundedUpDate = dateTimeParser.parse("June 2, 2008 0:00:00.000"); [EOL]         roundedDownDate = targetPmDate; [EOL]         lastRoundedDownDate = dateTimeParser.parse("June 1, 2008 17:59:59.999"); [EOL]         baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate,  calendarField); [EOL]  [EOL]         //round to January 1 [EOL]         minDate = dateTimeParser.parse("December 31, 2007 18:00:00.000"); [EOL]         maxDate = dateTimeParser.parse("January 1, 2008 5:59:59.999"); [EOL]         roundToJanuaryFirst(minDate, maxDate, calendarField); [EOL]     } [EOL]      [EOL]     /** [EOL]      * Tests DateUtils.round()-method with Calendar.HOUR_OF_DAY [EOL]      * Includes rounding the extremes of one hour  [EOL]      * Includes rounding to January 1 [EOL]      *  [EOL]      * @throws Exception [EOL]      * @since 3.0 [EOL]      */ [EOL]
@Test [EOL]     public void testRoundAmPm() throws Exception { [EOL]         final int calendarField = Calendar.AM_PM; [EOL]         Date roundedUpDate, roundedDownDate, lastRoundedDownDate; [EOL]         Date minDate, maxDate; [EOL]  [EOL]         //AM [EOL]         roundedUpDate = dateTimeParser.parse("June 1, 2008 12:00:00.000"); [EOL]         roundedDownDate = targetAmDate; [EOL]         lastRoundedDownDate = dateTimeParser.parse("June 1, 2008 5:59:59.999"); [EOL]         baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate,  calendarField); [EOL]  [EOL]         //PM [EOL]         roundedUpDate = dateTimeParser.parse("June 2, 2008 0:00:00.000"); [EOL]         roundedDownDate = targetPmDate; [EOL]         lastRoundedDownDate = dateTimeParser.parse("June 1, 2008 17:59:59.999"); [EOL]         baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate,  calendarField); [EOL]  [EOL]         //round to January 1 [EOL]         minDate = dateTimeParser.parse("December 31, 2007 18:00:00.000"); [EOL]         maxDate = dateTimeParser.parse("January 1, 2008 5:59:59.999"); [EOL]         roundToJanuaryFirst(minDate, maxDate, calendarField); [EOL]     } [EOL]      [EOL]     /** [EOL]      * Tests DateUtils.round()-method with Calendar.HOUR_OF_DAY [EOL]      * Includes rounding the extremes of one hour  [EOL]      * Includes rounding to January 1 [EOL]      *  [EOL]      * @throws Exception [EOL]      * @since 3.0 [EOL]      */ [EOL]
@Test [EOL]     public void testTruncate() throws Exception { [EOL]         // tests public static Date truncate(Date date, int field) [EOL]         assertEquals("truncate year-1 failed", [EOL]                 dateParser.parse("January 1, 2002"), [EOL]                 DateUtils.truncate(date1, Calendar.YEAR)); [EOL]         assertEquals("truncate year-2 failed", [EOL]                 dateParser.parse("January 1, 2001"), [EOL]                 DateUtils.truncate(date2, Calendar.YEAR)); [EOL]         assertEquals("truncate month-1 failed", [EOL]                 dateParser.parse("February 1, 2002"), [EOL]                 DateUtils.truncate(date1, Calendar.MONTH)); [EOL]         assertEquals("truncate month-2 failed", [EOL]                 dateParser.parse("November 1, 2001"), [EOL]                 DateUtils.truncate(date2, Calendar.MONTH)); [EOL]         assertEquals("truncate semimonth-1 failed", [EOL]                 dateParser.parse("February 1, 2002"), [EOL]                 DateUtils.truncate(date1, DateUtils.SEMI_MONTH)); [EOL]         assertEquals("truncate semimonth-2 failed", [EOL]                 dateParser.parse("November 16, 2001"), [EOL]                 DateUtils.truncate(date2, DateUtils.SEMI_MONTH)); [EOL]         assertEquals("truncate date-1 failed", [EOL]                 dateParser.parse("February 12, 2002"), [EOL]                 DateUtils.truncate(date1, Calendar.DATE)); [EOL]         assertEquals("truncate date-2 failed", [EOL]                 dateParser.parse("November 18, 2001"), [EOL]                 DateUtils.truncate(date2, Calendar.DATE)); [EOL]         assertEquals("truncate hour-1 failed", [EOL]                 dateTimeParser.parse("February 12, 2002 12:00:00.000"), [EOL]                 DateUtils.truncate(date1, Calendar.HOUR)); [EOL]         assertEquals("truncate hour-2 failed", [EOL]                 dateTimeParser.parse("November 18, 2001 1:00:00.000"), [EOL]                 DateUtils.truncate(date2, Calendar.HOUR)); [EOL]         assertEquals("truncate minute-1 failed", [EOL]                 dateTimeParser.parse("February 12, 2002 12:34:00.000"), [EOL]                 DateUtils.truncate(date1, Calendar.MINUTE)); [EOL]         assertEquals("truncate minute-2 failed", [EOL]                 dateTimeParser.parse("November 18, 2001 1:23:00.000"), [EOL]                 DateUtils.truncate(date2, Calendar.MINUTE)); [EOL]         assertEquals("truncate second-1 failed", [EOL]                 dateTimeParser.parse("February 12, 2002 12:34:56.000"), [EOL]                 DateUtils.truncate(date1, Calendar.SECOND)); [EOL]         assertEquals("truncate second-2 failed", [EOL]                 dateTimeParser.parse("November 18, 2001 1:23:11.000"), [EOL]                 DateUtils.truncate(date2, Calendar.SECOND)); [EOL]         assertEquals("truncate ampm-1 failed", [EOL]                 dateTimeParser.parse("February 3, 2002 00:00:00.000"), [EOL]                 DateUtils.truncate(dateAmPm1, Calendar.AM_PM)); [EOL]         assertEquals("truncate ampm-2 failed", [EOL]                 dateTimeParser.parse("February 3, 2002 00:00:00.000"), [EOL]                 DateUtils.truncate(dateAmPm2, Calendar.AM_PM)); [EOL]         assertEquals("truncate ampm-3 failed", [EOL]                 dateTimeParser.parse("February 3, 2002 12:00:00.000"), [EOL]                 DateUtils.truncate(dateAmPm3, Calendar.AM_PM)); [EOL]         assertEquals("truncate ampm-4 failed", [EOL]                 dateTimeParser.parse("February 3, 2002 12:00:00.000"), [EOL]                 DateUtils.truncate(dateAmPm4, Calendar.AM_PM)); [EOL]  [EOL]         // tests public static Date truncate(Object date, int field) [EOL]         assertEquals("truncate year-1 failed", [EOL]                 dateParser.parse("January 1, 2002"), [EOL]                 DateUtils.truncate((Object) date1, Calendar.YEAR)); [EOL]         assertEquals("truncate year-2 failed", [EOL]                 dateParser.parse("January 1, 2001"), [EOL]                 DateUtils.truncate((Object) date2, Calendar.YEAR)); [EOL]         assertEquals("truncate month-1 failed", [EOL]                 dateParser.parse("February 1, 2002"), [EOL]                 DateUtils.truncate((Object) date1, Calendar.MONTH)); [EOL]         assertEquals("truncate month-2 failed", [EOL]                 dateParser.parse("November 1, 2001"), [EOL]                 DateUtils.truncate((Object) date2, Calendar.MONTH)); [EOL]         assertEquals("truncate semimonth-1 failed", [EOL]                 dateParser.parse("February 1, 2002"), [EOL]                 DateUtils.truncate((Object) date1, DateUtils.SEMI_MONTH)); [EOL]         assertEquals("truncate semimonth-2 failed", [EOL]                 dateParser.parse("November 16, 2001"), [EOL]                 DateUtils.truncate((Object) date2, DateUtils.SEMI_MONTH)); [EOL]         assertEquals("truncate date-1 failed", [EOL]                 dateParser.parse("February 12, 2002"), [EOL]                 DateUtils.truncate((Object) date1, Calendar.DATE)); [EOL]         assertEquals("truncate date-2 failed", [EOL]                 dateParser.parse("November 18, 2001"), [EOL]                 DateUtils.truncate((Object) date2, Calendar.DATE)); [EOL]         assertEquals("truncate hour-1 failed", [EOL]                 dateTimeParser.parse("February 12, 2002 12:00:00.000"), [EOL]                 DateUtils.truncate((Object) date1, Calendar.HOUR)); [EOL]         assertEquals("truncate hour-2 failed", [EOL]                 dateTimeParser.parse("November 18, 2001 1:00:00.000"), [EOL]                 DateUtils.truncate((Object) date2, Calendar.HOUR)); [EOL]         assertEquals("truncate minute-1 failed", [EOL]                 dateTimeParser.parse("February 12, 2002 12:34:00.000"), [EOL]                 DateUtils.truncate((Object) date1, Calendar.MINUTE)); [EOL]         assertEquals("truncate minute-2 failed", [EOL]                 dateTimeParser.parse("November 18, 2001 1:23:00.000"), [EOL]                 DateUtils.truncate((Object) date2, Calendar.MINUTE)); [EOL]         assertEquals("truncate second-1 failed", [EOL]                 dateTimeParser.parse("February 12, 2002 12:34:56.000"), [EOL]                 DateUtils.truncate((Object) date1, Calendar.SECOND)); [EOL]         assertEquals("truncate second-2 failed", [EOL]                 dateTimeParser.parse("November 18, 2001 1:23:11.000"), [EOL]                 DateUtils.truncate((Object) date2, Calendar.SECOND)); [EOL]         assertEquals("truncate ampm-1 failed", [EOL]                 dateTimeParser.parse("February 3, 2002 00:00:00.000"), [EOL]                 DateUtils.truncate((Object) dateAmPm1, Calendar.AM_PM)); [EOL]         assertEquals("truncate ampm-2 failed", [EOL]                 dateTimeParser.parse("February 3, 2002 00:00:00.000"), [EOL]                 DateUtils.truncate((Object) dateAmPm2, Calendar.AM_PM)); [EOL]         assertEquals("truncate ampm-3 failed", [EOL]                 dateTimeParser.parse("February 3, 2002 12:00:00.000"), [EOL]                 DateUtils.truncate((Object) dateAmPm3, Calendar.AM_PM)); [EOL]         assertEquals("truncate ampm-4 failed", [EOL]                 dateTimeParser.parse("February 3, 2002 12:00:00.000"), [EOL]                 DateUtils.truncate((Object) dateAmPm4, Calendar.AM_PM)); [EOL]          [EOL]         assertEquals("truncate calendar second-1 failed", [EOL]                 dateTimeParser.parse("February 12, 2002 12:34:56.000"), [EOL]                 DateUtils.truncate((Object) cal1, Calendar.SECOND)); [EOL]         assertEquals("truncate calendar second-2 failed", [EOL]                 dateTimeParser.parse("November 18, 2001 1:23:11.000"), [EOL]                 DateUtils.truncate((Object) cal2, Calendar.SECOND)); [EOL]          [EOL]         assertEquals("truncate ampm-1 failed", [EOL]                 dateTimeParser.parse("February 3, 2002 00:00:00.000"), [EOL]                 DateUtils.truncate((Object) calAmPm1, Calendar.AM_PM)); [EOL]         assertEquals("truncate ampm-2 failed", [EOL]                 dateTimeParser.parse("February 3, 2002 00:00:00.000"), [EOL]                 DateUtils.truncate((Object) calAmPm2, Calendar.AM_PM)); [EOL]         assertEquals("truncate ampm-3 failed", [EOL]                 dateTimeParser.parse("February 3, 2002 12:00:00.000"), [EOL]                 DateUtils.truncate((Object) calAmPm3, Calendar.AM_PM)); [EOL]         assertEquals("truncate ampm-4 failed", [EOL]                 dateTimeParser.parse("February 3, 2002 12:00:00.000"), [EOL]                 DateUtils.truncate((Object) calAmPm4, Calendar.AM_PM)); [EOL]          [EOL]         try { [EOL]             DateUtils.truncate((Date) null, Calendar.SECOND); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             DateUtils.truncate((Calendar) null, Calendar.SECOND); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             DateUtils.truncate((Object) null, Calendar.SECOND); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             DateUtils.truncate("", Calendar.SECOND); [EOL]             fail(); [EOL]         } catch (final ClassCastException ex) {} [EOL]  [EOL]         // Fix for http://issues.apache.org/bugzilla/show_bug.cgi?id=25560 [EOL]         // Test truncate across beginning of daylight saving time [EOL]         TimeZone.setDefault(zone); [EOL]         dateTimeParser.setTimeZone(zone); [EOL]         assertEquals("truncate MET date across DST change-over", [EOL]                 dateTimeParser.parse("March 30, 2003 00:00:00.000"), [EOL]                 DateUtils.truncate(date3, Calendar.DATE)); [EOL]         assertEquals("truncate MET date across DST change-over", [EOL]                 dateTimeParser.parse("March 30, 2003 00:00:00.000"), [EOL]                 DateUtils.truncate((Object) cal3, Calendar.DATE)); [EOL]         // Test truncate across end of daylight saving time [EOL]         assertEquals("truncate MET date across DST change-over", [EOL]                 dateTimeParser.parse("October 26, 2003 00:00:00.000"), [EOL]                 DateUtils.truncate(date8, Calendar.DATE)); [EOL]         assertEquals("truncate MET date across DST change-over", [EOL]                 dateTimeParser.parse("October 26, 2003 00:00:00.000"), [EOL]                 DateUtils.truncate((Object) cal8, Calendar.DATE)); [EOL]         TimeZone.setDefault(defaultZone); [EOL]         dateTimeParser.setTimeZone(defaultZone); [EOL]          [EOL]         // Bug 31395, large dates [EOL]         final Date endOfTime = new Date(Long.MAX_VALUE); // fyi: Sun Aug 17 07:12:55 CET 292278994 -- 807 millis [EOL]         final GregorianCalendar endCal = new GregorianCalendar(); [EOL]         endCal.setTime(endOfTime); [EOL]         try { [EOL]             DateUtils.truncate(endCal, Calendar.DATE); [EOL]             fail(); [EOL]         } catch (final ArithmeticException ex) {} [EOL]         endCal.set(Calendar.YEAR, 280000001); [EOL]         try { [EOL]             DateUtils.truncate(endCal, Calendar.DATE); [EOL]             fail(); [EOL]         } catch (final ArithmeticException ex) {} [EOL]         endCal.set(Calendar.YEAR, 280000000); [EOL]         final Calendar cal = DateUtils.truncate(endCal, Calendar.DATE); [EOL]         assertEquals(0, cal.get(Calendar.HOUR)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests for LANG-59 [EOL]      * [EOL]      * see http://issues.apache.org/jira/browse/LANG-59 [EOL]      */ [EOL]
@Test [EOL]     public void testIteratorEx() throws Exception { [EOL]         try { [EOL]             DateUtils.iterator(Calendar.getInstance(), -9999); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             DateUtils.iterator((Date) null, DateUtils.RANGE_WEEK_CENTER); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             DateUtils.iterator((Calendar) null, DateUtils.RANGE_WEEK_CENTER); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             DateUtils.iterator((Object) null, DateUtils.RANGE_WEEK_CENTER); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             DateUtils.iterator("", DateUtils.RANGE_WEEK_CENTER); [EOL]             fail(); [EOL]         } catch (final ClassCastException ex) {} [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the calendar iterator for week ranges [EOL]      */ [EOL]
@Test [EOL]     public void testWeekIterator() throws Exception { [EOL]         final Calendar now = Calendar.getInstance(); [EOL]         for (int i = 0; i< 7; i++) { [EOL]             final Calendar today = DateUtils.truncate(now, Calendar.DATE); [EOL]             final Calendar sunday = DateUtils.truncate(now, Calendar.DATE); [EOL]             sunday.add(Calendar.DATE, 1 - sunday.get(Calendar.DAY_OF_WEEK)); [EOL]             final Calendar monday = DateUtils.truncate(now, Calendar.DATE); [EOL]             if (monday.get(Calendar.DAY_OF_WEEK) == 1) { [EOL]                 //This is sunday... roll back 6 days [EOL]                 monday.add(Calendar.DATE, -6); [EOL]             } else { [EOL]                 monday.add(Calendar.DATE, 2 - monday.get(Calendar.DAY_OF_WEEK)); [EOL]             } [EOL]             final Calendar centered = DateUtils.truncate(now, Calendar.DATE); [EOL]             centered.add(Calendar.DATE, -3); [EOL]              [EOL]             Iterator<?> it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_SUNDAY); [EOL]             assertWeekIterator(it, sunday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_MONDAY); [EOL]             assertWeekIterator(it, monday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_RELATIVE); [EOL]             assertWeekIterator(it, today); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]              [EOL]             it = DateUtils.iterator((Object) now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now.getTime(), DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             try { [EOL]                 it.next(); [EOL]                 fail(); [EOL]             } catch (final NoSuchElementException ex) {} [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER); [EOL]             it.next(); [EOL]             try { [EOL]                 it.remove(); [EOL]             } catch( final UnsupportedOperationException ex) {} [EOL]              [EOL]             now.add(Calendar.DATE,1); [EOL]         } [EOL]     } [EOL]              [EOL]     /** [EOL]      * Tests the calendar iterator for month-based ranges [EOL]      */ [EOL]
@Test [EOL]     public void testWeekIterator() throws Exception { [EOL]         final Calendar now = Calendar.getInstance(); [EOL]         for (int i = 0; i< 7; i++) { [EOL]             final Calendar today = DateUtils.truncate(now, Calendar.DATE); [EOL]             final Calendar sunday = DateUtils.truncate(now, Calendar.DATE); [EOL]             sunday.add(Calendar.DATE, 1 - sunday.get(Calendar.DAY_OF_WEEK)); [EOL]             final Calendar monday = DateUtils.truncate(now, Calendar.DATE); [EOL]             if (monday.get(Calendar.DAY_OF_WEEK) == 1) { [EOL]                 //This is sunday... roll back 6 days [EOL]                 monday.add(Calendar.DATE, -6); [EOL]             } else { [EOL]                 monday.add(Calendar.DATE, 2 - monday.get(Calendar.DAY_OF_WEEK)); [EOL]             } [EOL]             final Calendar centered = DateUtils.truncate(now, Calendar.DATE); [EOL]             centered.add(Calendar.DATE, -3); [EOL]              [EOL]             Iterator<?> it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_SUNDAY); [EOL]             assertWeekIterator(it, sunday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_MONDAY); [EOL]             assertWeekIterator(it, monday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_RELATIVE); [EOL]             assertWeekIterator(it, today); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]              [EOL]             it = DateUtils.iterator((Object) now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now.getTime(), DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             try { [EOL]                 it.next(); [EOL]                 fail(); [EOL]             } catch (final NoSuchElementException ex) {} [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER); [EOL]             it.next(); [EOL]             try { [EOL]                 it.remove(); [EOL]             } catch( final UnsupportedOperationException ex) {} [EOL]              [EOL]             now.add(Calendar.DATE,1); [EOL]         } [EOL]     } [EOL]              [EOL]     /** [EOL]      * Tests the calendar iterator for month-based ranges [EOL]      */ [EOL]
@Test [EOL]     public void testWeekIterator() throws Exception { [EOL]         final Calendar now = Calendar.getInstance(); [EOL]         for (int i = 0; i< 7; i++) { [EOL]             final Calendar today = DateUtils.truncate(now, Calendar.DATE); [EOL]             final Calendar sunday = DateUtils.truncate(now, Calendar.DATE); [EOL]             sunday.add(Calendar.DATE, 1 - sunday.get(Calendar.DAY_OF_WEEK)); [EOL]             final Calendar monday = DateUtils.truncate(now, Calendar.DATE); [EOL]             if (monday.get(Calendar.DAY_OF_WEEK) == 1) { [EOL]                 //This is sunday... roll back 6 days [EOL]                 monday.add(Calendar.DATE, -6); [EOL]             } else { [EOL]                 monday.add(Calendar.DATE, 2 - monday.get(Calendar.DAY_OF_WEEK)); [EOL]             } [EOL]             final Calendar centered = DateUtils.truncate(now, Calendar.DATE); [EOL]             centered.add(Calendar.DATE, -3); [EOL]              [EOL]             Iterator<?> it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_SUNDAY); [EOL]             assertWeekIterator(it, sunday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_MONDAY); [EOL]             assertWeekIterator(it, monday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_RELATIVE); [EOL]             assertWeekIterator(it, today); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]              [EOL]             it = DateUtils.iterator((Object) now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now.getTime(), DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             try { [EOL]                 it.next(); [EOL]                 fail(); [EOL]             } catch (final NoSuchElementException ex) {} [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER); [EOL]             it.next(); [EOL]             try { [EOL]                 it.remove(); [EOL]             } catch( final UnsupportedOperationException ex) {} [EOL]              [EOL]             now.add(Calendar.DATE,1); [EOL]         } [EOL]     } [EOL]              [EOL]     /** [EOL]      * Tests the calendar iterator for month-based ranges [EOL]      */ [EOL]
@Test [EOL]     public void testWeekIterator() throws Exception { [EOL]         final Calendar now = Calendar.getInstance(); [EOL]         for (int i = 0; i< 7; i++) { [EOL]             final Calendar today = DateUtils.truncate(now, Calendar.DATE); [EOL]             final Calendar sunday = DateUtils.truncate(now, Calendar.DATE); [EOL]             sunday.add(Calendar.DATE, 1 - sunday.get(Calendar.DAY_OF_WEEK)); [EOL]             final Calendar monday = DateUtils.truncate(now, Calendar.DATE); [EOL]             if (monday.get(Calendar.DAY_OF_WEEK) == 1) { [EOL]                 //This is sunday... roll back 6 days [EOL]                 monday.add(Calendar.DATE, -6); [EOL]             } else { [EOL]                 monday.add(Calendar.DATE, 2 - monday.get(Calendar.DAY_OF_WEEK)); [EOL]             } [EOL]             final Calendar centered = DateUtils.truncate(now, Calendar.DATE); [EOL]             centered.add(Calendar.DATE, -3); [EOL]              [EOL]             Iterator<?> it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_SUNDAY); [EOL]             assertWeekIterator(it, sunday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_MONDAY); [EOL]             assertWeekIterator(it, monday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_RELATIVE); [EOL]             assertWeekIterator(it, today); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]              [EOL]             it = DateUtils.iterator((Object) now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now.getTime(), DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             try { [EOL]                 it.next(); [EOL]                 fail(); [EOL]             } catch (final NoSuchElementException ex) {} [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER); [EOL]             it.next(); [EOL]             try { [EOL]                 it.remove(); [EOL]             } catch( final UnsupportedOperationException ex) {} [EOL]              [EOL]             now.add(Calendar.DATE,1); [EOL]         } [EOL]     } [EOL]              [EOL]     /** [EOL]      * Tests the calendar iterator for month-based ranges [EOL]      */ [EOL]
@Test [EOL]     public void testWeekIterator() throws Exception { [EOL]         final Calendar now = Calendar.getInstance(); [EOL]         for (int i = 0; i< 7; i++) { [EOL]             final Calendar today = DateUtils.truncate(now, Calendar.DATE); [EOL]             final Calendar sunday = DateUtils.truncate(now, Calendar.DATE); [EOL]             sunday.add(Calendar.DATE, 1 - sunday.get(Calendar.DAY_OF_WEEK)); [EOL]             final Calendar monday = DateUtils.truncate(now, Calendar.DATE); [EOL]             if (monday.get(Calendar.DAY_OF_WEEK) == 1) { [EOL]                 //This is sunday... roll back 6 days [EOL]                 monday.add(Calendar.DATE, -6); [EOL]             } else { [EOL]                 monday.add(Calendar.DATE, 2 - monday.get(Calendar.DAY_OF_WEEK)); [EOL]             } [EOL]             final Calendar centered = DateUtils.truncate(now, Calendar.DATE); [EOL]             centered.add(Calendar.DATE, -3); [EOL]              [EOL]             Iterator<?> it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_SUNDAY); [EOL]             assertWeekIterator(it, sunday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_MONDAY); [EOL]             assertWeekIterator(it, monday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_RELATIVE); [EOL]             assertWeekIterator(it, today); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]              [EOL]             it = DateUtils.iterator((Object) now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now.getTime(), DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             try { [EOL]                 it.next(); [EOL]                 fail(); [EOL]             } catch (final NoSuchElementException ex) {} [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER); [EOL]             it.next(); [EOL]             try { [EOL]                 it.remove(); [EOL]             } catch( final UnsupportedOperationException ex) {} [EOL]              [EOL]             now.add(Calendar.DATE,1); [EOL]         } [EOL]     } [EOL]              [EOL]     /** [EOL]      * Tests the calendar iterator for month-based ranges [EOL]      */ [EOL]
@Test [EOL]     public void testWeekIterator() throws Exception { [EOL]         final Calendar now = Calendar.getInstance(); [EOL]         for (int i = 0; i< 7; i++) { [EOL]             final Calendar today = DateUtils.truncate(now, Calendar.DATE); [EOL]             final Calendar sunday = DateUtils.truncate(now, Calendar.DATE); [EOL]             sunday.add(Calendar.DATE, 1 - sunday.get(Calendar.DAY_OF_WEEK)); [EOL]             final Calendar monday = DateUtils.truncate(now, Calendar.DATE); [EOL]             if (monday.get(Calendar.DAY_OF_WEEK) == 1) { [EOL]                 //This is sunday... roll back 6 days [EOL]                 monday.add(Calendar.DATE, -6); [EOL]             } else { [EOL]                 monday.add(Calendar.DATE, 2 - monday.get(Calendar.DAY_OF_WEEK)); [EOL]             } [EOL]             final Calendar centered = DateUtils.truncate(now, Calendar.DATE); [EOL]             centered.add(Calendar.DATE, -3); [EOL]              [EOL]             Iterator<?> it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_SUNDAY); [EOL]             assertWeekIterator(it, sunday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_MONDAY); [EOL]             assertWeekIterator(it, monday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_RELATIVE); [EOL]             assertWeekIterator(it, today); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]              [EOL]             it = DateUtils.iterator((Object) now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now.getTime(), DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             try { [EOL]                 it.next(); [EOL]                 fail(); [EOL]             } catch (final NoSuchElementException ex) {} [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER); [EOL]             it.next(); [EOL]             try { [EOL]                 it.remove(); [EOL]             } catch( final UnsupportedOperationException ex) {} [EOL]              [EOL]             now.add(Calendar.DATE,1); [EOL]         } [EOL]     } [EOL]              [EOL]     /** [EOL]      * Tests the calendar iterator for month-based ranges [EOL]      */ [EOL]
@Test [EOL]     public void testWeekIterator() throws Exception { [EOL]         final Calendar now = Calendar.getInstance(); [EOL]         for (int i = 0; i< 7; i++) { [EOL]             final Calendar today = DateUtils.truncate(now, Calendar.DATE); [EOL]             final Calendar sunday = DateUtils.truncate(now, Calendar.DATE); [EOL]             sunday.add(Calendar.DATE, 1 - sunday.get(Calendar.DAY_OF_WEEK)); [EOL]             final Calendar monday = DateUtils.truncate(now, Calendar.DATE); [EOL]             if (monday.get(Calendar.DAY_OF_WEEK) == 1) { [EOL]                 //This is sunday... roll back 6 days [EOL]                 monday.add(Calendar.DATE, -6); [EOL]             } else { [EOL]                 monday.add(Calendar.DATE, 2 - monday.get(Calendar.DAY_OF_WEEK)); [EOL]             } [EOL]             final Calendar centered = DateUtils.truncate(now, Calendar.DATE); [EOL]             centered.add(Calendar.DATE, -3); [EOL]              [EOL]             Iterator<?> it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_SUNDAY); [EOL]             assertWeekIterator(it, sunday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_MONDAY); [EOL]             assertWeekIterator(it, monday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_RELATIVE); [EOL]             assertWeekIterator(it, today); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]              [EOL]             it = DateUtils.iterator((Object) now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now.getTime(), DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             try { [EOL]                 it.next(); [EOL]                 fail(); [EOL]             } catch (final NoSuchElementException ex) {} [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER); [EOL]             it.next(); [EOL]             try { [EOL]                 it.remove(); [EOL]             } catch( final UnsupportedOperationException ex) {} [EOL]              [EOL]             now.add(Calendar.DATE,1); [EOL]         } [EOL]     } [EOL]              [EOL]     /** [EOL]      * Tests the calendar iterator for month-based ranges [EOL]      */ [EOL]
@Test [EOL]     public void testWeekIterator() throws Exception { [EOL]         final Calendar now = Calendar.getInstance(); [EOL]         for (int i = 0; i< 7; i++) { [EOL]             final Calendar today = DateUtils.truncate(now, Calendar.DATE); [EOL]             final Calendar sunday = DateUtils.truncate(now, Calendar.DATE); [EOL]             sunday.add(Calendar.DATE, 1 - sunday.get(Calendar.DAY_OF_WEEK)); [EOL]             final Calendar monday = DateUtils.truncate(now, Calendar.DATE); [EOL]             if (monday.get(Calendar.DAY_OF_WEEK) == 1) { [EOL]                 //This is sunday... roll back 6 days [EOL]                 monday.add(Calendar.DATE, -6); [EOL]             } else { [EOL]                 monday.add(Calendar.DATE, 2 - monday.get(Calendar.DAY_OF_WEEK)); [EOL]             } [EOL]             final Calendar centered = DateUtils.truncate(now, Calendar.DATE); [EOL]             centered.add(Calendar.DATE, -3); [EOL]              [EOL]             Iterator<?> it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_SUNDAY); [EOL]             assertWeekIterator(it, sunday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_MONDAY); [EOL]             assertWeekIterator(it, monday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_RELATIVE); [EOL]             assertWeekIterator(it, today); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]              [EOL]             it = DateUtils.iterator((Object) now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now.getTime(), DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             try { [EOL]                 it.next(); [EOL]                 fail(); [EOL]             } catch (final NoSuchElementException ex) {} [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER); [EOL]             it.next(); [EOL]             try { [EOL]                 it.remove(); [EOL]             } catch( final UnsupportedOperationException ex) {} [EOL]              [EOL]             now.add(Calendar.DATE,1); [EOL]         } [EOL]     } [EOL]              [EOL]     /** [EOL]      * Tests the calendar iterator for month-based ranges [EOL]      */ [EOL]
@Test [EOL]     public void testWeekIterator() throws Exception { [EOL]         final Calendar now = Calendar.getInstance(); [EOL]         for (int i = 0; i< 7; i++) { [EOL]             final Calendar today = DateUtils.truncate(now, Calendar.DATE); [EOL]             final Calendar sunday = DateUtils.truncate(now, Calendar.DATE); [EOL]             sunday.add(Calendar.DATE, 1 - sunday.get(Calendar.DAY_OF_WEEK)); [EOL]             final Calendar monday = DateUtils.truncate(now, Calendar.DATE); [EOL]             if (monday.get(Calendar.DAY_OF_WEEK) == 1) { [EOL]                 //This is sunday... roll back 6 days [EOL]                 monday.add(Calendar.DATE, -6); [EOL]             } else { [EOL]                 monday.add(Calendar.DATE, 2 - monday.get(Calendar.DAY_OF_WEEK)); [EOL]             } [EOL]             final Calendar centered = DateUtils.truncate(now, Calendar.DATE); [EOL]             centered.add(Calendar.DATE, -3); [EOL]              [EOL]             Iterator<?> it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_SUNDAY); [EOL]             assertWeekIterator(it, sunday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_MONDAY); [EOL]             assertWeekIterator(it, monday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_RELATIVE); [EOL]             assertWeekIterator(it, today); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]              [EOL]             it = DateUtils.iterator((Object) now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now.getTime(), DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             try { [EOL]                 it.next(); [EOL]                 fail(); [EOL]             } catch (final NoSuchElementException ex) {} [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER); [EOL]             it.next(); [EOL]             try { [EOL]                 it.remove(); [EOL]             } catch( final UnsupportedOperationException ex) {} [EOL]              [EOL]             now.add(Calendar.DATE,1); [EOL]         } [EOL]     } [EOL]              [EOL]     /** [EOL]      * Tests the calendar iterator for month-based ranges [EOL]      */ [EOL]
@Test [EOL]     public void testWeekIterator() throws Exception { [EOL]         final Calendar now = Calendar.getInstance(); [EOL]         for (int i = 0; i< 7; i++) { [EOL]             final Calendar today = DateUtils.truncate(now, Calendar.DATE); [EOL]             final Calendar sunday = DateUtils.truncate(now, Calendar.DATE); [EOL]             sunday.add(Calendar.DATE, 1 - sunday.get(Calendar.DAY_OF_WEEK)); [EOL]             final Calendar monday = DateUtils.truncate(now, Calendar.DATE); [EOL]             if (monday.get(Calendar.DAY_OF_WEEK) == 1) { [EOL]                 //This is sunday... roll back 6 days [EOL]                 monday.add(Calendar.DATE, -6); [EOL]             } else { [EOL]                 monday.add(Calendar.DATE, 2 - monday.get(Calendar.DAY_OF_WEEK)); [EOL]             } [EOL]             final Calendar centered = DateUtils.truncate(now, Calendar.DATE); [EOL]             centered.add(Calendar.DATE, -3); [EOL]              [EOL]             Iterator<?> it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_SUNDAY); [EOL]             assertWeekIterator(it, sunday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_MONDAY); [EOL]             assertWeekIterator(it, monday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_RELATIVE); [EOL]             assertWeekIterator(it, today); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]              [EOL]             it = DateUtils.iterator((Object) now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now.getTime(), DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             try { [EOL]                 it.next(); [EOL]                 fail(); [EOL]             } catch (final NoSuchElementException ex) {} [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER); [EOL]             it.next(); [EOL]             try { [EOL]                 it.remove(); [EOL]             } catch( final UnsupportedOperationException ex) {} [EOL]              [EOL]             now.add(Calendar.DATE,1); [EOL]         } [EOL]     } [EOL]              [EOL]     /** [EOL]      * Tests the calendar iterator for month-based ranges [EOL]      */ [EOL]
@Test [EOL]     public void testWeekIterator() throws Exception { [EOL]         final Calendar now = Calendar.getInstance(); [EOL]         for (int i = 0; i< 7; i++) { [EOL]             final Calendar today = DateUtils.truncate(now, Calendar.DATE); [EOL]             final Calendar sunday = DateUtils.truncate(now, Calendar.DATE); [EOL]             sunday.add(Calendar.DATE, 1 - sunday.get(Calendar.DAY_OF_WEEK)); [EOL]             final Calendar monday = DateUtils.truncate(now, Calendar.DATE); [EOL]             if (monday.get(Calendar.DAY_OF_WEEK) == 1) { [EOL]                 //This is sunday... roll back 6 days [EOL]                 monday.add(Calendar.DATE, -6); [EOL]             } else { [EOL]                 monday.add(Calendar.DATE, 2 - monday.get(Calendar.DAY_OF_WEEK)); [EOL]             } [EOL]             final Calendar centered = DateUtils.truncate(now, Calendar.DATE); [EOL]             centered.add(Calendar.DATE, -3); [EOL]              [EOL]             Iterator<?> it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_SUNDAY); [EOL]             assertWeekIterator(it, sunday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_MONDAY); [EOL]             assertWeekIterator(it, monday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_RELATIVE); [EOL]             assertWeekIterator(it, today); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]              [EOL]             it = DateUtils.iterator((Object) now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now.getTime(), DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             try { [EOL]                 it.next(); [EOL]                 fail(); [EOL]             } catch (final NoSuchElementException ex) {} [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER); [EOL]             it.next(); [EOL]             try { [EOL]                 it.remove(); [EOL]             } catch( final UnsupportedOperationException ex) {} [EOL]              [EOL]             now.add(Calendar.DATE,1); [EOL]         } [EOL]     } [EOL]              [EOL]     /** [EOL]      * Tests the calendar iterator for month-based ranges [EOL]      */ [EOL]
@Test [EOL]     public void testWeekIterator() throws Exception { [EOL]         final Calendar now = Calendar.getInstance(); [EOL]         for (int i = 0; i< 7; i++) { [EOL]             final Calendar today = DateUtils.truncate(now, Calendar.DATE); [EOL]             final Calendar sunday = DateUtils.truncate(now, Calendar.DATE); [EOL]             sunday.add(Calendar.DATE, 1 - sunday.get(Calendar.DAY_OF_WEEK)); [EOL]             final Calendar monday = DateUtils.truncate(now, Calendar.DATE); [EOL]             if (monday.get(Calendar.DAY_OF_WEEK) == 1) { [EOL]                 //This is sunday... roll back 6 days [EOL]                 monday.add(Calendar.DATE, -6); [EOL]             } else { [EOL]                 monday.add(Calendar.DATE, 2 - monday.get(Calendar.DAY_OF_WEEK)); [EOL]             } [EOL]             final Calendar centered = DateUtils.truncate(now, Calendar.DATE); [EOL]             centered.add(Calendar.DATE, -3); [EOL]              [EOL]             Iterator<?> it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_SUNDAY); [EOL]             assertWeekIterator(it, sunday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_MONDAY); [EOL]             assertWeekIterator(it, monday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_RELATIVE); [EOL]             assertWeekIterator(it, today); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]              [EOL]             it = DateUtils.iterator((Object) now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now.getTime(), DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             try { [EOL]                 it.next(); [EOL]                 fail(); [EOL]             } catch (final NoSuchElementException ex) {} [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER); [EOL]             it.next(); [EOL]             try { [EOL]                 it.remove(); [EOL]             } catch( final UnsupportedOperationException ex) {} [EOL]              [EOL]             now.add(Calendar.DATE,1); [EOL]         } [EOL]     } [EOL]              [EOL]     /** [EOL]      * Tests the calendar iterator for month-based ranges [EOL]      */ [EOL]
@Test [EOL]     public void testWeekIterator() throws Exception { [EOL]         final Calendar now = Calendar.getInstance(); [EOL]         for (int i = 0; i< 7; i++) { [EOL]             final Calendar today = DateUtils.truncate(now, Calendar.DATE); [EOL]             final Calendar sunday = DateUtils.truncate(now, Calendar.DATE); [EOL]             sunday.add(Calendar.DATE, 1 - sunday.get(Calendar.DAY_OF_WEEK)); [EOL]             final Calendar monday = DateUtils.truncate(now, Calendar.DATE); [EOL]             if (monday.get(Calendar.DAY_OF_WEEK) == 1) { [EOL]                 //This is sunday... roll back 6 days [EOL]                 monday.add(Calendar.DATE, -6); [EOL]             } else { [EOL]                 monday.add(Calendar.DATE, 2 - monday.get(Calendar.DAY_OF_WEEK)); [EOL]             } [EOL]             final Calendar centered = DateUtils.truncate(now, Calendar.DATE); [EOL]             centered.add(Calendar.DATE, -3); [EOL]              [EOL]             Iterator<?> it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_SUNDAY); [EOL]             assertWeekIterator(it, sunday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_MONDAY); [EOL]             assertWeekIterator(it, monday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_RELATIVE); [EOL]             assertWeekIterator(it, today); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]              [EOL]             it = DateUtils.iterator((Object) now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now.getTime(), DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             try { [EOL]                 it.next(); [EOL]                 fail(); [EOL]             } catch (final NoSuchElementException ex) {} [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER); [EOL]             it.next(); [EOL]             try { [EOL]                 it.remove(); [EOL]             } catch( final UnsupportedOperationException ex) {} [EOL]              [EOL]             now.add(Calendar.DATE,1); [EOL]         } [EOL]     } [EOL]              [EOL]     /** [EOL]      * Tests the calendar iterator for month-based ranges [EOL]      */ [EOL]
@Test [EOL]     public void testMinutesOfDayWithDate() { [EOL]         long testResult = DateUtils.getFragmentInMinutes(aDate, Calendar.DATE); [EOL]         final long expectedValue = minutes + ((hours * DateUtils.MILLIS_PER_HOUR))/ DateUtils.MILLIS_PER_MINUTE;  [EOL]         assertEquals(expectedValue,testResult); [EOL]         testResult = DateUtils.getFragmentInMinutes(aDate, Calendar.DAY_OF_YEAR); [EOL]         assertEquals(expectedValue,testResult); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMinutesOfHourWithCalendar() { [EOL]         final long testResult = DateUtils.getFragmentInMinutes(aCalendar, Calendar.HOUR_OF_DAY); [EOL]         assertEquals(minutes, testResult); [EOL]     } [EOL]  [EOL]     //Calendar.DATE and Calendar.DAY_OF_YEAR as useful fragment [EOL]
@Test [EOL]     public void testSecondsofMinuteWithDate() { [EOL]         final long testResult = DateUtils.getFragmentInSeconds(aDate, Calendar.MINUTE); [EOL]         assertEquals(seconds, testResult); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMillisecondFragmentInLargerUnitWithCalendar() { [EOL]         assertEquals(0, DateUtils.getFragmentInMilliseconds(aCalendar, Calendar.MILLISECOND)); [EOL]         assertEquals(0, DateUtils.getFragmentInSeconds(aCalendar, Calendar.MILLISECOND)); [EOL]         assertEquals(0, DateUtils.getFragmentInMinutes(aCalendar, Calendar.MILLISECOND)); [EOL]         assertEquals(0, DateUtils.getFragmentInHours(aCalendar, Calendar.MILLISECOND)); [EOL]         assertEquals(0, DateUtils.getFragmentInDays(aCalendar, Calendar.MILLISECOND)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testEquals_Object() { [EOL]         final CharRange rangea = CharRange.is('a'); [EOL]         final CharRange rangeae = CharRange.isIn('a', 'e'); [EOL]         final CharRange rangenotbf = CharRange.isIn('b', 'f'); [EOL]  [EOL]         assertFalse(rangea.equals(null)); [EOL]  [EOL]         assertTrue(rangea.equals(rangea)); [EOL]         assertTrue(rangea.equals(CharRange.is('a'))); [EOL]         assertTrue(rangeae.equals(rangeae)); [EOL]         assertTrue(rangeae.equals(CharRange.isIn('a', 'e'))); [EOL]         assertTrue(rangenotbf.equals(rangenotbf)); [EOL]         assertTrue(rangenotbf.equals(CharRange.isIn('b', 'f'))); [EOL]  [EOL]         assertFalse(rangea.equals(rangeae)); [EOL]         assertFalse(rangea.equals(rangenotbf)); [EOL]         assertFalse(rangeae.equals(rangea)); [EOL]         assertFalse(rangeae.equals(rangenotbf)); [EOL]         assertFalse(rangenotbf.equals(rangea)); [EOL]         assertFalse(rangenotbf.equals(rangeae)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIterator() { [EOL]         final CharRange a = CharRange.is('a'); [EOL]         final CharRange ad = CharRange.isIn('a', 'd'); [EOL]         final CharRange nota = CharRange.isNot('a'); [EOL]         final CharRange emptySet = CharRange.isNotIn((char) 0, Character.MAX_VALUE); [EOL]         final CharRange notFirst = CharRange.isNotIn((char) 1, Character.MAX_VALUE); [EOL]         final CharRange notLast = CharRange.isNotIn((char) 0, (char) (Character.MAX_VALUE - 1)); [EOL]  [EOL]         final Iterator<Character> aIt = a.iterator(); [EOL]         assertNotNull(aIt); [EOL]         assertTrue(aIt.hasNext()); [EOL]         assertEquals(Character.valueOf('a'), aIt.next()); [EOL]         assertFalse(aIt.hasNext()); [EOL]  [EOL]         final Iterator<Character> adIt = ad.iterator(); [EOL]         assertNotNull(adIt); [EOL]         assertTrue(adIt.hasNext()); [EOL]         assertEquals(Character.valueOf('a'), adIt.next()); [EOL]         assertEquals(Character.valueOf('b'), adIt.next()); [EOL]         assertEquals(Character.valueOf('c'), adIt.next()); [EOL]         assertEquals(Character.valueOf('d'), adIt.next()); [EOL]         assertFalse(adIt.hasNext()); [EOL]  [EOL]         final Iterator<Character> notaIt = nota.iterator(); [EOL]         assertNotNull(notaIt); [EOL]         assertTrue(notaIt.hasNext()); [EOL]         while (notaIt.hasNext()) { [EOL]             final Character c = notaIt.next(); [EOL]             assertFalse('a' == c.charValue()); [EOL]         } [EOL]  [EOL]         final Iterator<Character> emptySetIt = emptySet.iterator(); [EOL]         assertNotNull(emptySetIt); [EOL]         assertFalse(emptySetIt.hasNext()); [EOL]         try { [EOL]             emptySetIt.next(); [EOL]             fail("Should throw NoSuchElementException"); [EOL]         } catch (final NoSuchElementException e) { [EOL]             assertTrue(true); [EOL]         } [EOL]  [EOL]         final Iterator<Character> notFirstIt = notFirst.iterator(); [EOL]         assertNotNull(notFirstIt); [EOL]         assertTrue(notFirstIt.hasNext()); [EOL]         assertEquals(Character.valueOf((char) 0), notFirstIt.next()); [EOL]         assertFalse(notFirstIt.hasNext()); [EOL]         try { [EOL]             notFirstIt.next(); [EOL]             fail("Should throw NoSuchElementException"); [EOL]         } catch (final NoSuchElementException e) { [EOL]             assertTrue(true); [EOL]         } [EOL]  [EOL]         final Iterator<Character> notLastIt = notLast.iterator(); [EOL]         assertNotNull(notLastIt); [EOL]         assertTrue(notLastIt.hasNext()); [EOL]         assertEquals(Character.valueOf(Character.MAX_VALUE), notLastIt.next()); [EOL]         assertFalse(notLastIt.hasNext()); [EOL]         try { [EOL]             notLastIt.next(); [EOL]             fail("Should throw NoSuchElementException"); [EOL]         } catch (final NoSuchElementException e) { [EOL]             assertTrue(true); [EOL]         } [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testIterator() { [EOL]         final CharRange a = CharRange.is('a'); [EOL]         final CharRange ad = CharRange.isIn('a', 'd'); [EOL]         final CharRange nota = CharRange.isNot('a'); [EOL]         final CharRange emptySet = CharRange.isNotIn((char) 0, Character.MAX_VALUE); [EOL]         final CharRange notFirst = CharRange.isNotIn((char) 1, Character.MAX_VALUE); [EOL]         final CharRange notLast = CharRange.isNotIn((char) 0, (char) (Character.MAX_VALUE - 1)); [EOL]  [EOL]         final Iterator<Character> aIt = a.iterator(); [EOL]         assertNotNull(aIt); [EOL]         assertTrue(aIt.hasNext()); [EOL]         assertEquals(Character.valueOf('a'), aIt.next()); [EOL]         assertFalse(aIt.hasNext()); [EOL]  [EOL]         final Iterator<Character> adIt = ad.iterator(); [EOL]         assertNotNull(adIt); [EOL]         assertTrue(adIt.hasNext()); [EOL]         assertEquals(Character.valueOf('a'), adIt.next()); [EOL]         assertEquals(Character.valueOf('b'), adIt.next()); [EOL]         assertEquals(Character.valueOf('c'), adIt.next()); [EOL]         assertEquals(Character.valueOf('d'), adIt.next()); [EOL]         assertFalse(adIt.hasNext()); [EOL]  [EOL]         final Iterator<Character> notaIt = nota.iterator(); [EOL]         assertNotNull(notaIt); [EOL]         assertTrue(notaIt.hasNext()); [EOL]         while (notaIt.hasNext()) { [EOL]             final Character c = notaIt.next(); [EOL]             assertFalse('a' == c.charValue()); [EOL]         } [EOL]  [EOL]         final Iterator<Character> emptySetIt = emptySet.iterator(); [EOL]         assertNotNull(emptySetIt); [EOL]         assertFalse(emptySetIt.hasNext()); [EOL]         try { [EOL]             emptySetIt.next(); [EOL]             fail("Should throw NoSuchElementException"); [EOL]         } catch (final NoSuchElementException e) { [EOL]             assertTrue(true); [EOL]         } [EOL]  [EOL]         final Iterator<Character> notFirstIt = notFirst.iterator(); [EOL]         assertNotNull(notFirstIt); [EOL]         assertTrue(notFirstIt.hasNext()); [EOL]         assertEquals(Character.valueOf((char) 0), notFirstIt.next()); [EOL]         assertFalse(notFirstIt.hasNext()); [EOL]         try { [EOL]             notFirstIt.next(); [EOL]             fail("Should throw NoSuchElementException"); [EOL]         } catch (final NoSuchElementException e) { [EOL]             assertTrue(true); [EOL]         } [EOL]  [EOL]         final Iterator<Character> notLastIt = notLast.iterator(); [EOL]         assertNotNull(notLastIt); [EOL]         assertTrue(notLastIt.hasNext()); [EOL]         assertEquals(Character.valueOf(Character.MAX_VALUE), notLastIt.next()); [EOL]         assertFalse(notLastIt.hasNext()); [EOL]         try { [EOL]             notLastIt.next(); [EOL]             fail("Should throw NoSuchElementException"); [EOL]         } catch (final NoSuchElementException e) { [EOL]             assertTrue(true); [EOL]         } [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testIterator() { [EOL]         final CharRange a = CharRange.is('a'); [EOL]         final CharRange ad = CharRange.isIn('a', 'd'); [EOL]         final CharRange nota = CharRange.isNot('a'); [EOL]         final CharRange emptySet = CharRange.isNotIn((char) 0, Character.MAX_VALUE); [EOL]         final CharRange notFirst = CharRange.isNotIn((char) 1, Character.MAX_VALUE); [EOL]         final CharRange notLast = CharRange.isNotIn((char) 0, (char) (Character.MAX_VALUE - 1)); [EOL]  [EOL]         final Iterator<Character> aIt = a.iterator(); [EOL]         assertNotNull(aIt); [EOL]         assertTrue(aIt.hasNext()); [EOL]         assertEquals(Character.valueOf('a'), aIt.next()); [EOL]         assertFalse(aIt.hasNext()); [EOL]  [EOL]         final Iterator<Character> adIt = ad.iterator(); [EOL]         assertNotNull(adIt); [EOL]         assertTrue(adIt.hasNext()); [EOL]         assertEquals(Character.valueOf('a'), adIt.next()); [EOL]         assertEquals(Character.valueOf('b'), adIt.next()); [EOL]         assertEquals(Character.valueOf('c'), adIt.next()); [EOL]         assertEquals(Character.valueOf('d'), adIt.next()); [EOL]         assertFalse(adIt.hasNext()); [EOL]  [EOL]         final Iterator<Character> notaIt = nota.iterator(); [EOL]         assertNotNull(notaIt); [EOL]         assertTrue(notaIt.hasNext()); [EOL]         while (notaIt.hasNext()) { [EOL]             final Character c = notaIt.next(); [EOL]             assertFalse('a' == c.charValue()); [EOL]         } [EOL]  [EOL]         final Iterator<Character> emptySetIt = emptySet.iterator(); [EOL]         assertNotNull(emptySetIt); [EOL]         assertFalse(emptySetIt.hasNext()); [EOL]         try { [EOL]             emptySetIt.next(); [EOL]             fail("Should throw NoSuchElementException"); [EOL]         } catch (final NoSuchElementException e) { [EOL]             assertTrue(true); [EOL]         } [EOL]  [EOL]         final Iterator<Character> notFirstIt = notFirst.iterator(); [EOL]         assertNotNull(notFirstIt); [EOL]         assertTrue(notFirstIt.hasNext()); [EOL]         assertEquals(Character.valueOf((char) 0), notFirstIt.next()); [EOL]         assertFalse(notFirstIt.hasNext()); [EOL]         try { [EOL]             notFirstIt.next(); [EOL]             fail("Should throw NoSuchElementException"); [EOL]         } catch (final NoSuchElementException e) { [EOL]             assertTrue(true); [EOL]         } [EOL]  [EOL]         final Iterator<Character> notLastIt = notLast.iterator(); [EOL]         assertNotNull(notLastIt); [EOL]         assertTrue(notLastIt.hasNext()); [EOL]         assertEquals(Character.valueOf(Character.MAX_VALUE), notLastIt.next()); [EOL]         assertFalse(notLastIt.hasNext()); [EOL]         try { [EOL]             notLastIt.next(); [EOL]             fail("Should throw NoSuchElementException"); [EOL]         } catch (final NoSuchElementException e) { [EOL]             assertTrue(true); [EOL]         } [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testIterator() { [EOL]         final CharRange a = CharRange.is('a'); [EOL]         final CharRange ad = CharRange.isIn('a', 'd'); [EOL]         final CharRange nota = CharRange.isNot('a'); [EOL]         final CharRange emptySet = CharRange.isNotIn((char) 0, Character.MAX_VALUE); [EOL]         final CharRange notFirst = CharRange.isNotIn((char) 1, Character.MAX_VALUE); [EOL]         final CharRange notLast = CharRange.isNotIn((char) 0, (char) (Character.MAX_VALUE - 1)); [EOL]  [EOL]         final Iterator<Character> aIt = a.iterator(); [EOL]         assertNotNull(aIt); [EOL]         assertTrue(aIt.hasNext()); [EOL]         assertEquals(Character.valueOf('a'), aIt.next()); [EOL]         assertFalse(aIt.hasNext()); [EOL]  [EOL]         final Iterator<Character> adIt = ad.iterator(); [EOL]         assertNotNull(adIt); [EOL]         assertTrue(adIt.hasNext()); [EOL]         assertEquals(Character.valueOf('a'), adIt.next()); [EOL]         assertEquals(Character.valueOf('b'), adIt.next()); [EOL]         assertEquals(Character.valueOf('c'), adIt.next()); [EOL]         assertEquals(Character.valueOf('d'), adIt.next()); [EOL]         assertFalse(adIt.hasNext()); [EOL]  [EOL]         final Iterator<Character> notaIt = nota.iterator(); [EOL]         assertNotNull(notaIt); [EOL]         assertTrue(notaIt.hasNext()); [EOL]         while (notaIt.hasNext()) { [EOL]             final Character c = notaIt.next(); [EOL]             assertFalse('a' == c.charValue()); [EOL]         } [EOL]  [EOL]         final Iterator<Character> emptySetIt = emptySet.iterator(); [EOL]         assertNotNull(emptySetIt); [EOL]         assertFalse(emptySetIt.hasNext()); [EOL]         try { [EOL]             emptySetIt.next(); [EOL]             fail("Should throw NoSuchElementException"); [EOL]         } catch (final NoSuchElementException e) { [EOL]             assertTrue(true); [EOL]         } [EOL]  [EOL]         final Iterator<Character> notFirstIt = notFirst.iterator(); [EOL]         assertNotNull(notFirstIt); [EOL]         assertTrue(notFirstIt.hasNext()); [EOL]         assertEquals(Character.valueOf((char) 0), notFirstIt.next()); [EOL]         assertFalse(notFirstIt.hasNext()); [EOL]         try { [EOL]             notFirstIt.next(); [EOL]             fail("Should throw NoSuchElementException"); [EOL]         } catch (final NoSuchElementException e) { [EOL]             assertTrue(true); [EOL]         } [EOL]  [EOL]         final Iterator<Character> notLastIt = notLast.iterator(); [EOL]         assertNotNull(notLastIt); [EOL]         assertTrue(notLastIt.hasNext()); [EOL]         assertEquals(Character.valueOf(Character.MAX_VALUE), notLastIt.next()); [EOL]         assertFalse(notLastIt.hasNext()); [EOL]         try { [EOL]             notLastIt.next(); [EOL]             fail("Should throw NoSuchElementException"); [EOL]         } catch (final NoSuchElementException e) { [EOL]             assertTrue(true); [EOL]         } [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testIterator() { [EOL]         final CharRange a = CharRange.is('a'); [EOL]         final CharRange ad = CharRange.isIn('a', 'd'); [EOL]         final CharRange nota = CharRange.isNot('a'); [EOL]         final CharRange emptySet = CharRange.isNotIn((char) 0, Character.MAX_VALUE); [EOL]         final CharRange notFirst = CharRange.isNotIn((char) 1, Character.MAX_VALUE); [EOL]         final CharRange notLast = CharRange.isNotIn((char) 0, (char) (Character.MAX_VALUE - 1)); [EOL]  [EOL]         final Iterator<Character> aIt = a.iterator(); [EOL]         assertNotNull(aIt); [EOL]         assertTrue(aIt.hasNext()); [EOL]         assertEquals(Character.valueOf('a'), aIt.next()); [EOL]         assertFalse(aIt.hasNext()); [EOL]  [EOL]         final Iterator<Character> adIt = ad.iterator(); [EOL]         assertNotNull(adIt); [EOL]         assertTrue(adIt.hasNext()); [EOL]         assertEquals(Character.valueOf('a'), adIt.next()); [EOL]         assertEquals(Character.valueOf('b'), adIt.next()); [EOL]         assertEquals(Character.valueOf('c'), adIt.next()); [EOL]         assertEquals(Character.valueOf('d'), adIt.next()); [EOL]         assertFalse(adIt.hasNext()); [EOL]  [EOL]         final Iterator<Character> notaIt = nota.iterator(); [EOL]         assertNotNull(notaIt); [EOL]         assertTrue(notaIt.hasNext()); [EOL]         while (notaIt.hasNext()) { [EOL]             final Character c = notaIt.next(); [EOL]             assertFalse('a' == c.charValue()); [EOL]         } [EOL]  [EOL]         final Iterator<Character> emptySetIt = emptySet.iterator(); [EOL]         assertNotNull(emptySetIt); [EOL]         assertFalse(emptySetIt.hasNext()); [EOL]         try { [EOL]             emptySetIt.next(); [EOL]             fail("Should throw NoSuchElementException"); [EOL]         } catch (final NoSuchElementException e) { [EOL]             assertTrue(true); [EOL]         } [EOL]  [EOL]         final Iterator<Character> notFirstIt = notFirst.iterator(); [EOL]         assertNotNull(notFirstIt); [EOL]         assertTrue(notFirstIt.hasNext()); [EOL]         assertEquals(Character.valueOf((char) 0), notFirstIt.next()); [EOL]         assertFalse(notFirstIt.hasNext()); [EOL]         try { [EOL]             notFirstIt.next(); [EOL]             fail("Should throw NoSuchElementException"); [EOL]         } catch (final NoSuchElementException e) { [EOL]             assertTrue(true); [EOL]         } [EOL]  [EOL]         final Iterator<Character> notLastIt = notLast.iterator(); [EOL]         assertNotNull(notLastIt); [EOL]         assertTrue(notLastIt.hasNext()); [EOL]         assertEquals(Character.valueOf(Character.MAX_VALUE), notLastIt.next()); [EOL]         assertFalse(notLastIt.hasNext()); [EOL]         try { [EOL]             notLastIt.next(); [EOL]             fail("Should throw NoSuchElementException"); [EOL]         } catch (final NoSuchElementException e) { [EOL]             assertTrue(true); [EOL]         } [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testIterator() { [EOL]         final CharRange a = CharRange.is('a'); [EOL]         final CharRange ad = CharRange.isIn('a', 'd'); [EOL]         final CharRange nota = CharRange.isNot('a'); [EOL]         final CharRange emptySet = CharRange.isNotIn((char) 0, Character.MAX_VALUE); [EOL]         final CharRange notFirst = CharRange.isNotIn((char) 1, Character.MAX_VALUE); [EOL]         final CharRange notLast = CharRange.isNotIn((char) 0, (char) (Character.MAX_VALUE - 1)); [EOL]  [EOL]         final Iterator<Character> aIt = a.iterator(); [EOL]         assertNotNull(aIt); [EOL]         assertTrue(aIt.hasNext()); [EOL]         assertEquals(Character.valueOf('a'), aIt.next()); [EOL]         assertFalse(aIt.hasNext()); [EOL]  [EOL]         final Iterator<Character> adIt = ad.iterator(); [EOL]         assertNotNull(adIt); [EOL]         assertTrue(adIt.hasNext()); [EOL]         assertEquals(Character.valueOf('a'), adIt.next()); [EOL]         assertEquals(Character.valueOf('b'), adIt.next()); [EOL]         assertEquals(Character.valueOf('c'), adIt.next()); [EOL]         assertEquals(Character.valueOf('d'), adIt.next()); [EOL]         assertFalse(adIt.hasNext()); [EOL]  [EOL]         final Iterator<Character> notaIt = nota.iterator(); [EOL]         assertNotNull(notaIt); [EOL]         assertTrue(notaIt.hasNext()); [EOL]         while (notaIt.hasNext()) { [EOL]             final Character c = notaIt.next(); [EOL]             assertFalse('a' == c.charValue()); [EOL]         } [EOL]  [EOL]         final Iterator<Character> emptySetIt = emptySet.iterator(); [EOL]         assertNotNull(emptySetIt); [EOL]         assertFalse(emptySetIt.hasNext()); [EOL]         try { [EOL]             emptySetIt.next(); [EOL]             fail("Should throw NoSuchElementException"); [EOL]         } catch (final NoSuchElementException e) { [EOL]             assertTrue(true); [EOL]         } [EOL]  [EOL]         final Iterator<Character> notFirstIt = notFirst.iterator(); [EOL]         assertNotNull(notFirstIt); [EOL]         assertTrue(notFirstIt.hasNext()); [EOL]         assertEquals(Character.valueOf((char) 0), notFirstIt.next()); [EOL]         assertFalse(notFirstIt.hasNext()); [EOL]         try { [EOL]             notFirstIt.next(); [EOL]             fail("Should throw NoSuchElementException"); [EOL]         } catch (final NoSuchElementException e) { [EOL]             assertTrue(true); [EOL]         } [EOL]  [EOL]         final Iterator<Character> notLastIt = notLast.iterator(); [EOL]         assertNotNull(notLastIt); [EOL]         assertTrue(notLastIt.hasNext()); [EOL]         assertEquals(Character.valueOf(Character.MAX_VALUE), notLastIt.next()); [EOL]         assertFalse(notLastIt.hasNext()); [EOL]         try { [EOL]             notLastIt.next(); [EOL]             fail("Should throw NoSuchElementException"); [EOL]         } catch (final NoSuchElementException e) { [EOL]             assertTrue(true); [EOL]         } [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testReadField() throws Exception { [EOL]         final Field parentS = FieldUtils.getDeclaredField(parentClass, "s"); [EOL]         assertEquals("s", FieldUtils.readField(parentS, publicChild)); [EOL]         assertEquals("s", FieldUtils.readField(parentS, publiclyShadowedChild)); [EOL]         assertEquals("s", FieldUtils.readField(parentS, privatelyShadowedChild)); [EOL]         final Field parentB = FieldUtils.getDeclaredField(parentClass, "b", true); [EOL]         assertEquals(Boolean.FALSE, FieldUtils.readField(parentB, publicChild)); [EOL]         assertEquals(Boolean.FALSE, FieldUtils.readField(parentB, publiclyShadowedChild)); [EOL]         assertEquals(Boolean.FALSE, FieldUtils.readField(parentB, privatelyShadowedChild)); [EOL]         final Field parentI = FieldUtils.getDeclaredField(parentClass, "i", true); [EOL]         assertEquals(I0, FieldUtils.readField(parentI, publicChild)); [EOL]         assertEquals(I0, FieldUtils.readField(parentI, publiclyShadowedChild)); [EOL]         assertEquals(I0, FieldUtils.readField(parentI, privatelyShadowedChild)); [EOL]         final Field parentD = FieldUtils.getDeclaredField(parentClass, "d", true); [EOL]         assertEquals(D0, FieldUtils.readField(parentD, publicChild)); [EOL]         assertEquals(D0, FieldUtils.readField(parentD, publiclyShadowedChild)); [EOL]         assertEquals(D0, FieldUtils.readField(parentD, privatelyShadowedChild)); [EOL]  [EOL]         try { [EOL]             FieldUtils.readField((Field) null, publicChild); [EOL]             fail("a null field should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReadField() throws Exception { [EOL]         final Field parentS = FieldUtils.getDeclaredField(parentClass, "s"); [EOL]         assertEquals("s", FieldUtils.readField(parentS, publicChild)); [EOL]         assertEquals("s", FieldUtils.readField(parentS, publiclyShadowedChild)); [EOL]         assertEquals("s", FieldUtils.readField(parentS, privatelyShadowedChild)); [EOL]         final Field parentB = FieldUtils.getDeclaredField(parentClass, "b", true); [EOL]         assertEquals(Boolean.FALSE, FieldUtils.readField(parentB, publicChild)); [EOL]         assertEquals(Boolean.FALSE, FieldUtils.readField(parentB, publiclyShadowedChild)); [EOL]         assertEquals(Boolean.FALSE, FieldUtils.readField(parentB, privatelyShadowedChild)); [EOL]         final Field parentI = FieldUtils.getDeclaredField(parentClass, "i", true); [EOL]         assertEquals(I0, FieldUtils.readField(parentI, publicChild)); [EOL]         assertEquals(I0, FieldUtils.readField(parentI, publiclyShadowedChild)); [EOL]         assertEquals(I0, FieldUtils.readField(parentI, privatelyShadowedChild)); [EOL]         final Field parentD = FieldUtils.getDeclaredField(parentClass, "d", true); [EOL]         assertEquals(D0, FieldUtils.readField(parentD, publicChild)); [EOL]         assertEquals(D0, FieldUtils.readField(parentD, publiclyShadowedChild)); [EOL]         assertEquals(D0, FieldUtils.readField(parentD, privatelyShadowedChild)); [EOL]  [EOL]         try { [EOL]             FieldUtils.readField((Field) null, publicChild); [EOL]             fail("a null field should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testInvokeMethod() throws Exception { [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 (Object[]) ArrayUtils.EMPTY_CLASS_ARRAY)); [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 (Object[]) null)); [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo",  [EOL]                 (Object[]) null, (Class<?>[]) null)); [EOL]         assertEquals("foo(String)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 "")); [EOL]         assertEquals("foo(Object)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 new Object())); [EOL]         assertEquals("foo(Object)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 Boolean.TRUE)); [EOL]         assertEquals("foo(Integer)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.INTEGER_ONE)); [EOL]         assertEquals("foo(int)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.BYTE_ONE)); [EOL]         assertEquals("foo(double)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.LONG_ONE)); [EOL]         assertEquals("foo(double)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.DOUBLE_ONE)); [EOL]     } [EOL]  [EOL]
@Test [EOL]    public void testGetMatchingAccessibleMethod() throws Exception { [EOL]         expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo", [EOL]                 ArrayUtils.EMPTY_CLASS_ARRAY, ArrayUtils.EMPTY_CLASS_ARRAY); [EOL]         expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo", [EOL]                 null, ArrayUtils.EMPTY_CLASS_ARRAY); [EOL]         expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo", [EOL]                 singletonArray(String.class), singletonArray(String.class)); [EOL]         expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo", [EOL]                 singletonArray(Object.class), singletonArray(Object.class)); [EOL]         expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo", [EOL]                 singletonArray(Boolean.class), singletonArray(Object.class)); [EOL]         expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo", [EOL]                 singletonArray(Byte.class), singletonArray(Integer.TYPE)); [EOL]         expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo", [EOL]                 singletonArray(Byte.TYPE), singletonArray(Integer.TYPE)); [EOL]         expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo", [EOL]                 singletonArray(Short.class), singletonArray(Integer.TYPE)); [EOL]         expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo", [EOL]                 singletonArray(Short.TYPE), singletonArray(Integer.TYPE)); [EOL]         expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo", [EOL]                 singletonArray(Character.class), singletonArray(Integer.TYPE)); [EOL]         expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo", [EOL]                 singletonArray(Character.TYPE), singletonArray(Integer.TYPE)); [EOL]         expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo", [EOL]                 singletonArray(Integer.class), singletonArray(Integer.class)); [EOL]         expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo", [EOL]                 singletonArray(Integer.TYPE), singletonArray(Integer.TYPE)); [EOL]         expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo", [EOL]                 singletonArray(Long.class), singletonArray(Double.TYPE)); [EOL]         expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo", [EOL]                 singletonArray(Long.TYPE), singletonArray(Double.TYPE)); [EOL]         expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo", [EOL]                 singletonArray(Float.class), singletonArray(Double.TYPE)); [EOL]         expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo", [EOL]                 singletonArray(Float.TYPE), singletonArray(Double.TYPE)); [EOL]         expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo", [EOL]                 singletonArray(Double.class), singletonArray(Double.TYPE)); [EOL]         expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo", [EOL]                 singletonArray(Double.TYPE), singletonArray(Double.TYPE)); [EOL]         expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo", [EOL]                 singletonArray(Double.TYPE), singletonArray(Double.TYPE)); [EOL]         expectMatchingAccessibleMethodParameterTypes(InheritanceBean.class, "testOne", [EOL]                 singletonArray(ParentObject.class), singletonArray(ParentObject.class)); [EOL]         expectMatchingAccessibleMethodParameterTypes(InheritanceBean.class, "testOne", [EOL]                 singletonArray(ChildObject.class), singletonArray(ParentObject.class)); [EOL]         expectMatchingAccessibleMethodParameterTypes(InheritanceBean.class, "testTwo", [EOL]                 singletonArray(ParentObject.class), singletonArray(GrandParentObject.class)); [EOL]         expectMatchingAccessibleMethodParameterTypes(InheritanceBean.class, "testTwo", [EOL]                 singletonArray(ChildObject.class), singletonArray(ChildInterface.class)); [EOL]     } [EOL]  [EOL]
@Test [EOL]    public void testGetMatchingAccessibleMethod() throws Exception { [EOL]         expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo", [EOL]                 ArrayUtils.EMPTY_CLASS_ARRAY, ArrayUtils.EMPTY_CLASS_ARRAY); [EOL]         expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo", [EOL]                 null, ArrayUtils.EMPTY_CLASS_ARRAY); [EOL]         expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo", [EOL]                 singletonArray(String.class), singletonArray(String.class)); [EOL]         expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo", [EOL]                 singletonArray(Object.class), singletonArray(Object.class)); [EOL]         expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo", [EOL]                 singletonArray(Boolean.class), singletonArray(Object.class)); [EOL]         expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo", [EOL]                 singletonArray(Byte.class), singletonArray(Integer.TYPE)); [EOL]         expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo", [EOL]                 singletonArray(Byte.TYPE), singletonArray(Integer.TYPE)); [EOL]         expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo", [EOL]                 singletonArray(Short.class), singletonArray(Integer.TYPE)); [EOL]         expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo", [EOL]                 singletonArray(Short.TYPE), singletonArray(Integer.TYPE)); [EOL]         expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo", [EOL]                 singletonArray(Character.class), singletonArray(Integer.TYPE)); [EOL]         expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo", [EOL]                 singletonArray(Character.TYPE), singletonArray(Integer.TYPE)); [EOL]         expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo", [EOL]                 singletonArray(Integer.class), singletonArray(Integer.class)); [EOL]         expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo", [EOL]                 singletonArray(Integer.TYPE), singletonArray(Integer.TYPE)); [EOL]         expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo", [EOL]                 singletonArray(Long.class), singletonArray(Double.TYPE)); [EOL]         expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo", [EOL]                 singletonArray(Long.TYPE), singletonArray(Double.TYPE)); [EOL]         expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo", [EOL]                 singletonArray(Float.class), singletonArray(Double.TYPE)); [EOL]         expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo", [EOL]                 singletonArray(Float.TYPE), singletonArray(Double.TYPE)); [EOL]         expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo", [EOL]                 singletonArray(Double.class), singletonArray(Double.TYPE)); [EOL]         expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo", [EOL]                 singletonArray(Double.TYPE), singletonArray(Double.TYPE)); [EOL]         expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo", [EOL]                 singletonArray(Double.TYPE), singletonArray(Double.TYPE)); [EOL]         expectMatchingAccessibleMethodParameterTypes(InheritanceBean.class, "testOne", [EOL]                 singletonArray(ParentObject.class), singletonArray(ParentObject.class)); [EOL]         expectMatchingAccessibleMethodParameterTypes(InheritanceBean.class, "testOne", [EOL]                 singletonArray(ChildObject.class), singletonArray(ParentObject.class)); [EOL]         expectMatchingAccessibleMethodParameterTypes(InheritanceBean.class, "testTwo", [EOL]                 singletonArray(ParentObject.class), singletonArray(GrandParentObject.class)); [EOL]         expectMatchingAccessibleMethodParameterTypes(InheritanceBean.class, "testTwo", [EOL]                 singletonArray(ChildObject.class), singletonArray(ChildInterface.class)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testInvokeMethod() throws Exception { [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 (Object[]) ArrayUtils.EMPTY_CLASS_ARRAY)); [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 (Object[]) null)); [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo",  [EOL]                 (Object[]) null, (Class<?>[]) null)); [EOL]         assertEquals("foo(String)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 "")); [EOL]         assertEquals("foo(Object)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 new Object())); [EOL]         assertEquals("foo(Object)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 Boolean.TRUE)); [EOL]         assertEquals("foo(Integer)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.INTEGER_ONE)); [EOL]         assertEquals("foo(int)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.BYTE_ONE)); [EOL]         assertEquals("foo(double)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.LONG_ONE)); [EOL]         assertEquals("foo(double)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.DOUBLE_ONE)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testInvokeMethod() throws Exception { [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 (Object[]) ArrayUtils.EMPTY_CLASS_ARRAY)); [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 (Object[]) null)); [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo",  [EOL]                 (Object[]) null, (Class<?>[]) null)); [EOL]         assertEquals("foo(String)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 "")); [EOL]         assertEquals("foo(Object)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 new Object())); [EOL]         assertEquals("foo(Object)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 Boolean.TRUE)); [EOL]         assertEquals("foo(Integer)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.INTEGER_ONE)); [EOL]         assertEquals("foo(int)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.BYTE_ONE)); [EOL]         assertEquals("foo(double)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.LONG_ONE)); [EOL]         assertEquals("foo(double)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.DOUBLE_ONE)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testInvokeMethod() throws Exception { [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 (Object[]) ArrayUtils.EMPTY_CLASS_ARRAY)); [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 (Object[]) null)); [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo",  [EOL]                 (Object[]) null, (Class<?>[]) null)); [EOL]         assertEquals("foo(String)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 "")); [EOL]         assertEquals("foo(Object)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 new Object())); [EOL]         assertEquals("foo(Object)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 Boolean.TRUE)); [EOL]         assertEquals("foo(Integer)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.INTEGER_ONE)); [EOL]         assertEquals("foo(int)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.BYTE_ONE)); [EOL]         assertEquals("foo(double)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.LONG_ONE)); [EOL]         assertEquals("foo(double)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.DOUBLE_ONE)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testInvokeMethod() throws Exception { [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 (Object[]) ArrayUtils.EMPTY_CLASS_ARRAY)); [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 (Object[]) null)); [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo",  [EOL]                 (Object[]) null, (Class<?>[]) null)); [EOL]         assertEquals("foo(String)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 "")); [EOL]         assertEquals("foo(Object)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 new Object())); [EOL]         assertEquals("foo(Object)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 Boolean.TRUE)); [EOL]         assertEquals("foo(Integer)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.INTEGER_ONE)); [EOL]         assertEquals("foo(int)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.BYTE_ONE)); [EOL]         assertEquals("foo(double)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.LONG_ONE)); [EOL]         assertEquals("foo(double)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.DOUBLE_ONE)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testInvokeMethod() throws Exception { [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 (Object[]) ArrayUtils.EMPTY_CLASS_ARRAY)); [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 (Object[]) null)); [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo",  [EOL]                 (Object[]) null, (Class<?>[]) null)); [EOL]         assertEquals("foo(String)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 "")); [EOL]         assertEquals("foo(Object)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 new Object())); [EOL]         assertEquals("foo(Object)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 Boolean.TRUE)); [EOL]         assertEquals("foo(Integer)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.INTEGER_ONE)); [EOL]         assertEquals("foo(int)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.BYTE_ONE)); [EOL]         assertEquals("foo(double)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.LONG_ONE)); [EOL]         assertEquals("foo(double)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.DOUBLE_ONE)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testInvokeMethod() throws Exception { [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 (Object[]) ArrayUtils.EMPTY_CLASS_ARRAY)); [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 (Object[]) null)); [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo",  [EOL]                 (Object[]) null, (Class<?>[]) null)); [EOL]         assertEquals("foo(String)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 "")); [EOL]         assertEquals("foo(Object)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 new Object())); [EOL]         assertEquals("foo(Object)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 Boolean.TRUE)); [EOL]         assertEquals("foo(Integer)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.INTEGER_ONE)); [EOL]         assertEquals("foo(int)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.BYTE_ONE)); [EOL]         assertEquals("foo(double)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.LONG_ONE)); [EOL]         assertEquals("foo(double)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.DOUBLE_ONE)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testInvokeMethod() throws Exception { [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 (Object[]) ArrayUtils.EMPTY_CLASS_ARRAY)); [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 (Object[]) null)); [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo",  [EOL]                 (Object[]) null, (Class<?>[]) null)); [EOL]         assertEquals("foo(String)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 "")); [EOL]         assertEquals("foo(Object)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 new Object())); [EOL]         assertEquals("foo(Object)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 Boolean.TRUE)); [EOL]         assertEquals("foo(Integer)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.INTEGER_ONE)); [EOL]         assertEquals("foo(int)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.BYTE_ONE)); [EOL]         assertEquals("foo(double)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.LONG_ONE)); [EOL]         assertEquals("foo(double)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.DOUBLE_ONE)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testInvokeMethod() throws Exception { [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 (Object[]) ArrayUtils.EMPTY_CLASS_ARRAY)); [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 (Object[]) null)); [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo",  [EOL]                 (Object[]) null, (Class<?>[]) null)); [EOL]         assertEquals("foo(String)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 "")); [EOL]         assertEquals("foo(Object)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 new Object())); [EOL]         assertEquals("foo(Object)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 Boolean.TRUE)); [EOL]         assertEquals("foo(Integer)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.INTEGER_ONE)); [EOL]         assertEquals("foo(int)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.BYTE_ONE)); [EOL]         assertEquals("foo(double)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.LONG_ONE)); [EOL]         assertEquals("foo(double)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.DOUBLE_ONE)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testInvokeMethod() throws Exception { [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 (Object[]) ArrayUtils.EMPTY_CLASS_ARRAY)); [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 (Object[]) null)); [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo",  [EOL]                 (Object[]) null, (Class<?>[]) null)); [EOL]         assertEquals("foo(String)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 "")); [EOL]         assertEquals("foo(Object)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 new Object())); [EOL]         assertEquals("foo(Object)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 Boolean.TRUE)); [EOL]         assertEquals("foo(Integer)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.INTEGER_ONE)); [EOL]         assertEquals("foo(int)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.BYTE_ONE)); [EOL]         assertEquals("foo(double)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.LONG_ONE)); [EOL]         assertEquals("foo(double)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.DOUBLE_ONE)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testInvokeMethod() throws Exception { [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 (Object[]) ArrayUtils.EMPTY_CLASS_ARRAY)); [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 (Object[]) null)); [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo",  [EOL]                 (Object[]) null, (Class<?>[]) null)); [EOL]         assertEquals("foo(String)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 "")); [EOL]         assertEquals("foo(Object)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 new Object())); [EOL]         assertEquals("foo(Object)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 Boolean.TRUE)); [EOL]         assertEquals("foo(Integer)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.INTEGER_ONE)); [EOL]         assertEquals("foo(int)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.BYTE_ONE)); [EOL]         assertEquals("foo(double)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.LONG_ONE)); [EOL]         assertEquals("foo(double)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.DOUBLE_ONE)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testInvokeMethod() throws Exception { [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 (Object[]) ArrayUtils.EMPTY_CLASS_ARRAY)); [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 (Object[]) null)); [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo",  [EOL]                 (Object[]) null, (Class<?>[]) null)); [EOL]         assertEquals("foo(String)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 "")); [EOL]         assertEquals("foo(Object)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 new Object())); [EOL]         assertEquals("foo(Object)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 Boolean.TRUE)); [EOL]         assertEquals("foo(Integer)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.INTEGER_ONE)); [EOL]         assertEquals("foo(int)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.BYTE_ONE)); [EOL]         assertEquals("foo(double)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.LONG_ONE)); [EOL]         assertEquals("foo(double)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.DOUBLE_ONE)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testInvokeMethod() throws Exception { [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 (Object[]) ArrayUtils.EMPTY_CLASS_ARRAY)); [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 (Object[]) null)); [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo",  [EOL]                 (Object[]) null, (Class<?>[]) null)); [EOL]         assertEquals("foo(String)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 "")); [EOL]         assertEquals("foo(Object)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 new Object())); [EOL]         assertEquals("foo(Object)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 Boolean.TRUE)); [EOL]         assertEquals("foo(Integer)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.INTEGER_ONE)); [EOL]         assertEquals("foo(int)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.BYTE_ONE)); [EOL]         assertEquals("foo(double)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.LONG_ONE)); [EOL]         assertEquals("foo(double)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.DOUBLE_ONE)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEscapeSurrogatePairsLang858() throws Exception { [EOL]         assertEquals("\\uDBFF\\uDFFD", StringEscapeUtils.escapeJava("\uDBFF\uDFFD"));       //fail LANG-858 [EOL]         assertEquals("\\uDBFF\\uDFFD", StringEscapeUtils.escapeEcmaScript("\uDBFF\uDFFD")); //fail LANG-858 [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testDeserializeStreamClassNotFound() throws Exception { [EOL]         final ByteArrayOutputStream streamReal = new ByteArrayOutputStream(); [EOL]         final ObjectOutputStream oos = new ObjectOutputStream(streamReal); [EOL]         oos.writeObject(new ClassNotFoundSerialization()); [EOL]         oos.flush(); [EOL]         oos.close(); [EOL]  [EOL]         final ByteArrayInputStream inTest = new ByteArrayInputStream(streamReal.toByteArray()); [EOL]         try { [EOL]             @SuppressWarnings("unused") [EOL]             final [EOL]             Object test = SerializationUtils.deserialize(inTest); [EOL]         } catch(final SerializationException se) { [EOL]             assertEquals("java.lang.ClassNotFoundException: " + CLASS_NOT_FOUND_MESSAGE, se.getMessage()); [EOL]         } [EOL]     } [EOL]      [EOL]     //----------------------------------------------------------------------- [EOL]  [EOL]
@Test [EOL]     public void testPrimitiveTypeClassSerialization() { [EOL]         final Class<?>[] primitiveTypes = { byte.class, short.class, int.class, long.class, float.class, double.class, [EOL]                 boolean.class, char.class, void.class }; [EOL]  [EOL]         for (final Class<?> primitiveType : primitiveTypes) { [EOL]             final Class<?> clone = SerializationUtils.clone(primitiveType); [EOL]             assertEquals(primitiveType, clone); [EOL]         } [EOL]     } [EOL]  [EOL] } [EOL]  [EOL] @SuppressWarnings("serial") [EOL] class ClassNotFoundSerialization implements Serializable [EOL] { [EOL]  [EOL]     private void readObject(final ObjectInputStream in) throws ClassNotFoundException    { [EOL]         throw new ClassNotFoundException(SerializationUtilsTest.CLASS_NOT_FOUND_MESSAGE); [EOL]     } [EOL] } [EOL]
@Test [EOL]     public void testPrimitiveTypeClassSerialization() { [EOL]         final Class<?>[] primitiveTypes = { byte.class, short.class, int.class, long.class, float.class, double.class, [EOL]                 boolean.class, char.class, void.class }; [EOL]  [EOL]         for (final Class<?> primitiveType : primitiveTypes) { [EOL]             final Class<?> clone = SerializationUtils.clone(primitiveType); [EOL]             assertEquals(primitiveType, clone); [EOL]         } [EOL]     } [EOL]  [EOL] } [EOL]  [EOL] @SuppressWarnings("serial") [EOL] class ClassNotFoundSerialization implements Serializable [EOL] { [EOL]  [EOL]     private void readObject(final ObjectInputStream in) throws ClassNotFoundException    { [EOL]         throw new ClassNotFoundException(SerializationUtilsTest.CLASS_NOT_FOUND_MESSAGE); [EOL]     } [EOL] } [EOL]
@Test [EOL]     public void testPrimitiveTypeClassSerialization() { [EOL]         final Class<?>[] primitiveTypes = { byte.class, short.class, int.class, long.class, float.class, double.class, [EOL]                 boolean.class, char.class, void.class }; [EOL]  [EOL]         for (final Class<?> primitiveType : primitiveTypes) { [EOL]             final Class<?> clone = SerializationUtils.clone(primitiveType); [EOL]             assertEquals(primitiveType, clone); [EOL]         } [EOL]     } [EOL]  [EOL] } [EOL]  [EOL] @SuppressWarnings("serial") [EOL] class ClassNotFoundSerialization implements Serializable [EOL] { [EOL]  [EOL]     private void readObject(final ObjectInputStream in) throws ClassNotFoundException    { [EOL]         throw new ClassNotFoundException(SerializationUtilsTest.CLASS_NOT_FOUND_MESSAGE); [EOL]     } [EOL] } [EOL]
@Test [EOL]     public void testPrimitiveTypeClassSerialization() { [EOL]         final Class<?>[] primitiveTypes = { byte.class, short.class, int.class, long.class, float.class, double.class, [EOL]                 boolean.class, char.class, void.class }; [EOL]  [EOL]         for (final Class<?> primitiveType : primitiveTypes) { [EOL]             final Class<?> clone = SerializationUtils.clone(primitiveType); [EOL]             assertEquals(primitiveType, clone); [EOL]         } [EOL]     } [EOL]  [EOL] } [EOL]  [EOL] @SuppressWarnings("serial") [EOL] class ClassNotFoundSerialization implements Serializable [EOL] { [EOL]  [EOL]     private void readObject(final ObjectInputStream in) throws ClassNotFoundException    { [EOL]         throw new ClassNotFoundException(SerializationUtilsTest.CLASS_NOT_FOUND_MESSAGE); [EOL]     } [EOL] } [EOL]
@Test [EOL]     public void testPrimitiveTypeClassSerialization() { [EOL]         final Class<?>[] primitiveTypes = { byte.class, short.class, int.class, long.class, float.class, double.class, [EOL]                 boolean.class, char.class, void.class }; [EOL]  [EOL]         for (final Class<?> primitiveType : primitiveTypes) { [EOL]             final Class<?> clone = SerializationUtils.clone(primitiveType); [EOL]             assertEquals(primitiveType, clone); [EOL]         } [EOL]     } [EOL]  [EOL] } [EOL]  [EOL] @SuppressWarnings("serial") [EOL] class ClassNotFoundSerialization implements Serializable [EOL] { [EOL]  [EOL]     private void readObject(final ObjectInputStream in) throws ClassNotFoundException    { [EOL]         throw new ClassNotFoundException(SerializationUtilsTest.CLASS_NOT_FOUND_MESSAGE); [EOL]     } [EOL] } [EOL]
@Test [EOL]     public void test_toStringExclude() { [EOL]         final String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), SECRET_FIELD); [EOL]         this.validateSecretFieldAbsent(toString); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void test_toStringExclude() { [EOL]         final String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), SECRET_FIELD); [EOL]         this.validateSecretFieldAbsent(toString); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReflectionFloatArray() { [EOL]         float[] array = new float[] { 1.0f, 2.9876f, -3.00001f, 4.3f }; [EOL]         final String baseStr = this.toBaseString(array); [EOL]         assertEquals(baseStr + "[{1.0,2.9876,-3.00001,4.3}]", ToStringBuilder.reflectionToString(array)); [EOL]         array = null; [EOL]         assertReflectionArray("<null>", array); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReflectionFloatArray() { [EOL]         float[] array = new float[] { 1.0f, 2.9876f, -3.00001f, 4.3f }; [EOL]         final String baseStr = this.toBaseString(array); [EOL]         assertEquals(baseStr + "[{1.0,2.9876,-3.00001,4.3}]", ToStringBuilder.reflectionToString(array)); [EOL]         array = null; [EOL]         assertReflectionArray("<null>", array); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReflectionFloatArray() { [EOL]         float[] array = new float[] { 1.0f, 2.9876f, -3.00001f, 4.3f }; [EOL]         final String baseStr = this.toBaseString(array); [EOL]         assertEquals(baseStr + "[{1.0,2.9876,-3.00001,4.3}]", ToStringBuilder.reflectionToString(array)); [EOL]         array = null; [EOL]         assertReflectionArray("<null>", array); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetConcurrent() throws ConcurrentException, [EOL]             InterruptedException { [EOL]         final ConcurrentInitializer<Object> initializer = createInitializer(); [EOL]         final int threadCount = 20; [EOL]         final CountDownLatch startLatch = new CountDownLatch(1); [EOL]         class GetThread extends Thread { [EOL]             Object object; [EOL]  [EOL]             @Override [EOL]             public void run() { [EOL]                 try { [EOL]                     // wait until all threads are ready for maximum parallelism [EOL]                     startLatch.await(); [EOL]                     // access the initializer [EOL]                     object = initializer.get(); [EOL]                 } catch (final InterruptedException iex) { [EOL]                     // ignore [EOL]                 } catch (final ConcurrentException cex) { [EOL]                     object = cex; [EOL]                 } [EOL]             } [EOL]         } [EOL]  [EOL]         final GetThread[] threads = new GetThread[threadCount]; [EOL]         for (int i = 0; i < threadCount; i++) { [EOL]             threads[i] = new GetThread(); [EOL]             threads[i].start(); [EOL]         } [EOL]  [EOL]         // fire all threads and wait until they are ready [EOL]         startLatch.countDown(); [EOL]         for (final Thread t : threads) { [EOL]             t.join(); [EOL]         } [EOL]  [EOL]         // check results [EOL]         final Object managedObject = initializer.get(); [EOL]         for (final GetThread t : threads) { [EOL]             assertEquals("Wrong object", managedObject, t.object); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Creates the {@link ConcurrentInitializer} object to be tested. This [EOL]      * method is called whenever the test fixture needs to be obtained. [EOL]      * [EOL]      * @return the initializer object to be tested [EOL]      */ [EOL]     protected abstract ConcurrentInitializer<Object> createInitializer(); [EOL] } [EOL]
@Test [EOL]     public void testGetConcurrent() throws ConcurrentException, [EOL]             InterruptedException { [EOL]         final ConcurrentInitializer<Object> initializer = createInitializer(); [EOL]         final int threadCount = 20; [EOL]         final CountDownLatch startLatch = new CountDownLatch(1); [EOL]         class GetThread extends Thread { [EOL]             Object object; [EOL]  [EOL]             @Override [EOL]             public void run() { [EOL]                 try { [EOL]                     // wait until all threads are ready for maximum parallelism [EOL]                     startLatch.await(); [EOL]                     // access the initializer [EOL]                     object = initializer.get(); [EOL]                 } catch (final InterruptedException iex) { [EOL]                     // ignore [EOL]                 } catch (final ConcurrentException cex) { [EOL]                     object = cex; [EOL]                 } [EOL]             } [EOL]         } [EOL]  [EOL]         final GetThread[] threads = new GetThread[threadCount]; [EOL]         for (int i = 0; i < threadCount; i++) { [EOL]             threads[i] = new GetThread(); [EOL]             threads[i].start(); [EOL]         } [EOL]  [EOL]         // fire all threads and wait until they are ready [EOL]         startLatch.countDown(); [EOL]         for (final Thread t : threads) { [EOL]             t.join(); [EOL]         } [EOL]  [EOL]         // check results [EOL]         final Object managedObject = initializer.get(); [EOL]         for (final GetThread t : threads) { [EOL]             assertEquals("Wrong object", managedObject, t.object); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Creates the {@link ConcurrentInitializer} object to be tested. This [EOL]      * method is called whenever the test fixture needs to be obtained. [EOL]      * [EOL]      * @return the initializer object to be tested [EOL]      */ [EOL]     protected abstract ConcurrentInitializer<Object> createInitializer(); [EOL] } [EOL]
@Test [EOL]     public void testGetConcurrent() throws ConcurrentException, [EOL]             InterruptedException { [EOL]         final ConcurrentInitializer<Object> initializer = createInitializer(); [EOL]         final int threadCount = 20; [EOL]         final CountDownLatch startLatch = new CountDownLatch(1); [EOL]         class GetThread extends Thread { [EOL]             Object object; [EOL]  [EOL]             @Override [EOL]             public void run() { [EOL]                 try { [EOL]                     // wait until all threads are ready for maximum parallelism [EOL]                     startLatch.await(); [EOL]                     // access the initializer [EOL]                     object = initializer.get(); [EOL]                 } catch (final InterruptedException iex) { [EOL]                     // ignore [EOL]                 } catch (final ConcurrentException cex) { [EOL]                     object = cex; [EOL]                 } [EOL]             } [EOL]         } [EOL]  [EOL]         final GetThread[] threads = new GetThread[threadCount]; [EOL]         for (int i = 0; i < threadCount; i++) { [EOL]             threads[i] = new GetThread(); [EOL]             threads[i].start(); [EOL]         } [EOL]  [EOL]         // fire all threads and wait until they are ready [EOL]         startLatch.countDown(); [EOL]         for (final Thread t : threads) { [EOL]             t.join(); [EOL]         } [EOL]  [EOL]         // check results [EOL]         final Object managedObject = initializer.get(); [EOL]         for (final GetThread t : threads) { [EOL]             assertEquals("Wrong object", managedObject, t.object); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Creates the {@link ConcurrentInitializer} object to be tested. This [EOL]      * method is called whenever the test fixture needs to be obtained. [EOL]      * [EOL]      * @return the initializer object to be tested [EOL]      */ [EOL]     protected abstract ConcurrentInitializer<Object> createInitializer(); [EOL] } [EOL]
@Test [EOL]     public void testGetConcurrent() throws ConcurrentException, [EOL]             InterruptedException { [EOL]         final ConcurrentInitializer<Object> initializer = createInitializer(); [EOL]         final int threadCount = 20; [EOL]         final CountDownLatch startLatch = new CountDownLatch(1); [EOL]         class GetThread extends Thread { [EOL]             Object object; [EOL]  [EOL]             @Override [EOL]             public void run() { [EOL]                 try { [EOL]                     // wait until all threads are ready for maximum parallelism [EOL]                     startLatch.await(); [EOL]                     // access the initializer [EOL]                     object = initializer.get(); [EOL]                 } catch (final InterruptedException iex) { [EOL]                     // ignore [EOL]                 } catch (final ConcurrentException cex) { [EOL]                     object = cex; [EOL]                 } [EOL]             } [EOL]         } [EOL]  [EOL]         final GetThread[] threads = new GetThread[threadCount]; [EOL]         for (int i = 0; i < threadCount; i++) { [EOL]             threads[i] = new GetThread(); [EOL]             threads[i].start(); [EOL]         } [EOL]  [EOL]         // fire all threads and wait until they are ready [EOL]         startLatch.countDown(); [EOL]         for (final Thread t : threads) { [EOL]             t.join(); [EOL]         } [EOL]  [EOL]         // check results [EOL]         final Object managedObject = initializer.get(); [EOL]         for (final GetThread t : threads) { [EOL]             assertEquals("Wrong object", managedObject, t.object); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Creates the {@link ConcurrentInitializer} object to be tested. This [EOL]      * method is called whenever the test fixture needs to be obtained. [EOL]      * [EOL]      * @return the initializer object to be tested [EOL]      */ [EOL]     protected abstract ConcurrentInitializer<Object> createInitializer(); [EOL] } [EOL]
@Test [EOL]     public void testGetConcurrent() throws ConcurrentException, [EOL]             InterruptedException { [EOL]         final ConcurrentInitializer<Object> initializer = createInitializer(); [EOL]         final int threadCount = 20; [EOL]         final CountDownLatch startLatch = new CountDownLatch(1); [EOL]         class GetThread extends Thread { [EOL]             Object object; [EOL]  [EOL]             @Override [EOL]             public void run() { [EOL]                 try { [EOL]                     // wait until all threads are ready for maximum parallelism [EOL]                     startLatch.await(); [EOL]                     // access the initializer [EOL]                     object = initializer.get(); [EOL]                 } catch (final InterruptedException iex) { [EOL]                     // ignore [EOL]                 } catch (final ConcurrentException cex) { [EOL]                     object = cex; [EOL]                 } [EOL]             } [EOL]         } [EOL]  [EOL]         final GetThread[] threads = new GetThread[threadCount]; [EOL]         for (int i = 0; i < threadCount; i++) { [EOL]             threads[i] = new GetThread(); [EOL]             threads[i].start(); [EOL]         } [EOL]  [EOL]         // fire all threads and wait until they are ready [EOL]         startLatch.countDown(); [EOL]         for (final Thread t : threads) { [EOL]             t.join(); [EOL]         } [EOL]  [EOL]         // check results [EOL]         final Object managedObject = initializer.get(); [EOL]         for (final GetThread t : threads) { [EOL]             assertEquals("Wrong object", managedObject, t.object); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Creates the {@link ConcurrentInitializer} object to be tested. This [EOL]      * method is called whenever the test fixture needs to be obtained. [EOL]      * [EOL]      * @return the initializer object to be tested [EOL]      */ [EOL]     protected abstract ConcurrentInitializer<Object> createInitializer(); [EOL] } [EOL]
@Test [EOL]     public void testGetConcurrent() throws ConcurrentException, [EOL]             InterruptedException { [EOL]         final ConcurrentInitializer<Object> initializer = createInitializer(); [EOL]         final int threadCount = 20; [EOL]         final CountDownLatch startLatch = new CountDownLatch(1); [EOL]         class GetThread extends Thread { [EOL]             Object object; [EOL]  [EOL]             @Override [EOL]             public void run() { [EOL]                 try { [EOL]                     // wait until all threads are ready for maximum parallelism [EOL]                     startLatch.await(); [EOL]                     // access the initializer [EOL]                     object = initializer.get(); [EOL]                 } catch (final InterruptedException iex) { [EOL]                     // ignore [EOL]                 } catch (final ConcurrentException cex) { [EOL]                     object = cex; [EOL]                 } [EOL]             } [EOL]         } [EOL]  [EOL]         final GetThread[] threads = new GetThread[threadCount]; [EOL]         for (int i = 0; i < threadCount; i++) { [EOL]             threads[i] = new GetThread(); [EOL]             threads[i].start(); [EOL]         } [EOL]  [EOL]         // fire all threads and wait until they are ready [EOL]         startLatch.countDown(); [EOL]         for (final Thread t : threads) { [EOL]             t.join(); [EOL]         } [EOL]  [EOL]         // check results [EOL]         final Object managedObject = initializer.get(); [EOL]         for (final GetThread t : threads) { [EOL]             assertEquals("Wrong object", managedObject, t.object); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Creates the {@link ConcurrentInitializer} object to be tested. This [EOL]      * method is called whenever the test fixture needs to be obtained. [EOL]      * [EOL]      * @return the initializer object to be tested [EOL]      */ [EOL]     protected abstract ConcurrentInitializer<Object> createInitializer(); [EOL] } [EOL]
@Test [EOL]     public void testEquals() throws Exception { [EOL]         assertEquals(MutableTriple.of(null, "foo", "baz"), MutableTriple.of(null, "foo", "baz")); [EOL]         assertFalse(MutableTriple.of("foo", 0, Boolean.TRUE).equals(MutableTriple.of("foo", null, Boolean.TRUE))); [EOL]         assertFalse(MutableTriple.of("foo", "bar", "baz").equals(MutableTriple.of("xyz", "bar", "baz"))); [EOL]         assertFalse(MutableTriple.of("foo", "bar", "baz").equals(MutableTriple.of("foo", "bar", "blo"))); [EOL]  [EOL]         final MutableTriple<String, String, String> p = MutableTriple.of("foo", "bar", "baz"); [EOL]         assertTrue(p.equals(p)); [EOL]         assertFalse(p.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testToUnicodeEscaped_char() { [EOL]         assertEquals("\\u0041", CharUtils.unicodeEscaped('A')); [EOL]         [EOL]         for (int i = 0; i < 196; i++) { [EOL]             final String str = CharUtils.unicodeEscaped((char) i); [EOL]             assertEquals(6, str.length()); [EOL]             final int val = Integer.parseInt(str.substring(2), 16); [EOL]             assertEquals(i, val); [EOL]         } [EOL]         assertEquals("\\u0999", CharUtils.unicodeEscaped((char) 0x999)); [EOL]         assertEquals("\\u1001", CharUtils.unicodeEscaped((char) 0x1001)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testBasicQuotedTrimmed1() { [EOL]         final String input = "a: 'b' :"; [EOL]         final StrTokenizer tok = new StrTokenizer(input, ':', '\''); [EOL]         tok.setTrimmerMatcher(StrMatcher.trimMatcher()); [EOL]         tok.setIgnoreEmptyTokens(false); [EOL]         tok.setEmptyTokenAsNull(true); [EOL]         assertEquals("a", tok.next()); [EOL]         assertEquals("b", tok.next()); [EOL]         assertEquals(null, tok.next()); [EOL]         assertFalse(tok.hasNext()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testCloneNotSupportedException() { [EOL]         final Object notCloned = new StrTokenizer() { [EOL]             @Override [EOL]             Object cloneReset() throws CloneNotSupportedException { [EOL]                 throw new CloneNotSupportedException("test"); [EOL]             } [EOL]         }.clone(); [EOL]         assertNull(notCloned); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testAcquireLimit() throws InterruptedException { [EOL]         final ScheduledExecutorService service = EasyMock [EOL]                 .createMock(ScheduledExecutorService.class); [EOL]         final ScheduledFuture<?> future = EasyMock.createMock(ScheduledFuture.class); [EOL]         prepareStartTimer(service, future); [EOL]         EasyMock.replay(service, future); [EOL]         final int count = 10; [EOL]         final CountDownLatch latch = new CountDownLatch(count - 1); [EOL]         final TimedSemaphore semaphore = new TimedSemaphore(service, PERIOD, UNIT, 1); [EOL]         final SemaphoreThread t = new SemaphoreThread(semaphore, latch, count, [EOL]                 count - 1); [EOL]         semaphore.setLimit(count - 1); [EOL]  [EOL]         // start a thread that calls the semaphore count times [EOL]         t.start(); [EOL]         latch.await(); [EOL]         // now the semaphore's limit should be reached and the thread blocked [EOL]         assertEquals("Wrong semaphore count", count - 1, semaphore [EOL]                 .getAcquireCount()); [EOL]  [EOL]         // this wakes up the thread, it should call the semaphore once more [EOL]         semaphore.endOfPeriod(); [EOL]         t.join(); [EOL]         assertEquals("Wrong semaphore count (2)", 1, semaphore [EOL]                 .getAcquireCount()); [EOL]         assertEquals("Wrong acquire() count", count - 1, semaphore [EOL]                 .getLastAcquiresPerPeriod()); [EOL]         EasyMock.verify(service, future); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the acquire() method if more threads are involved than the limit. [EOL]      * This method starts a number of threads that all invoke the semaphore. The [EOL]      * semaphore's limit is set to 1, so in each period only a single thread can [EOL]      * acquire the semaphore. [EOL]      */ [EOL]
@Test [EOL]     public void testStartTimer() throws InterruptedException { [EOL]         final TimedSemaphoreTestImpl semaphore = new TimedSemaphoreTestImpl(PERIOD, [EOL]                 UNIT, LIMIT); [EOL]         final ScheduledFuture<?> future = semaphore.startTimer(); [EOL]         assertNotNull("No future returned", future); [EOL]         Thread.sleep(PERIOD); [EOL]         final int trials = 10; [EOL]         int count = 0; [EOL]         do { [EOL]             Thread.sleep(PERIOD); [EOL]             if (count++ > trials) { [EOL]                 fail("endOfPeriod() not called!"); [EOL]             } [EOL]         } while (semaphore.getPeriodEnds() <= 0); [EOL]         semaphore.shutdown(); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the shutdown() method if the executor belongs to the semaphore. In [EOL]      * this case it has to be shut down. [EOL]      */ [EOL]
@Test [EOL]     public void testStartTimer() throws InterruptedException { [EOL]         final TimedSemaphoreTestImpl semaphore = new TimedSemaphoreTestImpl(PERIOD, [EOL]                 UNIT, LIMIT); [EOL]         final ScheduledFuture<?> future = semaphore.startTimer(); [EOL]         assertNotNull("No future returned", future); [EOL]         Thread.sleep(PERIOD); [EOL]         final int trials = 10; [EOL]         int count = 0; [EOL]         do { [EOL]             Thread.sleep(PERIOD); [EOL]             if (count++ > trials) { [EOL]                 fail("endOfPeriod() not called!"); [EOL]             } [EOL]         } while (semaphore.getPeriodEnds() <= 0); [EOL]         semaphore.shutdown(); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the shutdown() method if the executor belongs to the semaphore. In [EOL]      * this case it has to be shut down. [EOL]      */ [EOL]
@Test [EOL]     public void testInitializeUncheckedEx() throws ConcurrentException { [EOL]         @SuppressWarnings("unchecked") [EOL]         final [EOL]         ConcurrentInitializer<Object> init = EasyMock [EOL]                 .createMock(ConcurrentInitializer.class); [EOL]         final Exception cause = new Exception(); [EOL]         EasyMock.expect(init.get()).andThrow(new ConcurrentException(cause)); [EOL]         EasyMock.replay(init); [EOL]         try { [EOL]             ConcurrentUtils.initializeUnchecked(init); [EOL]             fail("Exception not thrown!"); [EOL]         } catch (final ConcurrentRuntimeException crex) { [EOL]             assertSame("Wrong cause", cause, crex.getCause()); [EOL]         } [EOL]         EasyMock.verify(init); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]     /** [EOL]      * Tests constant future. [EOL]      */ [EOL]
@Test [EOL]     public void testCreateIfAbsentUncheckedException() [EOL]             throws ConcurrentException { [EOL]         @SuppressWarnings("unchecked") [EOL]         final [EOL]         ConcurrentInitializer<Integer> init = EasyMock [EOL]                 .createMock(ConcurrentInitializer.class); [EOL]         final Exception ex = new Exception(); [EOL]         EasyMock.expect(init.get()).andThrow(new ConcurrentException(ex)); [EOL]         EasyMock.replay(init); [EOL]         try { [EOL]             ConcurrentUtils.createIfAbsentUnchecked( [EOL]                     new ConcurrentHashMap<String, Integer>(), "test", init); [EOL]             fail("Exception not thrown!"); [EOL]         } catch (final ConcurrentRuntimeException crex) { [EOL]             assertEquals("Wrong cause", ex, crex.getCause()); [EOL]         } [EOL]         EasyMock.verify(init); [EOL]     } [EOL] } [EOL]
@Test [EOL]     public void testNonEquivalentAnnotationsOfSameType() { [EOL]         assertFalse(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field3.getAnnotation(TestAnnotation.class))); [EOL]         assertFalse(AnnotationUtils.equals(field3.getAnnotation(TestAnnotation.class), field1.getAnnotation(TestAnnotation.class))); [EOL]     } [EOL]  [EOL]
@Test(timeout = 666000) [EOL]     public void testHashCode() throws Exception { [EOL]         final Test test = getClass().getDeclaredMethod("testHashCode").getAnnotation(Test.class); [EOL]         assertEquals(test.hashCode(), AnnotationUtils.hashCode(test)); [EOL]         final TestAnnotation testAnnotation1 = field1.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation1.hashCode(), AnnotationUtils.hashCode(testAnnotation1)); [EOL]         final TestAnnotation testAnnotation3 = field3.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation3.hashCode(), AnnotationUtils.hashCode(testAnnotation3)); [EOL]     } [EOL]  [EOL]
@Test(timeout = 666000) [EOL]     public void testHashCode() throws Exception { [EOL]         final Test test = getClass().getDeclaredMethod("testHashCode").getAnnotation(Test.class); [EOL]         assertEquals(test.hashCode(), AnnotationUtils.hashCode(test)); [EOL]         final TestAnnotation testAnnotation1 = field1.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation1.hashCode(), AnnotationUtils.hashCode(testAnnotation1)); [EOL]         final TestAnnotation testAnnotation3 = field3.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation3.hashCode(), AnnotationUtils.hashCode(testAnnotation3)); [EOL]     } [EOL]  [EOL]
@Test(timeout = 666000) [EOL]     public void testHashCode() throws Exception { [EOL]         final Test test = getClass().getDeclaredMethod("testHashCode").getAnnotation(Test.class); [EOL]         assertEquals(test.hashCode(), AnnotationUtils.hashCode(test)); [EOL]         final TestAnnotation testAnnotation1 = field1.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation1.hashCode(), AnnotationUtils.hashCode(testAnnotation1)); [EOL]         final TestAnnotation testAnnotation3 = field3.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation3.hashCode(), AnnotationUtils.hashCode(testAnnotation3)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNonEquivalentAnnotationsOfSameType() { [EOL]         assertFalse(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field3.getAnnotation(TestAnnotation.class))); [EOL]         assertFalse(AnnotationUtils.equals(field3.getAnnotation(TestAnnotation.class), field1.getAnnotation(TestAnnotation.class))); [EOL]     } [EOL]  [EOL]
@Test(timeout = 666000) [EOL]     public void testHashCode() throws Exception { [EOL]         final Test test = getClass().getDeclaredMethod("testHashCode").getAnnotation(Test.class); [EOL]         assertEquals(test.hashCode(), AnnotationUtils.hashCode(test)); [EOL]         final TestAnnotation testAnnotation1 = field1.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation1.hashCode(), AnnotationUtils.hashCode(testAnnotation1)); [EOL]         final TestAnnotation testAnnotation3 = field3.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation3.hashCode(), AnnotationUtils.hashCode(testAnnotation3)); [EOL]     } [EOL]  [EOL]
@Test(timeout = 666000) [EOL]     public void testHashCode() throws Exception { [EOL]         final Test test = getClass().getDeclaredMethod("testHashCode").getAnnotation(Test.class); [EOL]         assertEquals(test.hashCode(), AnnotationUtils.hashCode(test)); [EOL]         final TestAnnotation testAnnotation1 = field1.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation1.hashCode(), AnnotationUtils.hashCode(testAnnotation1)); [EOL]         final TestAnnotation testAnnotation3 = field3.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation3.hashCode(), AnnotationUtils.hashCode(testAnnotation3)); [EOL]     } [EOL]  [EOL]
@Test(timeout = 666000) [EOL]     public void testHashCode() throws Exception { [EOL]         final Test test = getClass().getDeclaredMethod("testHashCode").getAnnotation(Test.class); [EOL]         assertEquals(test.hashCode(), AnnotationUtils.hashCode(test)); [EOL]         final TestAnnotation testAnnotation1 = field1.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation1.hashCode(), AnnotationUtils.hashCode(testAnnotation1)); [EOL]         final TestAnnotation testAnnotation3 = field3.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation3.hashCode(), AnnotationUtils.hashCode(testAnnotation3)); [EOL]     } [EOL]  [EOL]
@Test(timeout = 666000) [EOL]     public void testHashCode() throws Exception { [EOL]         final Test test = getClass().getDeclaredMethod("testHashCode").getAnnotation(Test.class); [EOL]         assertEquals(test.hashCode(), AnnotationUtils.hashCode(test)); [EOL]         final TestAnnotation testAnnotation1 = field1.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation1.hashCode(), AnnotationUtils.hashCode(testAnnotation1)); [EOL]         final TestAnnotation testAnnotation3 = field3.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation3.hashCode(), AnnotationUtils.hashCode(testAnnotation3)); [EOL]     } [EOL]  [EOL]
@Test(timeout = 666000) [EOL]     public void testHashCode() throws Exception { [EOL]         final Test test = getClass().getDeclaredMethod("testHashCode").getAnnotation(Test.class); [EOL]         assertEquals(test.hashCode(), AnnotationUtils.hashCode(test)); [EOL]         final TestAnnotation testAnnotation1 = field1.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation1.hashCode(), AnnotationUtils.hashCode(testAnnotation1)); [EOL]         final TestAnnotation testAnnotation3 = field3.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation3.hashCode(), AnnotationUtils.hashCode(testAnnotation3)); [EOL]     } [EOL]  [EOL]
@Test(timeout = 666000) [EOL]     public void testHashCode() throws Exception { [EOL]         final Test test = getClass().getDeclaredMethod("testHashCode").getAnnotation(Test.class); [EOL]         assertEquals(test.hashCode(), AnnotationUtils.hashCode(test)); [EOL]         final TestAnnotation testAnnotation1 = field1.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation1.hashCode(), AnnotationUtils.hashCode(testAnnotation1)); [EOL]         final TestAnnotation testAnnotation3 = field3.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation3.hashCode(), AnnotationUtils.hashCode(testAnnotation3)); [EOL]     } [EOL]  [EOL]
@Test(timeout = 666000) [EOL]     public void testHashCode() throws Exception { [EOL]         final Test test = getClass().getDeclaredMethod("testHashCode").getAnnotation(Test.class); [EOL]         assertEquals(test.hashCode(), AnnotationUtils.hashCode(test)); [EOL]         final TestAnnotation testAnnotation1 = field1.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation1.hashCode(), AnnotationUtils.hashCode(testAnnotation1)); [EOL]         final TestAnnotation testAnnotation3 = field3.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation3.hashCode(), AnnotationUtils.hashCode(testAnnotation3)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNonEquivalentAnnotationsOfSameType() { [EOL]         assertFalse(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field3.getAnnotation(TestAnnotation.class))); [EOL]         assertFalse(AnnotationUtils.equals(field3.getAnnotation(TestAnnotation.class), field1.getAnnotation(TestAnnotation.class))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNonEquivalentAnnotationsOfSameType() { [EOL]         assertFalse(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field3.getAnnotation(TestAnnotation.class))); [EOL]         assertFalse(AnnotationUtils.equals(field3.getAnnotation(TestAnnotation.class), field1.getAnnotation(TestAnnotation.class))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNonEquivalentAnnotationsOfSameType() { [EOL]         assertFalse(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field3.getAnnotation(TestAnnotation.class))); [EOL]         assertFalse(AnnotationUtils.equals(field3.getAnnotation(TestAnnotation.class), field1.getAnnotation(TestAnnotation.class))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNonEquivalentAnnotationsOfSameType() { [EOL]         assertFalse(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field3.getAnnotation(TestAnnotation.class))); [EOL]         assertFalse(AnnotationUtils.equals(field3.getAnnotation(TestAnnotation.class), field1.getAnnotation(TestAnnotation.class))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNonEquivalentAnnotationsOfSameType() { [EOL]         assertFalse(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field3.getAnnotation(TestAnnotation.class))); [EOL]         assertFalse(AnnotationUtils.equals(field3.getAnnotation(TestAnnotation.class), field1.getAnnotation(TestAnnotation.class))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNonEquivalentAnnotationsOfSameType() { [EOL]         assertFalse(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field3.getAnnotation(TestAnnotation.class))); [EOL]         assertFalse(AnnotationUtils.equals(field3.getAnnotation(TestAnnotation.class), field1.getAnnotation(TestAnnotation.class))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNonEquivalentAnnotationsOfSameType() { [EOL]         assertFalse(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field3.getAnnotation(TestAnnotation.class))); [EOL]         assertFalse(AnnotationUtils.equals(field3.getAnnotation(TestAnnotation.class), field1.getAnnotation(TestAnnotation.class))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNonEquivalentAnnotationsOfSameType() { [EOL]         assertFalse(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field3.getAnnotation(TestAnnotation.class))); [EOL]         assertFalse(AnnotationUtils.equals(field3.getAnnotation(TestAnnotation.class), field1.getAnnotation(TestAnnotation.class))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNonEquivalentAnnotationsOfSameType() { [EOL]         assertFalse(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field3.getAnnotation(TestAnnotation.class))); [EOL]         assertFalse(AnnotationUtils.equals(field3.getAnnotation(TestAnnotation.class), field1.getAnnotation(TestAnnotation.class))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNonEquivalentAnnotationsOfSameType() { [EOL]         assertFalse(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field3.getAnnotation(TestAnnotation.class))); [EOL]         assertFalse(AnnotationUtils.equals(field3.getAnnotation(TestAnnotation.class), field1.getAnnotation(TestAnnotation.class))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNonEquivalentAnnotationsOfSameType() { [EOL]         assertFalse(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field3.getAnnotation(TestAnnotation.class))); [EOL]         assertFalse(AnnotationUtils.equals(field3.getAnnotation(TestAnnotation.class), field1.getAnnotation(TestAnnotation.class))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNonEquivalentAnnotationsOfSameType() { [EOL]         assertFalse(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field3.getAnnotation(TestAnnotation.class))); [EOL]         assertFalse(AnnotationUtils.equals(field3.getAnnotation(TestAnnotation.class), field1.getAnnotation(TestAnnotation.class))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNonEquivalentAnnotationsOfSameType() { [EOL]         assertFalse(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field3.getAnnotation(TestAnnotation.class))); [EOL]         assertFalse(AnnotationUtils.equals(field3.getAnnotation(TestAnnotation.class), field1.getAnnotation(TestAnnotation.class))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNonEquivalentAnnotationsOfSameType() { [EOL]         assertFalse(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field3.getAnnotation(TestAnnotation.class))); [EOL]         assertFalse(AnnotationUtils.equals(field3.getAnnotation(TestAnnotation.class), field1.getAnnotation(TestAnnotation.class))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNonEquivalentAnnotationsOfSameType() { [EOL]         assertFalse(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field3.getAnnotation(TestAnnotation.class))); [EOL]         assertFalse(AnnotationUtils.equals(field3.getAnnotation(TestAnnotation.class), field1.getAnnotation(TestAnnotation.class))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNonEquivalentAnnotationsOfSameType() { [EOL]         assertFalse(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field3.getAnnotation(TestAnnotation.class))); [EOL]         assertFalse(AnnotationUtils.equals(field3.getAnnotation(TestAnnotation.class), field1.getAnnotation(TestAnnotation.class))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNonEquivalentAnnotationsOfSameType() { [EOL]         assertFalse(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field3.getAnnotation(TestAnnotation.class))); [EOL]         assertFalse(AnnotationUtils.equals(field3.getAnnotation(TestAnnotation.class), field1.getAnnotation(TestAnnotation.class))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNonEquivalentAnnotationsOfSameType() { [EOL]         assertFalse(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field3.getAnnotation(TestAnnotation.class))); [EOL]         assertFalse(AnnotationUtils.equals(field3.getAnnotation(TestAnnotation.class), field1.getAnnotation(TestAnnotation.class))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNonEquivalentAnnotationsOfSameType() { [EOL]         assertFalse(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field3.getAnnotation(TestAnnotation.class))); [EOL]         assertFalse(AnnotationUtils.equals(field3.getAnnotation(TestAnnotation.class), field1.getAnnotation(TestAnnotation.class))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNonEquivalentAnnotationsOfSameType() { [EOL]         assertFalse(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field3.getAnnotation(TestAnnotation.class))); [EOL]         assertFalse(AnnotationUtils.equals(field3.getAnnotation(TestAnnotation.class), field1.getAnnotation(TestAnnotation.class))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNonEquivalentAnnotationsOfSameType() { [EOL]         assertFalse(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field3.getAnnotation(TestAnnotation.class))); [EOL]         assertFalse(AnnotationUtils.equals(field3.getAnnotation(TestAnnotation.class), field1.getAnnotation(TestAnnotation.class))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNonEquivalentAnnotationsOfSameType() { [EOL]         assertFalse(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field3.getAnnotation(TestAnnotation.class))); [EOL]         assertFalse(AnnotationUtils.equals(field3.getAnnotation(TestAnnotation.class), field1.getAnnotation(TestAnnotation.class))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNonEquivalentAnnotationsOfSameType() { [EOL]         assertFalse(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field3.getAnnotation(TestAnnotation.class))); [EOL]         assertFalse(AnnotationUtils.equals(field3.getAnnotation(TestAnnotation.class), field1.getAnnotation(TestAnnotation.class))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNonEquivalentAnnotationsOfSameType() { [EOL]         assertFalse(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field3.getAnnotation(TestAnnotation.class))); [EOL]         assertFalse(AnnotationUtils.equals(field3.getAnnotation(TestAnnotation.class), field1.getAnnotation(TestAnnotation.class))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNonEquivalentAnnotationsOfSameType() { [EOL]         assertFalse(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field3.getAnnotation(TestAnnotation.class))); [EOL]         assertFalse(AnnotationUtils.equals(field3.getAnnotation(TestAnnotation.class), field1.getAnnotation(TestAnnotation.class))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNonEquivalentAnnotationsOfSameType() { [EOL]         assertFalse(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field3.getAnnotation(TestAnnotation.class))); [EOL]         assertFalse(AnnotationUtils.equals(field3.getAnnotation(TestAnnotation.class), field1.getAnnotation(TestAnnotation.class))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquivalence() { [EOL]         assertTrue(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field2.getAnnotation(TestAnnotation.class))); [EOL]         assertTrue(AnnotationUtils.equals(field2.getAnnotation(TestAnnotation.class), field1.getAnnotation(TestAnnotation.class))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquivalence() { [EOL]         assertTrue(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field2.getAnnotation(TestAnnotation.class))); [EOL]         assertTrue(AnnotationUtils.equals(field2.getAnnotation(TestAnnotation.class), field1.getAnnotation(TestAnnotation.class))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquivalence() { [EOL]         assertTrue(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field2.getAnnotation(TestAnnotation.class))); [EOL]         assertTrue(AnnotationUtils.equals(field2.getAnnotation(TestAnnotation.class), field1.getAnnotation(TestAnnotation.class))); [EOL]     } [EOL]  [EOL]
@Test(timeout = 666000) [EOL]     public void testHashCode() throws Exception { [EOL]         final Test test = getClass().getDeclaredMethod("testHashCode").getAnnotation(Test.class); [EOL]         assertEquals(test.hashCode(), AnnotationUtils.hashCode(test)); [EOL]         final TestAnnotation testAnnotation1 = field1.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation1.hashCode(), AnnotationUtils.hashCode(testAnnotation1)); [EOL]         final TestAnnotation testAnnotation3 = field3.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation3.hashCode(), AnnotationUtils.hashCode(testAnnotation3)); [EOL]     } [EOL]  [EOL]
@Test(timeout = 666000) [EOL]     public void testHashCode() throws Exception { [EOL]         final Test test = getClass().getDeclaredMethod("testHashCode").getAnnotation(Test.class); [EOL]         assertEquals(test.hashCode(), AnnotationUtils.hashCode(test)); [EOL]         final TestAnnotation testAnnotation1 = field1.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation1.hashCode(), AnnotationUtils.hashCode(testAnnotation1)); [EOL]         final TestAnnotation testAnnotation3 = field3.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation3.hashCode(), AnnotationUtils.hashCode(testAnnotation3)); [EOL]     } [EOL]  [EOL]
@Test(timeout = 666000) [EOL]     public void testHashCode() throws Exception { [EOL]         final Test test = getClass().getDeclaredMethod("testHashCode").getAnnotation(Test.class); [EOL]         assertEquals(test.hashCode(), AnnotationUtils.hashCode(test)); [EOL]         final TestAnnotation testAnnotation1 = field1.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation1.hashCode(), AnnotationUtils.hashCode(testAnnotation1)); [EOL]         final TestAnnotation testAnnotation3 = field3.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation3.hashCode(), AnnotationUtils.hashCode(testAnnotation3)); [EOL]     } [EOL]  [EOL]
@Test(timeout = 666000) [EOL]     public void testHashCode() throws Exception { [EOL]         final Test test = getClass().getDeclaredMethod("testHashCode").getAnnotation(Test.class); [EOL]         assertEquals(test.hashCode(), AnnotationUtils.hashCode(test)); [EOL]         final TestAnnotation testAnnotation1 = field1.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation1.hashCode(), AnnotationUtils.hashCode(testAnnotation1)); [EOL]         final TestAnnotation testAnnotation3 = field3.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation3.hashCode(), AnnotationUtils.hashCode(testAnnotation3)); [EOL]     } [EOL]  [EOL]
@Test(timeout = 666000) [EOL]     public void testHashCode() throws Exception { [EOL]         final Test test = getClass().getDeclaredMethod("testHashCode").getAnnotation(Test.class); [EOL]         assertEquals(test.hashCode(), AnnotationUtils.hashCode(test)); [EOL]         final TestAnnotation testAnnotation1 = field1.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation1.hashCode(), AnnotationUtils.hashCode(testAnnotation1)); [EOL]         final TestAnnotation testAnnotation3 = field3.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation3.hashCode(), AnnotationUtils.hashCode(testAnnotation3)); [EOL]     } [EOL]  [EOL]
@Test(timeout = 666000) [EOL]     public void testHashCode() throws Exception { [EOL]         final Test test = getClass().getDeclaredMethod("testHashCode").getAnnotation(Test.class); [EOL]         assertEquals(test.hashCode(), AnnotationUtils.hashCode(test)); [EOL]         final TestAnnotation testAnnotation1 = field1.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation1.hashCode(), AnnotationUtils.hashCode(testAnnotation1)); [EOL]         final TestAnnotation testAnnotation3 = field3.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation3.hashCode(), AnnotationUtils.hashCode(testAnnotation3)); [EOL]     } [EOL]  [EOL]
@Test(timeout = 666000) [EOL]     public void testHashCode() throws Exception { [EOL]         final Test test = getClass().getDeclaredMethod("testHashCode").getAnnotation(Test.class); [EOL]         assertEquals(test.hashCode(), AnnotationUtils.hashCode(test)); [EOL]         final TestAnnotation testAnnotation1 = field1.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation1.hashCode(), AnnotationUtils.hashCode(testAnnotation1)); [EOL]         final TestAnnotation testAnnotation3 = field3.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation3.hashCode(), AnnotationUtils.hashCode(testAnnotation3)); [EOL]     } [EOL]  [EOL]
@Test(timeout = 666000) [EOL]     public void testHashCode() throws Exception { [EOL]         final Test test = getClass().getDeclaredMethod("testHashCode").getAnnotation(Test.class); [EOL]         assertEquals(test.hashCode(), AnnotationUtils.hashCode(test)); [EOL]         final TestAnnotation testAnnotation1 = field1.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation1.hashCode(), AnnotationUtils.hashCode(testAnnotation1)); [EOL]         final TestAnnotation testAnnotation3 = field3.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation3.hashCode(), AnnotationUtils.hashCode(testAnnotation3)); [EOL]     } [EOL]  [EOL]
@Test(timeout = 666000) [EOL]     public void testHashCode() throws Exception { [EOL]         final Test test = getClass().getDeclaredMethod("testHashCode").getAnnotation(Test.class); [EOL]         assertEquals(test.hashCode(), AnnotationUtils.hashCode(test)); [EOL]         final TestAnnotation testAnnotation1 = field1.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation1.hashCode(), AnnotationUtils.hashCode(testAnnotation1)); [EOL]         final TestAnnotation testAnnotation3 = field3.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation3.hashCode(), AnnotationUtils.hashCode(testAnnotation3)); [EOL]     } [EOL]  [EOL]
@Test(timeout = 666000) [EOL]     public void testHashCode() throws Exception { [EOL]         final Test test = getClass().getDeclaredMethod("testHashCode").getAnnotation(Test.class); [EOL]         assertEquals(test.hashCode(), AnnotationUtils.hashCode(test)); [EOL]         final TestAnnotation testAnnotation1 = field1.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation1.hashCode(), AnnotationUtils.hashCode(testAnnotation1)); [EOL]         final TestAnnotation testAnnotation3 = field3.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation3.hashCode(), AnnotationUtils.hashCode(testAnnotation3)); [EOL]     } [EOL]  [EOL]
@Test(timeout = 666000) [EOL]     public void testHashCode() throws Exception { [EOL]         final Test test = getClass().getDeclaredMethod("testHashCode").getAnnotation(Test.class); [EOL]         assertEquals(test.hashCode(), AnnotationUtils.hashCode(test)); [EOL]         final TestAnnotation testAnnotation1 = field1.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation1.hashCode(), AnnotationUtils.hashCode(testAnnotation1)); [EOL]         final TestAnnotation testAnnotation3 = field3.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation3.hashCode(), AnnotationUtils.hashCode(testAnnotation3)); [EOL]     } [EOL]  [EOL]
@Test(timeout = 666000) [EOL]     public void testHashCode() throws Exception { [EOL]         final Test test = getClass().getDeclaredMethod("testHashCode").getAnnotation(Test.class); [EOL]         assertEquals(test.hashCode(), AnnotationUtils.hashCode(test)); [EOL]         final TestAnnotation testAnnotation1 = field1.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation1.hashCode(), AnnotationUtils.hashCode(testAnnotation1)); [EOL]         final TestAnnotation testAnnotation3 = field3.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation3.hashCode(), AnnotationUtils.hashCode(testAnnotation3)); [EOL]     } [EOL]  [EOL]
@Test(timeout = 666000) [EOL]     public void testHashCode() throws Exception { [EOL]         final Test test = getClass().getDeclaredMethod("testHashCode").getAnnotation(Test.class); [EOL]         assertEquals(test.hashCode(), AnnotationUtils.hashCode(test)); [EOL]         final TestAnnotation testAnnotation1 = field1.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation1.hashCode(), AnnotationUtils.hashCode(testAnnotation1)); [EOL]         final TestAnnotation testAnnotation3 = field3.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation3.hashCode(), AnnotationUtils.hashCode(testAnnotation3)); [EOL]     } [EOL]  [EOL]
@Test(timeout = 666000) [EOL]     public void testHashCode() throws Exception { [EOL]         final Test test = getClass().getDeclaredMethod("testHashCode").getAnnotation(Test.class); [EOL]         assertEquals(test.hashCode(), AnnotationUtils.hashCode(test)); [EOL]         final TestAnnotation testAnnotation1 = field1.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation1.hashCode(), AnnotationUtils.hashCode(testAnnotation1)); [EOL]         final TestAnnotation testAnnotation3 = field3.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation3.hashCode(), AnnotationUtils.hashCode(testAnnotation3)); [EOL]     } [EOL]  [EOL]
@Test(timeout = 666000) [EOL]     public void testHashCode() throws Exception { [EOL]         final Test test = getClass().getDeclaredMethod("testHashCode").getAnnotation(Test.class); [EOL]         assertEquals(test.hashCode(), AnnotationUtils.hashCode(test)); [EOL]         final TestAnnotation testAnnotation1 = field1.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation1.hashCode(), AnnotationUtils.hashCode(testAnnotation1)); [EOL]         final TestAnnotation testAnnotation3 = field3.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation3.hashCode(), AnnotationUtils.hashCode(testAnnotation3)); [EOL]     } [EOL]  [EOL]
@Test(timeout = 666000) [EOL]     public void testHashCode() throws Exception { [EOL]         final Test test = getClass().getDeclaredMethod("testHashCode").getAnnotation(Test.class); [EOL]         assertEquals(test.hashCode(), AnnotationUtils.hashCode(test)); [EOL]         final TestAnnotation testAnnotation1 = field1.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation1.hashCode(), AnnotationUtils.hashCode(testAnnotation1)); [EOL]         final TestAnnotation testAnnotation3 = field3.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation3.hashCode(), AnnotationUtils.hashCode(testAnnotation3)); [EOL]     } [EOL]  [EOL]
@Test(timeout = 666000) [EOL]     public void testHashCode() throws Exception { [EOL]         final Test test = getClass().getDeclaredMethod("testHashCode").getAnnotation(Test.class); [EOL]         assertEquals(test.hashCode(), AnnotationUtils.hashCode(test)); [EOL]         final TestAnnotation testAnnotation1 = field1.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation1.hashCode(), AnnotationUtils.hashCode(testAnnotation1)); [EOL]         final TestAnnotation testAnnotation3 = field3.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation3.hashCode(), AnnotationUtils.hashCode(testAnnotation3)); [EOL]     } [EOL]  [EOL]
@Test(timeout = 666000) [EOL]     public void testHashCode() throws Exception { [EOL]         final Test test = getClass().getDeclaredMethod("testHashCode").getAnnotation(Test.class); [EOL]         assertEquals(test.hashCode(), AnnotationUtils.hashCode(test)); [EOL]         final TestAnnotation testAnnotation1 = field1.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation1.hashCode(), AnnotationUtils.hashCode(testAnnotation1)); [EOL]         final TestAnnotation testAnnotation3 = field3.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation3.hashCode(), AnnotationUtils.hashCode(testAnnotation3)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testAddEventListenerThrowsException() [EOL]     { [EOL]         final ExceptionEventSource src = new ExceptionEventSource(); [EOL]         try [EOL]         { [EOL]             EventUtils.addEventListener(src, PropertyChangeListener.class, new PropertyChangeListener() [EOL]             { [EOL]                 @Override [EOL]                 public void propertyChange(final PropertyChangeEvent e) [EOL]                 { [EOL]                     // Do nothing! [EOL]                 } [EOL]             }); [EOL]             fail("Add method should have thrown an exception, so method should fail."); [EOL]         } [EOL]         catch (final RuntimeException e) [EOL]         { [EOL]  [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testBindFilteredEventsToMethod() [EOL]     { [EOL]         final MultipleEventSource src = new MultipleEventSource(); [EOL]         final EventCounter counter = new EventCounter(); [EOL]         EventUtils.bindEventsToMethod(counter, "eventOccurred", src, MultipleEventListener.class, "event1"); [EOL]         assertEquals(0, counter.getCount()); [EOL]         src.listeners.fire().event1(new PropertyChangeEvent(new Date(), "Day", Integer.valueOf(0), Integer.valueOf(1))); [EOL]         assertEquals(1, counter.getCount()); [EOL]         src.listeners.fire().event2(new PropertyChangeEvent(new Date(), "Day", Integer.valueOf(1), Integer.valueOf(2))); [EOL]         assertEquals(1, counter.getCount()); [EOL]     } [EOL]  [EOL]     public static interface MultipleEventListener [EOL]     { [EOL]         public void event1(PropertyChangeEvent e); [EOL]  [EOL]         public void event2(PropertyChangeEvent e); [EOL]     } [EOL]  [EOL]     public static class EventCounter [EOL]     { [EOL]         private int count; [EOL]  [EOL]         public void eventOccurred() [EOL]         { [EOL]             count++; [EOL]         } [EOL]  [EOL]         public int getCount() [EOL]         { [EOL]             return count; [EOL]         } [EOL]     } [EOL]  [EOL]     public static class EventCounterWithEvent [EOL]     { [EOL]         private int count; [EOL]  [EOL]         public void eventOccurred(final PropertyChangeEvent e) [EOL]         { [EOL]             count++; [EOL]         } [EOL]  [EOL]         public int getCount() [EOL]         { [EOL]             return count; [EOL]         } [EOL]     } [EOL]  [EOL]  [EOL]     private static class EventCountingInvociationHandler implements InvocationHandler [EOL]     { [EOL]         private final Map<String, Integer> eventCounts = new TreeMap<String, Integer>(); [EOL]  [EOL]         public <L> L createListener(final Class<L> listenerType) [EOL]         { [EOL]             return listenerType.cast(Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), [EOL]                     new Class[]{listenerType}, [EOL]                     this)); [EOL]         } [EOL]  [EOL]         public int getEventCount(final String eventName) [EOL]         { [EOL]             final Integer count = eventCounts.get(eventName); [EOL]             return count == null ? 0 : count.intValue(); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public Object invoke(final Object proxy, final Method method, final Object[] args) throws Throwable [EOL]         { [EOL]             final Integer count = eventCounts.get(method.getName()); [EOL]             if (count == null) [EOL]             { [EOL]                 eventCounts.put(method.getName(), Integer.valueOf(1)); [EOL]             } [EOL]             else [EOL]             { [EOL]                 eventCounts.put(method.getName(), Integer.valueOf(count.intValue() + 1)); [EOL]             } [EOL]             return null; [EOL]         } [EOL]     } [EOL]  [EOL]     public static class MultipleEventSource [EOL]     { [EOL]         private final EventListenerSupport<MultipleEventListener> listeners = EventListenerSupport.create(MultipleEventListener.class); [EOL]  [EOL]         public void addMultipleEventListener(final MultipleEventListener listener) [EOL]         { [EOL]             listeners.addListener(listener); [EOL]         } [EOL]     } [EOL]  [EOL]     public static class ExceptionEventSource [EOL]     { [EOL]         public void addPropertyChangeListener(final PropertyChangeListener listener) [EOL]         { [EOL]             throw new RuntimeException(); [EOL]         } [EOL]     } [EOL]  [EOL]     public static class PropertyChangeSource [EOL]     { [EOL]         private final EventListenerSupport<PropertyChangeListener> listeners = EventListenerSupport.create(PropertyChangeListener.class); [EOL]  [EOL]         private String property; [EOL]  [EOL]         public void setProperty(final String property) [EOL]         { [EOL]             final String oldValue = this.property; [EOL]             this.property = property; [EOL]             listeners.fire().propertyChange(new PropertyChangeEvent(this, "property", oldValue, property)); [EOL]         } [EOL]  [EOL]         protected void addVetoableChangeListener(final VetoableChangeListener listener) [EOL]         { [EOL]             // Do nothing! [EOL]         } [EOL]  [EOL]         public void addPropertyChangeListener(final PropertyChangeListener listener) [EOL]         { [EOL]             listeners.addListener(listener); [EOL]         } [EOL]  [EOL]         public void removePropertyChangeListener(final PropertyChangeListener listener) [EOL]         { [EOL]             listeners.removeListener(listener); [EOL]         } [EOL]     } [EOL] } [EOL]
@Test [EOL]     public void testBindFilteredEventsToMethod() [EOL]     { [EOL]         final MultipleEventSource src = new MultipleEventSource(); [EOL]         final EventCounter counter = new EventCounter(); [EOL]         EventUtils.bindEventsToMethod(counter, "eventOccurred", src, MultipleEventListener.class, "event1"); [EOL]         assertEquals(0, counter.getCount()); [EOL]         src.listeners.fire().event1(new PropertyChangeEvent(new Date(), "Day", Integer.valueOf(0), Integer.valueOf(1))); [EOL]         assertEquals(1, counter.getCount()); [EOL]         src.listeners.fire().event2(new PropertyChangeEvent(new Date(), "Day", Integer.valueOf(1), Integer.valueOf(2))); [EOL]         assertEquals(1, counter.getCount()); [EOL]     } [EOL]  [EOL]     public static interface MultipleEventListener [EOL]     { [EOL]         public void event1(PropertyChangeEvent e); [EOL]  [EOL]         public void event2(PropertyChangeEvent e); [EOL]     } [EOL]  [EOL]     public static class EventCounter [EOL]     { [EOL]         private int count; [EOL]  [EOL]         public void eventOccurred() [EOL]         { [EOL]             count++; [EOL]         } [EOL]  [EOL]         public int getCount() [EOL]         { [EOL]             return count; [EOL]         } [EOL]     } [EOL]  [EOL]     public static class EventCounterWithEvent [EOL]     { [EOL]         private int count; [EOL]  [EOL]         public void eventOccurred(final PropertyChangeEvent e) [EOL]         { [EOL]             count++; [EOL]         } [EOL]  [EOL]         public int getCount() [EOL]         { [EOL]             return count; [EOL]         } [EOL]     } [EOL]  [EOL]  [EOL]     private static class EventCountingInvociationHandler implements InvocationHandler [EOL]     { [EOL]         private final Map<String, Integer> eventCounts = new TreeMap<String, Integer>(); [EOL]  [EOL]         public <L> L createListener(final Class<L> listenerType) [EOL]         { [EOL]             return listenerType.cast(Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), [EOL]                     new Class[]{listenerType}, [EOL]                     this)); [EOL]         } [EOL]  [EOL]         public int getEventCount(final String eventName) [EOL]         { [EOL]             final Integer count = eventCounts.get(eventName); [EOL]             return count == null ? 0 : count.intValue(); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public Object invoke(final Object proxy, final Method method, final Object[] args) throws Throwable [EOL]         { [EOL]             final Integer count = eventCounts.get(method.getName()); [EOL]             if (count == null) [EOL]             { [EOL]                 eventCounts.put(method.getName(), Integer.valueOf(1)); [EOL]             } [EOL]             else [EOL]             { [EOL]                 eventCounts.put(method.getName(), Integer.valueOf(count.intValue() + 1)); [EOL]             } [EOL]             return null; [EOL]         } [EOL]     } [EOL]  [EOL]     public static class MultipleEventSource [EOL]     { [EOL]         private final EventListenerSupport<MultipleEventListener> listeners = EventListenerSupport.create(MultipleEventListener.class); [EOL]  [EOL]         public void addMultipleEventListener(final MultipleEventListener listener) [EOL]         { [EOL]             listeners.addListener(listener); [EOL]         } [EOL]     } [EOL]  [EOL]     public static class ExceptionEventSource [EOL]     { [EOL]         public void addPropertyChangeListener(final PropertyChangeListener listener) [EOL]         { [EOL]             throw new RuntimeException(); [EOL]         } [EOL]     } [EOL]  [EOL]     public static class PropertyChangeSource [EOL]     { [EOL]         private final EventListenerSupport<PropertyChangeListener> listeners = EventListenerSupport.create(PropertyChangeListener.class); [EOL]  [EOL]         private String property; [EOL]  [EOL]         public void setProperty(final String property) [EOL]         { [EOL]             final String oldValue = this.property; [EOL]             this.property = property; [EOL]             listeners.fire().propertyChange(new PropertyChangeEvent(this, "property", oldValue, property)); [EOL]         } [EOL]  [EOL]         protected void addVetoableChangeListener(final VetoableChangeListener listener) [EOL]         { [EOL]             // Do nothing! [EOL]         } [EOL]  [EOL]         public void addPropertyChangeListener(final PropertyChangeListener listener) [EOL]         { [EOL]             listeners.addListener(listener); [EOL]         } [EOL]  [EOL]         public void removePropertyChangeListener(final PropertyChangeListener listener) [EOL]         { [EOL]             listeners.removeListener(listener); [EOL]         } [EOL]     } [EOL] } [EOL]
@Test [EOL]     public void testBindFilteredEventsToMethod() [EOL]     { [EOL]         final MultipleEventSource src = new MultipleEventSource(); [EOL]         final EventCounter counter = new EventCounter(); [EOL]         EventUtils.bindEventsToMethod(counter, "eventOccurred", src, MultipleEventListener.class, "event1"); [EOL]         assertEquals(0, counter.getCount()); [EOL]         src.listeners.fire().event1(new PropertyChangeEvent(new Date(), "Day", Integer.valueOf(0), Integer.valueOf(1))); [EOL]         assertEquals(1, counter.getCount()); [EOL]         src.listeners.fire().event2(new PropertyChangeEvent(new Date(), "Day", Integer.valueOf(1), Integer.valueOf(2))); [EOL]         assertEquals(1, counter.getCount()); [EOL]     } [EOL]  [EOL]     public static interface MultipleEventListener [EOL]     { [EOL]         public void event1(PropertyChangeEvent e); [EOL]  [EOL]         public void event2(PropertyChangeEvent e); [EOL]     } [EOL]  [EOL]     public static class EventCounter [EOL]     { [EOL]         private int count; [EOL]  [EOL]         public void eventOccurred() [EOL]         { [EOL]             count++; [EOL]         } [EOL]  [EOL]         public int getCount() [EOL]         { [EOL]             return count; [EOL]         } [EOL]     } [EOL]  [EOL]     public static class EventCounterWithEvent [EOL]     { [EOL]         private int count; [EOL]  [EOL]         public void eventOccurred(final PropertyChangeEvent e) [EOL]         { [EOL]             count++; [EOL]         } [EOL]  [EOL]         public int getCount() [EOL]         { [EOL]             return count; [EOL]         } [EOL]     } [EOL]  [EOL]  [EOL]     private static class EventCountingInvociationHandler implements InvocationHandler [EOL]     { [EOL]         private final Map<String, Integer> eventCounts = new TreeMap<String, Integer>(); [EOL]  [EOL]         public <L> L createListener(final Class<L> listenerType) [EOL]         { [EOL]             return listenerType.cast(Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), [EOL]                     new Class[]{listenerType}, [EOL]                     this)); [EOL]         } [EOL]  [EOL]         public int getEventCount(final String eventName) [EOL]         { [EOL]             final Integer count = eventCounts.get(eventName); [EOL]             return count == null ? 0 : count.intValue(); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public Object invoke(final Object proxy, final Method method, final Object[] args) throws Throwable [EOL]         { [EOL]             final Integer count = eventCounts.get(method.getName()); [EOL]             if (count == null) [EOL]             { [EOL]                 eventCounts.put(method.getName(), Integer.valueOf(1)); [EOL]             } [EOL]             else [EOL]             { [EOL]                 eventCounts.put(method.getName(), Integer.valueOf(count.intValue() + 1)); [EOL]             } [EOL]             return null; [EOL]         } [EOL]     } [EOL]  [EOL]     public static class MultipleEventSource [EOL]     { [EOL]         private final EventListenerSupport<MultipleEventListener> listeners = EventListenerSupport.create(MultipleEventListener.class); [EOL]  [EOL]         public void addMultipleEventListener(final MultipleEventListener listener) [EOL]         { [EOL]             listeners.addListener(listener); [EOL]         } [EOL]     } [EOL]  [EOL]     public static class ExceptionEventSource [EOL]     { [EOL]         public void addPropertyChangeListener(final PropertyChangeListener listener) [EOL]         { [EOL]             throw new RuntimeException(); [EOL]         } [EOL]     } [EOL]  [EOL]     public static class PropertyChangeSource [EOL]     { [EOL]         private final EventListenerSupport<PropertyChangeListener> listeners = EventListenerSupport.create(PropertyChangeListener.class); [EOL]  [EOL]         private String property; [EOL]  [EOL]         public void setProperty(final String property) [EOL]         { [EOL]             final String oldValue = this.property; [EOL]             this.property = property; [EOL]             listeners.fire().propertyChange(new PropertyChangeEvent(this, "property", oldValue, property)); [EOL]         } [EOL]  [EOL]         protected void addVetoableChangeListener(final VetoableChangeListener listener) [EOL]         { [EOL]             // Do nothing! [EOL]         } [EOL]  [EOL]         public void addPropertyChangeListener(final PropertyChangeListener listener) [EOL]         { [EOL]             listeners.addListener(listener); [EOL]         } [EOL]  [EOL]         public void removePropertyChangeListener(final PropertyChangeListener listener) [EOL]         { [EOL]             listeners.removeListener(listener); [EOL]         } [EOL]     } [EOL] } [EOL]
@Test [EOL]     public void testBindFilteredEventsToMethod() [EOL]     { [EOL]         final MultipleEventSource src = new MultipleEventSource(); [EOL]         final EventCounter counter = new EventCounter(); [EOL]         EventUtils.bindEventsToMethod(counter, "eventOccurred", src, MultipleEventListener.class, "event1"); [EOL]         assertEquals(0, counter.getCount()); [EOL]         src.listeners.fire().event1(new PropertyChangeEvent(new Date(), "Day", Integer.valueOf(0), Integer.valueOf(1))); [EOL]         assertEquals(1, counter.getCount()); [EOL]         src.listeners.fire().event2(new PropertyChangeEvent(new Date(), "Day", Integer.valueOf(1), Integer.valueOf(2))); [EOL]         assertEquals(1, counter.getCount()); [EOL]     } [EOL]  [EOL]     public static interface MultipleEventListener [EOL]     { [EOL]         public void event1(PropertyChangeEvent e); [EOL]  [EOL]         public void event2(PropertyChangeEvent e); [EOL]     } [EOL]  [EOL]     public static class EventCounter [EOL]     { [EOL]         private int count; [EOL]  [EOL]         public void eventOccurred() [EOL]         { [EOL]             count++; [EOL]         } [EOL]  [EOL]         public int getCount() [EOL]         { [EOL]             return count; [EOL]         } [EOL]     } [EOL]  [EOL]     public static class EventCounterWithEvent [EOL]     { [EOL]         private int count; [EOL]  [EOL]         public void eventOccurred(final PropertyChangeEvent e) [EOL]         { [EOL]             count++; [EOL]         } [EOL]  [EOL]         public int getCount() [EOL]         { [EOL]             return count; [EOL]         } [EOL]     } [EOL]  [EOL]  [EOL]     private static class EventCountingInvociationHandler implements InvocationHandler [EOL]     { [EOL]         private final Map<String, Integer> eventCounts = new TreeMap<String, Integer>(); [EOL]  [EOL]         public <L> L createListener(final Class<L> listenerType) [EOL]         { [EOL]             return listenerType.cast(Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), [EOL]                     new Class[]{listenerType}, [EOL]                     this)); [EOL]         } [EOL]  [EOL]         public int getEventCount(final String eventName) [EOL]         { [EOL]             final Integer count = eventCounts.get(eventName); [EOL]             return count == null ? 0 : count.intValue(); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public Object invoke(final Object proxy, final Method method, final Object[] args) throws Throwable [EOL]         { [EOL]             final Integer count = eventCounts.get(method.getName()); [EOL]             if (count == null) [EOL]             { [EOL]                 eventCounts.put(method.getName(), Integer.valueOf(1)); [EOL]             } [EOL]             else [EOL]             { [EOL]                 eventCounts.put(method.getName(), Integer.valueOf(count.intValue() + 1)); [EOL]             } [EOL]             return null; [EOL]         } [EOL]     } [EOL]  [EOL]     public static class MultipleEventSource [EOL]     { [EOL]         private final EventListenerSupport<MultipleEventListener> listeners = EventListenerSupport.create(MultipleEventListener.class); [EOL]  [EOL]         public void addMultipleEventListener(final MultipleEventListener listener) [EOL]         { [EOL]             listeners.addListener(listener); [EOL]         } [EOL]     } [EOL]  [EOL]     public static class ExceptionEventSource [EOL]     { [EOL]         public void addPropertyChangeListener(final PropertyChangeListener listener) [EOL]         { [EOL]             throw new RuntimeException(); [EOL]         } [EOL]     } [EOL]  [EOL]     public static class PropertyChangeSource [EOL]     { [EOL]         private final EventListenerSupport<PropertyChangeListener> listeners = EventListenerSupport.create(PropertyChangeListener.class); [EOL]  [EOL]         private String property; [EOL]  [EOL]         public void setProperty(final String property) [EOL]         { [EOL]             final String oldValue = this.property; [EOL]             this.property = property; [EOL]             listeners.fire().propertyChange(new PropertyChangeEvent(this, "property", oldValue, property)); [EOL]         } [EOL]  [EOL]         protected void addVetoableChangeListener(final VetoableChangeListener listener) [EOL]         { [EOL]             // Do nothing! [EOL]         } [EOL]  [EOL]         public void addPropertyChangeListener(final PropertyChangeListener listener) [EOL]         { [EOL]             listeners.addListener(listener); [EOL]         } [EOL]  [EOL]         public void removePropertyChangeListener(final PropertyChangeListener listener) [EOL]         { [EOL]             listeners.removeListener(listener); [EOL]         } [EOL]     } [EOL] } [EOL]
@Test [EOL]     public void testBindEventsToMethodWithEvent() [EOL]     { [EOL]         final PropertyChangeSource src = new PropertyChangeSource(); [EOL]         final EventCounterWithEvent counter = new EventCounterWithEvent(); [EOL]         EventUtils.bindEventsToMethod(counter, "eventOccurred", src, PropertyChangeListener.class); [EOL]         assertEquals(0, counter.getCount()); [EOL]         src.setProperty("newValue"); [EOL]         assertEquals(1, counter.getCount()); [EOL]     } [EOL]  [EOL]  [EOL]
@Test [EOL]     public void testBindFilteredEventsToMethod() [EOL]     { [EOL]         final MultipleEventSource src = new MultipleEventSource(); [EOL]         final EventCounter counter = new EventCounter(); [EOL]         EventUtils.bindEventsToMethod(counter, "eventOccurred", src, MultipleEventListener.class, "event1"); [EOL]         assertEquals(0, counter.getCount()); [EOL]         src.listeners.fire().event1(new PropertyChangeEvent(new Date(), "Day", Integer.valueOf(0), Integer.valueOf(1))); [EOL]         assertEquals(1, counter.getCount()); [EOL]         src.listeners.fire().event2(new PropertyChangeEvent(new Date(), "Day", Integer.valueOf(1), Integer.valueOf(2))); [EOL]         assertEquals(1, counter.getCount()); [EOL]     } [EOL]  [EOL]     public static interface MultipleEventListener [EOL]     { [EOL]         public void event1(PropertyChangeEvent e); [EOL]  [EOL]         public void event2(PropertyChangeEvent e); [EOL]     } [EOL]  [EOL]     public static class EventCounter [EOL]     { [EOL]         private int count; [EOL]  [EOL]         public void eventOccurred() [EOL]         { [EOL]             count++; [EOL]         } [EOL]  [EOL]         public int getCount() [EOL]         { [EOL]             return count; [EOL]         } [EOL]     } [EOL]  [EOL]     public static class EventCounterWithEvent [EOL]     { [EOL]         private int count; [EOL]  [EOL]         public void eventOccurred(final PropertyChangeEvent e) [EOL]         { [EOL]             count++; [EOL]         } [EOL]  [EOL]         public int getCount() [EOL]         { [EOL]             return count; [EOL]         } [EOL]     } [EOL]  [EOL]  [EOL]     private static class EventCountingInvociationHandler implements InvocationHandler [EOL]     { [EOL]         private final Map<String, Integer> eventCounts = new TreeMap<String, Integer>(); [EOL]  [EOL]         public <L> L createListener(final Class<L> listenerType) [EOL]         { [EOL]             return listenerType.cast(Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), [EOL]                     new Class[]{listenerType}, [EOL]                     this)); [EOL]         } [EOL]  [EOL]         public int getEventCount(final String eventName) [EOL]         { [EOL]             final Integer count = eventCounts.get(eventName); [EOL]             return count == null ? 0 : count.intValue(); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public Object invoke(final Object proxy, final Method method, final Object[] args) throws Throwable [EOL]         { [EOL]             final Integer count = eventCounts.get(method.getName()); [EOL]             if (count == null) [EOL]             { [EOL]                 eventCounts.put(method.getName(), Integer.valueOf(1)); [EOL]             } [EOL]             else [EOL]             { [EOL]                 eventCounts.put(method.getName(), Integer.valueOf(count.intValue() + 1)); [EOL]             } [EOL]             return null; [EOL]         } [EOL]     } [EOL]  [EOL]     public static class MultipleEventSource [EOL]     { [EOL]         private final EventListenerSupport<MultipleEventListener> listeners = EventListenerSupport.create(MultipleEventListener.class); [EOL]  [EOL]         public void addMultipleEventListener(final MultipleEventListener listener) [EOL]         { [EOL]             listeners.addListener(listener); [EOL]         } [EOL]     } [EOL]  [EOL]     public static class ExceptionEventSource [EOL]     { [EOL]         public void addPropertyChangeListener(final PropertyChangeListener listener) [EOL]         { [EOL]             throw new RuntimeException(); [EOL]         } [EOL]     } [EOL]  [EOL]     public static class PropertyChangeSource [EOL]     { [EOL]         private final EventListenerSupport<PropertyChangeListener> listeners = EventListenerSupport.create(PropertyChangeListener.class); [EOL]  [EOL]         private String property; [EOL]  [EOL]         public void setProperty(final String property) [EOL]         { [EOL]             final String oldValue = this.property; [EOL]             this.property = property; [EOL]             listeners.fire().propertyChange(new PropertyChangeEvent(this, "property", oldValue, property)); [EOL]         } [EOL]  [EOL]         protected void addVetoableChangeListener(final VetoableChangeListener listener) [EOL]         { [EOL]             // Do nothing! [EOL]         } [EOL]  [EOL]         public void addPropertyChangeListener(final PropertyChangeListener listener) [EOL]         { [EOL]             listeners.addListener(listener); [EOL]         } [EOL]  [EOL]         public void removePropertyChangeListener(final PropertyChangeListener listener) [EOL]         { [EOL]             listeners.removeListener(listener); [EOL]         } [EOL]     } [EOL] } [EOL]
@Test [EOL]     public void testBindFilteredEventsToMethod() [EOL]     { [EOL]         final MultipleEventSource src = new MultipleEventSource(); [EOL]         final EventCounter counter = new EventCounter(); [EOL]         EventUtils.bindEventsToMethod(counter, "eventOccurred", src, MultipleEventListener.class, "event1"); [EOL]         assertEquals(0, counter.getCount()); [EOL]         src.listeners.fire().event1(new PropertyChangeEvent(new Date(), "Day", Integer.valueOf(0), Integer.valueOf(1))); [EOL]         assertEquals(1, counter.getCount()); [EOL]         src.listeners.fire().event2(new PropertyChangeEvent(new Date(), "Day", Integer.valueOf(1), Integer.valueOf(2))); [EOL]         assertEquals(1, counter.getCount()); [EOL]     } [EOL]  [EOL]     public static interface MultipleEventListener [EOL]     { [EOL]         public void event1(PropertyChangeEvent e); [EOL]  [EOL]         public void event2(PropertyChangeEvent e); [EOL]     } [EOL]  [EOL]     public static class EventCounter [EOL]     { [EOL]         private int count; [EOL]  [EOL]         public void eventOccurred() [EOL]         { [EOL]             count++; [EOL]         } [EOL]  [EOL]         public int getCount() [EOL]         { [EOL]             return count; [EOL]         } [EOL]     } [EOL]  [EOL]     public static class EventCounterWithEvent [EOL]     { [EOL]         private int count; [EOL]  [EOL]         public void eventOccurred(final PropertyChangeEvent e) [EOL]         { [EOL]             count++; [EOL]         } [EOL]  [EOL]         public int getCount() [EOL]         { [EOL]             return count; [EOL]         } [EOL]     } [EOL]  [EOL]  [EOL]     private static class EventCountingInvociationHandler implements InvocationHandler [EOL]     { [EOL]         private final Map<String, Integer> eventCounts = new TreeMap<String, Integer>(); [EOL]  [EOL]         public <L> L createListener(final Class<L> listenerType) [EOL]         { [EOL]             return listenerType.cast(Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), [EOL]                     new Class[]{listenerType}, [EOL]                     this)); [EOL]         } [EOL]  [EOL]         public int getEventCount(final String eventName) [EOL]         { [EOL]             final Integer count = eventCounts.get(eventName); [EOL]             return count == null ? 0 : count.intValue(); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public Object invoke(final Object proxy, final Method method, final Object[] args) throws Throwable [EOL]         { [EOL]             final Integer count = eventCounts.get(method.getName()); [EOL]             if (count == null) [EOL]             { [EOL]                 eventCounts.put(method.getName(), Integer.valueOf(1)); [EOL]             } [EOL]             else [EOL]             { [EOL]                 eventCounts.put(method.getName(), Integer.valueOf(count.intValue() + 1)); [EOL]             } [EOL]             return null; [EOL]         } [EOL]     } [EOL]  [EOL]     public static class MultipleEventSource [EOL]     { [EOL]         private final EventListenerSupport<MultipleEventListener> listeners = EventListenerSupport.create(MultipleEventListener.class); [EOL]  [EOL]         public void addMultipleEventListener(final MultipleEventListener listener) [EOL]         { [EOL]             listeners.addListener(listener); [EOL]         } [EOL]     } [EOL]  [EOL]     public static class ExceptionEventSource [EOL]     { [EOL]         public void addPropertyChangeListener(final PropertyChangeListener listener) [EOL]         { [EOL]             throw new RuntimeException(); [EOL]         } [EOL]     } [EOL]  [EOL]     public static class PropertyChangeSource [EOL]     { [EOL]         private final EventListenerSupport<PropertyChangeListener> listeners = EventListenerSupport.create(PropertyChangeListener.class); [EOL]  [EOL]         private String property; [EOL]  [EOL]         public void setProperty(final String property) [EOL]         { [EOL]             final String oldValue = this.property; [EOL]             this.property = property; [EOL]             listeners.fire().propertyChange(new PropertyChangeEvent(this, "property", oldValue, property)); [EOL]         } [EOL]  [EOL]         protected void addVetoableChangeListener(final VetoableChangeListener listener) [EOL]         { [EOL]             // Do nothing! [EOL]         } [EOL]  [EOL]         public void addPropertyChangeListener(final PropertyChangeListener listener) [EOL]         { [EOL]             listeners.addListener(listener); [EOL]         } [EOL]  [EOL]         public void removePropertyChangeListener(final PropertyChangeListener listener) [EOL]         { [EOL]             listeners.removeListener(listener); [EOL]         } [EOL]     } [EOL] } [EOL]
@Test [EOL]     public void testBindFilteredEventsToMethod() [EOL]     { [EOL]         final MultipleEventSource src = new MultipleEventSource(); [EOL]         final EventCounter counter = new EventCounter(); [EOL]         EventUtils.bindEventsToMethod(counter, "eventOccurred", src, MultipleEventListener.class, "event1"); [EOL]         assertEquals(0, counter.getCount()); [EOL]         src.listeners.fire().event1(new PropertyChangeEvent(new Date(), "Day", Integer.valueOf(0), Integer.valueOf(1))); [EOL]         assertEquals(1, counter.getCount()); [EOL]         src.listeners.fire().event2(new PropertyChangeEvent(new Date(), "Day", Integer.valueOf(1), Integer.valueOf(2))); [EOL]         assertEquals(1, counter.getCount()); [EOL]     } [EOL]  [EOL]     public static interface MultipleEventListener [EOL]     { [EOL]         public void event1(PropertyChangeEvent e); [EOL]  [EOL]         public void event2(PropertyChangeEvent e); [EOL]     } [EOL]  [EOL]     public static class EventCounter [EOL]     { [EOL]         private int count; [EOL]  [EOL]         public void eventOccurred() [EOL]         { [EOL]             count++; [EOL]         } [EOL]  [EOL]         public int getCount() [EOL]         { [EOL]             return count; [EOL]         } [EOL]     } [EOL]  [EOL]     public static class EventCounterWithEvent [EOL]     { [EOL]         private int count; [EOL]  [EOL]         public void eventOccurred(final PropertyChangeEvent e) [EOL]         { [EOL]             count++; [EOL]         } [EOL]  [EOL]         public int getCount() [EOL]         { [EOL]             return count; [EOL]         } [EOL]     } [EOL]  [EOL]  [EOL]     private static class EventCountingInvociationHandler implements InvocationHandler [EOL]     { [EOL]         private final Map<String, Integer> eventCounts = new TreeMap<String, Integer>(); [EOL]  [EOL]         public <L> L createListener(final Class<L> listenerType) [EOL]         { [EOL]             return listenerType.cast(Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), [EOL]                     new Class[]{listenerType}, [EOL]                     this)); [EOL]         } [EOL]  [EOL]         public int getEventCount(final String eventName) [EOL]         { [EOL]             final Integer count = eventCounts.get(eventName); [EOL]             return count == null ? 0 : count.intValue(); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public Object invoke(final Object proxy, final Method method, final Object[] args) throws Throwable [EOL]         { [EOL]             final Integer count = eventCounts.get(method.getName()); [EOL]             if (count == null) [EOL]             { [EOL]                 eventCounts.put(method.getName(), Integer.valueOf(1)); [EOL]             } [EOL]             else [EOL]             { [EOL]                 eventCounts.put(method.getName(), Integer.valueOf(count.intValue() + 1)); [EOL]             } [EOL]             return null; [EOL]         } [EOL]     } [EOL]  [EOL]     public static class MultipleEventSource [EOL]     { [EOL]         private final EventListenerSupport<MultipleEventListener> listeners = EventListenerSupport.create(MultipleEventListener.class); [EOL]  [EOL]         public void addMultipleEventListener(final MultipleEventListener listener) [EOL]         { [EOL]             listeners.addListener(listener); [EOL]         } [EOL]     } [EOL]  [EOL]     public static class ExceptionEventSource [EOL]     { [EOL]         public void addPropertyChangeListener(final PropertyChangeListener listener) [EOL]         { [EOL]             throw new RuntimeException(); [EOL]         } [EOL]     } [EOL]  [EOL]     public static class PropertyChangeSource [EOL]     { [EOL]         private final EventListenerSupport<PropertyChangeListener> listeners = EventListenerSupport.create(PropertyChangeListener.class); [EOL]  [EOL]         private String property; [EOL]  [EOL]         public void setProperty(final String property) [EOL]         { [EOL]             final String oldValue = this.property; [EOL]             this.property = property; [EOL]             listeners.fire().propertyChange(new PropertyChangeEvent(this, "property", oldValue, property)); [EOL]         } [EOL]  [EOL]         protected void addVetoableChangeListener(final VetoableChangeListener listener) [EOL]         { [EOL]             // Do nothing! [EOL]         } [EOL]  [EOL]         public void addPropertyChangeListener(final PropertyChangeListener listener) [EOL]         { [EOL]             listeners.addListener(listener); [EOL]         } [EOL]  [EOL]         public void removePropertyChangeListener(final PropertyChangeListener listener) [EOL]         { [EOL]             listeners.removeListener(listener); [EOL]         } [EOL]     } [EOL] } [EOL]
@Test [EOL]     public void testBindFilteredEventsToMethod() [EOL]     { [EOL]         final MultipleEventSource src = new MultipleEventSource(); [EOL]         final EventCounter counter = new EventCounter(); [EOL]         EventUtils.bindEventsToMethod(counter, "eventOccurred", src, MultipleEventListener.class, "event1"); [EOL]         assertEquals(0, counter.getCount()); [EOL]         src.listeners.fire().event1(new PropertyChangeEvent(new Date(), "Day", Integer.valueOf(0), Integer.valueOf(1))); [EOL]         assertEquals(1, counter.getCount()); [EOL]         src.listeners.fire().event2(new PropertyChangeEvent(new Date(), "Day", Integer.valueOf(1), Integer.valueOf(2))); [EOL]         assertEquals(1, counter.getCount()); [EOL]     } [EOL]  [EOL]     public static interface MultipleEventListener [EOL]     { [EOL]         public void event1(PropertyChangeEvent e); [EOL]  [EOL]         public void event2(PropertyChangeEvent e); [EOL]     } [EOL]  [EOL]     public static class EventCounter [EOL]     { [EOL]         private int count; [EOL]  [EOL]         public void eventOccurred() [EOL]         { [EOL]             count++; [EOL]         } [EOL]  [EOL]         public int getCount() [EOL]         { [EOL]             return count; [EOL]         } [EOL]     } [EOL]  [EOL]     public static class EventCounterWithEvent [EOL]     { [EOL]         private int count; [EOL]  [EOL]         public void eventOccurred(final PropertyChangeEvent e) [EOL]         { [EOL]             count++; [EOL]         } [EOL]  [EOL]         public int getCount() [EOL]         { [EOL]             return count; [EOL]         } [EOL]     } [EOL]  [EOL]  [EOL]     private static class EventCountingInvociationHandler implements InvocationHandler [EOL]     { [EOL]         private final Map<String, Integer> eventCounts = new TreeMap<String, Integer>(); [EOL]  [EOL]         public <L> L createListener(final Class<L> listenerType) [EOL]         { [EOL]             return listenerType.cast(Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), [EOL]                     new Class[]{listenerType}, [EOL]                     this)); [EOL]         } [EOL]  [EOL]         public int getEventCount(final String eventName) [EOL]         { [EOL]             final Integer count = eventCounts.get(eventName); [EOL]             return count == null ? 0 : count.intValue(); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public Object invoke(final Object proxy, final Method method, final Object[] args) throws Throwable [EOL]         { [EOL]             final Integer count = eventCounts.get(method.getName()); [EOL]             if (count == null) [EOL]             { [EOL]                 eventCounts.put(method.getName(), Integer.valueOf(1)); [EOL]             } [EOL]             else [EOL]             { [EOL]                 eventCounts.put(method.getName(), Integer.valueOf(count.intValue() + 1)); [EOL]             } [EOL]             return null; [EOL]         } [EOL]     } [EOL]  [EOL]     public static class MultipleEventSource [EOL]     { [EOL]         private final EventListenerSupport<MultipleEventListener> listeners = EventListenerSupport.create(MultipleEventListener.class); [EOL]  [EOL]         public void addMultipleEventListener(final MultipleEventListener listener) [EOL]         { [EOL]             listeners.addListener(listener); [EOL]         } [EOL]     } [EOL]  [EOL]     public static class ExceptionEventSource [EOL]     { [EOL]         public void addPropertyChangeListener(final PropertyChangeListener listener) [EOL]         { [EOL]             throw new RuntimeException(); [EOL]         } [EOL]     } [EOL]  [EOL]     public static class PropertyChangeSource [EOL]     { [EOL]         private final EventListenerSupport<PropertyChangeListener> listeners = EventListenerSupport.create(PropertyChangeListener.class); [EOL]  [EOL]         private String property; [EOL]  [EOL]         public void setProperty(final String property) [EOL]         { [EOL]             final String oldValue = this.property; [EOL]             this.property = property; [EOL]             listeners.fire().propertyChange(new PropertyChangeEvent(this, "property", oldValue, property)); [EOL]         } [EOL]  [EOL]         protected void addVetoableChangeListener(final VetoableChangeListener listener) [EOL]         { [EOL]             // Do nothing! [EOL]         } [EOL]  [EOL]         public void addPropertyChangeListener(final PropertyChangeListener listener) [EOL]         { [EOL]             listeners.addListener(listener); [EOL]         } [EOL]  [EOL]         public void removePropertyChangeListener(final PropertyChangeListener listener) [EOL]         { [EOL]             listeners.removeListener(listener); [EOL]         } [EOL]     } [EOL] } [EOL]
@Test [EOL]     public void testToMap() { [EOL]         Map<?, ?> map = ArrayUtils.toMap(new String[][] {{"foo", "bar"}, {"hello", "world"}}); [EOL]          [EOL]         assertEquals("bar", map.get("foo")); [EOL]         assertEquals("world", map.get("hello")); [EOL]          [EOL]         assertEquals(null, ArrayUtils.toMap(null)); [EOL]         try { [EOL]             ArrayUtils.toMap(new String[][] {{"foo", "bar"}, {"short"}}); [EOL]             fail("exception expected"); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             ArrayUtils.toMap(new Object[] {new Object[] {"foo", "bar"}, "illegal type"}); [EOL]             fail("exception expected"); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             ArrayUtils.toMap(new Object[] {new Object[] {"foo", "bar"}, null}); [EOL]             fail("exception expected"); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]          [EOL]         map = ArrayUtils.toMap(new Object[] {new Map.Entry<Object, Object>() { [EOL]             @Override [EOL]             public Object getKey() { [EOL]                 return "foo"; [EOL]             } [EOL]             @Override [EOL]             public Object getValue() { [EOL]                 return "bar"; [EOL]             } [EOL]             @Override [EOL]             public Object setValue(final Object value) { [EOL]                 throw new UnsupportedOperationException(); [EOL]             } [EOL]             @Override [EOL]             public boolean equals(final Object o) { [EOL]                 throw new UnsupportedOperationException(); [EOL]             } [EOL]             @Override [EOL]             public int hashCode() { [EOL]                 throw new UnsupportedOperationException(); [EOL]             } [EOL]         }}); [EOL]         assertEquals("bar", map.get("foo")); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testToMap() { [EOL]         Map<?, ?> map = ArrayUtils.toMap(new String[][] {{"foo", "bar"}, {"hello", "world"}}); [EOL]          [EOL]         assertEquals("bar", map.get("foo")); [EOL]         assertEquals("world", map.get("hello")); [EOL]          [EOL]         assertEquals(null, ArrayUtils.toMap(null)); [EOL]         try { [EOL]             ArrayUtils.toMap(new String[][] {{"foo", "bar"}, {"short"}}); [EOL]             fail("exception expected"); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             ArrayUtils.toMap(new Object[] {new Object[] {"foo", "bar"}, "illegal type"}); [EOL]             fail("exception expected"); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             ArrayUtils.toMap(new Object[] {new Object[] {"foo", "bar"}, null}); [EOL]             fail("exception expected"); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]          [EOL]         map = ArrayUtils.toMap(new Object[] {new Map.Entry<Object, Object>() { [EOL]             @Override [EOL]             public Object getKey() { [EOL]                 return "foo"; [EOL]             } [EOL]             @Override [EOL]             public Object getValue() { [EOL]                 return "bar"; [EOL]             } [EOL]             @Override [EOL]             public Object setValue(final Object value) { [EOL]                 throw new UnsupportedOperationException(); [EOL]             } [EOL]             @Override [EOL]             public boolean equals(final Object o) { [EOL]                 throw new UnsupportedOperationException(); [EOL]             } [EOL]             @Override [EOL]             public int hashCode() { [EOL]                 throw new UnsupportedOperationException(); [EOL]             } [EOL]         }}); [EOL]         assertEquals("bar", map.get("foo")); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testToMap() { [EOL]         Map<?, ?> map = ArrayUtils.toMap(new String[][] {{"foo", "bar"}, {"hello", "world"}}); [EOL]          [EOL]         assertEquals("bar", map.get("foo")); [EOL]         assertEquals("world", map.get("hello")); [EOL]          [EOL]         assertEquals(null, ArrayUtils.toMap(null)); [EOL]         try { [EOL]             ArrayUtils.toMap(new String[][] {{"foo", "bar"}, {"short"}}); [EOL]             fail("exception expected"); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             ArrayUtils.toMap(new Object[] {new Object[] {"foo", "bar"}, "illegal type"}); [EOL]             fail("exception expected"); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             ArrayUtils.toMap(new Object[] {new Object[] {"foo", "bar"}, null}); [EOL]             fail("exception expected"); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]          [EOL]         map = ArrayUtils.toMap(new Object[] {new Map.Entry<Object, Object>() { [EOL]             @Override [EOL]             public Object getKey() { [EOL]                 return "foo"; [EOL]             } [EOL]             @Override [EOL]             public Object getValue() { [EOL]                 return "bar"; [EOL]             } [EOL]             @Override [EOL]             public Object setValue(final Object value) { [EOL]                 throw new UnsupportedOperationException(); [EOL]             } [EOL]             @Override [EOL]             public boolean equals(final Object o) { [EOL]                 throw new UnsupportedOperationException(); [EOL]             } [EOL]             @Override [EOL]             public int hashCode() { [EOL]                 throw new UnsupportedOperationException(); [EOL]             } [EOL]         }}); [EOL]         assertEquals("bar", map.get("foo")); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testToMap() { [EOL]         Map<?, ?> map = ArrayUtils.toMap(new String[][] {{"foo", "bar"}, {"hello", "world"}}); [EOL]          [EOL]         assertEquals("bar", map.get("foo")); [EOL]         assertEquals("world", map.get("hello")); [EOL]          [EOL]         assertEquals(null, ArrayUtils.toMap(null)); [EOL]         try { [EOL]             ArrayUtils.toMap(new String[][] {{"foo", "bar"}, {"short"}}); [EOL]             fail("exception expected"); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             ArrayUtils.toMap(new Object[] {new Object[] {"foo", "bar"}, "illegal type"}); [EOL]             fail("exception expected"); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             ArrayUtils.toMap(new Object[] {new Object[] {"foo", "bar"}, null}); [EOL]             fail("exception expected"); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]          [EOL]         map = ArrayUtils.toMap(new Object[] {new Map.Entry<Object, Object>() { [EOL]             @Override [EOL]             public Object getKey() { [EOL]                 return "foo"; [EOL]             } [EOL]             @Override [EOL]             public Object getValue() { [EOL]                 return "bar"; [EOL]             } [EOL]             @Override [EOL]             public Object setValue(final Object value) { [EOL]                 throw new UnsupportedOperationException(); [EOL]             } [EOL]             @Override [EOL]             public boolean equals(final Object o) { [EOL]                 throw new UnsupportedOperationException(); [EOL]             } [EOL]             @Override [EOL]             public int hashCode() { [EOL]                 throw new UnsupportedOperationException(); [EOL]             } [EOL]         }}); [EOL]         assertEquals("bar", map.get("foo")); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testToMap() { [EOL]         Map<?, ?> map = ArrayUtils.toMap(new String[][] {{"foo", "bar"}, {"hello", "world"}}); [EOL]          [EOL]         assertEquals("bar", map.get("foo")); [EOL]         assertEquals("world", map.get("hello")); [EOL]          [EOL]         assertEquals(null, ArrayUtils.toMap(null)); [EOL]         try { [EOL]             ArrayUtils.toMap(new String[][] {{"foo", "bar"}, {"short"}}); [EOL]             fail("exception expected"); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             ArrayUtils.toMap(new Object[] {new Object[] {"foo", "bar"}, "illegal type"}); [EOL]             fail("exception expected"); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             ArrayUtils.toMap(new Object[] {new Object[] {"foo", "bar"}, null}); [EOL]             fail("exception expected"); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]          [EOL]         map = ArrayUtils.toMap(new Object[] {new Map.Entry<Object, Object>() { [EOL]             @Override [EOL]             public Object getKey() { [EOL]                 return "foo"; [EOL]             } [EOL]             @Override [EOL]             public Object getValue() { [EOL]                 return "bar"; [EOL]             } [EOL]             @Override [EOL]             public Object setValue(final Object value) { [EOL]                 throw new UnsupportedOperationException(); [EOL]             } [EOL]             @Override [EOL]             public boolean equals(final Object o) { [EOL]                 throw new UnsupportedOperationException(); [EOL]             } [EOL]             @Override [EOL]             public int hashCode() { [EOL]                 throw new UnsupportedOperationException(); [EOL]             } [EOL]         }}); [EOL]         assertEquals("bar", map.get("foo")); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testToMap() { [EOL]         Map<?, ?> map = ArrayUtils.toMap(new String[][] {{"foo", "bar"}, {"hello", "world"}}); [EOL]          [EOL]         assertEquals("bar", map.get("foo")); [EOL]         assertEquals("world", map.get("hello")); [EOL]          [EOL]         assertEquals(null, ArrayUtils.toMap(null)); [EOL]         try { [EOL]             ArrayUtils.toMap(new String[][] {{"foo", "bar"}, {"short"}}); [EOL]             fail("exception expected"); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             ArrayUtils.toMap(new Object[] {new Object[] {"foo", "bar"}, "illegal type"}); [EOL]             fail("exception expected"); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             ArrayUtils.toMap(new Object[] {new Object[] {"foo", "bar"}, null}); [EOL]             fail("exception expected"); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]          [EOL]         map = ArrayUtils.toMap(new Object[] {new Map.Entry<Object, Object>() { [EOL]             @Override [EOL]             public Object getKey() { [EOL]                 return "foo"; [EOL]             } [EOL]             @Override [EOL]             public Object getValue() { [EOL]                 return "bar"; [EOL]             } [EOL]             @Override [EOL]             public Object setValue(final Object value) { [EOL]                 throw new UnsupportedOperationException(); [EOL]             } [EOL]             @Override [EOL]             public boolean equals(final Object o) { [EOL]                 throw new UnsupportedOperationException(); [EOL]             } [EOL]             @Override [EOL]             public int hashCode() { [EOL]                 throw new UnsupportedOperationException(); [EOL]             } [EOL]         }}); [EOL]         assertEquals("bar", map.get("foo")); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testToMap() { [EOL]         Map<?, ?> map = ArrayUtils.toMap(new String[][] {{"foo", "bar"}, {"hello", "world"}}); [EOL]          [EOL]         assertEquals("bar", map.get("foo")); [EOL]         assertEquals("world", map.get("hello")); [EOL]          [EOL]         assertEquals(null, ArrayUtils.toMap(null)); [EOL]         try { [EOL]             ArrayUtils.toMap(new String[][] {{"foo", "bar"}, {"short"}}); [EOL]             fail("exception expected"); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             ArrayUtils.toMap(new Object[] {new Object[] {"foo", "bar"}, "illegal type"}); [EOL]             fail("exception expected"); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             ArrayUtils.toMap(new Object[] {new Object[] {"foo", "bar"}, null}); [EOL]             fail("exception expected"); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]          [EOL]         map = ArrayUtils.toMap(new Object[] {new Map.Entry<Object, Object>() { [EOL]             @Override [EOL]             public Object getKey() { [EOL]                 return "foo"; [EOL]             } [EOL]             @Override [EOL]             public Object getValue() { [EOL]                 return "bar"; [EOL]             } [EOL]             @Override [EOL]             public Object setValue(final Object value) { [EOL]                 throw new UnsupportedOperationException(); [EOL]             } [EOL]             @Override [EOL]             public boolean equals(final Object o) { [EOL]                 throw new UnsupportedOperationException(); [EOL]             } [EOL]             @Override [EOL]             public int hashCode() { [EOL]                 throw new UnsupportedOperationException(); [EOL]             } [EOL]         }}); [EOL]         assertEquals("bar", map.get("foo")); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testToMap() { [EOL]         Map<?, ?> map = ArrayUtils.toMap(new String[][] {{"foo", "bar"}, {"hello", "world"}}); [EOL]          [EOL]         assertEquals("bar", map.get("foo")); [EOL]         assertEquals("world", map.get("hello")); [EOL]          [EOL]         assertEquals(null, ArrayUtils.toMap(null)); [EOL]         try { [EOL]             ArrayUtils.toMap(new String[][] {{"foo", "bar"}, {"short"}}); [EOL]             fail("exception expected"); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             ArrayUtils.toMap(new Object[] {new Object[] {"foo", "bar"}, "illegal type"}); [EOL]             fail("exception expected"); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             ArrayUtils.toMap(new Object[] {new Object[] {"foo", "bar"}, null}); [EOL]             fail("exception expected"); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]          [EOL]         map = ArrayUtils.toMap(new Object[] {new Map.Entry<Object, Object>() { [EOL]             @Override [EOL]             public Object getKey() { [EOL]                 return "foo"; [EOL]             } [EOL]             @Override [EOL]             public Object getValue() { [EOL]                 return "bar"; [EOL]             } [EOL]             @Override [EOL]             public Object setValue(final Object value) { [EOL]                 throw new UnsupportedOperationException(); [EOL]             } [EOL]             @Override [EOL]             public boolean equals(final Object o) { [EOL]                 throw new UnsupportedOperationException(); [EOL]             } [EOL]             @Override [EOL]             public int hashCode() { [EOL]                 throw new UnsupportedOperationException(); [EOL]             } [EOL]         }}); [EOL]         assertEquals("bar", map.get("foo")); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testToMap() { [EOL]         Map<?, ?> map = ArrayUtils.toMap(new String[][] {{"foo", "bar"}, {"hello", "world"}}); [EOL]          [EOL]         assertEquals("bar", map.get("foo")); [EOL]         assertEquals("world", map.get("hello")); [EOL]          [EOL]         assertEquals(null, ArrayUtils.toMap(null)); [EOL]         try { [EOL]             ArrayUtils.toMap(new String[][] {{"foo", "bar"}, {"short"}}); [EOL]             fail("exception expected"); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             ArrayUtils.toMap(new Object[] {new Object[] {"foo", "bar"}, "illegal type"}); [EOL]             fail("exception expected"); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             ArrayUtils.toMap(new Object[] {new Object[] {"foo", "bar"}, null}); [EOL]             fail("exception expected"); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]          [EOL]         map = ArrayUtils.toMap(new Object[] {new Map.Entry<Object, Object>() { [EOL]             @Override [EOL]             public Object getKey() { [EOL]                 return "foo"; [EOL]             } [EOL]             @Override [EOL]             public Object getValue() { [EOL]                 return "bar"; [EOL]             } [EOL]             @Override [EOL]             public Object setValue(final Object value) { [EOL]                 throw new UnsupportedOperationException(); [EOL]             } [EOL]             @Override [EOL]             public boolean equals(final Object o) { [EOL]                 throw new UnsupportedOperationException(); [EOL]             } [EOL]             @Override [EOL]             public int hashCode() { [EOL]                 throw new UnsupportedOperationException(); [EOL]             } [EOL]         }}); [EOL]         assertEquals("bar", map.get("foo")); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testToMap() { [EOL]         Map<?, ?> map = ArrayUtils.toMap(new String[][] {{"foo", "bar"}, {"hello", "world"}}); [EOL]          [EOL]         assertEquals("bar", map.get("foo")); [EOL]         assertEquals("world", map.get("hello")); [EOL]          [EOL]         assertEquals(null, ArrayUtils.toMap(null)); [EOL]         try { [EOL]             ArrayUtils.toMap(new String[][] {{"foo", "bar"}, {"short"}}); [EOL]             fail("exception expected"); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             ArrayUtils.toMap(new Object[] {new Object[] {"foo", "bar"}, "illegal type"}); [EOL]             fail("exception expected"); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             ArrayUtils.toMap(new Object[] {new Object[] {"foo", "bar"}, null}); [EOL]             fail("exception expected"); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]          [EOL]         map = ArrayUtils.toMap(new Object[] {new Map.Entry<Object, Object>() { [EOL]             @Override [EOL]             public Object getKey() { [EOL]                 return "foo"; [EOL]             } [EOL]             @Override [EOL]             public Object getValue() { [EOL]                 return "bar"; [EOL]             } [EOL]             @Override [EOL]             public Object setValue(final Object value) { [EOL]                 throw new UnsupportedOperationException(); [EOL]             } [EOL]             @Override [EOL]             public boolean equals(final Object o) { [EOL]                 throw new UnsupportedOperationException(); [EOL]             } [EOL]             @Override [EOL]             public int hashCode() { [EOL]                 throw new UnsupportedOperationException(); [EOL]             } [EOL]         }}); [EOL]         assertEquals("bar", map.get("foo")); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testToMap() { [EOL]         Map<?, ?> map = ArrayUtils.toMap(new String[][] {{"foo", "bar"}, {"hello", "world"}}); [EOL]          [EOL]         assertEquals("bar", map.get("foo")); [EOL]         assertEquals("world", map.get("hello")); [EOL]          [EOL]         assertEquals(null, ArrayUtils.toMap(null)); [EOL]         try { [EOL]             ArrayUtils.toMap(new String[][] {{"foo", "bar"}, {"short"}}); [EOL]             fail("exception expected"); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             ArrayUtils.toMap(new Object[] {new Object[] {"foo", "bar"}, "illegal type"}); [EOL]             fail("exception expected"); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             ArrayUtils.toMap(new Object[] {new Object[] {"foo", "bar"}, null}); [EOL]             fail("exception expected"); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]          [EOL]         map = ArrayUtils.toMap(new Object[] {new Map.Entry<Object, Object>() { [EOL]             @Override [EOL]             public Object getKey() { [EOL]                 return "foo"; [EOL]             } [EOL]             @Override [EOL]             public Object getValue() { [EOL]                 return "bar"; [EOL]             } [EOL]             @Override [EOL]             public Object setValue(final Object value) { [EOL]                 throw new UnsupportedOperationException(); [EOL]             } [EOL]             @Override [EOL]             public boolean equals(final Object o) { [EOL]                 throw new UnsupportedOperationException(); [EOL]             } [EOL]             @Override [EOL]             public int hashCode() { [EOL]                 throw new UnsupportedOperationException(); [EOL]             } [EOL]         }}); [EOL]         assertEquals("bar", map.get("foo")); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testRemoveElementBooleanArray() { [EOL]         boolean[] array; [EOL]         array = ArrayUtils.removeElement((boolean[]) null, true); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElement(ArrayUtils.EMPTY_BOOLEAN_ARRAY, true); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BOOLEAN_ARRAY, array)); [EOL]         assertEquals(Boolean.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElement(new boolean[] {true}, true); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BOOLEAN_ARRAY, array)); [EOL]         assertEquals(Boolean.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElement(new boolean[] {true, false}, true); [EOL]         assertTrue(Arrays.equals(new boolean[] {false}, array)); [EOL]         assertEquals(Boolean.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElement(new boolean[] {true, false, true}, true); [EOL]         assertTrue(Arrays.equals(new boolean[] {false, true}, array)); [EOL]         assertEquals(Boolean.TYPE, array.getClass().getComponentType()); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testNullToEmptyObject() { [EOL]         // Test null handling [EOL]         assertArrayEquals(ArrayUtils.EMPTY_OBJECT_ARRAY, ArrayUtils.nullToEmpty((Object[]) null)); [EOL]         // Test valid array handling [EOL]         final Object[] original = new Object[] {Boolean.TRUE, Boolean.FALSE}; [EOL]         assertArrayEquals(original, ArrayUtils.nullToEmpty(original)); [EOL]         // Test empty array handling [EOL]         final Object[] empty = new Object[]{}; [EOL]         final Object[] result = ArrayUtils.nullToEmpty(empty); [EOL]         assertArrayEquals(ArrayUtils.EMPTY_OBJECT_ARRAY, result); [EOL]         assertTrue(empty != result); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNullToEmptyString() { [EOL]         // Test null handling [EOL]         assertArrayEquals(ArrayUtils.EMPTY_STRING_ARRAY, ArrayUtils.nullToEmpty((String[]) null)); [EOL]         // Test valid array handling [EOL]         final String[] original = new String[] {"abc", "def"}; [EOL]         assertArrayEquals(original, ArrayUtils.nullToEmpty(original)); [EOL]         // Test empty array handling [EOL]         final String[] empty = new String[]{}; [EOL]         final String[] result = ArrayUtils.nullToEmpty(empty); [EOL]         assertArrayEquals(ArrayUtils.EMPTY_STRING_ARRAY, result); [EOL]         assertTrue(empty != result); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNullToEmptyInt() { [EOL]         // Test null handling [EOL]         assertEquals(ArrayUtils.EMPTY_INT_ARRAY, ArrayUtils.nullToEmpty((int[]) null)); [EOL]         // Test valid array handling [EOL]         final int[] original = new int[] {1, 2}; [EOL]         assertEquals(original, ArrayUtils.nullToEmpty(original)); [EOL]         // Test empty array handling [EOL]         final int[] empty = new int[]{}; [EOL]         final int[] result = ArrayUtils.nullToEmpty(empty); [EOL]         assertEquals(ArrayUtils.EMPTY_INT_ARRAY, result); [EOL]         assertTrue(empty != result); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testNullToEmptyByte() { [EOL]         // Test null handling [EOL]         assertEquals(ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.nullToEmpty((byte[]) null)); [EOL]         // Test valid array handling [EOL]         final byte[] original = new byte[] {0x0F, 0x0E}; [EOL]         assertEquals(original, ArrayUtils.nullToEmpty(original)); [EOL]         // Test empty array handling [EOL]         final byte[] empty = new byte[]{}; [EOL]         final byte[] result = ArrayUtils.nullToEmpty(empty); [EOL]         assertEquals(ArrayUtils.EMPTY_BYTE_ARRAY, result); [EOL]         assertTrue(empty != result); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testNullToEmptyIntObject() { [EOL]         // Test null handling [EOL]         assertArrayEquals(ArrayUtils.EMPTY_INTEGER_OBJECT_ARRAY, ArrayUtils.nullToEmpty((Integer[]) null)); [EOL]         // Test valid array handling [EOL]         final Integer[] original = new Integer[] {1, 2}; [EOL]         assertArrayEquals(original, ArrayUtils.nullToEmpty(original)); [EOL]         // Test empty array handling [EOL]         final Integer[] empty = new Integer[]{}; [EOL]         final Integer[] result = ArrayUtils.nullToEmpty(empty); [EOL]         assertArrayEquals(ArrayUtils.EMPTY_INTEGER_OBJECT_ARRAY, result); [EOL]         assertTrue(empty != result); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testNullToEmptyByteObject() { [EOL]         // Test null handling [EOL]         assertArrayEquals(ArrayUtils.EMPTY_BYTE_OBJECT_ARRAY, ArrayUtils.nullToEmpty((Byte[]) null)); [EOL]         // Test valid array handling [EOL]         final Byte[] original = new Byte[] {0x0F, 0x0E}; [EOL]         assertArrayEquals(original, ArrayUtils.nullToEmpty(original)); [EOL]         // Test empty array handling [EOL]         final Byte[] empty = new Byte[]{}; [EOL]         final Byte[] result = ArrayUtils.nullToEmpty(empty); [EOL]         assertArrayEquals(ArrayUtils.EMPTY_BYTE_OBJECT_ARRAY, result); [EOL]         assertTrue(empty != result); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testNullToEmptyDoubleObject() { [EOL]         // Test null handling [EOL]         assertArrayEquals(ArrayUtils.EMPTY_DOUBLE_OBJECT_ARRAY, ArrayUtils.nullToEmpty((Double[]) null)); [EOL]         // Test valid array handling [EOL]         final Double[] original = new Double[] {1D, 2D}; [EOL]         assertArrayEquals(original, ArrayUtils.nullToEmpty(original)); [EOL]         // Test empty array handling [EOL]         final Double[] empty = new Double[]{}; [EOL]         final Double[] result = ArrayUtils.nullToEmpty(empty); [EOL]         assertArrayEquals(ArrayUtils.EMPTY_DOUBLE_OBJECT_ARRAY, result); [EOL]         assertTrue(empty != result); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testSubarrayObject() { [EOL]         final Object[] nullArray = null; [EOL]         final Object[] objectArray = { "a", "b", "c", "d", "e", "f"}; [EOL]  [EOL]         assertEquals("0 start, mid end", "abcd", [EOL]             StringUtils.join(ArrayUtils.subarray(objectArray, 0, 4))); [EOL]         assertEquals("0 start, length end", "abcdef", [EOL]             StringUtils.join(ArrayUtils.subarray(objectArray, 0, objectArray.length))); [EOL]         assertEquals("mid start, mid end", "bcd", [EOL]             StringUtils.join(ArrayUtils.subarray(objectArray, 1, 4))); [EOL]         assertEquals("mid start, length end", "bcdef", [EOL]             StringUtils.join(ArrayUtils.subarray(objectArray, 1, objectArray.length))); [EOL]  [EOL]         assertNull("null input", ArrayUtils.subarray(nullArray, 0, 3)); [EOL]         assertEquals("empty array", "", [EOL]             StringUtils.join(ArrayUtils.subarray(ArrayUtils.EMPTY_OBJECT_ARRAY, 1, 2))); [EOL]         assertEquals("start > end", "", [EOL]             StringUtils.join(ArrayUtils.subarray(objectArray, 4, 2))); [EOL]         assertEquals("start == end", "", [EOL]             StringUtils.join(ArrayUtils.subarray(objectArray, 3, 3))); [EOL]         assertEquals("start undershoot, normal end", "abcd", [EOL]             StringUtils.join(ArrayUtils.subarray(objectArray, -2, 4))); [EOL]         assertEquals("start overshoot, any end", "", [EOL]             StringUtils.join(ArrayUtils.subarray(objectArray, 33, 4))); [EOL]         assertEquals("normal start, end overshoot", "cdef", [EOL]             StringUtils.join(ArrayUtils.subarray(objectArray, 2, 33))); [EOL]         assertEquals("start undershoot, end overshoot", "abcdef", [EOL]             StringUtils.join(ArrayUtils.subarray(objectArray, -2, 12))); [EOL]              [EOL]         // array type tests [EOL]         final Date[] dateArray = { new java.sql.Date(new Date().getTime()), [EOL]             new Date(), new Date(), new Date(), new Date() }; [EOL]  [EOL]         assertSame("Object type", Object.class, [EOL]             ArrayUtils.subarray(objectArray, 2, 4).getClass().getComponentType()); [EOL]         assertSame("java.util.Date type", java.util.Date.class, [EOL]             ArrayUtils.subarray(dateArray, 1, 4).getClass().getComponentType()); [EOL]         assertNotSame("java.sql.Date type", java.sql.Date.class, [EOL]             ArrayUtils.subarray(dateArray, 1, 4).getClass().getComponentType()); [EOL]         try { [EOL]             @SuppressWarnings("unused") [EOL]             final [EOL]             java.sql.Date[] dummy = (java.sql.Date[])ArrayUtils.subarray(dateArray, 1,3); [EOL]             fail("Invalid downcast"); [EOL]         } catch (final ClassCastException e) {} [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSubarrayObject() { [EOL]         final Object[] nullArray = null; [EOL]         final Object[] objectArray = { "a", "b", "c", "d", "e", "f"}; [EOL]  [EOL]         assertEquals("0 start, mid end", "abcd", [EOL]             StringUtils.join(ArrayUtils.subarray(objectArray, 0, 4))); [EOL]         assertEquals("0 start, length end", "abcdef", [EOL]             StringUtils.join(ArrayUtils.subarray(objectArray, 0, objectArray.length))); [EOL]         assertEquals("mid start, mid end", "bcd", [EOL]             StringUtils.join(ArrayUtils.subarray(objectArray, 1, 4))); [EOL]         assertEquals("mid start, length end", "bcdef", [EOL]             StringUtils.join(ArrayUtils.subarray(objectArray, 1, objectArray.length))); [EOL]  [EOL]         assertNull("null input", ArrayUtils.subarray(nullArray, 0, 3)); [EOL]         assertEquals("empty array", "", [EOL]             StringUtils.join(ArrayUtils.subarray(ArrayUtils.EMPTY_OBJECT_ARRAY, 1, 2))); [EOL]         assertEquals("start > end", "", [EOL]             StringUtils.join(ArrayUtils.subarray(objectArray, 4, 2))); [EOL]         assertEquals("start == end", "", [EOL]             StringUtils.join(ArrayUtils.subarray(objectArray, 3, 3))); [EOL]         assertEquals("start undershoot, normal end", "abcd", [EOL]             StringUtils.join(ArrayUtils.subarray(objectArray, -2, 4))); [EOL]         assertEquals("start overshoot, any end", "", [EOL]             StringUtils.join(ArrayUtils.subarray(objectArray, 33, 4))); [EOL]         assertEquals("normal start, end overshoot", "cdef", [EOL]             StringUtils.join(ArrayUtils.subarray(objectArray, 2, 33))); [EOL]         assertEquals("start undershoot, end overshoot", "abcdef", [EOL]             StringUtils.join(ArrayUtils.subarray(objectArray, -2, 12))); [EOL]              [EOL]         // array type tests [EOL]         final Date[] dateArray = { new java.sql.Date(new Date().getTime()), [EOL]             new Date(), new Date(), new Date(), new Date() }; [EOL]  [EOL]         assertSame("Object type", Object.class, [EOL]             ArrayUtils.subarray(objectArray, 2, 4).getClass().getComponentType()); [EOL]         assertSame("java.util.Date type", java.util.Date.class, [EOL]             ArrayUtils.subarray(dateArray, 1, 4).getClass().getComponentType()); [EOL]         assertNotSame("java.sql.Date type", java.sql.Date.class, [EOL]             ArrayUtils.subarray(dateArray, 1, 4).getClass().getComponentType()); [EOL]         try { [EOL]             @SuppressWarnings("unused") [EOL]             final [EOL]             java.sql.Date[] dummy = (java.sql.Date[])ArrayUtils.subarray(dateArray, 1,3); [EOL]             fail("Invalid downcast"); [EOL]         } catch (final ClassCastException e) {} [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSubarrayObject() { [EOL]         final Object[] nullArray = null; [EOL]         final Object[] objectArray = { "a", "b", "c", "d", "e", "f"}; [EOL]  [EOL]         assertEquals("0 start, mid end", "abcd", [EOL]             StringUtils.join(ArrayUtils.subarray(objectArray, 0, 4))); [EOL]         assertEquals("0 start, length end", "abcdef", [EOL]             StringUtils.join(ArrayUtils.subarray(objectArray, 0, objectArray.length))); [EOL]         assertEquals("mid start, mid end", "bcd", [EOL]             StringUtils.join(ArrayUtils.subarray(objectArray, 1, 4))); [EOL]         assertEquals("mid start, length end", "bcdef", [EOL]             StringUtils.join(ArrayUtils.subarray(objectArray, 1, objectArray.length))); [EOL]  [EOL]         assertNull("null input", ArrayUtils.subarray(nullArray, 0, 3)); [EOL]         assertEquals("empty array", "", [EOL]             StringUtils.join(ArrayUtils.subarray(ArrayUtils.EMPTY_OBJECT_ARRAY, 1, 2))); [EOL]         assertEquals("start > end", "", [EOL]             StringUtils.join(ArrayUtils.subarray(objectArray, 4, 2))); [EOL]         assertEquals("start == end", "", [EOL]             StringUtils.join(ArrayUtils.subarray(objectArray, 3, 3))); [EOL]         assertEquals("start undershoot, normal end", "abcd", [EOL]             StringUtils.join(ArrayUtils.subarray(objectArray, -2, 4))); [EOL]         assertEquals("start overshoot, any end", "", [EOL]             StringUtils.join(ArrayUtils.subarray(objectArray, 33, 4))); [EOL]         assertEquals("normal start, end overshoot", "cdef", [EOL]             StringUtils.join(ArrayUtils.subarray(objectArray, 2, 33))); [EOL]         assertEquals("start undershoot, end overshoot", "abcdef", [EOL]             StringUtils.join(ArrayUtils.subarray(objectArray, -2, 12))); [EOL]              [EOL]         // array type tests [EOL]         final Date[] dateArray = { new java.sql.Date(new Date().getTime()), [EOL]             new Date(), new Date(), new Date(), new Date() }; [EOL]  [EOL]         assertSame("Object type", Object.class, [EOL]             ArrayUtils.subarray(objectArray, 2, 4).getClass().getComponentType()); [EOL]         assertSame("java.util.Date type", java.util.Date.class, [EOL]             ArrayUtils.subarray(dateArray, 1, 4).getClass().getComponentType()); [EOL]         assertNotSame("java.sql.Date type", java.sql.Date.class, [EOL]             ArrayUtils.subarray(dateArray, 1, 4).getClass().getComponentType()); [EOL]         try { [EOL]             @SuppressWarnings("unused") [EOL]             final [EOL]             java.sql.Date[] dummy = (java.sql.Date[])ArrayUtils.subarray(dateArray, 1,3); [EOL]             fail("Invalid downcast"); [EOL]         } catch (final ClassCastException e) {} [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSubarrayObject() { [EOL]         final Object[] nullArray = null; [EOL]         final Object[] objectArray = { "a", "b", "c", "d", "e", "f"}; [EOL]  [EOL]         assertEquals("0 start, mid end", "abcd", [EOL]             StringUtils.join(ArrayUtils.subarray(objectArray, 0, 4))); [EOL]         assertEquals("0 start, length end", "abcdef", [EOL]             StringUtils.join(ArrayUtils.subarray(objectArray, 0, objectArray.length))); [EOL]         assertEquals("mid start, mid end", "bcd", [EOL]             StringUtils.join(ArrayUtils.subarray(objectArray, 1, 4))); [EOL]         assertEquals("mid start, length end", "bcdef", [EOL]             StringUtils.join(ArrayUtils.subarray(objectArray, 1, objectArray.length))); [EOL]  [EOL]         assertNull("null input", ArrayUtils.subarray(nullArray, 0, 3)); [EOL]         assertEquals("empty array", "", [EOL]             StringUtils.join(ArrayUtils.subarray(ArrayUtils.EMPTY_OBJECT_ARRAY, 1, 2))); [EOL]         assertEquals("start > end", "", [EOL]             StringUtils.join(ArrayUtils.subarray(objectArray, 4, 2))); [EOL]         assertEquals("start == end", "", [EOL]             StringUtils.join(ArrayUtils.subarray(objectArray, 3, 3))); [EOL]         assertEquals("start undershoot, normal end", "abcd", [EOL]             StringUtils.join(ArrayUtils.subarray(objectArray, -2, 4))); [EOL]         assertEquals("start overshoot, any end", "", [EOL]             StringUtils.join(ArrayUtils.subarray(objectArray, 33, 4))); [EOL]         assertEquals("normal start, end overshoot", "cdef", [EOL]             StringUtils.join(ArrayUtils.subarray(objectArray, 2, 33))); [EOL]         assertEquals("start undershoot, end overshoot", "abcdef", [EOL]             StringUtils.join(ArrayUtils.subarray(objectArray, -2, 12))); [EOL]              [EOL]         // array type tests [EOL]         final Date[] dateArray = { new java.sql.Date(new Date().getTime()), [EOL]             new Date(), new Date(), new Date(), new Date() }; [EOL]  [EOL]         assertSame("Object type", Object.class, [EOL]             ArrayUtils.subarray(objectArray, 2, 4).getClass().getComponentType()); [EOL]         assertSame("java.util.Date type", java.util.Date.class, [EOL]             ArrayUtils.subarray(dateArray, 1, 4).getClass().getComponentType()); [EOL]         assertNotSame("java.sql.Date type", java.sql.Date.class, [EOL]             ArrayUtils.subarray(dateArray, 1, 4).getClass().getComponentType()); [EOL]         try { [EOL]             @SuppressWarnings("unused") [EOL]             final [EOL]             java.sql.Date[] dummy = (java.sql.Date[])ArrayUtils.subarray(dateArray, 1,3); [EOL]             fail("Invalid downcast"); [EOL]         } catch (final ClassCastException e) {} [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSubarrayLong() { [EOL]         final long[] nullArray = null; [EOL]         final long[] array = { 999910, 999911, 999912, 999913, 999914, 999915 }; [EOL]         final long[] leftSubarray     = { 999910, 999911, 999912, 999913 }; [EOL]         final long[] midSubarray      = { 999911, 999912, 999913, 999914 }; [EOL]         final long[] rightSubarray    = { 999912, 999913, 999914, 999915 }; [EOL]  [EOL]         assertTrue("0 start, mid end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, 0, 4))); [EOL]  [EOL]         assertTrue("0 start, length end", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, 0, array.length))); [EOL]  [EOL]         assertTrue("mid start, mid end", [EOL]             ArrayUtils.isEquals(midSubarray, [EOL]                 ArrayUtils.subarray(array, 1, 5))); [EOL]  [EOL]         assertTrue("mid start, length end", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]                 ArrayUtils.subarray(array, 2, array.length))); [EOL]  [EOL]  [EOL]         assertNull("null input", ArrayUtils.subarray(nullArray, 0, 3)); [EOL]  [EOL]         assertEquals("empty array", ArrayUtils.EMPTY_LONG_ARRAY, [EOL]             ArrayUtils.subarray(ArrayUtils.EMPTY_LONG_ARRAY, 1, 2)); [EOL]  [EOL]         assertEquals("start > end", ArrayUtils.EMPTY_LONG_ARRAY, [EOL]             ArrayUtils.subarray(array, 4, 2)); [EOL]  [EOL]         assertEquals("start == end", ArrayUtils.EMPTY_LONG_ARRAY, [EOL]             ArrayUtils.subarray(array, 3, 3)); [EOL]  [EOL]         assertTrue("start undershoot, normal end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, -2, 4))); [EOL]  [EOL]         assertEquals("start overshoot, any end", [EOL]             ArrayUtils.EMPTY_LONG_ARRAY, [EOL]                 ArrayUtils.subarray(array, 33, 4)); [EOL]  [EOL]         assertTrue("normal start, end overshoot", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]                 ArrayUtils.subarray(array, 2, 33))); [EOL]  [EOL]         assertTrue("start undershoot, end overshoot", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, -2, 12))); [EOL]  [EOL]         // empty-return tests [EOL]  [EOL]         assertSame("empty array, object test", [EOL]             ArrayUtils.EMPTY_LONG_ARRAY, [EOL]                 ArrayUtils.subarray(ArrayUtils.EMPTY_LONG_ARRAY, 1, 2)); [EOL]  [EOL]         assertSame("start > end, object test", [EOL]             ArrayUtils.EMPTY_LONG_ARRAY, [EOL]                 ArrayUtils.subarray(array, 4, 1)); [EOL]  [EOL]         assertSame("start == end, object test", [EOL]             ArrayUtils.EMPTY_LONG_ARRAY, [EOL]                 ArrayUtils.subarray(array, 3, 3)); [EOL]  [EOL]         assertSame("start overshoot, any end, object test", [EOL]             ArrayUtils.EMPTY_LONG_ARRAY, [EOL]                 ArrayUtils.subarray(array, 8733, 4)); [EOL]  [EOL]         // array type tests [EOL]  [EOL]         assertSame("long type", long.class, [EOL]             ArrayUtils.subarray(array, 2, 4).getClass().getComponentType()); [EOL]  [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSubarrayLong() { [EOL]         final long[] nullArray = null; [EOL]         final long[] array = { 999910, 999911, 999912, 999913, 999914, 999915 }; [EOL]         final long[] leftSubarray     = { 999910, 999911, 999912, 999913 }; [EOL]         final long[] midSubarray      = { 999911, 999912, 999913, 999914 }; [EOL]         final long[] rightSubarray    = { 999912, 999913, 999914, 999915 }; [EOL]  [EOL]         assertTrue("0 start, mid end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, 0, 4))); [EOL]  [EOL]         assertTrue("0 start, length end", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, 0, array.length))); [EOL]  [EOL]         assertTrue("mid start, mid end", [EOL]             ArrayUtils.isEquals(midSubarray, [EOL]                 ArrayUtils.subarray(array, 1, 5))); [EOL]  [EOL]         assertTrue("mid start, length end", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]                 ArrayUtils.subarray(array, 2, array.length))); [EOL]  [EOL]  [EOL]         assertNull("null input", ArrayUtils.subarray(nullArray, 0, 3)); [EOL]  [EOL]         assertEquals("empty array", ArrayUtils.EMPTY_LONG_ARRAY, [EOL]             ArrayUtils.subarray(ArrayUtils.EMPTY_LONG_ARRAY, 1, 2)); [EOL]  [EOL]         assertEquals("start > end", ArrayUtils.EMPTY_LONG_ARRAY, [EOL]             ArrayUtils.subarray(array, 4, 2)); [EOL]  [EOL]         assertEquals("start == end", ArrayUtils.EMPTY_LONG_ARRAY, [EOL]             ArrayUtils.subarray(array, 3, 3)); [EOL]  [EOL]         assertTrue("start undershoot, normal end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, -2, 4))); [EOL]  [EOL]         assertEquals("start overshoot, any end", [EOL]             ArrayUtils.EMPTY_LONG_ARRAY, [EOL]                 ArrayUtils.subarray(array, 33, 4)); [EOL]  [EOL]         assertTrue("normal start, end overshoot", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]                 ArrayUtils.subarray(array, 2, 33))); [EOL]  [EOL]         assertTrue("start undershoot, end overshoot", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, -2, 12))); [EOL]  [EOL]         // empty-return tests [EOL]  [EOL]         assertSame("empty array, object test", [EOL]             ArrayUtils.EMPTY_LONG_ARRAY, [EOL]                 ArrayUtils.subarray(ArrayUtils.EMPTY_LONG_ARRAY, 1, 2)); [EOL]  [EOL]         assertSame("start > end, object test", [EOL]             ArrayUtils.EMPTY_LONG_ARRAY, [EOL]                 ArrayUtils.subarray(array, 4, 1)); [EOL]  [EOL]         assertSame("start == end, object test", [EOL]             ArrayUtils.EMPTY_LONG_ARRAY, [EOL]                 ArrayUtils.subarray(array, 3, 3)); [EOL]  [EOL]         assertSame("start overshoot, any end, object test", [EOL]             ArrayUtils.EMPTY_LONG_ARRAY, [EOL]                 ArrayUtils.subarray(array, 8733, 4)); [EOL]  [EOL]         // array type tests [EOL]  [EOL]         assertSame("long type", long.class, [EOL]             ArrayUtils.subarray(array, 2, 4).getClass().getComponentType()); [EOL]  [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSubarrayLong() { [EOL]         final long[] nullArray = null; [EOL]         final long[] array = { 999910, 999911, 999912, 999913, 999914, 999915 }; [EOL]         final long[] leftSubarray     = { 999910, 999911, 999912, 999913 }; [EOL]         final long[] midSubarray      = { 999911, 999912, 999913, 999914 }; [EOL]         final long[] rightSubarray    = { 999912, 999913, 999914, 999915 }; [EOL]  [EOL]         assertTrue("0 start, mid end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, 0, 4))); [EOL]  [EOL]         assertTrue("0 start, length end", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, 0, array.length))); [EOL]  [EOL]         assertTrue("mid start, mid end", [EOL]             ArrayUtils.isEquals(midSubarray, [EOL]                 ArrayUtils.subarray(array, 1, 5))); [EOL]  [EOL]         assertTrue("mid start, length end", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]                 ArrayUtils.subarray(array, 2, array.length))); [EOL]  [EOL]  [EOL]         assertNull("null input", ArrayUtils.subarray(nullArray, 0, 3)); [EOL]  [EOL]         assertEquals("empty array", ArrayUtils.EMPTY_LONG_ARRAY, [EOL]             ArrayUtils.subarray(ArrayUtils.EMPTY_LONG_ARRAY, 1, 2)); [EOL]  [EOL]         assertEquals("start > end", ArrayUtils.EMPTY_LONG_ARRAY, [EOL]             ArrayUtils.subarray(array, 4, 2)); [EOL]  [EOL]         assertEquals("start == end", ArrayUtils.EMPTY_LONG_ARRAY, [EOL]             ArrayUtils.subarray(array, 3, 3)); [EOL]  [EOL]         assertTrue("start undershoot, normal end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, -2, 4))); [EOL]  [EOL]         assertEquals("start overshoot, any end", [EOL]             ArrayUtils.EMPTY_LONG_ARRAY, [EOL]                 ArrayUtils.subarray(array, 33, 4)); [EOL]  [EOL]         assertTrue("normal start, end overshoot", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]                 ArrayUtils.subarray(array, 2, 33))); [EOL]  [EOL]         assertTrue("start undershoot, end overshoot", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, -2, 12))); [EOL]  [EOL]         // empty-return tests [EOL]  [EOL]         assertSame("empty array, object test", [EOL]             ArrayUtils.EMPTY_LONG_ARRAY, [EOL]                 ArrayUtils.subarray(ArrayUtils.EMPTY_LONG_ARRAY, 1, 2)); [EOL]  [EOL]         assertSame("start > end, object test", [EOL]             ArrayUtils.EMPTY_LONG_ARRAY, [EOL]                 ArrayUtils.subarray(array, 4, 1)); [EOL]  [EOL]         assertSame("start == end, object test", [EOL]             ArrayUtils.EMPTY_LONG_ARRAY, [EOL]                 ArrayUtils.subarray(array, 3, 3)); [EOL]  [EOL]         assertSame("start overshoot, any end, object test", [EOL]             ArrayUtils.EMPTY_LONG_ARRAY, [EOL]                 ArrayUtils.subarray(array, 8733, 4)); [EOL]  [EOL]         // array type tests [EOL]  [EOL]         assertSame("long type", long.class, [EOL]             ArrayUtils.subarray(array, 2, 4).getClass().getComponentType()); [EOL]  [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSubarrayLong() { [EOL]         final long[] nullArray = null; [EOL]         final long[] array = { 999910, 999911, 999912, 999913, 999914, 999915 }; [EOL]         final long[] leftSubarray     = { 999910, 999911, 999912, 999913 }; [EOL]         final long[] midSubarray      = { 999911, 999912, 999913, 999914 }; [EOL]         final long[] rightSubarray    = { 999912, 999913, 999914, 999915 }; [EOL]  [EOL]         assertTrue("0 start, mid end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, 0, 4))); [EOL]  [EOL]         assertTrue("0 start, length end", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, 0, array.length))); [EOL]  [EOL]         assertTrue("mid start, mid end", [EOL]             ArrayUtils.isEquals(midSubarray, [EOL]                 ArrayUtils.subarray(array, 1, 5))); [EOL]  [EOL]         assertTrue("mid start, length end", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]                 ArrayUtils.subarray(array, 2, array.length))); [EOL]  [EOL]  [EOL]         assertNull("null input", ArrayUtils.subarray(nullArray, 0, 3)); [EOL]  [EOL]         assertEquals("empty array", ArrayUtils.EMPTY_LONG_ARRAY, [EOL]             ArrayUtils.subarray(ArrayUtils.EMPTY_LONG_ARRAY, 1, 2)); [EOL]  [EOL]         assertEquals("start > end", ArrayUtils.EMPTY_LONG_ARRAY, [EOL]             ArrayUtils.subarray(array, 4, 2)); [EOL]  [EOL]         assertEquals("start == end", ArrayUtils.EMPTY_LONG_ARRAY, [EOL]             ArrayUtils.subarray(array, 3, 3)); [EOL]  [EOL]         assertTrue("start undershoot, normal end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, -2, 4))); [EOL]  [EOL]         assertEquals("start overshoot, any end", [EOL]             ArrayUtils.EMPTY_LONG_ARRAY, [EOL]                 ArrayUtils.subarray(array, 33, 4)); [EOL]  [EOL]         assertTrue("normal start, end overshoot", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]                 ArrayUtils.subarray(array, 2, 33))); [EOL]  [EOL]         assertTrue("start undershoot, end overshoot", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, -2, 12))); [EOL]  [EOL]         // empty-return tests [EOL]  [EOL]         assertSame("empty array, object test", [EOL]             ArrayUtils.EMPTY_LONG_ARRAY, [EOL]                 ArrayUtils.subarray(ArrayUtils.EMPTY_LONG_ARRAY, 1, 2)); [EOL]  [EOL]         assertSame("start > end, object test", [EOL]             ArrayUtils.EMPTY_LONG_ARRAY, [EOL]                 ArrayUtils.subarray(array, 4, 1)); [EOL]  [EOL]         assertSame("start == end, object test", [EOL]             ArrayUtils.EMPTY_LONG_ARRAY, [EOL]                 ArrayUtils.subarray(array, 3, 3)); [EOL]  [EOL]         assertSame("start overshoot, any end, object test", [EOL]             ArrayUtils.EMPTY_LONG_ARRAY, [EOL]                 ArrayUtils.subarray(array, 8733, 4)); [EOL]  [EOL]         // array type tests [EOL]  [EOL]         assertSame("long type", long.class, [EOL]             ArrayUtils.subarray(array, 2, 4).getClass().getComponentType()); [EOL]  [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSubarrayShort() { [EOL]         final short[] nullArray = null; [EOL]         final short[] array = { 10, 11, 12, 13, 14, 15 }; [EOL]         final short[] leftSubarray    = { 10, 11, 12, 13 }; [EOL]         final short[] midSubarray     = { 11, 12, 13, 14 }; [EOL]         final short[] rightSubarray   = { 12, 13, 14, 15 }; [EOL]  [EOL]  [EOL]         assertTrue("0 start, mid end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, 0, 4))); [EOL]  [EOL]         assertTrue("0 start, length end", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, 0, array.length))); [EOL]  [EOL]         assertTrue("mid start, mid end", [EOL]             ArrayUtils.isEquals(midSubarray, [EOL]                 ArrayUtils.subarray(array, 1, 5))); [EOL]  [EOL]         assertTrue("mid start, length end", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]                 ArrayUtils.subarray(array, 2, array.length))); [EOL]  [EOL]  [EOL]         assertNull("null input", ArrayUtils.subarray(nullArray, 0, 3)); [EOL]  [EOL]         assertEquals("empty array", ArrayUtils.EMPTY_SHORT_ARRAY, [EOL]             ArrayUtils.subarray(ArrayUtils.EMPTY_SHORT_ARRAY, 1, 2)); [EOL]  [EOL]         assertEquals("start > end", ArrayUtils.EMPTY_SHORT_ARRAY, [EOL]             ArrayUtils.subarray(array, 4, 2)); [EOL]  [EOL]         assertEquals("start == end", ArrayUtils.EMPTY_SHORT_ARRAY, [EOL]             ArrayUtils.subarray(array, 3, 3)); [EOL]  [EOL]         assertTrue("start undershoot, normal end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, -2, 4))); [EOL]  [EOL]         assertEquals("start overshoot, any end", [EOL]             ArrayUtils.EMPTY_SHORT_ARRAY, [EOL]                 ArrayUtils.subarray(array, 33, 4)); [EOL]  [EOL]         assertTrue("normal start, end overshoot", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]                 ArrayUtils.subarray(array, 2, 33))); [EOL]  [EOL]         assertTrue("start undershoot, end overshoot", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, -2, 12))); [EOL]  [EOL]         // empty-return tests [EOL]  [EOL]         assertSame("empty array, object test", [EOL]             ArrayUtils.EMPTY_SHORT_ARRAY, [EOL]                 ArrayUtils.subarray(ArrayUtils.EMPTY_SHORT_ARRAY, 1, 2)); [EOL]  [EOL]         assertSame("start > end, object test", [EOL]             ArrayUtils.EMPTY_SHORT_ARRAY, [EOL]                 ArrayUtils.subarray(array, 4, 1)); [EOL]  [EOL]         assertSame("start == end, object test", [EOL]             ArrayUtils.EMPTY_SHORT_ARRAY, [EOL]                 ArrayUtils.subarray(array, 3, 3)); [EOL]  [EOL]         assertSame("start overshoot, any end, object test", [EOL]             ArrayUtils.EMPTY_SHORT_ARRAY, [EOL]                 ArrayUtils.subarray(array, 8733, 4)); [EOL]  [EOL]         // array type tests [EOL]  [EOL]         assertSame("short type", short.class, [EOL]             ArrayUtils.subarray(array, 2, 4).getClass().getComponentType()); [EOL]  [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSubarrayShort() { [EOL]         final short[] nullArray = null; [EOL]         final short[] array = { 10, 11, 12, 13, 14, 15 }; [EOL]         final short[] leftSubarray    = { 10, 11, 12, 13 }; [EOL]         final short[] midSubarray     = { 11, 12, 13, 14 }; [EOL]         final short[] rightSubarray   = { 12, 13, 14, 15 }; [EOL]  [EOL]  [EOL]         assertTrue("0 start, mid end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, 0, 4))); [EOL]  [EOL]         assertTrue("0 start, length end", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, 0, array.length))); [EOL]  [EOL]         assertTrue("mid start, mid end", [EOL]             ArrayUtils.isEquals(midSubarray, [EOL]                 ArrayUtils.subarray(array, 1, 5))); [EOL]  [EOL]         assertTrue("mid start, length end", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]                 ArrayUtils.subarray(array, 2, array.length))); [EOL]  [EOL]  [EOL]         assertNull("null input", ArrayUtils.subarray(nullArray, 0, 3)); [EOL]  [EOL]         assertEquals("empty array", ArrayUtils.EMPTY_SHORT_ARRAY, [EOL]             ArrayUtils.subarray(ArrayUtils.EMPTY_SHORT_ARRAY, 1, 2)); [EOL]  [EOL]         assertEquals("start > end", ArrayUtils.EMPTY_SHORT_ARRAY, [EOL]             ArrayUtils.subarray(array, 4, 2)); [EOL]  [EOL]         assertEquals("start == end", ArrayUtils.EMPTY_SHORT_ARRAY, [EOL]             ArrayUtils.subarray(array, 3, 3)); [EOL]  [EOL]         assertTrue("start undershoot, normal end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, -2, 4))); [EOL]  [EOL]         assertEquals("start overshoot, any end", [EOL]             ArrayUtils.EMPTY_SHORT_ARRAY, [EOL]                 ArrayUtils.subarray(array, 33, 4)); [EOL]  [EOL]         assertTrue("normal start, end overshoot", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]                 ArrayUtils.subarray(array, 2, 33))); [EOL]  [EOL]         assertTrue("start undershoot, end overshoot", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, -2, 12))); [EOL]  [EOL]         // empty-return tests [EOL]  [EOL]         assertSame("empty array, object test", [EOL]             ArrayUtils.EMPTY_SHORT_ARRAY, [EOL]                 ArrayUtils.subarray(ArrayUtils.EMPTY_SHORT_ARRAY, 1, 2)); [EOL]  [EOL]         assertSame("start > end, object test", [EOL]             ArrayUtils.EMPTY_SHORT_ARRAY, [EOL]                 ArrayUtils.subarray(array, 4, 1)); [EOL]  [EOL]         assertSame("start == end, object test", [EOL]             ArrayUtils.EMPTY_SHORT_ARRAY, [EOL]                 ArrayUtils.subarray(array, 3, 3)); [EOL]  [EOL]         assertSame("start overshoot, any end, object test", [EOL]             ArrayUtils.EMPTY_SHORT_ARRAY, [EOL]                 ArrayUtils.subarray(array, 8733, 4)); [EOL]  [EOL]         // array type tests [EOL]  [EOL]         assertSame("short type", short.class, [EOL]             ArrayUtils.subarray(array, 2, 4).getClass().getComponentType()); [EOL]  [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSubarrayShort() { [EOL]         final short[] nullArray = null; [EOL]         final short[] array = { 10, 11, 12, 13, 14, 15 }; [EOL]         final short[] leftSubarray    = { 10, 11, 12, 13 }; [EOL]         final short[] midSubarray     = { 11, 12, 13, 14 }; [EOL]         final short[] rightSubarray   = { 12, 13, 14, 15 }; [EOL]  [EOL]  [EOL]         assertTrue("0 start, mid end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, 0, 4))); [EOL]  [EOL]         assertTrue("0 start, length end", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, 0, array.length))); [EOL]  [EOL]         assertTrue("mid start, mid end", [EOL]             ArrayUtils.isEquals(midSubarray, [EOL]                 ArrayUtils.subarray(array, 1, 5))); [EOL]  [EOL]         assertTrue("mid start, length end", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]                 ArrayUtils.subarray(array, 2, array.length))); [EOL]  [EOL]  [EOL]         assertNull("null input", ArrayUtils.subarray(nullArray, 0, 3)); [EOL]  [EOL]         assertEquals("empty array", ArrayUtils.EMPTY_SHORT_ARRAY, [EOL]             ArrayUtils.subarray(ArrayUtils.EMPTY_SHORT_ARRAY, 1, 2)); [EOL]  [EOL]         assertEquals("start > end", ArrayUtils.EMPTY_SHORT_ARRAY, [EOL]             ArrayUtils.subarray(array, 4, 2)); [EOL]  [EOL]         assertEquals("start == end", ArrayUtils.EMPTY_SHORT_ARRAY, [EOL]             ArrayUtils.subarray(array, 3, 3)); [EOL]  [EOL]         assertTrue("start undershoot, normal end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, -2, 4))); [EOL]  [EOL]         assertEquals("start overshoot, any end", [EOL]             ArrayUtils.EMPTY_SHORT_ARRAY, [EOL]                 ArrayUtils.subarray(array, 33, 4)); [EOL]  [EOL]         assertTrue("normal start, end overshoot", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]                 ArrayUtils.subarray(array, 2, 33))); [EOL]  [EOL]         assertTrue("start undershoot, end overshoot", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, -2, 12))); [EOL]  [EOL]         // empty-return tests [EOL]  [EOL]         assertSame("empty array, object test", [EOL]             ArrayUtils.EMPTY_SHORT_ARRAY, [EOL]                 ArrayUtils.subarray(ArrayUtils.EMPTY_SHORT_ARRAY, 1, 2)); [EOL]  [EOL]         assertSame("start > end, object test", [EOL]             ArrayUtils.EMPTY_SHORT_ARRAY, [EOL]                 ArrayUtils.subarray(array, 4, 1)); [EOL]  [EOL]         assertSame("start == end, object test", [EOL]             ArrayUtils.EMPTY_SHORT_ARRAY, [EOL]                 ArrayUtils.subarray(array, 3, 3)); [EOL]  [EOL]         assertSame("start overshoot, any end, object test", [EOL]             ArrayUtils.EMPTY_SHORT_ARRAY, [EOL]                 ArrayUtils.subarray(array, 8733, 4)); [EOL]  [EOL]         // array type tests [EOL]  [EOL]         assertSame("short type", short.class, [EOL]             ArrayUtils.subarray(array, 2, 4).getClass().getComponentType()); [EOL]  [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSubarrChar() { [EOL]         final char[] nullArray = null; [EOL]         final char[] array = { 'a', 'b', 'c', 'd', 'e', 'f' }; [EOL]         final char[] leftSubarray     = { 'a', 'b', 'c', 'd', }; [EOL]         final char[] midSubarray      = { 'b', 'c', 'd', 'e', }; [EOL]         final char[] rightSubarray    = { 'c', 'd', 'e', 'f', }; [EOL]  [EOL]  [EOL]         assertTrue("0 start, mid end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, 0, 4))); [EOL]  [EOL]         assertTrue("0 start, length end", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, 0, array.length))); [EOL]  [EOL]         assertTrue("mid start, mid end", [EOL]             ArrayUtils.isEquals(midSubarray, [EOL]                 ArrayUtils.subarray(array, 1, 5))); [EOL]  [EOL]         assertTrue("mid start, length end", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]                 ArrayUtils.subarray(array, 2, array.length))); [EOL]  [EOL]  [EOL]         assertNull("null input", ArrayUtils.subarray(nullArray, 0, 3)); [EOL]  [EOL]         assertEquals("empty array", ArrayUtils.EMPTY_CHAR_ARRAY, [EOL]             ArrayUtils.subarray(ArrayUtils.EMPTY_CHAR_ARRAY, 1, 2)); [EOL]  [EOL]         assertEquals("start > end", ArrayUtils.EMPTY_CHAR_ARRAY, [EOL]             ArrayUtils.subarray(array, 4, 2)); [EOL]  [EOL]         assertEquals("start == end", ArrayUtils.EMPTY_CHAR_ARRAY, [EOL]             ArrayUtils.subarray(array, 3, 3)); [EOL]  [EOL]         assertTrue("start undershoot, normal end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, -2, 4))); [EOL]  [EOL]         assertEquals("start overshoot, any end", [EOL]             ArrayUtils.EMPTY_CHAR_ARRAY, [EOL]                 ArrayUtils.subarray(array, 33, 4)); [EOL]  [EOL]         assertTrue("normal start, end overshoot", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]                 ArrayUtils.subarray(array, 2, 33))); [EOL]  [EOL]         assertTrue("start undershoot, end overshoot", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, -2, 12))); [EOL]  [EOL]         // empty-return tests [EOL]  [EOL]         assertSame("empty array, object test", [EOL]             ArrayUtils.EMPTY_CHAR_ARRAY, [EOL]                 ArrayUtils.subarray(ArrayUtils.EMPTY_CHAR_ARRAY, 1, 2)); [EOL]  [EOL]         assertSame("start > end, object test", [EOL]             ArrayUtils.EMPTY_CHAR_ARRAY, [EOL]                 ArrayUtils.subarray(array, 4, 1)); [EOL]  [EOL]         assertSame("start == end, object test", [EOL]             ArrayUtils.EMPTY_CHAR_ARRAY, [EOL]                 ArrayUtils.subarray(array, 3, 3)); [EOL]  [EOL]         assertSame("start overshoot, any end, object test", [EOL]             ArrayUtils.EMPTY_CHAR_ARRAY, [EOL]                 ArrayUtils.subarray(array, 8733, 4)); [EOL]  [EOL]         // array type tests [EOL]  [EOL]         assertSame("char type", char.class, [EOL]             ArrayUtils.subarray(array, 2, 4).getClass().getComponentType()); [EOL]  [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSubarrChar() { [EOL]         final char[] nullArray = null; [EOL]         final char[] array = { 'a', 'b', 'c', 'd', 'e', 'f' }; [EOL]         final char[] leftSubarray     = { 'a', 'b', 'c', 'd', }; [EOL]         final char[] midSubarray      = { 'b', 'c', 'd', 'e', }; [EOL]         final char[] rightSubarray    = { 'c', 'd', 'e', 'f', }; [EOL]  [EOL]  [EOL]         assertTrue("0 start, mid end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, 0, 4))); [EOL]  [EOL]         assertTrue("0 start, length end", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, 0, array.length))); [EOL]  [EOL]         assertTrue("mid start, mid end", [EOL]             ArrayUtils.isEquals(midSubarray, [EOL]                 ArrayUtils.subarray(array, 1, 5))); [EOL]  [EOL]         assertTrue("mid start, length end", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]                 ArrayUtils.subarray(array, 2, array.length))); [EOL]  [EOL]  [EOL]         assertNull("null input", ArrayUtils.subarray(nullArray, 0, 3)); [EOL]  [EOL]         assertEquals("empty array", ArrayUtils.EMPTY_CHAR_ARRAY, [EOL]             ArrayUtils.subarray(ArrayUtils.EMPTY_CHAR_ARRAY, 1, 2)); [EOL]  [EOL]         assertEquals("start > end", ArrayUtils.EMPTY_CHAR_ARRAY, [EOL]             ArrayUtils.subarray(array, 4, 2)); [EOL]  [EOL]         assertEquals("start == end", ArrayUtils.EMPTY_CHAR_ARRAY, [EOL]             ArrayUtils.subarray(array, 3, 3)); [EOL]  [EOL]         assertTrue("start undershoot, normal end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, -2, 4))); [EOL]  [EOL]         assertEquals("start overshoot, any end", [EOL]             ArrayUtils.EMPTY_CHAR_ARRAY, [EOL]                 ArrayUtils.subarray(array, 33, 4)); [EOL]  [EOL]         assertTrue("normal start, end overshoot", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]                 ArrayUtils.subarray(array, 2, 33))); [EOL]  [EOL]         assertTrue("start undershoot, end overshoot", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, -2, 12))); [EOL]  [EOL]         // empty-return tests [EOL]  [EOL]         assertSame("empty array, object test", [EOL]             ArrayUtils.EMPTY_CHAR_ARRAY, [EOL]                 ArrayUtils.subarray(ArrayUtils.EMPTY_CHAR_ARRAY, 1, 2)); [EOL]  [EOL]         assertSame("start > end, object test", [EOL]             ArrayUtils.EMPTY_CHAR_ARRAY, [EOL]                 ArrayUtils.subarray(array, 4, 1)); [EOL]  [EOL]         assertSame("start == end, object test", [EOL]             ArrayUtils.EMPTY_CHAR_ARRAY, [EOL]                 ArrayUtils.subarray(array, 3, 3)); [EOL]  [EOL]         assertSame("start overshoot, any end, object test", [EOL]             ArrayUtils.EMPTY_CHAR_ARRAY, [EOL]                 ArrayUtils.subarray(array, 8733, 4)); [EOL]  [EOL]         // array type tests [EOL]  [EOL]         assertSame("char type", char.class, [EOL]             ArrayUtils.subarray(array, 2, 4).getClass().getComponentType()); [EOL]  [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSubarrChar() { [EOL]         final char[] nullArray = null; [EOL]         final char[] array = { 'a', 'b', 'c', 'd', 'e', 'f' }; [EOL]         final char[] leftSubarray     = { 'a', 'b', 'c', 'd', }; [EOL]         final char[] midSubarray      = { 'b', 'c', 'd', 'e', }; [EOL]         final char[] rightSubarray    = { 'c', 'd', 'e', 'f', }; [EOL]  [EOL]  [EOL]         assertTrue("0 start, mid end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, 0, 4))); [EOL]  [EOL]         assertTrue("0 start, length end", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, 0, array.length))); [EOL]  [EOL]         assertTrue("mid start, mid end", [EOL]             ArrayUtils.isEquals(midSubarray, [EOL]                 ArrayUtils.subarray(array, 1, 5))); [EOL]  [EOL]         assertTrue("mid start, length end", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]                 ArrayUtils.subarray(array, 2, array.length))); [EOL]  [EOL]  [EOL]         assertNull("null input", ArrayUtils.subarray(nullArray, 0, 3)); [EOL]  [EOL]         assertEquals("empty array", ArrayUtils.EMPTY_CHAR_ARRAY, [EOL]             ArrayUtils.subarray(ArrayUtils.EMPTY_CHAR_ARRAY, 1, 2)); [EOL]  [EOL]         assertEquals("start > end", ArrayUtils.EMPTY_CHAR_ARRAY, [EOL]             ArrayUtils.subarray(array, 4, 2)); [EOL]  [EOL]         assertEquals("start == end", ArrayUtils.EMPTY_CHAR_ARRAY, [EOL]             ArrayUtils.subarray(array, 3, 3)); [EOL]  [EOL]         assertTrue("start undershoot, normal end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, -2, 4))); [EOL]  [EOL]         assertEquals("start overshoot, any end", [EOL]             ArrayUtils.EMPTY_CHAR_ARRAY, [EOL]                 ArrayUtils.subarray(array, 33, 4)); [EOL]  [EOL]         assertTrue("normal start, end overshoot", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]                 ArrayUtils.subarray(array, 2, 33))); [EOL]  [EOL]         assertTrue("start undershoot, end overshoot", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, -2, 12))); [EOL]  [EOL]         // empty-return tests [EOL]  [EOL]         assertSame("empty array, object test", [EOL]             ArrayUtils.EMPTY_CHAR_ARRAY, [EOL]                 ArrayUtils.subarray(ArrayUtils.EMPTY_CHAR_ARRAY, 1, 2)); [EOL]  [EOL]         assertSame("start > end, object test", [EOL]             ArrayUtils.EMPTY_CHAR_ARRAY, [EOL]                 ArrayUtils.subarray(array, 4, 1)); [EOL]  [EOL]         assertSame("start == end, object test", [EOL]             ArrayUtils.EMPTY_CHAR_ARRAY, [EOL]                 ArrayUtils.subarray(array, 3, 3)); [EOL]  [EOL]         assertSame("start overshoot, any end, object test", [EOL]             ArrayUtils.EMPTY_CHAR_ARRAY, [EOL]                 ArrayUtils.subarray(array, 8733, 4)); [EOL]  [EOL]         // array type tests [EOL]  [EOL]         assertSame("char type", char.class, [EOL]             ArrayUtils.subarray(array, 2, 4).getClass().getComponentType()); [EOL]  [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSubarrChar() { [EOL]         final char[] nullArray = null; [EOL]         final char[] array = { 'a', 'b', 'c', 'd', 'e', 'f' }; [EOL]         final char[] leftSubarray     = { 'a', 'b', 'c', 'd', }; [EOL]         final char[] midSubarray      = { 'b', 'c', 'd', 'e', }; [EOL]         final char[] rightSubarray    = { 'c', 'd', 'e', 'f', }; [EOL]  [EOL]  [EOL]         assertTrue("0 start, mid end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, 0, 4))); [EOL]  [EOL]         assertTrue("0 start, length end", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, 0, array.length))); [EOL]  [EOL]         assertTrue("mid start, mid end", [EOL]             ArrayUtils.isEquals(midSubarray, [EOL]                 ArrayUtils.subarray(array, 1, 5))); [EOL]  [EOL]         assertTrue("mid start, length end", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]                 ArrayUtils.subarray(array, 2, array.length))); [EOL]  [EOL]  [EOL]         assertNull("null input", ArrayUtils.subarray(nullArray, 0, 3)); [EOL]  [EOL]         assertEquals("empty array", ArrayUtils.EMPTY_CHAR_ARRAY, [EOL]             ArrayUtils.subarray(ArrayUtils.EMPTY_CHAR_ARRAY, 1, 2)); [EOL]  [EOL]         assertEquals("start > end", ArrayUtils.EMPTY_CHAR_ARRAY, [EOL]             ArrayUtils.subarray(array, 4, 2)); [EOL]  [EOL]         assertEquals("start == end", ArrayUtils.EMPTY_CHAR_ARRAY, [EOL]             ArrayUtils.subarray(array, 3, 3)); [EOL]  [EOL]         assertTrue("start undershoot, normal end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, -2, 4))); [EOL]  [EOL]         assertEquals("start overshoot, any end", [EOL]             ArrayUtils.EMPTY_CHAR_ARRAY, [EOL]                 ArrayUtils.subarray(array, 33, 4)); [EOL]  [EOL]         assertTrue("normal start, end overshoot", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]                 ArrayUtils.subarray(array, 2, 33))); [EOL]  [EOL]         assertTrue("start undershoot, end overshoot", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, -2, 12))); [EOL]  [EOL]         // empty-return tests [EOL]  [EOL]         assertSame("empty array, object test", [EOL]             ArrayUtils.EMPTY_CHAR_ARRAY, [EOL]                 ArrayUtils.subarray(ArrayUtils.EMPTY_CHAR_ARRAY, 1, 2)); [EOL]  [EOL]         assertSame("start > end, object test", [EOL]             ArrayUtils.EMPTY_CHAR_ARRAY, [EOL]                 ArrayUtils.subarray(array, 4, 1)); [EOL]  [EOL]         assertSame("start == end, object test", [EOL]             ArrayUtils.EMPTY_CHAR_ARRAY, [EOL]                 ArrayUtils.subarray(array, 3, 3)); [EOL]  [EOL]         assertSame("start overshoot, any end, object test", [EOL]             ArrayUtils.EMPTY_CHAR_ARRAY, [EOL]                 ArrayUtils.subarray(array, 8733, 4)); [EOL]  [EOL]         // array type tests [EOL]  [EOL]         assertSame("char type", char.class, [EOL]             ArrayUtils.subarray(array, 2, 4).getClass().getComponentType()); [EOL]  [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSubarrChar() { [EOL]         final char[] nullArray = null; [EOL]         final char[] array = { 'a', 'b', 'c', 'd', 'e', 'f' }; [EOL]         final char[] leftSubarray     = { 'a', 'b', 'c', 'd', }; [EOL]         final char[] midSubarray      = { 'b', 'c', 'd', 'e', }; [EOL]         final char[] rightSubarray    = { 'c', 'd', 'e', 'f', }; [EOL]  [EOL]  [EOL]         assertTrue("0 start, mid end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, 0, 4))); [EOL]  [EOL]         assertTrue("0 start, length end", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, 0, array.length))); [EOL]  [EOL]         assertTrue("mid start, mid end", [EOL]             ArrayUtils.isEquals(midSubarray, [EOL]                 ArrayUtils.subarray(array, 1, 5))); [EOL]  [EOL]         assertTrue("mid start, length end", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]                 ArrayUtils.subarray(array, 2, array.length))); [EOL]  [EOL]  [EOL]         assertNull("null input", ArrayUtils.subarray(nullArray, 0, 3)); [EOL]  [EOL]         assertEquals("empty array", ArrayUtils.EMPTY_CHAR_ARRAY, [EOL]             ArrayUtils.subarray(ArrayUtils.EMPTY_CHAR_ARRAY, 1, 2)); [EOL]  [EOL]         assertEquals("start > end", ArrayUtils.EMPTY_CHAR_ARRAY, [EOL]             ArrayUtils.subarray(array, 4, 2)); [EOL]  [EOL]         assertEquals("start == end", ArrayUtils.EMPTY_CHAR_ARRAY, [EOL]             ArrayUtils.subarray(array, 3, 3)); [EOL]  [EOL]         assertTrue("start undershoot, normal end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, -2, 4))); [EOL]  [EOL]         assertEquals("start overshoot, any end", [EOL]             ArrayUtils.EMPTY_CHAR_ARRAY, [EOL]                 ArrayUtils.subarray(array, 33, 4)); [EOL]  [EOL]         assertTrue("normal start, end overshoot", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]                 ArrayUtils.subarray(array, 2, 33))); [EOL]  [EOL]         assertTrue("start undershoot, end overshoot", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, -2, 12))); [EOL]  [EOL]         // empty-return tests [EOL]  [EOL]         assertSame("empty array, object test", [EOL]             ArrayUtils.EMPTY_CHAR_ARRAY, [EOL]                 ArrayUtils.subarray(ArrayUtils.EMPTY_CHAR_ARRAY, 1, 2)); [EOL]  [EOL]         assertSame("start > end, object test", [EOL]             ArrayUtils.EMPTY_CHAR_ARRAY, [EOL]                 ArrayUtils.subarray(array, 4, 1)); [EOL]  [EOL]         assertSame("start == end, object test", [EOL]             ArrayUtils.EMPTY_CHAR_ARRAY, [EOL]                 ArrayUtils.subarray(array, 3, 3)); [EOL]  [EOL]         assertSame("start overshoot, any end, object test", [EOL]             ArrayUtils.EMPTY_CHAR_ARRAY, [EOL]                 ArrayUtils.subarray(array, 8733, 4)); [EOL]  [EOL]         // array type tests [EOL]  [EOL]         assertSame("char type", char.class, [EOL]             ArrayUtils.subarray(array, 2, 4).getClass().getComponentType()); [EOL]  [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSubarrayByte() { [EOL]         final byte[] nullArray = null; [EOL]         final byte[] array = { 10, 11, 12, 13, 14, 15 }; [EOL]         final byte[] leftSubarray     = { 10, 11, 12, 13 }; [EOL]         final byte[] midSubarray      = { 11, 12, 13, 14 }; [EOL]         final byte[] rightSubarray = { 12, 13, 14, 15 }; [EOL]  [EOL]  [EOL]         assertTrue("0 start, mid end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, 0, 4))); [EOL]  [EOL]         assertTrue("0 start, length end", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, 0, array.length))); [EOL]  [EOL]         assertTrue("mid start, mid end", [EOL]             ArrayUtils.isEquals(midSubarray, [EOL]                 ArrayUtils.subarray(array, 1, 5))); [EOL]  [EOL]         assertTrue("mid start, length end", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]                 ArrayUtils.subarray(array, 2, array.length))); [EOL]  [EOL]  [EOL]         assertNull("null input", ArrayUtils.subarray(nullArray, 0, 3)); [EOL]  [EOL]         assertEquals("empty array", ArrayUtils.EMPTY_BYTE_ARRAY, [EOL]             ArrayUtils.subarray(ArrayUtils.EMPTY_BYTE_ARRAY, 1, 2)); [EOL]  [EOL]         assertEquals("start > end", ArrayUtils.EMPTY_BYTE_ARRAY, [EOL]             ArrayUtils.subarray(array, 4, 2)); [EOL]  [EOL]         assertEquals("start == end", ArrayUtils.EMPTY_BYTE_ARRAY, [EOL]             ArrayUtils.subarray(array, 3, 3)); [EOL]  [EOL]         assertTrue("start undershoot, normal end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, -2, 4))); [EOL]  [EOL]         assertEquals("start overshoot, any end", [EOL]             ArrayUtils.EMPTY_BYTE_ARRAY, [EOL]                 ArrayUtils.subarray(array, 33, 4)); [EOL]  [EOL]         assertTrue("normal start, end overshoot", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]                 ArrayUtils.subarray(array, 2, 33))); [EOL]  [EOL]         assertTrue("start undershoot, end overshoot", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, -2, 12))); [EOL]  [EOL]         // empty-return tests [EOL]  [EOL]         assertSame("empty array, object test", [EOL]             ArrayUtils.EMPTY_BYTE_ARRAY, [EOL]                 ArrayUtils.subarray(ArrayUtils.EMPTY_BYTE_ARRAY, 1, 2)); [EOL]  [EOL]         assertSame("start > end, object test", [EOL]             ArrayUtils.EMPTY_BYTE_ARRAY, [EOL]                 ArrayUtils.subarray(array, 4, 1)); [EOL]  [EOL]         assertSame("start == end, object test", [EOL]             ArrayUtils.EMPTY_BYTE_ARRAY, [EOL]                 ArrayUtils.subarray(array, 3, 3)); [EOL]  [EOL]         assertSame("start overshoot, any end, object test", [EOL]             ArrayUtils.EMPTY_BYTE_ARRAY, [EOL]                 ArrayUtils.subarray(array, 8733, 4)); [EOL]  [EOL]         // array type tests [EOL]  [EOL]         assertSame("byte type", byte.class, [EOL]             ArrayUtils.subarray(array, 2, 4).getClass().getComponentType()); [EOL]  [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSubarrayByte() { [EOL]         final byte[] nullArray = null; [EOL]         final byte[] array = { 10, 11, 12, 13, 14, 15 }; [EOL]         final byte[] leftSubarray     = { 10, 11, 12, 13 }; [EOL]         final byte[] midSubarray      = { 11, 12, 13, 14 }; [EOL]         final byte[] rightSubarray = { 12, 13, 14, 15 }; [EOL]  [EOL]  [EOL]         assertTrue("0 start, mid end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, 0, 4))); [EOL]  [EOL]         assertTrue("0 start, length end", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, 0, array.length))); [EOL]  [EOL]         assertTrue("mid start, mid end", [EOL]             ArrayUtils.isEquals(midSubarray, [EOL]                 ArrayUtils.subarray(array, 1, 5))); [EOL]  [EOL]         assertTrue("mid start, length end", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]                 ArrayUtils.subarray(array, 2, array.length))); [EOL]  [EOL]  [EOL]         assertNull("null input", ArrayUtils.subarray(nullArray, 0, 3)); [EOL]  [EOL]         assertEquals("empty array", ArrayUtils.EMPTY_BYTE_ARRAY, [EOL]             ArrayUtils.subarray(ArrayUtils.EMPTY_BYTE_ARRAY, 1, 2)); [EOL]  [EOL]         assertEquals("start > end", ArrayUtils.EMPTY_BYTE_ARRAY, [EOL]             ArrayUtils.subarray(array, 4, 2)); [EOL]  [EOL]         assertEquals("start == end", ArrayUtils.EMPTY_BYTE_ARRAY, [EOL]             ArrayUtils.subarray(array, 3, 3)); [EOL]  [EOL]         assertTrue("start undershoot, normal end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, -2, 4))); [EOL]  [EOL]         assertEquals("start overshoot, any end", [EOL]             ArrayUtils.EMPTY_BYTE_ARRAY, [EOL]                 ArrayUtils.subarray(array, 33, 4)); [EOL]  [EOL]         assertTrue("normal start, end overshoot", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]                 ArrayUtils.subarray(array, 2, 33))); [EOL]  [EOL]         assertTrue("start undershoot, end overshoot", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, -2, 12))); [EOL]  [EOL]         // empty-return tests [EOL]  [EOL]         assertSame("empty array, object test", [EOL]             ArrayUtils.EMPTY_BYTE_ARRAY, [EOL]                 ArrayUtils.subarray(ArrayUtils.EMPTY_BYTE_ARRAY, 1, 2)); [EOL]  [EOL]         assertSame("start > end, object test", [EOL]             ArrayUtils.EMPTY_BYTE_ARRAY, [EOL]                 ArrayUtils.subarray(array, 4, 1)); [EOL]  [EOL]         assertSame("start == end, object test", [EOL]             ArrayUtils.EMPTY_BYTE_ARRAY, [EOL]                 ArrayUtils.subarray(array, 3, 3)); [EOL]  [EOL]         assertSame("start overshoot, any end, object test", [EOL]             ArrayUtils.EMPTY_BYTE_ARRAY, [EOL]                 ArrayUtils.subarray(array, 8733, 4)); [EOL]  [EOL]         // array type tests [EOL]  [EOL]         assertSame("byte type", byte.class, [EOL]             ArrayUtils.subarray(array, 2, 4).getClass().getComponentType()); [EOL]  [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSubarrayByte() { [EOL]         final byte[] nullArray = null; [EOL]         final byte[] array = { 10, 11, 12, 13, 14, 15 }; [EOL]         final byte[] leftSubarray     = { 10, 11, 12, 13 }; [EOL]         final byte[] midSubarray      = { 11, 12, 13, 14 }; [EOL]         final byte[] rightSubarray = { 12, 13, 14, 15 }; [EOL]  [EOL]  [EOL]         assertTrue("0 start, mid end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, 0, 4))); [EOL]  [EOL]         assertTrue("0 start, length end", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, 0, array.length))); [EOL]  [EOL]         assertTrue("mid start, mid end", [EOL]             ArrayUtils.isEquals(midSubarray, [EOL]                 ArrayUtils.subarray(array, 1, 5))); [EOL]  [EOL]         assertTrue("mid start, length end", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]                 ArrayUtils.subarray(array, 2, array.length))); [EOL]  [EOL]  [EOL]         assertNull("null input", ArrayUtils.subarray(nullArray, 0, 3)); [EOL]  [EOL]         assertEquals("empty array", ArrayUtils.EMPTY_BYTE_ARRAY, [EOL]             ArrayUtils.subarray(ArrayUtils.EMPTY_BYTE_ARRAY, 1, 2)); [EOL]  [EOL]         assertEquals("start > end", ArrayUtils.EMPTY_BYTE_ARRAY, [EOL]             ArrayUtils.subarray(array, 4, 2)); [EOL]  [EOL]         assertEquals("start == end", ArrayUtils.EMPTY_BYTE_ARRAY, [EOL]             ArrayUtils.subarray(array, 3, 3)); [EOL]  [EOL]         assertTrue("start undershoot, normal end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, -2, 4))); [EOL]  [EOL]         assertEquals("start overshoot, any end", [EOL]             ArrayUtils.EMPTY_BYTE_ARRAY, [EOL]                 ArrayUtils.subarray(array, 33, 4)); [EOL]  [EOL]         assertTrue("normal start, end overshoot", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]                 ArrayUtils.subarray(array, 2, 33))); [EOL]  [EOL]         assertTrue("start undershoot, end overshoot", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, -2, 12))); [EOL]  [EOL]         // empty-return tests [EOL]  [EOL]         assertSame("empty array, object test", [EOL]             ArrayUtils.EMPTY_BYTE_ARRAY, [EOL]                 ArrayUtils.subarray(ArrayUtils.EMPTY_BYTE_ARRAY, 1, 2)); [EOL]  [EOL]         assertSame("start > end, object test", [EOL]             ArrayUtils.EMPTY_BYTE_ARRAY, [EOL]                 ArrayUtils.subarray(array, 4, 1)); [EOL]  [EOL]         assertSame("start == end, object test", [EOL]             ArrayUtils.EMPTY_BYTE_ARRAY, [EOL]                 ArrayUtils.subarray(array, 3, 3)); [EOL]  [EOL]         assertSame("start overshoot, any end, object test", [EOL]             ArrayUtils.EMPTY_BYTE_ARRAY, [EOL]                 ArrayUtils.subarray(array, 8733, 4)); [EOL]  [EOL]         // array type tests [EOL]  [EOL]         assertSame("byte type", byte.class, [EOL]             ArrayUtils.subarray(array, 2, 4).getClass().getComponentType()); [EOL]  [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSubarrayByte() { [EOL]         final byte[] nullArray = null; [EOL]         final byte[] array = { 10, 11, 12, 13, 14, 15 }; [EOL]         final byte[] leftSubarray     = { 10, 11, 12, 13 }; [EOL]         final byte[] midSubarray      = { 11, 12, 13, 14 }; [EOL]         final byte[] rightSubarray = { 12, 13, 14, 15 }; [EOL]  [EOL]  [EOL]         assertTrue("0 start, mid end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, 0, 4))); [EOL]  [EOL]         assertTrue("0 start, length end", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, 0, array.length))); [EOL]  [EOL]         assertTrue("mid start, mid end", [EOL]             ArrayUtils.isEquals(midSubarray, [EOL]                 ArrayUtils.subarray(array, 1, 5))); [EOL]  [EOL]         assertTrue("mid start, length end", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]                 ArrayUtils.subarray(array, 2, array.length))); [EOL]  [EOL]  [EOL]         assertNull("null input", ArrayUtils.subarray(nullArray, 0, 3)); [EOL]  [EOL]         assertEquals("empty array", ArrayUtils.EMPTY_BYTE_ARRAY, [EOL]             ArrayUtils.subarray(ArrayUtils.EMPTY_BYTE_ARRAY, 1, 2)); [EOL]  [EOL]         assertEquals("start > end", ArrayUtils.EMPTY_BYTE_ARRAY, [EOL]             ArrayUtils.subarray(array, 4, 2)); [EOL]  [EOL]         assertEquals("start == end", ArrayUtils.EMPTY_BYTE_ARRAY, [EOL]             ArrayUtils.subarray(array, 3, 3)); [EOL]  [EOL]         assertTrue("start undershoot, normal end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, -2, 4))); [EOL]  [EOL]         assertEquals("start overshoot, any end", [EOL]             ArrayUtils.EMPTY_BYTE_ARRAY, [EOL]                 ArrayUtils.subarray(array, 33, 4)); [EOL]  [EOL]         assertTrue("normal start, end overshoot", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]                 ArrayUtils.subarray(array, 2, 33))); [EOL]  [EOL]         assertTrue("start undershoot, end overshoot", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, -2, 12))); [EOL]  [EOL]         // empty-return tests [EOL]  [EOL]         assertSame("empty array, object test", [EOL]             ArrayUtils.EMPTY_BYTE_ARRAY, [EOL]                 ArrayUtils.subarray(ArrayUtils.EMPTY_BYTE_ARRAY, 1, 2)); [EOL]  [EOL]         assertSame("start > end, object test", [EOL]             ArrayUtils.EMPTY_BYTE_ARRAY, [EOL]                 ArrayUtils.subarray(array, 4, 1)); [EOL]  [EOL]         assertSame("start == end, object test", [EOL]             ArrayUtils.EMPTY_BYTE_ARRAY, [EOL]                 ArrayUtils.subarray(array, 3, 3)); [EOL]  [EOL]         assertSame("start overshoot, any end, object test", [EOL]             ArrayUtils.EMPTY_BYTE_ARRAY, [EOL]                 ArrayUtils.subarray(array, 8733, 4)); [EOL]  [EOL]         // array type tests [EOL]  [EOL]         assertSame("byte type", byte.class, [EOL]             ArrayUtils.subarray(array, 2, 4).getClass().getComponentType()); [EOL]  [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSubarrayFloat() { [EOL]         final float[] nullArray = null; [EOL]         final float[] array = { 10, 11, 12, 13, 14, 15 }; [EOL]         final float[] leftSubarray    = { 10, 11, 12, 13 }; [EOL]         final float[] midSubarray     = { 11, 12, 13, 14 }; [EOL]         final float[] rightSubarray   = { 12, 13, 14, 15 }; [EOL]  [EOL]  [EOL]         assertTrue("0 start, mid end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, 0, 4))); [EOL]  [EOL]         assertTrue("0 start, length end", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, 0, array.length))); [EOL]  [EOL]         assertTrue("mid start, mid end", [EOL]             ArrayUtils.isEquals(midSubarray, [EOL]                 ArrayUtils.subarray(array, 1, 5))); [EOL]  [EOL]         assertTrue("mid start, length end", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]                 ArrayUtils.subarray(array, 2, array.length))); [EOL]  [EOL]  [EOL]         assertNull("null input", ArrayUtils.subarray(nullArray, 0, 3)); [EOL]  [EOL]         assertEquals("empty array", ArrayUtils.EMPTY_FLOAT_ARRAY, [EOL]             ArrayUtils.subarray(ArrayUtils.EMPTY_FLOAT_ARRAY, 1, 2)); [EOL]  [EOL]         assertEquals("start > end", ArrayUtils.EMPTY_FLOAT_ARRAY, [EOL]             ArrayUtils.subarray(array, 4, 2)); [EOL]  [EOL]         assertEquals("start == end", ArrayUtils.EMPTY_FLOAT_ARRAY, [EOL]             ArrayUtils.subarray(array, 3, 3)); [EOL]  [EOL]         assertTrue("start undershoot, normal end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, -2, 4))); [EOL]  [EOL]         assertEquals("start overshoot, any end", [EOL]             ArrayUtils.EMPTY_FLOAT_ARRAY, [EOL]                 ArrayUtils.subarray(array, 33, 4)); [EOL]  [EOL]         assertTrue("normal start, end overshoot", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]                 ArrayUtils.subarray(array, 2, 33))); [EOL]  [EOL]         assertTrue("start undershoot, end overshoot", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, -2, 12))); [EOL]  [EOL]         // empty-return tests [EOL]  [EOL]         assertSame("empty array, object test", [EOL]             ArrayUtils.EMPTY_FLOAT_ARRAY, [EOL]                 ArrayUtils.subarray(ArrayUtils.EMPTY_FLOAT_ARRAY, 1, 2)); [EOL]  [EOL]         assertSame("start > end, object test", [EOL]             ArrayUtils.EMPTY_FLOAT_ARRAY, [EOL]                 ArrayUtils.subarray(array, 4, 1)); [EOL]  [EOL]         assertSame("start == end, object test", [EOL]             ArrayUtils.EMPTY_FLOAT_ARRAY, [EOL]                 ArrayUtils.subarray(array, 3, 3)); [EOL]  [EOL]         assertSame("start overshoot, any end, object test", [EOL]             ArrayUtils.EMPTY_FLOAT_ARRAY, [EOL]                 ArrayUtils.subarray(array, 8733, 4)); [EOL]  [EOL]         // array type tests [EOL]  [EOL]         assertSame("float type", float.class, [EOL]             ArrayUtils.subarray(array, 2, 4).getClass().getComponentType()); [EOL]  [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSubarrayBoolean() { [EOL]         final boolean[] nullArray = null; [EOL]         final boolean[] array = { true, true, false, true, false, true }; [EOL]         final boolean[] leftSubarray  = { true, true, false, true  }; [EOL]         final boolean[] midSubarray   = { true, false, true, false }; [EOL]         final boolean[] rightSubarray = { false, true, false, true }; [EOL]  [EOL]  [EOL]         assertTrue("0 start, mid end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, 0, 4))); [EOL]  [EOL]         assertTrue("0 start, length end", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, 0, array.length))); [EOL]  [EOL]         assertTrue("mid start, mid end", [EOL]             ArrayUtils.isEquals(midSubarray, [EOL]                 ArrayUtils.subarray(array, 1, 5))); [EOL]  [EOL]         assertTrue("mid start, length end", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]                 ArrayUtils.subarray(array, 2, array.length))); [EOL]  [EOL]  [EOL]         assertNull("null input", ArrayUtils.subarray(nullArray, 0, 3)); [EOL]  [EOL]         assertEquals("empty array", ArrayUtils.EMPTY_BOOLEAN_ARRAY, [EOL]             ArrayUtils.subarray(ArrayUtils.EMPTY_BOOLEAN_ARRAY, 1, 2)); [EOL]  [EOL]         assertEquals("start > end", ArrayUtils.EMPTY_BOOLEAN_ARRAY, [EOL]             ArrayUtils.subarray(array, 4, 2)); [EOL]  [EOL]         assertEquals("start == end", ArrayUtils.EMPTY_BOOLEAN_ARRAY, [EOL]             ArrayUtils.subarray(array, 3, 3)); [EOL]  [EOL]         assertTrue("start undershoot, normal end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, -2, 4))); [EOL]  [EOL]         assertEquals("start overshoot, any end", [EOL]             ArrayUtils.EMPTY_BOOLEAN_ARRAY, [EOL]                 ArrayUtils.subarray(array, 33, 4)); [EOL]  [EOL]         assertTrue("normal start, end overshoot", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]                 ArrayUtils.subarray(array, 2, 33))); [EOL]  [EOL]         assertTrue("start undershoot, end overshoot", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, -2, 12))); [EOL]  [EOL]         // empty-return tests [EOL]  [EOL]         assertSame("empty array, object test", [EOL]             ArrayUtils.EMPTY_BOOLEAN_ARRAY, [EOL]                 ArrayUtils.subarray(ArrayUtils.EMPTY_BOOLEAN_ARRAY, 1, 2)); [EOL]  [EOL]         assertSame("start > end, object test", [EOL]             ArrayUtils.EMPTY_BOOLEAN_ARRAY, [EOL]                 ArrayUtils.subarray(array, 4, 1)); [EOL]  [EOL]         assertSame("start == end, object test", [EOL]             ArrayUtils.EMPTY_BOOLEAN_ARRAY, [EOL]                 ArrayUtils.subarray(array, 3, 3)); [EOL]  [EOL]         assertSame("start overshoot, any end, object test", [EOL]             ArrayUtils.EMPTY_BOOLEAN_ARRAY, [EOL]                 ArrayUtils.subarray(array, 8733, 4)); [EOL]  [EOL]         // array type tests [EOL]  [EOL]         assertSame("boolean type", boolean.class, [EOL]             ArrayUtils.subarray(array, 2, 4).getClass().getComponentType()); [EOL]  [EOL]     } [EOL]      [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testSubarrayBoolean() { [EOL]         final boolean[] nullArray = null; [EOL]         final boolean[] array = { true, true, false, true, false, true }; [EOL]         final boolean[] leftSubarray  = { true, true, false, true  }; [EOL]         final boolean[] midSubarray   = { true, false, true, false }; [EOL]         final boolean[] rightSubarray = { false, true, false, true }; [EOL]  [EOL]  [EOL]         assertTrue("0 start, mid end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, 0, 4))); [EOL]  [EOL]         assertTrue("0 start, length end", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, 0, array.length))); [EOL]  [EOL]         assertTrue("mid start, mid end", [EOL]             ArrayUtils.isEquals(midSubarray, [EOL]                 ArrayUtils.subarray(array, 1, 5))); [EOL]  [EOL]         assertTrue("mid start, length end", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]                 ArrayUtils.subarray(array, 2, array.length))); [EOL]  [EOL]  [EOL]         assertNull("null input", ArrayUtils.subarray(nullArray, 0, 3)); [EOL]  [EOL]         assertEquals("empty array", ArrayUtils.EMPTY_BOOLEAN_ARRAY, [EOL]             ArrayUtils.subarray(ArrayUtils.EMPTY_BOOLEAN_ARRAY, 1, 2)); [EOL]  [EOL]         assertEquals("start > end", ArrayUtils.EMPTY_BOOLEAN_ARRAY, [EOL]             ArrayUtils.subarray(array, 4, 2)); [EOL]  [EOL]         assertEquals("start == end", ArrayUtils.EMPTY_BOOLEAN_ARRAY, [EOL]             ArrayUtils.subarray(array, 3, 3)); [EOL]  [EOL]         assertTrue("start undershoot, normal end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, -2, 4))); [EOL]  [EOL]         assertEquals("start overshoot, any end", [EOL]             ArrayUtils.EMPTY_BOOLEAN_ARRAY, [EOL]                 ArrayUtils.subarray(array, 33, 4)); [EOL]  [EOL]         assertTrue("normal start, end overshoot", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]                 ArrayUtils.subarray(array, 2, 33))); [EOL]  [EOL]         assertTrue("start undershoot, end overshoot", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, -2, 12))); [EOL]  [EOL]         // empty-return tests [EOL]  [EOL]         assertSame("empty array, object test", [EOL]             ArrayUtils.EMPTY_BOOLEAN_ARRAY, [EOL]                 ArrayUtils.subarray(ArrayUtils.EMPTY_BOOLEAN_ARRAY, 1, 2)); [EOL]  [EOL]         assertSame("start > end, object test", [EOL]             ArrayUtils.EMPTY_BOOLEAN_ARRAY, [EOL]                 ArrayUtils.subarray(array, 4, 1)); [EOL]  [EOL]         assertSame("start == end, object test", [EOL]             ArrayUtils.EMPTY_BOOLEAN_ARRAY, [EOL]                 ArrayUtils.subarray(array, 3, 3)); [EOL]  [EOL]         assertSame("start overshoot, any end, object test", [EOL]             ArrayUtils.EMPTY_BOOLEAN_ARRAY, [EOL]                 ArrayUtils.subarray(array, 8733, 4)); [EOL]  [EOL]         // array type tests [EOL]  [EOL]         assertSame("boolean type", boolean.class, [EOL]             ArrayUtils.subarray(array, 2, 4).getClass().getComponentType()); [EOL]  [EOL]     } [EOL]      [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testSubarrayBoolean() { [EOL]         final boolean[] nullArray = null; [EOL]         final boolean[] array = { true, true, false, true, false, true }; [EOL]         final boolean[] leftSubarray  = { true, true, false, true  }; [EOL]         final boolean[] midSubarray   = { true, false, true, false }; [EOL]         final boolean[] rightSubarray = { false, true, false, true }; [EOL]  [EOL]  [EOL]         assertTrue("0 start, mid end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, 0, 4))); [EOL]  [EOL]         assertTrue("0 start, length end", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, 0, array.length))); [EOL]  [EOL]         assertTrue("mid start, mid end", [EOL]             ArrayUtils.isEquals(midSubarray, [EOL]                 ArrayUtils.subarray(array, 1, 5))); [EOL]  [EOL]         assertTrue("mid start, length end", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]                 ArrayUtils.subarray(array, 2, array.length))); [EOL]  [EOL]  [EOL]         assertNull("null input", ArrayUtils.subarray(nullArray, 0, 3)); [EOL]  [EOL]         assertEquals("empty array", ArrayUtils.EMPTY_BOOLEAN_ARRAY, [EOL]             ArrayUtils.subarray(ArrayUtils.EMPTY_BOOLEAN_ARRAY, 1, 2)); [EOL]  [EOL]         assertEquals("start > end", ArrayUtils.EMPTY_BOOLEAN_ARRAY, [EOL]             ArrayUtils.subarray(array, 4, 2)); [EOL]  [EOL]         assertEquals("start == end", ArrayUtils.EMPTY_BOOLEAN_ARRAY, [EOL]             ArrayUtils.subarray(array, 3, 3)); [EOL]  [EOL]         assertTrue("start undershoot, normal end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, -2, 4))); [EOL]  [EOL]         assertEquals("start overshoot, any end", [EOL]             ArrayUtils.EMPTY_BOOLEAN_ARRAY, [EOL]                 ArrayUtils.subarray(array, 33, 4)); [EOL]  [EOL]         assertTrue("normal start, end overshoot", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]                 ArrayUtils.subarray(array, 2, 33))); [EOL]  [EOL]         assertTrue("start undershoot, end overshoot", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, -2, 12))); [EOL]  [EOL]         // empty-return tests [EOL]  [EOL]         assertSame("empty array, object test", [EOL]             ArrayUtils.EMPTY_BOOLEAN_ARRAY, [EOL]                 ArrayUtils.subarray(ArrayUtils.EMPTY_BOOLEAN_ARRAY, 1, 2)); [EOL]  [EOL]         assertSame("start > end, object test", [EOL]             ArrayUtils.EMPTY_BOOLEAN_ARRAY, [EOL]                 ArrayUtils.subarray(array, 4, 1)); [EOL]  [EOL]         assertSame("start == end, object test", [EOL]             ArrayUtils.EMPTY_BOOLEAN_ARRAY, [EOL]                 ArrayUtils.subarray(array, 3, 3)); [EOL]  [EOL]         assertSame("start overshoot, any end, object test", [EOL]             ArrayUtils.EMPTY_BOOLEAN_ARRAY, [EOL]                 ArrayUtils.subarray(array, 8733, 4)); [EOL]  [EOL]         // array type tests [EOL]  [EOL]         assertSame("boolean type", boolean.class, [EOL]             ArrayUtils.subarray(array, 2, 4).getClass().getComponentType()); [EOL]  [EOL]     } [EOL]      [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testSubarrayBoolean() { [EOL]         final boolean[] nullArray = null; [EOL]         final boolean[] array = { true, true, false, true, false, true }; [EOL]         final boolean[] leftSubarray  = { true, true, false, true  }; [EOL]         final boolean[] midSubarray   = { true, false, true, false }; [EOL]         final boolean[] rightSubarray = { false, true, false, true }; [EOL]  [EOL]  [EOL]         assertTrue("0 start, mid end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, 0, 4))); [EOL]  [EOL]         assertTrue("0 start, length end", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, 0, array.length))); [EOL]  [EOL]         assertTrue("mid start, mid end", [EOL]             ArrayUtils.isEquals(midSubarray, [EOL]                 ArrayUtils.subarray(array, 1, 5))); [EOL]  [EOL]         assertTrue("mid start, length end", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]                 ArrayUtils.subarray(array, 2, array.length))); [EOL]  [EOL]  [EOL]         assertNull("null input", ArrayUtils.subarray(nullArray, 0, 3)); [EOL]  [EOL]         assertEquals("empty array", ArrayUtils.EMPTY_BOOLEAN_ARRAY, [EOL]             ArrayUtils.subarray(ArrayUtils.EMPTY_BOOLEAN_ARRAY, 1, 2)); [EOL]  [EOL]         assertEquals("start > end", ArrayUtils.EMPTY_BOOLEAN_ARRAY, [EOL]             ArrayUtils.subarray(array, 4, 2)); [EOL]  [EOL]         assertEquals("start == end", ArrayUtils.EMPTY_BOOLEAN_ARRAY, [EOL]             ArrayUtils.subarray(array, 3, 3)); [EOL]  [EOL]         assertTrue("start undershoot, normal end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, -2, 4))); [EOL]  [EOL]         assertEquals("start overshoot, any end", [EOL]             ArrayUtils.EMPTY_BOOLEAN_ARRAY, [EOL]                 ArrayUtils.subarray(array, 33, 4)); [EOL]  [EOL]         assertTrue("normal start, end overshoot", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]                 ArrayUtils.subarray(array, 2, 33))); [EOL]  [EOL]         assertTrue("start undershoot, end overshoot", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, -2, 12))); [EOL]  [EOL]         // empty-return tests [EOL]  [EOL]         assertSame("empty array, object test", [EOL]             ArrayUtils.EMPTY_BOOLEAN_ARRAY, [EOL]                 ArrayUtils.subarray(ArrayUtils.EMPTY_BOOLEAN_ARRAY, 1, 2)); [EOL]  [EOL]         assertSame("start > end, object test", [EOL]             ArrayUtils.EMPTY_BOOLEAN_ARRAY, [EOL]                 ArrayUtils.subarray(array, 4, 1)); [EOL]  [EOL]         assertSame("start == end, object test", [EOL]             ArrayUtils.EMPTY_BOOLEAN_ARRAY, [EOL]                 ArrayUtils.subarray(array, 3, 3)); [EOL]  [EOL]         assertSame("start overshoot, any end, object test", [EOL]             ArrayUtils.EMPTY_BOOLEAN_ARRAY, [EOL]                 ArrayUtils.subarray(array, 8733, 4)); [EOL]  [EOL]         // array type tests [EOL]  [EOL]         assertSame("boolean type", boolean.class, [EOL]             ArrayUtils.subarray(array, 2, 4).getClass().getComponentType()); [EOL]  [EOL]     } [EOL]      [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testSubarrayBoolean() { [EOL]         final boolean[] nullArray = null; [EOL]         final boolean[] array = { true, true, false, true, false, true }; [EOL]         final boolean[] leftSubarray  = { true, true, false, true  }; [EOL]         final boolean[] midSubarray   = { true, false, true, false }; [EOL]         final boolean[] rightSubarray = { false, true, false, true }; [EOL]  [EOL]  [EOL]         assertTrue("0 start, mid end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, 0, 4))); [EOL]  [EOL]         assertTrue("0 start, length end", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, 0, array.length))); [EOL]  [EOL]         assertTrue("mid start, mid end", [EOL]             ArrayUtils.isEquals(midSubarray, [EOL]                 ArrayUtils.subarray(array, 1, 5))); [EOL]  [EOL]         assertTrue("mid start, length end", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]                 ArrayUtils.subarray(array, 2, array.length))); [EOL]  [EOL]  [EOL]         assertNull("null input", ArrayUtils.subarray(nullArray, 0, 3)); [EOL]  [EOL]         assertEquals("empty array", ArrayUtils.EMPTY_BOOLEAN_ARRAY, [EOL]             ArrayUtils.subarray(ArrayUtils.EMPTY_BOOLEAN_ARRAY, 1, 2)); [EOL]  [EOL]         assertEquals("start > end", ArrayUtils.EMPTY_BOOLEAN_ARRAY, [EOL]             ArrayUtils.subarray(array, 4, 2)); [EOL]  [EOL]         assertEquals("start == end", ArrayUtils.EMPTY_BOOLEAN_ARRAY, [EOL]             ArrayUtils.subarray(array, 3, 3)); [EOL]  [EOL]         assertTrue("start undershoot, normal end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, -2, 4))); [EOL]  [EOL]         assertEquals("start overshoot, any end", [EOL]             ArrayUtils.EMPTY_BOOLEAN_ARRAY, [EOL]                 ArrayUtils.subarray(array, 33, 4)); [EOL]  [EOL]         assertTrue("normal start, end overshoot", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]                 ArrayUtils.subarray(array, 2, 33))); [EOL]  [EOL]         assertTrue("start undershoot, end overshoot", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, -2, 12))); [EOL]  [EOL]         // empty-return tests [EOL]  [EOL]         assertSame("empty array, object test", [EOL]             ArrayUtils.EMPTY_BOOLEAN_ARRAY, [EOL]                 ArrayUtils.subarray(ArrayUtils.EMPTY_BOOLEAN_ARRAY, 1, 2)); [EOL]  [EOL]         assertSame("start > end, object test", [EOL]             ArrayUtils.EMPTY_BOOLEAN_ARRAY, [EOL]                 ArrayUtils.subarray(array, 4, 1)); [EOL]  [EOL]         assertSame("start == end, object test", [EOL]             ArrayUtils.EMPTY_BOOLEAN_ARRAY, [EOL]                 ArrayUtils.subarray(array, 3, 3)); [EOL]  [EOL]         assertSame("start overshoot, any end, object test", [EOL]             ArrayUtils.EMPTY_BOOLEAN_ARRAY, [EOL]                 ArrayUtils.subarray(array, 8733, 4)); [EOL]  [EOL]         // array type tests [EOL]  [EOL]         assertSame("boolean type", boolean.class, [EOL]             ArrayUtils.subarray(array, 2, 4).getClass().getComponentType()); [EOL]  [EOL]     } [EOL]      [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testSameLengthInt() { [EOL]         final int[] nullArray = null; [EOL]         final int[] emptyArray = new int[0]; [EOL]         final int[] oneArray = new int[] {4}; [EOL]         final int[] twoArray = new int[] {5, 7}; [EOL]          [EOL]         assertTrue(ArrayUtils.isSameLength(nullArray, nullArray)); [EOL]         assertTrue(ArrayUtils.isSameLength(nullArray, emptyArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(nullArray, oneArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(nullArray, twoArray)); [EOL]          [EOL]         assertTrue(ArrayUtils.isSameLength(emptyArray, nullArray)); [EOL]         assertTrue(ArrayUtils.isSameLength(emptyArray, emptyArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(emptyArray, oneArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(emptyArray, twoArray)); [EOL]          [EOL]         assertFalse(ArrayUtils.isSameLength(oneArray, nullArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(oneArray, emptyArray)); [EOL]         assertTrue(ArrayUtils.isSameLength(oneArray, oneArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(oneArray, twoArray)); [EOL]          [EOL]         assertFalse(ArrayUtils.isSameLength(twoArray, nullArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(twoArray, emptyArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(twoArray, oneArray)); [EOL]         assertTrue(ArrayUtils.isSameLength(twoArray, twoArray)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testSameLengthShort() { [EOL]         final short[] nullArray = null; [EOL]         final short[] emptyArray = new short[0]; [EOL]         final short[] oneArray = new short[] {4}; [EOL]         final short[] twoArray = new short[] {6, 8}; [EOL]          [EOL]         assertTrue(ArrayUtils.isSameLength(nullArray, nullArray)); [EOL]         assertTrue(ArrayUtils.isSameLength(nullArray, emptyArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(nullArray, oneArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(nullArray, twoArray)); [EOL]          [EOL]         assertTrue(ArrayUtils.isSameLength(emptyArray, nullArray)); [EOL]         assertTrue(ArrayUtils.isSameLength(emptyArray, emptyArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(emptyArray, oneArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(emptyArray, twoArray)); [EOL]          [EOL]         assertFalse(ArrayUtils.isSameLength(oneArray, nullArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(oneArray, emptyArray)); [EOL]         assertTrue(ArrayUtils.isSameLength(oneArray, oneArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(oneArray, twoArray)); [EOL]          [EOL]         assertFalse(ArrayUtils.isSameLength(twoArray, nullArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(twoArray, emptyArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(twoArray, oneArray)); [EOL]         assertTrue(ArrayUtils.isSameLength(twoArray, twoArray)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testSameLengthByte() { [EOL]         final byte[] nullArray = null; [EOL]         final byte[] emptyArray = new byte[0]; [EOL]         final byte[] oneArray = new byte[] {3}; [EOL]         final byte[] twoArray = new byte[] {4, 6}; [EOL]          [EOL]         assertTrue(ArrayUtils.isSameLength(nullArray, nullArray)); [EOL]         assertTrue(ArrayUtils.isSameLength(nullArray, emptyArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(nullArray, oneArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(nullArray, twoArray)); [EOL]          [EOL]         assertTrue(ArrayUtils.isSameLength(emptyArray, nullArray)); [EOL]         assertTrue(ArrayUtils.isSameLength(emptyArray, emptyArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(emptyArray, oneArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(emptyArray, twoArray)); [EOL]          [EOL]         assertFalse(ArrayUtils.isSameLength(oneArray, nullArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(oneArray, emptyArray)); [EOL]         assertTrue(ArrayUtils.isSameLength(oneArray, oneArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(oneArray, twoArray)); [EOL]          [EOL]         assertFalse(ArrayUtils.isSameLength(twoArray, nullArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(twoArray, emptyArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(twoArray, oneArray)); [EOL]         assertTrue(ArrayUtils.isSameLength(twoArray, twoArray)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testSameLengthDouble() { [EOL]         final double[] nullArray = null; [EOL]         final double[] emptyArray = new double[0]; [EOL]         final double[] oneArray = new double[] {1.3d}; [EOL]         final double[] twoArray = new double[] {4.5d, 6.3d}; [EOL]          [EOL]         assertTrue(ArrayUtils.isSameLength(nullArray, nullArray)); [EOL]         assertTrue(ArrayUtils.isSameLength(nullArray, emptyArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(nullArray, oneArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(nullArray, twoArray)); [EOL]          [EOL]         assertTrue(ArrayUtils.isSameLength(emptyArray, nullArray)); [EOL]         assertTrue(ArrayUtils.isSameLength(emptyArray, emptyArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(emptyArray, oneArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(emptyArray, twoArray)); [EOL]          [EOL]         assertFalse(ArrayUtils.isSameLength(oneArray, nullArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(oneArray, emptyArray)); [EOL]         assertTrue(ArrayUtils.isSameLength(oneArray, oneArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(oneArray, twoArray)); [EOL]          [EOL]         assertFalse(ArrayUtils.isSameLength(twoArray, nullArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(twoArray, emptyArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(twoArray, oneArray)); [EOL]         assertTrue(ArrayUtils.isSameLength(twoArray, twoArray)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testSameLengthFloat() { [EOL]         final float[] nullArray = null; [EOL]         final float[] emptyArray = new float[0]; [EOL]         final float[] oneArray = new float[] {2.5f}; [EOL]         final float[] twoArray = new float[] {6.4f, 5.8f}; [EOL]          [EOL]         assertTrue(ArrayUtils.isSameLength(nullArray, nullArray)); [EOL]         assertTrue(ArrayUtils.isSameLength(nullArray, emptyArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(nullArray, oneArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(nullArray, twoArray)); [EOL]          [EOL]         assertTrue(ArrayUtils.isSameLength(emptyArray, nullArray)); [EOL]         assertTrue(ArrayUtils.isSameLength(emptyArray, emptyArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(emptyArray, oneArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(emptyArray, twoArray)); [EOL]          [EOL]         assertFalse(ArrayUtils.isSameLength(oneArray, nullArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(oneArray, emptyArray)); [EOL]         assertTrue(ArrayUtils.isSameLength(oneArray, oneArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(oneArray, twoArray)); [EOL]          [EOL]         assertFalse(ArrayUtils.isSameLength(twoArray, nullArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(twoArray, emptyArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(twoArray, oneArray)); [EOL]         assertTrue(ArrayUtils.isSameLength(twoArray, twoArray)); [EOL]     } [EOL]      [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testSameLengthBoolean() { [EOL]         final boolean[] nullArray = null; [EOL]         final boolean[] emptyArray = new boolean[0]; [EOL]         final boolean[] oneArray = new boolean[] {true}; [EOL]         final boolean[] twoArray = new boolean[] {true, false}; [EOL]          [EOL]         assertTrue(ArrayUtils.isSameLength(nullArray, nullArray)); [EOL]         assertTrue(ArrayUtils.isSameLength(nullArray, emptyArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(nullArray, oneArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(nullArray, twoArray)); [EOL]          [EOL]         assertTrue(ArrayUtils.isSameLength(emptyArray, nullArray)); [EOL]         assertTrue(ArrayUtils.isSameLength(emptyArray, emptyArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(emptyArray, oneArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(emptyArray, twoArray)); [EOL]          [EOL]         assertFalse(ArrayUtils.isSameLength(oneArray, nullArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(oneArray, emptyArray)); [EOL]         assertTrue(ArrayUtils.isSameLength(oneArray, oneArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(oneArray, twoArray)); [EOL]          [EOL]         assertFalse(ArrayUtils.isSameLength(twoArray, nullArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(twoArray, emptyArray)); [EOL]         assertFalse(ArrayUtils.isSameLength(twoArray, oneArray)); [EOL]         assertTrue(ArrayUtils.isSameLength(twoArray, twoArray)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testReverse() { [EOL]         final StringBuffer str1 = new StringBuffer("pick"); [EOL]         final String str2 = "a"; [EOL]         final String[] str3 = new String[] {"stick"}; [EOL]         final String str4 = "up"; [EOL]          [EOL]         Object[] array = new Object[] {str1, str2, str3}; [EOL]         ArrayUtils.reverse(array); [EOL]         assertEquals(array[0], str3); [EOL]         assertEquals(array[1], str2); [EOL]         assertEquals(array[2], str1); [EOL]          [EOL]         array = new Object[] {str1, str2, str3, str4}; [EOL]         ArrayUtils.reverse(array); [EOL]         assertEquals(array[0], str4); [EOL]         assertEquals(array[1], str3); [EOL]         assertEquals(array[2], str2); [EOL]         assertEquals(array[3], str1); [EOL]  [EOL]         array = null; [EOL]         ArrayUtils.reverse(array); [EOL]         assertArrayEquals(null, array); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReverseLong() { [EOL]         long[] array = new long[] {1L, 2L, 3L}; [EOL]         ArrayUtils.reverse(array); [EOL]         assertEquals(array[0], 3L); [EOL]         assertEquals(array[1], 2L); [EOL]         assertEquals(array[2], 1L); [EOL]  [EOL]         array = null; [EOL]         ArrayUtils.reverse(array); [EOL]         assertEquals(null, array); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testReverseChar() { [EOL]         char[] array = new char[] {'a', 'f', 'C'}; [EOL]         ArrayUtils.reverse(array); [EOL]         assertEquals(array[0], 'C'); [EOL]         assertEquals(array[1], 'f'); [EOL]         assertEquals(array[2], 'a'); [EOL]  [EOL]         array = null; [EOL]         ArrayUtils.reverse(array); [EOL]         assertEquals(null, array); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testReverseByte() { [EOL]         byte[] array = new byte[] {2, 3, 4}; [EOL]         ArrayUtils.reverse(array); [EOL]         assertEquals(array[0], 4); [EOL]         assertEquals(array[1], 3); [EOL]         assertEquals(array[2], 2); [EOL]  [EOL]         array = null; [EOL]         ArrayUtils.reverse(array); [EOL]         assertEquals(null, array); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testReverseBoolean() { [EOL]         boolean[] array = new boolean[] {false, false, true}; [EOL]         ArrayUtils.reverse(array); [EOL]         assertTrue(array[0]); [EOL]         assertFalse(array[1]); [EOL]         assertFalse(array[2]); [EOL]  [EOL]         array = null; [EOL]         ArrayUtils.reverse(array); [EOL]         assertEquals(null, array); [EOL]     } [EOL]      [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testLastIndexOfWithStartIndex() { [EOL]         final Object[] array = new Object[] { "0", "1", "2", "3", null, "0" }; [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(null, null, 2)); [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(null, "0", 2)); [EOL]         assertEquals(0, ArrayUtils.lastIndexOf(array, "0", 2)); [EOL]         assertEquals(1, ArrayUtils.lastIndexOf(array, "1", 2)); [EOL]         assertEquals(2, ArrayUtils.lastIndexOf(array, "2", 2)); [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, "3", 2)); [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, "3", -1)); [EOL]         assertEquals(4, ArrayUtils.lastIndexOf(array, null, 5)); [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, null, 2)); [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, "notInArray", 5)); [EOL]          [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, null, -1)); [EOL]         assertEquals(5, ArrayUtils.lastIndexOf(array, "0", 88)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLastIndexOfLongWithStartIndex() { [EOL]         long[] array = null; [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, 0, 2)); [EOL]         array = new long[] { 0, 1, 2, 3, 0 }; [EOL]         assertEquals(0, ArrayUtils.lastIndexOf(array, 0, 2)); [EOL]         assertEquals(1, ArrayUtils.lastIndexOf(array, 1, 2)); [EOL]         assertEquals(2, ArrayUtils.lastIndexOf(array, 2, 2)); [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, 3, 2)); [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, 3, -1)); [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, 99, 4)); [EOL]         assertEquals(4, ArrayUtils.lastIndexOf(array, 0, 88)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLastIndexOfLongWithStartIndex() { [EOL]         long[] array = null; [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, 0, 2)); [EOL]         array = new long[] { 0, 1, 2, 3, 0 }; [EOL]         assertEquals(0, ArrayUtils.lastIndexOf(array, 0, 2)); [EOL]         assertEquals(1, ArrayUtils.lastIndexOf(array, 1, 2)); [EOL]         assertEquals(2, ArrayUtils.lastIndexOf(array, 2, 2)); [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, 3, 2)); [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, 3, -1)); [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, 99, 4)); [EOL]         assertEquals(4, ArrayUtils.lastIndexOf(array, 0, 88)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIndexOfShortWithStartIndex() { [EOL]         short[] array = null; [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, (short) 0, 2)); [EOL]         array = new short[] { 0, 1, 2, 3, 0 }; [EOL]         assertEquals(4, ArrayUtils.indexOf(array, (short) 0, 2)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, (short) 1, 2)); [EOL]         assertEquals(2, ArrayUtils.indexOf(array, (short) 2, 2)); [EOL]         assertEquals(3, ArrayUtils.indexOf(array, (short) 3, 2)); [EOL]         assertEquals(3, ArrayUtils.indexOf(array, (short) 3, -1)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, (short) 99, 0)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, (short) 0, 6)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIndexOfCharWithStartIndex() { [EOL]         char[] array = null; [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, 'a', 2)); [EOL]         array = new char[] { 'a', 'b', 'c', 'd', 'a' }; [EOL]         assertEquals(4, ArrayUtils.indexOf(array, 'a', 2)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, 'b', 2)); [EOL]         assertEquals(2, ArrayUtils.indexOf(array, 'c', 2)); [EOL]         assertEquals(3, ArrayUtils.indexOf(array, 'd', 2)); [EOL]         assertEquals(3, ArrayUtils.indexOf(array, 'd', -1)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, 'e', 0)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, 'a', 6)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLastIndexOfCharWithStartIndex() { [EOL]         char[] array = null; [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, 'a', 2)); [EOL]         array = new char[] { 'a', 'b', 'c', 'd', 'a' }; [EOL]         assertEquals(0, ArrayUtils.lastIndexOf(array, 'a', 2)); [EOL]         assertEquals(1, ArrayUtils.lastIndexOf(array, 'b', 2)); [EOL]         assertEquals(2, ArrayUtils.lastIndexOf(array, 'c', 2)); [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, 'd', 2)); [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, 'd', -1)); [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, 'e')); [EOL]         assertEquals(4, ArrayUtils.lastIndexOf(array, 'a', 88)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testContainsByte() { [EOL]         byte[] array = null; [EOL]         assertFalse(ArrayUtils.contains(array, (byte) 1)); [EOL]         array = new byte[] { 0, 1, 2, 3, 0 }; [EOL]         assertTrue(ArrayUtils.contains(array, (byte) 0)); [EOL]         assertTrue(ArrayUtils.contains(array, (byte) 1)); [EOL]         assertTrue(ArrayUtils.contains(array, (byte) 2)); [EOL]         assertTrue(ArrayUtils.contains(array, (byte) 3)); [EOL]         assertFalse(ArrayUtils.contains(array, (byte) 99)); [EOL]     } [EOL]      [EOL]     //----------------------------------------------------------------------- [EOL]     @SuppressWarnings("cast") [EOL]
@Test [EOL]     public void testLastIndexOfFloatWithStartIndex() { [EOL]         float[] array = null; [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, (float) 0, 2)); [EOL]         array = new float[0]; [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, (float) 0, 2)); [EOL]         array = new float[] { 0, 1, 2, 3, 0 }; [EOL]         assertEquals(0, ArrayUtils.lastIndexOf(array, (float) 0, 2)); [EOL]         assertEquals(1, ArrayUtils.lastIndexOf(array, (float) 1, 2)); [EOL]         assertEquals(2, ArrayUtils.lastIndexOf(array, (float) 2, 2)); [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, (float) 3, 2)); [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, (float) 3, -1)); [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, (float) 99)); [EOL]         assertEquals(4, ArrayUtils.lastIndexOf(array, (float) 0, 88)); [EOL]     } [EOL]  [EOL]     @SuppressWarnings("cast") [EOL]
@Test [EOL]     public void testToPrimitive_char() { [EOL]         final Character[] b = null; [EOL]         assertEquals(null, ArrayUtils.toPrimitive(b)); [EOL]          [EOL]         assertSame(ArrayUtils.EMPTY_CHAR_ARRAY, ArrayUtils.toPrimitive(new Character[0])); [EOL]          [EOL]         assertTrue(Arrays.equals( [EOL]             new char[] {Character.MIN_VALUE, Character.MAX_VALUE, '0'}, [EOL]             ArrayUtils.toPrimitive(new Character[] {new Character(Character.MIN_VALUE),  [EOL]                 new Character(Character.MAX_VALUE), new Character('0')})) [EOL]         ); [EOL]  [EOL]         try { [EOL]             ArrayUtils.toPrimitive(new Character[] {new Character(Character.MIN_VALUE), null}); [EOL]             fail(); [EOL]         } catch (final NullPointerException ex) {} [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testToPrimitive_char_char() { [EOL]         final Character[] b = null; [EOL]         assertEquals(null, ArrayUtils.toPrimitive(b, Character.MIN_VALUE)); [EOL]          [EOL]         assertSame(ArrayUtils.EMPTY_CHAR_ARRAY,  [EOL]             ArrayUtils.toPrimitive(new Character[0], (char)0)); [EOL]          [EOL]         assertTrue(Arrays.equals( [EOL]             new char[] {Character.MIN_VALUE, Character.MAX_VALUE, '0'}, [EOL]             ArrayUtils.toPrimitive(new Character[] {new Character(Character.MIN_VALUE),  [EOL]                 new Character(Character.MAX_VALUE), new Character('0')},  [EOL]                 Character.MIN_VALUE)) [EOL]         ); [EOL]          [EOL]         assertTrue(Arrays.equals( [EOL]             new char[] {Character.MIN_VALUE, Character.MAX_VALUE, '0'}, [EOL]             ArrayUtils.toPrimitive(new Character[] {new Character(Character.MIN_VALUE), null,  [EOL]                 new Character('0')}, Character.MAX_VALUE)) [EOL]         ); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testToObject_char() { [EOL]         final char[] b = null; [EOL]         assertArrayEquals(null, ArrayUtils.toObject(b)); [EOL]          [EOL]         assertSame(ArrayUtils.EMPTY_CHARACTER_OBJECT_ARRAY,  [EOL]             ArrayUtils.toObject(new char[0])); [EOL]          [EOL]         assertTrue(Arrays.equals( [EOL]             new Character[] {new Character(Character.MIN_VALUE),  [EOL]                 new Character(Character.MAX_VALUE), new Character('0')}, [EOL]                 ArrayUtils.toObject(new char[] {Character.MIN_VALUE, Character.MAX_VALUE,  [EOL]                 '0'} )) [EOL]         ); [EOL]     } [EOL]      [EOL]     // testToPrimitive/Object for byte [EOL]     //  ----------------------------------------------------------------------- [EOL]
@Test [EOL]      public void testToPrimitive_long() { [EOL]          final Long[] b = null; [EOL]          assertEquals(null, ArrayUtils.toPrimitive(b)); [EOL]           [EOL]          assertSame(ArrayUtils.EMPTY_LONG_ARRAY,  [EOL]             ArrayUtils.toPrimitive(new Long[0])); [EOL]           [EOL]          assertTrue(Arrays.equals( [EOL]              new long[] {Long.MIN_VALUE, Long.MAX_VALUE, 9999999}, [EOL]              ArrayUtils.toPrimitive(new Long[] {Long.valueOf(Long.MIN_VALUE),  [EOL]                  Long.valueOf(Long.MAX_VALUE), Long.valueOf(9999999)})) [EOL]          ); [EOL]  [EOL]          try { [EOL]              ArrayUtils.toPrimitive(new Long[] {Long.valueOf(Long.MIN_VALUE), null}); [EOL]              fail(); [EOL]          } catch (final NullPointerException ex) {} [EOL]      } [EOL]  [EOL]
@Test [EOL]      public void testToPrimitive_long() { [EOL]          final Long[] b = null; [EOL]          assertEquals(null, ArrayUtils.toPrimitive(b)); [EOL]           [EOL]          assertSame(ArrayUtils.EMPTY_LONG_ARRAY,  [EOL]             ArrayUtils.toPrimitive(new Long[0])); [EOL]           [EOL]          assertTrue(Arrays.equals( [EOL]              new long[] {Long.MIN_VALUE, Long.MAX_VALUE, 9999999}, [EOL]              ArrayUtils.toPrimitive(new Long[] {Long.valueOf(Long.MIN_VALUE),  [EOL]                  Long.valueOf(Long.MAX_VALUE), Long.valueOf(9999999)})) [EOL]          ); [EOL]  [EOL]          try { [EOL]              ArrayUtils.toPrimitive(new Long[] {Long.valueOf(Long.MIN_VALUE), null}); [EOL]              fail(); [EOL]          } catch (final NullPointerException ex) {} [EOL]      } [EOL]  [EOL]
@Test [EOL]      public void testToPrimitive_long_long() { [EOL]          final Long[] l = null; [EOL]          assertEquals(null, ArrayUtils.toPrimitive(l, Long.MIN_VALUE)); [EOL]           [EOL]          assertSame(ArrayUtils.EMPTY_LONG_ARRAY,  [EOL]          ArrayUtils.toPrimitive(new Long[0], 1)); [EOL]           [EOL]          assertTrue(Arrays.equals( [EOL]              new long[] {Long.MIN_VALUE, Long.MAX_VALUE, 9999999}, [EOL]              ArrayUtils.toPrimitive(new Long[] {Long.valueOf(Long.MIN_VALUE),  [EOL]                  Long.valueOf(Long.MAX_VALUE), Long.valueOf(9999999)},1))); [EOL]           [EOL]          assertTrue(Arrays.equals( [EOL]              new long[] {Long.MIN_VALUE, Long.MAX_VALUE, 9999999}, [EOL]              ArrayUtils.toPrimitive(new Long[] {Long.valueOf(Long.MIN_VALUE),  [EOL]                  null, Long.valueOf(9999999)}, Long.MAX_VALUE)) [EOL]          ); [EOL]      } [EOL]       [EOL]
@Test [EOL]      public void testToPrimitive_long_long() { [EOL]          final Long[] l = null; [EOL]          assertEquals(null, ArrayUtils.toPrimitive(l, Long.MIN_VALUE)); [EOL]           [EOL]          assertSame(ArrayUtils.EMPTY_LONG_ARRAY,  [EOL]          ArrayUtils.toPrimitive(new Long[0], 1)); [EOL]           [EOL]          assertTrue(Arrays.equals( [EOL]              new long[] {Long.MIN_VALUE, Long.MAX_VALUE, 9999999}, [EOL]              ArrayUtils.toPrimitive(new Long[] {Long.valueOf(Long.MIN_VALUE),  [EOL]                  Long.valueOf(Long.MAX_VALUE), Long.valueOf(9999999)},1))); [EOL]           [EOL]          assertTrue(Arrays.equals( [EOL]              new long[] {Long.MIN_VALUE, Long.MAX_VALUE, 9999999}, [EOL]              ArrayUtils.toPrimitive(new Long[] {Long.valueOf(Long.MIN_VALUE),  [EOL]                  null, Long.valueOf(9999999)}, Long.MAX_VALUE)) [EOL]          ); [EOL]      } [EOL]       [EOL]
@Test [EOL]     public void testToObject_long() { [EOL]         final long[] b = null; [EOL]         assertArrayEquals(null, ArrayUtils.toObject(b)); [EOL]      [EOL]         assertSame( [EOL]             ArrayUtils.EMPTY_LONG_OBJECT_ARRAY, [EOL]             ArrayUtils.toObject(new long[0])); [EOL]      [EOL]         assertTrue( [EOL]             Arrays.equals( [EOL]                 new Long[] { [EOL]                     Long.valueOf(Long.MIN_VALUE), [EOL]                     Long.valueOf(Long.MAX_VALUE), [EOL]                     Long.valueOf(9999999)}, [EOL]             ArrayUtils.toObject( [EOL]                 new long[] { Long.MIN_VALUE, Long.MAX_VALUE, 9999999 }))); [EOL]     } [EOL]  [EOL]     //  testToPrimitive/Object for float [EOL]     //  ----------------------------------------------------------------------- [EOL]
@Test [EOL]      public void testToPrimitive_int() { [EOL]          final Integer[] b = null; [EOL]          assertEquals(null, ArrayUtils.toPrimitive(b)); [EOL]          assertSame(ArrayUtils.EMPTY_INT_ARRAY, ArrayUtils.toPrimitive(new Integer[0])); [EOL]          assertTrue(Arrays.equals( [EOL]              new int[] {Integer.MIN_VALUE, Integer.MAX_VALUE, 9999999}, [EOL]              ArrayUtils.toPrimitive(new Integer[] {Integer.valueOf(Integer.MIN_VALUE),  [EOL]                  Integer.valueOf(Integer.MAX_VALUE), Integer.valueOf(9999999)})) [EOL]          ); [EOL]  [EOL]          try { [EOL]              ArrayUtils.toPrimitive(new Integer[] {Integer.valueOf(Integer.MIN_VALUE), null}); [EOL]              fail(); [EOL]          } catch (final NullPointerException ex) {} [EOL]      } [EOL]  [EOL]
@Test [EOL]     public void testToPrimitive_intNull() { [EOL]         final Integer[] iArray = null; [EOL]         assertEquals(null, ArrayUtils.toPrimitive(iArray, Integer.MIN_VALUE)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testToPrimitive_intNull() { [EOL]         final Integer[] iArray = null; [EOL]         assertEquals(null, ArrayUtils.toPrimitive(iArray, Integer.MIN_VALUE)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testToPrimitive_intNull() { [EOL]         final Integer[] iArray = null; [EOL]         assertEquals(null, ArrayUtils.toPrimitive(iArray, Integer.MIN_VALUE)); [EOL]     } [EOL]  [EOL]
@Test [EOL]      public void testToPrimitive_int_int() { [EOL]          final Long[] l = null; [EOL]          assertEquals(null, ArrayUtils.toPrimitive(l, Integer.MIN_VALUE)); [EOL]          assertSame(ArrayUtils.EMPTY_INT_ARRAY,  [EOL]          ArrayUtils.toPrimitive(new Integer[0], 1)); [EOL]          assertTrue(Arrays.equals( [EOL]              new int[] {Integer.MIN_VALUE, Integer.MAX_VALUE, 9999999}, [EOL]              ArrayUtils.toPrimitive(new Integer[] {Integer.valueOf(Integer.MIN_VALUE),  [EOL]                  Integer.valueOf(Integer.MAX_VALUE), Integer.valueOf(9999999)},1))); [EOL]          assertTrue(Arrays.equals( [EOL]              new int[] {Integer.MIN_VALUE, Integer.MAX_VALUE, 9999999}, [EOL]              ArrayUtils.toPrimitive(new Integer[] {Integer.valueOf(Integer.MIN_VALUE),  [EOL]                  null, Integer.valueOf(9999999)}, Integer.MAX_VALUE)) [EOL]          ); [EOL]      } [EOL]       [EOL]
@Test [EOL]      public void testToPrimitive_int_int() { [EOL]          final Long[] l = null; [EOL]          assertEquals(null, ArrayUtils.toPrimitive(l, Integer.MIN_VALUE)); [EOL]          assertSame(ArrayUtils.EMPTY_INT_ARRAY,  [EOL]          ArrayUtils.toPrimitive(new Integer[0], 1)); [EOL]          assertTrue(Arrays.equals( [EOL]              new int[] {Integer.MIN_VALUE, Integer.MAX_VALUE, 9999999}, [EOL]              ArrayUtils.toPrimitive(new Integer[] {Integer.valueOf(Integer.MIN_VALUE),  [EOL]                  Integer.valueOf(Integer.MAX_VALUE), Integer.valueOf(9999999)},1))); [EOL]          assertTrue(Arrays.equals( [EOL]              new int[] {Integer.MIN_VALUE, Integer.MAX_VALUE, 9999999}, [EOL]              ArrayUtils.toPrimitive(new Integer[] {Integer.valueOf(Integer.MIN_VALUE),  [EOL]                  null, Integer.valueOf(9999999)}, Integer.MAX_VALUE)) [EOL]          ); [EOL]      } [EOL]       [EOL]
@Test [EOL]      public void testToPrimitive_int_int() { [EOL]          final Long[] l = null; [EOL]          assertEquals(null, ArrayUtils.toPrimitive(l, Integer.MIN_VALUE)); [EOL]          assertSame(ArrayUtils.EMPTY_INT_ARRAY,  [EOL]          ArrayUtils.toPrimitive(new Integer[0], 1)); [EOL]          assertTrue(Arrays.equals( [EOL]              new int[] {Integer.MIN_VALUE, Integer.MAX_VALUE, 9999999}, [EOL]              ArrayUtils.toPrimitive(new Integer[] {Integer.valueOf(Integer.MIN_VALUE),  [EOL]                  Integer.valueOf(Integer.MAX_VALUE), Integer.valueOf(9999999)},1))); [EOL]          assertTrue(Arrays.equals( [EOL]              new int[] {Integer.MIN_VALUE, Integer.MAX_VALUE, 9999999}, [EOL]              ArrayUtils.toPrimitive(new Integer[] {Integer.valueOf(Integer.MIN_VALUE),  [EOL]                  null, Integer.valueOf(9999999)}, Integer.MAX_VALUE)) [EOL]          ); [EOL]      } [EOL]       [EOL]
@Test [EOL]      public void testToPrimitive_int_int() { [EOL]          final Long[] l = null; [EOL]          assertEquals(null, ArrayUtils.toPrimitive(l, Integer.MIN_VALUE)); [EOL]          assertSame(ArrayUtils.EMPTY_INT_ARRAY,  [EOL]          ArrayUtils.toPrimitive(new Integer[0], 1)); [EOL]          assertTrue(Arrays.equals( [EOL]              new int[] {Integer.MIN_VALUE, Integer.MAX_VALUE, 9999999}, [EOL]              ArrayUtils.toPrimitive(new Integer[] {Integer.valueOf(Integer.MIN_VALUE),  [EOL]                  Integer.valueOf(Integer.MAX_VALUE), Integer.valueOf(9999999)},1))); [EOL]          assertTrue(Arrays.equals( [EOL]              new int[] {Integer.MIN_VALUE, Integer.MAX_VALUE, 9999999}, [EOL]              ArrayUtils.toPrimitive(new Integer[] {Integer.valueOf(Integer.MIN_VALUE),  [EOL]                  null, Integer.valueOf(9999999)}, Integer.MAX_VALUE)) [EOL]          ); [EOL]      } [EOL]       [EOL]
@Test [EOL]      public void testToPrimitive_int_int() { [EOL]          final Long[] l = null; [EOL]          assertEquals(null, ArrayUtils.toPrimitive(l, Integer.MIN_VALUE)); [EOL]          assertSame(ArrayUtils.EMPTY_INT_ARRAY,  [EOL]          ArrayUtils.toPrimitive(new Integer[0], 1)); [EOL]          assertTrue(Arrays.equals( [EOL]              new int[] {Integer.MIN_VALUE, Integer.MAX_VALUE, 9999999}, [EOL]              ArrayUtils.toPrimitive(new Integer[] {Integer.valueOf(Integer.MIN_VALUE),  [EOL]                  Integer.valueOf(Integer.MAX_VALUE), Integer.valueOf(9999999)},1))); [EOL]          assertTrue(Arrays.equals( [EOL]              new int[] {Integer.MIN_VALUE, Integer.MAX_VALUE, 9999999}, [EOL]              ArrayUtils.toPrimitive(new Integer[] {Integer.valueOf(Integer.MIN_VALUE),  [EOL]                  null, Integer.valueOf(9999999)}, Integer.MAX_VALUE)) [EOL]          ); [EOL]      } [EOL]       [EOL]
@Test [EOL]      public void testToPrimitive_int_int() { [EOL]          final Long[] l = null; [EOL]          assertEquals(null, ArrayUtils.toPrimitive(l, Integer.MIN_VALUE)); [EOL]          assertSame(ArrayUtils.EMPTY_INT_ARRAY,  [EOL]          ArrayUtils.toPrimitive(new Integer[0], 1)); [EOL]          assertTrue(Arrays.equals( [EOL]              new int[] {Integer.MIN_VALUE, Integer.MAX_VALUE, 9999999}, [EOL]              ArrayUtils.toPrimitive(new Integer[] {Integer.valueOf(Integer.MIN_VALUE),  [EOL]                  Integer.valueOf(Integer.MAX_VALUE), Integer.valueOf(9999999)},1))); [EOL]          assertTrue(Arrays.equals( [EOL]              new int[] {Integer.MIN_VALUE, Integer.MAX_VALUE, 9999999}, [EOL]              ArrayUtils.toPrimitive(new Integer[] {Integer.valueOf(Integer.MIN_VALUE),  [EOL]                  null, Integer.valueOf(9999999)}, Integer.MAX_VALUE)) [EOL]          ); [EOL]      } [EOL]       [EOL]
@Test [EOL]      public void testToPrimitive_int_int() { [EOL]          final Long[] l = null; [EOL]          assertEquals(null, ArrayUtils.toPrimitive(l, Integer.MIN_VALUE)); [EOL]          assertSame(ArrayUtils.EMPTY_INT_ARRAY,  [EOL]          ArrayUtils.toPrimitive(new Integer[0], 1)); [EOL]          assertTrue(Arrays.equals( [EOL]              new int[] {Integer.MIN_VALUE, Integer.MAX_VALUE, 9999999}, [EOL]              ArrayUtils.toPrimitive(new Integer[] {Integer.valueOf(Integer.MIN_VALUE),  [EOL]                  Integer.valueOf(Integer.MAX_VALUE), Integer.valueOf(9999999)},1))); [EOL]          assertTrue(Arrays.equals( [EOL]              new int[] {Integer.MIN_VALUE, Integer.MAX_VALUE, 9999999}, [EOL]              ArrayUtils.toPrimitive(new Integer[] {Integer.valueOf(Integer.MIN_VALUE),  [EOL]                  null, Integer.valueOf(9999999)}, Integer.MAX_VALUE)) [EOL]          ); [EOL]      } [EOL]       [EOL]
@Test [EOL]     public void testToObject_int() { [EOL]         final int[] b = null; [EOL]         assertArrayEquals(null, ArrayUtils.toObject(b)); [EOL]      [EOL]         assertSame( [EOL]             ArrayUtils.EMPTY_INTEGER_OBJECT_ARRAY, [EOL]             ArrayUtils.toObject(new int[0])); [EOL]      [EOL]         assertTrue( [EOL]             Arrays.equals( [EOL]                 new Integer[] { [EOL]                     Integer.valueOf(Integer.MIN_VALUE), [EOL]                     Integer.valueOf(Integer.MAX_VALUE), [EOL]                     Integer.valueOf(9999999)}, [EOL]             ArrayUtils.toObject( [EOL]                 new int[] { Integer.MIN_VALUE, Integer.MAX_VALUE, 9999999 }))); [EOL]     } [EOL]  [EOL]     //  testToPrimitive/Object for long [EOL]     //  ----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testToObject_int() { [EOL]         final int[] b = null; [EOL]         assertArrayEquals(null, ArrayUtils.toObject(b)); [EOL]      [EOL]         assertSame( [EOL]             ArrayUtils.EMPTY_INTEGER_OBJECT_ARRAY, [EOL]             ArrayUtils.toObject(new int[0])); [EOL]      [EOL]         assertTrue( [EOL]             Arrays.equals( [EOL]                 new Integer[] { [EOL]                     Integer.valueOf(Integer.MIN_VALUE), [EOL]                     Integer.valueOf(Integer.MAX_VALUE), [EOL]                     Integer.valueOf(9999999)}, [EOL]             ArrayUtils.toObject( [EOL]                 new int[] { Integer.MIN_VALUE, Integer.MAX_VALUE, 9999999 }))); [EOL]     } [EOL]  [EOL]     //  testToPrimitive/Object for long [EOL]     //  ----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testToPrimitive_short_short() { [EOL]         final Short[] s = null; [EOL]         assertEquals(null, ArrayUtils.toPrimitive(s, Short.MIN_VALUE)); [EOL]          [EOL]         assertSame(ArrayUtils.EMPTY_SHORT_ARRAY, ArrayUtils.toPrimitive(new Short[0],  [EOL]         Short.MIN_VALUE)); [EOL]          [EOL]         assertTrue(Arrays.equals( [EOL]             new short[] {Short.MIN_VALUE, Short.MAX_VALUE, (short)9999999}, [EOL]             ArrayUtils.toPrimitive(new Short[] {Short.valueOf(Short.MIN_VALUE),  [EOL]                 Short.valueOf(Short.MAX_VALUE), Short.valueOf((short)9999999)}, Short.MIN_VALUE)) [EOL]         ); [EOL]          [EOL]         assertTrue(Arrays.equals( [EOL]             new short[] {Short.MIN_VALUE, Short.MAX_VALUE, (short)9999999}, [EOL]             ArrayUtils.toPrimitive(new Short[] {Short.valueOf(Short.MIN_VALUE), null,  [EOL]                 Short.valueOf((short)9999999)}, Short.MAX_VALUE)) [EOL]         ); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testToPrimitive_short_short() { [EOL]         final Short[] s = null; [EOL]         assertEquals(null, ArrayUtils.toPrimitive(s, Short.MIN_VALUE)); [EOL]          [EOL]         assertSame(ArrayUtils.EMPTY_SHORT_ARRAY, ArrayUtils.toPrimitive(new Short[0],  [EOL]         Short.MIN_VALUE)); [EOL]          [EOL]         assertTrue(Arrays.equals( [EOL]             new short[] {Short.MIN_VALUE, Short.MAX_VALUE, (short)9999999}, [EOL]             ArrayUtils.toPrimitive(new Short[] {Short.valueOf(Short.MIN_VALUE),  [EOL]                 Short.valueOf(Short.MAX_VALUE), Short.valueOf((short)9999999)}, Short.MIN_VALUE)) [EOL]         ); [EOL]          [EOL]         assertTrue(Arrays.equals( [EOL]             new short[] {Short.MIN_VALUE, Short.MAX_VALUE, (short)9999999}, [EOL]             ArrayUtils.toPrimitive(new Short[] {Short.valueOf(Short.MIN_VALUE), null,  [EOL]                 Short.valueOf((short)9999999)}, Short.MAX_VALUE)) [EOL]         ); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testToPrimitive_byte() { [EOL]         final Byte[] b = null; [EOL]         assertEquals(null, ArrayUtils.toPrimitive(b)); [EOL]          [EOL]         assertSame(ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.toPrimitive(new Byte[0])); [EOL]          [EOL]         assertTrue(Arrays.equals( [EOL]             new byte[] {Byte.MIN_VALUE, Byte.MAX_VALUE, (byte)9999999}, [EOL]             ArrayUtils.toPrimitive(new Byte[] {Byte.valueOf(Byte.MIN_VALUE),  [EOL]                 Byte.valueOf(Byte.MAX_VALUE), Byte.valueOf((byte)9999999)})) [EOL]         ); [EOL]  [EOL]         try { [EOL]             ArrayUtils.toPrimitive(new Byte[] {Byte.valueOf(Byte.MIN_VALUE), null}); [EOL]             fail(); [EOL]         } catch (final NullPointerException ex) {} [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testToPrimitive_byte_byte() { [EOL]         final Byte[] b = null; [EOL]         assertEquals(null, ArrayUtils.toPrimitive(b, Byte.MIN_VALUE)); [EOL]          [EOL]         assertSame(ArrayUtils.EMPTY_BYTE_ARRAY,  [EOL]             ArrayUtils.toPrimitive(new Byte[0], (byte)1)); [EOL]          [EOL]         assertTrue(Arrays.equals( [EOL]             new byte[] {Byte.MIN_VALUE, Byte.MAX_VALUE, (byte)9999999}, [EOL]             ArrayUtils.toPrimitive(new Byte[] {Byte.valueOf(Byte.MIN_VALUE),  [EOL]                 Byte.valueOf(Byte.MAX_VALUE), Byte.valueOf((byte)9999999)},  [EOL]                 Byte.MIN_VALUE)) [EOL]         ); [EOL]          [EOL]         assertTrue(Arrays.equals( [EOL]             new byte[] {Byte.MIN_VALUE, Byte.MAX_VALUE, (byte)9999999}, [EOL]             ArrayUtils.toPrimitive(new Byte[] {Byte.valueOf(Byte.MIN_VALUE), null,  [EOL]                 Byte.valueOf((byte)9999999)}, Byte.MAX_VALUE)) [EOL]         ); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testToObject_byte() { [EOL]         final byte[] b = null; [EOL]         assertArrayEquals(null, ArrayUtils.toObject(b)); [EOL]          [EOL]         assertSame(ArrayUtils.EMPTY_BYTE_OBJECT_ARRAY,  [EOL]             ArrayUtils.toObject(new byte[0])); [EOL]          [EOL]         assertTrue(Arrays.equals( [EOL]             new Byte[] {Byte.valueOf(Byte.MIN_VALUE),  [EOL]                 Byte.valueOf(Byte.MAX_VALUE), Byte.valueOf((byte)9999999)}, [EOL]                 ArrayUtils.toObject(new byte[] {Byte.MIN_VALUE, Byte.MAX_VALUE,  [EOL]                 (byte)9999999})) [EOL]         ); [EOL]     } [EOL]  [EOL]     // testToPrimitive/Object for short [EOL]     //  ----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testToObject_byte() { [EOL]         final byte[] b = null; [EOL]         assertArrayEquals(null, ArrayUtils.toObject(b)); [EOL]          [EOL]         assertSame(ArrayUtils.EMPTY_BYTE_OBJECT_ARRAY,  [EOL]             ArrayUtils.toObject(new byte[0])); [EOL]          [EOL]         assertTrue(Arrays.equals( [EOL]             new Byte[] {Byte.valueOf(Byte.MIN_VALUE),  [EOL]                 Byte.valueOf(Byte.MAX_VALUE), Byte.valueOf((byte)9999999)}, [EOL]                 ArrayUtils.toObject(new byte[] {Byte.MIN_VALUE, Byte.MAX_VALUE,  [EOL]                 (byte)9999999})) [EOL]         ); [EOL]     } [EOL]  [EOL]     // testToPrimitive/Object for short [EOL]     //  ----------------------------------------------------------------------- [EOL]
@Test [EOL]      public void testToPrimitive_double() { [EOL]          final Double[] b = null; [EOL]          assertEquals(null, ArrayUtils.toPrimitive(b)); [EOL]           [EOL]          assertSame(ArrayUtils.EMPTY_DOUBLE_ARRAY,  [EOL]             ArrayUtils.toPrimitive(new Double[0])); [EOL]           [EOL]          assertTrue(Arrays.equals( [EOL]              new double[] {Double.MIN_VALUE, Double.MAX_VALUE, 9999999}, [EOL]              ArrayUtils.toPrimitive(new Double[] {Double.valueOf(Double.MIN_VALUE),  [EOL]                  Double.valueOf(Double.MAX_VALUE), Double.valueOf(9999999)})) [EOL]          ); [EOL]  [EOL]          try { [EOL]              ArrayUtils.toPrimitive(new Float[] {Float.valueOf(Float.MIN_VALUE), null}); [EOL]              fail(); [EOL]          } catch (final NullPointerException ex) {} [EOL]      } [EOL]  [EOL]
@Test [EOL]      public void testToPrimitive_double_double() { [EOL]          final Double[] l = null; [EOL]          assertEquals(null, ArrayUtils.toPrimitive(l, Double.MIN_VALUE)); [EOL]           [EOL]          assertSame(ArrayUtils.EMPTY_DOUBLE_ARRAY,  [EOL]          ArrayUtils.toPrimitive(new Double[0], 1)); [EOL]           [EOL]          assertTrue(Arrays.equals( [EOL]              new double[] {Double.MIN_VALUE, Double.MAX_VALUE, 9999999}, [EOL]              ArrayUtils.toPrimitive(new Double[] {Double.valueOf(Double.MIN_VALUE),  [EOL]                  Double.valueOf(Double.MAX_VALUE), Double.valueOf(9999999)},1))); [EOL]           [EOL]          assertTrue(Arrays.equals( [EOL]              new double[] {Double.MIN_VALUE, Double.MAX_VALUE, 9999999}, [EOL]              ArrayUtils.toPrimitive(new Double[] {Double.valueOf(Double.MIN_VALUE),  [EOL]                  null, Double.valueOf(9999999)}, Double.MAX_VALUE)) [EOL]          ); [EOL]      } [EOL]       [EOL]
@Test [EOL]     public void testToObject_double() { [EOL]         final double[] b = null; [EOL]         assertArrayEquals(null, ArrayUtils.toObject(b)); [EOL]      [EOL]         assertSame( [EOL]             ArrayUtils.EMPTY_DOUBLE_OBJECT_ARRAY, [EOL]             ArrayUtils.toObject(new double[0])); [EOL]      [EOL]         assertTrue( [EOL]             Arrays.equals( [EOL]                 new Double[] { [EOL]                     Double.valueOf(Double.MIN_VALUE), [EOL]                     Double.valueOf(Double.MAX_VALUE), [EOL]                     Double.valueOf(9999999)}, [EOL]             ArrayUtils.toObject( [EOL]                 new double[] { Double.MIN_VALUE, Double.MAX_VALUE, 9999999 }))); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]     /** [EOL]      * Test for {@link ArrayUtils#isEmpty(java.lang.Object[])}. [EOL]      */ [EOL]
@Test [EOL]     public void testToObject_double() { [EOL]         final double[] b = null; [EOL]         assertArrayEquals(null, ArrayUtils.toObject(b)); [EOL]      [EOL]         assertSame( [EOL]             ArrayUtils.EMPTY_DOUBLE_OBJECT_ARRAY, [EOL]             ArrayUtils.toObject(new double[0])); [EOL]      [EOL]         assertTrue( [EOL]             Arrays.equals( [EOL]                 new Double[] { [EOL]                     Double.valueOf(Double.MIN_VALUE), [EOL]                     Double.valueOf(Double.MAX_VALUE), [EOL]                     Double.valueOf(9999999)}, [EOL]             ArrayUtils.toObject( [EOL]                 new double[] { Double.MIN_VALUE, Double.MAX_VALUE, 9999999 }))); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]     /** [EOL]      * Test for {@link ArrayUtils#isEmpty(java.lang.Object[])}. [EOL]      */ [EOL]
@Test [EOL]      public void testToPrimitive_float() { [EOL]          final Float[] b = null; [EOL]          assertEquals(null, ArrayUtils.toPrimitive(b)); [EOL]           [EOL]          assertSame(ArrayUtils.EMPTY_FLOAT_ARRAY,  [EOL]             ArrayUtils.toPrimitive(new Float[0])); [EOL]           [EOL]          assertTrue(Arrays.equals( [EOL]              new float[] {Float.MIN_VALUE, Float.MAX_VALUE, 9999999}, [EOL]              ArrayUtils.toPrimitive(new Float[] {Float.valueOf(Float.MIN_VALUE),  [EOL]                  Float.valueOf(Float.MAX_VALUE), Float.valueOf(9999999)})) [EOL]          ); [EOL]  [EOL]          try { [EOL]              ArrayUtils.toPrimitive(new Float[] {Float.valueOf(Float.MIN_VALUE), null}); [EOL]              fail(); [EOL]          } catch (final NullPointerException ex) {} [EOL]      } [EOL]  [EOL]
@Test [EOL]      public void testToPrimitive_float() { [EOL]          final Float[] b = null; [EOL]          assertEquals(null, ArrayUtils.toPrimitive(b)); [EOL]           [EOL]          assertSame(ArrayUtils.EMPTY_FLOAT_ARRAY,  [EOL]             ArrayUtils.toPrimitive(new Float[0])); [EOL]           [EOL]          assertTrue(Arrays.equals( [EOL]              new float[] {Float.MIN_VALUE, Float.MAX_VALUE, 9999999}, [EOL]              ArrayUtils.toPrimitive(new Float[] {Float.valueOf(Float.MIN_VALUE),  [EOL]                  Float.valueOf(Float.MAX_VALUE), Float.valueOf(9999999)})) [EOL]          ); [EOL]  [EOL]          try { [EOL]              ArrayUtils.toPrimitive(new Float[] {Float.valueOf(Float.MIN_VALUE), null}); [EOL]              fail(); [EOL]          } catch (final NullPointerException ex) {} [EOL]      } [EOL]  [EOL]
@Test [EOL]      public void testToPrimitive_float() { [EOL]          final Float[] b = null; [EOL]          assertEquals(null, ArrayUtils.toPrimitive(b)); [EOL]           [EOL]          assertSame(ArrayUtils.EMPTY_FLOAT_ARRAY,  [EOL]             ArrayUtils.toPrimitive(new Float[0])); [EOL]           [EOL]          assertTrue(Arrays.equals( [EOL]              new float[] {Float.MIN_VALUE, Float.MAX_VALUE, 9999999}, [EOL]              ArrayUtils.toPrimitive(new Float[] {Float.valueOf(Float.MIN_VALUE),  [EOL]                  Float.valueOf(Float.MAX_VALUE), Float.valueOf(9999999)})) [EOL]          ); [EOL]  [EOL]          try { [EOL]              ArrayUtils.toPrimitive(new Float[] {Float.valueOf(Float.MIN_VALUE), null}); [EOL]              fail(); [EOL]          } catch (final NullPointerException ex) {} [EOL]      } [EOL]  [EOL]
@Test [EOL]      public void testToPrimitive_float() { [EOL]          final Float[] b = null; [EOL]          assertEquals(null, ArrayUtils.toPrimitive(b)); [EOL]           [EOL]          assertSame(ArrayUtils.EMPTY_FLOAT_ARRAY,  [EOL]             ArrayUtils.toPrimitive(new Float[0])); [EOL]           [EOL]          assertTrue(Arrays.equals( [EOL]              new float[] {Float.MIN_VALUE, Float.MAX_VALUE, 9999999}, [EOL]              ArrayUtils.toPrimitive(new Float[] {Float.valueOf(Float.MIN_VALUE),  [EOL]                  Float.valueOf(Float.MAX_VALUE), Float.valueOf(9999999)})) [EOL]          ); [EOL]  [EOL]          try { [EOL]              ArrayUtils.toPrimitive(new Float[] {Float.valueOf(Float.MIN_VALUE), null}); [EOL]              fail(); [EOL]          } catch (final NullPointerException ex) {} [EOL]      } [EOL]  [EOL]
@Test [EOL]      public void testToPrimitive_float() { [EOL]          final Float[] b = null; [EOL]          assertEquals(null, ArrayUtils.toPrimitive(b)); [EOL]           [EOL]          assertSame(ArrayUtils.EMPTY_FLOAT_ARRAY,  [EOL]             ArrayUtils.toPrimitive(new Float[0])); [EOL]           [EOL]          assertTrue(Arrays.equals( [EOL]              new float[] {Float.MIN_VALUE, Float.MAX_VALUE, 9999999}, [EOL]              ArrayUtils.toPrimitive(new Float[] {Float.valueOf(Float.MIN_VALUE),  [EOL]                  Float.valueOf(Float.MAX_VALUE), Float.valueOf(9999999)})) [EOL]          ); [EOL]  [EOL]          try { [EOL]              ArrayUtils.toPrimitive(new Float[] {Float.valueOf(Float.MIN_VALUE), null}); [EOL]              fail(); [EOL]          } catch (final NullPointerException ex) {} [EOL]      } [EOL]  [EOL]
@Test [EOL]      public void testToPrimitive_float_float() { [EOL]          final Float[] l = null; [EOL]          assertEquals(null, ArrayUtils.toPrimitive(l, Float.MIN_VALUE)); [EOL]           [EOL]          assertSame(ArrayUtils.EMPTY_FLOAT_ARRAY,  [EOL]          ArrayUtils.toPrimitive(new Float[0], 1)); [EOL]           [EOL]          assertTrue(Arrays.equals( [EOL]              new float[] {Float.MIN_VALUE, Float.MAX_VALUE, 9999999}, [EOL]              ArrayUtils.toPrimitive(new Float[] {Float.valueOf(Float.MIN_VALUE),  [EOL]                  Float.valueOf(Float.MAX_VALUE), Float.valueOf(9999999)},1))); [EOL]           [EOL]          assertTrue(Arrays.equals( [EOL]              new float[] {Float.MIN_VALUE, Float.MAX_VALUE, 9999999}, [EOL]              ArrayUtils.toPrimitive(new Float[] {Float.valueOf(Float.MIN_VALUE),  [EOL]                  null, Float.valueOf(9999999)}, Float.MAX_VALUE)) [EOL]          ); [EOL]      } [EOL]       [EOL]
@Test [EOL]      public void testToPrimitive_float_float() { [EOL]          final Float[] l = null; [EOL]          assertEquals(null, ArrayUtils.toPrimitive(l, Float.MIN_VALUE)); [EOL]           [EOL]          assertSame(ArrayUtils.EMPTY_FLOAT_ARRAY,  [EOL]          ArrayUtils.toPrimitive(new Float[0], 1)); [EOL]           [EOL]          assertTrue(Arrays.equals( [EOL]              new float[] {Float.MIN_VALUE, Float.MAX_VALUE, 9999999}, [EOL]              ArrayUtils.toPrimitive(new Float[] {Float.valueOf(Float.MIN_VALUE),  [EOL]                  Float.valueOf(Float.MAX_VALUE), Float.valueOf(9999999)},1))); [EOL]           [EOL]          assertTrue(Arrays.equals( [EOL]              new float[] {Float.MIN_VALUE, Float.MAX_VALUE, 9999999}, [EOL]              ArrayUtils.toPrimitive(new Float[] {Float.valueOf(Float.MIN_VALUE),  [EOL]                  null, Float.valueOf(9999999)}, Float.MAX_VALUE)) [EOL]          ); [EOL]      } [EOL]       [EOL]
@Test [EOL]     public void testToObject_float() { [EOL]         final float[] b = null; [EOL]         assertArrayEquals(null, ArrayUtils.toObject(b)); [EOL]      [EOL]         assertSame( [EOL]             ArrayUtils.EMPTY_FLOAT_OBJECT_ARRAY, [EOL]             ArrayUtils.toObject(new float[0])); [EOL]      [EOL]         assertTrue( [EOL]             Arrays.equals( [EOL]                 new Float[] { [EOL]                     Float.valueOf(Float.MIN_VALUE), [EOL]                     Float.valueOf(Float.MAX_VALUE), [EOL]                     Float.valueOf(9999999)}, [EOL]             ArrayUtils.toObject( [EOL]                 new float[] { Float.MIN_VALUE, Float.MAX_VALUE, 9999999 }))); [EOL]     } [EOL]  [EOL]     //  testToPrimitive/Object for double [EOL]     //  ----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testToObject_float() { [EOL]         final float[] b = null; [EOL]         assertArrayEquals(null, ArrayUtils.toObject(b)); [EOL]      [EOL]         assertSame( [EOL]             ArrayUtils.EMPTY_FLOAT_OBJECT_ARRAY, [EOL]             ArrayUtils.toObject(new float[0])); [EOL]      [EOL]         assertTrue( [EOL]             Arrays.equals( [EOL]                 new Float[] { [EOL]                     Float.valueOf(Float.MIN_VALUE), [EOL]                     Float.valueOf(Float.MAX_VALUE), [EOL]                     Float.valueOf(9999999)}, [EOL]             ArrayUtils.toObject( [EOL]                 new float[] { Float.MIN_VALUE, Float.MAX_VALUE, 9999999 }))); [EOL]     } [EOL]  [EOL]     //  testToPrimitive/Object for double [EOL]     //  ----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testToPrimitive_boolean() { [EOL]         final Boolean[] b = null; [EOL]         assertEquals(null, ArrayUtils.toPrimitive(b)); [EOL]         assertSame(ArrayUtils.EMPTY_BOOLEAN_ARRAY, ArrayUtils.toPrimitive(new Boolean[0])); [EOL]         assertTrue(Arrays.equals( [EOL]             new boolean[] {true, false, true}, [EOL]             ArrayUtils.toPrimitive(new Boolean[] {Boolean.TRUE, Boolean.FALSE, Boolean.TRUE})) [EOL]         ); [EOL]  [EOL]         try { [EOL]             ArrayUtils.toPrimitive(new Boolean[] {Boolean.TRUE, null}); [EOL]             fail(); [EOL]         } catch (final NullPointerException ex) {} [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testToPrimitive_boolean_boolean() { [EOL]         assertEquals(null, ArrayUtils.toPrimitive(null, false)); [EOL]         assertSame(ArrayUtils.EMPTY_BOOLEAN_ARRAY, ArrayUtils.toPrimitive(new Boolean[0], false)); [EOL]         assertTrue(Arrays.equals( [EOL]             new boolean[] {true, false, true}, [EOL]             ArrayUtils.toPrimitive(new Boolean[] {Boolean.TRUE, Boolean.FALSE, Boolean.TRUE}, false)) [EOL]         ); [EOL]         assertTrue(Arrays.equals( [EOL]             new boolean[] {true, false, false}, [EOL]             ArrayUtils.toPrimitive(new Boolean[] {Boolean.TRUE, null, Boolean.FALSE}, false)) [EOL]         ); [EOL]         assertTrue(Arrays.equals( [EOL]             new boolean[] {true, true, false}, [EOL]             ArrayUtils.toPrimitive(new Boolean[] {Boolean.TRUE, null, Boolean.FALSE}, true)) [EOL]         ); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testToPrimitive_boolean_boolean() { [EOL]         assertEquals(null, ArrayUtils.toPrimitive(null, false)); [EOL]         assertSame(ArrayUtils.EMPTY_BOOLEAN_ARRAY, ArrayUtils.toPrimitive(new Boolean[0], false)); [EOL]         assertTrue(Arrays.equals( [EOL]             new boolean[] {true, false, true}, [EOL]             ArrayUtils.toPrimitive(new Boolean[] {Boolean.TRUE, Boolean.FALSE, Boolean.TRUE}, false)) [EOL]         ); [EOL]         assertTrue(Arrays.equals( [EOL]             new boolean[] {true, false, false}, [EOL]             ArrayUtils.toPrimitive(new Boolean[] {Boolean.TRUE, null, Boolean.FALSE}, false)) [EOL]         ); [EOL]         assertTrue(Arrays.equals( [EOL]             new boolean[] {true, true, false}, [EOL]             ArrayUtils.toPrimitive(new Boolean[] {Boolean.TRUE, null, Boolean.FALSE}, true)) [EOL]         ); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testToObject_boolean() { [EOL]         final boolean[] b = null; [EOL]         assertArrayEquals(null, ArrayUtils.toObject(b)); [EOL]         assertSame(ArrayUtils.EMPTY_BOOLEAN_OBJECT_ARRAY, ArrayUtils.toObject(new boolean[0])); [EOL]         assertTrue(Arrays.equals( [EOL]             new Boolean[] {Boolean.TRUE, Boolean.FALSE, Boolean.TRUE}, [EOL]             ArrayUtils.toObject(new boolean[] {true, false, true})) [EOL]         ); [EOL]     } [EOL]  [EOL]     // testToPrimitive/Object for byte [EOL]     //  ----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAddObjectArrayToObjectArray() { [EOL]         assertNull(ArrayUtils.addAll((Object[]) null, (Object[]) null)); [EOL]         Object[] newArray; [EOL]         final String[] stringArray1 = new String[]{"a", "b", "c"}; [EOL]         final String[] stringArray2 = new String[]{"1", "2", "3"}; [EOL]         newArray = ArrayUtils.addAll(stringArray1, (String[]) null); [EOL]         assertNotSame(stringArray1, newArray); [EOL]         assertTrue(Arrays.equals(stringArray1, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{"a", "b", "c"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(null, stringArray2); [EOL]         assertNotSame(stringArray2, newArray); [EOL]         assertTrue(Arrays.equals(stringArray2, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{"1", "2", "3"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(stringArray1, stringArray2); [EOL]         assertTrue(Arrays.equals(new String[]{"a", "b", "c", "1", "2", "3"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(ArrayUtils.EMPTY_STRING_ARRAY, (String[]) null); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_STRING_ARRAY, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(null, ArrayUtils.EMPTY_STRING_ARRAY); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_STRING_ARRAY, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(ArrayUtils.EMPTY_STRING_ARRAY, ArrayUtils.EMPTY_STRING_ARRAY); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_STRING_ARRAY, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         final String[] stringArrayNull = new String []{null}; [EOL]         newArray = ArrayUtils.addAll(stringArrayNull, stringArrayNull); [EOL]         assertTrue(Arrays.equals(new String[]{null, null}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]  [EOL]         // boolean [EOL]         assertTrue( Arrays.equals( new boolean[] { true, false, false, true }, [EOL]             ArrayUtils.addAll( new boolean[] { true, false }, new boolean[] { false, true } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new boolean[] { false, true }, [EOL]             ArrayUtils.addAll( null, new boolean[] { false, true } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new boolean[] { true, false }, [EOL]             ArrayUtils.addAll( new boolean[] { true, false }, null ) ) ); [EOL]  [EOL]         // char [EOL]         assertTrue( Arrays.equals( new char[] { 'a', 'b', 'c', 'd' }, [EOL]             ArrayUtils.addAll( new char[] { 'a', 'b' }, new char[] { 'c', 'd' } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new char[] { 'c', 'd' }, [EOL]             ArrayUtils.addAll( null, new char[] { 'c', 'd' } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new char[] { 'a', 'b' }, [EOL]             ArrayUtils.addAll( new char[] { 'a', 'b' }, null ) ) ); [EOL]  [EOL]         // byte [EOL]         assertTrue( Arrays.equals( new byte[] { (byte) 0, (byte) 1, (byte) 2, (byte) 3 }, [EOL]             ArrayUtils.addAll( new byte[] { (byte) 0, (byte) 1 }, new byte[] { (byte) 2, (byte) 3 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new byte[] { (byte) 2, (byte) 3 }, [EOL]             ArrayUtils.addAll( null, new byte[] { (byte) 2, (byte) 3 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new byte[] { (byte) 0, (byte) 1 }, [EOL]             ArrayUtils.addAll( new byte[] { (byte) 0, (byte) 1 }, null ) ) ); [EOL]  [EOL]         // short [EOL]         assertTrue( Arrays.equals( new short[] { (short) 10, (short) 20, (short) 30, (short) 40 }, [EOL]             ArrayUtils.addAll( new short[] { (short) 10, (short) 20 }, new short[] { (short) 30, (short) 40 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new short[] { (short) 30, (short) 40 }, [EOL]             ArrayUtils.addAll( null, new short[] { (short) 30, (short) 40 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new short[] { (short) 10, (short) 20 }, [EOL]             ArrayUtils.addAll( new short[] { (short) 10, (short) 20 }, null ) ) ); [EOL]  [EOL]         // int [EOL]         assertTrue( Arrays.equals( new int[] { 1, 1000, -1000, -1 }, [EOL]             ArrayUtils.addAll( new int[] { 1, 1000 }, new int[] { -1000, -1 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new int[] { -1000, -1 }, [EOL]             ArrayUtils.addAll( null, new int[] { -1000, -1 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new int[] { 1, 1000 }, [EOL]             ArrayUtils.addAll( new int[] { 1, 1000 }, null ) ) ); [EOL]  [EOL]         // long [EOL]         assertTrue( Arrays.equals( new long[] { 1L, -1L, 1000L, -1000L }, [EOL]             ArrayUtils.addAll( new long[] { 1L, -1L }, new long[] { 1000L, -1000L } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new long[] { 1000L, -1000L }, [EOL]             ArrayUtils.addAll( null, new long[] { 1000L, -1000L } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new long[] { 1L, -1L }, [EOL]             ArrayUtils.addAll( new long[] { 1L, -1L }, null ) ) ); [EOL]  [EOL]         // float [EOL]         assertTrue( Arrays.equals( new float[] { 10.5f, 10.1f, 1.6f, 0.01f }, [EOL]             ArrayUtils.addAll( new float[] { 10.5f, 10.1f }, new float[] { 1.6f, 0.01f } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new float[] { 1.6f, 0.01f }, [EOL]             ArrayUtils.addAll( null, new float[] { 1.6f, 0.01f } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new float[] { 10.5f, 10.1f }, [EOL]             ArrayUtils.addAll( new float[] { 10.5f, 10.1f }, null ) ) ); [EOL]  [EOL]         // double [EOL]         assertTrue( Arrays.equals( new double[] { Math.PI, -Math.PI, 0, 9.99 }, [EOL]             ArrayUtils.addAll( new double[] { Math.PI, -Math.PI }, new double[] { 0, 9.99 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new double[] { 0, 9.99 }, [EOL]             ArrayUtils.addAll( null, new double[] { 0, 9.99 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new double[] { Math.PI, -Math.PI }, [EOL]             ArrayUtils.addAll( new double[] { Math.PI, -Math.PI }, null ) ) ); [EOL]  [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testJira567(){ [EOL]         Number[] n; [EOL]         // Valid array construction [EOL]         n = ArrayUtils.addAll(new Number[]{Integer.valueOf(1)}, new Long[]{Long.valueOf(2)}); [EOL]         assertEquals(2,n.length); [EOL]         assertEquals(Number.class,n.getClass().getComponentType()); [EOL]         try { [EOL]             // Invalid - can't store Long in Integer array [EOL]                n = ArrayUtils.addAll(new Integer[]{Integer.valueOf(1)}, new Long[]{Long.valueOf(2)}); [EOL]                fail("Should have generated IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException expected) { [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testJira567(){ [EOL]         Number[] n; [EOL]         // Valid array construction [EOL]         n = ArrayUtils.addAll(new Number[]{Integer.valueOf(1)}, new Long[]{Long.valueOf(2)}); [EOL]         assertEquals(2,n.length); [EOL]         assertEquals(Number.class,n.getClass().getComponentType()); [EOL]         try { [EOL]             // Invalid - can't store Long in Integer array [EOL]                n = ArrayUtils.addAll(new Integer[]{Integer.valueOf(1)}, new Long[]{Long.valueOf(2)}); [EOL]                fail("Should have generated IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException expected) { [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testJira567(){ [EOL]         Number[] n; [EOL]         // Valid array construction [EOL]         n = ArrayUtils.addAll(new Number[]{Integer.valueOf(1)}, new Long[]{Long.valueOf(2)}); [EOL]         assertEquals(2,n.length); [EOL]         assertEquals(Number.class,n.getClass().getComponentType()); [EOL]         try { [EOL]             // Invalid - can't store Long in Integer array [EOL]                n = ArrayUtils.addAll(new Integer[]{Integer.valueOf(1)}, new Long[]{Long.valueOf(2)}); [EOL]                fail("Should have generated IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException expected) { [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testAddObjectArrayToObjectArray() { [EOL]         assertNull(ArrayUtils.addAll((Object[]) null, (Object[]) null)); [EOL]         Object[] newArray; [EOL]         final String[] stringArray1 = new String[]{"a", "b", "c"}; [EOL]         final String[] stringArray2 = new String[]{"1", "2", "3"}; [EOL]         newArray = ArrayUtils.addAll(stringArray1, (String[]) null); [EOL]         assertNotSame(stringArray1, newArray); [EOL]         assertTrue(Arrays.equals(stringArray1, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{"a", "b", "c"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(null, stringArray2); [EOL]         assertNotSame(stringArray2, newArray); [EOL]         assertTrue(Arrays.equals(stringArray2, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{"1", "2", "3"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(stringArray1, stringArray2); [EOL]         assertTrue(Arrays.equals(new String[]{"a", "b", "c", "1", "2", "3"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(ArrayUtils.EMPTY_STRING_ARRAY, (String[]) null); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_STRING_ARRAY, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(null, ArrayUtils.EMPTY_STRING_ARRAY); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_STRING_ARRAY, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(ArrayUtils.EMPTY_STRING_ARRAY, ArrayUtils.EMPTY_STRING_ARRAY); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_STRING_ARRAY, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         final String[] stringArrayNull = new String []{null}; [EOL]         newArray = ArrayUtils.addAll(stringArrayNull, stringArrayNull); [EOL]         assertTrue(Arrays.equals(new String[]{null, null}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]  [EOL]         // boolean [EOL]         assertTrue( Arrays.equals( new boolean[] { true, false, false, true }, [EOL]             ArrayUtils.addAll( new boolean[] { true, false }, new boolean[] { false, true } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new boolean[] { false, true }, [EOL]             ArrayUtils.addAll( null, new boolean[] { false, true } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new boolean[] { true, false }, [EOL]             ArrayUtils.addAll( new boolean[] { true, false }, null ) ) ); [EOL]  [EOL]         // char [EOL]         assertTrue( Arrays.equals( new char[] { 'a', 'b', 'c', 'd' }, [EOL]             ArrayUtils.addAll( new char[] { 'a', 'b' }, new char[] { 'c', 'd' } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new char[] { 'c', 'd' }, [EOL]             ArrayUtils.addAll( null, new char[] { 'c', 'd' } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new char[] { 'a', 'b' }, [EOL]             ArrayUtils.addAll( new char[] { 'a', 'b' }, null ) ) ); [EOL]  [EOL]         // byte [EOL]         assertTrue( Arrays.equals( new byte[] { (byte) 0, (byte) 1, (byte) 2, (byte) 3 }, [EOL]             ArrayUtils.addAll( new byte[] { (byte) 0, (byte) 1 }, new byte[] { (byte) 2, (byte) 3 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new byte[] { (byte) 2, (byte) 3 }, [EOL]             ArrayUtils.addAll( null, new byte[] { (byte) 2, (byte) 3 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new byte[] { (byte) 0, (byte) 1 }, [EOL]             ArrayUtils.addAll( new byte[] { (byte) 0, (byte) 1 }, null ) ) ); [EOL]  [EOL]         // short [EOL]         assertTrue( Arrays.equals( new short[] { (short) 10, (short) 20, (short) 30, (short) 40 }, [EOL]             ArrayUtils.addAll( new short[] { (short) 10, (short) 20 }, new short[] { (short) 30, (short) 40 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new short[] { (short) 30, (short) 40 }, [EOL]             ArrayUtils.addAll( null, new short[] { (short) 30, (short) 40 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new short[] { (short) 10, (short) 20 }, [EOL]             ArrayUtils.addAll( new short[] { (short) 10, (short) 20 }, null ) ) ); [EOL]  [EOL]         // int [EOL]         assertTrue( Arrays.equals( new int[] { 1, 1000, -1000, -1 }, [EOL]             ArrayUtils.addAll( new int[] { 1, 1000 }, new int[] { -1000, -1 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new int[] { -1000, -1 }, [EOL]             ArrayUtils.addAll( null, new int[] { -1000, -1 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new int[] { 1, 1000 }, [EOL]             ArrayUtils.addAll( new int[] { 1, 1000 }, null ) ) ); [EOL]  [EOL]         // long [EOL]         assertTrue( Arrays.equals( new long[] { 1L, -1L, 1000L, -1000L }, [EOL]             ArrayUtils.addAll( new long[] { 1L, -1L }, new long[] { 1000L, -1000L } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new long[] { 1000L, -1000L }, [EOL]             ArrayUtils.addAll( null, new long[] { 1000L, -1000L } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new long[] { 1L, -1L }, [EOL]             ArrayUtils.addAll( new long[] { 1L, -1L }, null ) ) ); [EOL]  [EOL]         // float [EOL]         assertTrue( Arrays.equals( new float[] { 10.5f, 10.1f, 1.6f, 0.01f }, [EOL]             ArrayUtils.addAll( new float[] { 10.5f, 10.1f }, new float[] { 1.6f, 0.01f } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new float[] { 1.6f, 0.01f }, [EOL]             ArrayUtils.addAll( null, new float[] { 1.6f, 0.01f } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new float[] { 10.5f, 10.1f }, [EOL]             ArrayUtils.addAll( new float[] { 10.5f, 10.1f }, null ) ) ); [EOL]  [EOL]         // double [EOL]         assertTrue( Arrays.equals( new double[] { Math.PI, -Math.PI, 0, 9.99 }, [EOL]             ArrayUtils.addAll( new double[] { Math.PI, -Math.PI }, new double[] { 0, 9.99 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new double[] { 0, 9.99 }, [EOL]             ArrayUtils.addAll( null, new double[] { 0, 9.99 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new double[] { Math.PI, -Math.PI }, [EOL]             ArrayUtils.addAll( new double[] { Math.PI, -Math.PI }, null ) ) ); [EOL]  [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testAddObjectArrayToObjectArray() { [EOL]         assertNull(ArrayUtils.addAll((Object[]) null, (Object[]) null)); [EOL]         Object[] newArray; [EOL]         final String[] stringArray1 = new String[]{"a", "b", "c"}; [EOL]         final String[] stringArray2 = new String[]{"1", "2", "3"}; [EOL]         newArray = ArrayUtils.addAll(stringArray1, (String[]) null); [EOL]         assertNotSame(stringArray1, newArray); [EOL]         assertTrue(Arrays.equals(stringArray1, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{"a", "b", "c"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(null, stringArray2); [EOL]         assertNotSame(stringArray2, newArray); [EOL]         assertTrue(Arrays.equals(stringArray2, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{"1", "2", "3"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(stringArray1, stringArray2); [EOL]         assertTrue(Arrays.equals(new String[]{"a", "b", "c", "1", "2", "3"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(ArrayUtils.EMPTY_STRING_ARRAY, (String[]) null); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_STRING_ARRAY, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(null, ArrayUtils.EMPTY_STRING_ARRAY); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_STRING_ARRAY, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(ArrayUtils.EMPTY_STRING_ARRAY, ArrayUtils.EMPTY_STRING_ARRAY); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_STRING_ARRAY, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         final String[] stringArrayNull = new String []{null}; [EOL]         newArray = ArrayUtils.addAll(stringArrayNull, stringArrayNull); [EOL]         assertTrue(Arrays.equals(new String[]{null, null}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]  [EOL]         // boolean [EOL]         assertTrue( Arrays.equals( new boolean[] { true, false, false, true }, [EOL]             ArrayUtils.addAll( new boolean[] { true, false }, new boolean[] { false, true } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new boolean[] { false, true }, [EOL]             ArrayUtils.addAll( null, new boolean[] { false, true } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new boolean[] { true, false }, [EOL]             ArrayUtils.addAll( new boolean[] { true, false }, null ) ) ); [EOL]  [EOL]         // char [EOL]         assertTrue( Arrays.equals( new char[] { 'a', 'b', 'c', 'd' }, [EOL]             ArrayUtils.addAll( new char[] { 'a', 'b' }, new char[] { 'c', 'd' } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new char[] { 'c', 'd' }, [EOL]             ArrayUtils.addAll( null, new char[] { 'c', 'd' } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new char[] { 'a', 'b' }, [EOL]             ArrayUtils.addAll( new char[] { 'a', 'b' }, null ) ) ); [EOL]  [EOL]         // byte [EOL]         assertTrue( Arrays.equals( new byte[] { (byte) 0, (byte) 1, (byte) 2, (byte) 3 }, [EOL]             ArrayUtils.addAll( new byte[] { (byte) 0, (byte) 1 }, new byte[] { (byte) 2, (byte) 3 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new byte[] { (byte) 2, (byte) 3 }, [EOL]             ArrayUtils.addAll( null, new byte[] { (byte) 2, (byte) 3 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new byte[] { (byte) 0, (byte) 1 }, [EOL]             ArrayUtils.addAll( new byte[] { (byte) 0, (byte) 1 }, null ) ) ); [EOL]  [EOL]         // short [EOL]         assertTrue( Arrays.equals( new short[] { (short) 10, (short) 20, (short) 30, (short) 40 }, [EOL]             ArrayUtils.addAll( new short[] { (short) 10, (short) 20 }, new short[] { (short) 30, (short) 40 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new short[] { (short) 30, (short) 40 }, [EOL]             ArrayUtils.addAll( null, new short[] { (short) 30, (short) 40 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new short[] { (short) 10, (short) 20 }, [EOL]             ArrayUtils.addAll( new short[] { (short) 10, (short) 20 }, null ) ) ); [EOL]  [EOL]         // int [EOL]         assertTrue( Arrays.equals( new int[] { 1, 1000, -1000, -1 }, [EOL]             ArrayUtils.addAll( new int[] { 1, 1000 }, new int[] { -1000, -1 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new int[] { -1000, -1 }, [EOL]             ArrayUtils.addAll( null, new int[] { -1000, -1 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new int[] { 1, 1000 }, [EOL]             ArrayUtils.addAll( new int[] { 1, 1000 }, null ) ) ); [EOL]  [EOL]         // long [EOL]         assertTrue( Arrays.equals( new long[] { 1L, -1L, 1000L, -1000L }, [EOL]             ArrayUtils.addAll( new long[] { 1L, -1L }, new long[] { 1000L, -1000L } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new long[] { 1000L, -1000L }, [EOL]             ArrayUtils.addAll( null, new long[] { 1000L, -1000L } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new long[] { 1L, -1L }, [EOL]             ArrayUtils.addAll( new long[] { 1L, -1L }, null ) ) ); [EOL]  [EOL]         // float [EOL]         assertTrue( Arrays.equals( new float[] { 10.5f, 10.1f, 1.6f, 0.01f }, [EOL]             ArrayUtils.addAll( new float[] { 10.5f, 10.1f }, new float[] { 1.6f, 0.01f } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new float[] { 1.6f, 0.01f }, [EOL]             ArrayUtils.addAll( null, new float[] { 1.6f, 0.01f } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new float[] { 10.5f, 10.1f }, [EOL]             ArrayUtils.addAll( new float[] { 10.5f, 10.1f }, null ) ) ); [EOL]  [EOL]         // double [EOL]         assertTrue( Arrays.equals( new double[] { Math.PI, -Math.PI, 0, 9.99 }, [EOL]             ArrayUtils.addAll( new double[] { Math.PI, -Math.PI }, new double[] { 0, 9.99 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new double[] { 0, 9.99 }, [EOL]             ArrayUtils.addAll( null, new double[] { 0, 9.99 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new double[] { Math.PI, -Math.PI }, [EOL]             ArrayUtils.addAll( new double[] { Math.PI, -Math.PI }, null ) ) ); [EOL]  [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testAddObjectArrayToObjectArray() { [EOL]         assertNull(ArrayUtils.addAll((Object[]) null, (Object[]) null)); [EOL]         Object[] newArray; [EOL]         final String[] stringArray1 = new String[]{"a", "b", "c"}; [EOL]         final String[] stringArray2 = new String[]{"1", "2", "3"}; [EOL]         newArray = ArrayUtils.addAll(stringArray1, (String[]) null); [EOL]         assertNotSame(stringArray1, newArray); [EOL]         assertTrue(Arrays.equals(stringArray1, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{"a", "b", "c"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(null, stringArray2); [EOL]         assertNotSame(stringArray2, newArray); [EOL]         assertTrue(Arrays.equals(stringArray2, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{"1", "2", "3"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(stringArray1, stringArray2); [EOL]         assertTrue(Arrays.equals(new String[]{"a", "b", "c", "1", "2", "3"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(ArrayUtils.EMPTY_STRING_ARRAY, (String[]) null); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_STRING_ARRAY, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(null, ArrayUtils.EMPTY_STRING_ARRAY); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_STRING_ARRAY, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(ArrayUtils.EMPTY_STRING_ARRAY, ArrayUtils.EMPTY_STRING_ARRAY); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_STRING_ARRAY, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         final String[] stringArrayNull = new String []{null}; [EOL]         newArray = ArrayUtils.addAll(stringArrayNull, stringArrayNull); [EOL]         assertTrue(Arrays.equals(new String[]{null, null}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]  [EOL]         // boolean [EOL]         assertTrue( Arrays.equals( new boolean[] { true, false, false, true }, [EOL]             ArrayUtils.addAll( new boolean[] { true, false }, new boolean[] { false, true } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new boolean[] { false, true }, [EOL]             ArrayUtils.addAll( null, new boolean[] { false, true } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new boolean[] { true, false }, [EOL]             ArrayUtils.addAll( new boolean[] { true, false }, null ) ) ); [EOL]  [EOL]         // char [EOL]         assertTrue( Arrays.equals( new char[] { 'a', 'b', 'c', 'd' }, [EOL]             ArrayUtils.addAll( new char[] { 'a', 'b' }, new char[] { 'c', 'd' } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new char[] { 'c', 'd' }, [EOL]             ArrayUtils.addAll( null, new char[] { 'c', 'd' } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new char[] { 'a', 'b' }, [EOL]             ArrayUtils.addAll( new char[] { 'a', 'b' }, null ) ) ); [EOL]  [EOL]         // byte [EOL]         assertTrue( Arrays.equals( new byte[] { (byte) 0, (byte) 1, (byte) 2, (byte) 3 }, [EOL]             ArrayUtils.addAll( new byte[] { (byte) 0, (byte) 1 }, new byte[] { (byte) 2, (byte) 3 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new byte[] { (byte) 2, (byte) 3 }, [EOL]             ArrayUtils.addAll( null, new byte[] { (byte) 2, (byte) 3 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new byte[] { (byte) 0, (byte) 1 }, [EOL]             ArrayUtils.addAll( new byte[] { (byte) 0, (byte) 1 }, null ) ) ); [EOL]  [EOL]         // short [EOL]         assertTrue( Arrays.equals( new short[] { (short) 10, (short) 20, (short) 30, (short) 40 }, [EOL]             ArrayUtils.addAll( new short[] { (short) 10, (short) 20 }, new short[] { (short) 30, (short) 40 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new short[] { (short) 30, (short) 40 }, [EOL]             ArrayUtils.addAll( null, new short[] { (short) 30, (short) 40 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new short[] { (short) 10, (short) 20 }, [EOL]             ArrayUtils.addAll( new short[] { (short) 10, (short) 20 }, null ) ) ); [EOL]  [EOL]         // int [EOL]         assertTrue( Arrays.equals( new int[] { 1, 1000, -1000, -1 }, [EOL]             ArrayUtils.addAll( new int[] { 1, 1000 }, new int[] { -1000, -1 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new int[] { -1000, -1 }, [EOL]             ArrayUtils.addAll( null, new int[] { -1000, -1 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new int[] { 1, 1000 }, [EOL]             ArrayUtils.addAll( new int[] { 1, 1000 }, null ) ) ); [EOL]  [EOL]         // long [EOL]         assertTrue( Arrays.equals( new long[] { 1L, -1L, 1000L, -1000L }, [EOL]             ArrayUtils.addAll( new long[] { 1L, -1L }, new long[] { 1000L, -1000L } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new long[] { 1000L, -1000L }, [EOL]             ArrayUtils.addAll( null, new long[] { 1000L, -1000L } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new long[] { 1L, -1L }, [EOL]             ArrayUtils.addAll( new long[] { 1L, -1L }, null ) ) ); [EOL]  [EOL]         // float [EOL]         assertTrue( Arrays.equals( new float[] { 10.5f, 10.1f, 1.6f, 0.01f }, [EOL]             ArrayUtils.addAll( new float[] { 10.5f, 10.1f }, new float[] { 1.6f, 0.01f } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new float[] { 1.6f, 0.01f }, [EOL]             ArrayUtils.addAll( null, new float[] { 1.6f, 0.01f } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new float[] { 10.5f, 10.1f }, [EOL]             ArrayUtils.addAll( new float[] { 10.5f, 10.1f }, null ) ) ); [EOL]  [EOL]         // double [EOL]         assertTrue( Arrays.equals( new double[] { Math.PI, -Math.PI, 0, 9.99 }, [EOL]             ArrayUtils.addAll( new double[] { Math.PI, -Math.PI }, new double[] { 0, 9.99 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new double[] { 0, 9.99 }, [EOL]             ArrayUtils.addAll( null, new double[] { 0, 9.99 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new double[] { Math.PI, -Math.PI }, [EOL]             ArrayUtils.addAll( new double[] { Math.PI, -Math.PI }, null ) ) ); [EOL]  [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testAddObjectArrayToObjectArray() { [EOL]         assertNull(ArrayUtils.addAll((Object[]) null, (Object[]) null)); [EOL]         Object[] newArray; [EOL]         final String[] stringArray1 = new String[]{"a", "b", "c"}; [EOL]         final String[] stringArray2 = new String[]{"1", "2", "3"}; [EOL]         newArray = ArrayUtils.addAll(stringArray1, (String[]) null); [EOL]         assertNotSame(stringArray1, newArray); [EOL]         assertTrue(Arrays.equals(stringArray1, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{"a", "b", "c"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(null, stringArray2); [EOL]         assertNotSame(stringArray2, newArray); [EOL]         assertTrue(Arrays.equals(stringArray2, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{"1", "2", "3"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(stringArray1, stringArray2); [EOL]         assertTrue(Arrays.equals(new String[]{"a", "b", "c", "1", "2", "3"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(ArrayUtils.EMPTY_STRING_ARRAY, (String[]) null); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_STRING_ARRAY, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(null, ArrayUtils.EMPTY_STRING_ARRAY); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_STRING_ARRAY, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(ArrayUtils.EMPTY_STRING_ARRAY, ArrayUtils.EMPTY_STRING_ARRAY); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_STRING_ARRAY, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         final String[] stringArrayNull = new String []{null}; [EOL]         newArray = ArrayUtils.addAll(stringArrayNull, stringArrayNull); [EOL]         assertTrue(Arrays.equals(new String[]{null, null}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]  [EOL]         // boolean [EOL]         assertTrue( Arrays.equals( new boolean[] { true, false, false, true }, [EOL]             ArrayUtils.addAll( new boolean[] { true, false }, new boolean[] { false, true } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new boolean[] { false, true }, [EOL]             ArrayUtils.addAll( null, new boolean[] { false, true } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new boolean[] { true, false }, [EOL]             ArrayUtils.addAll( new boolean[] { true, false }, null ) ) ); [EOL]  [EOL]         // char [EOL]         assertTrue( Arrays.equals( new char[] { 'a', 'b', 'c', 'd' }, [EOL]             ArrayUtils.addAll( new char[] { 'a', 'b' }, new char[] { 'c', 'd' } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new char[] { 'c', 'd' }, [EOL]             ArrayUtils.addAll( null, new char[] { 'c', 'd' } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new char[] { 'a', 'b' }, [EOL]             ArrayUtils.addAll( new char[] { 'a', 'b' }, null ) ) ); [EOL]  [EOL]         // byte [EOL]         assertTrue( Arrays.equals( new byte[] { (byte) 0, (byte) 1, (byte) 2, (byte) 3 }, [EOL]             ArrayUtils.addAll( new byte[] { (byte) 0, (byte) 1 }, new byte[] { (byte) 2, (byte) 3 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new byte[] { (byte) 2, (byte) 3 }, [EOL]             ArrayUtils.addAll( null, new byte[] { (byte) 2, (byte) 3 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new byte[] { (byte) 0, (byte) 1 }, [EOL]             ArrayUtils.addAll( new byte[] { (byte) 0, (byte) 1 }, null ) ) ); [EOL]  [EOL]         // short [EOL]         assertTrue( Arrays.equals( new short[] { (short) 10, (short) 20, (short) 30, (short) 40 }, [EOL]             ArrayUtils.addAll( new short[] { (short) 10, (short) 20 }, new short[] { (short) 30, (short) 40 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new short[] { (short) 30, (short) 40 }, [EOL]             ArrayUtils.addAll( null, new short[] { (short) 30, (short) 40 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new short[] { (short) 10, (short) 20 }, [EOL]             ArrayUtils.addAll( new short[] { (short) 10, (short) 20 }, null ) ) ); [EOL]  [EOL]         // int [EOL]         assertTrue( Arrays.equals( new int[] { 1, 1000, -1000, -1 }, [EOL]             ArrayUtils.addAll( new int[] { 1, 1000 }, new int[] { -1000, -1 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new int[] { -1000, -1 }, [EOL]             ArrayUtils.addAll( null, new int[] { -1000, -1 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new int[] { 1, 1000 }, [EOL]             ArrayUtils.addAll( new int[] { 1, 1000 }, null ) ) ); [EOL]  [EOL]         // long [EOL]         assertTrue( Arrays.equals( new long[] { 1L, -1L, 1000L, -1000L }, [EOL]             ArrayUtils.addAll( new long[] { 1L, -1L }, new long[] { 1000L, -1000L } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new long[] { 1000L, -1000L }, [EOL]             ArrayUtils.addAll( null, new long[] { 1000L, -1000L } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new long[] { 1L, -1L }, [EOL]             ArrayUtils.addAll( new long[] { 1L, -1L }, null ) ) ); [EOL]  [EOL]         // float [EOL]         assertTrue( Arrays.equals( new float[] { 10.5f, 10.1f, 1.6f, 0.01f }, [EOL]             ArrayUtils.addAll( new float[] { 10.5f, 10.1f }, new float[] { 1.6f, 0.01f } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new float[] { 1.6f, 0.01f }, [EOL]             ArrayUtils.addAll( null, new float[] { 1.6f, 0.01f } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new float[] { 10.5f, 10.1f }, [EOL]             ArrayUtils.addAll( new float[] { 10.5f, 10.1f }, null ) ) ); [EOL]  [EOL]         // double [EOL]         assertTrue( Arrays.equals( new double[] { Math.PI, -Math.PI, 0, 9.99 }, [EOL]             ArrayUtils.addAll( new double[] { Math.PI, -Math.PI }, new double[] { 0, 9.99 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new double[] { 0, 9.99 }, [EOL]             ArrayUtils.addAll( null, new double[] { 0, 9.99 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new double[] { Math.PI, -Math.PI }, [EOL]             ArrayUtils.addAll( new double[] { Math.PI, -Math.PI }, null ) ) ); [EOL]  [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testAddObjectArrayToObjectArray() { [EOL]         assertNull(ArrayUtils.addAll((Object[]) null, (Object[]) null)); [EOL]         Object[] newArray; [EOL]         final String[] stringArray1 = new String[]{"a", "b", "c"}; [EOL]         final String[] stringArray2 = new String[]{"1", "2", "3"}; [EOL]         newArray = ArrayUtils.addAll(stringArray1, (String[]) null); [EOL]         assertNotSame(stringArray1, newArray); [EOL]         assertTrue(Arrays.equals(stringArray1, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{"a", "b", "c"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(null, stringArray2); [EOL]         assertNotSame(stringArray2, newArray); [EOL]         assertTrue(Arrays.equals(stringArray2, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{"1", "2", "3"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(stringArray1, stringArray2); [EOL]         assertTrue(Arrays.equals(new String[]{"a", "b", "c", "1", "2", "3"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(ArrayUtils.EMPTY_STRING_ARRAY, (String[]) null); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_STRING_ARRAY, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(null, ArrayUtils.EMPTY_STRING_ARRAY); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_STRING_ARRAY, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(ArrayUtils.EMPTY_STRING_ARRAY, ArrayUtils.EMPTY_STRING_ARRAY); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_STRING_ARRAY, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         final String[] stringArrayNull = new String []{null}; [EOL]         newArray = ArrayUtils.addAll(stringArrayNull, stringArrayNull); [EOL]         assertTrue(Arrays.equals(new String[]{null, null}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]  [EOL]         // boolean [EOL]         assertTrue( Arrays.equals( new boolean[] { true, false, false, true }, [EOL]             ArrayUtils.addAll( new boolean[] { true, false }, new boolean[] { false, true } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new boolean[] { false, true }, [EOL]             ArrayUtils.addAll( null, new boolean[] { false, true } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new boolean[] { true, false }, [EOL]             ArrayUtils.addAll( new boolean[] { true, false }, null ) ) ); [EOL]  [EOL]         // char [EOL]         assertTrue( Arrays.equals( new char[] { 'a', 'b', 'c', 'd' }, [EOL]             ArrayUtils.addAll( new char[] { 'a', 'b' }, new char[] { 'c', 'd' } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new char[] { 'c', 'd' }, [EOL]             ArrayUtils.addAll( null, new char[] { 'c', 'd' } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new char[] { 'a', 'b' }, [EOL]             ArrayUtils.addAll( new char[] { 'a', 'b' }, null ) ) ); [EOL]  [EOL]         // byte [EOL]         assertTrue( Arrays.equals( new byte[] { (byte) 0, (byte) 1, (byte) 2, (byte) 3 }, [EOL]             ArrayUtils.addAll( new byte[] { (byte) 0, (byte) 1 }, new byte[] { (byte) 2, (byte) 3 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new byte[] { (byte) 2, (byte) 3 }, [EOL]             ArrayUtils.addAll( null, new byte[] { (byte) 2, (byte) 3 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new byte[] { (byte) 0, (byte) 1 }, [EOL]             ArrayUtils.addAll( new byte[] { (byte) 0, (byte) 1 }, null ) ) ); [EOL]  [EOL]         // short [EOL]         assertTrue( Arrays.equals( new short[] { (short) 10, (short) 20, (short) 30, (short) 40 }, [EOL]             ArrayUtils.addAll( new short[] { (short) 10, (short) 20 }, new short[] { (short) 30, (short) 40 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new short[] { (short) 30, (short) 40 }, [EOL]             ArrayUtils.addAll( null, new short[] { (short) 30, (short) 40 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new short[] { (short) 10, (short) 20 }, [EOL]             ArrayUtils.addAll( new short[] { (short) 10, (short) 20 }, null ) ) ); [EOL]  [EOL]         // int [EOL]         assertTrue( Arrays.equals( new int[] { 1, 1000, -1000, -1 }, [EOL]             ArrayUtils.addAll( new int[] { 1, 1000 }, new int[] { -1000, -1 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new int[] { -1000, -1 }, [EOL]             ArrayUtils.addAll( null, new int[] { -1000, -1 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new int[] { 1, 1000 }, [EOL]             ArrayUtils.addAll( new int[] { 1, 1000 }, null ) ) ); [EOL]  [EOL]         // long [EOL]         assertTrue( Arrays.equals( new long[] { 1L, -1L, 1000L, -1000L }, [EOL]             ArrayUtils.addAll( new long[] { 1L, -1L }, new long[] { 1000L, -1000L } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new long[] { 1000L, -1000L }, [EOL]             ArrayUtils.addAll( null, new long[] { 1000L, -1000L } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new long[] { 1L, -1L }, [EOL]             ArrayUtils.addAll( new long[] { 1L, -1L }, null ) ) ); [EOL]  [EOL]         // float [EOL]         assertTrue( Arrays.equals( new float[] { 10.5f, 10.1f, 1.6f, 0.01f }, [EOL]             ArrayUtils.addAll( new float[] { 10.5f, 10.1f }, new float[] { 1.6f, 0.01f } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new float[] { 1.6f, 0.01f }, [EOL]             ArrayUtils.addAll( null, new float[] { 1.6f, 0.01f } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new float[] { 10.5f, 10.1f }, [EOL]             ArrayUtils.addAll( new float[] { 10.5f, 10.1f }, null ) ) ); [EOL]  [EOL]         // double [EOL]         assertTrue( Arrays.equals( new double[] { Math.PI, -Math.PI, 0, 9.99 }, [EOL]             ArrayUtils.addAll( new double[] { Math.PI, -Math.PI }, new double[] { 0, 9.99 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new double[] { 0, 9.99 }, [EOL]             ArrayUtils.addAll( null, new double[] { 0, 9.99 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new double[] { Math.PI, -Math.PI }, [EOL]             ArrayUtils.addAll( new double[] { Math.PI, -Math.PI }, null ) ) ); [EOL]  [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testAddObjectArrayToObjectArray() { [EOL]         assertNull(ArrayUtils.addAll((Object[]) null, (Object[]) null)); [EOL]         Object[] newArray; [EOL]         final String[] stringArray1 = new String[]{"a", "b", "c"}; [EOL]         final String[] stringArray2 = new String[]{"1", "2", "3"}; [EOL]         newArray = ArrayUtils.addAll(stringArray1, (String[]) null); [EOL]         assertNotSame(stringArray1, newArray); [EOL]         assertTrue(Arrays.equals(stringArray1, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{"a", "b", "c"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(null, stringArray2); [EOL]         assertNotSame(stringArray2, newArray); [EOL]         assertTrue(Arrays.equals(stringArray2, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{"1", "2", "3"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(stringArray1, stringArray2); [EOL]         assertTrue(Arrays.equals(new String[]{"a", "b", "c", "1", "2", "3"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(ArrayUtils.EMPTY_STRING_ARRAY, (String[]) null); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_STRING_ARRAY, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(null, ArrayUtils.EMPTY_STRING_ARRAY); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_STRING_ARRAY, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(ArrayUtils.EMPTY_STRING_ARRAY, ArrayUtils.EMPTY_STRING_ARRAY); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_STRING_ARRAY, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         final String[] stringArrayNull = new String []{null}; [EOL]         newArray = ArrayUtils.addAll(stringArrayNull, stringArrayNull); [EOL]         assertTrue(Arrays.equals(new String[]{null, null}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]  [EOL]         // boolean [EOL]         assertTrue( Arrays.equals( new boolean[] { true, false, false, true }, [EOL]             ArrayUtils.addAll( new boolean[] { true, false }, new boolean[] { false, true } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new boolean[] { false, true }, [EOL]             ArrayUtils.addAll( null, new boolean[] { false, true } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new boolean[] { true, false }, [EOL]             ArrayUtils.addAll( new boolean[] { true, false }, null ) ) ); [EOL]  [EOL]         // char [EOL]         assertTrue( Arrays.equals( new char[] { 'a', 'b', 'c', 'd' }, [EOL]             ArrayUtils.addAll( new char[] { 'a', 'b' }, new char[] { 'c', 'd' } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new char[] { 'c', 'd' }, [EOL]             ArrayUtils.addAll( null, new char[] { 'c', 'd' } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new char[] { 'a', 'b' }, [EOL]             ArrayUtils.addAll( new char[] { 'a', 'b' }, null ) ) ); [EOL]  [EOL]         // byte [EOL]         assertTrue( Arrays.equals( new byte[] { (byte) 0, (byte) 1, (byte) 2, (byte) 3 }, [EOL]             ArrayUtils.addAll( new byte[] { (byte) 0, (byte) 1 }, new byte[] { (byte) 2, (byte) 3 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new byte[] { (byte) 2, (byte) 3 }, [EOL]             ArrayUtils.addAll( null, new byte[] { (byte) 2, (byte) 3 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new byte[] { (byte) 0, (byte) 1 }, [EOL]             ArrayUtils.addAll( new byte[] { (byte) 0, (byte) 1 }, null ) ) ); [EOL]  [EOL]         // short [EOL]         assertTrue( Arrays.equals( new short[] { (short) 10, (short) 20, (short) 30, (short) 40 }, [EOL]             ArrayUtils.addAll( new short[] { (short) 10, (short) 20 }, new short[] { (short) 30, (short) 40 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new short[] { (short) 30, (short) 40 }, [EOL]             ArrayUtils.addAll( null, new short[] { (short) 30, (short) 40 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new short[] { (short) 10, (short) 20 }, [EOL]             ArrayUtils.addAll( new short[] { (short) 10, (short) 20 }, null ) ) ); [EOL]  [EOL]         // int [EOL]         assertTrue( Arrays.equals( new int[] { 1, 1000, -1000, -1 }, [EOL]             ArrayUtils.addAll( new int[] { 1, 1000 }, new int[] { -1000, -1 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new int[] { -1000, -1 }, [EOL]             ArrayUtils.addAll( null, new int[] { -1000, -1 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new int[] { 1, 1000 }, [EOL]             ArrayUtils.addAll( new int[] { 1, 1000 }, null ) ) ); [EOL]  [EOL]         // long [EOL]         assertTrue( Arrays.equals( new long[] { 1L, -1L, 1000L, -1000L }, [EOL]             ArrayUtils.addAll( new long[] { 1L, -1L }, new long[] { 1000L, -1000L } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new long[] { 1000L, -1000L }, [EOL]             ArrayUtils.addAll( null, new long[] { 1000L, -1000L } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new long[] { 1L, -1L }, [EOL]             ArrayUtils.addAll( new long[] { 1L, -1L }, null ) ) ); [EOL]  [EOL]         // float [EOL]         assertTrue( Arrays.equals( new float[] { 10.5f, 10.1f, 1.6f, 0.01f }, [EOL]             ArrayUtils.addAll( new float[] { 10.5f, 10.1f }, new float[] { 1.6f, 0.01f } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new float[] { 1.6f, 0.01f }, [EOL]             ArrayUtils.addAll( null, new float[] { 1.6f, 0.01f } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new float[] { 10.5f, 10.1f }, [EOL]             ArrayUtils.addAll( new float[] { 10.5f, 10.1f }, null ) ) ); [EOL]  [EOL]         // double [EOL]         assertTrue( Arrays.equals( new double[] { Math.PI, -Math.PI, 0, 9.99 }, [EOL]             ArrayUtils.addAll( new double[] { Math.PI, -Math.PI }, new double[] { 0, 9.99 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new double[] { 0, 9.99 }, [EOL]             ArrayUtils.addAll( null, new double[] { 0, 9.99 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new double[] { Math.PI, -Math.PI }, [EOL]             ArrayUtils.addAll( new double[] { Math.PI, -Math.PI }, null ) ) ); [EOL]  [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testAddObjectArrayToObjectArray() { [EOL]         assertNull(ArrayUtils.addAll((Object[]) null, (Object[]) null)); [EOL]         Object[] newArray; [EOL]         final String[] stringArray1 = new String[]{"a", "b", "c"}; [EOL]         final String[] stringArray2 = new String[]{"1", "2", "3"}; [EOL]         newArray = ArrayUtils.addAll(stringArray1, (String[]) null); [EOL]         assertNotSame(stringArray1, newArray); [EOL]         assertTrue(Arrays.equals(stringArray1, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{"a", "b", "c"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(null, stringArray2); [EOL]         assertNotSame(stringArray2, newArray); [EOL]         assertTrue(Arrays.equals(stringArray2, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{"1", "2", "3"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(stringArray1, stringArray2); [EOL]         assertTrue(Arrays.equals(new String[]{"a", "b", "c", "1", "2", "3"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(ArrayUtils.EMPTY_STRING_ARRAY, (String[]) null); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_STRING_ARRAY, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(null, ArrayUtils.EMPTY_STRING_ARRAY); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_STRING_ARRAY, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(ArrayUtils.EMPTY_STRING_ARRAY, ArrayUtils.EMPTY_STRING_ARRAY); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_STRING_ARRAY, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         final String[] stringArrayNull = new String []{null}; [EOL]         newArray = ArrayUtils.addAll(stringArrayNull, stringArrayNull); [EOL]         assertTrue(Arrays.equals(new String[]{null, null}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]  [EOL]         // boolean [EOL]         assertTrue( Arrays.equals( new boolean[] { true, false, false, true }, [EOL]             ArrayUtils.addAll( new boolean[] { true, false }, new boolean[] { false, true } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new boolean[] { false, true }, [EOL]             ArrayUtils.addAll( null, new boolean[] { false, true } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new boolean[] { true, false }, [EOL]             ArrayUtils.addAll( new boolean[] { true, false }, null ) ) ); [EOL]  [EOL]         // char [EOL]         assertTrue( Arrays.equals( new char[] { 'a', 'b', 'c', 'd' }, [EOL]             ArrayUtils.addAll( new char[] { 'a', 'b' }, new char[] { 'c', 'd' } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new char[] { 'c', 'd' }, [EOL]             ArrayUtils.addAll( null, new char[] { 'c', 'd' } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new char[] { 'a', 'b' }, [EOL]             ArrayUtils.addAll( new char[] { 'a', 'b' }, null ) ) ); [EOL]  [EOL]         // byte [EOL]         assertTrue( Arrays.equals( new byte[] { (byte) 0, (byte) 1, (byte) 2, (byte) 3 }, [EOL]             ArrayUtils.addAll( new byte[] { (byte) 0, (byte) 1 }, new byte[] { (byte) 2, (byte) 3 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new byte[] { (byte) 2, (byte) 3 }, [EOL]             ArrayUtils.addAll( null, new byte[] { (byte) 2, (byte) 3 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new byte[] { (byte) 0, (byte) 1 }, [EOL]             ArrayUtils.addAll( new byte[] { (byte) 0, (byte) 1 }, null ) ) ); [EOL]  [EOL]         // short [EOL]         assertTrue( Arrays.equals( new short[] { (short) 10, (short) 20, (short) 30, (short) 40 }, [EOL]             ArrayUtils.addAll( new short[] { (short) 10, (short) 20 }, new short[] { (short) 30, (short) 40 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new short[] { (short) 30, (short) 40 }, [EOL]             ArrayUtils.addAll( null, new short[] { (short) 30, (short) 40 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new short[] { (short) 10, (short) 20 }, [EOL]             ArrayUtils.addAll( new short[] { (short) 10, (short) 20 }, null ) ) ); [EOL]  [EOL]         // int [EOL]         assertTrue( Arrays.equals( new int[] { 1, 1000, -1000, -1 }, [EOL]             ArrayUtils.addAll( new int[] { 1, 1000 }, new int[] { -1000, -1 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new int[] { -1000, -1 }, [EOL]             ArrayUtils.addAll( null, new int[] { -1000, -1 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new int[] { 1, 1000 }, [EOL]             ArrayUtils.addAll( new int[] { 1, 1000 }, null ) ) ); [EOL]  [EOL]         // long [EOL]         assertTrue( Arrays.equals( new long[] { 1L, -1L, 1000L, -1000L }, [EOL]             ArrayUtils.addAll( new long[] { 1L, -1L }, new long[] { 1000L, -1000L } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new long[] { 1000L, -1000L }, [EOL]             ArrayUtils.addAll( null, new long[] { 1000L, -1000L } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new long[] { 1L, -1L }, [EOL]             ArrayUtils.addAll( new long[] { 1L, -1L }, null ) ) ); [EOL]  [EOL]         // float [EOL]         assertTrue( Arrays.equals( new float[] { 10.5f, 10.1f, 1.6f, 0.01f }, [EOL]             ArrayUtils.addAll( new float[] { 10.5f, 10.1f }, new float[] { 1.6f, 0.01f } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new float[] { 1.6f, 0.01f }, [EOL]             ArrayUtils.addAll( null, new float[] { 1.6f, 0.01f } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new float[] { 10.5f, 10.1f }, [EOL]             ArrayUtils.addAll( new float[] { 10.5f, 10.1f }, null ) ) ); [EOL]  [EOL]         // double [EOL]         assertTrue( Arrays.equals( new double[] { Math.PI, -Math.PI, 0, 9.99 }, [EOL]             ArrayUtils.addAll( new double[] { Math.PI, -Math.PI }, new double[] { 0, 9.99 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new double[] { 0, 9.99 }, [EOL]             ArrayUtils.addAll( null, new double[] { 0, 9.99 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new double[] { Math.PI, -Math.PI }, [EOL]             ArrayUtils.addAll( new double[] { Math.PI, -Math.PI }, null ) ) ); [EOL]  [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testAddObjectArrayToObjectArray() { [EOL]         assertNull(ArrayUtils.addAll((Object[]) null, (Object[]) null)); [EOL]         Object[] newArray; [EOL]         final String[] stringArray1 = new String[]{"a", "b", "c"}; [EOL]         final String[] stringArray2 = new String[]{"1", "2", "3"}; [EOL]         newArray = ArrayUtils.addAll(stringArray1, (String[]) null); [EOL]         assertNotSame(stringArray1, newArray); [EOL]         assertTrue(Arrays.equals(stringArray1, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{"a", "b", "c"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(null, stringArray2); [EOL]         assertNotSame(stringArray2, newArray); [EOL]         assertTrue(Arrays.equals(stringArray2, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{"1", "2", "3"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(stringArray1, stringArray2); [EOL]         assertTrue(Arrays.equals(new String[]{"a", "b", "c", "1", "2", "3"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(ArrayUtils.EMPTY_STRING_ARRAY, (String[]) null); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_STRING_ARRAY, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(null, ArrayUtils.EMPTY_STRING_ARRAY); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_STRING_ARRAY, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(ArrayUtils.EMPTY_STRING_ARRAY, ArrayUtils.EMPTY_STRING_ARRAY); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_STRING_ARRAY, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         final String[] stringArrayNull = new String []{null}; [EOL]         newArray = ArrayUtils.addAll(stringArrayNull, stringArrayNull); [EOL]         assertTrue(Arrays.equals(new String[]{null, null}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]  [EOL]         // boolean [EOL]         assertTrue( Arrays.equals( new boolean[] { true, false, false, true }, [EOL]             ArrayUtils.addAll( new boolean[] { true, false }, new boolean[] { false, true } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new boolean[] { false, true }, [EOL]             ArrayUtils.addAll( null, new boolean[] { false, true } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new boolean[] { true, false }, [EOL]             ArrayUtils.addAll( new boolean[] { true, false }, null ) ) ); [EOL]  [EOL]         // char [EOL]         assertTrue( Arrays.equals( new char[] { 'a', 'b', 'c', 'd' }, [EOL]             ArrayUtils.addAll( new char[] { 'a', 'b' }, new char[] { 'c', 'd' } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new char[] { 'c', 'd' }, [EOL]             ArrayUtils.addAll( null, new char[] { 'c', 'd' } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new char[] { 'a', 'b' }, [EOL]             ArrayUtils.addAll( new char[] { 'a', 'b' }, null ) ) ); [EOL]  [EOL]         // byte [EOL]         assertTrue( Arrays.equals( new byte[] { (byte) 0, (byte) 1, (byte) 2, (byte) 3 }, [EOL]             ArrayUtils.addAll( new byte[] { (byte) 0, (byte) 1 }, new byte[] { (byte) 2, (byte) 3 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new byte[] { (byte) 2, (byte) 3 }, [EOL]             ArrayUtils.addAll( null, new byte[] { (byte) 2, (byte) 3 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new byte[] { (byte) 0, (byte) 1 }, [EOL]             ArrayUtils.addAll( new byte[] { (byte) 0, (byte) 1 }, null ) ) ); [EOL]  [EOL]         // short [EOL]         assertTrue( Arrays.equals( new short[] { (short) 10, (short) 20, (short) 30, (short) 40 }, [EOL]             ArrayUtils.addAll( new short[] { (short) 10, (short) 20 }, new short[] { (short) 30, (short) 40 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new short[] { (short) 30, (short) 40 }, [EOL]             ArrayUtils.addAll( null, new short[] { (short) 30, (short) 40 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new short[] { (short) 10, (short) 20 }, [EOL]             ArrayUtils.addAll( new short[] { (short) 10, (short) 20 }, null ) ) ); [EOL]  [EOL]         // int [EOL]         assertTrue( Arrays.equals( new int[] { 1, 1000, -1000, -1 }, [EOL]             ArrayUtils.addAll( new int[] { 1, 1000 }, new int[] { -1000, -1 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new int[] { -1000, -1 }, [EOL]             ArrayUtils.addAll( null, new int[] { -1000, -1 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new int[] { 1, 1000 }, [EOL]             ArrayUtils.addAll( new int[] { 1, 1000 }, null ) ) ); [EOL]  [EOL]         // long [EOL]         assertTrue( Arrays.equals( new long[] { 1L, -1L, 1000L, -1000L }, [EOL]             ArrayUtils.addAll( new long[] { 1L, -1L }, new long[] { 1000L, -1000L } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new long[] { 1000L, -1000L }, [EOL]             ArrayUtils.addAll( null, new long[] { 1000L, -1000L } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new long[] { 1L, -1L }, [EOL]             ArrayUtils.addAll( new long[] { 1L, -1L }, null ) ) ); [EOL]  [EOL]         // float [EOL]         assertTrue( Arrays.equals( new float[] { 10.5f, 10.1f, 1.6f, 0.01f }, [EOL]             ArrayUtils.addAll( new float[] { 10.5f, 10.1f }, new float[] { 1.6f, 0.01f } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new float[] { 1.6f, 0.01f }, [EOL]             ArrayUtils.addAll( null, new float[] { 1.6f, 0.01f } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new float[] { 10.5f, 10.1f }, [EOL]             ArrayUtils.addAll( new float[] { 10.5f, 10.1f }, null ) ) ); [EOL]  [EOL]         // double [EOL]         assertTrue( Arrays.equals( new double[] { Math.PI, -Math.PI, 0, 9.99 }, [EOL]             ArrayUtils.addAll( new double[] { Math.PI, -Math.PI }, new double[] { 0, 9.99 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new double[] { 0, 9.99 }, [EOL]             ArrayUtils.addAll( null, new double[] { 0, 9.99 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new double[] { Math.PI, -Math.PI }, [EOL]             ArrayUtils.addAll( new double[] { Math.PI, -Math.PI }, null ) ) ); [EOL]  [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testAddObjectArrayToObjectArray() { [EOL]         assertNull(ArrayUtils.addAll((Object[]) null, (Object[]) null)); [EOL]         Object[] newArray; [EOL]         final String[] stringArray1 = new String[]{"a", "b", "c"}; [EOL]         final String[] stringArray2 = new String[]{"1", "2", "3"}; [EOL]         newArray = ArrayUtils.addAll(stringArray1, (String[]) null); [EOL]         assertNotSame(stringArray1, newArray); [EOL]         assertTrue(Arrays.equals(stringArray1, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{"a", "b", "c"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(null, stringArray2); [EOL]         assertNotSame(stringArray2, newArray); [EOL]         assertTrue(Arrays.equals(stringArray2, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{"1", "2", "3"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(stringArray1, stringArray2); [EOL]         assertTrue(Arrays.equals(new String[]{"a", "b", "c", "1", "2", "3"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(ArrayUtils.EMPTY_STRING_ARRAY, (String[]) null); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_STRING_ARRAY, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(null, ArrayUtils.EMPTY_STRING_ARRAY); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_STRING_ARRAY, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(ArrayUtils.EMPTY_STRING_ARRAY, ArrayUtils.EMPTY_STRING_ARRAY); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_STRING_ARRAY, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         final String[] stringArrayNull = new String []{null}; [EOL]         newArray = ArrayUtils.addAll(stringArrayNull, stringArrayNull); [EOL]         assertTrue(Arrays.equals(new String[]{null, null}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]  [EOL]         // boolean [EOL]         assertTrue( Arrays.equals( new boolean[] { true, false, false, true }, [EOL]             ArrayUtils.addAll( new boolean[] { true, false }, new boolean[] { false, true } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new boolean[] { false, true }, [EOL]             ArrayUtils.addAll( null, new boolean[] { false, true } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new boolean[] { true, false }, [EOL]             ArrayUtils.addAll( new boolean[] { true, false }, null ) ) ); [EOL]  [EOL]         // char [EOL]         assertTrue( Arrays.equals( new char[] { 'a', 'b', 'c', 'd' }, [EOL]             ArrayUtils.addAll( new char[] { 'a', 'b' }, new char[] { 'c', 'd' } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new char[] { 'c', 'd' }, [EOL]             ArrayUtils.addAll( null, new char[] { 'c', 'd' } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new char[] { 'a', 'b' }, [EOL]             ArrayUtils.addAll( new char[] { 'a', 'b' }, null ) ) ); [EOL]  [EOL]         // byte [EOL]         assertTrue( Arrays.equals( new byte[] { (byte) 0, (byte) 1, (byte) 2, (byte) 3 }, [EOL]             ArrayUtils.addAll( new byte[] { (byte) 0, (byte) 1 }, new byte[] { (byte) 2, (byte) 3 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new byte[] { (byte) 2, (byte) 3 }, [EOL]             ArrayUtils.addAll( null, new byte[] { (byte) 2, (byte) 3 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new byte[] { (byte) 0, (byte) 1 }, [EOL]             ArrayUtils.addAll( new byte[] { (byte) 0, (byte) 1 }, null ) ) ); [EOL]  [EOL]         // short [EOL]         assertTrue( Arrays.equals( new short[] { (short) 10, (short) 20, (short) 30, (short) 40 }, [EOL]             ArrayUtils.addAll( new short[] { (short) 10, (short) 20 }, new short[] { (short) 30, (short) 40 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new short[] { (short) 30, (short) 40 }, [EOL]             ArrayUtils.addAll( null, new short[] { (short) 30, (short) 40 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new short[] { (short) 10, (short) 20 }, [EOL]             ArrayUtils.addAll( new short[] { (short) 10, (short) 20 }, null ) ) ); [EOL]  [EOL]         // int [EOL]         assertTrue( Arrays.equals( new int[] { 1, 1000, -1000, -1 }, [EOL]             ArrayUtils.addAll( new int[] { 1, 1000 }, new int[] { -1000, -1 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new int[] { -1000, -1 }, [EOL]             ArrayUtils.addAll( null, new int[] { -1000, -1 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new int[] { 1, 1000 }, [EOL]             ArrayUtils.addAll( new int[] { 1, 1000 }, null ) ) ); [EOL]  [EOL]         // long [EOL]         assertTrue( Arrays.equals( new long[] { 1L, -1L, 1000L, -1000L }, [EOL]             ArrayUtils.addAll( new long[] { 1L, -1L }, new long[] { 1000L, -1000L } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new long[] { 1000L, -1000L }, [EOL]             ArrayUtils.addAll( null, new long[] { 1000L, -1000L } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new long[] { 1L, -1L }, [EOL]             ArrayUtils.addAll( new long[] { 1L, -1L }, null ) ) ); [EOL]  [EOL]         // float [EOL]         assertTrue( Arrays.equals( new float[] { 10.5f, 10.1f, 1.6f, 0.01f }, [EOL]             ArrayUtils.addAll( new float[] { 10.5f, 10.1f }, new float[] { 1.6f, 0.01f } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new float[] { 1.6f, 0.01f }, [EOL]             ArrayUtils.addAll( null, new float[] { 1.6f, 0.01f } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new float[] { 10.5f, 10.1f }, [EOL]             ArrayUtils.addAll( new float[] { 10.5f, 10.1f }, null ) ) ); [EOL]  [EOL]         // double [EOL]         assertTrue( Arrays.equals( new double[] { Math.PI, -Math.PI, 0, 9.99 }, [EOL]             ArrayUtils.addAll( new double[] { Math.PI, -Math.PI }, new double[] { 0, 9.99 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new double[] { 0, 9.99 }, [EOL]             ArrayUtils.addAll( null, new double[] { 0, 9.99 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new double[] { Math.PI, -Math.PI }, [EOL]             ArrayUtils.addAll( new double[] { Math.PI, -Math.PI }, null ) ) ); [EOL]  [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testAddObjectArrayToObjectArray() { [EOL]         assertNull(ArrayUtils.addAll((Object[]) null, (Object[]) null)); [EOL]         Object[] newArray; [EOL]         final String[] stringArray1 = new String[]{"a", "b", "c"}; [EOL]         final String[] stringArray2 = new String[]{"1", "2", "3"}; [EOL]         newArray = ArrayUtils.addAll(stringArray1, (String[]) null); [EOL]         assertNotSame(stringArray1, newArray); [EOL]         assertTrue(Arrays.equals(stringArray1, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{"a", "b", "c"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(null, stringArray2); [EOL]         assertNotSame(stringArray2, newArray); [EOL]         assertTrue(Arrays.equals(stringArray2, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{"1", "2", "3"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(stringArray1, stringArray2); [EOL]         assertTrue(Arrays.equals(new String[]{"a", "b", "c", "1", "2", "3"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(ArrayUtils.EMPTY_STRING_ARRAY, (String[]) null); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_STRING_ARRAY, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(null, ArrayUtils.EMPTY_STRING_ARRAY); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_STRING_ARRAY, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(ArrayUtils.EMPTY_STRING_ARRAY, ArrayUtils.EMPTY_STRING_ARRAY); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_STRING_ARRAY, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         final String[] stringArrayNull = new String []{null}; [EOL]         newArray = ArrayUtils.addAll(stringArrayNull, stringArrayNull); [EOL]         assertTrue(Arrays.equals(new String[]{null, null}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]  [EOL]         // boolean [EOL]         assertTrue( Arrays.equals( new boolean[] { true, false, false, true }, [EOL]             ArrayUtils.addAll( new boolean[] { true, false }, new boolean[] { false, true } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new boolean[] { false, true }, [EOL]             ArrayUtils.addAll( null, new boolean[] { false, true } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new boolean[] { true, false }, [EOL]             ArrayUtils.addAll( new boolean[] { true, false }, null ) ) ); [EOL]  [EOL]         // char [EOL]         assertTrue( Arrays.equals( new char[] { 'a', 'b', 'c', 'd' }, [EOL]             ArrayUtils.addAll( new char[] { 'a', 'b' }, new char[] { 'c', 'd' } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new char[] { 'c', 'd' }, [EOL]             ArrayUtils.addAll( null, new char[] { 'c', 'd' } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new char[] { 'a', 'b' }, [EOL]             ArrayUtils.addAll( new char[] { 'a', 'b' }, null ) ) ); [EOL]  [EOL]         // byte [EOL]         assertTrue( Arrays.equals( new byte[] { (byte) 0, (byte) 1, (byte) 2, (byte) 3 }, [EOL]             ArrayUtils.addAll( new byte[] { (byte) 0, (byte) 1 }, new byte[] { (byte) 2, (byte) 3 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new byte[] { (byte) 2, (byte) 3 }, [EOL]             ArrayUtils.addAll( null, new byte[] { (byte) 2, (byte) 3 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new byte[] { (byte) 0, (byte) 1 }, [EOL]             ArrayUtils.addAll( new byte[] { (byte) 0, (byte) 1 }, null ) ) ); [EOL]  [EOL]         // short [EOL]         assertTrue( Arrays.equals( new short[] { (short) 10, (short) 20, (short) 30, (short) 40 }, [EOL]             ArrayUtils.addAll( new short[] { (short) 10, (short) 20 }, new short[] { (short) 30, (short) 40 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new short[] { (short) 30, (short) 40 }, [EOL]             ArrayUtils.addAll( null, new short[] { (short) 30, (short) 40 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new short[] { (short) 10, (short) 20 }, [EOL]             ArrayUtils.addAll( new short[] { (short) 10, (short) 20 }, null ) ) ); [EOL]  [EOL]         // int [EOL]         assertTrue( Arrays.equals( new int[] { 1, 1000, -1000, -1 }, [EOL]             ArrayUtils.addAll( new int[] { 1, 1000 }, new int[] { -1000, -1 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new int[] { -1000, -1 }, [EOL]             ArrayUtils.addAll( null, new int[] { -1000, -1 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new int[] { 1, 1000 }, [EOL]             ArrayUtils.addAll( new int[] { 1, 1000 }, null ) ) ); [EOL]  [EOL]         // long [EOL]         assertTrue( Arrays.equals( new long[] { 1L, -1L, 1000L, -1000L }, [EOL]             ArrayUtils.addAll( new long[] { 1L, -1L }, new long[] { 1000L, -1000L } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new long[] { 1000L, -1000L }, [EOL]             ArrayUtils.addAll( null, new long[] { 1000L, -1000L } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new long[] { 1L, -1L }, [EOL]             ArrayUtils.addAll( new long[] { 1L, -1L }, null ) ) ); [EOL]  [EOL]         // float [EOL]         assertTrue( Arrays.equals( new float[] { 10.5f, 10.1f, 1.6f, 0.01f }, [EOL]             ArrayUtils.addAll( new float[] { 10.5f, 10.1f }, new float[] { 1.6f, 0.01f } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new float[] { 1.6f, 0.01f }, [EOL]             ArrayUtils.addAll( null, new float[] { 1.6f, 0.01f } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new float[] { 10.5f, 10.1f }, [EOL]             ArrayUtils.addAll( new float[] { 10.5f, 10.1f }, null ) ) ); [EOL]  [EOL]         // double [EOL]         assertTrue( Arrays.equals( new double[] { Math.PI, -Math.PI, 0, 9.99 }, [EOL]             ArrayUtils.addAll( new double[] { Math.PI, -Math.PI }, new double[] { 0, 9.99 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new double[] { 0, 9.99 }, [EOL]             ArrayUtils.addAll( null, new double[] { 0, 9.99 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new double[] { Math.PI, -Math.PI }, [EOL]             ArrayUtils.addAll( new double[] { Math.PI, -Math.PI }, null ) ) ); [EOL]  [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testAddObjectArrayToObjectArray() { [EOL]         assertNull(ArrayUtils.addAll((Object[]) null, (Object[]) null)); [EOL]         Object[] newArray; [EOL]         final String[] stringArray1 = new String[]{"a", "b", "c"}; [EOL]         final String[] stringArray2 = new String[]{"1", "2", "3"}; [EOL]         newArray = ArrayUtils.addAll(stringArray1, (String[]) null); [EOL]         assertNotSame(stringArray1, newArray); [EOL]         assertTrue(Arrays.equals(stringArray1, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{"a", "b", "c"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(null, stringArray2); [EOL]         assertNotSame(stringArray2, newArray); [EOL]         assertTrue(Arrays.equals(stringArray2, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{"1", "2", "3"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(stringArray1, stringArray2); [EOL]         assertTrue(Arrays.equals(new String[]{"a", "b", "c", "1", "2", "3"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(ArrayUtils.EMPTY_STRING_ARRAY, (String[]) null); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_STRING_ARRAY, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(null, ArrayUtils.EMPTY_STRING_ARRAY); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_STRING_ARRAY, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(ArrayUtils.EMPTY_STRING_ARRAY, ArrayUtils.EMPTY_STRING_ARRAY); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_STRING_ARRAY, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         final String[] stringArrayNull = new String []{null}; [EOL]         newArray = ArrayUtils.addAll(stringArrayNull, stringArrayNull); [EOL]         assertTrue(Arrays.equals(new String[]{null, null}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]  [EOL]         // boolean [EOL]         assertTrue( Arrays.equals( new boolean[] { true, false, false, true }, [EOL]             ArrayUtils.addAll( new boolean[] { true, false }, new boolean[] { false, true } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new boolean[] { false, true }, [EOL]             ArrayUtils.addAll( null, new boolean[] { false, true } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new boolean[] { true, false }, [EOL]             ArrayUtils.addAll( new boolean[] { true, false }, null ) ) ); [EOL]  [EOL]         // char [EOL]         assertTrue( Arrays.equals( new char[] { 'a', 'b', 'c', 'd' }, [EOL]             ArrayUtils.addAll( new char[] { 'a', 'b' }, new char[] { 'c', 'd' } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new char[] { 'c', 'd' }, [EOL]             ArrayUtils.addAll( null, new char[] { 'c', 'd' } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new char[] { 'a', 'b' }, [EOL]             ArrayUtils.addAll( new char[] { 'a', 'b' }, null ) ) ); [EOL]  [EOL]         // byte [EOL]         assertTrue( Arrays.equals( new byte[] { (byte) 0, (byte) 1, (byte) 2, (byte) 3 }, [EOL]             ArrayUtils.addAll( new byte[] { (byte) 0, (byte) 1 }, new byte[] { (byte) 2, (byte) 3 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new byte[] { (byte) 2, (byte) 3 }, [EOL]             ArrayUtils.addAll( null, new byte[] { (byte) 2, (byte) 3 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new byte[] { (byte) 0, (byte) 1 }, [EOL]             ArrayUtils.addAll( new byte[] { (byte) 0, (byte) 1 }, null ) ) ); [EOL]  [EOL]         // short [EOL]         assertTrue( Arrays.equals( new short[] { (short) 10, (short) 20, (short) 30, (short) 40 }, [EOL]             ArrayUtils.addAll( new short[] { (short) 10, (short) 20 }, new short[] { (short) 30, (short) 40 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new short[] { (short) 30, (short) 40 }, [EOL]             ArrayUtils.addAll( null, new short[] { (short) 30, (short) 40 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new short[] { (short) 10, (short) 20 }, [EOL]             ArrayUtils.addAll( new short[] { (short) 10, (short) 20 }, null ) ) ); [EOL]  [EOL]         // int [EOL]         assertTrue( Arrays.equals( new int[] { 1, 1000, -1000, -1 }, [EOL]             ArrayUtils.addAll( new int[] { 1, 1000 }, new int[] { -1000, -1 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new int[] { -1000, -1 }, [EOL]             ArrayUtils.addAll( null, new int[] { -1000, -1 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new int[] { 1, 1000 }, [EOL]             ArrayUtils.addAll( new int[] { 1, 1000 }, null ) ) ); [EOL]  [EOL]         // long [EOL]         assertTrue( Arrays.equals( new long[] { 1L, -1L, 1000L, -1000L }, [EOL]             ArrayUtils.addAll( new long[] { 1L, -1L }, new long[] { 1000L, -1000L } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new long[] { 1000L, -1000L }, [EOL]             ArrayUtils.addAll( null, new long[] { 1000L, -1000L } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new long[] { 1L, -1L }, [EOL]             ArrayUtils.addAll( new long[] { 1L, -1L }, null ) ) ); [EOL]  [EOL]         // float [EOL]         assertTrue( Arrays.equals( new float[] { 10.5f, 10.1f, 1.6f, 0.01f }, [EOL]             ArrayUtils.addAll( new float[] { 10.5f, 10.1f }, new float[] { 1.6f, 0.01f } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new float[] { 1.6f, 0.01f }, [EOL]             ArrayUtils.addAll( null, new float[] { 1.6f, 0.01f } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new float[] { 10.5f, 10.1f }, [EOL]             ArrayUtils.addAll( new float[] { 10.5f, 10.1f }, null ) ) ); [EOL]  [EOL]         // double [EOL]         assertTrue( Arrays.equals( new double[] { Math.PI, -Math.PI, 0, 9.99 }, [EOL]             ArrayUtils.addAll( new double[] { Math.PI, -Math.PI }, new double[] { 0, 9.99 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new double[] { 0, 9.99 }, [EOL]             ArrayUtils.addAll( null, new double[] { 0, 9.99 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new double[] { Math.PI, -Math.PI }, [EOL]             ArrayUtils.addAll( new double[] { Math.PI, -Math.PI }, null ) ) ); [EOL]  [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testAddObjectArrayToObjectArray() { [EOL]         assertNull(ArrayUtils.addAll((Object[]) null, (Object[]) null)); [EOL]         Object[] newArray; [EOL]         final String[] stringArray1 = new String[]{"a", "b", "c"}; [EOL]         final String[] stringArray2 = new String[]{"1", "2", "3"}; [EOL]         newArray = ArrayUtils.addAll(stringArray1, (String[]) null); [EOL]         assertNotSame(stringArray1, newArray); [EOL]         assertTrue(Arrays.equals(stringArray1, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{"a", "b", "c"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(null, stringArray2); [EOL]         assertNotSame(stringArray2, newArray); [EOL]         assertTrue(Arrays.equals(stringArray2, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{"1", "2", "3"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(stringArray1, stringArray2); [EOL]         assertTrue(Arrays.equals(new String[]{"a", "b", "c", "1", "2", "3"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(ArrayUtils.EMPTY_STRING_ARRAY, (String[]) null); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_STRING_ARRAY, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(null, ArrayUtils.EMPTY_STRING_ARRAY); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_STRING_ARRAY, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(ArrayUtils.EMPTY_STRING_ARRAY, ArrayUtils.EMPTY_STRING_ARRAY); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_STRING_ARRAY, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         final String[] stringArrayNull = new String []{null}; [EOL]         newArray = ArrayUtils.addAll(stringArrayNull, stringArrayNull); [EOL]         assertTrue(Arrays.equals(new String[]{null, null}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]  [EOL]         // boolean [EOL]         assertTrue( Arrays.equals( new boolean[] { true, false, false, true }, [EOL]             ArrayUtils.addAll( new boolean[] { true, false }, new boolean[] { false, true } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new boolean[] { false, true }, [EOL]             ArrayUtils.addAll( null, new boolean[] { false, true } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new boolean[] { true, false }, [EOL]             ArrayUtils.addAll( new boolean[] { true, false }, null ) ) ); [EOL]  [EOL]         // char [EOL]         assertTrue( Arrays.equals( new char[] { 'a', 'b', 'c', 'd' }, [EOL]             ArrayUtils.addAll( new char[] { 'a', 'b' }, new char[] { 'c', 'd' } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new char[] { 'c', 'd' }, [EOL]             ArrayUtils.addAll( null, new char[] { 'c', 'd' } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new char[] { 'a', 'b' }, [EOL]             ArrayUtils.addAll( new char[] { 'a', 'b' }, null ) ) ); [EOL]  [EOL]         // byte [EOL]         assertTrue( Arrays.equals( new byte[] { (byte) 0, (byte) 1, (byte) 2, (byte) 3 }, [EOL]             ArrayUtils.addAll( new byte[] { (byte) 0, (byte) 1 }, new byte[] { (byte) 2, (byte) 3 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new byte[] { (byte) 2, (byte) 3 }, [EOL]             ArrayUtils.addAll( null, new byte[] { (byte) 2, (byte) 3 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new byte[] { (byte) 0, (byte) 1 }, [EOL]             ArrayUtils.addAll( new byte[] { (byte) 0, (byte) 1 }, null ) ) ); [EOL]  [EOL]         // short [EOL]         assertTrue( Arrays.equals( new short[] { (short) 10, (short) 20, (short) 30, (short) 40 }, [EOL]             ArrayUtils.addAll( new short[] { (short) 10, (short) 20 }, new short[] { (short) 30, (short) 40 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new short[] { (short) 30, (short) 40 }, [EOL]             ArrayUtils.addAll( null, new short[] { (short) 30, (short) 40 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new short[] { (short) 10, (short) 20 }, [EOL]             ArrayUtils.addAll( new short[] { (short) 10, (short) 20 }, null ) ) ); [EOL]  [EOL]         // int [EOL]         assertTrue( Arrays.equals( new int[] { 1, 1000, -1000, -1 }, [EOL]             ArrayUtils.addAll( new int[] { 1, 1000 }, new int[] { -1000, -1 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new int[] { -1000, -1 }, [EOL]             ArrayUtils.addAll( null, new int[] { -1000, -1 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new int[] { 1, 1000 }, [EOL]             ArrayUtils.addAll( new int[] { 1, 1000 }, null ) ) ); [EOL]  [EOL]         // long [EOL]         assertTrue( Arrays.equals( new long[] { 1L, -1L, 1000L, -1000L }, [EOL]             ArrayUtils.addAll( new long[] { 1L, -1L }, new long[] { 1000L, -1000L } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new long[] { 1000L, -1000L }, [EOL]             ArrayUtils.addAll( null, new long[] { 1000L, -1000L } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new long[] { 1L, -1L }, [EOL]             ArrayUtils.addAll( new long[] { 1L, -1L }, null ) ) ); [EOL]  [EOL]         // float [EOL]         assertTrue( Arrays.equals( new float[] { 10.5f, 10.1f, 1.6f, 0.01f }, [EOL]             ArrayUtils.addAll( new float[] { 10.5f, 10.1f }, new float[] { 1.6f, 0.01f } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new float[] { 1.6f, 0.01f }, [EOL]             ArrayUtils.addAll( null, new float[] { 1.6f, 0.01f } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new float[] { 10.5f, 10.1f }, [EOL]             ArrayUtils.addAll( new float[] { 10.5f, 10.1f }, null ) ) ); [EOL]  [EOL]         // double [EOL]         assertTrue( Arrays.equals( new double[] { Math.PI, -Math.PI, 0, 9.99 }, [EOL]             ArrayUtils.addAll( new double[] { Math.PI, -Math.PI }, new double[] { 0, 9.99 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new double[] { 0, 9.99 }, [EOL]             ArrayUtils.addAll( null, new double[] { 0, 9.99 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new double[] { Math.PI, -Math.PI }, [EOL]             ArrayUtils.addAll( new double[] { Math.PI, -Math.PI }, null ) ) ); [EOL]  [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testAddObjectArrayToObjectArray() { [EOL]         assertNull(ArrayUtils.addAll((Object[]) null, (Object[]) null)); [EOL]         Object[] newArray; [EOL]         final String[] stringArray1 = new String[]{"a", "b", "c"}; [EOL]         final String[] stringArray2 = new String[]{"1", "2", "3"}; [EOL]         newArray = ArrayUtils.addAll(stringArray1, (String[]) null); [EOL]         assertNotSame(stringArray1, newArray); [EOL]         assertTrue(Arrays.equals(stringArray1, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{"a", "b", "c"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(null, stringArray2); [EOL]         assertNotSame(stringArray2, newArray); [EOL]         assertTrue(Arrays.equals(stringArray2, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{"1", "2", "3"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(stringArray1, stringArray2); [EOL]         assertTrue(Arrays.equals(new String[]{"a", "b", "c", "1", "2", "3"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(ArrayUtils.EMPTY_STRING_ARRAY, (String[]) null); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_STRING_ARRAY, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(null, ArrayUtils.EMPTY_STRING_ARRAY); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_STRING_ARRAY, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(ArrayUtils.EMPTY_STRING_ARRAY, ArrayUtils.EMPTY_STRING_ARRAY); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_STRING_ARRAY, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         final String[] stringArrayNull = new String []{null}; [EOL]         newArray = ArrayUtils.addAll(stringArrayNull, stringArrayNull); [EOL]         assertTrue(Arrays.equals(new String[]{null, null}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]  [EOL]         // boolean [EOL]         assertTrue( Arrays.equals( new boolean[] { true, false, false, true }, [EOL]             ArrayUtils.addAll( new boolean[] { true, false }, new boolean[] { false, true } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new boolean[] { false, true }, [EOL]             ArrayUtils.addAll( null, new boolean[] { false, true } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new boolean[] { true, false }, [EOL]             ArrayUtils.addAll( new boolean[] { true, false }, null ) ) ); [EOL]  [EOL]         // char [EOL]         assertTrue( Arrays.equals( new char[] { 'a', 'b', 'c', 'd' }, [EOL]             ArrayUtils.addAll( new char[] { 'a', 'b' }, new char[] { 'c', 'd' } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new char[] { 'c', 'd' }, [EOL]             ArrayUtils.addAll( null, new char[] { 'c', 'd' } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new char[] { 'a', 'b' }, [EOL]             ArrayUtils.addAll( new char[] { 'a', 'b' }, null ) ) ); [EOL]  [EOL]         // byte [EOL]         assertTrue( Arrays.equals( new byte[] { (byte) 0, (byte) 1, (byte) 2, (byte) 3 }, [EOL]             ArrayUtils.addAll( new byte[] { (byte) 0, (byte) 1 }, new byte[] { (byte) 2, (byte) 3 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new byte[] { (byte) 2, (byte) 3 }, [EOL]             ArrayUtils.addAll( null, new byte[] { (byte) 2, (byte) 3 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new byte[] { (byte) 0, (byte) 1 }, [EOL]             ArrayUtils.addAll( new byte[] { (byte) 0, (byte) 1 }, null ) ) ); [EOL]  [EOL]         // short [EOL]         assertTrue( Arrays.equals( new short[] { (short) 10, (short) 20, (short) 30, (short) 40 }, [EOL]             ArrayUtils.addAll( new short[] { (short) 10, (short) 20 }, new short[] { (short) 30, (short) 40 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new short[] { (short) 30, (short) 40 }, [EOL]             ArrayUtils.addAll( null, new short[] { (short) 30, (short) 40 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new short[] { (short) 10, (short) 20 }, [EOL]             ArrayUtils.addAll( new short[] { (short) 10, (short) 20 }, null ) ) ); [EOL]  [EOL]         // int [EOL]         assertTrue( Arrays.equals( new int[] { 1, 1000, -1000, -1 }, [EOL]             ArrayUtils.addAll( new int[] { 1, 1000 }, new int[] { -1000, -1 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new int[] { -1000, -1 }, [EOL]             ArrayUtils.addAll( null, new int[] { -1000, -1 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new int[] { 1, 1000 }, [EOL]             ArrayUtils.addAll( new int[] { 1, 1000 }, null ) ) ); [EOL]  [EOL]         // long [EOL]         assertTrue( Arrays.equals( new long[] { 1L, -1L, 1000L, -1000L }, [EOL]             ArrayUtils.addAll( new long[] { 1L, -1L }, new long[] { 1000L, -1000L } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new long[] { 1000L, -1000L }, [EOL]             ArrayUtils.addAll( null, new long[] { 1000L, -1000L } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new long[] { 1L, -1L }, [EOL]             ArrayUtils.addAll( new long[] { 1L, -1L }, null ) ) ); [EOL]  [EOL]         // float [EOL]         assertTrue( Arrays.equals( new float[] { 10.5f, 10.1f, 1.6f, 0.01f }, [EOL]             ArrayUtils.addAll( new float[] { 10.5f, 10.1f }, new float[] { 1.6f, 0.01f } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new float[] { 1.6f, 0.01f }, [EOL]             ArrayUtils.addAll( null, new float[] { 1.6f, 0.01f } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new float[] { 10.5f, 10.1f }, [EOL]             ArrayUtils.addAll( new float[] { 10.5f, 10.1f }, null ) ) ); [EOL]  [EOL]         // double [EOL]         assertTrue( Arrays.equals( new double[] { Math.PI, -Math.PI, 0, 9.99 }, [EOL]             ArrayUtils.addAll( new double[] { Math.PI, -Math.PI }, new double[] { 0, 9.99 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new double[] { 0, 9.99 }, [EOL]             ArrayUtils.addAll( null, new double[] { 0, 9.99 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new double[] { Math.PI, -Math.PI }, [EOL]             ArrayUtils.addAll( new double[] { Math.PI, -Math.PI }, null ) ) ); [EOL]  [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testAddObjectArrayToObjectArray() { [EOL]         assertNull(ArrayUtils.addAll((Object[]) null, (Object[]) null)); [EOL]         Object[] newArray; [EOL]         final String[] stringArray1 = new String[]{"a", "b", "c"}; [EOL]         final String[] stringArray2 = new String[]{"1", "2", "3"}; [EOL]         newArray = ArrayUtils.addAll(stringArray1, (String[]) null); [EOL]         assertNotSame(stringArray1, newArray); [EOL]         assertTrue(Arrays.equals(stringArray1, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{"a", "b", "c"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(null, stringArray2); [EOL]         assertNotSame(stringArray2, newArray); [EOL]         assertTrue(Arrays.equals(stringArray2, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{"1", "2", "3"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(stringArray1, stringArray2); [EOL]         assertTrue(Arrays.equals(new String[]{"a", "b", "c", "1", "2", "3"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(ArrayUtils.EMPTY_STRING_ARRAY, (String[]) null); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_STRING_ARRAY, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(null, ArrayUtils.EMPTY_STRING_ARRAY); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_STRING_ARRAY, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(ArrayUtils.EMPTY_STRING_ARRAY, ArrayUtils.EMPTY_STRING_ARRAY); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_STRING_ARRAY, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         final String[] stringArrayNull = new String []{null}; [EOL]         newArray = ArrayUtils.addAll(stringArrayNull, stringArrayNull); [EOL]         assertTrue(Arrays.equals(new String[]{null, null}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]  [EOL]         // boolean [EOL]         assertTrue( Arrays.equals( new boolean[] { true, false, false, true }, [EOL]             ArrayUtils.addAll( new boolean[] { true, false }, new boolean[] { false, true } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new boolean[] { false, true }, [EOL]             ArrayUtils.addAll( null, new boolean[] { false, true } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new boolean[] { true, false }, [EOL]             ArrayUtils.addAll( new boolean[] { true, false }, null ) ) ); [EOL]  [EOL]         // char [EOL]         assertTrue( Arrays.equals( new char[] { 'a', 'b', 'c', 'd' }, [EOL]             ArrayUtils.addAll( new char[] { 'a', 'b' }, new char[] { 'c', 'd' } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new char[] { 'c', 'd' }, [EOL]             ArrayUtils.addAll( null, new char[] { 'c', 'd' } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new char[] { 'a', 'b' }, [EOL]             ArrayUtils.addAll( new char[] { 'a', 'b' }, null ) ) ); [EOL]  [EOL]         // byte [EOL]         assertTrue( Arrays.equals( new byte[] { (byte) 0, (byte) 1, (byte) 2, (byte) 3 }, [EOL]             ArrayUtils.addAll( new byte[] { (byte) 0, (byte) 1 }, new byte[] { (byte) 2, (byte) 3 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new byte[] { (byte) 2, (byte) 3 }, [EOL]             ArrayUtils.addAll( null, new byte[] { (byte) 2, (byte) 3 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new byte[] { (byte) 0, (byte) 1 }, [EOL]             ArrayUtils.addAll( new byte[] { (byte) 0, (byte) 1 }, null ) ) ); [EOL]  [EOL]         // short [EOL]         assertTrue( Arrays.equals( new short[] { (short) 10, (short) 20, (short) 30, (short) 40 }, [EOL]             ArrayUtils.addAll( new short[] { (short) 10, (short) 20 }, new short[] { (short) 30, (short) 40 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new short[] { (short) 30, (short) 40 }, [EOL]             ArrayUtils.addAll( null, new short[] { (short) 30, (short) 40 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new short[] { (short) 10, (short) 20 }, [EOL]             ArrayUtils.addAll( new short[] { (short) 10, (short) 20 }, null ) ) ); [EOL]  [EOL]         // int [EOL]         assertTrue( Arrays.equals( new int[] { 1, 1000, -1000, -1 }, [EOL]             ArrayUtils.addAll( new int[] { 1, 1000 }, new int[] { -1000, -1 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new int[] { -1000, -1 }, [EOL]             ArrayUtils.addAll( null, new int[] { -1000, -1 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new int[] { 1, 1000 }, [EOL]             ArrayUtils.addAll( new int[] { 1, 1000 }, null ) ) ); [EOL]  [EOL]         // long [EOL]         assertTrue( Arrays.equals( new long[] { 1L, -1L, 1000L, -1000L }, [EOL]             ArrayUtils.addAll( new long[] { 1L, -1L }, new long[] { 1000L, -1000L } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new long[] { 1000L, -1000L }, [EOL]             ArrayUtils.addAll( null, new long[] { 1000L, -1000L } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new long[] { 1L, -1L }, [EOL]             ArrayUtils.addAll( new long[] { 1L, -1L }, null ) ) ); [EOL]  [EOL]         // float [EOL]         assertTrue( Arrays.equals( new float[] { 10.5f, 10.1f, 1.6f, 0.01f }, [EOL]             ArrayUtils.addAll( new float[] { 10.5f, 10.1f }, new float[] { 1.6f, 0.01f } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new float[] { 1.6f, 0.01f }, [EOL]             ArrayUtils.addAll( null, new float[] { 1.6f, 0.01f } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new float[] { 10.5f, 10.1f }, [EOL]             ArrayUtils.addAll( new float[] { 10.5f, 10.1f }, null ) ) ); [EOL]  [EOL]         // double [EOL]         assertTrue( Arrays.equals( new double[] { Math.PI, -Math.PI, 0, 9.99 }, [EOL]             ArrayUtils.addAll( new double[] { Math.PI, -Math.PI }, new double[] { 0, 9.99 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new double[] { 0, 9.99 }, [EOL]             ArrayUtils.addAll( null, new double[] { 0, 9.99 } ) ) ); [EOL]  [EOL]         assertTrue( Arrays.equals( new double[] { Math.PI, -Math.PI }, [EOL]             ArrayUtils.addAll( new double[] { Math.PI, -Math.PI }, null ) ) ); [EOL]  [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLANG571(){ [EOL]         final String[] stringArray=null; [EOL]         final String aString=null; [EOL]         try { [EOL]             @SuppressWarnings("unused") [EOL]             final [EOL]             String[] sa = ArrayUtils.add(stringArray, aString); [EOL]             fail("Should have caused IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException iae){ [EOL]             //expected [EOL]         } [EOL]         try { [EOL]             @SuppressWarnings("unused") [EOL]             final [EOL]             String[] sa = ArrayUtils.add(stringArray, 0, aString); [EOL]             fail("Should have caused IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException iae){ [EOL]             //expected [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLANG571(){ [EOL]         final String[] stringArray=null; [EOL]         final String aString=null; [EOL]         try { [EOL]             @SuppressWarnings("unused") [EOL]             final [EOL]             String[] sa = ArrayUtils.add(stringArray, aString); [EOL]             fail("Should have caused IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException iae){ [EOL]             //expected [EOL]         } [EOL]         try { [EOL]             @SuppressWarnings("unused") [EOL]             final [EOL]             String[] sa = ArrayUtils.add(stringArray, 0, aString); [EOL]             fail("Should have caused IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException iae){ [EOL]             //expected [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testAddObjectAtIndex() { [EOL]         Object[] newArray; [EOL]         newArray = ArrayUtils.add((Object[])null, 0, "a"); [EOL]         assertTrue(Arrays.equals(new String[]{"a"}, newArray)); [EOL]         assertTrue(Arrays.equals(new Object[]{"a"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         final String[] stringArray1 = new String[]{"a", "b", "c"}; [EOL]         newArray = ArrayUtils.add(stringArray1, 0, null); [EOL]         assertTrue(Arrays.equals(new String[]{null, "a", "b", "c"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.add(stringArray1, 1, null); [EOL]         assertTrue(Arrays.equals(new String[]{"a", null, "b", "c"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.add(stringArray1, 3, null); [EOL]         assertTrue(Arrays.equals(new String[]{"a", "b", "c", null}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.add(stringArray1, 3, "d"); [EOL]         assertTrue(Arrays.equals(new String[]{"a", "b", "c", "d"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]  [EOL]         final Object[] o = new Object[] {"1", "2", "4"}; [EOL]         final Object[] result = ArrayUtils.add(o, 2, "3"); [EOL]         final Object[] result2 = ArrayUtils.add(o, 3, "5"); [EOL]  [EOL]         assertNotNull(result); [EOL]         assertEquals(4, result.length); [EOL]         assertEquals("1", result[0]); [EOL]         assertEquals("2", result[1]); [EOL]         assertEquals("3", result[2]); [EOL]         assertEquals("4", result[3]); [EOL]         assertNotNull(result2); [EOL]         assertEquals(4, result2.length); [EOL]         assertEquals("1", result2[0]); [EOL]         assertEquals("2", result2[1]); [EOL]         assertEquals("4", result2[2]); [EOL]         assertEquals("5", result2[3]); [EOL]  [EOL]         // boolean tests [EOL]         boolean[] booleanArray = ArrayUtils.add( null, 0, true ); [EOL]         assertTrue( Arrays.equals( new boolean[] { true }, booleanArray ) ); [EOL]         try { [EOL]             booleanArray = ArrayUtils.add( null, -1, true ); [EOL]         } catch(final IndexOutOfBoundsException e) { [EOL]             assertEquals("Index: -1, Length: 0", e.getMessage()); [EOL]         } [EOL]         booleanArray = ArrayUtils.add( new boolean[] { true }, 0, false); [EOL]         assertTrue( Arrays.equals( new boolean[] { false, true }, booleanArray ) ); [EOL]         booleanArray = ArrayUtils.add( new boolean[] { false }, 1, true); [EOL]         assertTrue( Arrays.equals( new boolean[] { false, true }, booleanArray ) ); [EOL]         booleanArray = ArrayUtils.add( new boolean[] { true, false }, 1, true); [EOL]         assertTrue( Arrays.equals( new boolean[] { true, true, false }, booleanArray ) ); [EOL]         try { [EOL]             booleanArray = ArrayUtils.add( new boolean[] { true, false }, 4, true); [EOL]         } catch(final IndexOutOfBoundsException e) { [EOL]             assertEquals("Index: 4, Length: 2", e.getMessage()); [EOL]         } [EOL]         try { [EOL]             booleanArray = ArrayUtils.add( new boolean[] { true, false }, -1, true); [EOL]         } catch(final IndexOutOfBoundsException e) { [EOL]             assertEquals("Index: -1, Length: 2", e.getMessage()); [EOL]         } [EOL]  [EOL]         // char tests [EOL]         char[] charArray = ArrayUtils.add( (char[]) null, 0, 'a' ); [EOL]         assertTrue( Arrays.equals( new char[] { 'a' }, charArray ) ); [EOL]         try { [EOL]             charArray = ArrayUtils.add( (char[]) null, -1, 'a' ); [EOL]         } catch(final IndexOutOfBoundsException e) { [EOL]             assertEquals("Index: -1, Length: 0", e.getMessage()); [EOL]         } [EOL]         charArray = ArrayUtils.add( new char[] { 'a' }, 0, 'b'); [EOL]         assertTrue( Arrays.equals( new char[] { 'b', 'a' }, charArray ) ); [EOL]         charArray = ArrayUtils.add( new char[] { 'a', 'b' }, 0, 'c'); [EOL]         assertTrue( Arrays.equals( new char[] { 'c', 'a', 'b' }, charArray ) ); [EOL]         charArray = ArrayUtils.add( new char[] { 'a', 'b' }, 1, 'k'); [EOL]         assertTrue( Arrays.equals( new char[] { 'a', 'k', 'b' }, charArray ) ); [EOL]         charArray = ArrayUtils.add( new char[] { 'a', 'b', 'c' }, 1, 't'); [EOL]         assertTrue( Arrays.equals( new char[] { 'a', 't', 'b', 'c' }, charArray ) ); [EOL]         try { [EOL]             charArray = ArrayUtils.add( new char[] { 'a', 'b' }, 4, 'c'); [EOL]         } catch(final IndexOutOfBoundsException e) { [EOL]             assertEquals("Index: 4, Length: 2", e.getMessage()); [EOL]         } [EOL]         try { [EOL]             charArray = ArrayUtils.add( new char[] { 'a', 'b' }, -1, 'c'); [EOL]         } catch(final IndexOutOfBoundsException e) { [EOL]             assertEquals("Index: -1, Length: 2", e.getMessage()); [EOL]         } [EOL]  [EOL]         // short tests [EOL]         short[] shortArray = ArrayUtils.add( new short[] { 1 }, 0, (short) 2); [EOL]         assertTrue( Arrays.equals( new short[] { 2, 1 }, shortArray ) ); [EOL]         try { [EOL]             shortArray = ArrayUtils.add( (short[]) null, -1, (short) 2); [EOL]         } catch(final IndexOutOfBoundsException e) { [EOL]             assertEquals("Index: -1, Length: 0", e.getMessage()); [EOL]         } [EOL]         shortArray = ArrayUtils.add( new short[] { 2, 6 }, 2, (short) 10); [EOL]         assertTrue( Arrays.equals( new short[] { 2, 6, 10 }, shortArray ) ); [EOL]         shortArray = ArrayUtils.add( new short[] { 2, 6 }, 0, (short) -4); [EOL]         assertTrue( Arrays.equals( new short[] { -4, 2, 6 }, shortArray ) ); [EOL]         shortArray = ArrayUtils.add( new short[] { 2, 6, 3 }, 2, (short) 1); [EOL]         assertTrue( Arrays.equals( new short[] { 2, 6, 1, 3 }, shortArray ) ); [EOL]         try { [EOL]             shortArray = ArrayUtils.add( new short[] { 2, 6 }, 4, (short) 10); [EOL]         } catch(final IndexOutOfBoundsException e) { [EOL]             assertEquals("Index: 4, Length: 2", e.getMessage()); [EOL]         } [EOL]         try { [EOL]             shortArray = ArrayUtils.add( new short[] { 2, 6 }, -1, (short) 10); [EOL]         } catch(final IndexOutOfBoundsException e) { [EOL]             assertEquals("Index: -1, Length: 2", e.getMessage()); [EOL]         } [EOL]  [EOL]         // byte tests [EOL]         byte[] byteArray = ArrayUtils.add( new byte[] { 1 }, 0, (byte) 2); [EOL]         assertTrue( Arrays.equals( new byte[] { 2, 1 }, byteArray ) ); [EOL]         try { [EOL]             byteArray = ArrayUtils.add( (byte[]) null, -1, (byte) 2); [EOL]         } catch(final IndexOutOfBoundsException e) { [EOL]             assertEquals("Index: -1, Length: 0", e.getMessage()); [EOL]         } [EOL]         byteArray = ArrayUtils.add( new byte[] { 2, 6 }, 2, (byte) 3); [EOL]         assertTrue( Arrays.equals( new byte[] { 2, 6, 3 }, byteArray ) ); [EOL]         byteArray = ArrayUtils.add( new byte[] { 2, 6 }, 0, (byte) 1); [EOL]         assertTrue( Arrays.equals( new byte[] { 1, 2, 6 }, byteArray ) ); [EOL]         byteArray = ArrayUtils.add( new byte[] { 2, 6, 3 }, 2, (byte) 1); [EOL]         assertTrue( Arrays.equals( new byte[] { 2, 6, 1, 3 }, byteArray ) ); [EOL]         try { [EOL]             byteArray = ArrayUtils.add( new byte[] { 2, 6 }, 4, (byte) 3); [EOL]         } catch(final IndexOutOfBoundsException e) { [EOL]             assertEquals("Index: 4, Length: 2", e.getMessage()); [EOL]         } [EOL]         try { [EOL]             byteArray = ArrayUtils.add( new byte[] { 2, 6 }, -1, (byte) 3); [EOL]         } catch(final IndexOutOfBoundsException e) { [EOL]             assertEquals("Index: -1, Length: 2", e.getMessage()); [EOL]         } [EOL]  [EOL]         // int tests [EOL]         int[] intArray = ArrayUtils.add( new int[] { 1 }, 0, 2); [EOL]         assertTrue( Arrays.equals( new int[] { 2, 1 }, intArray ) ); [EOL]         try { [EOL]             intArray = ArrayUtils.add( (int[]) null, -1, 2); [EOL]         } catch(final IndexOutOfBoundsException e) { [EOL]             assertEquals("Index: -1, Length: 0", e.getMessage()); [EOL]         } [EOL]         intArray = ArrayUtils.add( new int[] { 2, 6 }, 2, 10); [EOL]         assertTrue( Arrays.equals( new int[] { 2, 6, 10 }, intArray ) ); [EOL]         intArray = ArrayUtils.add( new int[] { 2, 6 }, 0, -4); [EOL]         assertTrue( Arrays.equals( new int[] { -4, 2, 6 }, intArray ) ); [EOL]         intArray = ArrayUtils.add( new int[] { 2, 6, 3 }, 2, 1); [EOL]         assertTrue( Arrays.equals( new int[] { 2, 6, 1, 3 }, intArray ) ); [EOL]         try { [EOL]             intArray = ArrayUtils.add( new int[] { 2, 6 }, 4, 10); [EOL]         } catch(final IndexOutOfBoundsException e) { [EOL]             assertEquals("Index: 4, Length: 2", e.getMessage()); [EOL]         } [EOL]         try { [EOL]             intArray = ArrayUtils.add( new int[] { 2, 6 }, -1, 10); [EOL]         } catch(final IndexOutOfBoundsException e) { [EOL]             assertEquals("Index: -1, Length: 2", e.getMessage()); [EOL]         } [EOL]  [EOL]         // long tests [EOL]         long[] longArray = ArrayUtils.add( new long[] { 1L }, 0, 2L); [EOL]         assertTrue( Arrays.equals( new long[] { 2L, 1L }, longArray ) ); [EOL]         try { [EOL]             longArray = ArrayUtils.add( (long[]) null, -1, 2L); [EOL]         } catch(final IndexOutOfBoundsException e) { [EOL]             assertEquals("Index: -1, Length: 0", e.getMessage()); [EOL]         } [EOL]         longArray = ArrayUtils.add( new long[] { 2L, 6L }, 2, 10L); [EOL]         assertTrue( Arrays.equals( new long[] { 2L, 6L, 10L }, longArray ) ); [EOL]         longArray = ArrayUtils.add( new long[] { 2L, 6L }, 0, -4L); [EOL]         assertTrue( Arrays.equals( new long[] { -4L, 2L, 6L }, longArray ) ); [EOL]         longArray = ArrayUtils.add( new long[] { 2L, 6L, 3L }, 2, 1L); [EOL]         assertTrue( Arrays.equals( new long[] { 2L, 6L, 1L, 3L }, longArray ) ); [EOL]         try { [EOL]             longArray = ArrayUtils.add( new long[] { 2L, 6L }, 4, 10L); [EOL]         } catch(final IndexOutOfBoundsException e) { [EOL]             assertEquals("Index: 4, Length: 2", e.getMessage()); [EOL]         } [EOL]         try { [EOL]             longArray = ArrayUtils.add( new long[] { 2L, 6L }, -1, 10L); [EOL]         } catch(final IndexOutOfBoundsException e) { [EOL]             assertEquals("Index: -1, Length: 2", e.getMessage()); [EOL]         } [EOL]  [EOL]         // float tests [EOL]         float[] floatArray = ArrayUtils.add( new float[] { 1.1f }, 0, 2.2f); [EOL]         assertTrue( Arrays.equals( new float[] { 2.2f, 1.1f }, floatArray ) ); [EOL]         try { [EOL]             floatArray = ArrayUtils.add( (float[]) null, -1, 2.2f); [EOL]         } catch(final IndexOutOfBoundsException e) { [EOL]             assertEquals("Index: -1, Length: 0", e.getMessage()); [EOL]         } [EOL]         floatArray = ArrayUtils.add( new float[] { 2.3f, 6.4f }, 2, 10.5f); [EOL]         assertTrue( Arrays.equals( new float[] { 2.3f, 6.4f, 10.5f }, floatArray ) ); [EOL]         floatArray = ArrayUtils.add( new float[] { 2.6f, 6.7f }, 0, -4.8f); [EOL]         assertTrue( Arrays.equals( new float[] { -4.8f, 2.6f, 6.7f }, floatArray ) ); [EOL]         floatArray = ArrayUtils.add( new float[] { 2.9f, 6.0f, 0.3f }, 2, 1.0f); [EOL]         assertTrue( Arrays.equals( new float[] { 2.9f, 6.0f, 1.0f, 0.3f }, floatArray ) ); [EOL]         try { [EOL]             floatArray = ArrayUtils.add( new float[] { 2.3f, 6.4f }, 4, 10.5f); [EOL]         } catch(final IndexOutOfBoundsException e) { [EOL]             assertEquals("Index: 4, Length: 2", e.getMessage()); [EOL]         } [EOL]         try { [EOL]             floatArray = ArrayUtils.add( new float[] { 2.3f, 6.4f }, -1, 10.5f); [EOL]         } catch(final IndexOutOfBoundsException e) { [EOL]             assertEquals("Index: -1, Length: 2", e.getMessage()); [EOL]         } [EOL]  [EOL]         // double tests [EOL]         double[] doubleArray = ArrayUtils.add( new double[] { 1.1 }, 0, 2.2); [EOL]         assertTrue( Arrays.equals( new double[] { 2.2, 1.1 }, doubleArray ) ); [EOL]         try { [EOL]           doubleArray = ArrayUtils.add( (double[]) null, -1, 2.2); [EOL]         } catch(final IndexOutOfBoundsException e) { [EOL]             assertEquals("Index: -1, Length: 0", e.getMessage()); [EOL]         } [EOL]         doubleArray = ArrayUtils.add( new double[] { 2.3, 6.4 }, 2, 10.5); [EOL]         assertTrue( Arrays.equals( new double[] { 2.3, 6.4, 10.5 }, doubleArray ) ); [EOL]         doubleArray = ArrayUtils.add( new double[] { 2.6, 6.7 }, 0, -4.8); [EOL]         assertTrue( Arrays.equals( new double[] { -4.8, 2.6, 6.7 }, doubleArray ) ); [EOL]         doubleArray = ArrayUtils.add( new double[] { 2.9, 6.0, 0.3 }, 2, 1.0); [EOL]         assertTrue( Arrays.equals( new double[] { 2.9, 6.0, 1.0, 0.3 }, doubleArray ) ); [EOL]         try { [EOL]             doubleArray = ArrayUtils.add( new double[] { 2.3, 6.4 }, 4, 10.5); [EOL]         } catch(final IndexOutOfBoundsException e) { [EOL]             assertEquals("Index: 4, Length: 2", e.getMessage()); [EOL]         } [EOL]         try { [EOL]             doubleArray = ArrayUtils.add( new double[] { 2.3, 6.4 }, -1, 10.5); [EOL]         } catch(final IndexOutOfBoundsException e) { [EOL]             assertEquals("Index: -1, Length: 2", e.getMessage()); [EOL]         } [EOL]     } [EOL]  [EOL] } [EOL]
@Test [EOL]     public void testLANG571(){ [EOL]         final String[] stringArray=null; [EOL]         final String aString=null; [EOL]         try { [EOL]             @SuppressWarnings("unused") [EOL]             final [EOL]             String[] sa = ArrayUtils.add(stringArray, aString); [EOL]             fail("Should have caused IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException iae){ [EOL]             //expected [EOL]         } [EOL]         try { [EOL]             @SuppressWarnings("unused") [EOL]             final [EOL]             String[] sa = ArrayUtils.add(stringArray, 0, aString); [EOL]             fail("Should have caused IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException iae){ [EOL]             //expected [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testAddObjectAtIndex() { [EOL]         Object[] newArray; [EOL]         newArray = ArrayUtils.add((Object[])null, 0, "a"); [EOL]         assertTrue(Arrays.equals(new String[]{"a"}, newArray)); [EOL]         assertTrue(Arrays.equals(new Object[]{"a"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         final String[] stringArray1 = new String[]{"a", "b", "c"}; [EOL]         newArray = ArrayUtils.add(stringArray1, 0, null); [EOL]         assertTrue(Arrays.equals(new String[]{null, "a", "b", "c"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.add(stringArray1, 1, null); [EOL]         assertTrue(Arrays.equals(new String[]{"a", null, "b", "c"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.add(stringArray1, 3, null); [EOL]         assertTrue(Arrays.equals(new String[]{"a", "b", "c", null}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.add(stringArray1, 3, "d"); [EOL]         assertTrue(Arrays.equals(new String[]{"a", "b", "c", "d"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]  [EOL]         final Object[] o = new Object[] {"1", "2", "4"}; [EOL]         final Object[] result = ArrayUtils.add(o, 2, "3"); [EOL]         final Object[] result2 = ArrayUtils.add(o, 3, "5"); [EOL]  [EOL]         assertNotNull(result); [EOL]         assertEquals(4, result.length); [EOL]         assertEquals("1", result[0]); [EOL]         assertEquals("2", result[1]); [EOL]         assertEquals("3", result[2]); [EOL]         assertEquals("4", result[3]); [EOL]         assertNotNull(result2); [EOL]         assertEquals(4, result2.length); [EOL]         assertEquals("1", result2[0]); [EOL]         assertEquals("2", result2[1]); [EOL]         assertEquals("4", result2[2]); [EOL]         assertEquals("5", result2[3]); [EOL]  [EOL]         // boolean tests [EOL]         boolean[] booleanArray = ArrayUtils.add( null, 0, true ); [EOL]         assertTrue( Arrays.equals( new boolean[] { true }, booleanArray ) ); [EOL]         try { [EOL]             booleanArray = ArrayUtils.add( null, -1, true ); [EOL]         } catch(final IndexOutOfBoundsException e) { [EOL]             assertEquals("Index: -1, Length: 0", e.getMessage()); [EOL]         } [EOL]         booleanArray = ArrayUtils.add( new boolean[] { true }, 0, false); [EOL]         assertTrue( Arrays.equals( new boolean[] { false, true }, booleanArray ) ); [EOL]         booleanArray = ArrayUtils.add( new boolean[] { false }, 1, true); [EOL]         assertTrue( Arrays.equals( new boolean[] { false, true }, booleanArray ) ); [EOL]         booleanArray = ArrayUtils.add( new boolean[] { true, false }, 1, true); [EOL]         assertTrue( Arrays.equals( new boolean[] { true, true, false }, booleanArray ) ); [EOL]         try { [EOL]             booleanArray = ArrayUtils.add( new boolean[] { true, false }, 4, true); [EOL]         } catch(final IndexOutOfBoundsException e) { [EOL]             assertEquals("Index: 4, Length: 2", e.getMessage()); [EOL]         } [EOL]         try { [EOL]             booleanArray = ArrayUtils.add( new boolean[] { true, false }, -1, true); [EOL]         } catch(final IndexOutOfBoundsException e) { [EOL]             assertEquals("Index: -1, Length: 2", e.getMessage()); [EOL]         } [EOL]  [EOL]         // char tests [EOL]         char[] charArray = ArrayUtils.add( (char[]) null, 0, 'a' ); [EOL]         assertTrue( Arrays.equals( new char[] { 'a' }, charArray ) ); [EOL]         try { [EOL]             charArray = ArrayUtils.add( (char[]) null, -1, 'a' ); [EOL]         } catch(final IndexOutOfBoundsException e) { [EOL]             assertEquals("Index: -1, Length: 0", e.getMessage()); [EOL]         } [EOL]         charArray = ArrayUtils.add( new char[] { 'a' }, 0, 'b'); [EOL]         assertTrue( Arrays.equals( new char[] { 'b', 'a' }, charArray ) ); [EOL]         charArray = ArrayUtils.add( new char[] { 'a', 'b' }, 0, 'c'); [EOL]         assertTrue( Arrays.equals( new char[] { 'c', 'a', 'b' }, charArray ) ); [EOL]         charArray = ArrayUtils.add( new char[] { 'a', 'b' }, 1, 'k'); [EOL]         assertTrue( Arrays.equals( new char[] { 'a', 'k', 'b' }, charArray ) ); [EOL]         charArray = ArrayUtils.add( new char[] { 'a', 'b', 'c' }, 1, 't'); [EOL]         assertTrue( Arrays.equals( new char[] { 'a', 't', 'b', 'c' }, charArray ) ); [EOL]         try { [EOL]             charArray = ArrayUtils.add( new char[] { 'a', 'b' }, 4, 'c'); [EOL]         } catch(final IndexOutOfBoundsException e) { [EOL]             assertEquals("Index: 4, Length: 2", e.getMessage()); [EOL]         } [EOL]         try { [EOL]             charArray = ArrayUtils.add( new char[] { 'a', 'b' }, -1, 'c'); [EOL]         } catch(final IndexOutOfBoundsException e) { [EOL]             assertEquals("Index: -1, Length: 2", e.getMessage()); [EOL]         } [EOL]  [EOL]         // short tests [EOL]         short[] shortArray = ArrayUtils.add( new short[] { 1 }, 0, (short) 2); [EOL]         assertTrue( Arrays.equals( new short[] { 2, 1 }, shortArray ) ); [EOL]         try { [EOL]             shortArray = ArrayUtils.add( (short[]) null, -1, (short) 2); [EOL]         } catch(final IndexOutOfBoundsException e) { [EOL]             assertEquals("Index: -1, Length: 0", e.getMessage()); [EOL]         } [EOL]         shortArray = ArrayUtils.add( new short[] { 2, 6 }, 2, (short) 10); [EOL]         assertTrue( Arrays.equals( new short[] { 2, 6, 10 }, shortArray ) ); [EOL]         shortArray = ArrayUtils.add( new short[] { 2, 6 }, 0, (short) -4); [EOL]         assertTrue( Arrays.equals( new short[] { -4, 2, 6 }, shortArray ) ); [EOL]         shortArray = ArrayUtils.add( new short[] { 2, 6, 3 }, 2, (short) 1); [EOL]         assertTrue( Arrays.equals( new short[] { 2, 6, 1, 3 }, shortArray ) ); [EOL]         try { [EOL]             shortArray = ArrayUtils.add( new short[] { 2, 6 }, 4, (short) 10); [EOL]         } catch(final IndexOutOfBoundsException e) { [EOL]             assertEquals("Index: 4, Length: 2", e.getMessage()); [EOL]         } [EOL]         try { [EOL]             shortArray = ArrayUtils.add( new short[] { 2, 6 }, -1, (short) 10); [EOL]         } catch(final IndexOutOfBoundsException e) { [EOL]             assertEquals("Index: -1, Length: 2", e.getMessage()); [EOL]         } [EOL]  [EOL]         // byte tests [EOL]         byte[] byteArray = ArrayUtils.add( new byte[] { 1 }, 0, (byte) 2); [EOL]         assertTrue( Arrays.equals( new byte[] { 2, 1 }, byteArray ) ); [EOL]         try { [EOL]             byteArray = ArrayUtils.add( (byte[]) null, -1, (byte) 2); [EOL]         } catch(final IndexOutOfBoundsException e) { [EOL]             assertEquals("Index: -1, Length: 0", e.getMessage()); [EOL]         } [EOL]         byteArray = ArrayUtils.add( new byte[] { 2, 6 }, 2, (byte) 3); [EOL]         assertTrue( Arrays.equals( new byte[] { 2, 6, 3 }, byteArray ) ); [EOL]         byteArray = ArrayUtils.add( new byte[] { 2, 6 }, 0, (byte) 1); [EOL]         assertTrue( Arrays.equals( new byte[] { 1, 2, 6 }, byteArray ) ); [EOL]         byteArray = ArrayUtils.add( new byte[] { 2, 6, 3 }, 2, (byte) 1); [EOL]         assertTrue( Arrays.equals( new byte[] { 2, 6, 1, 3 }, byteArray ) ); [EOL]         try { [EOL]             byteArray = ArrayUtils.add( new byte[] { 2, 6 }, 4, (byte) 3); [EOL]         } catch(final IndexOutOfBoundsException e) { [EOL]             assertEquals("Index: 4, Length: 2", e.getMessage()); [EOL]         } [EOL]         try { [EOL]             byteArray = ArrayUtils.add( new byte[] { 2, 6 }, -1, (byte) 3); [EOL]         } catch(final IndexOutOfBoundsException e) { [EOL]             assertEquals("Index: -1, Length: 2", e.getMessage()); [EOL]         } [EOL]  [EOL]         // int tests [EOL]         int[] intArray = ArrayUtils.add( new int[] { 1 }, 0, 2); [EOL]         assertTrue( Arrays.equals( new int[] { 2, 1 }, intArray ) ); [EOL]         try { [EOL]             intArray = ArrayUtils.add( (int[]) null, -1, 2); [EOL]         } catch(final IndexOutOfBoundsException e) { [EOL]             assertEquals("Index: -1, Length: 0", e.getMessage()); [EOL]         } [EOL]         intArray = ArrayUtils.add( new int[] { 2, 6 }, 2, 10); [EOL]         assertTrue( Arrays.equals( new int[] { 2, 6, 10 }, intArray ) ); [EOL]         intArray = ArrayUtils.add( new int[] { 2, 6 }, 0, -4); [EOL]         assertTrue( Arrays.equals( new int[] { -4, 2, 6 }, intArray ) ); [EOL]         intArray = ArrayUtils.add( new int[] { 2, 6, 3 }, 2, 1); [EOL]         assertTrue( Arrays.equals( new int[] { 2, 6, 1, 3 }, intArray ) ); [EOL]         try { [EOL]             intArray = ArrayUtils.add( new int[] { 2, 6 }, 4, 10); [EOL]         } catch(final IndexOutOfBoundsException e) { [EOL]             assertEquals("Index: 4, Length: 2", e.getMessage()); [EOL]         } [EOL]         try { [EOL]             intArray = ArrayUtils.add( new int[] { 2, 6 }, -1, 10); [EOL]         } catch(final IndexOutOfBoundsException e) { [EOL]             assertEquals("Index: -1, Length: 2", e.getMessage()); [EOL]         } [EOL]  [EOL]         // long tests [EOL]         long[] longArray = ArrayUtils.add( new long[] { 1L }, 0, 2L); [EOL]         assertTrue( Arrays.equals( new long[] { 2L, 1L }, longArray ) ); [EOL]         try { [EOL]             longArray = ArrayUtils.add( (long[]) null, -1, 2L); [EOL]         } catch(final IndexOutOfBoundsException e) { [EOL]             assertEquals("Index: -1, Length: 0", e.getMessage()); [EOL]         } [EOL]         longArray = ArrayUtils.add( new long[] { 2L, 6L }, 2, 10L); [EOL]         assertTrue( Arrays.equals( new long[] { 2L, 6L, 10L }, longArray ) ); [EOL]         longArray = ArrayUtils.add( new long[] { 2L, 6L }, 0, -4L); [EOL]         assertTrue( Arrays.equals( new long[] { -4L, 2L, 6L }, longArray ) ); [EOL]         longArray = ArrayUtils.add( new long[] { 2L, 6L, 3L }, 2, 1L); [EOL]         assertTrue( Arrays.equals( new long[] { 2L, 6L, 1L, 3L }, longArray ) ); [EOL]         try { [EOL]             longArray = ArrayUtils.add( new long[] { 2L, 6L }, 4, 10L); [EOL]         } catch(final IndexOutOfBoundsException e) { [EOL]             assertEquals("Index: 4, Length: 2", e.getMessage()); [EOL]         } [EOL]         try { [EOL]             longArray = ArrayUtils.add( new long[] { 2L, 6L }, -1, 10L); [EOL]         } catch(final IndexOutOfBoundsException e) { [EOL]             assertEquals("Index: -1, Length: 2", e.getMessage()); [EOL]         } [EOL]  [EOL]         // float tests [EOL]         float[] floatArray = ArrayUtils.add( new float[] { 1.1f }, 0, 2.2f); [EOL]         assertTrue( Arrays.equals( new float[] { 2.2f, 1.1f }, floatArray ) ); [EOL]         try { [EOL]             floatArray = ArrayUtils.add( (float[]) null, -1, 2.2f); [EOL]         } catch(final IndexOutOfBoundsException e) { [EOL]             assertEquals("Index: -1, Length: 0", e.getMessage()); [EOL]         } [EOL]         floatArray = ArrayUtils.add( new float[] { 2.3f, 6.4f }, 2, 10.5f); [EOL]         assertTrue( Arrays.equals( new float[] { 2.3f, 6.4f, 10.5f }, floatArray ) ); [EOL]         floatArray = ArrayUtils.add( new float[] { 2.6f, 6.7f }, 0, -4.8f); [EOL]         assertTrue( Arrays.equals( new float[] { -4.8f, 2.6f, 6.7f }, floatArray ) ); [EOL]         floatArray = ArrayUtils.add( new float[] { 2.9f, 6.0f, 0.3f }, 2, 1.0f); [EOL]         assertTrue( Arrays.equals( new float[] { 2.9f, 6.0f, 1.0f, 0.3f }, floatArray ) ); [EOL]         try { [EOL]             floatArray = ArrayUtils.add( new float[] { 2.3f, 6.4f }, 4, 10.5f); [EOL]         } catch(final IndexOutOfBoundsException e) { [EOL]             assertEquals("Index: 4, Length: 2", e.getMessage()); [EOL]         } [EOL]         try { [EOL]             floatArray = ArrayUtils.add( new float[] { 2.3f, 6.4f }, -1, 10.5f); [EOL]         } catch(final IndexOutOfBoundsException e) { [EOL]             assertEquals("Index: -1, Length: 2", e.getMessage()); [EOL]         } [EOL]  [EOL]         // double tests [EOL]         double[] doubleArray = ArrayUtils.add( new double[] { 1.1 }, 0, 2.2); [EOL]         assertTrue( Arrays.equals( new double[] { 2.2, 1.1 }, doubleArray ) ); [EOL]         try { [EOL]           doubleArray = ArrayUtils.add( (double[]) null, -1, 2.2); [EOL]         } catch(final IndexOutOfBoundsException e) { [EOL]             assertEquals("Index: -1, Length: 0", e.getMessage()); [EOL]         } [EOL]         doubleArray = ArrayUtils.add( new double[] { 2.3, 6.4 }, 2, 10.5); [EOL]         assertTrue( Arrays.equals( new double[] { 2.3, 6.4, 10.5 }, doubleArray ) ); [EOL]         doubleArray = ArrayUtils.add( new double[] { 2.6, 6.7 }, 0, -4.8); [EOL]         assertTrue( Arrays.equals( new double[] { -4.8, 2.6, 6.7 }, doubleArray ) ); [EOL]         doubleArray = ArrayUtils.add( new double[] { 2.9, 6.0, 0.3 }, 2, 1.0); [EOL]         assertTrue( Arrays.equals( new double[] { 2.9, 6.0, 1.0, 0.3 }, doubleArray ) ); [EOL]         try { [EOL]             doubleArray = ArrayUtils.add( new double[] { 2.3, 6.4 }, 4, 10.5); [EOL]         } catch(final IndexOutOfBoundsException e) { [EOL]             assertEquals("Index: 4, Length: 2", e.getMessage()); [EOL]         } [EOL]         try { [EOL]             doubleArray = ArrayUtils.add( new double[] { 2.3, 6.4 }, -1, 10.5); [EOL]         } catch(final IndexOutOfBoundsException e) { [EOL]             assertEquals("Index: -1, Length: 2", e.getMessage()); [EOL]         } [EOL]     } [EOL]  [EOL] } [EOL]
@Test [EOL]     public void testRemoveElementObjectArray() { [EOL]         Object[] array; [EOL]         array = ArrayUtils.removeElement((Object[]) null, "a"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElement(ArrayUtils.EMPTY_OBJECT_ARRAY, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElement(new Object[] {"a"}, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElement(new Object[] {"a", "b"}, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] {"b"}, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElement(new Object[] {"a", "b", "a"}, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] {"b", "a"}, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testRemoveElementIntArray() { [EOL]         int[] array; [EOL]         array = ArrayUtils.removeElement((int[]) null, 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElement(ArrayUtils.EMPTY_INT_ARRAY, 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_INT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElement(new int[] {1}, 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_INT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElement(new int[] {1, 2}, 1); [EOL]         assertTrue(Arrays.equals(new int[] {2}, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElement(new int[] {1, 2, 1}, 1); [EOL]         assertTrue(Arrays.equals(new int[] {2, 1}, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testRemoveElementsObjectArray() { [EOL]         Object[] array; [EOL]         array = ArrayUtils.removeElements((Object[]) null, "a"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a" }, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b", "a" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((Object[]) null, "a", "b"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a", "b"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a" }, "a", "b"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b" }, "a", "c"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b", "a" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a", "b"); [EOL]         assertTrue(Arrays.equals(new Object[] { "a" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a", "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a", "a", "a", "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testRemoveElementsObjectArray() { [EOL]         Object[] array; [EOL]         array = ArrayUtils.removeElements((Object[]) null, "a"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a" }, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b", "a" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((Object[]) null, "a", "b"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a", "b"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a" }, "a", "b"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b" }, "a", "c"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b", "a" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a", "b"); [EOL]         assertTrue(Arrays.equals(new Object[] { "a" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a", "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a", "a", "a", "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testRemoveElementsObjectArray() { [EOL]         Object[] array; [EOL]         array = ArrayUtils.removeElements((Object[]) null, "a"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a" }, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b", "a" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((Object[]) null, "a", "b"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a", "b"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a" }, "a", "b"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b" }, "a", "c"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b", "a" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a", "b"); [EOL]         assertTrue(Arrays.equals(new Object[] { "a" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a", "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a", "a", "a", "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testRemoveElementsObjectArray() { [EOL]         Object[] array; [EOL]         array = ArrayUtils.removeElements((Object[]) null, "a"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a" }, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b", "a" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((Object[]) null, "a", "b"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a", "b"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a" }, "a", "b"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b" }, "a", "c"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b", "a" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a", "b"); [EOL]         assertTrue(Arrays.equals(new Object[] { "a" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a", "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a", "a", "a", "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testRemoveElementsObjectArray() { [EOL]         Object[] array; [EOL]         array = ArrayUtils.removeElements((Object[]) null, "a"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a" }, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b", "a" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((Object[]) null, "a", "b"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a", "b"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a" }, "a", "b"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b" }, "a", "c"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b", "a" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a", "b"); [EOL]         assertTrue(Arrays.equals(new Object[] { "a" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a", "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a", "a", "a", "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testRemoveElementsObjectArray() { [EOL]         Object[] array; [EOL]         array = ArrayUtils.removeElements((Object[]) null, "a"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a" }, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b", "a" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((Object[]) null, "a", "b"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a", "b"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a" }, "a", "b"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b" }, "a", "c"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b", "a" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a", "b"); [EOL]         assertTrue(Arrays.equals(new Object[] { "a" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a", "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a", "a", "a", "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testRemoveElementsObjectArray() { [EOL]         Object[] array; [EOL]         array = ArrayUtils.removeElements((Object[]) null, "a"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a" }, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b", "a" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((Object[]) null, "a", "b"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a", "b"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a" }, "a", "b"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b" }, "a", "c"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b", "a" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a", "b"); [EOL]         assertTrue(Arrays.equals(new Object[] { "a" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a", "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a", "a", "a", "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testRemoveElementsObjectArray() { [EOL]         Object[] array; [EOL]         array = ArrayUtils.removeElements((Object[]) null, "a"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a" }, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b", "a" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((Object[]) null, "a", "b"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a", "b"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a" }, "a", "b"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b" }, "a", "c"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b", "a" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a", "b"); [EOL]         assertTrue(Arrays.equals(new Object[] { "a" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a", "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a", "a", "a", "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testRemoveElementsObjectArray() { [EOL]         Object[] array; [EOL]         array = ArrayUtils.removeElements((Object[]) null, "a"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a" }, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b", "a" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((Object[]) null, "a", "b"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a", "b"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a" }, "a", "b"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b" }, "a", "c"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b", "a" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a", "b"); [EOL]         assertTrue(Arrays.equals(new Object[] { "a" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a", "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a", "a", "a", "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testRemoveElementsObjectArray() { [EOL]         Object[] array; [EOL]         array = ArrayUtils.removeElements((Object[]) null, "a"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a" }, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b", "a" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((Object[]) null, "a", "b"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a", "b"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a" }, "a", "b"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b" }, "a", "c"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b", "a" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a", "b"); [EOL]         assertTrue(Arrays.equals(new Object[] { "a" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a", "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a", "a", "a", "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testRemoveElementsObjectArray() { [EOL]         Object[] array; [EOL]         array = ArrayUtils.removeElements((Object[]) null, "a"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a" }, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b", "a" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((Object[]) null, "a", "b"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a", "b"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a" }, "a", "b"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b" }, "a", "c"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b", "a" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a", "b"); [EOL]         assertTrue(Arrays.equals(new Object[] { "a" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a", "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a", "a", "a", "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testRemoveElementsObjectArray() { [EOL]         Object[] array; [EOL]         array = ArrayUtils.removeElements((Object[]) null, "a"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a" }, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b", "a" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((Object[]) null, "a", "b"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a", "b"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a" }, "a", "b"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b" }, "a", "c"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b", "a" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a", "b"); [EOL]         assertTrue(Arrays.equals(new Object[] { "a" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a", "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a", "a", "a", "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testRemoveElementsObjectArray() { [EOL]         Object[] array; [EOL]         array = ArrayUtils.removeElements((Object[]) null, "a"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a" }, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b", "a" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((Object[]) null, "a", "b"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a", "b"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a" }, "a", "b"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b" }, "a", "c"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b", "a" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a", "b"); [EOL]         assertTrue(Arrays.equals(new Object[] { "a" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a", "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a", "a", "a", "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testRemoveElementsObjectArray() { [EOL]         Object[] array; [EOL]         array = ArrayUtils.removeElements((Object[]) null, "a"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a" }, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b", "a" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((Object[]) null, "a", "b"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a", "b"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a" }, "a", "b"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b" }, "a", "c"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b", "a" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a", "b"); [EOL]         assertTrue(Arrays.equals(new Object[] { "a" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a", "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a", "a", "a", "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testRemoveElementsObjectArray() { [EOL]         Object[] array; [EOL]         array = ArrayUtils.removeElements((Object[]) null, "a"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a" }, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b", "a" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((Object[]) null, "a", "b"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a", "b"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a" }, "a", "b"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b" }, "a", "c"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b", "a" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a", "b"); [EOL]         assertTrue(Arrays.equals(new Object[] { "a" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a", "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a", "a", "a", "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testRemoveElementsObjectArray() { [EOL]         Object[] array; [EOL]         array = ArrayUtils.removeElements((Object[]) null, "a"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a" }, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b", "a" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((Object[]) null, "a", "b"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a", "b"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a" }, "a", "b"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b" }, "a", "c"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b", "a" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a", "b"); [EOL]         assertTrue(Arrays.equals(new Object[] { "a" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a", "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a", "a", "a", "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testRemoveElementsObjectArray() { [EOL]         Object[] array; [EOL]         array = ArrayUtils.removeElements((Object[]) null, "a"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a" }, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b", "a" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((Object[]) null, "a", "b"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a", "b"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a" }, "a", "b"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b" }, "a", "c"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b", "a" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a", "b"); [EOL]         assertTrue(Arrays.equals(new Object[] { "a" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a", "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a", "a", "a", "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testRemoveElementsObjectArray() { [EOL]         Object[] array; [EOL]         array = ArrayUtils.removeElements((Object[]) null, "a"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a" }, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b", "a" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((Object[]) null, "a", "b"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a", "b"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a" }, "a", "b"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b" }, "a", "c"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b", "a" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a", "b"); [EOL]         assertTrue(Arrays.equals(new Object[] { "a" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a", "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a", "a", "a", "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testRemoveElementsObjectArray() { [EOL]         Object[] array; [EOL]         array = ArrayUtils.removeElements((Object[]) null, "a"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a" }, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b", "a" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((Object[]) null, "a", "b"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a", "b"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a" }, "a", "b"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b" }, "a", "c"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b", "a" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a", "b"); [EOL]         assertTrue(Arrays.equals(new Object[] { "a" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a", "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a", "a", "a", "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testRemoveElementsObjectArray() { [EOL]         Object[] array; [EOL]         array = ArrayUtils.removeElements((Object[]) null, "a"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a" }, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b", "a" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((Object[]) null, "a", "b"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a", "b"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a" }, "a", "b"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b" }, "a", "c"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b", "a" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a", "b"); [EOL]         assertTrue(Arrays.equals(new Object[] { "a" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a", "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a", "a", "a", "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Object.class, array.getClass().getComponentType()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testRemoveElementByteArray() { [EOL]         byte[] array; [EOL]         array = ArrayUtils.removeElements((byte[]) null, (byte) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2, 1 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((byte[]) null, (byte) 1, (byte) 2); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1, (byte) 2); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1, (byte) 2); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1, (byte) 2); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1, (byte) 2); [EOL]         assertTrue(Arrays.equals(new byte[] { 1 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1, (byte) 1, (byte) 1, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testRemoveElementByteArray() { [EOL]         byte[] array; [EOL]         array = ArrayUtils.removeElements((byte[]) null, (byte) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2, 1 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((byte[]) null, (byte) 1, (byte) 2); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1, (byte) 2); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1, (byte) 2); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1, (byte) 2); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1, (byte) 2); [EOL]         assertTrue(Arrays.equals(new byte[] { 1 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1, (byte) 1, (byte) 1, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testRemoveElementShortArray() { [EOL]         short[] array; [EOL]         array = ArrayUtils.removeElements((short[]) null, (short) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_SHORT_ARRAY, (short) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]         assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new short[] { 1 }, (short) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]         assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new short[] { 1, 2 }, (short) 1); [EOL]         assertTrue(Arrays.equals(new short[] { 2 }, array)); [EOL]         assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new short[] { 1, 2, 1 }, (short) 1); [EOL]         assertTrue(Arrays.equals(new short[] { 2, 1 }, array)); [EOL]         assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((short[]) null, (short) 1, (short) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_SHORT_ARRAY, (short) 1, (short) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]         assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new short[] { 1 }, (short) 1, (short) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]         assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new short[] { 1, 2 }, (short) 1, (short) 2); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]         assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new short[] { 1, 2 }, (short) 1, (short) 1); [EOL]         assertTrue(Arrays.equals(new short[] { 2 }, array)); [EOL]         assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new short[] { 1, 2, 1 }, (short) 1, (short) 1); [EOL]         assertTrue(Arrays.equals(new short[] { 2 }, array)); [EOL]         assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new short[] { 1, 2, 1 }, (short) 1, (short) 2); [EOL]         assertTrue(Arrays.equals(new short[] { 1 }, array)); [EOL]         assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new short[] { 1, 2, 1 }, (short) 1, (short) 1, (short) 1, (short) 1); [EOL]         assertTrue(Arrays.equals(new short[] { 2 }, array)); [EOL]         assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     } [EOL]  [EOL] } [EOL]
@Test [EOL]     public void testRemoveElementIntArray() { [EOL]         int[] array; [EOL]         array = ArrayUtils.removeElements((int[]) null, 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_INT_ARRAY, 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_INT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new int[] { 1 }, 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_INT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new int[] { 1, 2 }, 1); [EOL]         assertTrue(Arrays.equals(new int[] { 2 }, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new int[] { 1, 2, 1 }, 1); [EOL]         assertTrue(Arrays.equals(new int[] { 2, 1 }, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((int[]) null, 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_INT_ARRAY, 1, 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_INT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new int[] { 1 }, 1, 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_INT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new int[] { 1, 2 }, 1, 2); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_INT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new int[] { 1, 2 }, 1, 1); [EOL]         assertTrue(Arrays.equals(new int[] { 2 }, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new int[] { 1, 2, 1 }, 1, 2); [EOL]         assertTrue(Arrays.equals(new int[] { 1 }, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new int[] { 1, 2, 1 }, 1, 1); [EOL]         assertTrue(Arrays.equals(new int[] { 2 }, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new int[] { 1, 2, 1 }, 1, 1, 1, 1); [EOL]         assertTrue(Arrays.equals(new int[] { 2 }, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testRemoveElementCharArray() { [EOL]         char[] array; [EOL]         array = ArrayUtils.removeElements((char[]) null, 'a'); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_CHAR_ARRAY, 'a'); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]         assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new char[] { 'a' }, 'a'); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]         assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new char[] { 'a', 'b' }, 'a'); [EOL]         assertTrue(Arrays.equals(new char[] { 'b' }, array)); [EOL]         assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new char[] { 'a', 'b', 'a' }, 'a'); [EOL]         assertTrue(Arrays.equals(new char[] { 'b', 'a' }, array)); [EOL]         assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((char[]) null, 'a', 'b'); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_CHAR_ARRAY, 'a', 'b'); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]         assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new char[] { 'a' }, 'a', 'b'); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]         assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new char[] { 'a', 'b' }, 'a', 'b'); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]         assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new char[] { 'a', 'b' }, 'a', 'a'); [EOL]         assertTrue(Arrays.equals(new char[] { 'b' }, array)); [EOL]         assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new char[] { 'a', 'b', 'a' }, 'a', 'b'); [EOL]         assertTrue(Arrays.equals(new char[] { 'a' }, array)); [EOL]         assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new char[] { 'a', 'b', 'a' }, 'a', 'a'); [EOL]         assertTrue(Arrays.equals(new char[] { 'b' }, array)); [EOL]         assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new char[] { 'a', 'b', 'a' }, 'a', 'a', 'a', 'a'); [EOL]         assertTrue(Arrays.equals(new char[] { 'b' }, array)); [EOL]         assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     @SuppressWarnings("cast") [EOL]     public void testRemoveElementLongArray() { [EOL]         long[] array; [EOL]         array = ArrayUtils.removeElements((long[]) null, (long) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_LONG_ARRAY, (long) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_LONG_ARRAY, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new long[] { 1 }, (long) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_LONG_ARRAY, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new long[] { 1, 2 }, (long) 1); [EOL]         assertTrue(Arrays.equals(new long[] { 2 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new long[] { 1, 2, 1 }, (long) 1); [EOL]         assertTrue(Arrays.equals(new long[] { 2, 1 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((long[]) null, (long) 1, (long) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_LONG_ARRAY, (long) 1, (long) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_LONG_ARRAY, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new long[] { 1 }, (long) 1, (long) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_LONG_ARRAY, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new long[] { 1, 2 }, (long) 1, (long) 2); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_LONG_ARRAY, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new long[] { 1, 2 }, (long) 1, (long) 1); [EOL]         assertTrue(Arrays.equals(new long[] { 2 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new long[] { 1, 2, 1 }, (long) 1, (long) 1); [EOL]         assertTrue(Arrays.equals(new long[] { 2 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new long[] { 1, 2, 1 }, (long) 1, (long) 2); [EOL]         assertTrue(Arrays.equals(new long[] { 1 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new long[] { 1, 2, 1 }, (long) 1, (long) 1, (long) 1, (long) 1); [EOL]         assertTrue(Arrays.equals(new long[] { 2 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     @SuppressWarnings("cast") [EOL]     public void testRemoveElementFloatArray() { [EOL]         float[] array; [EOL]         array = ArrayUtils.removeElements((float[]) null, (float) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_FLOAT_ARRAY, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1 }, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1, 2 }, (float) 1); [EOL]         assertTrue(Arrays.equals(new float[] { 2 }, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1, 2, 1 }, (float) 1); [EOL]         assertTrue(Arrays.equals(new float[] { 2, 1 }, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((float[]) null, (float) 1, (float) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_FLOAT_ARRAY, (float) 1, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1 }, (float) 1, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1, 2 }, (float) 1, (float) 2); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1, 2 }, (float) 1, (float) 1); [EOL]         assertTrue(Arrays.equals(new float[] { 2 }, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1, 2, 1 }, (float) 1, (float) 1); [EOL]         assertTrue(Arrays.equals(new float[] { 2 }, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1, 2, 1 }, (float) 1, (float) 2); [EOL]         assertTrue(Arrays.equals(new float[] { 1 }, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1, 2, 1 }, (float) 1, (float) 1, (float) 1, (float) 1); [EOL]         assertTrue(Arrays.equals(new float[] { 2 }, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     @SuppressWarnings("cast") [EOL]     public void testRemoveElementDoubleArray() { [EOL]         double[] array; [EOL]         array = ArrayUtils.removeElements((double[]) null, (double) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_DOUBLE_ARRAY, (double) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_DOUBLE_ARRAY, array)); [EOL]         assertEquals(Double.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new double[] { 1 }, (double) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_DOUBLE_ARRAY, array)); [EOL]         assertEquals(Double.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new double[] { 1, 2 }, (double) 1); [EOL]         assertTrue(Arrays.equals(new double[] { 2 }, array)); [EOL]         assertEquals(Double.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new double[] { 1, 2, 1 }, (double) 1); [EOL]         assertTrue(Arrays.equals(new double[] { 2, 1 }, array)); [EOL]         assertEquals(Double.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((double[]) null, (double) 1, (double) 2); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_DOUBLE_ARRAY, (double) 1, (double) 2); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_DOUBLE_ARRAY, array)); [EOL]         assertEquals(Double.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new double[] { 1 }, (double) 1, (double) 2); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_DOUBLE_ARRAY, array)); [EOL]         assertEquals(Double.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new double[] { 1, 2 }, (double) 1, (double) 2); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_DOUBLE_ARRAY, array)); [EOL]         assertEquals(Double.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new double[] { 1, 2 }, (double) 1, (double) 1); [EOL]         assertTrue(Arrays.equals(new double[] { 2 }, array)); [EOL]         assertEquals(Double.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new double[] { 1, 2, 1 }, (double) 1, (double) 2); [EOL]         assertTrue(Arrays.equals(new double[] { 1 }, array)); [EOL]         assertEquals(Double.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new double[] { 1, 2, 1 }, (double) 1, (double) 1); [EOL]         assertTrue(Arrays.equals(new double[] { 2 }, array)); [EOL]         assertEquals(Double.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new double[] { 1, 2, 1 }, (double) 1, (double) 1, (double) 1, (double) 1); [EOL]         assertTrue(Arrays.equals(new double[] { 2 }, array)); [EOL]         assertEquals(Double.TYPE, array.getClass().getComponentType()); [EOL]     } [EOL]  [EOL]
@Test(expected = IndexOutOfBoundsException.class) [EOL]     public void testRemoveAllBooleanArrayOutOfBoundsIndex() { [EOL]         ArrayUtils.removeAll(new boolean[] { true, false }, 2); [EOL]     } [EOL]  [EOL]
@Test(expected = IndexOutOfBoundsException.class) [EOL]     public void testRemoveAllBooleanArrayOutOfBoundsIndex() { [EOL]         ArrayUtils.removeAll(new boolean[] { true, false }, 2); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testRemoveElementBooleanArray() { [EOL]         boolean[] array; [EOL]         array = ArrayUtils.removeElements((boolean[]) null, true); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BOOLEAN_ARRAY, true); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BOOLEAN_ARRAY, array)); [EOL]         assertEquals(Boolean.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new boolean[] { true }, true); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BOOLEAN_ARRAY, array)); [EOL]         assertEquals(Boolean.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new boolean[] { true, false }, true); [EOL]         assertTrue(Arrays.equals(new boolean[] { false }, array)); [EOL]         assertEquals(Boolean.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new boolean[] { true, false, true }, true); [EOL]         assertTrue(Arrays.equals(new boolean[] { false, true }, array)); [EOL]         assertEquals(Boolean.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((boolean[]) null, true, false); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BOOLEAN_ARRAY, true, false); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BOOLEAN_ARRAY, array)); [EOL]         assertEquals(Boolean.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new boolean[] { true }, true, false); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BOOLEAN_ARRAY, array)); [EOL]         assertEquals(Boolean.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new boolean[] { true, false }, true, false); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BOOLEAN_ARRAY, array)); [EOL]         assertEquals(Boolean.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new boolean[] { true, false }, true, true); [EOL]         assertTrue(Arrays.equals(new boolean[] { false }, array)); [EOL]         assertEquals(Boolean.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new boolean[] { true, false, true }, true, false); [EOL]         assertTrue(Arrays.equals(new boolean[] { true }, array)); [EOL]         assertEquals(Boolean.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new boolean[] { true, false, true }, true, true); [EOL]         assertTrue(Arrays.equals(new boolean[] { false }, array)); [EOL]         assertEquals(Boolean.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new boolean[] { true, false, true }, true, true, true, true); [EOL]         assertTrue(Arrays.equals(new boolean[] { false }, array)); [EOL]         assertEquals(Boolean.TYPE, array.getClass().getComponentType()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testRemoveAllDoubleArray() { [EOL]         double[] array; [EOL]         array = ArrayUtils.removeAll(new double[] { 1 }, 0); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_DOUBLE_ARRAY, array)); [EOL]         assertEquals(Double.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new double[] { 1, 2 }, 0); [EOL]         assertTrue(Arrays.equals(new double[] { 2 }, array)); [EOL]         assertEquals(Double.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new double[] { 1, 2 }, 1); [EOL]         assertTrue(Arrays.equals(new double[] { 1 }, array)); [EOL]         assertEquals(Double.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new double[] { 1, 2, 1 }, 1); [EOL]         assertTrue(Arrays.equals(new double[] { 1, 1 }, array)); [EOL]         assertEquals(Double.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeAll(new double[] { 1, 2 }, 0, 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_DOUBLE_ARRAY, array)); [EOL]         assertEquals(Double.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new double[] { 1, 2, 3 }, 0, 1); [EOL]         assertTrue(Arrays.equals(new double[] { 3 }, array)); [EOL]         assertEquals(Double.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new double[] { 1, 2, 3 }, 1, 2); [EOL]         assertTrue(Arrays.equals(new double[] { 1 }, array)); [EOL]         assertEquals(Double.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new double[] { 1, 2, 3 }, 0, 2); [EOL]         assertTrue(Arrays.equals(new double[] { 2 }, array)); [EOL]         assertEquals(Double.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new double[] { 1, 2, 3, 4, 5 }, 1, 3); [EOL]         assertTrue(Arrays.equals(new double[] { 1, 3, 5 }, array)); [EOL]         assertEquals(Double.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new double[] { 1, 2, 3, 4, 5 }, 0, 2, 4); [EOL]         assertTrue(Arrays.equals(new double[] { 2, 4 }, array)); [EOL]         assertEquals(Double.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new double[] { 1, 2, 3, 4, 5, 6, 7 }, 1, 3, 5); [EOL]         assertTrue(Arrays.equals(new double[] { 1, 3, 5, 7 }, array)); [EOL]         assertEquals(Double.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new double[] { 1, 2, 3, 4, 5, 6, 7 }, 0, 2, 4, 6); [EOL]         assertTrue(Arrays.equals(new double[] { 2, 4, 6 }, array)); [EOL]         assertEquals(Double.TYPE, array.getClass().getComponentType()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testRemoveElementByteArray() { [EOL]         byte[] array; [EOL]         array = ArrayUtils.removeElements((byte[]) null, (byte) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2, 1 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((byte[]) null, (byte) 1, (byte) 2); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1, (byte) 2); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1, (byte) 2); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1, (byte) 2); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1, (byte) 2); [EOL]         assertTrue(Arrays.equals(new byte[] { 1 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1, (byte) 1, (byte) 1, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testRemoveElementByteArray() { [EOL]         byte[] array; [EOL]         array = ArrayUtils.removeElements((byte[]) null, (byte) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2, 1 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((byte[]) null, (byte) 1, (byte) 2); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1, (byte) 2); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1, (byte) 2); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1, (byte) 2); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1, (byte) 2); [EOL]         assertTrue(Arrays.equals(new byte[] { 1 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1, (byte) 1, (byte) 1, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testRemoveElementByteArray() { [EOL]         byte[] array; [EOL]         array = ArrayUtils.removeElements((byte[]) null, (byte) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2, 1 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((byte[]) null, (byte) 1, (byte) 2); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1, (byte) 2); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1, (byte) 2); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1, (byte) 2); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1, (byte) 2); [EOL]         assertTrue(Arrays.equals(new byte[] { 1 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1, (byte) 1, (byte) 1, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLang865() { [EOL]         assertValidToLocale("_GB", "", "GB", ""); [EOL]         assertValidToLocale("_GB_P", "", "GB", "P"); [EOL]         assertValidToLocale("_GB_POSIX", "", "GB", "POSIX"); [EOL]         try { [EOL]             LocaleUtils.toLocale("_G"); [EOL]             fail("Must be at least 3 chars if starts with underscore"); [EOL]         } catch (final IllegalArgumentException iae) { [EOL]         } [EOL]         try { [EOL]             LocaleUtils.toLocale("_Gb"); [EOL]             fail("Must be uppercase if starts with underscore"); [EOL]         } catch (final IllegalArgumentException iae) { [EOL]         } [EOL]         try { [EOL]             LocaleUtils.toLocale("_gB"); [EOL]             fail("Must be uppercase if starts with underscore"); [EOL]         } catch (final IllegalArgumentException iae) { [EOL]         } [EOL]         try { [EOL]             LocaleUtils.toLocale("_1B"); [EOL]             fail("Must be letter if starts with underscore"); [EOL]         } catch (final IllegalArgumentException iae) { [EOL]         } [EOL]         try { [EOL]             LocaleUtils.toLocale("_G1"); [EOL]             fail("Must be letter if starts with underscore"); [EOL]         } catch (final IllegalArgumentException iae) { [EOL]         } [EOL]         try { [EOL]             LocaleUtils.toLocale("_GB_"); [EOL]             fail("Must be at least 5 chars if starts with underscore"); [EOL]         } catch (final IllegalArgumentException iae) { [EOL]         } [EOL]         try { [EOL]             LocaleUtils.toLocale("_GBAP"); [EOL]             fail("Must have underscore after the country if starts with underscore and is at least 5 chars"); [EOL]         } catch (final IllegalArgumentException iae) { [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLang865() { [EOL]         assertValidToLocale("_GB", "", "GB", ""); [EOL]         assertValidToLocale("_GB_P", "", "GB", "P"); [EOL]         assertValidToLocale("_GB_POSIX", "", "GB", "POSIX"); [EOL]         try { [EOL]             LocaleUtils.toLocale("_G"); [EOL]             fail("Must be at least 3 chars if starts with underscore"); [EOL]         } catch (final IllegalArgumentException iae) { [EOL]         } [EOL]         try { [EOL]             LocaleUtils.toLocale("_Gb"); [EOL]             fail("Must be uppercase if starts with underscore"); [EOL]         } catch (final IllegalArgumentException iae) { [EOL]         } [EOL]         try { [EOL]             LocaleUtils.toLocale("_gB"); [EOL]             fail("Must be uppercase if starts with underscore"); [EOL]         } catch (final IllegalArgumentException iae) { [EOL]         } [EOL]         try { [EOL]             LocaleUtils.toLocale("_1B"); [EOL]             fail("Must be letter if starts with underscore"); [EOL]         } catch (final IllegalArgumentException iae) { [EOL]         } [EOL]         try { [EOL]             LocaleUtils.toLocale("_G1"); [EOL]             fail("Must be letter if starts with underscore"); [EOL]         } catch (final IllegalArgumentException iae) { [EOL]         } [EOL]         try { [EOL]             LocaleUtils.toLocale("_GB_"); [EOL]             fail("Must be at least 5 chars if starts with underscore"); [EOL]         } catch (final IllegalArgumentException iae) { [EOL]         } [EOL]         try { [EOL]             LocaleUtils.toLocale("_GBAP"); [EOL]             fail("Must have underscore after the country if starts with underscore and is at least 5 chars"); [EOL]         } catch (final IllegalArgumentException iae) { [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLang865() { [EOL]         assertValidToLocale("_GB", "", "GB", ""); [EOL]         assertValidToLocale("_GB_P", "", "GB", "P"); [EOL]         assertValidToLocale("_GB_POSIX", "", "GB", "POSIX"); [EOL]         try { [EOL]             LocaleUtils.toLocale("_G"); [EOL]             fail("Must be at least 3 chars if starts with underscore"); [EOL]         } catch (final IllegalArgumentException iae) { [EOL]         } [EOL]         try { [EOL]             LocaleUtils.toLocale("_Gb"); [EOL]             fail("Must be uppercase if starts with underscore"); [EOL]         } catch (final IllegalArgumentException iae) { [EOL]         } [EOL]         try { [EOL]             LocaleUtils.toLocale("_gB"); [EOL]             fail("Must be uppercase if starts with underscore"); [EOL]         } catch (final IllegalArgumentException iae) { [EOL]         } [EOL]         try { [EOL]             LocaleUtils.toLocale("_1B"); [EOL]             fail("Must be letter if starts with underscore"); [EOL]         } catch (final IllegalArgumentException iae) { [EOL]         } [EOL]         try { [EOL]             LocaleUtils.toLocale("_G1"); [EOL]             fail("Must be letter if starts with underscore"); [EOL]         } catch (final IllegalArgumentException iae) { [EOL]         } [EOL]         try { [EOL]             LocaleUtils.toLocale("_GB_"); [EOL]             fail("Must be at least 5 chars if starts with underscore"); [EOL]         } catch (final IllegalArgumentException iae) { [EOL]         } [EOL]         try { [EOL]             LocaleUtils.toLocale("_GBAP"); [EOL]             fail("Must have underscore after the country if starts with underscore and is at least 5 chars"); [EOL]         } catch (final IllegalArgumentException iae) { [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLang865() { [EOL]         assertValidToLocale("_GB", "", "GB", ""); [EOL]         assertValidToLocale("_GB_P", "", "GB", "P"); [EOL]         assertValidToLocale("_GB_POSIX", "", "GB", "POSIX"); [EOL]         try { [EOL]             LocaleUtils.toLocale("_G"); [EOL]             fail("Must be at least 3 chars if starts with underscore"); [EOL]         } catch (final IllegalArgumentException iae) { [EOL]         } [EOL]         try { [EOL]             LocaleUtils.toLocale("_Gb"); [EOL]             fail("Must be uppercase if starts with underscore"); [EOL]         } catch (final IllegalArgumentException iae) { [EOL]         } [EOL]         try { [EOL]             LocaleUtils.toLocale("_gB"); [EOL]             fail("Must be uppercase if starts with underscore"); [EOL]         } catch (final IllegalArgumentException iae) { [EOL]         } [EOL]         try { [EOL]             LocaleUtils.toLocale("_1B"); [EOL]             fail("Must be letter if starts with underscore"); [EOL]         } catch (final IllegalArgumentException iae) { [EOL]         } [EOL]         try { [EOL]             LocaleUtils.toLocale("_G1"); [EOL]             fail("Must be letter if starts with underscore"); [EOL]         } catch (final IllegalArgumentException iae) { [EOL]         } [EOL]         try { [EOL]             LocaleUtils.toLocale("_GB_"); [EOL]             fail("Must be at least 5 chars if starts with underscore"); [EOL]         } catch (final IllegalArgumentException iae) { [EOL]         } [EOL]         try { [EOL]             LocaleUtils.toLocale("_GBAP"); [EOL]             fail("Must have underscore after the country if starts with underscore and is at least 5 chars"); [EOL]         } catch (final IllegalArgumentException iae) { [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLang865() { [EOL]         assertValidToLocale("_GB", "", "GB", ""); [EOL]         assertValidToLocale("_GB_P", "", "GB", "P"); [EOL]         assertValidToLocale("_GB_POSIX", "", "GB", "POSIX"); [EOL]         try { [EOL]             LocaleUtils.toLocale("_G"); [EOL]             fail("Must be at least 3 chars if starts with underscore"); [EOL]         } catch (final IllegalArgumentException iae) { [EOL]         } [EOL]         try { [EOL]             LocaleUtils.toLocale("_Gb"); [EOL]             fail("Must be uppercase if starts with underscore"); [EOL]         } catch (final IllegalArgumentException iae) { [EOL]         } [EOL]         try { [EOL]             LocaleUtils.toLocale("_gB"); [EOL]             fail("Must be uppercase if starts with underscore"); [EOL]         } catch (final IllegalArgumentException iae) { [EOL]         } [EOL]         try { [EOL]             LocaleUtils.toLocale("_1B"); [EOL]             fail("Must be letter if starts with underscore"); [EOL]         } catch (final IllegalArgumentException iae) { [EOL]         } [EOL]         try { [EOL]             LocaleUtils.toLocale("_G1"); [EOL]             fail("Must be letter if starts with underscore"); [EOL]         } catch (final IllegalArgumentException iae) { [EOL]         } [EOL]         try { [EOL]             LocaleUtils.toLocale("_GB_"); [EOL]             fail("Must be at least 5 chars if starts with underscore"); [EOL]         } catch (final IllegalArgumentException iae) { [EOL]         } [EOL]         try { [EOL]             LocaleUtils.toLocale("_GBAP"); [EOL]             fail("Must have underscore after the country if starts with underscore and is at least 5 chars"); [EOL]         } catch (final IllegalArgumentException iae) { [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLang865() { [EOL]         assertValidToLocale("_GB", "", "GB", ""); [EOL]         assertValidToLocale("_GB_P", "", "GB", "P"); [EOL]         assertValidToLocale("_GB_POSIX", "", "GB", "POSIX"); [EOL]         try { [EOL]             LocaleUtils.toLocale("_G"); [EOL]             fail("Must be at least 3 chars if starts with underscore"); [EOL]         } catch (final IllegalArgumentException iae) { [EOL]         } [EOL]         try { [EOL]             LocaleUtils.toLocale("_Gb"); [EOL]             fail("Must be uppercase if starts with underscore"); [EOL]         } catch (final IllegalArgumentException iae) { [EOL]         } [EOL]         try { [EOL]             LocaleUtils.toLocale("_gB"); [EOL]             fail("Must be uppercase if starts with underscore"); [EOL]         } catch (final IllegalArgumentException iae) { [EOL]         } [EOL]         try { [EOL]             LocaleUtils.toLocale("_1B"); [EOL]             fail("Must be letter if starts with underscore"); [EOL]         } catch (final IllegalArgumentException iae) { [EOL]         } [EOL]         try { [EOL]             LocaleUtils.toLocale("_G1"); [EOL]             fail("Must be letter if starts with underscore"); [EOL]         } catch (final IllegalArgumentException iae) { [EOL]         } [EOL]         try { [EOL]             LocaleUtils.toLocale("_GB_"); [EOL]             fail("Must be at least 5 chars if starts with underscore"); [EOL]         } catch (final IllegalArgumentException iae) { [EOL]         } [EOL]         try { [EOL]             LocaleUtils.toLocale("_GBAP"); [EOL]             fail("Must have underscore after the country if starts with underscore and is at least 5 chars"); [EOL]         } catch (final IllegalArgumentException iae) { [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLang865() { [EOL]         assertValidToLocale("_GB", "", "GB", ""); [EOL]         assertValidToLocale("_GB_P", "", "GB", "P"); [EOL]         assertValidToLocale("_GB_POSIX", "", "GB", "POSIX"); [EOL]         try { [EOL]             LocaleUtils.toLocale("_G"); [EOL]             fail("Must be at least 3 chars if starts with underscore"); [EOL]         } catch (final IllegalArgumentException iae) { [EOL]         } [EOL]         try { [EOL]             LocaleUtils.toLocale("_Gb"); [EOL]             fail("Must be uppercase if starts with underscore"); [EOL]         } catch (final IllegalArgumentException iae) { [EOL]         } [EOL]         try { [EOL]             LocaleUtils.toLocale("_gB"); [EOL]             fail("Must be uppercase if starts with underscore"); [EOL]         } catch (final IllegalArgumentException iae) { [EOL]         } [EOL]         try { [EOL]             LocaleUtils.toLocale("_1B"); [EOL]             fail("Must be letter if starts with underscore"); [EOL]         } catch (final IllegalArgumentException iae) { [EOL]         } [EOL]         try { [EOL]             LocaleUtils.toLocale("_G1"); [EOL]             fail("Must be letter if starts with underscore"); [EOL]         } catch (final IllegalArgumentException iae) { [EOL]         } [EOL]         try { [EOL]             LocaleUtils.toLocale("_GB_"); [EOL]             fail("Must be at least 5 chars if starts with underscore"); [EOL]         } catch (final IllegalArgumentException iae) { [EOL]         } [EOL]         try { [EOL]             LocaleUtils.toLocale("_GBAP"); [EOL]             fail("Must have underscore after the country if starts with underscore and is at least 5 chars"); [EOL]         } catch (final IllegalArgumentException iae) { [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLang865() { [EOL]         assertValidToLocale("_GB", "", "GB", ""); [EOL]         assertValidToLocale("_GB_P", "", "GB", "P"); [EOL]         assertValidToLocale("_GB_POSIX", "", "GB", "POSIX"); [EOL]         try { [EOL]             LocaleUtils.toLocale("_G"); [EOL]             fail("Must be at least 3 chars if starts with underscore"); [EOL]         } catch (final IllegalArgumentException iae) { [EOL]         } [EOL]         try { [EOL]             LocaleUtils.toLocale("_Gb"); [EOL]             fail("Must be uppercase if starts with underscore"); [EOL]         } catch (final IllegalArgumentException iae) { [EOL]         } [EOL]         try { [EOL]             LocaleUtils.toLocale("_gB"); [EOL]             fail("Must be uppercase if starts with underscore"); [EOL]         } catch (final IllegalArgumentException iae) { [EOL]         } [EOL]         try { [EOL]             LocaleUtils.toLocale("_1B"); [EOL]             fail("Must be letter if starts with underscore"); [EOL]         } catch (final IllegalArgumentException iae) { [EOL]         } [EOL]         try { [EOL]             LocaleUtils.toLocale("_G1"); [EOL]             fail("Must be letter if starts with underscore"); [EOL]         } catch (final IllegalArgumentException iae) { [EOL]         } [EOL]         try { [EOL]             LocaleUtils.toLocale("_GB_"); [EOL]             fail("Must be at least 5 chars if starts with underscore"); [EOL]         } catch (final IllegalArgumentException iae) { [EOL]         } [EOL]         try { [EOL]             LocaleUtils.toLocale("_GBAP"); [EOL]             fail("Must have underscore after the country if starts with underscore and is at least 5 chars"); [EOL]         } catch (final IllegalArgumentException iae) { [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testToLocale_2Part() { [EOL]         assertValidToLocale("us_EN", "us", "EN"); [EOL]         //valid though doesnt exist [EOL]         assertValidToLocale("us_ZH", "us", "ZH"); [EOL]          [EOL]         try { [EOL]             LocaleUtils.toLocale("us-EN"); [EOL]             fail("Should fail as not underscore"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("us_En"); [EOL]             fail("Should fail second part not uppercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("us_en"); [EOL]             fail("Should fail second part not uppercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("us_eN"); [EOL]             fail("Should fail second part not uppercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("uS_EN"); [EOL]             fail("Should fail first part not lowercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("us_E3"); [EOL]             fail("Should fail second part not uppercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]     }         [EOL]  [EOL]     /** [EOL]      * Test toLocale() method. [EOL]      */ [EOL]
@Test [EOL]     public void testToLocale_2Part() { [EOL]         assertValidToLocale("us_EN", "us", "EN"); [EOL]         //valid though doesnt exist [EOL]         assertValidToLocale("us_ZH", "us", "ZH"); [EOL]          [EOL]         try { [EOL]             LocaleUtils.toLocale("us-EN"); [EOL]             fail("Should fail as not underscore"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("us_En"); [EOL]             fail("Should fail second part not uppercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("us_en"); [EOL]             fail("Should fail second part not uppercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("us_eN"); [EOL]             fail("Should fail second part not uppercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("uS_EN"); [EOL]             fail("Should fail first part not lowercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("us_E3"); [EOL]             fail("Should fail second part not uppercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]     }         [EOL]  [EOL]     /** [EOL]      * Test toLocale() method. [EOL]      */ [EOL]
@Test [EOL]     public void testLang328() { [EOL]         assertValidToLocale("fr__P", "fr", "", "P"); [EOL]         assertValidToLocale("fr__POSIX", "fr", "", "POSIX"); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests #LANG-865, strings starting with an underscore. [EOL]      */ [EOL]
@Test [EOL]     public void testToLocale_2Part() { [EOL]         assertValidToLocale("us_EN", "us", "EN"); [EOL]         //valid though doesnt exist [EOL]         assertValidToLocale("us_ZH", "us", "ZH"); [EOL]          [EOL]         try { [EOL]             LocaleUtils.toLocale("us-EN"); [EOL]             fail("Should fail as not underscore"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("us_En"); [EOL]             fail("Should fail second part not uppercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("us_en"); [EOL]             fail("Should fail second part not uppercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("us_eN"); [EOL]             fail("Should fail second part not uppercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("uS_EN"); [EOL]             fail("Should fail first part not lowercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("us_E3"); [EOL]             fail("Should fail second part not uppercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]     }         [EOL]  [EOL]     /** [EOL]      * Test toLocale() method. [EOL]      */ [EOL]
@Test [EOL]     public void testToLocale_2Part() { [EOL]         assertValidToLocale("us_EN", "us", "EN"); [EOL]         //valid though doesnt exist [EOL]         assertValidToLocale("us_ZH", "us", "ZH"); [EOL]          [EOL]         try { [EOL]             LocaleUtils.toLocale("us-EN"); [EOL]             fail("Should fail as not underscore"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("us_En"); [EOL]             fail("Should fail second part not uppercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("us_en"); [EOL]             fail("Should fail second part not uppercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("us_eN"); [EOL]             fail("Should fail second part not uppercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("uS_EN"); [EOL]             fail("Should fail first part not lowercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("us_E3"); [EOL]             fail("Should fail second part not uppercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]     }         [EOL]  [EOL]     /** [EOL]      * Test toLocale() method. [EOL]      */ [EOL]
@Test [EOL]     public void testToLocale_2Part() { [EOL]         assertValidToLocale("us_EN", "us", "EN"); [EOL]         //valid though doesnt exist [EOL]         assertValidToLocale("us_ZH", "us", "ZH"); [EOL]          [EOL]         try { [EOL]             LocaleUtils.toLocale("us-EN"); [EOL]             fail("Should fail as not underscore"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("us_En"); [EOL]             fail("Should fail second part not uppercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("us_en"); [EOL]             fail("Should fail second part not uppercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("us_eN"); [EOL]             fail("Should fail second part not uppercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("uS_EN"); [EOL]             fail("Should fail first part not lowercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("us_E3"); [EOL]             fail("Should fail second part not uppercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]     }         [EOL]  [EOL]     /** [EOL]      * Test toLocale() method. [EOL]      */ [EOL]
@Test [EOL]     public void testToLocale_2Part() { [EOL]         assertValidToLocale("us_EN", "us", "EN"); [EOL]         //valid though doesnt exist [EOL]         assertValidToLocale("us_ZH", "us", "ZH"); [EOL]          [EOL]         try { [EOL]             LocaleUtils.toLocale("us-EN"); [EOL]             fail("Should fail as not underscore"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("us_En"); [EOL]             fail("Should fail second part not uppercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("us_en"); [EOL]             fail("Should fail second part not uppercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("us_eN"); [EOL]             fail("Should fail second part not uppercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("uS_EN"); [EOL]             fail("Should fail first part not lowercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("us_E3"); [EOL]             fail("Should fail second part not uppercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]     }         [EOL]  [EOL]     /** [EOL]      * Test toLocale() method. [EOL]      */ [EOL]
@Test [EOL]     public void testToLocale_2Part() { [EOL]         assertValidToLocale("us_EN", "us", "EN"); [EOL]         //valid though doesnt exist [EOL]         assertValidToLocale("us_ZH", "us", "ZH"); [EOL]          [EOL]         try { [EOL]             LocaleUtils.toLocale("us-EN"); [EOL]             fail("Should fail as not underscore"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("us_En"); [EOL]             fail("Should fail second part not uppercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("us_en"); [EOL]             fail("Should fail second part not uppercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("us_eN"); [EOL]             fail("Should fail second part not uppercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("uS_EN"); [EOL]             fail("Should fail first part not lowercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("us_E3"); [EOL]             fail("Should fail second part not uppercase"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]     }         [EOL]  [EOL]     /** [EOL]      * Test toLocale() method. [EOL]      */ [EOL]
@Test [EOL]     public void testToLocale_3Part() { [EOL]         assertValidToLocale("us_EN_A", "us", "EN", "A"); [EOL]         // this isn't pretty, but was caused by a jdk bug it seems [EOL]         // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4210525 [EOL]         if (SystemUtils.isJavaVersionAtLeast(JAVA_1_4)) { [EOL]             assertValidToLocale("us_EN_a", "us", "EN", "a"); [EOL]             assertValidToLocale("us_EN_SFsafdFDsdfF", "us", "EN", "SFsafdFDsdfF"); [EOL]         } else { [EOL]             assertValidToLocale("us_EN_a", "us", "EN", "A"); [EOL]             assertValidToLocale("us_EN_SFsafdFDsdfF", "us", "EN", "SFSAFDFDSDFF"); [EOL]         } [EOL]          [EOL]         try { [EOL]             LocaleUtils.toLocale("us_EN-a"); [EOL]             fail("Should fail as not underscore"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("uu_UU_"); [EOL]             fail("Must be 3, 5 or 7+ in length"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]     /** [EOL]      * Helper method for local lookups. [EOL]      * [EOL]      * @param locale  the input locale [EOL]      * @param defaultLocale  the input default locale [EOL]      * @param expected  expected results [EOL]      */ [EOL]     private void assertLocaleLookupList(final Locale locale, final Locale defaultLocale, final Locale[] expected) { [EOL]         final List<Locale> localeList = defaultLocale == null ? [EOL]                 LocaleUtils.localeLookupList(locale) : [EOL]                 LocaleUtils.localeLookupList(locale, defaultLocale); [EOL]          [EOL]         assertEquals(expected.length, localeList.size()); [EOL]         assertEquals(Arrays.asList(expected), localeList); [EOL]         assertUnmodifiableCollection(localeList); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]     /** [EOL]      * Test localeLookupList() method. [EOL]      */ [EOL]
@Test [EOL]     public void testToLocale_3Part() { [EOL]         assertValidToLocale("us_EN_A", "us", "EN", "A"); [EOL]         // this isn't pretty, but was caused by a jdk bug it seems [EOL]         // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4210525 [EOL]         if (SystemUtils.isJavaVersionAtLeast(JAVA_1_4)) { [EOL]             assertValidToLocale("us_EN_a", "us", "EN", "a"); [EOL]             assertValidToLocale("us_EN_SFsafdFDsdfF", "us", "EN", "SFsafdFDsdfF"); [EOL]         } else { [EOL]             assertValidToLocale("us_EN_a", "us", "EN", "A"); [EOL]             assertValidToLocale("us_EN_SFsafdFDsdfF", "us", "EN", "SFSAFDFDSDFF"); [EOL]         } [EOL]          [EOL]         try { [EOL]             LocaleUtils.toLocale("us_EN-a"); [EOL]             fail("Should fail as not underscore"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("uu_UU_"); [EOL]             fail("Must be 3, 5 or 7+ in length"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]     /** [EOL]      * Helper method for local lookups. [EOL]      * [EOL]      * @param locale  the input locale [EOL]      * @param defaultLocale  the input default locale [EOL]      * @param expected  expected results [EOL]      */ [EOL]     private void assertLocaleLookupList(final Locale locale, final Locale defaultLocale, final Locale[] expected) { [EOL]         final List<Locale> localeList = defaultLocale == null ? [EOL]                 LocaleUtils.localeLookupList(locale) : [EOL]                 LocaleUtils.localeLookupList(locale, defaultLocale); [EOL]          [EOL]         assertEquals(expected.length, localeList.size()); [EOL]         assertEquals(Arrays.asList(expected), localeList); [EOL]         assertUnmodifiableCollection(localeList); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]     /** [EOL]      * Test localeLookupList() method. [EOL]      */ [EOL]
@Test [EOL]     public void testToLocale_3Part() { [EOL]         assertValidToLocale("us_EN_A", "us", "EN", "A"); [EOL]         // this isn't pretty, but was caused by a jdk bug it seems [EOL]         // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4210525 [EOL]         if (SystemUtils.isJavaVersionAtLeast(JAVA_1_4)) { [EOL]             assertValidToLocale("us_EN_a", "us", "EN", "a"); [EOL]             assertValidToLocale("us_EN_SFsafdFDsdfF", "us", "EN", "SFsafdFDsdfF"); [EOL]         } else { [EOL]             assertValidToLocale("us_EN_a", "us", "EN", "A"); [EOL]             assertValidToLocale("us_EN_SFsafdFDsdfF", "us", "EN", "SFSAFDFDSDFF"); [EOL]         } [EOL]          [EOL]         try { [EOL]             LocaleUtils.toLocale("us_EN-a"); [EOL]             fail("Should fail as not underscore"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("uu_UU_"); [EOL]             fail("Must be 3, 5 or 7+ in length"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]     /** [EOL]      * Helper method for local lookups. [EOL]      * [EOL]      * @param locale  the input locale [EOL]      * @param defaultLocale  the input default locale [EOL]      * @param expected  expected results [EOL]      */ [EOL]     private void assertLocaleLookupList(final Locale locale, final Locale defaultLocale, final Locale[] expected) { [EOL]         final List<Locale> localeList = defaultLocale == null ? [EOL]                 LocaleUtils.localeLookupList(locale) : [EOL]                 LocaleUtils.localeLookupList(locale, defaultLocale); [EOL]          [EOL]         assertEquals(expected.length, localeList.size()); [EOL]         assertEquals(Arrays.asList(expected), localeList); [EOL]         assertUnmodifiableCollection(localeList); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]     /** [EOL]      * Test localeLookupList() method. [EOL]      */ [EOL]
@Test [EOL]     public void testToLocale_3Part() { [EOL]         assertValidToLocale("us_EN_A", "us", "EN", "A"); [EOL]         // this isn't pretty, but was caused by a jdk bug it seems [EOL]         // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4210525 [EOL]         if (SystemUtils.isJavaVersionAtLeast(JAVA_1_4)) { [EOL]             assertValidToLocale("us_EN_a", "us", "EN", "a"); [EOL]             assertValidToLocale("us_EN_SFsafdFDsdfF", "us", "EN", "SFsafdFDsdfF"); [EOL]         } else { [EOL]             assertValidToLocale("us_EN_a", "us", "EN", "A"); [EOL]             assertValidToLocale("us_EN_SFsafdFDsdfF", "us", "EN", "SFSAFDFDSDFF"); [EOL]         } [EOL]          [EOL]         try { [EOL]             LocaleUtils.toLocale("us_EN-a"); [EOL]             fail("Should fail as not underscore"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("uu_UU_"); [EOL]             fail("Must be 3, 5 or 7+ in length"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]     /** [EOL]      * Helper method for local lookups. [EOL]      * [EOL]      * @param locale  the input locale [EOL]      * @param defaultLocale  the input default locale [EOL]      * @param expected  expected results [EOL]      */ [EOL]     private void assertLocaleLookupList(final Locale locale, final Locale defaultLocale, final Locale[] expected) { [EOL]         final List<Locale> localeList = defaultLocale == null ? [EOL]                 LocaleUtils.localeLookupList(locale) : [EOL]                 LocaleUtils.localeLookupList(locale, defaultLocale); [EOL]          [EOL]         assertEquals(expected.length, localeList.size()); [EOL]         assertEquals(Arrays.asList(expected), localeList); [EOL]         assertUnmodifiableCollection(localeList); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]     /** [EOL]      * Test localeLookupList() method. [EOL]      */ [EOL]
@Test [EOL]     public void testToLocale_3Part() { [EOL]         assertValidToLocale("us_EN_A", "us", "EN", "A"); [EOL]         // this isn't pretty, but was caused by a jdk bug it seems [EOL]         // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4210525 [EOL]         if (SystemUtils.isJavaVersionAtLeast(JAVA_1_4)) { [EOL]             assertValidToLocale("us_EN_a", "us", "EN", "a"); [EOL]             assertValidToLocale("us_EN_SFsafdFDsdfF", "us", "EN", "SFsafdFDsdfF"); [EOL]         } else { [EOL]             assertValidToLocale("us_EN_a", "us", "EN", "A"); [EOL]             assertValidToLocale("us_EN_SFsafdFDsdfF", "us", "EN", "SFSAFDFDSDFF"); [EOL]         } [EOL]          [EOL]         try { [EOL]             LocaleUtils.toLocale("us_EN-a"); [EOL]             fail("Should fail as not underscore"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]         try { [EOL]             LocaleUtils.toLocale("uu_UU_"); [EOL]             fail("Must be 3, 5 or 7+ in length"); [EOL]         } catch (final IllegalArgumentException iae) {} [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]     /** [EOL]      * Helper method for local lookups. [EOL]      * [EOL]      * @param locale  the input locale [EOL]      * @param defaultLocale  the input default locale [EOL]      * @param expected  expected results [EOL]      */ [EOL]     private void assertLocaleLookupList(final Locale locale, final Locale defaultLocale, final Locale[] expected) { [EOL]         final List<Locale> localeList = defaultLocale == null ? [EOL]                 LocaleUtils.localeLookupList(locale) : [EOL]                 LocaleUtils.localeLookupList(locale, defaultLocale); [EOL]          [EOL]         assertEquals(expected.length, localeList.size()); [EOL]         assertEquals(Arrays.asList(expected), localeList); [EOL]         assertUnmodifiableCollection(localeList); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]     /** [EOL]      * Test localeLookupList() method. [EOL]      */ [EOL]
@Test [EOL]     public void testCountriesByLanguage() { [EOL]         assertCountriesByLanguage(null, new String[0]); [EOL]         assertCountriesByLanguage("de", new String[]{"DE", "CH", "AT", "LU"}); [EOL]         assertCountriesByLanguage("zz", new String[0]); [EOL]         assertCountriesByLanguage("it", new String[]{"IT", "CH"}); [EOL]     } [EOL]  [EOL]     /** [EOL]      * @param coll  the collection to check [EOL]      */ [EOL]     private static void assertUnmodifiableCollection(final Collection<?> coll) { [EOL]         try { [EOL]             coll.add(null); [EOL]             fail(); [EOL]         } catch (final UnsupportedOperationException ex) {} [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests #LANG-328 - only language+variant [EOL]      */ [EOL]
@Test [EOL]     public void testInvokeExactMethod() throws Exception { [EOL]         assertEquals("foo()", MethodUtils.invokeExactMethod(testBean, "foo", [EOL]                 (Object[]) ArrayUtils.EMPTY_CLASS_ARRAY)); [EOL]         assertEquals("foo()", MethodUtils.invokeExactMethod(testBean, "foo", [EOL]                 (Object[]) null)); [EOL]         assertEquals("foo()", MethodUtils.invokeExactMethod(testBean, "foo",  [EOL]                 (Object[]) null, (Class<?>[]) null)); [EOL]         assertEquals("foo(String)", MethodUtils.invokeExactMethod(testBean, [EOL]                 "foo", "")); [EOL]         assertEquals("foo(Object)", MethodUtils.invokeExactMethod(testBean, [EOL]                 "foo", new Object())); [EOL]         assertEquals("foo(Integer)", MethodUtils.invokeExactMethod(testBean, [EOL]                 "foo", NumberUtils.INTEGER_ONE)); [EOL]         assertEquals("foo(double)", MethodUtils.invokeExactMethod(testBean, [EOL]                 "foo", new Object[] { NumberUtils.DOUBLE_ONE }, [EOL]                 new Class[] { Double.TYPE })); [EOL]  [EOL]         try { [EOL]             MethodUtils [EOL]                     .invokeExactMethod(testBean, "foo", NumberUtils.BYTE_ONE); [EOL]             fail("should throw NoSuchMethodException"); [EOL]         } catch (final NoSuchMethodException e) { [EOL]         } [EOL]         try { [EOL]             MethodUtils [EOL]                     .invokeExactMethod(testBean, "foo", NumberUtils.LONG_ONE); [EOL]             fail("should throw NoSuchMethodException"); [EOL]         } catch (final NoSuchMethodException e) { [EOL]         } [EOL]         try { [EOL]             MethodUtils.invokeExactMethod(testBean, "foo", Boolean.TRUE); [EOL]             fail("should throw NoSuchMethodException"); [EOL]         } catch (final NoSuchMethodException e) { [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAccessibleInterfaceMethodFromDescription() [EOL]             throws Exception { [EOL]         final Class<?>[][] p = { ArrayUtils.EMPTY_CLASS_ARRAY, null }; [EOL]         for (final Class<?>[] element : p) { [EOL]             final Method accessibleMethod = MethodUtils.getAccessibleMethod( [EOL]                     TestMutable.class, "getValue", element); [EOL]             assertSame(Mutable.class, accessibleMethod.getDeclaringClass()); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAccessibleInterfaceMethodFromDescription() [EOL]             throws Exception { [EOL]         final Class<?>[][] p = { ArrayUtils.EMPTY_CLASS_ARRAY, null }; [EOL]         for (final Class<?>[] element : p) { [EOL]             final Method accessibleMethod = MethodUtils.getAccessibleMethod( [EOL]                     TestMutable.class, "getValue", element); [EOL]             assertSame(Mutable.class, accessibleMethod.getDeclaringClass()); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAccessibleInterfaceMethodFromDescription() [EOL]             throws Exception { [EOL]         final Class<?>[][] p = { ArrayUtils.EMPTY_CLASS_ARRAY, null }; [EOL]         for (final Class<?>[] element : p) { [EOL]             final Method accessibleMethod = MethodUtils.getAccessibleMethod( [EOL]                     TestMutable.class, "getValue", element); [EOL]             assertSame(Mutable.class, accessibleMethod.getDeclaringClass()); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAccessibleInterfaceMethodFromDescription() [EOL]             throws Exception { [EOL]         final Class<?>[][] p = { ArrayUtils.EMPTY_CLASS_ARRAY, null }; [EOL]         for (final Class<?>[] element : p) { [EOL]             final Method accessibleMethod = MethodUtils.getAccessibleMethod( [EOL]                     TestMutable.class, "getValue", element); [EOL]             assertSame(Mutable.class, accessibleMethod.getDeclaringClass()); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAccessibleMethodPrivateInterface() throws Exception { [EOL]         final Method expected = TestBeanWithInterfaces.class.getMethod("foo"); [EOL]         assertNotNull(expected); [EOL]         final Method actual = MethodUtils.getAccessibleMethod(TestBeanWithInterfaces.class, "foo"); [EOL]         assertNull(actual); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAccessibleInterfaceMethodFromDescription() [EOL]             throws Exception { [EOL]         final Class<?>[][] p = { ArrayUtils.EMPTY_CLASS_ARRAY, null }; [EOL]         for (final Class<?>[] element : p) { [EOL]             final Method accessibleMethod = MethodUtils.getAccessibleMethod( [EOL]                     TestMutable.class, "getValue", element); [EOL]             assertSame(Mutable.class, accessibleMethod.getDeclaringClass()); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAccessibleMethodPrivateInterface() throws Exception { [EOL]         final Method expected = TestBeanWithInterfaces.class.getMethod("foo"); [EOL]         assertNotNull(expected); [EOL]         final Method actual = MethodUtils.getAccessibleMethod(TestBeanWithInterfaces.class, "foo"); [EOL]         assertNull(actual); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAccessibleMethodPrivateInterface() throws Exception { [EOL]         final Method expected = TestBeanWithInterfaces.class.getMethod("foo"); [EOL]         assertNotNull(expected); [EOL]         final Method actual = MethodUtils.getAccessibleMethod(TestBeanWithInterfaces.class, "foo"); [EOL]         assertNull(actual); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAccessibleMethodPrivateInterface() throws Exception { [EOL]         final Method expected = TestBeanWithInterfaces.class.getMethod("foo"); [EOL]         assertNotNull(expected); [EOL]         final Method actual = MethodUtils.getAccessibleMethod(TestBeanWithInterfaces.class, "foo"); [EOL]         assertNull(actual); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAccessibleMethodPrivateInterface() throws Exception { [EOL]         final Method expected = TestBeanWithInterfaces.class.getMethod("foo"); [EOL]         assertNotNull(expected); [EOL]         final Method actual = MethodUtils.getAccessibleMethod(TestBeanWithInterfaces.class, "foo"); [EOL]         assertNull(actual); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAccessibleMethodPrivateInterface() throws Exception { [EOL]         final Method expected = TestBeanWithInterfaces.class.getMethod("foo"); [EOL]         assertNotNull(expected); [EOL]         final Method actual = MethodUtils.getAccessibleMethod(TestBeanWithInterfaces.class, "foo"); [EOL]         assertNull(actual); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAccessibleMethodPrivateInterface() throws Exception { [EOL]         final Method expected = TestBeanWithInterfaces.class.getMethod("foo"); [EOL]         assertNotNull(expected); [EOL]         final Method actual = MethodUtils.getAccessibleMethod(TestBeanWithInterfaces.class, "foo"); [EOL]         assertNull(actual); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAccessibleMethodPrivateInterface() throws Exception { [EOL]         final Method expected = TestBeanWithInterfaces.class.getMethod("foo"); [EOL]         assertNotNull(expected); [EOL]         final Method actual = MethodUtils.getAccessibleMethod(TestBeanWithInterfaces.class, "foo"); [EOL]         assertNull(actual); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAccessibleInterfaceMethodFromDescription() [EOL]             throws Exception { [EOL]         final Class<?>[][] p = { ArrayUtils.EMPTY_CLASS_ARRAY, null }; [EOL]         for (final Class<?>[] element : p) { [EOL]             final Method accessibleMethod = MethodUtils.getAccessibleMethod( [EOL]                     TestMutable.class, "getValue", element); [EOL]             assertSame(Mutable.class, accessibleMethod.getDeclaringClass()); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAccessibleInterfaceMethodFromDescription() [EOL]             throws Exception { [EOL]         final Class<?>[][] p = { ArrayUtils.EMPTY_CLASS_ARRAY, null }; [EOL]         for (final Class<?>[] element : p) { [EOL]             final Method accessibleMethod = MethodUtils.getAccessibleMethod( [EOL]                     TestMutable.class, "getValue", element); [EOL]             assertSame(Mutable.class, accessibleMethod.getDeclaringClass()); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAccessibleInterfaceMethodFromDescription() [EOL]             throws Exception { [EOL]         final Class<?>[][] p = { ArrayUtils.EMPTY_CLASS_ARRAY, null }; [EOL]         for (final Class<?>[] element : p) { [EOL]             final Method accessibleMethod = MethodUtils.getAccessibleMethod( [EOL]                     TestMutable.class, "getValue", element); [EOL]             assertSame(Mutable.class, accessibleMethod.getDeclaringClass()); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAccessibleInterfaceMethodFromDescription() [EOL]             throws Exception { [EOL]         final Class<?>[][] p = { ArrayUtils.EMPTY_CLASS_ARRAY, null }; [EOL]         for (final Class<?>[] element : p) { [EOL]             final Method accessibleMethod = MethodUtils.getAccessibleMethod( [EOL]                     TestMutable.class, "getValue", element); [EOL]             assertSame(Mutable.class, accessibleMethod.getDeclaringClass()); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAccessibleInterfaceMethodFromDescription() [EOL]             throws Exception { [EOL]         final Class<?>[][] p = { ArrayUtils.EMPTY_CLASS_ARRAY, null }; [EOL]         for (final Class<?>[] element : p) { [EOL]             final Method accessibleMethod = MethodUtils.getAccessibleMethod( [EOL]                     TestMutable.class, "getValue", element); [EOL]             assertSame(Mutable.class, accessibleMethod.getDeclaringClass()); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAccessibleInterfaceMethodFromDescription() [EOL]             throws Exception { [EOL]         final Class<?>[][] p = { ArrayUtils.EMPTY_CLASS_ARRAY, null }; [EOL]         for (final Class<?>[] element : p) { [EOL]             final Method accessibleMethod = MethodUtils.getAccessibleMethod( [EOL]                     TestMutable.class, "getValue", element); [EOL]             assertSame(Mutable.class, accessibleMethod.getDeclaringClass()); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAccessibleMethodPrivateInterface() throws Exception { [EOL]         final Method expected = TestBeanWithInterfaces.class.getMethod("foo"); [EOL]         assertNotNull(expected); [EOL]         final Method actual = MethodUtils.getAccessibleMethod(TestBeanWithInterfaces.class, "foo"); [EOL]         assertNull(actual); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAccessibleInterfaceMethodFromDescription() [EOL]             throws Exception { [EOL]         final Class<?>[][] p = { ArrayUtils.EMPTY_CLASS_ARRAY, null }; [EOL]         for (final Class<?>[] element : p) { [EOL]             final Method accessibleMethod = MethodUtils.getAccessibleMethod( [EOL]                     TestMutable.class, "getValue", element); [EOL]             assertSame(Mutable.class, accessibleMethod.getDeclaringClass()); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAccessibleInterfaceMethodFromDescription() [EOL]             throws Exception { [EOL]         final Class<?>[][] p = { ArrayUtils.EMPTY_CLASS_ARRAY, null }; [EOL]         for (final Class<?>[] element : p) { [EOL]             final Method accessibleMethod = MethodUtils.getAccessibleMethod( [EOL]                     TestMutable.class, "getValue", element); [EOL]             assertSame(Mutable.class, accessibleMethod.getDeclaringClass()); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAccessibleInterfaceMethodFromDescription() [EOL]             throws Exception { [EOL]         final Class<?>[][] p = { ArrayUtils.EMPTY_CLASS_ARRAY, null }; [EOL]         for (final Class<?>[] element : p) { [EOL]             final Method accessibleMethod = MethodUtils.getAccessibleMethod( [EOL]                     TestMutable.class, "getValue", element); [EOL]             assertSame(Mutable.class, accessibleMethod.getDeclaringClass()); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAccessibleInterfaceMethodFromDescription() [EOL]             throws Exception { [EOL]         final Class<?>[][] p = { ArrayUtils.EMPTY_CLASS_ARRAY, null }; [EOL]         for (final Class<?>[] element : p) { [EOL]             final Method accessibleMethod = MethodUtils.getAccessibleMethod( [EOL]                     TestMutable.class, "getValue", element); [EOL]             assertSame(Mutable.class, accessibleMethod.getDeclaringClass()); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAccessibleInterfaceMethodFromDescription() [EOL]             throws Exception { [EOL]         final Class<?>[][] p = { ArrayUtils.EMPTY_CLASS_ARRAY, null }; [EOL]         for (final Class<?>[] element : p) { [EOL]             final Method accessibleMethod = MethodUtils.getAccessibleMethod( [EOL]                     TestMutable.class, "getValue", element); [EOL]             assertSame(Mutable.class, accessibleMethod.getDeclaringClass()); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testInvokeMethod() throws Exception { [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 (Object[]) ArrayUtils.EMPTY_CLASS_ARRAY)); [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 (Object[]) null)); [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo",  [EOL]                 (Object[]) null, (Class<?>[]) null)); [EOL]         assertEquals("foo(String)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 "")); [EOL]         assertEquals("foo(Object)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 new Object())); [EOL]         assertEquals("foo(Object)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 Boolean.TRUE)); [EOL]         assertEquals("foo(Integer)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.INTEGER_ONE)); [EOL]         assertEquals("foo(int)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.BYTE_ONE)); [EOL]         assertEquals("foo(double)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.LONG_ONE)); [EOL]         assertEquals("foo(double)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.DOUBLE_ONE)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testInvokeMethod() throws Exception { [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 (Object[]) ArrayUtils.EMPTY_CLASS_ARRAY)); [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 (Object[]) null)); [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo",  [EOL]                 (Object[]) null, (Class<?>[]) null)); [EOL]         assertEquals("foo(String)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 "")); [EOL]         assertEquals("foo(Object)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 new Object())); [EOL]         assertEquals("foo(Object)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 Boolean.TRUE)); [EOL]         assertEquals("foo(Integer)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.INTEGER_ONE)); [EOL]         assertEquals("foo(int)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.BYTE_ONE)); [EOL]         assertEquals("foo(double)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.LONG_ONE)); [EOL]         assertEquals("foo(double)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.DOUBLE_ONE)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testInvokeMethod() throws Exception { [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 (Object[]) ArrayUtils.EMPTY_CLASS_ARRAY)); [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 (Object[]) null)); [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo",  [EOL]                 (Object[]) null, (Class<?>[]) null)); [EOL]         assertEquals("foo(String)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 "")); [EOL]         assertEquals("foo(Object)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 new Object())); [EOL]         assertEquals("foo(Object)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 Boolean.TRUE)); [EOL]         assertEquals("foo(Integer)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.INTEGER_ONE)); [EOL]         assertEquals("foo(int)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.BYTE_ONE)); [EOL]         assertEquals("foo(double)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.LONG_ONE)); [EOL]         assertEquals("foo(double)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.DOUBLE_ONE)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testInvokeMethod() throws Exception { [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 (Object[]) ArrayUtils.EMPTY_CLASS_ARRAY)); [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 (Object[]) null)); [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo",  [EOL]                 (Object[]) null, (Class<?>[]) null)); [EOL]         assertEquals("foo(String)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 "")); [EOL]         assertEquals("foo(Object)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 new Object())); [EOL]         assertEquals("foo(Object)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 Boolean.TRUE)); [EOL]         assertEquals("foo(Integer)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.INTEGER_ONE)); [EOL]         assertEquals("foo(int)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.BYTE_ONE)); [EOL]         assertEquals("foo(double)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.LONG_ONE)); [EOL]         assertEquals("foo(double)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.DOUBLE_ONE)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNewThreadExHandler() { [EOL]         final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class); [EOL]         final Runnable r = EasyMock.createMock(Runnable.class); [EOL]         final Thread.UncaughtExceptionHandler handler = EasyMock [EOL]                 .createMock(Thread.UncaughtExceptionHandler.class); [EOL]         final Thread t = new Thread(); [EOL]         EasyMock.expect(wrapped.newThread(r)).andReturn(t); [EOL]         EasyMock.replay(wrapped, r, handler); [EOL]         final BasicThreadFactory factory = builder.wrappedFactory(wrapped) [EOL]                 .uncaughtExceptionHandler(handler).build(); [EOL]         assertSame("Wrong thread", t, factory.newThread(r)); [EOL]         assertEquals("Wrong exception handler", handler, t [EOL]                 .getUncaughtExceptionHandler()); [EOL]         EasyMock.verify(wrapped, r, handler); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether the original exception hander is not touched if none is [EOL]      * specified. [EOL]      */ [EOL]
@Test [EOL]     public void testNewThreadExHandler() { [EOL]         final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class); [EOL]         final Runnable r = EasyMock.createMock(Runnable.class); [EOL]         final Thread.UncaughtExceptionHandler handler = EasyMock [EOL]                 .createMock(Thread.UncaughtExceptionHandler.class); [EOL]         final Thread t = new Thread(); [EOL]         EasyMock.expect(wrapped.newThread(r)).andReturn(t); [EOL]         EasyMock.replay(wrapped, r, handler); [EOL]         final BasicThreadFactory factory = builder.wrappedFactory(wrapped) [EOL]                 .uncaughtExceptionHandler(handler).build(); [EOL]         assertSame("Wrong thread", t, factory.newThread(r)); [EOL]         assertEquals("Wrong exception handler", handler, t [EOL]                 .getUncaughtExceptionHandler()); [EOL]         EasyMock.verify(wrapped, r, handler); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether the original exception hander is not touched if none is [EOL]      * specified. [EOL]      */ [EOL]
@Test [EOL]     public void testBuilderReset() { [EOL]         final ThreadFactory wrappedFactory = EasyMock.createMock(ThreadFactory.class); [EOL]         final Thread.UncaughtExceptionHandler exHandler = EasyMock [EOL]                 .createMock(Thread.UncaughtExceptionHandler.class); [EOL]         EasyMock.replay(wrappedFactory, exHandler); [EOL]         builder.namingPattern(PATTERN).daemon(true).priority( [EOL]                 Thread.MAX_PRIORITY).uncaughtExceptionHandler(exHandler) [EOL]                 .wrappedFactory(wrappedFactory); [EOL]         builder.reset(); [EOL]         final BasicThreadFactory factory = builder.build(); [EOL]         checkFactoryDefaults(factory); [EOL]         assertNotSame("Wrapped factory not reset", wrappedFactory, factory [EOL]                 .getWrappedFactory()); [EOL]         EasyMock.verify(wrappedFactory, exHandler); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether reset() is automatically called after build(). [EOL]      */ [EOL]
@Test [EOL]     public void testNewThreadExHandler() { [EOL]         final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class); [EOL]         final Runnable r = EasyMock.createMock(Runnable.class); [EOL]         final Thread.UncaughtExceptionHandler handler = EasyMock [EOL]                 .createMock(Thread.UncaughtExceptionHandler.class); [EOL]         final Thread t = new Thread(); [EOL]         EasyMock.expect(wrapped.newThread(r)).andReturn(t); [EOL]         EasyMock.replay(wrapped, r, handler); [EOL]         final BasicThreadFactory factory = builder.wrappedFactory(wrapped) [EOL]                 .uncaughtExceptionHandler(handler).build(); [EOL]         assertSame("Wrong thread", t, factory.newThread(r)); [EOL]         assertEquals("Wrong exception handler", handler, t [EOL]                 .getUncaughtExceptionHandler()); [EOL]         EasyMock.verify(wrapped, r, handler); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether the original exception hander is not touched if none is [EOL]      * specified. [EOL]      */ [EOL]
@Test [EOL]     public void testNewThreadExHandler() { [EOL]         final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class); [EOL]         final Runnable r = EasyMock.createMock(Runnable.class); [EOL]         final Thread.UncaughtExceptionHandler handler = EasyMock [EOL]                 .createMock(Thread.UncaughtExceptionHandler.class); [EOL]         final Thread t = new Thread(); [EOL]         EasyMock.expect(wrapped.newThread(r)).andReturn(t); [EOL]         EasyMock.replay(wrapped, r, handler); [EOL]         final BasicThreadFactory factory = builder.wrappedFactory(wrapped) [EOL]                 .uncaughtExceptionHandler(handler).build(); [EOL]         assertSame("Wrong thread", t, factory.newThread(r)); [EOL]         assertEquals("Wrong exception handler", handler, t [EOL]                 .getUncaughtExceptionHandler()); [EOL]         EasyMock.verify(wrapped, r, handler); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether the original exception hander is not touched if none is [EOL]      * specified. [EOL]      */ [EOL]
@Test [EOL]     public void testNewThreadExHandler() { [EOL]         final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class); [EOL]         final Runnable r = EasyMock.createMock(Runnable.class); [EOL]         final Thread.UncaughtExceptionHandler handler = EasyMock [EOL]                 .createMock(Thread.UncaughtExceptionHandler.class); [EOL]         final Thread t = new Thread(); [EOL]         EasyMock.expect(wrapped.newThread(r)).andReturn(t); [EOL]         EasyMock.replay(wrapped, r, handler); [EOL]         final BasicThreadFactory factory = builder.wrappedFactory(wrapped) [EOL]                 .uncaughtExceptionHandler(handler).build(); [EOL]         assertSame("Wrong thread", t, factory.newThread(r)); [EOL]         assertEquals("Wrong exception handler", handler, t [EOL]                 .getUncaughtExceptionHandler()); [EOL]         EasyMock.verify(wrapped, r, handler); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether the original exception hander is not touched if none is [EOL]      * specified. [EOL]      */ [EOL]
@Test [EOL]     public void testNewThreadExHandler() { [EOL]         final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class); [EOL]         final Runnable r = EasyMock.createMock(Runnable.class); [EOL]         final Thread.UncaughtExceptionHandler handler = EasyMock [EOL]                 .createMock(Thread.UncaughtExceptionHandler.class); [EOL]         final Thread t = new Thread(); [EOL]         EasyMock.expect(wrapped.newThread(r)).andReturn(t); [EOL]         EasyMock.replay(wrapped, r, handler); [EOL]         final BasicThreadFactory factory = builder.wrappedFactory(wrapped) [EOL]                 .uncaughtExceptionHandler(handler).build(); [EOL]         assertSame("Wrong thread", t, factory.newThread(r)); [EOL]         assertEquals("Wrong exception handler", handler, t [EOL]                 .getUncaughtExceptionHandler()); [EOL]         EasyMock.verify(wrapped, r, handler); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether the original exception hander is not touched if none is [EOL]      * specified. [EOL]      */ [EOL]
@Test [EOL]     public void testNewThreadExHandler() { [EOL]         final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class); [EOL]         final Runnable r = EasyMock.createMock(Runnable.class); [EOL]         final Thread.UncaughtExceptionHandler handler = EasyMock [EOL]                 .createMock(Thread.UncaughtExceptionHandler.class); [EOL]         final Thread t = new Thread(); [EOL]         EasyMock.expect(wrapped.newThread(r)).andReturn(t); [EOL]         EasyMock.replay(wrapped, r, handler); [EOL]         final BasicThreadFactory factory = builder.wrappedFactory(wrapped) [EOL]                 .uncaughtExceptionHandler(handler).build(); [EOL]         assertSame("Wrong thread", t, factory.newThread(r)); [EOL]         assertEquals("Wrong exception handler", handler, t [EOL]                 .getUncaughtExceptionHandler()); [EOL]         EasyMock.verify(wrapped, r, handler); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether the original exception hander is not touched if none is [EOL]      * specified. [EOL]      */ [EOL]
@Test [EOL]     public void testNewThreadExHandler() { [EOL]         final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class); [EOL]         final Runnable r = EasyMock.createMock(Runnable.class); [EOL]         final Thread.UncaughtExceptionHandler handler = EasyMock [EOL]                 .createMock(Thread.UncaughtExceptionHandler.class); [EOL]         final Thread t = new Thread(); [EOL]         EasyMock.expect(wrapped.newThread(r)).andReturn(t); [EOL]         EasyMock.replay(wrapped, r, handler); [EOL]         final BasicThreadFactory factory = builder.wrappedFactory(wrapped) [EOL]                 .uncaughtExceptionHandler(handler).build(); [EOL]         assertSame("Wrong thread", t, factory.newThread(r)); [EOL]         assertEquals("Wrong exception handler", handler, t [EOL]                 .getUncaughtExceptionHandler()); [EOL]         EasyMock.verify(wrapped, r, handler); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether the original exception hander is not touched if none is [EOL]      * specified. [EOL]      */ [EOL]
@Test [EOL]     public void testNewThreadExHandler() { [EOL]         final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class); [EOL]         final Runnable r = EasyMock.createMock(Runnable.class); [EOL]         final Thread.UncaughtExceptionHandler handler = EasyMock [EOL]                 .createMock(Thread.UncaughtExceptionHandler.class); [EOL]         final Thread t = new Thread(); [EOL]         EasyMock.expect(wrapped.newThread(r)).andReturn(t); [EOL]         EasyMock.replay(wrapped, r, handler); [EOL]         final BasicThreadFactory factory = builder.wrappedFactory(wrapped) [EOL]                 .uncaughtExceptionHandler(handler).build(); [EOL]         assertSame("Wrong thread", t, factory.newThread(r)); [EOL]         assertEquals("Wrong exception handler", handler, t [EOL]                 .getUncaughtExceptionHandler()); [EOL]         EasyMock.verify(wrapped, r, handler); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether the original exception hander is not touched if none is [EOL]      * specified. [EOL]      */ [EOL]
@Test [EOL]     public void testNewThreadExHandler() { [EOL]         final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class); [EOL]         final Runnable r = EasyMock.createMock(Runnable.class); [EOL]         final Thread.UncaughtExceptionHandler handler = EasyMock [EOL]                 .createMock(Thread.UncaughtExceptionHandler.class); [EOL]         final Thread t = new Thread(); [EOL]         EasyMock.expect(wrapped.newThread(r)).andReturn(t); [EOL]         EasyMock.replay(wrapped, r, handler); [EOL]         final BasicThreadFactory factory = builder.wrappedFactory(wrapped) [EOL]                 .uncaughtExceptionHandler(handler).build(); [EOL]         assertSame("Wrong thread", t, factory.newThread(r)); [EOL]         assertEquals("Wrong exception handler", handler, t [EOL]                 .getUncaughtExceptionHandler()); [EOL]         EasyMock.verify(wrapped, r, handler); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether the original exception hander is not touched if none is [EOL]      * specified. [EOL]      */ [EOL]
@Test [EOL]     public void testNewThreadExHandler() { [EOL]         final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class); [EOL]         final Runnable r = EasyMock.createMock(Runnable.class); [EOL]         final Thread.UncaughtExceptionHandler handler = EasyMock [EOL]                 .createMock(Thread.UncaughtExceptionHandler.class); [EOL]         final Thread t = new Thread(); [EOL]         EasyMock.expect(wrapped.newThread(r)).andReturn(t); [EOL]         EasyMock.replay(wrapped, r, handler); [EOL]         final BasicThreadFactory factory = builder.wrappedFactory(wrapped) [EOL]                 .uncaughtExceptionHandler(handler).build(); [EOL]         assertSame("Wrong thread", t, factory.newThread(r)); [EOL]         assertEquals("Wrong exception handler", handler, t [EOL]                 .getUncaughtExceptionHandler()); [EOL]         EasyMock.verify(wrapped, r, handler); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether the original exception hander is not touched if none is [EOL]      * specified. [EOL]      */ [EOL]
@Test [EOL]     public void testNewThreadExHandler() { [EOL]         final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class); [EOL]         final Runnable r = EasyMock.createMock(Runnable.class); [EOL]         final Thread.UncaughtExceptionHandler handler = EasyMock [EOL]                 .createMock(Thread.UncaughtExceptionHandler.class); [EOL]         final Thread t = new Thread(); [EOL]         EasyMock.expect(wrapped.newThread(r)).andReturn(t); [EOL]         EasyMock.replay(wrapped, r, handler); [EOL]         final BasicThreadFactory factory = builder.wrappedFactory(wrapped) [EOL]                 .uncaughtExceptionHandler(handler).build(); [EOL]         assertSame("Wrong thread", t, factory.newThread(r)); [EOL]         assertEquals("Wrong exception handler", handler, t [EOL]                 .getUncaughtExceptionHandler()); [EOL]         EasyMock.verify(wrapped, r, handler); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether the original exception hander is not touched if none is [EOL]      * specified. [EOL]      */ [EOL]
@Test [EOL]     public void testNewThreadExHandler() { [EOL]         final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class); [EOL]         final Runnable r = EasyMock.createMock(Runnable.class); [EOL]         final Thread.UncaughtExceptionHandler handler = EasyMock [EOL]                 .createMock(Thread.UncaughtExceptionHandler.class); [EOL]         final Thread t = new Thread(); [EOL]         EasyMock.expect(wrapped.newThread(r)).andReturn(t); [EOL]         EasyMock.replay(wrapped, r, handler); [EOL]         final BasicThreadFactory factory = builder.wrappedFactory(wrapped) [EOL]                 .uncaughtExceptionHandler(handler).build(); [EOL]         assertSame("Wrong thread", t, factory.newThread(r)); [EOL]         assertEquals("Wrong exception handler", handler, t [EOL]                 .getUncaughtExceptionHandler()); [EOL]         EasyMock.verify(wrapped, r, handler); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether the original exception hander is not touched if none is [EOL]      * specified. [EOL]      */ [EOL]
@Test [EOL]     public void testNewThreadExHandler() { [EOL]         final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class); [EOL]         final Runnable r = EasyMock.createMock(Runnable.class); [EOL]         final Thread.UncaughtExceptionHandler handler = EasyMock [EOL]                 .createMock(Thread.UncaughtExceptionHandler.class); [EOL]         final Thread t = new Thread(); [EOL]         EasyMock.expect(wrapped.newThread(r)).andReturn(t); [EOL]         EasyMock.replay(wrapped, r, handler); [EOL]         final BasicThreadFactory factory = builder.wrappedFactory(wrapped) [EOL]                 .uncaughtExceptionHandler(handler).build(); [EOL]         assertSame("Wrong thread", t, factory.newThread(r)); [EOL]         assertEquals("Wrong exception handler", handler, t [EOL]                 .getUncaughtExceptionHandler()); [EOL]         EasyMock.verify(wrapped, r, handler); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether the original exception hander is not touched if none is [EOL]      * specified. [EOL]      */ [EOL]
@Test [EOL]     public void testNewThreadExHandler() { [EOL]         final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class); [EOL]         final Runnable r = EasyMock.createMock(Runnable.class); [EOL]         final Thread.UncaughtExceptionHandler handler = EasyMock [EOL]                 .createMock(Thread.UncaughtExceptionHandler.class); [EOL]         final Thread t = new Thread(); [EOL]         EasyMock.expect(wrapped.newThread(r)).andReturn(t); [EOL]         EasyMock.replay(wrapped, r, handler); [EOL]         final BasicThreadFactory factory = builder.wrappedFactory(wrapped) [EOL]                 .uncaughtExceptionHandler(handler).build(); [EOL]         assertSame("Wrong thread", t, factory.newThread(r)); [EOL]         assertEquals("Wrong exception handler", handler, t [EOL]                 .getUncaughtExceptionHandler()); [EOL]         EasyMock.verify(wrapped, r, handler); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether the original exception hander is not touched if none is [EOL]      * specified. [EOL]      */ [EOL]
@Test [EOL]     public void testNewThreadExHandler() { [EOL]         final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class); [EOL]         final Runnable r = EasyMock.createMock(Runnable.class); [EOL]         final Thread.UncaughtExceptionHandler handler = EasyMock [EOL]                 .createMock(Thread.UncaughtExceptionHandler.class); [EOL]         final Thread t = new Thread(); [EOL]         EasyMock.expect(wrapped.newThread(r)).andReturn(t); [EOL]         EasyMock.replay(wrapped, r, handler); [EOL]         final BasicThreadFactory factory = builder.wrappedFactory(wrapped) [EOL]                 .uncaughtExceptionHandler(handler).build(); [EOL]         assertSame("Wrong thread", t, factory.newThread(r)); [EOL]         assertEquals("Wrong exception handler", handler, t [EOL]                 .getUncaughtExceptionHandler()); [EOL]         EasyMock.verify(wrapped, r, handler); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether the original exception hander is not touched if none is [EOL]      * specified. [EOL]      */ [EOL]
@Test [EOL]     public void testNewThreadExHandler() { [EOL]         final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class); [EOL]         final Runnable r = EasyMock.createMock(Runnable.class); [EOL]         final Thread.UncaughtExceptionHandler handler = EasyMock [EOL]                 .createMock(Thread.UncaughtExceptionHandler.class); [EOL]         final Thread t = new Thread(); [EOL]         EasyMock.expect(wrapped.newThread(r)).andReturn(t); [EOL]         EasyMock.replay(wrapped, r, handler); [EOL]         final BasicThreadFactory factory = builder.wrappedFactory(wrapped) [EOL]                 .uncaughtExceptionHandler(handler).build(); [EOL]         assertSame("Wrong thread", t, factory.newThread(r)); [EOL]         assertEquals("Wrong exception handler", handler, t [EOL]                 .getUncaughtExceptionHandler()); [EOL]         EasyMock.verify(wrapped, r, handler); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether the original exception hander is not touched if none is [EOL]      * specified. [EOL]      */ [EOL]
@Test [EOL]     public void testNewThreadExHandler() { [EOL]         final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class); [EOL]         final Runnable r = EasyMock.createMock(Runnable.class); [EOL]         final Thread.UncaughtExceptionHandler handler = EasyMock [EOL]                 .createMock(Thread.UncaughtExceptionHandler.class); [EOL]         final Thread t = new Thread(); [EOL]         EasyMock.expect(wrapped.newThread(r)).andReturn(t); [EOL]         EasyMock.replay(wrapped, r, handler); [EOL]         final BasicThreadFactory factory = builder.wrappedFactory(wrapped) [EOL]                 .uncaughtExceptionHandler(handler).build(); [EOL]         assertSame("Wrong thread", t, factory.newThread(r)); [EOL]         assertEquals("Wrong exception handler", handler, t [EOL]                 .getUncaughtExceptionHandler()); [EOL]         EasyMock.verify(wrapped, r, handler); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether the original exception hander is not touched if none is [EOL]      * specified. [EOL]      */ [EOL]
@Test [EOL]     public void testNewThreadNamingPattern() { [EOL]         final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class); [EOL]         final Runnable r = EasyMock.createMock(Runnable.class); [EOL]         final int count = 12; [EOL]         for (int i = 0; i < count; i++) { [EOL]             EasyMock.expect(wrapped.newThread(r)).andReturn(new Thread()); [EOL]         } [EOL]         EasyMock.replay(wrapped, r); [EOL]         final BasicThreadFactory factory = builder.wrappedFactory(wrapped) [EOL]                 .namingPattern(PATTERN).build(); [EOL]         for (int i = 0; i < count; i++) { [EOL]             final Thread t = factory.newThread(r); [EOL]             assertEquals("Wrong thread name", String.format(PATTERN, Long [EOL]                     .valueOf(i + 1)), t.getName()); [EOL]             assertEquals("Wrong thread count", i + 1, factory.getThreadCount()); [EOL]         } [EOL]         EasyMock.verify(wrapped, r); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether the thread name is not modified if no naming pattern is [EOL]      * set. [EOL]      */ [EOL]
@Test [EOL]     public void testNewThreadNamingPattern() { [EOL]         final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class); [EOL]         final Runnable r = EasyMock.createMock(Runnable.class); [EOL]         final int count = 12; [EOL]         for (int i = 0; i < count; i++) { [EOL]             EasyMock.expect(wrapped.newThread(r)).andReturn(new Thread()); [EOL]         } [EOL]         EasyMock.replay(wrapped, r); [EOL]         final BasicThreadFactory factory = builder.wrappedFactory(wrapped) [EOL]                 .namingPattern(PATTERN).build(); [EOL]         for (int i = 0; i < count; i++) { [EOL]             final Thread t = factory.newThread(r); [EOL]             assertEquals("Wrong thread name", String.format(PATTERN, Long [EOL]                     .valueOf(i + 1)), t.getName()); [EOL]             assertEquals("Wrong thread count", i + 1, factory.getThreadCount()); [EOL]         } [EOL]         EasyMock.verify(wrapped, r); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether the thread name is not modified if no naming pattern is [EOL]      * set. [EOL]      */ [EOL]
@Test [EOL]     public void testNewThreadExHandler() { [EOL]         final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class); [EOL]         final Runnable r = EasyMock.createMock(Runnable.class); [EOL]         final Thread.UncaughtExceptionHandler handler = EasyMock [EOL]                 .createMock(Thread.UncaughtExceptionHandler.class); [EOL]         final Thread t = new Thread(); [EOL]         EasyMock.expect(wrapped.newThread(r)).andReturn(t); [EOL]         EasyMock.replay(wrapped, r, handler); [EOL]         final BasicThreadFactory factory = builder.wrappedFactory(wrapped) [EOL]                 .uncaughtExceptionHandler(handler).build(); [EOL]         assertSame("Wrong thread", t, factory.newThread(r)); [EOL]         assertEquals("Wrong exception handler", handler, t [EOL]                 .getUncaughtExceptionHandler()); [EOL]         EasyMock.verify(wrapped, r, handler); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether the original exception hander is not touched if none is [EOL]      * specified. [EOL]      */ [EOL]
@Test [EOL]     public void testNewThreadExHandler() { [EOL]         final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class); [EOL]         final Runnable r = EasyMock.createMock(Runnable.class); [EOL]         final Thread.UncaughtExceptionHandler handler = EasyMock [EOL]                 .createMock(Thread.UncaughtExceptionHandler.class); [EOL]         final Thread t = new Thread(); [EOL]         EasyMock.expect(wrapped.newThread(r)).andReturn(t); [EOL]         EasyMock.replay(wrapped, r, handler); [EOL]         final BasicThreadFactory factory = builder.wrappedFactory(wrapped) [EOL]                 .uncaughtExceptionHandler(handler).build(); [EOL]         assertSame("Wrong thread", t, factory.newThread(r)); [EOL]         assertEquals("Wrong exception handler", handler, t [EOL]                 .getUncaughtExceptionHandler()); [EOL]         EasyMock.verify(wrapped, r, handler); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether the original exception hander is not touched if none is [EOL]      * specified. [EOL]      */ [EOL]
@Test [EOL]     public void testNewThreadExHandler() { [EOL]         final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class); [EOL]         final Runnable r = EasyMock.createMock(Runnable.class); [EOL]         final Thread.UncaughtExceptionHandler handler = EasyMock [EOL]                 .createMock(Thread.UncaughtExceptionHandler.class); [EOL]         final Thread t = new Thread(); [EOL]         EasyMock.expect(wrapped.newThread(r)).andReturn(t); [EOL]         EasyMock.replay(wrapped, r, handler); [EOL]         final BasicThreadFactory factory = builder.wrappedFactory(wrapped) [EOL]                 .uncaughtExceptionHandler(handler).build(); [EOL]         assertSame("Wrong thread", t, factory.newThread(r)); [EOL]         assertEquals("Wrong exception handler", handler, t [EOL]                 .getUncaughtExceptionHandler()); [EOL]         EasyMock.verify(wrapped, r, handler); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether the original exception hander is not touched if none is [EOL]      * specified. [EOL]      */ [EOL]
@Test [EOL]     public void testNewThreadExHandler() { [EOL]         final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class); [EOL]         final Runnable r = EasyMock.createMock(Runnable.class); [EOL]         final Thread.UncaughtExceptionHandler handler = EasyMock [EOL]                 .createMock(Thread.UncaughtExceptionHandler.class); [EOL]         final Thread t = new Thread(); [EOL]         EasyMock.expect(wrapped.newThread(r)).andReturn(t); [EOL]         EasyMock.replay(wrapped, r, handler); [EOL]         final BasicThreadFactory factory = builder.wrappedFactory(wrapped) [EOL]                 .uncaughtExceptionHandler(handler).build(); [EOL]         assertSame("Wrong thread", t, factory.newThread(r)); [EOL]         assertEquals("Wrong exception handler", handler, t [EOL]                 .getUncaughtExceptionHandler()); [EOL]         EasyMock.verify(wrapped, r, handler); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether the original exception hander is not touched if none is [EOL]      * specified. [EOL]      */ [EOL]
@Test [EOL]     public void testNewThreadExHandler() { [EOL]         final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class); [EOL]         final Runnable r = EasyMock.createMock(Runnable.class); [EOL]         final Thread.UncaughtExceptionHandler handler = EasyMock [EOL]                 .createMock(Thread.UncaughtExceptionHandler.class); [EOL]         final Thread t = new Thread(); [EOL]         EasyMock.expect(wrapped.newThread(r)).andReturn(t); [EOL]         EasyMock.replay(wrapped, r, handler); [EOL]         final BasicThreadFactory factory = builder.wrappedFactory(wrapped) [EOL]                 .uncaughtExceptionHandler(handler).build(); [EOL]         assertSame("Wrong thread", t, factory.newThread(r)); [EOL]         assertEquals("Wrong exception handler", handler, t [EOL]                 .getUncaughtExceptionHandler()); [EOL]         EasyMock.verify(wrapped, r, handler); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether the original exception hander is not touched if none is [EOL]      * specified. [EOL]      */ [EOL]
@Test [EOL]     public void testNewThreadExHandler() { [EOL]         final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class); [EOL]         final Runnable r = EasyMock.createMock(Runnable.class); [EOL]         final Thread.UncaughtExceptionHandler handler = EasyMock [EOL]                 .createMock(Thread.UncaughtExceptionHandler.class); [EOL]         final Thread t = new Thread(); [EOL]         EasyMock.expect(wrapped.newThread(r)).andReturn(t); [EOL]         EasyMock.replay(wrapped, r, handler); [EOL]         final BasicThreadFactory factory = builder.wrappedFactory(wrapped) [EOL]                 .uncaughtExceptionHandler(handler).build(); [EOL]         assertSame("Wrong thread", t, factory.newThread(r)); [EOL]         assertEquals("Wrong exception handler", handler, t [EOL]                 .getUncaughtExceptionHandler()); [EOL]         EasyMock.verify(wrapped, r, handler); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether the original exception hander is not touched if none is [EOL]      * specified. [EOL]      */ [EOL]
@Test [EOL]     public void testNewThreadNamingPattern() { [EOL]         final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class); [EOL]         final Runnable r = EasyMock.createMock(Runnable.class); [EOL]         final int count = 12; [EOL]         for (int i = 0; i < count; i++) { [EOL]             EasyMock.expect(wrapped.newThread(r)).andReturn(new Thread()); [EOL]         } [EOL]         EasyMock.replay(wrapped, r); [EOL]         final BasicThreadFactory factory = builder.wrappedFactory(wrapped) [EOL]                 .namingPattern(PATTERN).build(); [EOL]         for (int i = 0; i < count; i++) { [EOL]             final Thread t = factory.newThread(r); [EOL]             assertEquals("Wrong thread name", String.format(PATTERN, Long [EOL]                     .valueOf(i + 1)), t.getName()); [EOL]             assertEquals("Wrong thread count", i + 1, factory.getThreadCount()); [EOL]         } [EOL]         EasyMock.verify(wrapped, r); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether the thread name is not modified if no naming pattern is [EOL]      * set. [EOL]      */ [EOL]
@Test [EOL]     public void testNewThreadNamingPattern() { [EOL]         final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class); [EOL]         final Runnable r = EasyMock.createMock(Runnable.class); [EOL]         final int count = 12; [EOL]         for (int i = 0; i < count; i++) { [EOL]             EasyMock.expect(wrapped.newThread(r)).andReturn(new Thread()); [EOL]         } [EOL]         EasyMock.replay(wrapped, r); [EOL]         final BasicThreadFactory factory = builder.wrappedFactory(wrapped) [EOL]                 .namingPattern(PATTERN).build(); [EOL]         for (int i = 0; i < count; i++) { [EOL]             final Thread t = factory.newThread(r); [EOL]             assertEquals("Wrong thread name", String.format(PATTERN, Long [EOL]                     .valueOf(i + 1)), t.getName()); [EOL]             assertEquals("Wrong thread count", i + 1, factory.getThreadCount()); [EOL]         } [EOL]         EasyMock.verify(wrapped, r); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether the thread name is not modified if no naming pattern is [EOL]      * set. [EOL]      */ [EOL]
@Test [EOL]     public void testNewThreadExHandler() { [EOL]         final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class); [EOL]         final Runnable r = EasyMock.createMock(Runnable.class); [EOL]         final Thread.UncaughtExceptionHandler handler = EasyMock [EOL]                 .createMock(Thread.UncaughtExceptionHandler.class); [EOL]         final Thread t = new Thread(); [EOL]         EasyMock.expect(wrapped.newThread(r)).andReturn(t); [EOL]         EasyMock.replay(wrapped, r, handler); [EOL]         final BasicThreadFactory factory = builder.wrappedFactory(wrapped) [EOL]                 .uncaughtExceptionHandler(handler).build(); [EOL]         assertSame("Wrong thread", t, factory.newThread(r)); [EOL]         assertEquals("Wrong exception handler", handler, t [EOL]                 .getUncaughtExceptionHandler()); [EOL]         EasyMock.verify(wrapped, r, handler); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether the original exception hander is not touched if none is [EOL]      * specified. [EOL]      */ [EOL]
@Test [EOL]     public void testNewThreadExHandler() { [EOL]         final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class); [EOL]         final Runnable r = EasyMock.createMock(Runnable.class); [EOL]         final Thread.UncaughtExceptionHandler handler = EasyMock [EOL]                 .createMock(Thread.UncaughtExceptionHandler.class); [EOL]         final Thread t = new Thread(); [EOL]         EasyMock.expect(wrapped.newThread(r)).andReturn(t); [EOL]         EasyMock.replay(wrapped, r, handler); [EOL]         final BasicThreadFactory factory = builder.wrappedFactory(wrapped) [EOL]                 .uncaughtExceptionHandler(handler).build(); [EOL]         assertSame("Wrong thread", t, factory.newThread(r)); [EOL]         assertEquals("Wrong exception handler", handler, t [EOL]                 .getUncaughtExceptionHandler()); [EOL]         EasyMock.verify(wrapped, r, handler); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether the original exception hander is not touched if none is [EOL]      * specified. [EOL]      */ [EOL]
@Test [EOL]     public void testNewThreadExHandler() { [EOL]         final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class); [EOL]         final Runnable r = EasyMock.createMock(Runnable.class); [EOL]         final Thread.UncaughtExceptionHandler handler = EasyMock [EOL]                 .createMock(Thread.UncaughtExceptionHandler.class); [EOL]         final Thread t = new Thread(); [EOL]         EasyMock.expect(wrapped.newThread(r)).andReturn(t); [EOL]         EasyMock.replay(wrapped, r, handler); [EOL]         final BasicThreadFactory factory = builder.wrappedFactory(wrapped) [EOL]                 .uncaughtExceptionHandler(handler).build(); [EOL]         assertSame("Wrong thread", t, factory.newThread(r)); [EOL]         assertEquals("Wrong exception handler", handler, t [EOL]                 .getUncaughtExceptionHandler()); [EOL]         EasyMock.verify(wrapped, r, handler); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether the original exception hander is not touched if none is [EOL]      * specified. [EOL]      */ [EOL]
@Test [EOL]     public void testNewThreadPriority() { [EOL]         final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class); [EOL]         final Runnable r = EasyMock.createMock(Runnable.class); [EOL]         final Thread t = new Thread(); [EOL]         EasyMock.expect(wrapped.newThread(r)).andReturn(t); [EOL]         EasyMock.replay(wrapped, r); [EOL]         final int priority = Thread.NORM_PRIORITY + 1; [EOL]         final BasicThreadFactory factory = builder.wrappedFactory(wrapped).priority( [EOL]                 priority).build(); [EOL]         assertSame("Wrong thread", t, factory.newThread(r)); [EOL]         assertEquals("Wrong priority", priority, t.getPriority()); [EOL]         EasyMock.verify(wrapped, r); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether the original priority is not changed if no priority is [EOL]      * specified. [EOL]      */ [EOL]
@Test [EOL]     public void testNewThreadExHandler() { [EOL]         final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class); [EOL]         final Runnable r = EasyMock.createMock(Runnable.class); [EOL]         final Thread.UncaughtExceptionHandler handler = EasyMock [EOL]                 .createMock(Thread.UncaughtExceptionHandler.class); [EOL]         final Thread t = new Thread(); [EOL]         EasyMock.expect(wrapped.newThread(r)).andReturn(t); [EOL]         EasyMock.replay(wrapped, r, handler); [EOL]         final BasicThreadFactory factory = builder.wrappedFactory(wrapped) [EOL]                 .uncaughtExceptionHandler(handler).build(); [EOL]         assertSame("Wrong thread", t, factory.newThread(r)); [EOL]         assertEquals("Wrong exception handler", handler, t [EOL]                 .getUncaughtExceptionHandler()); [EOL]         EasyMock.verify(wrapped, r, handler); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether the original exception hander is not touched if none is [EOL]      * specified. [EOL]      */ [EOL]
@Test [EOL]     public void testNewThreadDaemonFalse() { [EOL]         checkDaemonFlag(false); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether the daemon flag is not touched on newly created threads if [EOL]      * it is not specified. [EOL]      */ [EOL]
@Test [EOL]     public void testNewThreadExHandler() { [EOL]         final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class); [EOL]         final Runnable r = EasyMock.createMock(Runnable.class); [EOL]         final Thread.UncaughtExceptionHandler handler = EasyMock [EOL]                 .createMock(Thread.UncaughtExceptionHandler.class); [EOL]         final Thread t = new Thread(); [EOL]         EasyMock.expect(wrapped.newThread(r)).andReturn(t); [EOL]         EasyMock.replay(wrapped, r, handler); [EOL]         final BasicThreadFactory factory = builder.wrappedFactory(wrapped) [EOL]                 .uncaughtExceptionHandler(handler).build(); [EOL]         assertSame("Wrong thread", t, factory.newThread(r)); [EOL]         assertEquals("Wrong exception handler", handler, t [EOL]                 .getUncaughtExceptionHandler()); [EOL]         EasyMock.verify(wrapped, r, handler); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether the original exception hander is not touched if none is [EOL]      * specified. [EOL]      */ [EOL]
@Test [EOL]     public void testNewThreadExHandler() { [EOL]         final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class); [EOL]         final Runnable r = EasyMock.createMock(Runnable.class); [EOL]         final Thread.UncaughtExceptionHandler handler = EasyMock [EOL]                 .createMock(Thread.UncaughtExceptionHandler.class); [EOL]         final Thread t = new Thread(); [EOL]         EasyMock.expect(wrapped.newThread(r)).andReturn(t); [EOL]         EasyMock.replay(wrapped, r, handler); [EOL]         final BasicThreadFactory factory = builder.wrappedFactory(wrapped) [EOL]                 .uncaughtExceptionHandler(handler).build(); [EOL]         assertSame("Wrong thread", t, factory.newThread(r)); [EOL]         assertEquals("Wrong exception handler", handler, t [EOL]                 .getUncaughtExceptionHandler()); [EOL]         EasyMock.verify(wrapped, r, handler); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether the original exception hander is not touched if none is [EOL]      * specified. [EOL]      */ [EOL]
@Test(expected = NullPointerException.class) [EOL]     public void testBuildWrappedFactoryNull() { [EOL]         builder.wrappedFactory(null); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tries to set a null exception handler. [EOL]      */ [EOL]
@Test [EOL]     public void testNewThreadExHandler() { [EOL]         final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class); [EOL]         final Runnable r = EasyMock.createMock(Runnable.class); [EOL]         final Thread.UncaughtExceptionHandler handler = EasyMock [EOL]                 .createMock(Thread.UncaughtExceptionHandler.class); [EOL]         final Thread t = new Thread(); [EOL]         EasyMock.expect(wrapped.newThread(r)).andReturn(t); [EOL]         EasyMock.replay(wrapped, r, handler); [EOL]         final BasicThreadFactory factory = builder.wrappedFactory(wrapped) [EOL]                 .uncaughtExceptionHandler(handler).build(); [EOL]         assertSame("Wrong thread", t, factory.newThread(r)); [EOL]         assertEquals("Wrong exception handler", handler, t [EOL]                 .getUncaughtExceptionHandler()); [EOL]         EasyMock.verify(wrapped, r, handler); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether the original exception hander is not touched if none is [EOL]      * specified. [EOL]      */ [EOL]
@Test [EOL]     public void testNewThreadExHandler() { [EOL]         final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class); [EOL]         final Runnable r = EasyMock.createMock(Runnable.class); [EOL]         final Thread.UncaughtExceptionHandler handler = EasyMock [EOL]                 .createMock(Thread.UncaughtExceptionHandler.class); [EOL]         final Thread t = new Thread(); [EOL]         EasyMock.expect(wrapped.newThread(r)).andReturn(t); [EOL]         EasyMock.replay(wrapped, r, handler); [EOL]         final BasicThreadFactory factory = builder.wrappedFactory(wrapped) [EOL]                 .uncaughtExceptionHandler(handler).build(); [EOL]         assertSame("Wrong thread", t, factory.newThread(r)); [EOL]         assertEquals("Wrong exception handler", handler, t [EOL]                 .getUncaughtExceptionHandler()); [EOL]         EasyMock.verify(wrapped, r, handler); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether the original exception hander is not touched if none is [EOL]      * specified. [EOL]      */ [EOL]
@Test [EOL]     public void testNewThreadNamingPattern() { [EOL]         final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class); [EOL]         final Runnable r = EasyMock.createMock(Runnable.class); [EOL]         final int count = 12; [EOL]         for (int i = 0; i < count; i++) { [EOL]             EasyMock.expect(wrapped.newThread(r)).andReturn(new Thread()); [EOL]         } [EOL]         EasyMock.replay(wrapped, r); [EOL]         final BasicThreadFactory factory = builder.wrappedFactory(wrapped) [EOL]                 .namingPattern(PATTERN).build(); [EOL]         for (int i = 0; i < count; i++) { [EOL]             final Thread t = factory.newThread(r); [EOL]             assertEquals("Wrong thread name", String.format(PATTERN, Long [EOL]                     .valueOf(i + 1)), t.getName()); [EOL]             assertEquals("Wrong thread count", i + 1, factory.getThreadCount()); [EOL]         } [EOL]         EasyMock.verify(wrapped, r); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether the thread name is not modified if no naming pattern is [EOL]      * set. [EOL]      */ [EOL]
@Test [EOL]     public void testNewThreadNamingPattern() { [EOL]         final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class); [EOL]         final Runnable r = EasyMock.createMock(Runnable.class); [EOL]         final int count = 12; [EOL]         for (int i = 0; i < count; i++) { [EOL]             EasyMock.expect(wrapped.newThread(r)).andReturn(new Thread()); [EOL]         } [EOL]         EasyMock.replay(wrapped, r); [EOL]         final BasicThreadFactory factory = builder.wrappedFactory(wrapped) [EOL]                 .namingPattern(PATTERN).build(); [EOL]         for (int i = 0; i < count; i++) { [EOL]             final Thread t = factory.newThread(r); [EOL]             assertEquals("Wrong thread name", String.format(PATTERN, Long [EOL]                     .valueOf(i + 1)), t.getName()); [EOL]             assertEquals("Wrong thread count", i + 1, factory.getThreadCount()); [EOL]         } [EOL]         EasyMock.verify(wrapped, r); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether the thread name is not modified if no naming pattern is [EOL]      * set. [EOL]      */ [EOL]
@Test(expected = NullPointerException.class) [EOL]     public void testBuildNamingPatternNull() { [EOL]         builder.namingPattern(null); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tries to set a null wrapped factory. [EOL]      */ [EOL]
@Test [EOL]     public void testNewThreadNamingPattern() { [EOL]         final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class); [EOL]         final Runnable r = EasyMock.createMock(Runnable.class); [EOL]         final int count = 12; [EOL]         for (int i = 0; i < count; i++) { [EOL]             EasyMock.expect(wrapped.newThread(r)).andReturn(new Thread()); [EOL]         } [EOL]         EasyMock.replay(wrapped, r); [EOL]         final BasicThreadFactory factory = builder.wrappedFactory(wrapped) [EOL]                 .namingPattern(PATTERN).build(); [EOL]         for (int i = 0; i < count; i++) { [EOL]             final Thread t = factory.newThread(r); [EOL]             assertEquals("Wrong thread name", String.format(PATTERN, Long [EOL]                     .valueOf(i + 1)), t.getName()); [EOL]             assertEquals("Wrong thread count", i + 1, factory.getThreadCount()); [EOL]         } [EOL]         EasyMock.verify(wrapped, r); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether the thread name is not modified if no naming pattern is [EOL]      * set. [EOL]      */ [EOL]
@Test [EOL]     public void testNewThreadNamingPattern() { [EOL]         final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class); [EOL]         final Runnable r = EasyMock.createMock(Runnable.class); [EOL]         final int count = 12; [EOL]         for (int i = 0; i < count; i++) { [EOL]             EasyMock.expect(wrapped.newThread(r)).andReturn(new Thread()); [EOL]         } [EOL]         EasyMock.replay(wrapped, r); [EOL]         final BasicThreadFactory factory = builder.wrappedFactory(wrapped) [EOL]                 .namingPattern(PATTERN).build(); [EOL]         for (int i = 0; i < count; i++) { [EOL]             final Thread t = factory.newThread(r); [EOL]             assertEquals("Wrong thread name", String.format(PATTERN, Long [EOL]                     .valueOf(i + 1)), t.getName()); [EOL]             assertEquals("Wrong thread count", i + 1, factory.getThreadCount()); [EOL]         } [EOL]         EasyMock.verify(wrapped, r); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether the thread name is not modified if no naming pattern is [EOL]      * set. [EOL]      */ [EOL]
@Test [EOL]     public void testBuilderReset() { [EOL]         final ThreadFactory wrappedFactory = EasyMock.createMock(ThreadFactory.class); [EOL]         final Thread.UncaughtExceptionHandler exHandler = EasyMock [EOL]                 .createMock(Thread.UncaughtExceptionHandler.class); [EOL]         EasyMock.replay(wrappedFactory, exHandler); [EOL]         builder.namingPattern(PATTERN).daemon(true).priority( [EOL]                 Thread.MAX_PRIORITY).uncaughtExceptionHandler(exHandler) [EOL]                 .wrappedFactory(wrappedFactory); [EOL]         builder.reset(); [EOL]         final BasicThreadFactory factory = builder.build(); [EOL]         checkFactoryDefaults(factory); [EOL]         assertNotSame("Wrapped factory not reset", wrappedFactory, factory [EOL]                 .getWrappedFactory()); [EOL]         EasyMock.verify(wrappedFactory, exHandler); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether reset() is automatically called after build(). [EOL]      */ [EOL]
@Test [EOL]     public void testBuilderReset() { [EOL]         final ThreadFactory wrappedFactory = EasyMock.createMock(ThreadFactory.class); [EOL]         final Thread.UncaughtExceptionHandler exHandler = EasyMock [EOL]                 .createMock(Thread.UncaughtExceptionHandler.class); [EOL]         EasyMock.replay(wrappedFactory, exHandler); [EOL]         builder.namingPattern(PATTERN).daemon(true).priority( [EOL]                 Thread.MAX_PRIORITY).uncaughtExceptionHandler(exHandler) [EOL]                 .wrappedFactory(wrappedFactory); [EOL]         builder.reset(); [EOL]         final BasicThreadFactory factory = builder.build(); [EOL]         checkFactoryDefaults(factory); [EOL]         assertNotSame("Wrapped factory not reset", wrappedFactory, factory [EOL]                 .getWrappedFactory()); [EOL]         EasyMock.verify(wrappedFactory, exHandler); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether reset() is automatically called after build(). [EOL]      */ [EOL]
@Test [EOL]     public void testBuilderReset() { [EOL]         final ThreadFactory wrappedFactory = EasyMock.createMock(ThreadFactory.class); [EOL]         final Thread.UncaughtExceptionHandler exHandler = EasyMock [EOL]                 .createMock(Thread.UncaughtExceptionHandler.class); [EOL]         EasyMock.replay(wrappedFactory, exHandler); [EOL]         builder.namingPattern(PATTERN).daemon(true).priority( [EOL]                 Thread.MAX_PRIORITY).uncaughtExceptionHandler(exHandler) [EOL]                 .wrappedFactory(wrappedFactory); [EOL]         builder.reset(); [EOL]         final BasicThreadFactory factory = builder.build(); [EOL]         checkFactoryDefaults(factory); [EOL]         assertNotSame("Wrapped factory not reset", wrappedFactory, factory [EOL]                 .getWrappedFactory()); [EOL]         EasyMock.verify(wrappedFactory, exHandler); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether reset() is automatically called after build(). [EOL]      */ [EOL]
@Test [EOL]     public void testBuilderReset() { [EOL]         final ThreadFactory wrappedFactory = EasyMock.createMock(ThreadFactory.class); [EOL]         final Thread.UncaughtExceptionHandler exHandler = EasyMock [EOL]                 .createMock(Thread.UncaughtExceptionHandler.class); [EOL]         EasyMock.replay(wrappedFactory, exHandler); [EOL]         builder.namingPattern(PATTERN).daemon(true).priority( [EOL]                 Thread.MAX_PRIORITY).uncaughtExceptionHandler(exHandler) [EOL]                 .wrappedFactory(wrappedFactory); [EOL]         builder.reset(); [EOL]         final BasicThreadFactory factory = builder.build(); [EOL]         checkFactoryDefaults(factory); [EOL]         assertNotSame("Wrapped factory not reset", wrappedFactory, factory [EOL]                 .getWrappedFactory()); [EOL]         EasyMock.verify(wrappedFactory, exHandler); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether reset() is automatically called after build(). [EOL]      */ [EOL]
@Test [EOL]     public void testBuilderReset() { [EOL]         final ThreadFactory wrappedFactory = EasyMock.createMock(ThreadFactory.class); [EOL]         final Thread.UncaughtExceptionHandler exHandler = EasyMock [EOL]                 .createMock(Thread.UncaughtExceptionHandler.class); [EOL]         EasyMock.replay(wrappedFactory, exHandler); [EOL]         builder.namingPattern(PATTERN).daemon(true).priority( [EOL]                 Thread.MAX_PRIORITY).uncaughtExceptionHandler(exHandler) [EOL]                 .wrappedFactory(wrappedFactory); [EOL]         builder.reset(); [EOL]         final BasicThreadFactory factory = builder.build(); [EOL]         checkFactoryDefaults(factory); [EOL]         assertNotSame("Wrapped factory not reset", wrappedFactory, factory [EOL]                 .getWrappedFactory()); [EOL]         EasyMock.verify(wrappedFactory, exHandler); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether reset() is automatically called after build(). [EOL]      */ [EOL]
@Test [EOL]     public void testBuilderReset() { [EOL]         final ThreadFactory wrappedFactory = EasyMock.createMock(ThreadFactory.class); [EOL]         final Thread.UncaughtExceptionHandler exHandler = EasyMock [EOL]                 .createMock(Thread.UncaughtExceptionHandler.class); [EOL]         EasyMock.replay(wrappedFactory, exHandler); [EOL]         builder.namingPattern(PATTERN).daemon(true).priority( [EOL]                 Thread.MAX_PRIORITY).uncaughtExceptionHandler(exHandler) [EOL]                 .wrappedFactory(wrappedFactory); [EOL]         builder.reset(); [EOL]         final BasicThreadFactory factory = builder.build(); [EOL]         checkFactoryDefaults(factory); [EOL]         assertNotSame("Wrapped factory not reset", wrappedFactory, factory [EOL]                 .getWrappedFactory()); [EOL]         EasyMock.verify(wrappedFactory, exHandler); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether reset() is automatically called after build(). [EOL]      */ [EOL]
@Test [EOL]     public void testNewThreadExHandler() { [EOL]         final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class); [EOL]         final Runnable r = EasyMock.createMock(Runnable.class); [EOL]         final Thread.UncaughtExceptionHandler handler = EasyMock [EOL]                 .createMock(Thread.UncaughtExceptionHandler.class); [EOL]         final Thread t = new Thread(); [EOL]         EasyMock.expect(wrapped.newThread(r)).andReturn(t); [EOL]         EasyMock.replay(wrapped, r, handler); [EOL]         final BasicThreadFactory factory = builder.wrappedFactory(wrapped) [EOL]                 .uncaughtExceptionHandler(handler).build(); [EOL]         assertSame("Wrong thread", t, factory.newThread(r)); [EOL]         assertEquals("Wrong exception handler", handler, t [EOL]                 .getUncaughtExceptionHandler()); [EOL]         EasyMock.verify(wrapped, r, handler); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether the original exception hander is not touched if none is [EOL]      * specified. [EOL]      */ [EOL]
@Test [EOL]     public void testNewThreadExHandler() { [EOL]         final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class); [EOL]         final Runnable r = EasyMock.createMock(Runnable.class); [EOL]         final Thread.UncaughtExceptionHandler handler = EasyMock [EOL]                 .createMock(Thread.UncaughtExceptionHandler.class); [EOL]         final Thread t = new Thread(); [EOL]         EasyMock.expect(wrapped.newThread(r)).andReturn(t); [EOL]         EasyMock.replay(wrapped, r, handler); [EOL]         final BasicThreadFactory factory = builder.wrappedFactory(wrapped) [EOL]                 .uncaughtExceptionHandler(handler).build(); [EOL]         assertSame("Wrong thread", t, factory.newThread(r)); [EOL]         assertEquals("Wrong exception handler", handler, t [EOL]                 .getUncaughtExceptionHandler()); [EOL]         EasyMock.verify(wrapped, r, handler); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether the original exception hander is not touched if none is [EOL]      * specified. [EOL]      */ [EOL]
@Test(expected = NullPointerException.class) [EOL]     public void testBuildUncaughtExceptionHandlerNull() { [EOL]         builder.uncaughtExceptionHandler(null); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the reset() method of the builder. [EOL]      */ [EOL]
@Test [EOL]     public void testNewThreadExHandler() { [EOL]         final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class); [EOL]         final Runnable r = EasyMock.createMock(Runnable.class); [EOL]         final Thread.UncaughtExceptionHandler handler = EasyMock [EOL]                 .createMock(Thread.UncaughtExceptionHandler.class); [EOL]         final Thread t = new Thread(); [EOL]         EasyMock.expect(wrapped.newThread(r)).andReturn(t); [EOL]         EasyMock.replay(wrapped, r, handler); [EOL]         final BasicThreadFactory factory = builder.wrappedFactory(wrapped) [EOL]                 .uncaughtExceptionHandler(handler).build(); [EOL]         assertSame("Wrong thread", t, factory.newThread(r)); [EOL]         assertEquals("Wrong exception handler", handler, t [EOL]                 .getUncaughtExceptionHandler()); [EOL]         EasyMock.verify(wrapped, r, handler); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether the original exception hander is not touched if none is [EOL]      * specified. [EOL]      */ [EOL]
@Test [EOL]     public void testNewThreadExHandler() { [EOL]         final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class); [EOL]         final Runnable r = EasyMock.createMock(Runnable.class); [EOL]         final Thread.UncaughtExceptionHandler handler = EasyMock [EOL]                 .createMock(Thread.UncaughtExceptionHandler.class); [EOL]         final Thread t = new Thread(); [EOL]         EasyMock.expect(wrapped.newThread(r)).andReturn(t); [EOL]         EasyMock.replay(wrapped, r, handler); [EOL]         final BasicThreadFactory factory = builder.wrappedFactory(wrapped) [EOL]                 .uncaughtExceptionHandler(handler).build(); [EOL]         assertSame("Wrong thread", t, factory.newThread(r)); [EOL]         assertEquals("Wrong exception handler", handler, t [EOL]                 .getUncaughtExceptionHandler()); [EOL]         EasyMock.verify(wrapped, r, handler); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether the original exception hander is not touched if none is [EOL]      * specified. [EOL]      */ [EOL]
@Test [EOL]     public void testNewThreadExHandler() { [EOL]         final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class); [EOL]         final Runnable r = EasyMock.createMock(Runnable.class); [EOL]         final Thread.UncaughtExceptionHandler handler = EasyMock [EOL]                 .createMock(Thread.UncaughtExceptionHandler.class); [EOL]         final Thread t = new Thread(); [EOL]         EasyMock.expect(wrapped.newThread(r)).andReturn(t); [EOL]         EasyMock.replay(wrapped, r, handler); [EOL]         final BasicThreadFactory factory = builder.wrappedFactory(wrapped) [EOL]                 .uncaughtExceptionHandler(handler).build(); [EOL]         assertSame("Wrong thread", t, factory.newThread(r)); [EOL]         assertEquals("Wrong exception handler", handler, t [EOL]                 .getUncaughtExceptionHandler()); [EOL]         EasyMock.verify(wrapped, r, handler); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether the original exception hander is not touched if none is [EOL]      * specified. [EOL]      */ [EOL]
@Test [EOL]     public void testNewThreadExHandler() { [EOL]         final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class); [EOL]         final Runnable r = EasyMock.createMock(Runnable.class); [EOL]         final Thread.UncaughtExceptionHandler handler = EasyMock [EOL]                 .createMock(Thread.UncaughtExceptionHandler.class); [EOL]         final Thread t = new Thread(); [EOL]         EasyMock.expect(wrapped.newThread(r)).andReturn(t); [EOL]         EasyMock.replay(wrapped, r, handler); [EOL]         final BasicThreadFactory factory = builder.wrappedFactory(wrapped) [EOL]                 .uncaughtExceptionHandler(handler).build(); [EOL]         assertSame("Wrong thread", t, factory.newThread(r)); [EOL]         assertEquals("Wrong exception handler", handler, t [EOL]                 .getUncaughtExceptionHandler()); [EOL]         EasyMock.verify(wrapped, r, handler); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether the original exception hander is not touched if none is [EOL]      * specified. [EOL]      */ [EOL]
@Test [EOL]     public void testNewThreadExHandler() { [EOL]         final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class); [EOL]         final Runnable r = EasyMock.createMock(Runnable.class); [EOL]         final Thread.UncaughtExceptionHandler handler = EasyMock [EOL]                 .createMock(Thread.UncaughtExceptionHandler.class); [EOL]         final Thread t = new Thread(); [EOL]         EasyMock.expect(wrapped.newThread(r)).andReturn(t); [EOL]         EasyMock.replay(wrapped, r, handler); [EOL]         final BasicThreadFactory factory = builder.wrappedFactory(wrapped) [EOL]                 .uncaughtExceptionHandler(handler).build(); [EOL]         assertSame("Wrong thread", t, factory.newThread(r)); [EOL]         assertEquals("Wrong exception handler", handler, t [EOL]                 .getUncaughtExceptionHandler()); [EOL]         EasyMock.verify(wrapped, r, handler); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether the original exception hander is not touched if none is [EOL]      * specified. [EOL]      */ [EOL]
@Test [EOL]     public void testNewThreadExHandler() { [EOL]         final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class); [EOL]         final Runnable r = EasyMock.createMock(Runnable.class); [EOL]         final Thread.UncaughtExceptionHandler handler = EasyMock [EOL]                 .createMock(Thread.UncaughtExceptionHandler.class); [EOL]         final Thread t = new Thread(); [EOL]         EasyMock.expect(wrapped.newThread(r)).andReturn(t); [EOL]         EasyMock.replay(wrapped, r, handler); [EOL]         final BasicThreadFactory factory = builder.wrappedFactory(wrapped) [EOL]                 .uncaughtExceptionHandler(handler).build(); [EOL]         assertSame("Wrong thread", t, factory.newThread(r)); [EOL]         assertEquals("Wrong exception handler", handler, t [EOL]                 .getUncaughtExceptionHandler()); [EOL]         EasyMock.verify(wrapped, r, handler); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether the original exception hander is not touched if none is [EOL]      * specified. [EOL]      */ [EOL]
@Test [EOL]     public void testNewThreadExHandler() { [EOL]         final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class); [EOL]         final Runnable r = EasyMock.createMock(Runnable.class); [EOL]         final Thread.UncaughtExceptionHandler handler = EasyMock [EOL]                 .createMock(Thread.UncaughtExceptionHandler.class); [EOL]         final Thread t = new Thread(); [EOL]         EasyMock.expect(wrapped.newThread(r)).andReturn(t); [EOL]         EasyMock.replay(wrapped, r, handler); [EOL]         final BasicThreadFactory factory = builder.wrappedFactory(wrapped) [EOL]                 .uncaughtExceptionHandler(handler).build(); [EOL]         assertSame("Wrong thread", t, factory.newThread(r)); [EOL]         assertEquals("Wrong exception handler", handler, t [EOL]                 .getUncaughtExceptionHandler()); [EOL]         EasyMock.verify(wrapped, r, handler); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether the original exception hander is not touched if none is [EOL]      * specified. [EOL]      */ [EOL]
@Test [EOL]     public void testNewThreadExHandler() { [EOL]         final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class); [EOL]         final Runnable r = EasyMock.createMock(Runnable.class); [EOL]         final Thread.UncaughtExceptionHandler handler = EasyMock [EOL]                 .createMock(Thread.UncaughtExceptionHandler.class); [EOL]         final Thread t = new Thread(); [EOL]         EasyMock.expect(wrapped.newThread(r)).andReturn(t); [EOL]         EasyMock.replay(wrapped, r, handler); [EOL]         final BasicThreadFactory factory = builder.wrappedFactory(wrapped) [EOL]                 .uncaughtExceptionHandler(handler).build(); [EOL]         assertSame("Wrong thread", t, factory.newThread(r)); [EOL]         assertEquals("Wrong exception handler", handler, t [EOL]                 .getUncaughtExceptionHandler()); [EOL]         EasyMock.verify(wrapped, r, handler); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether the original exception hander is not touched if none is [EOL]      * specified. [EOL]      */ [EOL]
@Test [EOL]     public void testNewThreadExHandler() { [EOL]         final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class); [EOL]         final Runnable r = EasyMock.createMock(Runnable.class); [EOL]         final Thread.UncaughtExceptionHandler handler = EasyMock [EOL]                 .createMock(Thread.UncaughtExceptionHandler.class); [EOL]         final Thread t = new Thread(); [EOL]         EasyMock.expect(wrapped.newThread(r)).andReturn(t); [EOL]         EasyMock.replay(wrapped, r, handler); [EOL]         final BasicThreadFactory factory = builder.wrappedFactory(wrapped) [EOL]                 .uncaughtExceptionHandler(handler).build(); [EOL]         assertSame("Wrong thread", t, factory.newThread(r)); [EOL]         assertEquals("Wrong exception handler", handler, t [EOL]                 .getUncaughtExceptionHandler()); [EOL]         EasyMock.verify(wrapped, r, handler); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether the original exception hander is not touched if none is [EOL]      * specified. [EOL]      */ [EOL]
@Test [EOL]     public void testNewThreadExHandler() { [EOL]         final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class); [EOL]         final Runnable r = EasyMock.createMock(Runnable.class); [EOL]         final Thread.UncaughtExceptionHandler handler = EasyMock [EOL]                 .createMock(Thread.UncaughtExceptionHandler.class); [EOL]         final Thread t = new Thread(); [EOL]         EasyMock.expect(wrapped.newThread(r)).andReturn(t); [EOL]         EasyMock.replay(wrapped, r, handler); [EOL]         final BasicThreadFactory factory = builder.wrappedFactory(wrapped) [EOL]                 .uncaughtExceptionHandler(handler).build(); [EOL]         assertSame("Wrong thread", t, factory.newThread(r)); [EOL]         assertEquals("Wrong exception handler", handler, t [EOL]                 .getUncaughtExceptionHandler()); [EOL]         EasyMock.verify(wrapped, r, handler); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether the original exception hander is not touched if none is [EOL]      * specified. [EOL]      */ [EOL]
@Test [EOL]     public void testNewThreadExHandler() { [EOL]         final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class); [EOL]         final Runnable r = EasyMock.createMock(Runnable.class); [EOL]         final Thread.UncaughtExceptionHandler handler = EasyMock [EOL]                 .createMock(Thread.UncaughtExceptionHandler.class); [EOL]         final Thread t = new Thread(); [EOL]         EasyMock.expect(wrapped.newThread(r)).andReturn(t); [EOL]         EasyMock.replay(wrapped, r, handler); [EOL]         final BasicThreadFactory factory = builder.wrappedFactory(wrapped) [EOL]                 .uncaughtExceptionHandler(handler).build(); [EOL]         assertSame("Wrong thread", t, factory.newThread(r)); [EOL]         assertEquals("Wrong exception handler", handler, t [EOL]                 .getUncaughtExceptionHandler()); [EOL]         EasyMock.verify(wrapped, r, handler); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether the original exception hander is not touched if none is [EOL]      * specified. [EOL]      */ [EOL]
@Test [EOL]     public void testNewThreadExHandler() { [EOL]         final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class); [EOL]         final Runnable r = EasyMock.createMock(Runnable.class); [EOL]         final Thread.UncaughtExceptionHandler handler = EasyMock [EOL]                 .createMock(Thread.UncaughtExceptionHandler.class); [EOL]         final Thread t = new Thread(); [EOL]         EasyMock.expect(wrapped.newThread(r)).andReturn(t); [EOL]         EasyMock.replay(wrapped, r, handler); [EOL]         final BasicThreadFactory factory = builder.wrappedFactory(wrapped) [EOL]                 .uncaughtExceptionHandler(handler).build(); [EOL]         assertSame("Wrong thread", t, factory.newThread(r)); [EOL]         assertEquals("Wrong exception handler", handler, t [EOL]                 .getUncaughtExceptionHandler()); [EOL]         EasyMock.verify(wrapped, r, handler); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether the original exception hander is not touched if none is [EOL]      * specified. [EOL]      */ [EOL]
